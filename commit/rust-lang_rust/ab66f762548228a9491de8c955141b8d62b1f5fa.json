{"sha": "ab66f762548228a9491de8c955141b8d62b1f5fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNjZmNzYyNTQ4MjI4YTk0OTFkZThjOTU1MTQxYjhkNjJiMWY1ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-13T22:51:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-13T22:51:34Z"}, "message": "auto merge of #11305 : pcwalton/rust/at-patterns, r=pcwalton\n\nr? @nikomatsakis", "tree": {"sha": "2b76b1f678c32810864186007c41fe900cd6ca58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b76b1f678c32810864186007c41fe900cd6ca58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab66f762548228a9491de8c955141b8d62b1f5fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab66f762548228a9491de8c955141b8d62b1f5fa", "html_url": "https://github.com/rust-lang/rust/commit/ab66f762548228a9491de8c955141b8d62b1f5fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab66f762548228a9491de8c955141b8d62b1f5fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "480b0f481390683e1ac9bf9f762dcefb5325190d", "url": "https://api.github.com/repos/rust-lang/rust/commits/480b0f481390683e1ac9bf9f762dcefb5325190d", "html_url": "https://github.com/rust-lang/rust/commit/480b0f481390683e1ac9bf9f762dcefb5325190d"}, {"sha": "119c6141f568b8b5bca141b24d3cbd3e1aacb2c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/119c6141f568b8b5bca141b24d3cbd3e1aacb2c7", "html_url": "https://github.com/rust-lang/rust/commit/119c6141f568b8b5bca141b24d3cbd3e1aacb2c7"}], "stats": {"total": 2062, "additions": 1025, "deletions": 1037}, "files": [{"sha": "ac0f64acca9ad03b26cd4665963b294de3c15f79", "filename": "doc/rust.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -2865,19 +2865,19 @@ In a pattern whose head expression has an `enum` type, a placeholder (`_`) stand\n variant. For example:\n \n ~~~~\n-enum List<X> { Nil, Cons(X, @List<X>) }\n+enum List<X> { Nil, Cons(X, ~List<X>) }\n \n-let x: List<int> = Cons(10, @Cons(11, @Nil));\n+let x: List<int> = Cons(10, ~Cons(11, ~Nil));\n \n match x {\n-    Cons(_, @Nil) => fail!(\"singleton list\"),\n+    Cons(_, ~Nil) => fail!(\"singleton list\"),\n     Cons(..)      => return,\n     Nil           => fail!(\"empty list\")\n }\n ~~~~\n \n The first pattern matches lists constructed by applying `Cons` to any head value, and a\n-tail value of `@Nil`. The second pattern matches _any_ list constructed with `Cons`,\n+tail value of `~Nil`. The second pattern matches _any_ list constructed with `Cons`,\n ignoring the values of its arguments. The difference between `_` and `*` is that the pattern `C(_)` is only type-correct if\n `C` has exactly one argument, while the pattern `C(..)` is type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n \n@@ -2893,12 +2893,12 @@ An example of an `match` expression:\n # fn process_pair(a: int, b: int) { }\n # fn process_ten() { }\n \n-enum List<X> { Nil, Cons(X, @List<X>) }\n+enum List<X> { Nil, Cons(X, ~List<X>) }\n \n-let x: List<int> = Cons(10, @Cons(11, @Nil));\n+let x: List<int> = Cons(10, ~Cons(11, ~Nil));\n \n match x {\n-    Cons(a, @Cons(b, _)) => {\n+    Cons(a, ~Cons(b, _)) => {\n         process_pair(a,b);\n     }\n     Cons(10, _) => {"}, {"sha": "f87c05ddab8a9807c3b2c6fce57c44a779f5c06e", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -201,7 +201,7 @@ fn method_in_cfg(cx: &Context, meth: &ast::Method) -> bool {\n fn trait_method_in_cfg(cx: &Context, meth: &ast::TraitMethod) -> bool {\n     match *meth {\n         ast::Required(ref meth) => (cx.in_cfg)(meth.attrs),\n-        ast::Provided(@ref meth) => (cx.in_cfg)(meth.attrs)\n+        ast::Provided(meth) => (cx.in_cfg)(meth.attrs)\n     }\n }\n "}, {"sha": "6a37324e05a69d9c039e63d809fec1bef1a787eb", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -308,15 +308,13 @@ impl Folder for NestedItemsDropper {\n     fn fold_block(&mut self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n             match stmt.node {\n-                ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n-                ast::StmtDecl(@codemap::Spanned {\n-                    node: ast::DeclLocal(_),\n-                    span: _\n-                }, _) => Some(*stmt),\n-                ast::StmtDecl(@codemap::Spanned {\n-                    node: ast::DeclItem(_),\n-                    span: _\n-                }, _) => None,\n+                ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => Some(*stmt),\n+                ast::StmtDecl(decl, _) => {\n+                    match decl.node {\n+                        ast::DeclLocal(_) => Some(*stmt),\n+                        ast::DeclItem(_) => None,\n+                    }\n+                }\n                 ast::StmtMac(..) => fail!(\"unexpanded macro in astencode\")\n             }\n         }).collect();"}, {"sha": "527d74f8a862fff3a02d4e576eeccb743157faf2", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -101,7 +101,6 @@ impl CFGBuilder {\n                 self.add_node(pat.id, [pred])\n             }\n \n-            ast::PatBox(subpat) |\n             ast::PatUniq(subpat) |\n             ast::PatRegion(subpat) |\n             ast::PatIdent(_, _, Some(subpat)) => {"}, {"sha": "e13f6f8c537c902d5848818c0140048b63b06618", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -16,7 +16,6 @@ use middle::typeck;\n use util::ppaux;\n \n use syntax::ast::*;\n-use syntax::codemap;\n use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -84,14 +83,13 @@ pub fn check_item(v: &mut CheckCrateVisitor,\n pub fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n     fn is_str(e: @Expr) -> bool {\n         match e.node {\n-            ExprVstore(\n-                @Expr { node: ExprLit(@codemap::Spanned {\n-                    node: LitStr(..),\n-                    ..}),\n-                       .. },\n-                ExprVstoreUniq\n-            ) => true,\n-            _ => false\n+            ExprVstore(expr, ExprVstoreUniq) => {\n+                match expr.node {\n+                    ExprLit(lit) => ast_util::lit_is_str(lit),\n+                    _ => false,\n+                }\n+            }\n+            _ => false,\n         }\n     }\n     match p.node {\n@@ -120,7 +118,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                           \"cannot do allocations in constant expressions\");\n             return;\n           }\n-          ExprLit(@codemap::Spanned {node: LitStr(..), ..}) => { }\n+          ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n             let method_map = method_map.borrow();\n             if method_map.get().contains_key(&e.id) {"}, {"sha": "598f62ce03ff927aa9426eb8cfcb72c779a1142c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -23,7 +23,7 @@ use std::num;\n use std::vec;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n-use syntax::codemap::{Span, DUMMY_SP, Spanned};\n+use syntax::codemap::{DUMMY_SP, Span};\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n \n@@ -362,7 +362,7 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n           _ => Some(single)\n         }\n       }\n-      PatBox(_) | PatUniq(_) | PatTup(_) | PatRegion(..) => {\n+      PatUniq(_) | PatTup(_) | PatRegion(..) => {\n         Some(single)\n       }\n       PatVec(ref before, slice, ref after) => {\n@@ -735,7 +735,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 }\n             }\n             PatTup(args) => Some(vec::append(args, r.tail())),\n-            PatBox(a) | PatUniq(a) | PatRegion(a) => {\n+            PatUniq(a) | PatRegion(a) => {\n                 Some(vec::append(~[a], r.tail()))\n             }\n             PatLit(expr) => {\n@@ -874,16 +874,22 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n     }\n \n     match pat.node {\n-      PatBox(sub) | PatUniq(sub) | PatRegion(sub) |\n-      PatIdent(_, _, Some(sub)) => {\n+      PatUniq(sub) | PatRegion(sub) | PatIdent(_, _, Some(sub)) => {\n         is_refutable(cx, sub)\n       }\n       PatWild | PatWildMulti | PatIdent(_, _, None) => { false }\n-      PatLit(@Expr {node: ExprLit(@Spanned { node: LitNil, ..}), ..}) => {\n-        // \"()\"\n-        false\n+      PatLit(lit) => {\n+          match lit.node {\n+            ExprLit(lit) => {\n+                match lit.node {\n+                    LitNil => false,    // `()`\n+                    _ => true,\n+                }\n+            }\n+            _ => true,\n+          }\n       }\n-      PatLit(_) | PatRange(_, _) => { true }\n+      PatRange(_, _) => { true }\n       PatStruct(_, ref fields, _) => {\n         fields.iter().any(|f| is_refutable(cx, f.pat))\n       }"}, {"sha": "fde3e4809c39abb2d9c30b491fb74d0d182032f9", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -330,12 +330,18 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n     // Search for auto-adjustments to find trait coercions.\n     let adjustments = cx.tcx.adjustments.borrow();\n     match adjustments.get().find(&e.id) {\n-        Some(&@ty::AutoObject(..)) => {\n-            let source_ty = ty::expr_ty(cx.tcx, e);\n-            let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n-            check_trait_cast(cx, source_ty, target_ty, e.span);\n+        Some(adjustment) => {\n+            match **adjustment {\n+                ty::AutoObject(..) => {\n+                    let source_ty = ty::expr_ty(cx.tcx, e);\n+                    let target_ty = ty::expr_ty_adjusted(cx.tcx, e);\n+                    check_trait_cast(cx, source_ty, target_ty, e.span);\n+                }\n+                ty::AutoAddEnv(..) |\n+                ty::AutoDerefRef(..) => {}\n+            }\n         }\n-        Some(&@ty::AutoAddEnv(..)) | Some(&@ty::AutoDerefRef(..)) | None => {}\n+        None => {}\n     }\n \n     visit::walk_expr(cx, e, ());"}, {"sha": "6da58c03b7247e3ab54927544132e6b78b14e47e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -62,7 +62,6 @@ use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods, AttributeMethods};\n use syntax::codemap::Span;\n-use syntax::codemap;\n use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n use syntax::ast_util::IdVisitingOperation;\n@@ -590,11 +589,16 @@ fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n     match e.node {\n         ast::ExprWhile(cond, _) => {\n             match cond.node {\n-                ast::ExprLit(@codemap::Spanned {\n-                    node: ast::LitBool(true), ..}) =>\n-                {\n-                    cx.span_lint(WhileTrue, e.span,\n-                                 \"denote infinite loops with loop { ... }\");\n+                ast::ExprLit(lit) => {\n+                    match lit.node {\n+                        ast::LitBool(true) => {\n+                            cx.span_lint(WhileTrue,\n+                                         e.span,\n+                                         \"denote infinite loops with loop \\\n+                                          { ... }\");\n+                        }\n+                        _ => {}\n+                    }\n                 }\n                 _ => ()\n             }\n@@ -989,9 +993,15 @@ fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n \n fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n     match s.node {\n-        ast::StmtSemi(@ast::Expr { node: ast::ExprPath(_), .. }, _) => {\n-            cx.span_lint(PathStatement, s.span,\n-                         \"path statement with no effect\");\n+        ast::StmtSemi(expr, _) => {\n+            match expr.node {\n+                ast::ExprPath(_) => {\n+                    cx.span_lint(PathStatement,\n+                                 s.span,\n+                                 \"path statement with no effect\");\n+                }\n+                _ => {}\n+            }\n         }\n         _ => ()\n     }\n@@ -1132,7 +1142,9 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n         ast::ExprVstore(e2, ast::ExprVstoreUniq) |\n         ast::ExprVstore(e2, ast::ExprVstoreBox) => {\n             match e2.node {\n-                ast::ExprLit(@codemap::Spanned{node: ast::LitStr(..), ..}) |\n+                ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n+                    VectorAllocation\n+                }\n                 ast::ExprVec(..) => VectorAllocation,\n                 _ => return\n             }\n@@ -1152,18 +1164,27 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n         adjustments.get().find_copy(&e.id)\n     };\n     match adjustment {\n-        Some(@ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. })) => {\n-            match (allocation, autoref) {\n-                (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n-                    report(\"unnecessary allocation, the sigil can be removed\");\n-                }\n-                (BoxAllocation, Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n-                    report(\"unnecessary allocation, use & instead\");\n-                }\n-                (BoxAllocation, Some(ty::AutoPtr(_, ast::MutMutable))) => {\n-                    report(\"unnecessary allocation, use &mut instead\");\n+        Some(adjustment) => {\n+            match *adjustment {\n+                ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n+                    match (allocation, autoref) {\n+                        (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n+                            report(\"unnecessary allocation, the sigil can be \\\n+                                    removed\");\n+                        }\n+                        (BoxAllocation,\n+                         Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n+                            report(\"unnecessary allocation, use & instead\");\n+                        }\n+                        (BoxAllocation,\n+                         Some(ty::AutoPtr(_, ast::MutMutable))) => {\n+                            report(\"unnecessary allocation, use &mut \\\n+                                    instead\");\n+                        }\n+                        _ => ()\n+                    }\n                 }\n-                _ => ()\n+                _ => {}\n             }\n         }\n "}, {"sha": "c50d23ff592e8b0b014c69066679b03982153555", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -341,36 +341,39 @@ impl mem_categorization_ctxt {\n                 self.cat_expr_unadjusted(expr)\n             }\n \n-            Some(&@ty::AutoObject(..)) => {\n-                // Implicity casts a concrete object to trait object\n-                // Result is an rvalue\n-                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                self.cat_rvalue_node(expr, expr_ty)\n-            }\n+            Some(adjustment) => {\n+                match **adjustment {\n+                    ty::AutoObject(..) => {\n+                        // Implicity casts a concrete object to trait object\n+                        // Result is an rvalue\n+                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                        self.cat_rvalue_node(expr, expr_ty)\n+                    }\n \n-            Some(&@ty::AutoAddEnv(..)) => {\n-                // Convert a bare fn to a closure by adding NULL env.\n-                // Result is an rvalue.\n-                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                self.cat_rvalue_node(expr, expr_ty)\n-            }\n+                    ty::AutoAddEnv(..) => {\n+                        // Convert a bare fn to a closure by adding NULL env.\n+                        // Result is an rvalue.\n+                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                        self.cat_rvalue_node(expr, expr_ty)\n+                    }\n \n-            Some(\n-                &@ty::AutoDerefRef(\n-                    ty::AutoDerefRef {\n-                        autoref: Some(_), ..})) => {\n-                // Equivalent to &*expr or something similar.\n-                // Result is an rvalue.\n-                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                self.cat_rvalue_node(expr, expr_ty)\n-            }\n+                    ty::AutoDerefRef(ty::AutoDerefRef {\n+                        autoref: Some(_),\n+                    ..}) => {\n+                        // Equivalent to &*expr or something similar.\n+                        // Result is an rvalue.\n+                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                        self.cat_rvalue_node(expr, expr_ty)\n+                    }\n \n-            Some(\n-                &@ty::AutoDerefRef(\n-                    ty::AutoDerefRef {\n-                        autoref: None, autoderefs: autoderefs})) => {\n-                // Equivalent to *expr or something similar.\n-                self.cat_expr_autoderefd(expr, autoderefs)\n+                    ty::AutoDerefRef(ty::AutoDerefRef {\n+                            autoref: None,\n+                            autoderefs: autoderefs\n+                    }) => {\n+                        // Equivalent to *expr or something similar.\n+                        self.cat_expr_autoderefd(expr, autoderefs)\n+                    }\n+                }\n             }\n         }\n     }\n@@ -973,8 +976,7 @@ impl mem_categorization_ctxt {\n             }\n           }\n \n-          ast::PatBox(subpat) | ast::PatUniq(subpat) |\n-          ast::PatRegion(subpat) => {\n+          ast::PatUniq(subpat) | ast::PatRegion(subpat) => {\n             // @p1, ~p1\n             let subcmt = self.cat_deref(pat, cmt, 0);\n             self.cat_pattern(subcmt, subpat, op);"}, {"sha": "a6a9ff80c5b9f417a9714749603c7a7d56c50819", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -328,10 +328,16 @@ impl VisitContext {\n         let comp_mode = {\n             let adjustments = self.tcx.adjustments.borrow();\n             match adjustments.get().find(&expr.id) {\n-                Some(&@ty::AutoDerefRef(\n-                    ty::AutoDerefRef {\n-                        autoref: Some(_), ..})) => Read,\n-                _ => expr_mode\n+                Some(adjustment) => {\n+                    match **adjustment {\n+                        ty::AutoDerefRef(ty::AutoDerefRef {\n+                            autoref: Some(_),\n+                            ..\n+                        }) => Read,\n+                        _ => expr_mode,\n+                    }\n+                }\n+                _ => expr_mode,\n             }\n         };\n "}, {"sha": "ead67f78063617343a8b28cf2da3c87bbe750c56", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -102,10 +102,16 @@ impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n     fn visit_ty(&mut self, ty: &ast::Ty,\n                 scope: &'a ScopeChain<'a>) {\n         match ty.node {\n-            ast::TyClosure(@ast::ClosureTy { lifetimes: ref lifetimes, .. }) |\n-            ast::TyBareFn(@ast::BareFnTy { lifetimes: ref lifetimes, .. }) => {\n-                let scope1 = FnScope(ty.id, lifetimes, scope);\n-                self.check_lifetime_names(lifetimes);\n+            ast::TyClosure(closure) => {\n+                let scope1 = FnScope(ty.id, &closure.lifetimes, scope);\n+                self.check_lifetime_names(&closure.lifetimes);\n+                debug!(\"pushing fn scope id={} due to type\", ty.id);\n+                visit::walk_ty(self, ty, &scope1);\n+                debug!(\"popping fn scope id={} due to type\", ty.id);\n+            }\n+            ast::TyBareFn(bare_fn) => {\n+                let scope1 = FnScope(ty.id, &bare_fn.lifetimes, scope);\n+                self.check_lifetime_names(&bare_fn.lifetimes);\n                 debug!(\"pushing fn scope id={} due to type\", ty.id);\n                 visit::walk_ty(self, ty, &scope1);\n                 debug!(\"popping fn scope id={} due to type\", ty.id);"}, {"sha": "89442d0cc848b9580df4d408dc656b06bad9943a", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -100,7 +100,7 @@ impl<T:Subst> Subst for OptVec<T> {\n impl<T:Subst + 'static> Subst for @T {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> @T {\n         match self {\n-            &@ref t => @t.subst(tcx, substs)\n+            t => @(**t).subst(tcx, substs)\n         }\n     }\n }"}, {"sha": "aa2bd656b909168e3edf4beadbf28e6220f66519", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 61, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -838,34 +838,6 @@ fn enter_tuple_struct<'r,'b>(\n     })\n }\n \n-fn enter_box<'r,'b>(\n-             bcx: &'b Block<'b>,\n-             dm: DefMap,\n-             m: &[Match<'r,'b>],\n-             col: uint,\n-             val: ValueRef)\n-             -> ~[Match<'r,'b>] {\n-    debug!(\"enter_box(bcx={}, m={}, col={}, val={})\",\n-           bcx.to_str(),\n-           m.repr(bcx.tcx()),\n-           col,\n-           bcx.val_to_str(val));\n-    let _indenter = indenter();\n-\n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n-    enter_match(bcx, dm, m, col, val, |p| {\n-        match p.node {\n-            ast::PatBox(sub) => {\n-                Some(~[sub])\n-            }\n-            _ => {\n-                assert_is_binding_or_wild(bcx, p);\n-                Some(~[dummy])\n-            }\n-        }\n-    })\n-}\n-\n fn enter_uniq<'r,'b>(\n               bcx: &'b Block<'b>,\n               dm: DefMap,\n@@ -1146,23 +1118,6 @@ fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n     })\n }\n \n-fn root_pats_as_necessary<'r,'b>(\n-                          mut bcx: &'b Block<'b>,\n-                          m: &[Match<'r,'b>],\n-                          col: uint,\n-                          val: ValueRef)\n-                          -> &'b Block<'b> {\n-    for br in m.iter() {\n-        let pat_id = br.pats[col].id;\n-        if pat_id != 0 {\n-            let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n-                               mode: ByRef(ZeroMem)};\n-            bcx = datum.root_and_write_guard(bcx, br.pats[col].span, pat_id, 0);\n-        }\n-    }\n-    return bcx;\n-}\n-\n // Macro for deciding whether any of the remaining matches fit a given kind of\n // pattern.  Note that, because the macro is well-typed, either ALL of the\n // matches should fit that sort of pattern or NONE (however, some of the\n@@ -1178,10 +1133,6 @@ macro_rules! any_pat (\n     )\n )\n \n-fn any_box_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, ast::PatBox(_))\n-}\n-\n fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::PatUniq(_))\n }\n@@ -1570,7 +1521,7 @@ fn compile_submatch_continue<'r,\n \n     // If we are not matching against an `@T`, we should not be\n     // required to root any values.\n-    assert!(any_box_pat(m, col) || !pats_require_rooting(bcx, m, col));\n+    assert!(!pats_require_rooting(bcx, m, col));\n \n     match collect_record_or_struct_fields(bcx, m, col) {\n         Some(ref rec_fields) => {\n@@ -1632,16 +1583,6 @@ fn compile_submatch_continue<'r,\n         return;\n     }\n \n-    // Unbox in case of a box field\n-    if any_box_pat(m, col) {\n-        bcx = root_pats_as_necessary(bcx, m, col, val);\n-        let llbox = Load(bcx, val);\n-        let unboxed = GEPi(bcx, llbox, [0u, abi::box_field_body]);\n-        compile_submatch(bcx, enter_box(bcx, dm, m, col, val),\n-                         vec::append(~[unboxed], vals_left), chk);\n-        return;\n-    }\n-\n     if any_uniq_pat(m, col) {\n         let pat_ty = node_id_type(bcx, pat_id);\n         let llbox = Load(bcx, val);\n@@ -2289,7 +2230,7 @@ fn bind_irrefutable_pat<'a>(\n                 bcx = bind_irrefutable_pat(bcx, *elem, fldptr, binding_mode);\n             }\n         }\n-        ast::PatBox(inner) | ast::PatUniq(inner) => {\n+        ast::PatUniq(inner) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n             let llbox = Load(bcx, val);\n             let unboxed = match ty::get(pat_ty).sty {"}, {"sha": "ce251a9ec06597cc139af114cbc790b0e3db5b50", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 76, "deletions": 54, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -172,10 +172,13 @@ pub fn get_const_val(cx: @CrateContext,\n         };\n \n         match opt_item {\n-            ast_map::NodeItem(@ast::Item {\n-                node: ast::ItemStatic(_, ast::MutImmutable, _), ..\n-            }, _) => {\n-                trans_const(cx, ast::MutImmutable, def_id.node);\n+            ast_map::NodeItem(item, _) => {\n+                match item.node {\n+                    ast::ItemStatic(_, ast::MutImmutable, _) => {\n+                        trans_const(cx, ast::MutImmutable, def_id.node);\n+                    }\n+                    _ => {}\n+                }\n             }\n             _ => cx.tcx.sess.bug(\"expected a const to be an item\")\n         }\n@@ -198,60 +201,79 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n     };\n     match adjustment {\n         None => { }\n-        Some(@ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil)) => {\n-            llconst = C_struct([llconst, C_null(Type::opaque_box(cx).ptr_to())], false)\n-        }\n-        Some(@ty::AutoAddEnv(ref r, ref s)) => {\n-            cx.sess.span_bug(e.span, format!(\"unexpected static function: \\\n-                                           region {:?} sigil {:?}\", *r, *s))\n-        }\n-        Some(@ty::AutoObject(..)) => {\n-            cx.sess.span_unimpl(e.span, \"unimplemented const coercion to trait object\");\n-        }\n-        Some(@ty::AutoDerefRef(ref adj)) => {\n-            let mut ty = ety;\n-            let mut maybe_ptr = None;\n-            adj.autoderefs.times(|| {\n-                let (dv, dt) = const_deref(cx, llconst, ty, false);\n-                maybe_ptr = Some(llconst);\n-                llconst = dv;\n-                ty = dt;\n-            });\n-\n-            match adj.autoref {\n-                None => { }\n-                Some(ref autoref) => {\n-                    // Don't copy data to do a deref+ref.\n-                    let llptr = match maybe_ptr {\n-                        Some(ptr) => ptr,\n-                        None => {\n-                            inlineable = false;\n-                            const_addr_of(cx, llconst)\n-                        }\n-                    };\n-                    match *autoref {\n-                        ty::AutoUnsafe(m) |\n-                        ty::AutoPtr(ty::ReStatic, m) => {\n-                            assert!(m != ast::MutMutable);\n-                            llconst = llptr;\n-                        }\n-                        ty::AutoBorrowVec(ty::ReStatic, m) => {\n-                            assert!(m != ast::MutMutable);\n-                            assert_eq!(abi::slice_elt_base, 0);\n-                            assert_eq!(abi::slice_elt_len, 1);\n+        Some(adj) => {\n+            match *adj {\n+                ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil) => {\n+                    llconst = C_struct([\n+                        llconst,\n+                        C_null(Type::opaque_box(cx).ptr_to())\n+                    ], false)\n+                }\n+                ty::AutoAddEnv(ref r, ref s) => {\n+                    cx.sess\n+                      .span_bug(e.span,\n+                                format!(\"unexpected static function: region \\\n+                                         {:?} sigil {:?}\",\n+                                        *r,\n+                                        *s))\n+                }\n+                ty::AutoObject(..) => {\n+                    cx.sess\n+                      .span_unimpl(e.span,\n+                                   \"unimplemented const coercion to trait \\\n+                                    object\");\n+                }\n+                ty::AutoDerefRef(ref adj) => {\n+                    let mut ty = ety;\n+                    let mut maybe_ptr = None;\n+                    adj.autoderefs.times(|| {\n+                        let (dv, dt) = const_deref(cx, llconst, ty, false);\n+                        maybe_ptr = Some(llconst);\n+                        llconst = dv;\n+                        ty = dt;\n+                    });\n \n-                            match ty::get(ty).sty {\n-                                ty::ty_vec(_, ty::vstore_fixed(len)) => {\n-                                    llconst = C_struct([llptr, C_uint(cx, len)], false);\n+                    match adj.autoref {\n+                        None => { }\n+                        Some(ref autoref) => {\n+                            // Don't copy data to do a deref+ref.\n+                            let llptr = match maybe_ptr {\n+                                Some(ptr) => ptr,\n+                                None => {\n+                                    inlineable = false;\n+                                    const_addr_of(cx, llconst)\n+                                }\n+                            };\n+                            match *autoref {\n+                                ty::AutoUnsafe(m) |\n+                                ty::AutoPtr(ty::ReStatic, m) => {\n+                                    assert!(m != ast::MutMutable);\n+                                    llconst = llptr;\n+                                }\n+                                ty::AutoBorrowVec(ty::ReStatic, m) => {\n+                                    assert!(m != ast::MutMutable);\n+                                    assert_eq!(abi::slice_elt_base, 0);\n+                                    assert_eq!(abi::slice_elt_len, 1);\n+                                    match ty::get(ty).sty {\n+                                        ty::ty_vec(_,\n+                                                   ty::vstore_fixed(len)) => {\n+                                            llconst = C_struct([\n+                                                llptr,\n+                                                C_uint(cx, len)\n+                                            ], false);\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                }\n+                                _ => {\n+                                    cx.sess.span_bug(e.span,\n+                                                     format!(\"unimplemented \\\n+                                                              const autoref \\\n+                                                              {:?}\",\n+                                                             autoref))\n                                 }\n-                                _ => {}\n                             }\n                         }\n-                        _ => {\n-                            cx.sess.span_bug(e.span,\n-                                             format!(\"unimplemented const \\\n-                                                   autoref {:?}\", autoref))\n-                        }\n                     }\n                 }\n             }"}, {"sha": "7e1efcf3a60e061695bcef61857be17e89b30f31", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 106, "deletions": 91, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -331,8 +331,21 @@ pub fn create_captured_var_metadata(bcx: &Block,\n             cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n         }\n         Some(ast_map::NodeLocal(ident, _)) => ident,\n-        Some(ast_map::NodeArg(@ast::Pat { node: ast::PatIdent(_, ref path, _), .. })) => {\n-            ast_util::path_to_ident(path)\n+        Some(ast_map::NodeArg(pat)) => {\n+            match pat.node {\n+                ast::PatIdent(_, ref path, _) => {\n+                    ast_util::path_to_ident(path)\n+                }\n+                _ => {\n+                    cx.sess\n+                      .span_bug(span,\n+                                format!(\n+                                \"debuginfo::create_captured_var_metadata() - \\\n+                                 Captured var-id refers to unexpected \\\n+                                 ast_map variant: {:?}\",\n+                                 ast_item));\n+                }\n+            }\n         }\n         _ => {\n             cx.sess.span_bug(span, format!(\"debuginfo::create_captured_var_metadata() - \\\n@@ -415,18 +428,20 @@ pub fn create_self_argument_metadata(bcx: &Block,\n         items.get().get_copy(&bcx.fcx.id)\n     };\n     let span = match fnitem {\n-        ast_map::NodeMethod(@ast::Method { explicit_self: explicit_self, .. }, _, _) => {\n-            explicit_self.span\n+        ast_map::NodeMethod(method, _, _) => {\n+            method.explicit_self.span\n         }\n-        ast_map::NodeTraitMethod(\n-            @ast::Provided(\n-                @ast::Method {\n-                    explicit_self: explicit_self,\n-                    ..\n-                }),\n-            _,\n-            _) => {\n-            explicit_self.span\n+        ast_map::NodeTraitMethod(trait_method, _, _) => {\n+            match *trait_method {\n+                ast::Provided(method) => method.explicit_self.span,\n+                _ => {\n+                    bcx.ccx()\n+                       .sess\n+                       .bug(format!(\"create_self_argument_metadata: \\\n+                                     unexpected sort of node: {:?}\",\n+                                     fnitem))\n+                }\n+            }\n         }\n         _ => bcx.ccx().sess.bug(\n                 format!(\"create_self_argument_metadata: unexpected sort of node: {:?}\", fnitem))\n@@ -614,18 +629,13 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 }\n             }\n         }\n-        ast_map::NodeMethod(\n-            @ast::Method {\n-                decl: fn_decl,\n-                ident: ident,\n-                generics: ref generics,\n-                body: top_level_block,\n-                span: span,\n-                ..\n-            },\n-            _,\n-            _) => {\n-            (ident, fn_decl, generics, top_level_block, span, true)\n+        ast_map::NodeMethod(method, _, _) => {\n+            (method.ident,\n+             method.decl,\n+             &method.generics,\n+             method.body,\n+             method.span,\n+             true)\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n@@ -646,22 +656,29 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n-        ast_map::NodeTraitMethod(\n-            @ast::Provided(\n-                @ast::Method {\n-                    decl: fn_decl,\n-                    ident: ident,\n-                    generics: ref generics,\n-                    body: top_level_block,\n-                    span: span,\n-                    ..\n-                }),\n-            _,\n-            _) => {\n-            (ident, fn_decl, generics, top_level_block, span, true)\n+        ast_map::NodeTraitMethod(trait_method, _, _) => {\n+            match *trait_method {\n+                ast::Provided(method) => {\n+                    (method.ident,\n+                     method.decl,\n+                     &method.generics,\n+                     method.body,\n+                     method.span,\n+                     true)\n+                }\n+                _ => {\n+                    cx.sess\n+                      .bug(format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\",\n+                                    fnitem))\n+                }\n+            }\n+        }\n+        ast_map::NodeForeignItem(..) |\n+        ast_map::NodeVariant(..) |\n+        ast_map::NodeStructCtor(..) => {\n+            return FunctionWithoutDebugInfo;\n         }\n-        ast_map::NodeForeignItem(..) | ast_map::NodeVariant(..)\n-        | ast_map::NodeStructCtor(..) => { return FunctionWithoutDebugInfo; }\n         _ => cx.sess.bug(format!(\"create_function_debug_context: \\\n                                   unexpected sort of node: {:?}\", fnitem))\n     };\n@@ -814,7 +831,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                name_to_append_suffix_to: &mut ~str)\n                             -> DIArray {\n         let self_type = match param_substs {\n-            Some(@param_substs{ self_ty: self_type, .. }) => self_type,\n+            Some(param_substs) => param_substs.self_ty,\n             _ => None\n         };\n \n@@ -868,7 +885,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n         // Handle other generic parameters\n         let actual_types = match param_substs {\n-            Some(@param_substs { tys: ref types, .. }) => types,\n+            Some(param_substs) => &param_substs.tys,\n             None => {\n                 return create_DIArray(DIB(cx), template_params);\n             }\n@@ -2290,7 +2307,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext,\n         {\n             let items = cx.tcx.items.borrow();\n             let definition_span = match items.get().find(&def_id.node) {\n-                Some(&ast_map::NodeItem(@ast::Item { span, .. }, _)) => span,\n+                Some(&ast_map::NodeItem(item, _)) => item.span,\n                 ref node => {\n                     cx.sess.span_warn(warning_span,\n                         format!(\"debuginfo::\\\n@@ -2393,19 +2410,19 @@ fn populate_scope_map(cx: &CrateContext,\n         scope_map.insert(block.id, scope_stack.last().scope_metadata);\n \n         // The interesting things here are statements and the concluding expression.\n-        for &@ ref statement in block.stmts.iter() {\n-            scope_map.insert(ast_util::stmt_id(statement), scope_stack.last().scope_metadata);\n+        for statement in block.stmts.iter() {\n+            scope_map.insert(ast_util::stmt_id(*statement), scope_stack.last().scope_metadata);\n \n             match statement.node {\n-                ast::StmtDecl(@ref decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n-                ast::StmtExpr(@ref exp, _) |\n-                ast::StmtSemi(@ref exp, _) => walk_expr(cx, exp, scope_stack, scope_map),\n+                ast::StmtDecl(decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n+                ast::StmtExpr(exp, _) |\n+                ast::StmtSemi(exp, _) => walk_expr(cx, exp, scope_stack, scope_map),\n                 ast::StmtMac(..) => () // ignore macros (which should be expanded anyway)\n             }\n         }\n \n-        for &@ref exp in block.expr.iter() {\n-            walk_expr(cx, exp, scope_stack, scope_map);\n+        for exp in block.expr.iter() {\n+            walk_expr(cx, *exp, scope_stack, scope_map);\n         }\n     }\n \n@@ -2414,13 +2431,13 @@ fn populate_scope_map(cx: &CrateContext,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n-            codemap::Spanned { node: ast::DeclLocal(@ref local), .. } => {\n+            codemap::Spanned { node: ast::DeclLocal(local), .. } => {\n                 scope_map.insert(local.id, scope_stack.last().scope_metadata);\n \n                 walk_pattern(cx, local.pat, scope_stack, scope_map);\n \n-                for &@ref exp in local.init.iter() {\n-                    walk_expr(cx, exp, scope_stack, scope_map);\n+                for exp in local.init.iter() {\n+                    walk_expr(cx, *exp, scope_stack, scope_map);\n                 }\n             }\n             _ => ()\n@@ -2538,19 +2555,17 @@ fn populate_scope_map(cx: &CrateContext,\n                 }\n             }\n \n-            ast::PatBox(sub_pat)    |\n-            ast::PatUniq(sub_pat)   |\n-            ast::PatRegion(sub_pat) => {\n+            ast::PatUniq(sub_pat) | ast::PatRegion(sub_pat) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n                 walk_pattern(cx, sub_pat, scope_stack, scope_map);\n             }\n \n-            ast::PatLit(@ref exp) => {\n+            ast::PatLit(exp) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, exp, scope_stack, scope_map);\n             }\n \n-            ast::PatRange(@ref exp1, @ref exp2) => {\n+            ast::PatRange(exp1, exp2) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, exp1, scope_stack, scope_map);\n                 walk_expr(cx, exp2, scope_stack, scope_map);\n@@ -2589,49 +2604,49 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprAgain(_) |\n             ast::ExprPath(_)  => (),\n \n-            ast::ExprVstore(@ref sub_exp, _)   |\n-            ast::ExprCast(@ref sub_exp, _)     |\n-            ast::ExprAddrOf(_, @ref sub_exp)  |\n-            ast::ExprField(@ref sub_exp, _, _) |\n-            ast::ExprParen(@ref sub_exp)       => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+            ast::ExprVstore(sub_exp, _)   |\n+            ast::ExprCast(sub_exp, _)     |\n+            ast::ExprAddrOf(_, sub_exp)  |\n+            ast::ExprField(sub_exp, _, _) |\n+            ast::ExprParen(sub_exp)       => walk_expr(cx, sub_exp, scope_stack, scope_map),\n \n-            ast::ExprBox(@ref place, @ref sub_expr) => {\n+            ast::ExprBox(place, sub_expr) => {\n                 walk_expr(cx, place, scope_stack, scope_map);\n                 walk_expr(cx, sub_expr, scope_stack, scope_map);\n             }\n \n             ast::ExprRet(exp_opt) => match exp_opt {\n-                Some(@ref sub_exp) => walk_expr(cx, sub_exp, scope_stack, scope_map),\n+                Some(sub_exp) => walk_expr(cx, sub_exp, scope_stack, scope_map),\n                 None => ()\n             },\n \n-            ast::ExprUnary(node_id, _, @ref sub_exp) => {\n+            ast::ExprUnary(node_id, _, sub_exp) => {\n                 scope_map.insert(node_id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, sub_exp, scope_stack, scope_map);\n             }\n \n-            ast::ExprAssignOp(node_id, _, @ref lhs, @ref rhs) |\n-            ast::ExprIndex(node_id, @ref lhs, @ref rhs)        |\n-            ast::ExprBinary(node_id, _, @ref lhs, @ref rhs)    => {\n+            ast::ExprAssignOp(node_id, _, lhs, rhs) |\n+            ast::ExprIndex(node_id, lhs, rhs)        |\n+            ast::ExprBinary(node_id, _, lhs, rhs)    => {\n                 scope_map.insert(node_id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, lhs, scope_stack, scope_map);\n                 walk_expr(cx, rhs, scope_stack, scope_map);\n             }\n \n             ast::ExprVec(ref init_expressions, _) |\n             ast::ExprTup(ref init_expressions)    => {\n-                for &@ref ie in init_expressions.iter() {\n-                    walk_expr(cx, ie, scope_stack, scope_map);\n+                for ie in init_expressions.iter() {\n+                    walk_expr(cx, *ie, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::ExprAssign(@ref sub_exp1, @ref sub_exp2)    |\n-            ast::ExprRepeat(@ref sub_exp1, @ref sub_exp2, _) => {\n+            ast::ExprAssign(sub_exp1, sub_exp2)    |\n+            ast::ExprRepeat(sub_exp1, sub_exp2, _) => {\n                 walk_expr(cx, sub_exp1, scope_stack, scope_map);\n                 walk_expr(cx, sub_exp2, scope_stack, scope_map);\n             }\n \n-            ast::ExprIf(@ref cond_exp, then_block, ref opt_else_exp) => {\n+            ast::ExprIf(cond_exp, then_block, ref opt_else_exp) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n                 with_new_scope(cx,\n@@ -2643,12 +2658,12 @@ fn populate_scope_map(cx: &CrateContext,\n                 });\n \n                 match *opt_else_exp {\n-                    Some(@ref else_exp) => walk_expr(cx, else_exp, scope_stack, scope_map),\n+                    Some(else_exp) => walk_expr(cx, else_exp, scope_stack, scope_map),\n                     _ => ()\n                 }\n             }\n \n-            ast::ExprWhile(@ref cond_exp, loop_body) => {\n+            ast::ExprWhile(cond_exp, loop_body) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n                 with_new_scope(cx,\n@@ -2696,8 +2711,8 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            // ast::expr_loop_body(@ref inner_exp) |\n-            ast::ExprDoBody(@ref inner_exp)   => {\n+            // ast::expr_loop_body(inner_exp) |\n+            ast::ExprDoBody(inner_exp)   => {\n                 let inner_expr_is_expr_fn_block = match *inner_exp {\n                     ast::Expr { node: ast::ExprFnBlock(..), .. } => true,\n                     _ => false\n@@ -2711,24 +2726,24 @@ fn populate_scope_map(cx: &CrateContext,\n                 walk_expr(cx, inner_exp, scope_stack, scope_map);\n             }\n \n-            ast::ExprCall(@ref fn_exp, ref args, _) => {\n+            ast::ExprCall(fn_exp, ref args, _) => {\n                 walk_expr(cx, fn_exp, scope_stack, scope_map);\n \n-                for &@ref arg_exp in args.iter() {\n-                    walk_expr(cx, arg_exp, scope_stack, scope_map);\n+                for arg_exp in args.iter() {\n+                    walk_expr(cx, *arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::ExprMethodCall(node_id, @ref receiver_exp, _, _, ref args, _) => {\n+            ast::ExprMethodCall(node_id, receiver_exp, _, _, ref args, _) => {\n                 scope_map.insert(node_id, scope_stack.last().scope_metadata);\n                 walk_expr(cx, receiver_exp, scope_stack, scope_map);\n \n-                for &@ref arg_exp in args.iter() {\n-                    walk_expr(cx, arg_exp, scope_stack, scope_map);\n+                for arg_exp in args.iter() {\n+                    walk_expr(cx, *arg_exp, scope_stack, scope_map);\n                 }\n             }\n \n-            ast::ExprMatch(@ref discriminant_exp, ref arms) => {\n+            ast::ExprMatch(discriminant_exp, ref arms) => {\n                 walk_expr(cx, discriminant_exp, scope_stack, scope_map);\n \n                 // for each arm we have to first walk the pattern as these might introduce new\n@@ -2747,8 +2762,8 @@ fn populate_scope_map(cx: &CrateContext,\n                             walk_pattern(cx, pat, scope_stack, scope_map);\n                         }\n \n-                        for &@ref guard_exp in arm_ref.guard.iter() {\n-                            walk_expr(cx, guard_exp, scope_stack, scope_map)\n+                        for guard_exp in arm_ref.guard.iter() {\n+                            walk_expr(cx, *guard_exp, scope_stack, scope_map)\n                         }\n \n                         walk_block(cx, arm_ref.body, scope_stack, scope_map);\n@@ -2757,12 +2772,12 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprStruct(_, ref fields, ref base_exp) => {\n-                for &ast::Field { expr: @ref exp, .. } in fields.iter() {\n+                for &ast::Field { expr: exp, .. } in fields.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n                 }\n \n                 match *base_exp {\n-                    Some(@ref exp) => walk_expr(cx, exp, scope_stack, scope_map),\n+                    Some(exp) => walk_expr(cx, exp, scope_stack, scope_map),\n                     None => ()\n                 }\n             }\n@@ -2771,11 +2786,11 @@ fn populate_scope_map(cx: &CrateContext,\n                                                 outputs: ref outputs,\n                                                 .. }) => {\n                 // inputs, outputs: ~[(@str, @expr)]\n-                for &(_, @ref exp) in inputs.iter() {\n+                for &(_, exp) in inputs.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n                 }\n \n-                for &(_, @ref exp) in outputs.iter() {\n+                for &(_, exp) in outputs.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n                 }\n             }"}, {"sha": "ae9aa461bc7f85dc21a69404c197aab67a304812", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -756,8 +756,19 @@ fn trans_rvalue_dps_unadjusted<'a>(\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n         }\n-        ast::ExprLit(@codemap::Spanned {node: ast::LitStr(s, _), ..}) => {\n-            return tvec::trans_lit_str(bcx, expr, s, dest);\n+        ast::ExprLit(lit) => {\n+            match lit.node {\n+                ast::LitStr(s, _) => {\n+                    return tvec::trans_lit_str(bcx, expr, s, dest);\n+                }\n+                _ => {\n+                    bcx.tcx()\n+                       .sess\n+                       .span_bug(expr.span,\n+                                 \"trans_rvalue_dps_unadjusted shouldn't be \\\n+                                  translating this type of literal\")\n+                }\n+            }\n         }\n         ast::ExprVstore(contents, ast::ExprVstoreSlice) |\n         ast::ExprVstore(contents, ast::ExprVstoreMutSlice) => {"}, {"sha": "7bf278fe8d8126f8f7f2e9d2515bf3dda588e44c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -109,8 +109,11 @@ pub fn trans_method(ccx: @CrateContext,\n         let self_ty = ty::node_id_to_type(ccx.tcx, method.self_id);\n         let self_ty = match param_substs {\n             None => self_ty,\n-            Some(@param_substs {tys: ref tys, self_ty: ref self_sub, ..}) => {\n-                ty::subst_tps(ccx.tcx, *tys, *self_sub, self_ty)\n+            Some(param_substs) => {\n+                ty::subst_tps(ccx.tcx,\n+                              param_substs.tys,\n+                              param_substs.self_ty,\n+                              self_ty)\n             }\n         };\n         debug!(\"calling trans_fn with self_ty {}\", self_ty.repr(ccx.tcx));"}, {"sha": "a05ca4296b1301c0afd44f8cdcf85bbece6d2db2", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -115,17 +115,21 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         // Foreign externs don't have to be monomorphized.\n         return (get_item_val(ccx, fn_id.node), true);\n       }\n-      ast_map::NodeTraitMethod(@ast::Provided(m), _, pt) => {\n-        // If this is a static provided method, indicate that\n-        // and stash the number of params on the method.\n-        if m.explicit_self.node == ast::SelfStatic {\n-            is_static_provided = Some(m.generics.ty_params.len());\n-        }\n+      ast_map::NodeTraitMethod(method, _, pt) => {\n+          match *method {\n+              ast::Provided(m) => {\n+                // If this is a static provided method, indicate that\n+                // and stash the number of params on the method.\n+                if m.explicit_self.node == ast::SelfStatic {\n+                    is_static_provided = Some(m.generics.ty_params.len());\n+                }\n \n-        (pt, m.ident, m.span)\n-      }\n-      ast_map::NodeTraitMethod(@ast::Required(_), _, _) => {\n-        ccx.tcx.sess.bug(\"Can't monomorphize a required trait method\")\n+                (pt, m.ident, m.span)\n+              }\n+              ast::Required(_) => {\n+                ccx.tcx.sess.bug(\"Can't monomorphize a required trait method\")\n+              }\n+          }\n       }\n       ast_map::NodeExpr(..) => {\n         ccx.tcx.sess.bug(\"Can't monomorphize an expr\")\n@@ -218,26 +222,30 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     };\n \n     let lldecl = match map_node {\n-      ast_map::NodeItem(i@@ast::Item {\n+      ast_map::NodeItem(i, _) => {\n+          match *i {\n+            ast::Item {\n                 node: ast::ItemFn(decl, _, _, _, body),\n                 ..\n-            }, _) => {\n-        let d = mk_lldecl(None);\n-        set_llvm_fn_attrs(i.attrs, d);\n-        trans_fn(ccx,\n-                 pt,\n-                 decl,\n-                 body,\n-                 d,\n-                 None,\n-                 Some(psubsts),\n-                 fn_id.node,\n-                 None,\n-                 []);\n-        d\n-      }\n-      ast_map::NodeItem(..) => {\n-          ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n+            } => {\n+                let d = mk_lldecl(None);\n+                set_llvm_fn_attrs(i.attrs, d);\n+                trans_fn(ccx,\n+                         pt,\n+                         decl,\n+                         body,\n+                         d,\n+                         None,\n+                         Some(psubsts),\n+                         fn_id.node,\n+                         None,\n+                         []);\n+                d\n+            }\n+            _ => {\n+              ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n+            }\n+          }\n       }\n       ast_map::NodeForeignItem(i, _, _, _) => {\n           let d = mk_lldecl(None);\n@@ -272,12 +280,24 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             d\n         })\n       }\n-      ast_map::NodeTraitMethod(@ast::Provided(mth), _, pt) => {\n-        meth::trans_method(ccx, (*pt).clone(), mth, Some(psubsts), |self_ty| {\n-            let d = mk_lldecl(self_ty);\n-            set_llvm_fn_attrs(mth.attrs, d);\n-            d\n-        })\n+      ast_map::NodeTraitMethod(method, _, pt) => {\n+          match *method {\n+              ast::Provided(mth) => {\n+                meth::trans_method(ccx,\n+                                   (*pt).clone(),\n+                                   mth,\n+                                   Some(psubsts),\n+                                   |self_ty| {\n+                    let d = mk_lldecl(self_ty);\n+                    set_llvm_fn_attrs(mth.attrs, d);\n+                    d\n+                })\n+              }\n+              _ => {\n+                ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\",\n+                                         map_node))\n+              }\n+          }\n       }\n       ast_map::NodeStructCtor(struct_def, _, _) => {\n         let d = mk_lldecl(None);\n@@ -294,7 +314,6 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       // Ugh -- but this ensures any new variants won't be forgotten\n       ast_map::NodeExpr(..) |\n       ast_map::NodeStmt(..) |\n-      ast_map::NodeTraitMethod(..) |\n       ast_map::NodeArg(..) |\n       ast_map::NodeBlock(..) |\n       ast_map::NodeCalleeScope(..) |"}, {"sha": "ce7a2a6ec68dcfbe93be73db1ecc70cedd483c0a", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 61, "deletions": 34, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -30,7 +30,6 @@ use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n use syntax::ast;\n-use syntax::codemap;\n \n // Boxed vector types are in some sense currently a \"shorthand\" for a box\n // containing an unboxed vector. This expands a boxed vector type into such an\n@@ -223,8 +222,13 @@ pub fn trans_slice_vstore<'a>(\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n-        ast::ExprLit(@codemap::Spanned {node: ast::LitStr(s, _), span: _}) => {\n-            return trans_lit_str(bcx, content_expr, s, dest);\n+        ast::ExprLit(lit) => {\n+            match lit.node {\n+                ast::LitStr(s, _) => {\n+                    return trans_lit_str(bcx, content_expr, s, dest);\n+                }\n+                _ => {}\n+            }\n         }\n         _ => {}\n     }\n@@ -317,25 +321,30 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n     match heap {\n         heap_exchange => {\n             match content_expr.node {\n-                ast::ExprLit(@codemap::Spanned {\n-                    node: ast::LitStr(s, _), span\n-                }) => {\n-                    let llptrval = C_cstr(bcx.ccx(), s);\n-                    let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n-                    let llsizeval = C_uint(bcx.ccx(), s.len());\n-                    let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n-                    let lldestval = scratch_datum(bcx, typ, \"\", false);\n-                    let alloc_fn = langcall(bcx, Some(span), \"\",\n-                                            StrDupUniqFnLangItem);\n-                    let bcx = callee::trans_lang_call(\n-                        bcx,\n-                        alloc_fn,\n-                        [ llptrval, llsizeval ],\n-                        Some(expr::SaveIn(lldestval.to_ref_llval(bcx)))).bcx;\n-                    return DatumBlock {\n-                        bcx: bcx,\n-                        datum: lldestval\n-                    };\n+                ast::ExprLit(lit) => {\n+                    match lit.node {\n+                        ast::LitStr(s, _) => {\n+                            let llptrval = C_cstr(bcx.ccx(), s);\n+                            let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n+                            let llsizeval = C_uint(bcx.ccx(), s.len());\n+                            let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n+                            let lldestval = scratch_datum(bcx, typ, \"\", false);\n+                            let alloc_fn = langcall(bcx,\n+                                                    Some(lit.span),\n+                                                    \"\",\n+                                                    StrDupUniqFnLangItem);\n+                            let bcx = callee::trans_lang_call(\n+                                bcx,\n+                                alloc_fn,\n+                                [ llptrval, llsizeval ],\n+                                Some(expr::SaveIn(lldestval.to_ref_llval(bcx)))).bcx;\n+                            return DatumBlock {\n+                                bcx: bcx,\n+                                datum: lldestval\n+                            };\n+                        }\n+                        _ => {}\n+                    }\n                 }\n                 _ => {}\n             }\n@@ -380,17 +389,29 @@ pub fn write_content<'a>(\n     let _indenter = indenter();\n \n     match content_expr.node {\n-        ast::ExprLit(@codemap::Spanned { node: ast::LitStr(s, _), .. }) => {\n-            match dest {\n-                Ignore => {\n-                    return bcx;\n+        ast::ExprLit(lit) => {\n+            match lit.node {\n+                ast::LitStr(s, _) => {\n+                    match dest {\n+                        Ignore => {\n+                            return bcx;\n+                        }\n+                        SaveIn(lldest) => {\n+                            let bytes = s.len();\n+                            let llbytes = C_uint(bcx.ccx(), bytes);\n+                            let llcstr = C_cstr(bcx.ccx(), s);\n+                            base::call_memcpy(bcx,\n+                                              lldest,\n+                                              llcstr,\n+                                              llbytes,\n+                                              1);\n+                            return bcx;\n+                        }\n+                    }\n                 }\n-                SaveIn(lldest) => {\n-                    let bytes = s.len();\n-                    let llbytes = C_uint(bcx.ccx(), bytes);\n-                    let llcstr = C_cstr(bcx.ccx(), s);\n-                    base::call_memcpy(bcx, lldest, llcstr, llbytes, 1);\n-                    return bcx;\n+                _ => {\n+                    bcx.tcx().sess.span_bug(content_expr.span,\n+                                            \"Unexpected evec content\");\n                 }\n             }\n         }\n@@ -477,8 +498,14 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n-        ast::ExprLit(@codemap::Spanned { node: ast::LitStr(s, _), .. }) => {\n-            s.len()\n+        ast::ExprLit(lit) => {\n+            match lit.node {\n+                ast::LitStr(s, _) => s.len(),\n+                _ => {\n+                    bcx.tcx().sess.span_bug(content_expr.span,\n+                                            \"Unexpected evec content\")\n+                }\n+            }\n         },\n         ast::ExprVec(ref es, _) => es.len(),\n         ast::ExprRepeat(_, count_expr, _) => {"}, {"sha": "e8ca4ba57283f6b643187a7b233392993050c022", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 172, "deletions": 117, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -38,12 +38,11 @@ use std::to_bytes;\n use std::to_str::ToStr;\n use std::vec;\n use syntax::ast::*;\n-use syntax::ast_util::is_local;\n+use syntax::ast_util::{is_local, lit_is_str};\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n-use syntax::codemap;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n@@ -2864,78 +2863,101 @@ pub fn adjust_ty(cx: ctxt,\n     return match adjustment {\n         None => unadjusted_ty,\n \n-        Some(@AutoAddEnv(r, s)) => {\n-            match ty::get(unadjusted_ty).sty {\n-                ty::ty_bare_fn(ref b) => {\n-                    ty::mk_closure(\n-                        cx,\n-                        ty::ClosureTy {purity: b.purity,\n-                                       sigil: s,\n-                                       onceness: ast::Many,\n-                                       region: r,\n-                                       bounds: ty::AllBuiltinBounds(),\n-                                       sig: b.sig.clone()})\n-                }\n-                ref b => {\n-                    cx.sess.bug(\n-                        format!(\"add_env adjustment on non-bare-fn: {:?}\", b));\n-                }\n-            }\n-        }\n-\n-        Some(@AutoDerefRef(ref adj)) => {\n-            let mut adjusted_ty = unadjusted_ty;\n-\n-            if (!ty::type_is_error(adjusted_ty)) {\n-                for i in range(0, adj.autoderefs) {\n-                    match ty::deref(adjusted_ty, true) {\n-                        Some(mt) => { adjusted_ty = mt.ty; }\n-                        None => {\n-                            cx.sess.span_bug(\n-                                span,\n-                                format!(\"The {}th autoderef failed: {}\",\n-                                     i, ty_to_str(cx,\n-                                                  adjusted_ty)));\n+        Some(adjustment) => {\n+            match *adjustment {\n+                AutoAddEnv(r, s) => {\n+                    match ty::get(unadjusted_ty).sty {\n+                        ty::ty_bare_fn(ref b) => {\n+                            ty::mk_closure(\n+                                cx,\n+                                ty::ClosureTy {purity: b.purity,\n+                                               sigil: s,\n+                                               onceness: ast::Many,\n+                                               region: r,\n+                                               bounds: ty::AllBuiltinBounds(),\n+                                               sig: b.sig.clone()})\n+                        }\n+                        ref b => {\n+                            cx.sess.bug(\n+                                format!(\"add_env adjustment on non-bare-fn: \\\n+                                         {:?}\",\n+                                        b));\n                         }\n                     }\n                 }\n-            }\n \n-            match adj.autoref {\n-                None => adjusted_ty,\n-                Some(ref autoref) => {\n-                    match *autoref {\n-                        AutoPtr(r, m) => {\n-                            mk_rptr(cx, r, mt {ty: adjusted_ty, mutbl: m})\n-                        }\n-\n-                        AutoBorrowVec(r, m) => {\n-                            borrow_vec(cx, span, r, m, adjusted_ty)\n-                        }\n-\n-                        AutoBorrowVecRef(r, m) => {\n-                            adjusted_ty = borrow_vec(cx, span, r, m, adjusted_ty);\n-                            mk_rptr(cx, r, mt {ty: adjusted_ty, mutbl: ast::MutImmutable})\n-                        }\n-\n-                        AutoBorrowFn(r) => {\n-                            borrow_fn(cx, span, r, adjusted_ty)\n-                        }\n-\n-                        AutoUnsafe(m) => {\n-                            mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n+                AutoDerefRef(ref adj) => {\n+                    let mut adjusted_ty = unadjusted_ty;\n+\n+                    if (!ty::type_is_error(adjusted_ty)) {\n+                        for i in range(0, adj.autoderefs) {\n+                            match ty::deref(adjusted_ty, true) {\n+                                Some(mt) => { adjusted_ty = mt.ty; }\n+                                None => {\n+                                    cx.sess.span_bug(\n+                                        span,\n+                                        format!(\"The {}th autoderef failed: \\\n+                                                {}\",\n+                                                i,\n+                                                ty_to_str(cx, adjusted_ty)));\n+                                }\n+                            }\n                         }\n+                    }\n \n-                        AutoBorrowObj(r, m) => {\n-                            borrow_obj(cx, span, r, m, adjusted_ty)\n+                    match adj.autoref {\n+                        None => adjusted_ty,\n+                        Some(ref autoref) => {\n+                            match *autoref {\n+                                AutoPtr(r, m) => {\n+                                    mk_rptr(cx, r, mt {\n+                                        ty: adjusted_ty,\n+                                        mutbl: m\n+                                    })\n+                                }\n+\n+                                AutoBorrowVec(r, m) => {\n+                                    borrow_vec(cx, span, r, m, adjusted_ty)\n+                                }\n+\n+                                AutoBorrowVecRef(r, m) => {\n+                                    adjusted_ty = borrow_vec(cx,\n+                                                             span,\n+                                                             r,\n+                                                             m,\n+                                                             adjusted_ty);\n+                                    mk_rptr(cx, r, mt {\n+                                        ty: adjusted_ty,\n+                                        mutbl: ast::MutImmutable\n+                                    })\n+                                }\n+\n+                                AutoBorrowFn(r) => {\n+                                    borrow_fn(cx, span, r, adjusted_ty)\n+                                }\n+\n+                                AutoUnsafe(m) => {\n+                                    mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n+                                }\n+\n+                                AutoBorrowObj(r, m) => {\n+                                    borrow_obj(cx, span, r, m, adjusted_ty)\n+                                }\n+                            }\n                         }\n                     }\n                 }\n-            }\n-        }\n \n-        Some(@AutoObject(ref sigil, ref region, m, b, def_id, ref substs)) => {\n-            trait_adjustment_to_ty(cx, sigil, region, def_id, substs, m, b)\n+                AutoObject(ref sigil, ref region, m, b, def_id, ref substs) => {\n+                    trait_adjustment_to_ty(cx,\n+                                           sigil,\n+                                           region,\n+                                           def_id,\n+                                           substs,\n+                                           m,\n+                                           b)\n+                }\n+            }\n         }\n     };\n \n@@ -3165,13 +3187,16 @@ pub fn expr_kind(tcx: ctxt,\n         ast::ExprDoBody(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n-        ast::ExprLit(@codemap::Spanned {node: LitStr(..), ..}) |\n         ast::ExprVstore(_, ast::ExprVstoreSlice) |\n         ast::ExprVstore(_, ast::ExprVstoreMutSlice) |\n         ast::ExprVec(..) => {\n             RvalueDpsExpr\n         }\n \n+        ast::ExprLit(lit) if lit_is_str(lit) => {\n+            RvalueDpsExpr\n+        }\n+\n         ast::ExprCast(..) => {\n             let node_types = tcx.node_types.borrow();\n             match node_types.get().find(&(expr.id as uint)) {\n@@ -3546,15 +3571,24 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n         {\n             let items = cx.items.borrow();\n             match items.get().find(&id.node) {\n-                Some(&ast_map::NodeItem(@ast::Item {\n-                            node: ItemTrait(_, _, ref ms),\n-                            ..\n-                        }, _)) =>\n-                    match ast_util::split_trait_methods(*ms) {\n-                       (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n-                    },\n-                _ => cx.sess.bug(format!(\"provided_trait_methods: {:?} is not a trait\",\n-                                      id))\n+                Some(&ast_map::NodeItem(item, _)) => {\n+                    match item.node {\n+                        ItemTrait(_, _, ref ms) => {\n+                            let (_, p) = ast_util::split_trait_methods(*ms);\n+                            p.map(|m| method(cx, ast_util::local_def(m.id)))\n+                        }\n+                        _ => {\n+                            cx.sess.bug(format!(\"provided_trait_methods: \\\n+                                                 {:?} is not a trait\",\n+                                                id))\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    cx.sess.bug(format!(\"provided_trait_methods: {:?} is not \\\n+                                         a trait\",\n+                                        id))\n+                }\n             }\n         }\n     } else {\n@@ -3668,13 +3702,18 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         {\n             let items = cx.items.borrow();\n             match items.get().find(&id.node) {\n-                Some(&ast_map::NodeItem(@ast::Item {\n-                     node: ast::ItemImpl(_, ref opt_trait, _, _),\n-                     ..},\n-                     _)) => {\n-                    match opt_trait {\n-                        &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n-                        &None => None\n+                Some(&ast_map::NodeItem(item, _)) => {\n+                    match item.node {\n+                        ast::ItemImpl(_, ref opt_trait, _, _) => {\n+                            match opt_trait {\n+                                &Some(ref t) => {\n+                                    Some(ty::node_id_to_trait_ref(cx,\n+                                                                  t.ref_id))\n+                                }\n+                                &None => None\n+                            }\n+                        }\n+                        _ => None\n                     }\n                 }\n                 _ => None\n@@ -3931,37 +3970,55 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n         {\n             let items = cx.items.borrow();\n             match items.get().get_copy(&id.node) {\n-              ast_map::NodeItem(@ast::Item {\n-                        node: ast::ItemEnum(ref enum_definition, _),\n-                        ..\n-                    }, _) => {\n-                let mut last_discriminant: Option<Disr> = None;\n-                @enum_definition.variants.iter().map(|&variant| {\n-\n-                    let mut discriminant = match last_discriminant {\n-                        Some(val) => val + 1,\n-                        None => INITIAL_DISCRIMINANT_VALUE\n-                    };\n-\n-                    match variant.node.disr_expr {\n-                        Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n-                            Ok(const_eval::const_int(val)) => discriminant = val as Disr,\n-                            Ok(const_eval::const_uint(val)) => discriminant = val as Disr,\n-                            Ok(_) => {\n-                                cx.sess.span_err(e.span, \"expected signed integer constant\");\n-                            }\n-                            Err(ref err) => {\n-                                cx.sess.span_err(e.span, format!(\"expected constant: {}\", (*err)));\n-                            }\n-                        },\n-                        None => {}\n-                    };\n-\n-                    let variant_info = @VariantInfo::from_ast_variant(cx, variant, discriminant);\n-                    last_discriminant = Some(discriminant);\n-                    variant_info\n-\n-                }).collect()\n+              ast_map::NodeItem(item, _) => {\n+                  match item.node {\n+                    ast::ItemEnum(ref enum_definition, _) => {\n+                        let mut last_discriminant: Option<Disr> = None;\n+                        @enum_definition.variants.iter().map(|&variant| {\n+\n+                            let mut discriminant = match last_discriminant {\n+                                Some(val) => val + 1,\n+                                None => INITIAL_DISCRIMINANT_VALUE\n+                            };\n+\n+                            match variant.node.disr_expr {\n+                                Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n+                                    Ok(const_eval::const_int(val)) => {\n+                                        discriminant = val as Disr\n+                                    }\n+                                    Ok(const_eval::const_uint(val)) => {\n+                                        discriminant = val as Disr\n+                                    }\n+                                    Ok(_) => {\n+                                        cx.sess\n+                                          .span_err(e.span,\n+                                                    \"expected signed integer \\\n+                                                     constant\");\n+                                    }\n+                                    Err(ref err) => {\n+                                        cx.sess\n+                                          .span_err(e.span,\n+                                                    format!(\"expected \\\n+                                                             constant: {}\",\n+                                                            (*err)));\n+                                    }\n+                                },\n+                                None => {}\n+                            };\n+\n+                            let variant_info =\n+                                @VariantInfo::from_ast_variant(cx,\n+                                                               variant,\n+                                                               discriminant);\n+                            last_discriminant = Some(discriminant);\n+                            variant_info\n+\n+                        }).collect()\n+                    }\n+                    _ => {\n+                        cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+                    }\n+                  }\n               }\n               _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n             }\n@@ -4038,11 +4095,9 @@ pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n         {\n             let items = tcx.items.borrow();\n             match items.get().find(&did.node) {\n-                Some(&ast_map::NodeItem(@ast::Item {\n-                    attrs: ref attrs,\n-                    ..\n-                }, _)) =>\n-                    attrs.iter().advance(|attr| f(attr.node.value)),\n+                Some(&ast_map::NodeItem(item, _)) => {\n+                    item.attrs.iter().advance(|attr| f(attr.node.value))\n+                }\n                 _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n                                           did))\n             }"}, {"sha": "0d7a1258972c4024f4ec7146433964817b9f6974", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -585,9 +585,6 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             }\n         }\n       }\n-      ast::PatBox(inner) => {\n-          check_pointer_pat(pcx, Managed, inner, pat.id, pat.span, expected);\n-      }\n       ast::PatUniq(inner) => {\n           check_pointer_pat(pcx, Send, inner, pat.id, pat.span, expected);\n       }\n@@ -672,9 +669,6 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n         fcx.write_ty(pat_id, expected);\n     };\n     match *structure_of(fcx, span, expected) {\n-        ty::ty_box(e_inner) if pointer_kind == Managed => {\n-            check_inner(e_inner);\n-        }\n         ty::ty_uniq(e_inner) if pointer_kind == Send => {\n             check_inner(e_inner.ty);\n         }\n@@ -692,7 +686,6 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                              e, actual)})},\n                 Some(expected),\n                 format!(\"{} pattern\", match pointer_kind {\n-                    Managed => \"an @-box\",\n                     Send => \"a ~-box\",\n                     Borrowed => \"an &-pointer\"\n                 }),\n@@ -703,5 +696,5 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n }\n \n #[deriving(Eq)]\n-enum PointerKind { Managed, Send, Borrowed }\n+enum PointerKind { Send, Borrowed }\n "}, {"sha": "910b0dbf7d891c2ded4fc7609948f1b84f65cf9d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -1309,10 +1309,15 @@ impl<'a> LookupContext<'a> {\n             {\n                 let items = self.tcx().items.borrow();\n                 match items.get().find(&did.node) {\n-                  Some(&ast_map::NodeMethod(m, _, _))\n-                  | Some(&ast_map::NodeTraitMethod(@ast::Provided(m),\n-                                                   _, _)) => {\n-                      m.span\n+                  Some(&ast_map::NodeMethod(m, _, _)) => m.span,\n+                  Some(&ast_map::NodeTraitMethod(trait_method, _, _)) => {\n+                      match *trait_method {\n+                          ast::Provided(m) => m.span,\n+                          _ => {\n+                              fail!(\"report_static_candidate, bad item {:?}\",\n+                                    did)\n+                          }\n+                      }\n                   }\n                   _ => fail!(\"report_static_candidate: bad item {:?}\", did)\n                 }"}, {"sha": "e2cad2b8e85ffe4e9f41c8bfd46f39cd46348be7", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -2627,7 +2627,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     match expr.node {\n       ast::ExprVstore(ev, vst) => {\n         let typ = match ev.node {\n-          ast::ExprLit(@codemap::Spanned { node: ast::LitStr(..), .. }) => {\n+          ast::ExprLit(lit) if ast_util::lit_is_str(lit) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             ty::mk_str(tcx, tt)\n           }\n@@ -3487,11 +3487,13 @@ pub fn check_block_with_expected(fcx: @FnCtxt,\n             let s_id = ast_util::stmt_id(*s);\n             let s_ty = fcx.node_ty(s_id);\n             if last_was_bot && !warned && match s.node {\n-                  ast::StmtDecl(@codemap::Spanned { node: ast::DeclLocal(_),\n-                                                 ..}, _) |\n-                  ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => {\n-                    true\n+                  ast::StmtDecl(decl, _) => {\n+                      match decl.node {\n+                          ast::DeclLocal(_) => true,\n+                          _ => false,\n+                      }\n                   }\n+                  ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => true,\n                   _ => false\n                 } {\n                 fcx.ccx.tcx.sess.add_lint(UnreachableCode, s_id, s.span,"}, {"sha": "ad0482cf4f42e2439a9d7fcd20d6aeac40ebef8d", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -310,8 +310,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         let r = adjustments.get().find(&expr.id);\n         for &adjustment in r.iter() {\n             debug!(\"adjustment={:?}\", adjustment);\n-            match *adjustment {\n-                @ty::AutoDerefRef(\n+            match **adjustment {\n+                ty::AutoDerefRef(\n                     ty::AutoDerefRef {autoderefs: autoderefs, autoref: opt_autoref}) =>\n                 {\n                     let expr_ty = rcx.resolve_node_type(expr.id);\n@@ -328,7 +328,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                             infer::AutoBorrow(expr.span));\n                     }\n                 }\n-                @ty::AutoObject(ast::BorrowedSigil, Some(trait_region), _, _, _, _) => {\n+                ty::AutoObject(ast::BorrowedSigil, Some(trait_region), _, _, _, _) => {\n                     // Determine if we are casting `expr` to an trait\n                     // instance.  If so, we have to be sure that the type of\n                     // the source obeys the trait's region bound.\n@@ -1086,66 +1086,75 @@ pub mod guarantor {\n \n         let adjustments = rcx.fcx.inh.adjustments.borrow();\n         match adjustments.get().find(&expr.id) {\n-            Some(&@ty::AutoAddEnv(..)) => {\n-                // This is basically an rvalue, not a pointer, no regions\n-                // involved.\n-                expr_ct.cat = ExprCategorization {\n-                    guarantor: None,\n-                    pointer: NotPointer\n-                };\n-            }\n-\n-            Some(&@ty::AutoObject(ast::BorrowedSigil, Some(region), _, _, _, _)) => {\n-                expr_ct.cat = ExprCategorization {\n-                    guarantor: None,\n-                    pointer: BorrowedPointer(region)\n-                };\n-            }\n-\n-            Some(&@ty::AutoObject(ast::OwnedSigil, _, _, _, _, _)) => {\n-                expr_ct.cat = ExprCategorization {\n-                    guarantor: None,\n-                    pointer: OwnedPointer\n-                };\n-            }\n-\n-            Some(&@ty::AutoObject(ast::ManagedSigil, _, _, _, _, _)) => {\n-                expr_ct.cat = ExprCategorization {\n-                    guarantor: None,\n-                    pointer: OtherPointer\n-                };\n-            }\n-\n-            Some(&@ty::AutoDerefRef(ref adjustment)) => {\n-                debug!(\"adjustment={:?}\", adjustment);\n+            Some(adjustment) => {\n+                match **adjustment {\n+                    ty::AutoAddEnv(..) => {\n+                        // This is basically an rvalue, not a pointer, no regions\n+                        // involved.\n+                        expr_ct.cat = ExprCategorization {\n+                            guarantor: None,\n+                            pointer: NotPointer\n+                        };\n+                    }\n \n-                expr_ct = apply_autoderefs(\n-                    rcx, expr, adjustment.autoderefs, expr_ct);\n+                    ty::AutoObject(ast::BorrowedSigil,\n+                                   Some(region),\n+                                   _,\n+                                   _,\n+                                   _,\n+                                   _) => {\n+                        expr_ct.cat = ExprCategorization {\n+                            guarantor: None,\n+                            pointer: BorrowedPointer(region)\n+                        };\n+                    }\n \n-                match adjustment.autoref {\n-                    None => {\n+                    ty::AutoObject(ast::OwnedSigil, _, _, _, _, _) => {\n+                        expr_ct.cat = ExprCategorization {\n+                            guarantor: None,\n+                            pointer: OwnedPointer\n+                        };\n                     }\n-                    Some(ty::AutoUnsafe(_)) => {\n-                        expr_ct.cat.guarantor = None;\n-                        expr_ct.cat.pointer = OtherPointer;\n-                        debug!(\"autoref, cat={:?}\", expr_ct.cat);\n+\n+                    ty::AutoObject(ast::ManagedSigil, _, _, _, _, _) => {\n+                        expr_ct.cat = ExprCategorization {\n+                            guarantor: None,\n+                            pointer: OtherPointer\n+                        };\n                     }\n-                    Some(ty::AutoPtr(r, _)) |\n-                    Some(ty::AutoBorrowVec(r, _)) |\n-                    Some(ty::AutoBorrowVecRef(r, _)) |\n-                    Some(ty::AutoBorrowFn(r)) |\n-                    Some(ty::AutoBorrowObj(r, _)) => {\n-                        // If there is an autoref, then the result of this\n-                        // expression will be some sort of reference.\n-                        expr_ct.cat.guarantor = None;\n-                        expr_ct.cat.pointer = BorrowedPointer(r);\n-                        debug!(\"autoref, cat={:?}\", expr_ct.cat);\n+                    ty::AutoDerefRef(ref adjustment) => {\n+                        debug!(\"adjustment={:?}\", adjustment);\n+\n+                        expr_ct = apply_autoderefs(\n+                            rcx, expr, adjustment.autoderefs, expr_ct);\n+\n+                        match adjustment.autoref {\n+                            None => {\n+                            }\n+                            Some(ty::AutoUnsafe(_)) => {\n+                                expr_ct.cat.guarantor = None;\n+                                expr_ct.cat.pointer = OtherPointer;\n+                                debug!(\"autoref, cat={:?}\", expr_ct.cat);\n+                            }\n+                            Some(ty::AutoPtr(r, _)) |\n+                            Some(ty::AutoBorrowVec(r, _)) |\n+                            Some(ty::AutoBorrowVecRef(r, _)) |\n+                            Some(ty::AutoBorrowFn(r)) |\n+                            Some(ty::AutoBorrowObj(r, _)) => {\n+                                // If there is an autoref, then the result of\n+                                // this expression will be some sort of\n+                                // reference.\n+                                expr_ct.cat.guarantor = None;\n+                                expr_ct.cat.pointer = BorrowedPointer(r);\n+                                debug!(\"autoref, cat={:?}\", expr_ct.cat);\n+                            }\n+                        }\n                     }\n+\n+                    _ => fail!(\"invalid or unhandled adjustment\"),\n                 }\n             }\n \n-            Some(..) => fail!(\"invalid or unhandled adjustment\"),\n-\n             None => {}\n         }\n \n@@ -1298,9 +1307,6 @@ pub mod guarantor {\n             ast::PatTup(ref ps) => {\n                 link_ref_bindings_in_pats(rcx, ps, guarantor)\n             }\n-            ast::PatBox(p) => {\n-                link_ref_bindings_in_pat(rcx, p, None)\n-            }\n             ast::PatUniq(p) => {\n                 link_ref_bindings_in_pat(rcx, p, guarantor)\n             }"}, {"sha": "9b9a211ea71ae9ba5f999b7b0bac230950c3816e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -741,15 +741,33 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n     // Search for auto-adjustments to find trait coercions\n     let adjustments = fcx.inh.adjustments.borrow();\n     match adjustments.get().find(&ex.id) {\n-        Some(&@AutoObject(ref sigil, ref region, m, b, def_id, ref substs)) => {\n-            debug!(\"doing trait adjustment for expr {} {} (early? {})\",\n-                   ex.id, ex.repr(fcx.tcx()), is_early);\n-\n-            let object_ty = ty::trait_adjustment_to_ty(cx.tcx, sigil, region,\n-                                                       def_id, substs, m, b);\n-            resolve_object_cast(ex, object_ty);\n+        Some(adjustment) => {\n+            match **adjustment {\n+                AutoObject(ref sigil,\n+                           ref region,\n+                           m,\n+                           b,\n+                           def_id,\n+                           ref substs) => {\n+                    debug!(\"doing trait adjustment for expr {} {} \\\n+                            (early? {})\",\n+                           ex.id,\n+                           ex.repr(fcx.tcx()),\n+                           is_early);\n+\n+                    let object_ty = ty::trait_adjustment_to_ty(cx.tcx,\n+                                                               sigil,\n+                                                               region,\n+                                                               def_id,\n+                                                               substs,\n+                                                               m,\n+                                                               b);\n+                    resolve_object_cast(ex, object_ty);\n+                }\n+                AutoAddEnv(..) | AutoDerefRef(..) => {}\n+            }\n         }\n-        Some(&@AutoAddEnv(..)) | Some(&@AutoDerefRef(..)) | None => {}\n+        None => {}\n     }\n }\n "}, {"sha": "2237c2f43e1934790ebc150901b755ccc7d8344b", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -140,55 +140,71 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n     match adjustment {\n         None => (),\n \n-        Some(@ty::AutoAddEnv(r, s)) => {\n-            match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n-                Err(e) => {\n-                    // This should not, I think, happen:\n-                    fcx.ccx.tcx.sess.span_err(\n-                        sp, format!(\"cannot resolve bound for closure: {}\",\n-                                 infer::fixup_err_to_str(e)));\n+        Some(adjustment) => {\n+            match *adjustment {\n+                ty::AutoAddEnv(r, s) => {\n+                    match resolve_region(fcx.infcx(),\n+                                         r,\n+                                         resolve_all | force_all) {\n+                        Err(e) => {\n+                            // This should not, I think, happen:\n+                            fcx.ccx.tcx.sess.span_err(\n+                                sp,\n+                                format!(\"cannot resolve bound for closure: \\\n+                                         {}\",\n+                                        infer::fixup_err_to_str(e)));\n+                        }\n+                        Ok(r1) => {\n+                            let resolved_adj = @ty::AutoAddEnv(r1, s);\n+                            debug!(\"Adjustments for node {}: {:?}\",\n+                                   id,\n+                                   resolved_adj);\n+                            let mut adjustments = fcx.tcx()\n+                                                     .adjustments\n+                                                     .borrow_mut();\n+                            adjustments.get().insert(id, resolved_adj);\n+                        }\n+                    }\n                 }\n-                Ok(r1) => {\n-                    let resolved_adj = @ty::AutoAddEnv(r1, s);\n+\n+                ty::AutoDerefRef(adj) => {\n+                    let fixup_region = |r| {\n+                        match resolve_region(fcx.infcx(),\n+                                             r,\n+                                             resolve_all | force_all) {\n+                            Ok(r1) => r1,\n+                            Err(e) => {\n+                                // This should not, I think, happen.\n+                                fcx.ccx.tcx.sess.span_err(\n+                                    sp,\n+                                    format!(\"cannot resolve scope of borrow: \\\n+                                             {}\",\n+                                             infer::fixup_err_to_str(e)));\n+                                r\n+                            }\n+                        }\n+                    };\n+\n+                    let resolved_autoref = match adj.autoref {\n+                        None => None,\n+                        Some(ref r) => Some(r.map_region(fixup_region))\n+                    };\n+\n+                    let resolved_adj = @ty::AutoDerefRef(ty::AutoDerefRef {\n+                        autoderefs: adj.autoderefs,\n+                        autoref: resolved_autoref,\n+                    });\n                     debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n                     let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n                     adjustments.get().insert(id, resolved_adj);\n                 }\n-            }\n-        }\n \n-        Some(@ty::AutoDerefRef(adj)) => {\n-            let fixup_region = |r| {\n-                match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n-                    Ok(r1) => r1,\n-                    Err(e) => {\n-                        // This should not, I think, happen.\n-                        fcx.ccx.tcx.sess.span_err(\n-                            sp, format!(\"cannot resolve scope of borrow: {}\",\n-                                     infer::fixup_err_to_str(e)));\n-                        r\n-                    }\n+                ty::AutoObject(..) => {\n+                    debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n+                    let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n+                    adjustments.get().insert(id, adjustment);\n                 }\n-            };\n-\n-            let resolved_autoref = match adj.autoref {\n-                None => None,\n-                Some(ref r) => Some(r.map_region(fixup_region))\n-            };\n-\n-            let resolved_adj = @ty::AutoDerefRef(ty::AutoDerefRef {\n-                autoderefs: adj.autoderefs,\n-                autoref: resolved_autoref,\n-            });\n-            debug!(\"Adjustments for node {}: {:?}\", id, resolved_adj);\n-            let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n-            adjustments.get().insert(id, resolved_adj);\n-        }\n-\n-        Some(adjustment @ @ty::AutoObject(..)) => {\n-            debug!(\"Adjustments for node {}: {:?}\", id, adjustment);\n-            let mut adjustments = fcx.tcx().adjustments.borrow_mut();\n-            adjustments.get().insert(id, adjustment);\n+            }\n         }\n     }\n "}, {"sha": "c58b9fb83bba1824c73fd7d2a12bc48c33641e06", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -736,7 +736,7 @@ impl CoherenceChecker {\n                         {\n                             let items = tcx.items.borrow();\n                             match items.get().find(&impl_info.did.node) {\n-                                Some(&ast_map::NodeItem(@ref item, _)) => {\n+                                Some(&ast_map::NodeItem(item, _)) => {\n                                     tcx.sess.span_err((*item).span,\n                                                       \"the Drop trait may \\\n                                                        only be implemented \\"}, {"sha": "eaf6cea244b90e372e3a45547ea2e520d14c2b5f", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -183,59 +183,63 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn ensure_trait_methods(ccx: &CrateCtxt,\n-                            trait_id: ast::NodeId)\n-{\n+pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n     let tcx = ccx.tcx;\n     let items = tcx.items.borrow();\n     match items.get().get_copy(&trait_id) {\n-        ast_map::NodeItem(@ast::Item {\n-            node: ast::ItemTrait(ref generics, _, ref ms),\n-            ..\n-        }, _) => {\n-            let trait_ty_generics =\n-                ty_generics(ccx, generics, 0);\n-\n-            // For each method, construct a suitable ty::Method and\n-            // store it into the `tcx.methods` table:\n-            for m in ms.iter() {\n-                let ty_method = @match m {\n-                    &ast::Required(ref m) => {\n-                        ty_method_of_trait_method(\n-                            ccx, trait_id, &trait_ty_generics,\n-                            &m.id, &m.ident, &m.explicit_self,\n-                            &m.generics, &m.purity, m.decl)\n+        ast_map::NodeItem(item, _) => {\n+            match item.node {\n+                ast::ItemTrait(ref generics, _, ref ms) => {\n+                    let trait_ty_generics = ty_generics(ccx, generics, 0);\n+\n+                    // For each method, construct a suitable ty::Method and\n+                    // store it into the `tcx.methods` table:\n+                    for m in ms.iter() {\n+                        let ty_method = @match m {\n+                            &ast::Required(ref m) => {\n+                                ty_method_of_trait_method(\n+                                    ccx, trait_id, &trait_ty_generics,\n+                                    &m.id, &m.ident, &m.explicit_self,\n+                                    &m.generics, &m.purity, m.decl)\n+                            }\n+\n+                            &ast::Provided(ref m) => {\n+                                ty_method_of_trait_method(\n+                                    ccx, trait_id, &trait_ty_generics,\n+                                    &m.id, &m.ident, &m.explicit_self,\n+                                    &m.generics, &m.purity, m.decl)\n+                            }\n+                        };\n+\n+                        if ty_method.explicit_self == ast::SelfStatic {\n+                            make_static_method_ty(ccx, trait_id, ty_method,\n+                                                  &trait_ty_generics);\n+                        }\n+\n+                        let mut methods = tcx.methods.borrow_mut();\n+                        methods.get().insert(ty_method.def_id, ty_method);\n                     }\n \n-                    &ast::Provided(ref m) => {\n-                        ty_method_of_trait_method(\n-                            ccx, trait_id, &trait_ty_generics,\n-                            &m.id, &m.ident, &m.explicit_self,\n-                            &m.generics, &m.purity, m.decl)\n-                    }\n-                };\n+                    // Add an entry mapping\n+                    let method_def_ids = @ms.map(|m| {\n+                        match m {\n+                            &ast::Required(ref ty_method) => {\n+                                local_def(ty_method.id)\n+                            }\n+                            &ast::Provided(ref method) => {\n+                                local_def(method.id)\n+                            }\n+                        }\n+                    });\n \n-                if ty_method.explicit_self == ast::SelfStatic {\n-                    make_static_method_ty(ccx, trait_id, ty_method,\n-                                          &trait_ty_generics);\n+                    let trait_def_id = local_def(trait_id);\n+                    let mut trait_method_def_ids = tcx.trait_method_def_ids\n+                                                      .borrow_mut();\n+                    trait_method_def_ids.get().insert(trait_def_id,\n+                                                      method_def_ids);\n                 }\n-\n-                let mut methods = tcx.methods.borrow_mut();\n-                methods.get().insert(ty_method.def_id, ty_method);\n+                _ => {} // Ignore things that aren't traits.\n             }\n-\n-            // Add an entry mapping\n-            let method_def_ids = @ms.map(|m| {\n-                match m {\n-                    &ast::Required(ref ty_method) => local_def(ty_method.id),\n-                    &ast::Provided(ref method) => local_def(method.id)\n-                }\n-            });\n-\n-            let trait_def_id = local_def(trait_id);\n-            let mut trait_method_def_ids = tcx.trait_method_def_ids\n-                                              .borrow_mut();\n-            trait_method_def_ids.get().insert(trait_def_id, method_def_ids);\n         }\n         _ => { /* Ignore things that aren't traits */ }\n     }"}, {"sha": "2b03ece5d5aff726ee7015598e5d3b156aea3ec2", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -1142,7 +1142,6 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n         PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n         PatTup(..) => ~\"(tuple arg NYI)\",\n-        PatBox(p) => name_from_pat(p),\n         PatUniq(p) => name_from_pat(p),\n         PatRegion(p) => name_from_pat(p),\n         PatLit(..) => {"}, {"sha": "ab16ab153d9c06ff1a674d42fdf52628d893386b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -369,7 +369,6 @@ pub enum Pat_ {\n                                        * we don't bind the fields to names */\n     PatStruct(Path, ~[FieldPat], bool),\n     PatTup(~[@Pat]),\n-    PatBox(@Pat),\n     PatUniq(@Pat),\n     PatRegion(@Pat), // reference pattern\n     PatLit(@Expr),"}, {"sha": "9cb4f14caf023178441aa99a86fbf03ad5274268", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -507,8 +507,12 @@ pub fn node_span(items: Map, id: ast::NodeId) -> Span {\n     match items.get().find(&id) {\n         Some(&NodeItem(item, _)) => item.span,\n         Some(&NodeForeignItem(foreign_item, _, _, _)) => foreign_item.span,\n-        Some(&NodeTraitMethod(@Required(ref type_method), _, _)) => type_method.span,\n-        Some(&NodeTraitMethod(@Provided(ref method), _, _)) => method.span,\n+        Some(&NodeTraitMethod(trait_method, _, _)) => {\n+            match *trait_method {\n+                Required(ref type_method) => type_method.span,\n+                Provided(ref method) => method.span,\n+            }\n+        }\n         Some(&NodeMethod(method, _, _)) => method.span,\n         Some(&NodeVariant(variant, _, _)) => variant.span,\n         Some(&NodeExpr(expr)) => expr.span,"}, {"sha": "3e0caab65c24096dce0ecec407170fd7e0d5e319", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -614,7 +614,7 @@ pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n         PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n             s.iter().advance(|&p| walk_pat(p, |p| it(p)))\n         }\n-        PatBox(s) | PatUniq(s) | PatRegion(s) => {\n+        PatUniq(s) | PatRegion(s) => {\n             walk_pat(s, it)\n         }\n         PatVec(ref before, ref slice, ref after) => {\n@@ -945,6 +945,15 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n     }\n }\n \n+// Returns true if this literal is a string and false otherwise.\n+pub fn lit_is_str(lit: @Lit) -> bool {\n+    match lit.node {\n+        LitStr(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+\n #[cfg(test)]\n mod test {\n     use ast::*;"}, {"sha": "8515c3aba50194bdbdef7e388a1cc7f4fefb9460", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -324,7 +324,7 @@ impl ExtCtxt {\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n         match self.backtrace {\n-            Some(@ExpnInfo {call_site: cs, ..}) => cs,\n+            Some(expn_info) => expn_info.call_site,\n             None => self.bug(\"missing top span\")\n         }\n     }\n@@ -346,10 +346,7 @@ impl ExtCtxt {\n     }\n     pub fn bt_pop(&mut self) {\n         match self.backtrace {\n-            Some(@ExpnInfo {\n-                call_site: Span {expn_info: prev, ..}, ..}) => {\n-                self.backtrace = prev\n-            }\n+            Some(expn_info) => self.backtrace = expn_info.call_site.expn_info,\n             _ => self.bug(\"tried to pop without a push\")\n         }\n     }"}, {"sha": "303277afbe84f94dccd99ded144c26188b2df786", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -471,63 +471,66 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                          -> SmallVector<@Stmt> {\n     // is it a let?\n     match s.node {\n-        StmtDecl(@Spanned {\n-            node: DeclLocal(ref local),\n-            span: stmt_span\n-        },\n-        node_id) => {\n-\n-            // take it apart:\n-            let @Local {\n-                ty: _,\n-                pat: pat,\n-                init: init,\n-                id: id,\n-                span: span\n-            } = *local;\n-            // expand the pat (it might contain exprs... #:(o)>\n-            let expanded_pat = fld.fold_pat(pat);\n-            // find the pat_idents in the pattern:\n-            // oh dear heaven... this is going to include the enum names, as well....\n-            // ... but that should be okay, as long as the new names are gensyms\n-            // for the old ones.\n-            let mut name_finder = new_name_finder(~[]);\n-            name_finder.visit_pat(expanded_pat,());\n-            // generate fresh names, push them to a new pending list\n-            let mut new_pending_renames = ~[];\n-            for ident in name_finder.ident_accumulator.iter() {\n-                let new_name = fresh_name(ident);\n-                new_pending_renames.push((*ident,new_name));\n-            }\n-            let rewritten_pat = {\n-                let mut rename_fld =\n-                    renames_to_fold(&mut new_pending_renames);\n-                // rewrite the pattern using the new names (the old ones\n-                // have already been applied):\n-                rename_fld.fold_pat(expanded_pat)\n-            };\n-            // add them to the existing pending renames:\n-            for pr in new_pending_renames.iter() {\n-                fld.extsbox.info().pending_renames.push(*pr)\n+        StmtDecl(decl, node_id) => {\n+            match *decl {\n+                Spanned {\n+                    node: DeclLocal(ref local),\n+                    span: stmt_span\n+                } => {\n+                    // take it apart:\n+                    let Local {\n+                        ty: _,\n+                        pat: pat,\n+                        init: init,\n+                        id: id,\n+                        span: span\n+                    } = **local;\n+                    // expand the pat (it might contain exprs... #:(o)>\n+                    let expanded_pat = fld.fold_pat(pat);\n+                    // find the pat_idents in the pattern:\n+                    // oh dear heaven... this is going to include the enum\n+                    // names, as well... but that should be okay, as long as\n+                    // the new names are gensyms for the old ones.\n+                    let mut name_finder = new_name_finder(~[]);\n+                    name_finder.visit_pat(expanded_pat,());\n+                    // generate fresh names, push them to a new pending list\n+                    let mut new_pending_renames = ~[];\n+                    for ident in name_finder.ident_accumulator.iter() {\n+                        let new_name = fresh_name(ident);\n+                        new_pending_renames.push((*ident,new_name));\n+                    }\n+                    let rewritten_pat = {\n+                        let mut rename_fld =\n+                            renames_to_fold(&mut new_pending_renames);\n+                        // rewrite the pattern using the new names (the old\n+                        // ones have already been applied):\n+                        rename_fld.fold_pat(expanded_pat)\n+                    };\n+                    // add them to the existing pending renames:\n+                    for pr in new_pending_renames.iter() {\n+                        fld.extsbox.info().pending_renames.push(*pr)\n+                    }\n+                    // also, don't forget to expand the init:\n+                    let new_init_opt = init.map(|e| fld.fold_expr(e));\n+                    let rewritten_local =\n+                        @Local {\n+                            ty: local.ty,\n+                            pat: rewritten_pat,\n+                            init: new_init_opt,\n+                            id: id,\n+                            span: span,\n+                        };\n+                    SmallVector::one(@Spanned {\n+                        node: StmtDecl(@Spanned {\n+                                node: DeclLocal(rewritten_local),\n+                                span: stmt_span\n+                            },\n+                            node_id),\n+                        span: span\n+                    })\n+                }\n+                _ => noop_fold_stmt(s, fld),\n             }\n-            // also, don't forget to expand the init:\n-            let new_init_opt = init.map(|e| fld.fold_expr(e));\n-            let rewritten_local =\n-                @Local {\n-                    ty: local.ty,\n-                    pat: rewritten_pat,\n-                    init: new_init_opt,\n-                    id: id,\n-                    span: span,\n-                };\n-            SmallVector::one(@Spanned {\n-                node: StmtDecl(@Spanned {\n-                        node: DeclLocal(rewritten_local),\n-                        span: stmt_span\n-                    },\n-                    node_id),\n-                span: span\n-            })\n         },\n         _ => noop_fold_stmt(s, fld),\n     }"}, {"sha": "cb7d54d73052974f3354290f9df10ba8db08e38a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -126,15 +126,15 @@ fn generic_extension(cx: &ExtCtxt,\n     let s_d = cx.parse_sess().span_diagnostic;\n \n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n-        match *lhs {\n-          @MatchedNonterminal(NtMatchers(ref mtcs)) => {\n+        match **lhs {\n+          MatchedNonterminal(NtMatchers(ref mtcs)) => {\n             // `none` is because we're not interpolating\n             let arg_rdr = new_tt_reader(s_d, None, arg.to_owned()) as @Reader;\n             match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n               Success(named_matches) => {\n-                let rhs = match rhses[i] {\n+                let rhs = match *rhses[i] {\n                     // okay, what's your transcriber?\n-                    @MatchedNonterminal(NtTT(@ref tt)) => {\n+                    MatchedNonterminal(NtTT(tt)) => {\n                         match (*tt) {\n                             // cut off delimiters; don't parse 'em\n                             TTDelim(ref tts) => {\n@@ -214,13 +214,13 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n                                      argument_gram);\n \n     // Extract the arguments:\n-    let lhses = match *argument_map.get(&lhs_nm) {\n-        @MatchedSeq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n+    let lhses = match **argument_map.get(&lhs_nm) {\n+        MatchedSeq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured lhs\")\n     };\n \n-    let rhses = match *argument_map.get(&rhs_nm) {\n-        @MatchedSeq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n+    let rhses = match **argument_map.get(&rhs_nm) {\n+        MatchedSeq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n "}, {"sha": "d3862cdf1a168bcd615344e0ce0c12454d4ac460", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -687,7 +687,6 @@ pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n             PatStruct(pth_, fs, etc)\n         }\n         PatTup(ref elts) => PatTup(elts.map(|x| folder.fold_pat(*x))),\n-        PatBox(inner) => PatBox(folder.fold_pat(inner)),\n         PatUniq(inner) => PatUniq(folder.fold_pat(inner)),\n         PatRegion(inner) => PatRegion(folder.fold_pat(inner)),\n         PatRange(e1, e2) => {"}, {"sha": "6aa1afee206ebe42f65eaffc1f5a89568205d818", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -44,7 +44,8 @@ pub enum ObsoleteSyntax {\n     ObsoleteBoxedClosure,\n     ObsoleteClosureType,\n     ObsoleteMultipleImport,\n-    ObsoleteExternModAttributesInParens\n+    ObsoleteExternModAttributesInParens,\n+    ObsoleteManagedPattern,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -148,7 +149,12 @@ impl ParserObsoleteMethods for Parser {\n                 \"`extern mod` with linkage attribute list\",\n                 \"use `extern mod foo = \\\"bar\\\";` instead of \\\n                 `extern mod foo (name = \\\"bar\\\")`\"\n-            )\n+            ),\n+            ObsoleteManagedPattern => (\n+                \"managed pointer pattern\",\n+                \"use a nested `match` expression instead of a managed box \\\n+                 pattern\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "715ce644726ab888d235eeee53efec9270a418de", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 67, "deletions": 56, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -40,7 +40,7 @@ use ast::{LitBool, LitFloat, LitFloatUnsuffixed, LitInt, LitChar};\n use ast::{LitIntUnsuffixed, LitNil, LitStr, LitUint, Local};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal};\n use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n-use ast::{NamedField, UnNeg, NoReturn, UnNot, P, Pat, PatBox, PatEnum};\n+use ast::{NamedField, UnNeg, NoReturn, UnNot, P, Pat, PatEnum};\n use ast::{PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatUniq, PatWild, PatWildMulti, Private};\n use ast::{BiRem, Required};\n@@ -60,7 +60,7 @@ use ast::{ViewItem_, ViewItemExternMod, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::Visibility;\n use ast;\n-use ast_util::{as_prec, operator_prec};\n+use ast_util::{as_prec, lit_is_str, operator_prec};\n use ast_util;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n use codemap;\n@@ -2278,10 +2278,10 @@ impl Parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-vec\n                 ex = match e.node {\n-                  ExprVec(..) | ExprLit(@codemap::Spanned {\n-                    node: LitStr(..), span: _\n-                  })\n-                  if m == MutImmutable => {\n+                  ExprVec(..) if m == MutImmutable => {\n+                    ExprVstore(e, ExprVstoreSlice)\n+                  }\n+                  ExprLit(lit) if lit_is_str(lit) && m == MutImmutable => {\n                     ExprVstore(e, ExprVstoreSlice)\n                   }\n                   ExprVec(..) if m == MutMutable => {\n@@ -2300,8 +2300,8 @@ impl Parser {\n             // HACK: turn @[...] into a @-vec\n             ex = match e.node {\n               ExprVec(..) |\n-              ExprLit(@codemap::Spanned { node: LitStr(..), span: _}) |\n               ExprRepeat(..) => ExprVstore(e, ExprVstoreBox),\n+              ExprLit(lit) if lit_is_str(lit) => ExprVstore(e, ExprVstoreBox),\n               _ => self.mk_unary(UnBox, e)\n             };\n           }\n@@ -2312,9 +2312,10 @@ impl Parser {\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-vec\n             ex = match e.node {\n-              ExprVec(..) |\n-              ExprLit(@codemap::Spanned { node: LitStr(..), span: _}) |\n-              ExprRepeat(..) => ExprVstore(e, ExprVstoreUniq),\n+              ExprVec(..) | ExprRepeat(..) => ExprVstore(e, ExprVstoreUniq),\n+              ExprLit(lit) if lit_is_str(lit) => {\n+                  ExprVstore(e, ExprVstoreUniq)\n+              }\n               _ => self.mk_unary(UnUniq, e)\n             };\n           }\n@@ -2339,12 +2340,12 @@ impl Parser {\n             hi = subexpression.span.hi;\n             // HACK: turn `box [...]` into a boxed-vec\n             ex = match subexpression.node {\n-                ExprVec(..) |\n-                ExprLit(@codemap::Spanned {\n-                    node: LitStr(..),\n-                    span: _\n-                }) |\n-                ExprRepeat(..) => ExprVstore(subexpression, ExprVstoreUniq),\n+                ExprVec(..) | ExprRepeat(..) => {\n+                    ExprVstore(subexpression, ExprVstoreUniq)\n+                }\n+                ExprLit(lit) if lit_is_str(lit) => {\n+                    ExprVstore(subexpression, ExprVstoreUniq)\n+                }\n                 _ => self.mk_unary(UnUniq, subexpression)\n             };\n           }\n@@ -2769,19 +2770,19 @@ impl Parser {\n                     })\n                 } else {\n                     let subpat = self.parse_pat();\n-                    match subpat {\n-                        @ast::Pat { id, node: PatWild, span } => {\n+                    match *subpat {\n+                        ast::Pat { id, node: PatWild, span } => {\n                             self.obsolete(self.span, ObsoleteVecDotDotWildcard);\n                             slice = Some(@ast::Pat {\n                                 id: id,\n                                 node: PatWildMulti,\n                                 span: span\n                             })\n                         },\n-                        @ast::Pat { node: PatIdent(_, _, _), .. } => {\n+                        ast::Pat { node: PatIdent(_, _, _), .. } => {\n                             slice = Some(subpat);\n                         }\n-                        @ast::Pat { span, .. } => self.span_fatal(\n+                        ast::Pat { span, .. } => self.span_fatal(\n                             span, \"expected an identifier or nothing\"\n                         )\n                     }\n@@ -2891,19 +2892,26 @@ impl Parser {\n             hi = sub.span.hi;\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n-              PatLit(e@@Expr {\n-                node: ExprLit(@codemap::Spanned {\n-                    node: LitStr(..),\n-                    span: _}), ..\n-              }) => {\n-                let vst = @Expr {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: ExprVstore(e, ExprVstoreBox),\n-                    span: mk_sp(lo, hi),\n-                };\n-                PatLit(vst)\n+              PatLit(e) => {\n+                  match e.node {\n+                      ExprLit(lit) if lit_is_str(lit) => {\n+                        let vst = @Expr {\n+                            id: ast::DUMMY_NODE_ID,\n+                            node: ExprVstore(e, ExprVstoreBox),\n+                            span: mk_sp(lo, hi),\n+                        };\n+                        PatLit(vst)\n+                      }\n+                      _ => {\n+                        self.obsolete(self.span, ObsoleteManagedPattern);\n+                        PatUniq(sub)\n+                      }\n+                  }\n+              }\n+              _ => {\n+                self.obsolete(self.span, ObsoleteManagedPattern);\n+                PatUniq(sub)\n               }\n-              _ => PatBox(sub)\n             };\n             hi = self.last_span.hi;\n             return @ast::Pat {\n@@ -2919,19 +2927,20 @@ impl Parser {\n             hi = sub.span.hi;\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n-              PatLit(e@@Expr {\n-                node: ExprLit(@codemap::Spanned {\n-                    node: LitStr(..),\n-                    span: _}), ..\n-              }) => {\n-                let vst = @Expr {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: ExprVstore(e, ExprVstoreUniq),\n-                    span: mk_sp(lo, hi),\n-                };\n-                PatLit(vst)\n-              }\n-              _ => PatUniq(sub)\n+                PatLit(e) => {\n+                    match e.node {\n+                        ExprLit(lit) if lit_is_str(lit) => {\n+                            let vst = @Expr {\n+                                id: ast::DUMMY_NODE_ID,\n+                                node: ExprVstore(e, ExprVstoreUniq),\n+                                span: mk_sp(lo, hi),\n+                            };\n+                            PatLit(vst)\n+                        }\n+                        _ => PatUniq(sub)\n+                    }\n+                }\n+                _ => PatUniq(sub)\n             };\n             hi = self.last_span.hi;\n             return @ast::Pat {\n@@ -2948,18 +2957,20 @@ impl Parser {\n               hi = sub.span.hi;\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n-                  PatLit(e@@Expr {\n-                      node: ExprLit(@codemap::Spanned{ node: LitStr(..), .. }),\n-                      ..\n-                  }) => {\n-                      let vst = @Expr {\n-                          id: ast::DUMMY_NODE_ID,\n-                          node: ExprVstore(e, ExprVstoreSlice),\n-                          span: mk_sp(lo, hi)\n-                      };\n-                      PatLit(vst)\n+                  PatLit(e) => {\n+                      match e.node {\n+                        ExprLit(lit) if lit_is_str(lit) => {\n+                          let vst = @Expr {\n+                              id: ast::DUMMY_NODE_ID,\n+                              node: ExprVstore(e, ExprVstoreSlice),\n+                              span: mk_sp(lo, hi)\n+                          };\n+                          PatLit(vst)\n+                        }\n+                        _ => PatRegion(sub),\n+                      }\n                   }\n-              _ => PatRegion(sub)\n+                  _ => PatRegion(sub),\n             };\n             hi = self.last_span.hi;\n             return @ast::Pat {"}, {"sha": "b6db827f7b88f13073a4189a9c19d8f4774cf634", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -1709,10 +1709,6 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) {\n         }\n         pclose(s);\n       }\n-      ast::PatBox(inner) => {\n-          word(&mut s.s, \"@\");\n-          print_pat(s, inner);\n-      }\n       ast::PatUniq(inner) => {\n           word(&mut s.s, \"~\");\n           print_pat(s, inner);\n@@ -1733,8 +1729,8 @@ pub fn print_pat(s: &mut State, pat: &ast::Pat) {\n         commasep(s, Inconsistent, *before, |s, &p| print_pat(s, p));\n         for &p in slice.iter() {\n             if !before.is_empty() { word_space(s, \",\"); }\n-            match p {\n-                @ast::Pat { node: ast::PatWildMulti, .. } => {\n+            match *p {\n+                ast::Pat { node: ast::PatWildMulti, .. } => {\n                     // this case is handled by print_pat\n                 }\n                 _ => word(&mut s.s, \"..\"),"}, {"sha": "ffea4b6dc751082fb4d1d90b3cd1367f19267f21", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -397,7 +397,6 @@ pub fn walk_pat<E: Clone, V: Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E)\n                 visitor.visit_pat(*tuple_element, env.clone())\n             }\n         }\n-        PatBox(subpattern) |\n         PatUniq(subpattern) |\n         PatRegion(subpattern) => {\n             visitor.visit_pat(subpattern, env)"}, {"sha": "25efa108ae34dfb0c8ba8748362b670f34f5f209", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -20,10 +20,6 @@ fn main() {\n         (true, false, false) => () //~ ERROR mismatched types: expected `(bool,bool)` but found tuple (expected a tuple with 2 elements but found one with 3 elements)\n     }\n \n-    match (true, false) {\n-        @(true, false) => () //~ ERROR mismatched types: expected `(bool,bool)` but found an @-box pattern\n-    }\n-\n     match (true, false) {\n         ~(true, false) => () //~ ERROR mismatched types: expected `(bool,bool)` but found a ~-box pattern\n     }"}, {"sha": "51aa576fc94086426a5d8e410e8989f44be08564", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n enum t { a, b, }\n \n fn main() {\n@@ -18,8 +16,8 @@ fn main() {\n     match true { //~ ERROR non-exhaustive patterns\n       true => {}\n     }\n-    match @Some(10) { //~ ERROR non-exhaustive patterns\n-      @None => {}\n+    match Some(10) { //~ ERROR non-exhaustive patterns\n+      None => {}\n     }\n     match (2, 3, 4) { //~ ERROR non-exhaustive patterns\n       (_, _, 4) => {}"}, {"sha": "b983eabb74350a03bf4aa351d1e3e32a68dedfdf", "filename": "src/test/compile-fail/unreachable-arm.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-arm.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n // error-pattern:unreachable pattern\n \n-enum foo { a(@foo, int), b(uint), }\n+enum foo { a(~foo, int), b(uint), }\n \n-fn main() { match b(1u) { b(_) | a(@_, 1) => { } a(_, 1) => { } } }\n+fn main() { match b(1u) { b(_) | a(~_, 1) => { } a(_, 1) => { } } }"}, {"sha": "0485a5ba022665eb44b4fee0878d21c501b379af", "filename": "src/test/debug-info/destructured-fn-argument.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -10,8 +10,6 @@\n \n // xfail-android: FIXME(#10381)\n \n-#[feature(managed_boxes)];\n-\n // compile-flags:-Z extra-debug-info\n // debugger:rbreak zzz\n // debugger:run\n@@ -238,7 +236,7 @@ fn complex_nesting(((u,   v  ), ((w,   (x,   Struct { a: y, b: z})), Struct { a:\n     zzz();\n }\n \n-fn managed_box(@aa: @(int, int)) {\n+fn managed_box(&aa: &(int, int)) {\n     zzz();\n }\n \n@@ -297,7 +295,7 @@ fn main() {\n     one_struct_destructured_one_not((Struct { a: 19, b: 20 }, Struct { a: 21, b: 22 }));\n     different_order_of_struct_fields(Struct { a: 23, b: 24 });\n     complex_nesting(((25, 26), ((27, (28, Struct { a: 29, b: 30})), Struct { a: 31, b: 32 }), 33));\n-    managed_box(@(34, 35));\n+    managed_box(&(34, 35));\n     borrowed_pointer(&(36, 37));\n     contained_borrowed_pointer((&38, 39));\n     unique_pointer(~(40, 41, 42));"}, {"sha": "bbe453594bc96ecd735de48086b7b48794f49195", "filename": "src/test/debug-info/destructured-local.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -125,7 +125,6 @@\n // debugger:print *nn\n // check:$43 = 56\n \n-#[feature(managed_boxes)];\n #[allow(unused_variable)];\n \n struct Struct {\n@@ -172,8 +171,8 @@ fn main() {\n     let ((u, v), ((w, (x, Struct { a: y, b: z})), Struct { a: ae, b: oe }), ue) =\n         ((25, 26), ((27, (28, Struct { a: 29, b: 30})), Struct { a: 31, b: 32 }), 33);\n \n-    // managed box\n-    let @aa = @(34, 35);\n+    // reference\n+    let &aa = &(34, 35);\n \n     // reference\n     let &bb = &(36, 37);"}, {"sha": "8871035908bbf2d3a57d7096bd7f54c43e6ea0fe", "filename": "src/test/run-pass/borrowck-preserve-box-in-arm-not-taken.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs?ref=480b0f481390683e1ac9bf9f762dcefb5325190d", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// exec-env:RUST_POISON_ON_FREE=1\n-\n-#[feature(managed_boxes)];\n-\n-use std::cell::RefCell;\n-\n-pub fn main() {\n-    let x: @RefCell<@Option<~int>> = @RefCell::new(@None);\n-    let mut xb = x.borrow_mut();\n-    match *xb.get() {\n-      @Some(ref _y) => {\n-        // here, the refcount of `*x` is bumped so\n-        // `_y` remains valid even if `*x` is modified.\n-        *xb.get() = @None;\n-      }\n-      @None => {\n-        // here, no bump of the ref count of `*x` is needed, but in\n-        // fact a bump occurs anyway because of how pattern marching\n-        // works.\n-      }\n-    }\n-}"}, {"sha": "0f37288d51db6d2d9d94ccb0a1bdf180182e8c2f", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=480b0f481390683e1ac9bf9f762dcefb5325190d", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// exec-env:RUST_POISON_ON_FREE=1\n-\n-#[feature(managed_boxes)];\n-\n-use std::ptr;\n-\n-struct F { f: ~int }\n-\n-pub fn main() {\n-    let mut x = @F {f: ~3};\n-    match x {\n-      @F {f: ref b_x} => {\n-        assert_eq!(**b_x, 3);\n-        assert_eq!(ptr::to_unsafe_ptr(&(*x.f)), ptr::to_unsafe_ptr(&(**b_x)));\n-\n-        x = @F {f: ~4};\n-\n-        info!(\"ptr::to_unsafe_ptr(*b_x) = {:x}\",\n-               ptr::to_unsafe_ptr(&(**b_x)) as uint);\n-        assert_eq!(**b_x, 3);\n-        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(**b_x)));\n-      }\n-    }\n-}"}, {"sha": "b333bcae5823add944d0739ccc1c920a0d2877a3", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=480b0f481390683e1ac9bf9f762dcefb5325190d", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// exec-env:RUST_POISON_ON_FREE=1\n-\n-#[feature(managed_boxes)];\n-\n-use std::cell::RefCell;\n-use std::ptr;\n-\n-struct F { f: ~int }\n-\n-pub fn main() {\n-    let x = @RefCell::new(@F {f: ~3});\n-    let mut xb = x.borrow_mut();\n-    match *xb.get() {\n-      @F{f: ref b_x} => {\n-        assert_eq!(**b_x, 3);\n-        assert_eq!(ptr::to_unsafe_ptr(&(xb.get().f)), ptr::to_unsafe_ptr(b_x));\n-\n-        *xb.get() = @F {f: ~4};\n-\n-        info!(\"ptr::to_unsafe_ptr(*b_x) = {:x}\",\n-               ptr::to_unsafe_ptr(&(**b_x)) as uint);\n-        assert_eq!(**b_x, 3);\n-        assert!(ptr::to_unsafe_ptr(&(*xb.get().f)) != ptr::to_unsafe_ptr(&(**b_x)));\n-      }\n-    }\n-}"}, {"sha": "dbd3e6302aff740b1e51881906c7f4fcf7a2f9a3", "filename": "src/test/run-pass/borrowck-preserve-box-sometimes-needed.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-sometimes-needed.rs?ref=480b0f481390683e1ac9bf9f762dcefb5325190d", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// exec-env:RUST_POISON_ON_FREE=1\n-\n-#[feature(managed_boxes)];\n-\n-fn switcher(x: Option<@int>) {\n-    let mut x = x;\n-    match x {\n-        Some(@y) => { y.clone(); x = None; }\n-        None => { }\n-    }\n-    assert_eq!(x, None);\n-}\n-\n-pub fn main() {\n-    switcher(None);\n-    switcher(Some(@3));\n-}"}, {"sha": "c7d848c7c91c6d7751040e6326794e8b0142e4e5", "filename": "src/test/run-pass/box-pattern.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fbox-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Fbox-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-pattern.rs?ref=480b0f481390683e1ac9bf9f762dcefb5325190d", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct Foo {a: int, b: uint}\n-enum bar { u(@Foo), w(int), }\n-\n-pub fn main() {\n-    assert!(match u(@Foo{a: 10, b: 40u}) {\n-              u(@Foo{a: a, b: b}) => { a + (b as int) }\n-              _ => { 66 }\n-            } == 50);\n-}"}, {"sha": "dd9fa9ce39311cd00cd2b164f1eebd1aa89e731d", "filename": "src/test/run-pass/let-destruct-fresh-mem.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Flet-destruct-fresh-mem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Flet-destruct-fresh-mem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-destruct-fresh-mem.rs?ref=480b0f481390683e1ac9bf9f762dcefb5325190d", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-#[allow(dead_assignment)];\n-\n-struct X { x: int, y: @A }\n-struct A { a: int }\n-\n-pub fn main() {\n-    let u = X {x: 10, y: @A {a: 20}};\n-    let X {x: x, y: @A {a: a}} = u;\n-    let mut x = x;\n-    let mut a = a;\n-    x = 100;\n-    a = 100;\n-    assert_eq!(x, 100);\n-    assert_eq!(a, 100);\n-    assert_eq!(u.x, 10);\n-    assert_eq!(u.y.a, 20);\n-}"}, {"sha": "a1453a38455791db40d5de75b7ce42b9b4e28907", "filename": "src/test/run-pass/let-destruct.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Flet-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480b0f481390683e1ac9bf9f762dcefb5325190d/src%2Ftest%2Frun-pass%2Flet-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-destruct.rs?ref=480b0f481390683e1ac9bf9f762dcefb5325190d", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct xx(int);\n-\n-struct X { x: xx, y: int }\n-\n-pub fn main() {\n-    let @X {x: xx(x), y: y} = @X{x: xx(10), y: 20};\n-    assert_eq!(x + y, 30);\n-}"}, {"sha": "e09ac9450ba3c973a12779064e090192dd7a87fe", "filename": "src/test/run-pass/nested-exhaustive-match.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Frun-pass%2Fnested-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Frun-pass%2Fnested-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-exhaustive-match.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n struct Foo { foo: bool, bar: Option<int>, baz: int }\n \n pub fn main() {\n-    match @Foo{foo: true, bar: Some(10), baz: 20} {\n-      @Foo{foo: true, bar: Some(_), ..} => {}\n-      @Foo{foo: false, bar: None, ..} => {}\n-      @Foo{foo: true, bar: None, ..} => {}\n-      @Foo{foo: false, bar: Some(_), ..} => {}\n+    match Foo{foo: true, bar: Some(10), baz: 20} {\n+      Foo{foo: true, bar: Some(_), ..} => {}\n+      Foo{foo: false, bar: None, ..} => {}\n+      Foo{foo: true, bar: None, ..} => {}\n+      Foo{foo: false, bar: Some(_), ..} => {}\n     }\n }"}, {"sha": "1cbed9c29ece21957e636cc18c603d48389b61a5", "filename": "src/test/run-pass/nested-patterns.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab66f762548228a9491de8c955141b8d62b1f5fa/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-patterns.rs?ref=ab66f762548228a9491de8c955141b8d62b1f5fa", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n-struct A { a: int, b: @int }\n+struct A { a: int, b: int }\n struct B { a: int, b: C }\n struct D { a: int, d: C }\n struct C { c: int }\n \n pub fn main() {\n-    match A {a: 10, b: @20} {\n-        x@A {a, b: @20} => { assert!(x.a == 10); assert!(a == 10); }\n+    match A {a: 10, b: 20} {\n+        x@A {a, b: 20} => { assert!(x.a == 10); assert!(a == 10); }\n         A {b: _b, ..} => { fail!(); }\n     }\n     let mut x@B {b, ..} = B {a: 10, b: C {c: 20}};"}]}