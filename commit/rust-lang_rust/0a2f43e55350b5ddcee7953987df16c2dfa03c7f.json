{"sha": "0a2f43e55350b5ddcee7953987df16c2dfa03c7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMmY0M2U1NTM1MGI1ZGRjZWU3OTUzOTg3ZGYxNmMyZGZhMDNjN2Y=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2015-11-21T02:49:25Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2015-11-21T02:49:25Z"}, "message": "Write fn call return values directly into an lvalue the caller provides.", "tree": {"sha": "83c33c9d658d08f17b30271ffe1f5784fb92f6b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83c33c9d658d08f17b30271ffe1f5784fb92f6b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a2f43e55350b5ddcee7953987df16c2dfa03c7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2f43e55350b5ddcee7953987df16c2dfa03c7f", "html_url": "https://github.com/rust-lang/rust/commit/0a2f43e55350b5ddcee7953987df16c2dfa03c7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a2f43e55350b5ddcee7953987df16c2dfa03c7f/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa4b82209ea13ca04c92583222782e3b9e17a096", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa4b82209ea13ca04c92583222782e3b9e17a096", "html_url": "https://github.com/rust-lang/rust/commit/aa4b82209ea13ca04c92583222782e3b9e17a096"}], "stats": {"total": 53, "additions": 23, "deletions": 30}, "files": [{"sha": "06766d81c1620fb9f40d8aa5c744701debff12b6", "filename": "src/interpreter.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0a2f43e55350b5ddcee7953987df16c2dfa03c7f/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2f43e55350b5ddcee7953987df16c2dfa03c7f/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=0a2f43e55350b5ddcee7953987df16c2dfa03c7f", "patch": "@@ -26,8 +26,6 @@ enum Pointer {\n ///\n /// ```text\n /// +-----------------------+\n-/// | ReturnPointer         | return value\n-/// + - - - - - - - - - - - +\n /// | Arg(0)                |\n /// | Arg(1)                | arguments\n /// | ...                   |\n@@ -48,6 +46,7 @@ enum Pointer {\n /// ```\n #[derive(Debug)]\n struct Frame {\n+    return_ptr: Pointer,\n     offset: usize,\n     num_args: usize,\n     num_vars: usize,\n@@ -57,23 +56,19 @@ struct Frame {\n \n impl Frame {\n     fn size(&self) -> usize {\n-        1 + self.num_args + self.num_vars + self.num_temps\n-    }\n-\n-    fn return_val_offset(&self) -> usize {\n-        self.offset\n+        self.num_args + self.num_vars + self.num_temps\n     }\n \n-    fn arg_offset(&self, i: u32) -> usize {\n-        self.offset + 1 + i as usize\n+    fn arg_offset(&self, i: usize) -> usize {\n+        self.offset + i\n     }\n \n-    fn var_offset(&self, i: u32) -> usize {\n-        self.offset + 1 + self.num_args + i as usize\n+    fn var_offset(&self, i: usize) -> usize {\n+        self.offset + self.num_args + i\n     }\n \n-    fn temp_offset(&self, i: u32) -> usize {\n-        self.offset + 1 + self.num_args + self.num_vars + i as usize\n+    fn temp_offset(&self, i: usize) -> usize {\n+        self.offset + self.num_args + self.num_vars + i\n     }\n }\n \n@@ -89,13 +84,14 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         Interpreter {\n             tcx: tcx,\n             mir_map: mir_map,\n-            value_stack: Vec::new(),\n+            value_stack: vec![Value::Uninit], // Allocate a spot for the top-level return value.\n             call_stack: Vec::new(),\n         }\n     }\n \n-    fn push_stack_frame(&mut self, mir: &Mir, args: &[Value]) {\n+    fn push_stack_frame(&mut self, mir: &Mir, args: &[Value], return_ptr: Pointer) {\n         self.call_stack.push(Frame {\n+            return_ptr: return_ptr,\n             offset: self.value_stack.len(),\n             num_args: mir.arg_decls.len(),\n             num_vars: mir.var_decls.len(),\n@@ -106,7 +102,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         self.value_stack.extend(iter::repeat(Value::Uninit).take(frame.size()));\n \n         for (i, arg) in args.iter().enumerate() {\n-            self.value_stack[frame.offset + 1 + i] = arg.clone();\n+            self.value_stack[frame.arg_offset(i)] = arg.clone();\n         }\n     }\n \n@@ -115,8 +111,8 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         self.value_stack.truncate(frame.offset);\n     }\n \n-    fn call(&mut self, mir: &Mir, args: &[Value]) -> Value {\n-        self.push_stack_frame(mir, args);\n+    fn call(&mut self, mir: &Mir, args: &[Value], return_ptr: Pointer) {\n+        self.push_stack_frame(mir, args, return_ptr);\n         let mut block = mir::START_BLOCK;\n \n         loop {\n@@ -156,10 +152,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                         let arg_vals: Vec<Value> =\n                             args.iter().map(|arg| self.eval_operand(arg)).collect();\n \n-                        // FIXME: Pass the destination lvalue such that the ReturnPointer inside\n-                        // the function call will point to the destination.\n-                        let return_val = self.call(mir, &arg_vals);\n-                        self.write_pointer(ptr, return_val);\n+                        self.call(mir, &arg_vals, ptr);\n                         block = targets[0];\n                     } else {\n                         panic!(\"tried to call a non-function value: {:?}\", func_val);\n@@ -190,19 +183,17 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n             }\n         }\n \n-        let ret_val = self.read_lvalue(&mir::Lvalue::ReturnPointer);\n         self.pop_stack_frame();\n-        ret_val\n     }\n \n     fn eval_lvalue(&self, lvalue: &mir::Lvalue) -> Pointer {\n         let frame = self.call_stack.last().expect(\"missing call frame\");\n \n         match *lvalue {\n-            mir::Lvalue::ReturnPointer => Pointer::Stack(frame.return_val_offset()),\n-            mir::Lvalue::Arg(i)  => Pointer::Stack(frame.arg_offset(i)),\n-            mir::Lvalue::Var(i)  => Pointer::Stack(frame.var_offset(i)),\n-            mir::Lvalue::Temp(i) => Pointer::Stack(frame.temp_offset(i)),\n+            mir::Lvalue::ReturnPointer => frame.return_ptr,\n+            mir::Lvalue::Arg(i)  => Pointer::Stack(frame.arg_offset(i as usize)),\n+            mir::Lvalue::Var(i)  => Pointer::Stack(frame.var_offset(i as usize)),\n+            mir::Lvalue::Temp(i) => Pointer::Stack(frame.temp_offset(i as usize)),\n             _ => unimplemented!(),\n         }\n     }\n@@ -319,10 +310,12 @@ pub fn interpret_start_points<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &MirMap<'tcx>\n                 let item = tcx.map.expect_item(id);\n \n                 println!(\"Interpreting: {}\", item.name);\n+\n                 let mut interpreter = Interpreter::new(tcx, mir_map);\n-                let val = interpreter.call(mir, &[]);\n-                let val_str = format!(\"{:?}\", val);\n+                let return_ptr = Pointer::Stack(0);\n+                interpreter.call(mir, &[], return_ptr);\n \n+                let val_str = format!(\"{:?}\", interpreter.read_pointer(return_ptr));\n                 if !check_expected(&val_str, attr) {\n                     println!(\"=> {}\\n\", val_str);\n                 }"}]}