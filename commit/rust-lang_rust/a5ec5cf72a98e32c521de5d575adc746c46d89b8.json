{"sha": "a5ec5cf72a98e32c521de5d575adc746c46d89b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZWM1Y2Y3MmE5OGUzMmM1MjFkZTVkNTc1YWRjNzQ2YzQ2ZDg5Yjg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-16T12:08:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-16T12:08:32Z"}, "message": "Rollup merge of #84145 - vojtechkral:vecdeque-binary-search, r=m-ou-se\n\nAddress comments for vecdeque_binary_search #78021", "tree": {"sha": "b694c530f2f7a6450f869a707b52af861432adc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b694c530f2f7a6450f869a707b52af861432adc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5ec5cf72a98e32c521de5d575adc746c46d89b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgeX5ACRBK7hj4Ov3rIwAA4R8IAEYY6iCayiLwY1eJupGx7FPt\nEYpGuHTVRuAnhXOFK5NnPThEN0GjcUpO00r7Oaq4cdyFw4CbFjkS18yPIR+JxRzq\n9Ojo37a72q8/mgxnoZwCF5h1FrWDm2/zF7imOBBbm3pNMOgkTmQme3SAmSjKGncn\nz1L7WW9yc7DnYKNblEBNe5aH1KHrpHPQaml0Fjv2iU8OeLmx8IMLoj2Nf6PThPhS\nFtBDlMAqc+pYyiN2n+PGHk+Nzyd3fii9xVEATYapliNZu/RsCeLLC1X5Zgeuecvq\nAU9SJdjUgCzjQK/uIl31OayCfZOsFkUh9QRVaNeQh09v0k4lUlP7gPpUGzPl9H0=\n=WR8T\n-----END PGP SIGNATURE-----\n", "payload": "tree b694c530f2f7a6450f869a707b52af861432adc2\nparent 8853aaeefc9739b497983912a6cddfddaaf01d58\nparent 44be1c2aa0df6ef4ff22e4aa92be3f32daf036a9\nauthor Dylan DPC <dylan.dpc@gmail.com> 1618574912 +0200\ncommitter GitHub <noreply@github.com> 1618574912 +0200\n\nRollup merge of #84145 - vojtechkral:vecdeque-binary-search, r=m-ou-se\n\nAddress comments for vecdeque_binary_search #78021\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ec5cf72a98e32c521de5d575adc746c46d89b8", "html_url": "https://github.com/rust-lang/rust/commit/a5ec5cf72a98e32c521de5d575adc746c46d89b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5ec5cf72a98e32c521de5d575adc746c46d89b8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8853aaeefc9739b497983912a6cddfddaaf01d58", "url": "https://api.github.com/repos/rust-lang/rust/commits/8853aaeefc9739b497983912a6cddfddaaf01d58", "html_url": "https://github.com/rust-lang/rust/commit/8853aaeefc9739b497983912a6cddfddaaf01d58"}, {"sha": "44be1c2aa0df6ef4ff22e4aa92be3f32daf036a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/44be1c2aa0df6ef4ff22e4aa92be3f32daf036a9", "html_url": "https://github.com/rust-lang/rust/commit/44be1c2aa0df6ef4ff22e4aa92be3f32daf036a9"}], "stats": {"total": 90, "additions": 87, "deletions": 3}, "files": [{"sha": "7d6fbf1c438bfe19e5632657b0a5b0fedc14805d", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a5ec5cf72a98e32c521de5d575adc746c46d89b8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ec5cf72a98e32c521de5d575adc746c46d89b8/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=a5ec5cf72a98e32c521de5d575adc746c46d89b8", "patch": "@@ -2403,6 +2403,12 @@ impl<T> VecDeque<T> {\n     /// [`Result::Err`] is returned, containing the index where a matching\n     /// element could be inserted while maintaining sorted order.\n     ///\n+    /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n+    ///\n+    /// [`binary_search_by`]: VecDeque::binary_search_by\n+    /// [`binary_search_by_key`]: VecDeque::binary_search_by_key\n+    /// [`partition_point`]: VecDeque::partition_point\n+    ///\n     /// # Examples\n     ///\n     /// Looks up a series of four elements. The first is found, with a\n@@ -2457,6 +2463,12 @@ impl<T> VecDeque<T> {\n     /// [`Result::Err`] is returned, containing the index where a matching\n     /// element could be inserted while maintaining sorted order.\n     ///\n+    /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n+    ///\n+    /// [`binary_search`]: VecDeque::binary_search\n+    /// [`binary_search_by_key`]: VecDeque::binary_search_by_key\n+    /// [`partition_point`]: VecDeque::partition_point\n+    ///\n     /// # Examples\n     ///\n     /// Looks up a series of four elements. The first is found, with a\n@@ -2481,8 +2493,11 @@ impl<T> VecDeque<T> {\n         F: FnMut(&'a T) -> Ordering,\n     {\n         let (front, back) = self.as_slices();\n+        let cmp_back = back.first().map(|elem| f(elem));\n \n-        if let Some(Ordering::Less | Ordering::Equal) = back.first().map(|elem| f(elem)) {\n+        if let Some(Ordering::Equal) = cmp_back {\n+            Ok(front.len())\n+        } else if let Some(Ordering::Less) = cmp_back {\n             back.binary_search_by(f).map(|idx| idx + front.len()).map_err(|idx| idx + front.len())\n         } else {\n             front.binary_search_by(f)\n@@ -2492,15 +2507,21 @@ impl<T> VecDeque<T> {\n     /// Binary searches this sorted `VecDeque` with a key extraction function.\n     ///\n     /// Assumes that the `VecDeque` is sorted by the key, for instance with\n-    /// [`make_contiguous().sort_by_key()`](#method.make_contiguous) using the same\n-    /// key extraction function.\n+    /// [`make_contiguous().sort_by_key()`] using the same key extraction function.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n     /// one of the matches could be returned. If the value is not found then\n     /// [`Result::Err`] is returned, containing the index where a matching\n     /// element could be inserted while maintaining sorted order.\n     ///\n+    /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n+    ///\n+    /// [`make_contiguous().sort_by_key()`]: VecDeque::make_contiguous\n+    /// [`binary_search`]: VecDeque::binary_search\n+    /// [`binary_search_by`]: VecDeque::binary_search_by\n+    /// [`partition_point`]: VecDeque::partition_point\n+    ///\n     /// # Examples\n     ///\n     /// Looks up a series of four elements in a slice of pairs sorted by\n@@ -2531,6 +2552,51 @@ impl<T> VecDeque<T> {\n     {\n         self.binary_search_by(|k| f(k).cmp(b))\n     }\n+\n+    /// Returns the index of the partition point according to the given predicate\n+    /// (the index of the first element of the second partition).\n+    ///\n+    /// The deque is assumed to be partitioned according to the given predicate.\n+    /// This means that all elements for which the predicate returns true are at the start of the deque\n+    /// and all elements for which the predicate returns false are at the end.\n+    /// For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0\n+    /// (all odd numbers are at the start, all even at the end).\n+    ///\n+    /// If this deque is not partitioned, the returned result is unspecified and meaningless,\n+    /// as this method performs a kind of binary search.\n+    ///\n+    /// See also [`binary_search`], [`binary_search_by`], and [`binary_search_by_key`].\n+    ///\n+    /// [`binary_search`]: VecDeque::binary_search\n+    /// [`binary_search_by`]: VecDeque::binary_search_by\n+    /// [`binary_search_by_key`]: VecDeque::binary_search_by_key\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![1, 2, 3, 3, 5, 6, 7].into();\n+    /// let i = deque.partition_point(|&x| x < 5);\n+    ///\n+    /// assert_eq!(i, 4);\n+    /// assert!(deque.iter().take(i).all(|&x| x < 5));\n+    /// assert!(deque.iter().skip(i).all(|&x| !(x < 5)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    pub fn partition_point<P>(&self, mut pred: P) -> usize\n+    where\n+        P: FnMut(&T) -> bool,\n+    {\n+        let (front, back) = self.as_slices();\n+\n+        if let Some(true) = back.first().map(|v| pred(v)) {\n+            back.partition_point(pred) + front.len()\n+        } else {\n+            front.partition_point(pred)\n+        }\n+    }\n }\n \n impl<T: Clone> VecDeque<T> {"}, {"sha": "d7140cf97593cbd8f751c2fac4e022f18900c697", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a5ec5cf72a98e32c521de5d575adc746c46d89b8/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ec5cf72a98e32c521de5d575adc746c46d89b8/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=a5ec5cf72a98e32c521de5d575adc746c46d89b8", "patch": "@@ -1699,6 +1699,24 @@ fn test_binary_search_by_key() {\n     assert_eq!(deque.binary_search_by_key(&4, |&(v,)| v), Err(3));\n }\n \n+#[test]\n+fn test_partition_point() {\n+    // Contiguous (front only) search:\n+    let deque: VecDeque<_> = vec![1, 2, 3, 5, 6].into();\n+    assert!(deque.as_slices().1.is_empty());\n+    assert_eq!(deque.partition_point(|&v| v <= 3), 3);\n+\n+    // Split search (both front & back non-empty):\n+    let mut deque: VecDeque<_> = vec![5, 6].into();\n+    deque.push_front(3);\n+    deque.push_front(2);\n+    deque.push_front(1);\n+    deque.push_back(10);\n+    assert!(!deque.as_slices().0.is_empty());\n+    assert!(!deque.as_slices().1.is_empty());\n+    assert_eq!(deque.partition_point(|&v| v <= 5), 4);\n+}\n+\n #[test]\n fn test_zero_sized_push() {\n     const N: usize = 8;"}]}