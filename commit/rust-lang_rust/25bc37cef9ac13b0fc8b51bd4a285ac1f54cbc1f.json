{"sha": "25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YmMzN2NlZjlhYzEzYjBmYzhiNTFiZDRhMjg1YWMxZjU0Y2JjMWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-15T06:29:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-11-16T23:24:08Z"}, "message": "refactor all unix types", "tree": {"sha": "03ec8337328e73bcb367ffefaa3e7bd8d64d1eda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03ec8337328e73bcb367ffefaa3e7bd8d64d1eda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "html_url": "https://github.com/rust-lang/rust/commit/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b27a88e99c2ab011ebc2fcaa8a8943bcfc0b3065", "url": "https://api.github.com/repos/rust-lang/rust/commits/b27a88e99c2ab011ebc2fcaa8a8943bcfc0b3065", "html_url": "https://github.com/rust-lang/rust/commit/b27a88e99c2ab011ebc2fcaa8a8943bcfc0b3065"}], "stats": {"total": 330, "additions": 192, "deletions": 138}, "files": [{"sha": "c48a2c8c073b17dfed34acf6591ed046d9e94481", "filename": "src/lib/ctypes.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Fctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Fctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fctypes.rs?ref=25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "patch": "@@ -4,11 +4,18 @@ Module: ctypes\n Definitions useful for C interop\n */\n \n-/* Type: size_t */\n+type c_int = i32;\n+type long = int;\n+type unsigned = u32;\n+type ulong = uint;\n+\n+type intptr_t = uint;\n+type uintptr_t = uint;\n+type uint32_t = u32;\n+\n type size_t = uint;\n-/* Type: ssize_t */\n type ssize_t = int;\n-/* Type: uint32_t */\n-type uint32_t = u32;\n-/* Type: uintptr_t */\n-type uintptr_t = uint;\n+type off_t = uint;\n+\n+type fd_t = i32;      // not actually a C type, but should be.\n+type pid_t = i32;"}, {"sha": "9ce889761de50956d66acb50f560310d025ca506", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "patch": "@@ -48,7 +48,7 @@ fn setenv(n: str, v: str) {\n                         let _: () =\n                             str::as_buf(v,\n                                         {|vbuf|\n-                                            os::libc::setenv(nbuf, vbuf, 1);\n+                                            os::libc::setenv(nbuf, vbuf, 1i32);\n                                         });\n                     });\n }"}, {"sha": "5cb8e2231a5545b6b5a06ae07b552a8418d39801", "filename": "src/lib/io.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "patch": "@@ -1,3 +1,5 @@\n+import ctypes::fd_t;\n+import ctypes::c_int;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n@@ -6,7 +8,6 @@ native mod rustrt {\n     fn rust_get_stderr() -> os::libc::FILE;\n }\n \n-\n // Reading\n \n // FIXME This is all buffered. We might need an unbuffered variant as well\n@@ -49,8 +50,12 @@ type reader =\n         fn tell() -> uint;\n     };\n \n-fn convert_whence(whence: seek_style) -> int {\n-    ret alt whence { seek_set. { 0 } seek_cur. { 1 } seek_end. { 2 } };\n+fn convert_whence(whence: seek_style) -> i32 {\n+    ret alt whence {\n+      seek_set. { 0i32 }\n+      seek_cur. { 1i32 }\n+      seek_end. { 2i32 }\n+    };\n }\n \n resource FILE_res(f: os::libc::FILE) { os::libc::fclose(f); }\n@@ -64,11 +69,11 @@ obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n         vec::unsafe::set_len::<u8>(buf, read);\n         ret buf;\n     }\n-    fn read_byte() -> int { ret os::libc::fgetc(f); }\n-    fn unread_byte(byte: int) { os::libc::ungetc(byte, f); }\n-    fn eof() -> bool { ret os::libc::feof(f) != 0; }\n+    fn read_byte() -> int { ret os::libc::fgetc(f) as int; }\n+    fn unread_byte(byte: int) { os::libc::ungetc(byte as i32, f); }\n+    fn eof() -> bool { ret os::libc::feof(f) != 0i32; }\n     fn seek(offset: int, whence: seek_style) {\n-        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n+        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0i32);\n     }\n     fn tell() -> uint { ret os::libc::ftell(f) as uint; }\n }\n@@ -247,14 +252,14 @@ obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n         if nout < 1u { log_err \"error dumping buffer\"; }\n     }\n     fn seek(offset: int, whence: seek_style) {\n-        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n+        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0i32);\n     }\n     fn tell() -> uint { ret os::libc::ftell(f) as uint; }\n }\n \n-resource fd_res(fd: int) { os::libc::close(fd); }\n+resource fd_res(fd: fd_t) { os::libc::close(fd); }\n \n-obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n+obj fd_buf_writer(fd: fd_t, res: option::t<@fd_res>) {\n     fn write(v: [u8]) unsafe {\n         let len = vec::len::<u8>(v);\n         let count = 0u;\n@@ -282,7 +287,7 @@ obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n \n fn file_buf_writer(path: str,\n                    flags: [fileflag]) -> result::t<buf_writer, str> {\n-    let fflags: int =\n+    let fflags: i32 =\n         os::libc_constants::O_WRONLY | os::libc_constants::O_BINARY;\n     for f: fileflag in flags {\n         alt f {\n@@ -299,7 +304,7 @@ fn file_buf_writer(path: str,\n                                        os::libc_constants::S_IRUSR |\n                                            os::libc_constants::S_IWUSR)\n                     });\n-    ret if fd < 0 {\n+    ret if fd < 0i32 {\n         log_err sys::last_os_error();\n         result::err(\"error opening \" + path)\n     } else {\n@@ -385,9 +390,14 @@ fn buffered_file_buf_writer(path: str) -> result::t<buf_writer, str> {\n \n \n // FIXME it would be great if this could be a const\n+<<<<<<< HEAD\n // Problem seems to be that new_writer is not pure\n fn stdout() -> writer { ret new_writer(fd_buf_writer(1, option::none)); }\n fn stderr() -> writer { ret new_writer(fd_buf_writer(2, option::none)); }\n+=======\n+fn stdout() -> writer { ret new_writer(fd_buf_writer(1i32, option::none)); }\n+fn stderr() -> writer { ret new_writer(fd_buf_writer(2i32, option::none)); }\n+>>>>>>> refactor all unix types\n \n fn print(s: str) { stdout().write_str(s); }\n fn println(s: str) { stdout().write_str(s + \"\\n\"); }"}, {"sha": "418a6fd0ad2081f579b9a4a204c1dc741ee82a52", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "patch": "@@ -4,82 +4,90 @@ Module: os\n TODO: Restructure and document\n */\n \n+import ctypes::*;\n+\n+export libc;\n+export libc_constants;\n+export pipe;\n+export fd_FILE;\n+export close;\n+export fclose;\n+export waitpid;\n+export getcwd;\n+export exec_suffix;\n+export target_os;\n+export dylib_filename;\n+export get_exe_path;\n+\n // FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n // by https://github.com/graydon/rust/issues#issue/268\n+\n #[link_name = \"\"]\n #[abi = \"cdecl\"]\n native mod libc {\n-    fn read(fd: int, buf: *u8, count: uint) -> int;\n-    fn write(fd: int, buf: *u8, count: uint) -> int;\n-    fn fread(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n-    fn fwrite(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n-    fn open(s: str::sbuf, flags: int, mode: uint) -> int;\n-    fn close(fd: int) -> int;\n+    fn read(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n+    fn write(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n+    fn fread(buf: *u8, size: size_t, n: size_t, f: libc::FILE) -> size_t;\n+    fn fwrite(buf: *u8, size: size_t, n: size_t, f: libc::FILE) -> size_t;\n+    fn open(s: str::sbuf, flags: c_int, mode: unsigned) -> fd_t;\n+    fn close(fd: fd_t) -> int;\n     type FILE;\n     fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n-    fn fdopen(fd: int, mode: str::sbuf) -> FILE;\n+    fn fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n     fn fclose(f: FILE);\n-    fn fgetc(f: FILE) -> int;\n-    fn ungetc(c: int, f: FILE);\n-    fn feof(f: FILE) -> int;\n-    fn fseek(f: FILE, offset: int, whence: int) -> int;\n-    fn ftell(f: FILE) -> int;\n+    fn fgetc(f: FILE) -> c_int;\n+    fn ungetc(c: c_int, f: FILE);\n+    fn feof(f: FILE) -> c_int;\n+    fn fseek(f: FILE, offset: long, whence: c_int) -> c_int;\n+    fn ftell(f: FILE) -> long;\n     type dir;\n     fn opendir(d: str::sbuf) -> dir;\n-    fn closedir(d: dir) -> int;\n+    fn closedir(d: dir) -> c_int;\n     type dirent;\n     fn readdir(d: dir) -> dirent;\n     fn getenv(n: str::sbuf) -> str::sbuf;\n-    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: int) -> int;\n-    fn unsetenv(n: str::sbuf) -> int;\n-    fn pipe(buf: *mutable int) -> int;\n-    fn waitpid(pid: int, &status: int, options: int) -> int;\n-    fn readlink(path: str::sbuf, buf: str::sbuf,\n-                bufsize: ctypes::size_t) -> ctypes::ssize_t;\n+    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: c_int) -> c_int;\n+    fn unsetenv(n: str::sbuf) -> c_int;\n+    fn pipe(buf: *mutable fd_t) -> c_int;\n+    fn waitpid(pid: pid_t, &status: c_int, options: c_int) -> pid_t;\n }\n \n mod libc_constants {\n-    const O_RDONLY: int = 0;\n-    const O_WRONLY: int = 1;\n-    const O_RDWR: int   = 2;\n-    const O_APPEND: int = 1024;\n-    const O_CREAT: int  = 64;\n-    const O_EXCL: int   = 128;\n-    const O_TRUNC: int  = 512;\n-    const O_TEXT: int   = 0;     // nonexistent in linux libc\n-    const O_BINARY: int = 0;     // nonexistent in linux libc\n-\n-    const S_IRUSR: uint = 256u;\n-    const S_IWUSR: uint = 128u;\n-}\n+    const O_RDONLY: c_int = 0;\n+    const O_WRONLY: c_int = 1;\n+    const O_RDWR: c_int   = 2;\n+    const O_APPEND: c_int = 1024;\n+    const O_CREAT: c_int  = 64;\n+    const O_EXCL: c_int   = 128;\n+    const O_TRUNC: c_int  = 512;\n+    const O_TEXT: c_int   = 0;     // nonexistent in linux libc\n+    const O_BINARY: c_int = 0;     // nonexistent in linux libc\n \n-// FIXME turn into constants\n-fn exec_suffix() -> str { ret \"\"; }\n-fn target_os() -> str { ret \"linux\"; }\n-\n-fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n+    const S_IRUSR: unsigned = 256u;\n+    const S_IWUSR: unsigned = 128u;\n+}\n \n-fn pipe() -> {in: int, out: int} {\n-    let fds = {mutable in: 0, mutable out: 0};\n-    assert (os::libc::pipe(ptr::mut_addr_of(fds.in)) == 0);\n+fn pipe() -> {in: fd_t, out: fd_t} {\n+    let fds = {mutable in: 0i32, mutable out: 0i32};\n+    assert (os::libc::pipe(ptr::mut_addr_of(fds.in)) == 0i32);\n     ret {in: fds.in, out: fds.out};\n }\n \n-fn fd_FILE(fd: int) -> libc::FILE {\n+fn fd_FILE(fd: fd_t) -> libc::FILE {\n     ret str::as_buf(\"r\", {|modebuf| libc::fdopen(fd, modebuf) });\n }\n \n-fn close(fd: int) -> int {\n+fn close(fd: fd_t) -> int {\n     libc::close(fd)\n }\n \n fn fclose(file: libc::FILE) {\n     libc::fclose(file)\n }\n \n-fn waitpid(pid: int) -> int {\n-    let status = 0;\n-    assert (os::libc::waitpid(pid, status, 0) != -1);\n+fn waitpid(pid: pid_t) -> i32 {\n+    let status = 0i32;\n+    assert (os::libc::waitpid(pid, status, 0i32) != -1i32);\n     ret status;\n }\n \n@@ -90,6 +98,12 @@ native mod rustrt {\n \n fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n \n+fn exec_suffix() -> str { ret \"\"; }\n+\n+fn target_os() -> str { ret \"linux\"; }\n+\n+fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n+\n /// Returns the directory containing the running program\n /// followed by a path separator\n fn get_exe_path() -> option::t<fs::path> {"}, {"sha": "0036af6c7a0cbdac7e30d1a86dbb79221ca2e40a", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 67, "deletions": 47, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "patch": "@@ -1,78 +1,87 @@\n+import ctypes::*;\n+\n+export libc;\n+export libc_constants;\n+export pipe;\n+export fd_FILE;\n+export close;\n+export fclose;\n+export waitpid;\n+export getcwd;\n+export exec_suffix;\n+export target_os;\n+export dylib_filename;\n+export get_exe_path;\n+\n+// FIXME Refactor into unix_os module or some such. Doesn't\n+// seem to work right now.\n \n #[link_name = \"\"]\n #[abi = \"cdecl\"]\n native mod libc {\n-    fn read(fd: int, buf: *u8, count: uint) -> int;\n-    fn write(fd: int, buf: *u8, count: uint) -> int;\n-    fn fread(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n-    fn fwrite(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n-    fn open(s: str::sbuf, flags: int, mode: uint) -> int;\n-    fn close(fd: int) -> int;\n+    fn read(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n+    fn write(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n+    fn fread(buf: *u8, size: size_t, n: size_t, f: libc::FILE) -> size_t;\n+    fn fwrite(buf: *u8, size: size_t, n: size_t, f: libc::FILE) -> size_t;\n+    fn open(s: str::sbuf, flags: c_int, mode: unsigned) -> fd_t;\n+    fn close(fd: fd_t) -> int;\n     type FILE;\n     fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n-    fn fdopen(fd: int, mode: str::sbuf) -> FILE;\n+    fn fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n     fn fclose(f: FILE);\n-    fn fgetc(f: FILE) -> int;\n-    fn ungetc(c: int, f: FILE);\n-    fn feof(f: FILE) -> int;\n-    fn fseek(f: FILE, offset: int, whence: int) -> int;\n-    fn ftell(f: FILE) -> int;\n+    fn fgetc(f: FILE) -> c_int;\n+    fn ungetc(c: c_int, f: FILE);\n+    fn feof(f: FILE) -> c_int;\n+    fn fseek(f: FILE, offset: long, whence: c_int) -> c_int;\n+    fn ftell(f: FILE) -> long;\n     type dir;\n     fn opendir(d: str::sbuf) -> dir;\n-    fn closedir(d: dir) -> int;\n+    fn closedir(d: dir) -> c_int;\n     type dirent;\n     fn readdir(d: dir) -> dirent;\n     fn getenv(n: str::sbuf) -> str::sbuf;\n-    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: int) -> int;\n-    fn unsetenv(n: str::sbuf) -> int;\n-    fn pipe(buf: *mutable int) -> int;\n-    fn waitpid(pid: int, &status: int, options: int) -> int;\n-    fn _NSGetExecutablePath(buf: str::sbuf,\n-                            bufsize: *mutable ctypes::uint32_t) -> int;\n+    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: c_int) -> c_int;\n+    fn unsetenv(n: str::sbuf) -> c_int;\n+    fn pipe(buf: *mutable fd_t) -> c_int;\n+    fn waitpid(pid: pid_t, &status: c_int, options: c_int) -> pid_t;\n }\n \n mod libc_constants {\n-    const O_RDONLY: int   = 0;\n-    const O_WRONLY: int   = 1;\n-    const O_RDWR: int     = 2;\n-    const O_APPEND: int   = 8;\n-    const O_CREAT: int    = 512;\n-    const O_EXCL: int     = 2048;\n-    const O_TRUNC: int    = 1024;\n-    const O_TEXT: int     = 0;    // nonexistent in darwin libc\n-    const O_BINARY: int   = 0;    // nonexistent in darwin libc\n-\n-    const S_IRUSR: uint   = 256u;\n-    const S_IWUSR: uint   = 128u;\n-}\n+    const O_RDONLY: int   = 0i32;\n+    const O_WRONLY: int   = 1i32;\n+    const O_RDWR: int     = 2i32;\n+    const O_APPEND: int   = 8i32;\n+    const O_CREAT: int    = 512i32;\n+    const O_EXCL: int     = 2048i32;\n+    const O_TRUNC: int    = 1024i32;\n+    const O_TEXT: int     = 0i32;    // nonexistent in darwin libc\n+    const O_BINARY: int   = 0i32;    // nonexistent in darwin libc\n \n-// FIXME turn into constants\n-fn exec_suffix() -> str { ret \"\"; }\n-fn target_os() -> str { ret \"macos\"; }\n-\n-fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".dylib\"; }\n+    const S_IRUSR: uint   = 256u32;\n+    const S_IWUSR: uint   = 128u32;\n+}\n \n-fn pipe() -> {in: int, out: int} {\n-    let fds = {mutable in: 0, mutable out: 0};\n-    assert (os::libc::pipe(ptr::mut_addr_of(fds.in)) == 0);\n+fn pipe() -> {in: fd_t, out: fd_t} {\n+    let fds = {mutable in: 0i32, mutable out: 0i32};\n+    assert (os::libc::pipe(ptr::mut_addr_of(fds.in)) == 0i32);\n     ret {in: fds.in, out: fds.out};\n }\n \n-fn fd_FILE(fd: int) -> libc::FILE {\n+fn fd_FILE(fd: fd_t) -> libc::FILE {\n     ret str::as_buf(\"r\", {|modebuf| libc::fdopen(fd, modebuf) });\n }\n \n-fn close(fd: int) -> int {\n+fn close(fd: fd_t) -> int {\n     libc::close(fd)\n }\n \n fn fclose(file: libc::FILE) {\n     libc::fclose(file)\n }\n \n-fn waitpid(pid: int) -> int {\n-    let status = 0;\n-    assert (os::libc::waitpid(pid, status, 0) != -1);\n+fn waitpid(pid: pid_t) -> i32 {\n+    let status = 0i32;\n+    assert (os::libc::waitpid(pid, status, 0i32) != -1i32);\n     ret status;\n }\n \n@@ -83,13 +92,24 @@ native mod rustrt {\n \n fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n \n+native \"cdecl\" mod mac_libc = \"\" {\n+    fn _NSGetExecutablePath(buf: str::sbuf,\n+                            bufsize: *mutable uint32_t) -> c_int;\n+}\n+\n+fn exec_suffix() -> str { ret \"\"; }\n+\n+fn target_os() -> str { ret \"macos\"; }\n+\n+fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".dylib\"; }\n+\n fn get_exe_path() -> option::t<fs::path> {\n     // FIXME: This doesn't handle the case where the buffer is too small\n     let bufsize = 1023u32;\n     let path = str::unsafe_from_bytes(vec::init_elt(0u8, bufsize as uint));\n     ret str::as_buf(path, { |path_buf|\n-        if libc::_NSGetExecutablePath(path_buf,\n-                                      ptr::mut_addr_of(bufsize)) == 0 {\n+        if mac_libc::_NSGetExecutablePath(path_buf,\n+                                          ptr::mut_addr_of(bufsize)) == 0i32 {\n             option::some(fs::dirname(path) + fs::path_sep())\n         } else {\n             option::none"}, {"sha": "ea24bc6dee877c6a1c817278f99a877f2e186d9f", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "patch": "@@ -4,6 +4,7 @@ Module: run\n Process spawning\n */\n import str::sbuf;\n+import ctypes::{fd_t, pid_t};\n \n export program;\n export run_program;\n@@ -14,8 +15,8 @@ export waitpid;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rust_run_program(argv: *sbuf, in_fd: int, out_fd: int, err_fd: int) ->\n-       int;\n+    fn rust_run_program(argv: *sbuf, in_fd: fd_t, out_fd: fd_t, err_fd: fd_t) ->\n+       pid_t;\n }\n \n /* Section: Types */\n@@ -41,7 +42,7 @@ type program = obj {\n \n     Returns the process id of the program\n     */\n-    fn get_id() -> int;\n+    fn get_id() -> pid_t;\n \n     /*\n     Method: input\n@@ -114,8 +115,8 @@ Returns:\n \n The process id of the spawned process\n */\n-fn spawn_process(prog: str, args: [str], in_fd: int, out_fd: int, err_fd: int)\n-   -> int unsafe {\n+fn spawn_process(prog: str, args: [str], in_fd: fd_t, out_fd: fd_t, err_fd: fd_t)\n+   -> pid_t unsafe {\n     // Note: we have to hold on to these vector references while we hold a\n     // pointer to their buffers\n     let prog = prog;\n@@ -142,7 +143,7 @@ Returns:\n The process id\n */\n fn run_program(prog: str, args: [str]) -> int {\n-    ret waitpid(spawn_process(prog, args, 0, 0, 0));\n+    ret waitpid(spawn_process(prog, args, 0i32, 0i32, 0i32));\n }\n \n /*\n@@ -171,16 +172,16 @@ fn start_program(prog: str, args: [str]) -> @program_res {\n         spawn_process(prog, args, pipe_input.in, pipe_output.out,\n                       pipe_err.out);\n \n-    if pid == -1 { fail; }\n+    if pid == -1i32 { fail; }\n     os::libc::close(pipe_input.in);\n     os::libc::close(pipe_output.out);\n     os::libc::close(pipe_err.out);\n-    obj new_program(pid: int,\n-                    mutable in_fd: int,\n+    obj new_program(pid: pid_t,\n+                    mutable in_fd: fd_t,\n                     out_file: os::libc::FILE,\n                     err_file: os::libc::FILE,\n                     mutable finished: bool) {\n-        fn get_id() -> int { ret pid; }\n+        fn get_id() -> pid_t { ret pid; }\n         fn input() -> io::writer {\n             ret io::new_writer(io::fd_buf_writer(in_fd, option::none));\n         }\n@@ -191,7 +192,7 @@ fn start_program(prog: str, args: [str]) -> @program_res {\n             ret io::new_reader(io::FILE_buf_reader(err_file, option::none));\n         }\n         fn close_input() {\n-            let invalid_fd = -1;\n+            let invalid_fd = -1i32;\n             if in_fd != invalid_fd {\n                 os::libc::close(in_fd);\n                 in_fd = invalid_fd;\n@@ -253,7 +254,7 @@ Function: waitpid\n \n Waits for a process to exit and returns the exit code\n */\n-fn waitpid(pid: int) -> int {\n+fn waitpid(pid: pid_t) -> int {\n     ret waitpid_os(pid);\n \n     #[cfg(target_os = \"win32\")]\n@@ -263,30 +264,30 @@ fn waitpid(pid: int) -> int {\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n-    fn waitpid_os(pid: int) -> int {\n+    fn waitpid_os(pid: pid_t) -> int {\n         #[cfg(target_os = \"linux\")]\n-        fn WIFEXITED(status: int) -> bool {\n-            (status & 0xff) == 0\n+        fn WIFEXITED(status: i32) -> bool {\n+            (status & 0xffi32) == 0i32\n         }\n \n         #[cfg(target_os = \"macos\")]\n-        fn WIFEXITED(status: int) -> bool {\n-            (status & 0x7f) == 0\n+        fn WIFEXITED(status: i32) -> bool {\n+            (status & 0x7fi32) == 0i32\n         }\n \n         #[cfg(target_os = \"linux\")]\n-        fn WEXITSTATUS(status: int) -> int {\n+        fn WEXITSTATUS(status: i32) -> i32 {\n             (status >> 8) & 0xff\n         }\n \n         #[cfg(target_os = \"macos\")]\n-        fn WEXITSTATUS(status: int) -> int {\n-            status >> 8\n+        fn WEXITSTATUS(status: i32) -> i32 {\n+            status >> 8i32\n         }\n \n         let status = os::waitpid(pid);\n         ret if WIFEXITED(status) {\n-            WEXITSTATUS(status)\n+            WEXITSTATUS(status) as int\n         } else {\n             1\n         };"}, {"sha": "7b8248833b156fbd3d3382df183fb3ed0e5b070f", "filename": "src/test/stdtest/run.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=25bc37cef9ac13b0fc8b51bd4a285ac1f54cbc1f", "patch": "@@ -4,6 +4,7 @@ import std::os;\n import std::io;\n import std::option;\n import std::str;\n+import std::ctypes::fd_t;\n \n // Regression test for memory leaks\n #[ignore(cfg(target_os = \"win32\"))] // FIXME\n@@ -14,7 +15,7 @@ fn test_leaks() {\n }\n \n #[test]\n-fn test_pipes() unsafe {\n+fn test_pipes() {\n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n     let pipe_err = os::pipe();\n@@ -25,7 +26,7 @@ fn test_pipes() unsafe {\n     os::close(pipe_out.out);\n     os::close(pipe_err.out);\n \n-    if pid == -1 { fail; }\n+    if pid == -1i32 { fail; }\n     let expected = \"test\";\n     writeclose(pipe_in.out, expected);\n     let actual = readclose(pipe_out.in);\n@@ -36,14 +37,15 @@ fn test_pipes() unsafe {\n     log actual;\n     assert (expected == actual);\n \n-    fn writeclose(fd: int, s: str) unsafe {\n+    fn writeclose(fd: fd_t, s: str) {\n+        log_err(\"writeclose\", (fd, s));\n         let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n         writer.write_str(s);\n \n         os::close(fd);\n     }\n \n-    fn readclose(fd: int) -> str unsafe {\n+    fn readclose(fd: fd_t) -> str {\n         // Copied from run::program_output\n         let file = os::fd_FILE(fd);\n         let reader = io::new_reader(io::FILE_buf_reader(file, option::none));\n@@ -58,8 +60,8 @@ fn test_pipes() unsafe {\n }\n \n #[test]\n-fn waitpid() unsafe {\n-    let pid = run::spawn_process(\"false\", [], 0, 0, 0);\n+fn waitpid() {\n+    let pid = run::spawn_process(\"false\", [], 0i32, 0i32, 0i32);\n     let status = run::waitpid(pid);\n     assert status == 1;\n }"}]}