{"sha": "e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZDRmYTMyOTViZjViZmQ4YTc5ODU1N2Q1Y2YwMTU4Y2E0NTNmODQ=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-04T07:21:27Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-04T07:21:27Z"}, "message": "Handle operand temps for function calls\n\nThis allows temporary destinations for function calls to have their\nallocas omitted.", "tree": {"sha": "cca5cd80edd58ae63fa3fb032ea4d6ffce84cb0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cca5cd80edd58ae63fa3fb032ea4d6ffce84cb0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "html_url": "https://github.com/rust-lang/rust/commit/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c2186d4d7427deef9d7c40cd34bf915904a6b09", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c2186d4d7427deef9d7c40cd34bf915904a6b09", "html_url": "https://github.com/rust-lang/rust/commit/9c2186d4d7427deef9d7c40cd34bf915904a6b09"}], "stats": {"total": 236, "additions": 191, "deletions": 45}, "files": [{"sha": "5fe70608ec6d3615cdc4cd7e84af535a967b3458", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "patch": "@@ -45,8 +45,9 @@ impl fmt::Debug for CodeExtent {\n \n         ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n-                let data = tcx.region_maps.code_extents.borrow()[self.0 as usize];\n-                write!(f, \"/{:?}\", data)?;\n+                if let Some(data) = tcx.region_maps.code_extents.borrow().get(self.0 as usize) {\n+                    write!(f, \"/{:?}\", data)?;\n+                }\n             }\n             Ok(())\n         })?;"}, {"sha": "66c7c4e41c132f377ebd8fbf3b3bd0a76a5fdb0b", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "patch": "@@ -407,7 +407,7 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(arg);\n                         }\n                         if let Some((ref $($mutability)* destination, target)) = *destination {\n-                            self.visit_lvalue(destination, LvalueContext::Store);\n+                            self.visit_lvalue(destination, LvalueContext::Call);\n                             self.visit_branch(block, target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n@@ -692,9 +692,12 @@ make_mir_visitor!(MutVisitor,mut);\n \n #[derive(Copy, Clone, Debug)]\n pub enum LvalueContext {\n-    // Appears as LHS of an assignment or as dest of a call\n+    // Appears as LHS of an assignment\n     Store,\n \n+    // Dest of a call\n+    Call,\n+\n     // Being dropped\n     Drop,\n "}, {"sha": "9b7b55842ccd1891dd47a28fe62dbe6d2bc05b05", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "patch": "@@ -105,6 +105,7 @@ impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n         match *lvalue {\n             mir::Lvalue::Temp(index) => {\n                 match context {\n+                    LvalueContext::Call |\n                     LvalueContext::Consume => {\n                     }\n                     LvalueContext::Store |"}, {"sha": "b8417f985650c5b321fc9911bb7e4ea6ada0e426", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 151, "deletions": 41, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, BasicBlockRef, ValueRef, OperandBundleDef};\n use rustc::ty;\n use rustc::mir::repr as mir;\n-use abi::{Abi, FnType};\n+use abi::{Abi, FnType, ArgType};\n use adt;\n use base;\n use build;\n@@ -25,7 +25,7 @@ use type_of;\n use glue;\n use type_::Type;\n \n-use super::{MirContext, drop};\n+use super::{MirContext, TempRef, drop};\n use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n@@ -191,25 +191,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 if intrinsic == Some(\"transmute\") {\n                     let &(ref dest, target) = destination.as_ref().unwrap();\n-                    let dst = self.trans_lvalue(&bcx, dest);\n-                    let mut val = self.trans_operand(&bcx, &args[0]);\n-                    if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n-                        let llouttype = type_of::type_of(bcx.ccx(), dst.ty.to_ty(bcx.tcx()));\n-                        let out_type_size = llbitsize_of_real(bcx.ccx(), llouttype);\n-                        if out_type_size != 0 {\n-                            // FIXME #19925 Remove this hack after a release cycle.\n-                            let f = Callee::def(bcx.ccx(), def_id, substs);\n-                            let datum = f.reify(bcx.ccx());\n-                            val = OperandRef {\n-                                val: OperandValue::Immediate(datum.val),\n-                                ty: datum.ty\n-                            };\n-                        }\n-                    }\n+                    self.with_lvalue_ref(&bcx, dest, |this, dest| {\n+                        this.trans_transmute(&bcx, &args[0], dest);\n+                    });\n \n-                    let llty = type_of::type_of(bcx.ccx(), val.ty);\n-                    let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n-                    self.store_operand(&bcx, cast_ptr, val);\n                     self.set_operand_dropped(&bcx, &args[0]);\n                     funclet_br(bcx, self.llblock(target));\n                     return;\n@@ -227,17 +212,71 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Prepare the return value destination\n                 let ret_dest = if let Some((ref d, _)) = *destination {\n-                    let dest = self.trans_lvalue(&bcx, d);\n-                    if fn_ty.ret.is_indirect() {\n-                        llargs.push(dest.llval);\n-                        None\n-                    } else if fn_ty.ret.is_ignore() {\n-                        None\n-                    } else {\n-                        Some(dest)\n+                    match *d {\n+                        // Handle temporary lvalues, specifically Operand ones, as\n+                        // they don't have allocas\n+                        mir::Lvalue::Temp(idx) => {\n+                            let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), d);\n+                            let ret_ty = lvalue_ty.to_ty(bcx.tcx());\n+                            match self.temps[idx as usize] {\n+                                TempRef::Lvalue(dest) => {\n+                                    if fn_ty.ret.is_indirect() {\n+                                        llargs.push(dest.llval);\n+                                        ReturnDest::Nothing\n+                                    } else if fn_ty.ret.is_ignore() {\n+                                        ReturnDest::Nothing\n+                                    } else {\n+                                        ReturnDest::Store(dest.llval)\n+                                    }\n+                                }\n+                                TempRef::Operand(None) => {\n+                                    let is_intrinsic = if let Intrinsic = callee.data {\n+                                        true\n+                                    } else {\n+                                        false\n+                                    };\n+\n+                                    if fn_ty.ret.is_indirect() {\n+                                        // Odd, but possible, case, we have an operand temporary,\n+                                        // but the calling convention has an indirect return.\n+                                        let tmp = bcx.with_block(|bcx| {\n+                                            base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n+                                        });\n+                                        llargs.push(tmp);\n+                                        ReturnDest::IndirectOperand(tmp, idx)\n+                                    } else if is_intrinsic {\n+                                        // Currently, intrinsics always need a location to store\n+                                        // the result. so we create a temporary alloca for the\n+                                        // result\n+                                        let tmp = bcx.with_block(|bcx| {\n+                                            base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n+                                        });\n+                                        ReturnDest::IndirectOperand(tmp, idx)\n+                                    } else if fn_ty.ret.is_ignore() {\n+                                        ReturnDest::Nothing\n+                                    } else {\n+                                        ReturnDest::DirectOperand(idx)\n+                                    }\n+                                }\n+                                TempRef::Operand(Some(_)) => {\n+                                    bug!(\"lvalue temp already assigned to\");\n+                                }\n+                            }\n+                        }\n+                        _ => {\n+                            let dest = self.trans_lvalue(&bcx, d);\n+                            if fn_ty.ret.is_indirect() {\n+                                llargs.push(dest.llval);\n+                                ReturnDest::Nothing\n+                            } else if fn_ty.ret.is_ignore() {\n+                                ReturnDest::Nothing\n+                            } else {\n+                                ReturnDest::Store(dest.llval)\n+                            }\n+                        }\n                     }\n                 } else {\n-                    None\n+                    ReturnDest::Nothing\n                 };\n \n                 // Split the rust-call tupled arguments off.\n@@ -269,12 +308,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         use expr::{Ignore, SaveIn};\n                         use intrinsic::trans_intrinsic_call;\n \n-                        let (dest, llargs) = if fn_ty.ret.is_indirect() {\n-                            (SaveIn(llargs[0]), &llargs[1..])\n-                        } else if let Some(dest) = ret_dest {\n-                            (SaveIn(dest.llval), &llargs[..])\n-                        } else {\n-                            (Ignore, &llargs[..])\n+                        let (dest, llargs) = match ret_dest {\n+                            _ if fn_ty.ret.is_indirect() => {\n+                                (SaveIn(llargs[0]), &llargs[1..])\n+                            }\n+                            ReturnDest::Nothing => (Ignore, &llargs[..]),\n+                            ReturnDest::IndirectOperand(dst, _) |\n+                            ReturnDest::Store(dst) => (SaveIn(dst), &llargs[..]),\n+                            ReturnDest::DirectOperand(_) =>\n+                                bug!(\"Cannot use direct operand with an intrinsic call\")\n                         };\n \n                         bcx.with_block(|bcx| {\n@@ -292,6 +334,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 // bcx.unreachable();\n                             }\n                         });\n+\n+                        if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n+                            // Make a fake operand for store_return\n+                            let op = OperandRef {\n+                                val: OperandValue::Ref(dst),\n+                                ty: sig.0.output.unwrap()\n+                            };\n+                            self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                        }\n+\n                         return;\n                     }\n                     Fn(f) => f,\n@@ -321,9 +373,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if destination.is_some() {\n                         let ret_bcx = ret_bcx.build();\n                         ret_bcx.at_start(|ret_bcx| {\n-                            if let Some(ret_dest) = ret_dest {\n-                                fn_ty.ret.store(&ret_bcx, invokeret, ret_dest.llval);\n-                            }\n+                            let op = OperandRef {\n+                                val: OperandValue::Immediate(invokeret),\n+                                ty: sig.0.output.unwrap()\n+                            };\n+                            self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n                             for op in args {\n                                 self.set_operand_dropped(&ret_bcx, op);\n                             }\n@@ -333,9 +387,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n                     fn_ty.apply_attrs_callsite(llret);\n                     if let Some((_, target)) = *destination {\n-                        if let Some(ret_dest) = ret_dest {\n-                            fn_ty.ret.store(&bcx, llret, ret_dest.llval);\n-                        }\n+                        let op = OperandRef {\n+                            val: OperandValue::Immediate(llret),\n+                            ty: sig.0.output.unwrap()\n+                        };\n+                        self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         for op in args {\n                             self.set_operand_dropped(&bcx, op);\n                         }\n@@ -544,4 +600,58 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n         self.blocks[bb.index()].llbb\n     }\n+\n+    fn trans_transmute(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                       src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n+        let mut val = self.trans_operand(bcx, src);\n+        if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n+            let llouttype = type_of::type_of(bcx.ccx(), dst.ty.to_ty(bcx.tcx()));\n+            let out_type_size = llbitsize_of_real(bcx.ccx(), llouttype);\n+            if out_type_size != 0 {\n+                // FIXME #19925 Remove this hack after a release cycle.\n+                let f = Callee::def(bcx.ccx(), def_id, substs);\n+                let datum = f.reify(bcx.ccx());\n+                val = OperandRef {\n+                    val: OperandValue::Immediate(datum.val),\n+                    ty: datum.ty\n+                };\n+            }\n+        }\n+\n+        let llty = type_of::type_of(bcx.ccx(), val.ty);\n+        let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n+        self.store_operand(bcx, cast_ptr, val);\n+    }\n+\n+    // Stores the return value of a function call into it's final location.\n+    fn store_return(&mut self,\n+                    bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                    dest: ReturnDest,\n+                    ret_ty: ArgType,\n+                    op: OperandRef<'tcx>) {\n+        use self::ReturnDest::*;\n+\n+        match dest {\n+            Nothing => (),\n+            Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n+            IndirectOperand(tmp, idx) => {\n+                let op = self.trans_load(bcx, tmp, op.ty);\n+                self.temps[idx as usize] = TempRef::Operand(Some(op));\n+            }\n+            DirectOperand(idx) => {\n+                self.temps[idx as usize] = TempRef::Operand(Some(op));\n+            }\n+        }\n+    }\n+}\n+\n+enum ReturnDest {\n+    // Do nothing, the return value is indirect or ignored\n+    Nothing,\n+    // Store the return value to the pointer\n+    Store(ValueRef),\n+    // Stores an indirect return value to an operand temporary lvalue\n+    IndirectOperand(ValueRef, u32),\n+    // Stores a direct return value to an operand temporary lvalue\n+    DirectOperand(u32)\n }"}, {"sha": "5a0992a6b6b41b02e774fab35c0e7c589d4e223b", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d4fa3295bf5bfd8a798557d5cf0158ca453f84/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=e4d4fa3295bf5bfd8a798557d5cf0158ca453f84", "patch": "@@ -207,6 +207,37 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n+    // Perform an action using the given Lvalue.\n+    // If the Lvalue is an empty TempRef::Operand, then a temporary stack slot\n+    // is created first, then used as an operand to update the Lvalue.\n+    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                 lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n+    where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n+    {\n+        match *lvalue {\n+            mir::Lvalue::Temp(idx) => {\n+                match self.temps[idx as usize] {\n+                    TempRef::Lvalue(lvalue) => f(self, lvalue),\n+                    TempRef::Operand(None) => {\n+                        let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n+                        let lvalue = LvalueRef::alloca(bcx, lvalue_ty.to_ty(bcx.tcx()), \"lvalue_temp\");\n+                        let ret = f(self, lvalue);\n+                        let op = self.trans_load(bcx, lvalue.llval, lvalue_ty.to_ty(bcx.tcx()));\n+                        self.temps[idx as usize] = TempRef::Operand(Some(op));\n+                        ret\n+                    }\n+                    TempRef::Operand(Some(_)) => {\n+                        bug!(\"Lvalue temp already set\");\n+                    }\n+                }\n+            }\n+            _ => {\n+                let lvalue = self.trans_lvalue(bcx, lvalue);\n+                f(self, lvalue)\n+            }\n+        }\n+    }\n+\n     /// Adjust the bitwidth of an index since LLVM is less forgiving\n     /// than we are.\n     ///"}]}