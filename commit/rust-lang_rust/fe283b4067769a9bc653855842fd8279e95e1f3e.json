{"sha": "fe283b4067769a9bc653855842fd8279e95e1f3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMjgzYjQwNjc3NjlhOWJjNjUzODU1ODQyZmQ4Mjc5ZTk1ZTFmM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-29T20:50:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-29T20:50:41Z"}, "message": "Auto merge of #26659 - nagisa:cas-docs, r=alexcrichton\n\nNamely:\r\n\r\n* Change parameter `old` to read `current` so it is clearer what the argument refers to (originally\r\n   suggested `expected`, but shot down by Steve);\r\n* Add some formatting and fix some mistakes like referring to the method as `swap` rather than\r\n  `compare_and_swap`.", "tree": {"sha": "413ef38241fb2992d182d37dc4dd0f6f85c403b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/413ef38241fb2992d182d37dc4dd0f6f85c403b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe283b4067769a9bc653855842fd8279e95e1f3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe283b4067769a9bc653855842fd8279e95e1f3e", "html_url": "https://github.com/rust-lang/rust/commit/fe283b4067769a9bc653855842fd8279e95e1f3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe283b4067769a9bc653855842fd8279e95e1f3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9b6929f4603950dafafa66c67df4cd37ed0b364", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9b6929f4603950dafafa66c67df4cd37ed0b364", "html_url": "https://github.com/rust-lang/rust/commit/f9b6929f4603950dafafa66c67df4cd37ed0b364"}, {"sha": "08b21661c3131297c021768134d4637d62c12dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/08b21661c3131297c021768134d4637d62c12dcb", "html_url": "https://github.com/rust-lang/rust/commit/08b21661c3131297c021768134d4637d62c12dcb"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "5e6be49be97ef77ed0ec9c8228559b607a09c615", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fe283b4067769a9bc653855842fd8279e95e1f3e/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe283b4067769a9bc653855842fd8279e95e1f3e/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=fe283b4067769a9bc653855842fd8279e95e1f3e", "patch": "@@ -272,13 +272,13 @@ impl AtomicBool {\n         unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n     }\n \n-    /// Stores a value into the bool if the current value is the same as the expected value.\n+    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n-    /// `swap` also takes an `Ordering` argument which describes the memory ordering of this\n-    /// operation.\n+    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n+    /// this operation.\n     ///\n     /// # Examples\n     ///\n@@ -295,11 +295,11 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n-        let old = if old { UINT_TRUE } else { 0 };\n+    pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n+        let current = if current { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) > 0 }\n     }\n \n     /// Logical \"and\" with a boolean value.\n@@ -515,10 +515,10 @@ impl AtomicIsize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// Stores a value into the isize if the current value is the same as the expected value.\n+    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -538,8 +538,8 @@ impl AtomicIsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize {\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n     }\n \n     /// Add an isize to the current value, returning the previous value.\n@@ -709,10 +709,10 @@ impl AtomicUsize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n-    /// Stores a value into the usize if the current value is the same as the expected value.\n+    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -732,8 +732,8 @@ impl AtomicUsize {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize {\n+        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n     }\n \n     /// Add to the current usize, returning the previous value.\n@@ -910,10 +910,10 @@ impl<T> AtomicPtr<T> {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n-    /// Stores a value into the pointer if the current value is the same as the expected value.\n+    /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// The return value is always the previous value. If it is equal to `old`, then the value was\n-    /// updated.\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n     ///\n     /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n     /// this operation.\n@@ -933,9 +933,9 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+    pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(self.p.get() as *mut usize, old as usize,\n+            atomic_compare_and_swap(self.p.get() as *mut usize, current as usize,\n                                     new as usize, order) as *mut T\n         }\n     }"}]}