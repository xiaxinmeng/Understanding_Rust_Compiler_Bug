{"sha": "180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MGZjNDEzZmIxYjEwZjViMTcyYWU0MGJmNTBmN2NlZTNkNTViMTM=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-10-21T01:04:59Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-10-22T13:33:36Z"}, "message": "Move Place::elem methods and friends to TyCtxt", "tree": {"sha": "4d0515c0080d656e8e59aa2212faaa4d1672358e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d0515c0080d656e8e59aa2212faaa4d1672358e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAl2vBTAACgkQiMlBzaHU\nZDIfUQ//ZfZvHUqREmRylGoUcw3b+G/g5DXnEdBrklNCugrf6E3frUAqwglDJsV/\nohVewknoDY/egWn1Lz+M7MhRh3nLkdqE12S9mR0NM1okWROGyzSlRmebpsUsdA2X\ncpvK6GqkUZPf9Mg+nvrSO0AM7KmYo1xZhMl9KdBML823id+iATuUDJrLPEvAeUx7\nvYD6tlhKkuGQpAs5K7hd5o/yS0vs+iNiKVAqTxdecvzuDgg9DZUHwOpoTfBTR9Ze\n27jii9B76HiF76+Jkc6d2RBREn9NDVcUSAcdvKYRlcISJiLnUi7zidTKC9/TQZfW\nVbtCEQKvVLwqno4VHfBN0zBDMDb0vHA71rO82LCCvfDqm8jz2cJKcYAPXs4EsKND\nb+MUhzYm0Pp0BweACO0SqpuzS3p4nP/7/6sCA6YTc5CC1REBYf0dIDA4tKj3GGFs\nw028deqAI0t81Cy0FLTXuKd0866684q+jp43H1bZKvHkItxwYZ/VO7/gffh1z+B1\n6wdmRJk5OG+avG8H/98lMsDvVHDoxHbhf1Y9hZ57h/Ew+qwJky1ZPL+S+ZLeO5MA\nX3KJru9BKIzZ32bkZuOn1Kzb7/BksTumEvAXzhmul/dnTWCsRRaZCw97qJzYbiu3\ni8gB+sdjA6TcRlxOIIk2JcIh8CW4zjAU5EcQHS4e2L8WkkhcTYY=\n=G51/\n-----END PGP SIGNATURE-----", "payload": "tree 4d0515c0080d656e8e59aa2212faaa4d1672358e\nparent d32c2865d64e53cdd1b716b2b8966e4d1a4bfa38\nauthor Santiago Pastorino <spastorino@gmail.com> 1571619899 -0400\ncommitter Santiago Pastorino <spastorino@gmail.com> 1571751216 -0300\n\nMove Place::elem methods and friends to TyCtxt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "html_url": "https://github.com/rust-lang/rust/commit/180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d32c2865d64e53cdd1b716b2b8966e4d1a4bfa38", "url": "https://api.github.com/repos/rust-lang/rust/commits/d32c2865d64e53cdd1b716b2b8966e4d1a4bfa38", "html_url": "https://github.com/rust-lang/rust/commit/d32c2865d64e53cdd1b716b2b8966e4d1a4bfa38"}], "stats": {"total": 263, "additions": 139, "deletions": 124}, "files": [{"sha": "b2c26b6f0fe6e5d67e3a73d4ae421cd6a1cd2847", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -1857,51 +1857,6 @@ impl<'tcx> Place<'tcx> {\n         }\n     }\n \n-    pub fn field(self, f: Field, ty: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Field(f, ty), tcx)\n-    }\n-\n-    pub fn deref(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Deref, tcx)\n-    }\n-\n-    pub fn downcast(\n-        self,\n-        adt_def: &'tcx AdtDef,\n-        variant_index: VariantIdx,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Place<'tcx> {\n-        self.elem(\n-            ProjectionElem::Downcast(\n-                Some(adt_def.variants[variant_index].ident.name),\n-                variant_index,\n-            ),\n-            tcx,\n-        )\n-    }\n-\n-    pub fn downcast_unnamed(self, variant_index: VariantIdx, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(None, variant_index), tcx)\n-    }\n-\n-    pub fn index(self, index: Local, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Index(index), tcx)\n-    }\n-\n-    /// This method copies `Place`'s projection, add an element and reintern it. Should not be used\n-    /// to build a full `Place` it's just a convenient way to grab a projection and modify it in\n-    /// flight.\n-    // FIXME: It may be a better idea to move all these methods to `PlaceBuilder`\n-    pub fn elem(self, elem: PlaceElem<'tcx>, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n-        let mut projection = self.projection.to_vec();\n-        projection.push(elem);\n-\n-        Place {\n-            base: self.base,\n-            projection: tcx.intern_place_elems(&projection),\n-        }\n-    }\n-\n     /// Returns `true` if this `Place` contains a `Deref` projection.\n     ///\n     /// If `Place::is_indirect` returns false, the caller knows that the `Place` refers to the"}, {"sha": "2c17817f7833d8349f460e7731b2e3bec7a81827", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -21,7 +21,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, interpret, PlaceElem, ProjectionKind, Promoted};\n+use crate::mir::{Body, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -2597,6 +2597,48 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Opaque(def_id, substs))\n     }\n \n+    pub fn mk_place_field(self, place: Place<'tcx>, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Field(f, ty))\n+    }\n+\n+    pub fn mk_place_deref(self, place: Place<'tcx>) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Deref)\n+    }\n+\n+    pub fn mk_place_downcast(\n+        self,\n+        place: Place<'tcx>,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+    ) -> Place<'tcx> {\n+        self.mk_place_elem(\n+            place,\n+            PlaceElem::Downcast(Some(adt_def.variants[variant_index].ident.name), variant_index),\n+        )\n+    }\n+\n+    pub fn mk_place_downcast_unnamed(\n+        self,\n+        place: Place<'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Downcast(None, variant_index))\n+    }\n+\n+    pub fn mk_place_index(self, place: Place<'tcx>, index: Local) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Index(index))\n+    }\n+\n+    /// This method copies `Place`'s projection, add an element and reintern it. Should not be used\n+    /// to build a full `Place` it's just a convenient way to grab a projection and modify it in\n+    /// flight.\n+    pub fn mk_place_elem(self, place: Place<'tcx>, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n+        let mut projection = place.projection.to_vec();\n+        projection.push(elem);\n+\n+        Place { base: place.base, projection: self.intern_place_elems(&projection) }\n+    }\n+\n     pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n         -> &'tcx List<ExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());"}, {"sha": "4f1ac8e51dc208e14c8d6c22ebb2f1368b8caccd", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // initialize the box contents:\n                 unpack!(\n                     block = this.into(\n-                        &Place::from(result).deref(this.hir.tcx()),\n+                        &this.hir.tcx().mk_place_deref(Place::from(result)),\n                         block, value\n                     )\n                 );\n@@ -296,10 +296,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         .zip(field_types.into_iter())\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n-                            None => this.consume_by_copy_or_move(base.clone().field(\n+                            None => this.consume_by_copy_or_move(this.hir.tcx().mk_place_field(\n+                                base.clone(),\n                                 n,\n                                 ty,\n-                                this.hir.tcx(),\n                             )),\n                         })\n                         .collect()\n@@ -402,8 +402,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let val_fld = Field::new(0);\n             let of_fld = Field::new(1);\n \n-            let val = result_value.clone().field(val_fld, ty, self.hir.tcx());\n-            let of = result_value.field(of_fld, bool_ty, self.hir.tcx());\n+            let tcx = self.hir.tcx();\n+            let val = tcx.mk_place_field(result_value.clone(), val_fld, ty);\n+            let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n             let err = PanicInfo::Overflow(op);\n "}, {"sha": "e7388b920548b731bdb603a0f72d782d65efd52d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n                     let block = unpack!(this.into(&ptr_temp, block, ptr));\n-                    this.into(&ptr_temp.deref(this.hir.tcx()), block, val)\n+                    this.into(&this.hir.tcx().mk_place_deref(ptr_temp), block, val)\n                 } else {\n                     let args: Vec<_> = args\n                         .into_iter()"}, {"sha": "9b7bccca2ddf3268aaac4602d48d15dd0e2c557a", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                 });\n                 if irrefutable {\n-                    let place = match_pair.place.downcast(adt_def, variant_index, tcx);\n+                    let place = tcx.mk_place_downcast(match_pair.place, adt_def, variant_index);\n                     candidate.match_pairs.extend(self.field_match_pairs(place, subpatterns));\n                     Ok(())\n                 } else {\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Deref { ref subpattern } => {\n-                let place = match_pair.place.deref(tcx);\n+                let place = tcx.mk_place_deref(match_pair.place);\n                 candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }"}, {"sha": "5c2f72c0a061fec79401d4fde1d5d964b42c025a", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -743,23 +743,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) {\n         let match_pair = candidate.match_pairs.remove(match_pair_index);\n+        let tcx = self.hir.tcx();\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n         let elem = ProjectionElem::Downcast(\n             Some(adt_def.variants[variant_index].ident.name), variant_index);\n-        let downcast_place = match_pair.place.elem(elem, self.hir.tcx()); // `(x as Variant)`\n-        let consequent_match_pairs =\n-            subpatterns.iter()\n-                       .map(|subpattern| {\n-                           // e.g., `(x as Variant).0`\n-                           let place = downcast_place.clone().field(subpattern.field,\n-                                                                    subpattern.pattern.ty,\n-                                                                    self.hir.tcx());\n-                           // e.g., `(x as Variant).0 @ P1`\n-                           MatchPair::new(place, &subpattern.pattern)\n-                       });\n+        let downcast_place = tcx.mk_place_elem(match_pair.place, elem); // `(x as Variant)`\n+        let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n+            // e.g., `(x as Variant).0`\n+            let place =\n+                tcx.mk_place_field(downcast_place.clone(), subpattern.field, subpattern.pattern.ty);\n+            // e.g., `(x as Variant).0 @ P1`\n+            MatchPair::new(place, &subpattern.pattern)\n+        });\n \n         candidate.match_pairs.extend(consequent_match_pairs);\n     }"}, {"sha": "917535f31dc4b06eda62d08dc7361b7f7e8b6fbf", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -6,18 +6,22 @@ use std::u32;\n use std::convert::TryInto;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn field_match_pairs<'pat>(&mut self,\n-                                   place: Place<'tcx>,\n-                                   subpatterns: &'pat [FieldPat<'tcx>])\n-                                   -> Vec<MatchPair<'pat, 'tcx>> {\n-        subpatterns.iter()\n-                   .map(|fieldpat| {\n-                       let place = place.clone().field(fieldpat.field,\n-                                                       fieldpat.pattern.ty,\n-                                                       self.hir.tcx());\n-                       MatchPair::new(place, &fieldpat.pattern)\n-                   })\n-                   .collect()\n+    pub fn field_match_pairs<'pat>(\n+        &mut self,\n+        place: Place<'tcx>,\n+        subpatterns: &'pat [FieldPat<'tcx>],\n+    ) -> Vec<MatchPair<'pat, 'tcx>> {\n+        subpatterns\n+            .iter()\n+            .map(|fieldpat| {\n+                let place = self.hir.tcx().mk_place_field(\n+                    place.clone(),\n+                    fieldpat.field,\n+                    fieldpat.pattern.ty,\n+                );\n+                MatchPair::new(place, &fieldpat.pattern)\n+            })\n+            .collect()\n     }\n \n     pub fn prefix_slice_suffix<'pat>(&mut self,\n@@ -28,6 +32,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                      suffix: &'pat [Pat<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         let min_length = min_length.try_into().unwrap();\n+        let tcx = self.hir.tcx();\n \n         match_pairs.extend(\n             prefix.iter()\n@@ -38,16 +43,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                           min_length,\n                           from_end: false,\n                       };\n-                      let place = place.clone().elem(elem, self.hir.tcx());\n+                      let place = tcx.mk_place_elem(place.clone(), elem);\n                       MatchPair::new(place, subpattern)\n                   })\n         );\n \n         if let Some(subslice_pat) = opt_slice {\n-            let subslice = place.clone().elem(ProjectionElem::Subslice {\n+            let subslice = tcx.mk_place_elem(place.clone(),ProjectionElem::Subslice {\n                 from: prefix.len() as u32,\n                 to: suffix.len() as u32\n-            }, self.hir.tcx());\n+            });\n             match_pairs.push(MatchPair::new(subslice, subslice_pat));\n         }\n \n@@ -61,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                           min_length,\n                           from_end: true,\n                       };\n-                      let place = place.clone().elem(elem, self.hir.tcx());\n+                      let place = tcx.mk_place_elem(place.clone(), elem);\n                       MatchPair::new(place, subpattern)\n                   })\n         );"}, {"sha": "52016d4c9363ab55768b70983359a1391e483975", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -274,7 +274,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                     // Box starts out uninitialized - need to create a separate\n                     // move-path for the interior so it will be separate from\n                     // the exterior.\n-                    self.create_move_path(&place.clone().deref(self.builder.tcx));\n+                    self.create_move_path(&self.builder.tcx.mk_place_deref(place.clone()));\n                     self.gather_init(place.as_ref(), InitKind::Shallow);\n                 } else {\n                     self.gather_init(place.as_ref(), InitKind::Deep);"}, {"sha": "177639956f7175ff8645f5daaf28ee46d905151e", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -231,7 +231,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n                 tcx,\n                 param_env\n             };\n-            let dropee = dropee_ptr.deref(tcx);\n+            let dropee = tcx.mk_place_deref(dropee_ptr);\n             let resume_block = elaborator.patch.resume_block();\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,\n@@ -312,7 +312,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env, builder.span);\n \n     let dest = Place::return_place();\n-    let src = Place::from(Local::new(1+0)).deref(tcx);\n+    let src = tcx.mk_place_deref(Place::from(Local::new(1+0)));\n \n     match self_ty.kind {\n         _ if is_copy => builder.copy_shim(),\n@@ -415,7 +415,7 @@ impl CloneShimBuilder<'tcx> {\n     }\n \n     fn copy_shim(&mut self) {\n-        let rcvr = Place::from(Local::new(1+0)).deref(self.tcx);\n+        let rcvr = self.tcx.mk_place_deref(Place::from(Local::new(1+0)));\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n                 box(\n@@ -561,8 +561,8 @@ impl CloneShimBuilder<'tcx> {\n         // BB #2\n         // `dest[i] = Clone::clone(src[beg])`;\n         // Goto #3 if ok, #5 if unwinding happens.\n-        let dest_field = dest.clone().index(beg, self.tcx);\n-        let src_field = src.index(beg, self.tcx);\n+        let dest_field = self.tcx.mk_place_index(dest.clone(), beg);\n+        let src_field = self.tcx.mk_place_index(src, beg);\n         self.make_clone_call(dest_field, src_field, ty, BasicBlock::new(3),\n                              BasicBlock::new(5));\n \n@@ -616,7 +616,7 @@ impl CloneShimBuilder<'tcx> {\n         // BB #7 (cleanup)\n         // `drop(dest[beg])`;\n         self.block(vec![], TerminatorKind::Drop {\n-            location: dest.index(beg, self.tcx),\n+            location: self.tcx.mk_place_index(dest, beg),\n             target: BasicBlock::new(8),\n             unwind: None,\n         }, true);\n@@ -648,9 +648,9 @@ impl CloneShimBuilder<'tcx> {\n         let mut previous_field = None;\n         for (i, ity) in tys.enumerate() {\n             let field = Field::new(i);\n-            let src_field = src.clone().field(field, ity, self.tcx);\n+            let src_field = self.tcx.mk_place_field(src.clone(), field, ity);\n \n-            let dest_field = dest.clone().field(field, ity, self.tcx);\n+            let dest_field = self.tcx.mk_place_field(dest.clone(), field, ity);\n \n             // #(2i + 1) is the cleanup block for the previous clone operation\n             let cleanup_block = self.block_index_offset(1);\n@@ -721,14 +721,14 @@ fn build_call_shim<'tcx>(\n \n     let rcvr = match rcvr_adjustment {\n         Adjustment::Identity => Operand::Move(rcvr_l),\n-        Adjustment::Deref => Operand::Copy(rcvr_l.deref(tcx)),\n+        Adjustment::Deref => Operand::Copy(tcx.mk_place_deref(rcvr_l)),\n         Adjustment::DerefMove => {\n             // fn(Self, ...) -> fn(*mut Self, ...)\n             let arg_ty = local_decls[rcvr_arg].ty;\n             debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.types.self_param);\n             local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n \n-            Operand::Move(rcvr_l.deref(tcx))\n+            Operand::Move(tcx.mk_place_deref(rcvr_l))\n         }\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n@@ -772,7 +772,7 @@ fn build_call_shim<'tcx>(\n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n             let arg_place = Place::from(Local::new(1+1));\n-            Operand::Move(arg_place.field(Field::new(i), *ity, tcx))\n+            Operand::Move(tcx.mk_place_field(arg_place, Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {"}, {"sha": "911901be36b242f4562d600ce18da3b72c92b41b", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -246,7 +246,7 @@ impl TransformVisitor<'tcx> {\n     // Create a Place referencing a generator struct field\n     fn make_field(&self, variant_index: VariantIdx, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n         let self_place = Place::from(self_arg());\n-        let base = self_place.downcast_unnamed(variant_index, self.tcx);\n+        let base = self.tcx.mk_place_downcast_unnamed(self_place, variant_index);\n         let mut projection = base.projection.to_vec();\n         projection.push(ProjectionElem::Field(Field::new(idx), ty));\n "}, {"sha": "5a34e3f471f666dc426f653029901cc7deb82d99", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -461,7 +461,7 @@ impl Inliner<'tcx> {\n                     };\n                     caller_body[callsite.bb]\n                         .statements.push(stmt);\n-                    tmp.deref(self.tcx)\n+                    self.tcx.mk_place_deref(tmp)\n                 } else {\n                     destination.0\n                 };\n@@ -560,10 +560,10 @@ impl Inliner<'tcx> {\n             let tuple_tmp_args =\n                 tuple_tys.iter().enumerate().map(|(i, ty)| {\n                     // This is e.g., `tuple_tmp.0` in our example above.\n-                    let tuple_field = Operand::Move(tuple.clone().field(\n+                    let tuple_field = Operand::Move(tcx.mk_place_field(\n+                        tuple.clone(),\n                         Field::new(i),\n                         ty.expect_ty(),\n-                        tcx,\n                     ));\n \n                     // Spill to a local to make e.g., `tmp0`."}, {"sha": "e6c3e4384d7aeb189fc5583dbf366d40b02d95d9", "filename": "src/librustc_mir/util/aggregate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Faggregate.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -30,7 +30,7 @@ pub fn expand_aggregate<'tcx>(\n                     },\n                     source_info,\n                 });\n-                lhs = lhs.downcast(adt_def, variant_index, tcx);\n+                lhs = tcx.mk_place_downcast(lhs, adt_def, variant_index);\n             }\n             active_field_index\n         }\n@@ -59,15 +59,15 @@ pub fn expand_aggregate<'tcx>(\n             // FIXME(eddyb) `offset` should be u64.\n             let offset = i as u32;\n             assert_eq!(offset as usize, i);\n-            lhs.clone().elem(ProjectionElem::ConstantIndex {\n+            tcx.mk_place_elem(lhs.clone(), ProjectionElem::ConstantIndex {\n                 offset,\n                 // FIXME(eddyb) `min_length` doesn't appear to be used.\n                 min_length: offset + 1,\n                 from_end: false\n-            }, tcx)\n+            })\n         } else {\n             let field = Field::new(active_field_index.unwrap_or(i));\n-            lhs.clone().field(field, ty, tcx)\n+            tcx.mk_place_field(lhs.clone(), field, ty)\n         };\n         Statement {\n             source_info,"}, {"sha": "a1846a1fb5eaf594f5ff4e5b8e2a357128cde8a8", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180fc413fb1b10f5b172ae40bf50f7cee3d55b13/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=180fc413fb1b10f5b172ae40bf50f7cee3d55b13", "patch": "@@ -200,13 +200,14 @@ where\n         variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n             let subpath = self.elaborator.field_subpath(variant_path, field);\n+            let tcx = self.tcx();\n \n             assert_eq!(self.elaborator.param_env().reveal, Reveal::All);\n-            let field_ty = self.tcx().normalize_erasing_regions(\n+            let field_ty = tcx.normalize_erasing_regions(\n                 self.elaborator.param_env(),\n-                f.ty(self.tcx(), substs),\n+                f.ty(tcx, substs),\n             );\n-            (base_place.clone().field(field, field_ty, self.tcx()), subpath)\n+            (tcx.mk_place_field(base_place.clone(), field, field_ty), subpath)\n         }).collect()\n     }\n \n@@ -323,7 +324,7 @@ where\n         debug!(\"open_drop_for_tuple({:?}, {:?})\", self, tys);\n \n         let fields = tys.iter().enumerate().map(|(i, &ty)| {\n-            (self.place.clone().field(Field::new(i), ty, self.tcx()),\n+            (self.tcx().mk_place_field(self.place.clone(), Field::new(i), ty),\n              self.elaborator.field_subpath(self.path, Field::new(i)))\n         }).collect();\n \n@@ -334,7 +335,7 @@ where\n     fn open_drop_for_box(&mut self, adt: &'tcx ty::AdtDef, substs: SubstsRef<'tcx>) -> BasicBlock {\n         debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n \n-        let interior = self.place.clone().deref(self.tcx());\n+        let interior = self.tcx().mk_place_deref(self.place.clone());\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#43234)\n@@ -406,14 +407,19 @@ where\n         };\n \n         let mut have_otherwise = false;\n+        let tcx = self.tcx();\n \n-        for (variant_index, discr) in adt.discriminants(self.tcx()) {\n+        for (variant_index, discr) in adt.discriminants(tcx) {\n             let subpath = self.elaborator.downcast_subpath(\n                 self.path, variant_index);\n             if let Some(variant_path) = subpath {\n-                let base_place = self.place.clone().elem(\n-                    ProjectionElem::Downcast(Some(adt.variants[variant_index].ident.name),\n-                                             variant_index), self.tcx());\n+                let base_place = tcx.mk_place_elem(\n+                    self.place.clone(),\n+                    ProjectionElem::Downcast(\n+                        Some(adt.variants[variant_index].ident.name),\n+                        variant_index,\n+                    ),\n+                );\n                 let fields = self.move_paths_for_fields(\n                     &base_place,\n                     variant_path,\n@@ -586,15 +592,15 @@ where\n                 BorrowKind::Mut { allow_two_phase_borrow: false },\n                 Place {\n                     base: PlaceBase::Local(cur),\n-                    projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Deref]),\n+                    projection: tcx.intern_place_elems(&vec![ProjectionElem::Deref]),\n                 }\n              ),\n              Rvalue::BinaryOp(BinOp::Offset, move_(&Place::from(cur)), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.lifetimes.re_erased,\n                  BorrowKind::Mut { allow_two_phase_borrow: false },\n-                 self.place.clone().index(cur, self.tcx())),\n+                 tcx.mk_place_index(self.place.clone(), cur)),\n              Rvalue::BinaryOp(BinOp::Add, move_(&Place::from(cur)), one))\n         };\n \n@@ -627,7 +633,7 @@ where\n         let loop_block = self.elaborator.patch().new_block(loop_block);\n \n         self.elaborator.patch().patch_terminator(drop_block, TerminatorKind::Drop {\n-            location: ptr.clone().deref(tcx),\n+            location: tcx.mk_place_deref(ptr.clone()),\n             target: loop_block,\n             unwind: unwind.into_option()\n         });\n@@ -644,18 +650,27 @@ where\n         //     ptr_based_loop\n         // }\n \n+        let tcx = self.tcx();\n+\n         if let Some(size) = opt_size {\n             let size: u32 = size.try_into().unwrap_or_else(|_| {\n                 bug!(\"move out check isn't implemented for array sizes bigger than u32::MAX\");\n             });\n-            let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size).map(|i| {\n-                (self.place.clone().elem(ProjectionElem::ConstantIndex{\n-                    offset: i,\n-                    min_length: size,\n-                    from_end: false\n-                }, self.tcx()),\n-                 self.elaborator.array_subpath(self.path, i, size))\n-            }).collect();\n+            let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size)\n+                .map(|i| {\n+                    (\n+                        tcx.mk_place_elem(\n+                            self.place.clone(),\n+                            ProjectionElem::ConstantIndex {\n+                                offset: i,\n+                                min_length: size,\n+                                from_end: false,\n+                            },\n+                        ),\n+                        self.elaborator.array_subpath(self.path, i, size),\n+                    )\n+                })\n+                .collect();\n \n             if fields.iter().any(|(_,path)| path.is_some()) {\n                 let (succ, unwind) = self.drop_ladder_bottom();\n@@ -664,7 +679,6 @@ where\n         }\n \n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n-        let tcx = self.tcx();\n         let elem_size = &Place::from(self.new_temp(tcx.types.usize));\n         let len = &Place::from(self.new_temp(tcx.types.usize));\n \n@@ -900,8 +914,8 @@ where\n         );\n         let args = adt.variants[VariantIdx::new(0)].fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n-            let field_ty = f.ty(self.tcx(), substs);\n-            Operand::Move(self.place.clone().field(field, field_ty, self.tcx()))\n+            let field_ty = f.ty(tcx, substs);\n+            Operand::Move(tcx.mk_place_field(self.place.clone(), field, field_ty))\n         }).collect();\n \n         let call = TerminatorKind::Call {"}]}