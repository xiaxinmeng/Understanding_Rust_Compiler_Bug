{"sha": "ca7283d746012397faa266b39dee78609b74ed64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNzI4M2Q3NDYwMTIzOTdmYWEyNjZiMzlkZWU3ODYwOWI3NGVkNjQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-22T11:24:08Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-22T11:24:08Z"}, "message": "get rid of Rc in Stacked Borrows", "tree": {"sha": "a9a050aa7f7b92e959f7613c48083d54a882f3a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9a050aa7f7b92e959f7613c48083d54a882f3a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca7283d746012397faa266b39dee78609b74ed64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca7283d746012397faa266b39dee78609b74ed64", "html_url": "https://github.com/rust-lang/rust/commit/ca7283d746012397faa266b39dee78609b74ed64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca7283d746012397faa266b39dee78609b74ed64/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a249581280ea0181cf3ae0d2028ee8b88d3d1e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a249581280ea0181cf3ae0d2028ee8b88d3d1e4", "html_url": "https://github.com/rust-lang/rust/commit/3a249581280ea0181cf3ae0d2028ee8b88d3d1e4"}], "stats": {"total": 59, "additions": 29, "deletions": 30}, "files": [{"sha": "0e0f3ad1568bc3667a523752f743b12660362c3b", "filename": "src/machine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca7283d746012397faa266b39dee78609b74ed64/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7283d746012397faa266b39dee78609b74ed64/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=ca7283d746012397faa266b39dee78609b74ed64", "patch": "@@ -116,7 +116,7 @@ pub struct AllocExtra {\n }\n \n /// Extra global memory data\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct MemoryExtra {\n     pub stacked_borrows: Option<stacked_borrows::MemoryExtra>,\n     pub data_race: Option<data_race::MemoryExtra>,\n@@ -144,11 +144,11 @@ impl MemoryExtra {\n     pub fn new(config: &MiriConfig) -> Self {\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n         let stacked_borrows = if config.stacked_borrows {\n-            Some(Rc::new(RefCell::new(stacked_borrows::GlobalState::new(\n+            Some(RefCell::new(stacked_borrows::GlobalState::new(\n                 config.tracked_pointer_tag,\n                 config.tracked_call_id,\n                 config.track_raw,\n-            ))))\n+            )))\n         } else {\n             None\n         };\n@@ -478,7 +478,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let alloc = alloc.into_owned();\n         let (stacks, base_tag) = if let Some(stacked_borrows) = &memory_extra.stacked_borrows {\n             let (stacks, base_tag) =\n-                Stacks::new_allocation(id, alloc.size(), Rc::clone(stacked_borrows), kind);\n+                Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind);\n             (Some(stacks), base_tag)\n         } else {\n             // No stacks, no tag.\n@@ -507,7 +507,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn memory_read(\n-        _memory_extra: &Self::MemoryExtra,\n+        memory_extra: &Self::MemoryExtra,\n         alloc_extra: &AllocExtra,\n         ptr: Pointer<Tag>,\n         size: Size,\n@@ -516,15 +516,15 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.read(ptr, size)?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_read(ptr, size)\n+            stacked_borrows.memory_read(ptr, size, memory_extra.stacked_borrows.as_ref().unwrap())\n         } else {\n             Ok(())\n         }\n     }\n \n     #[inline(always)]\n     fn memory_written(\n-        _memory_extra: &mut Self::MemoryExtra,\n+        memory_extra: &mut Self::MemoryExtra,\n         alloc_extra: &mut AllocExtra,\n         ptr: Pointer<Tag>,\n         size: Size,\n@@ -533,7 +533,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.write(ptr, size)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_written(ptr, size)\n+            stacked_borrows.memory_written(ptr, size, memory_extra.stacked_borrows.as_mut().unwrap())\n         } else {\n             Ok(())\n         }\n@@ -553,7 +553,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             data_race.deallocate(ptr, size)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_deallocated(ptr, size)\n+            stacked_borrows.memory_deallocated(ptr, size, memory_extra.stacked_borrows.as_mut().unwrap())\n         } else {\n             Ok(())\n         }"}, {"sha": "87f8e4886933c389ebdfe692dd3cf3d36ac460eb", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ca7283d746012397faa266b39dee78609b74ed64/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca7283d746012397faa266b39dee78609b74ed64/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=ca7283d746012397faa266b39dee78609b74ed64", "patch": "@@ -4,8 +4,6 @@\n use std::cell::RefCell;\n use std::fmt;\n use std::num::NonZeroU64;\n-use std::rc::Rc;\n-\n use log::trace;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -87,8 +85,6 @@ pub struct Stack {\n pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n-    // Pointer to global state\n-    global: MemoryExtra,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -112,7 +108,7 @@ pub struct GlobalState {\n     track_raw: bool,\n }\n /// Memory extra state gives us interior mutable access to the global state.\n-pub type MemoryExtra = Rc<RefCell<GlobalState>>;\n+pub type MemoryExtra = RefCell<GlobalState>;\n \n /// Indicates which kind of access is being performed.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n@@ -449,21 +445,21 @@ impl<'tcx> Stack {\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n-    fn new(size: Size, perm: Permission, tag: Tag, extra: MemoryExtra) -> Self {\n+    fn new(size: Size, perm: Permission, tag: Tag) -> Self {\n         let item = Item { perm, tag, protector: None };\n         let stack = Stack { borrows: vec![item] };\n \n-        Stacks { stacks: RefCell::new(RangeMap::new(size, stack)), global: extra }\n+        Stacks { stacks: RefCell::new(RangeMap::new(size, stack)) }\n     }\n \n     /// Call `f` on every stack in the range.\n     fn for_each(\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        global: &GlobalState,\n         f: impl Fn(Pointer<Tag>, &mut Stack, &GlobalState) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n             let mut cur_ptr = ptr;\n@@ -479,16 +475,17 @@ impl Stacks {\n     pub fn new_allocation(\n         id: AllocId,\n         size: Size,\n-        extra: MemoryExtra,\n+        extra: &MemoryExtra,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> (Self, Tag) {\n+        let mut extra = extra.borrow_mut();\n         let (tag, perm) = match kind {\n             // New unique borrow. This tag is not accessible by the program,\n             // so it will only ever be used when using the local directly (i.e.,\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (Tag::Tagged(extra.borrow_mut().new_ptr()), Permission::Unique),\n+            MemoryKind::Stack => (Tag::Tagged(extra.new_ptr()), Permission::Unique),\n             // `Global` memory can be referenced by global pointers from `tcx`.\n             // Thus we call `global_base_ptr` such that the global pointers get the same tag\n             // as what we use here.\n@@ -500,38 +497,38 @@ impl Stacks {\n                 | MiriMemoryKind::ExternStatic\n                 | MiriMemoryKind::Tls\n                 | MiriMemoryKind::Env,\n-            ) => (extra.borrow_mut().global_base_ptr(id), Permission::SharedReadWrite),\n+            ) => (extra.global_base_ptr(id), Permission::SharedReadWrite),\n             // Everything else we handle like raw pointers for now.\n             _ => {\n-                let mut extra = extra.borrow_mut();\n                 let tag =\n                     if extra.track_raw { Tag::Tagged(extra.new_ptr()) } else { Tag::Untagged };\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n-        (Stacks::new(size, perm, tag, extra), tag)\n+        (Stacks::new(size, perm, tag), tag)\n     }\n \n     #[inline(always)]\n-    pub fn memory_read<'tcx>(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n+    pub fn memory_read<'tcx>(&self, ptr: Pointer<Tag>, size: Size, extra: &MemoryExtra) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |ptr, stack, global| stack.access(AccessKind::Read, ptr, global))\n+        self.for_each(ptr, size, &*extra.borrow(), |ptr, stack, global| stack.access(AccessKind::Read, ptr, global))\n     }\n \n     #[inline(always)]\n-    pub fn memory_written<'tcx>(&mut self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n+    pub fn memory_written<'tcx>(&mut self, ptr: Pointer<Tag>, size: Size, extra: &mut MemoryExtra) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |ptr, stack, global| stack.access(AccessKind::Write, ptr, global))\n+        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| stack.access(AccessKind::Write, ptr, global))\n     }\n \n     #[inline(always)]\n     pub fn memory_deallocated<'tcx>(\n         &mut self,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        extra: &mut MemoryExtra,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |ptr, stack, global| stack.dealloc(ptr, global))\n+        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| stack.dealloc(ptr, global))\n     }\n }\n \n@@ -560,10 +557,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             size.bytes()\n         );\n \n-        // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n+        // Get the allocation. We need both the allocation and the MemoryExtra, so we cannot use `&mut`.\n+        // FIXME: make `get_alloc_extra_mut` also return `&mut MemoryExtra`.\n         let extra = this.memory.get_alloc_extra(ptr.alloc_id)?;\n         let stacked_borrows =\n             extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+        let global = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow();\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -583,14 +582,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    stacked_borrows.for_each(cur_ptr, size, |cur_ptr, stack, global| {\n+                    stacked_borrows.for_each(cur_ptr, size, &*global, |cur_ptr, stack, global| {\n                         stack.grant(cur_ptr, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows.for_each(ptr, size, |ptr, stack, global| stack.grant(ptr, item, global))\n+        stacked_borrows.for_each(ptr, size, &*global, |ptr, stack, global| stack.grant(ptr, item, global))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version."}]}