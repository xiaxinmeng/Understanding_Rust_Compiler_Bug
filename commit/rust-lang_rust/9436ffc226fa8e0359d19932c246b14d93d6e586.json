{"sha": "9436ffc226fa8e0359d19932c246b14d93d6e586", "node_id": "C_kwDOAAsO6NoAKDk0MzZmZmMyMjZmYThlMDM1OWQxOTkzMmMyNDZiMTRkOTNkNmU1ODY", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-09-28T04:07:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-28T04:07:17Z"}, "message": "Rollup merge of #102288 - mejrs:inner, r=compiler-errors\n\nSuggest unwrapping `???<T>` if a method cannot be found on it but is present on `T`.\n\nThis suggests various ways to get inside wrapper types if the method cannot be found on the wrapper type, but is present on the wrappee.\n\nFor this PR, those wrapper types include `Localkey`, `MaybeUninit`, `RefCell`, `RwLock` and `Mutex`.", "tree": {"sha": "1e9812b33d136a8ef1e68ac38327043ae24ea3a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e9812b33d136a8ef1e68ac38327043ae24ea3a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9436ffc226fa8e0359d19932c246b14d93d6e586", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjM8h1CRBK7hj4Ov3rIwAAnpYIADuZhGbzibpqb+4LkFQE2ouh\nULpl5coDQnW8shQGoBtJUd222QTtg2uDfIAsp3N6XFw5Q0Xo0XYKl+Ufr2w+j4s+\n/MfBV48GRV7lTSX92JQhcUe+7PF5Fll/PTo0if1A7pOdHv9h6Vo2OlP3mw9w4bdN\nDg/YPUVn20ZZyH1li24v7umIBFrdbC7lfOO+L9upKbPey1C6WKjKhwHYSf0/q5Fy\nPKr3YvUWaVGJHj4JkJ3xCm5iG5BDmCP62wrkjPNlnarBvwaHoxfEFad2FIByDBgv\n7i5heeK67VrHrfjhQXoL+EiJ8SUc6Hi4R5L+dJL74i3o1clLJOogwFhlBM9Oc5Y=\n=k5gM\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e9812b33d136a8ef1e68ac38327043ae24ea3a2\nparent 07bb2e65276d21ef97a6bdbcfdd74cfce47baa37\nparent 4ff83cee95cf73708cc5455f4ecce5eb1c21ffc6\nauthor Yuki Okushi <jtitor@2k36.org> 1664338037 +0900\ncommitter GitHub <noreply@github.com> 1664338037 +0900\n\nRollup merge of #102288 - mejrs:inner, r=compiler-errors\n\nSuggest unwrapping `???<T>` if a method cannot be found on it but is present on `T`.\n\nThis suggests various ways to get inside wrapper types if the method cannot be found on the wrapper type, but is present on the wrappee.\n\nFor this PR, those wrapper types include `Localkey`, `MaybeUninit`, `RefCell`, `RwLock` and `Mutex`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9436ffc226fa8e0359d19932c246b14d93d6e586", "html_url": "https://github.com/rust-lang/rust/commit/9436ffc226fa8e0359d19932c246b14d93d6e586", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9436ffc226fa8e0359d19932c246b14d93d6e586/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07bb2e65276d21ef97a6bdbcfdd74cfce47baa37", "url": "https://api.github.com/repos/rust-lang/rust/commits/07bb2e65276d21ef97a6bdbcfdd74cfce47baa37", "html_url": "https://github.com/rust-lang/rust/commit/07bb2e65276d21ef97a6bdbcfdd74cfce47baa37"}, {"sha": "4ff83cee95cf73708cc5455f4ecce5eb1c21ffc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff83cee95cf73708cc5455f4ecce5eb1c21ffc6", "html_url": "https://github.com/rust-lang/rust/commit/4ff83cee95cf73708cc5455f4ecce5eb1c21ffc6"}], "stats": {"total": 434, "additions": 373, "deletions": 61}, "files": [{"sha": "0e82e4956c7c17d582329b4c3a7f313c260f9f1f", "filename": "compiler/rustc_hir_analysis/src/check/method/suggest.rs", "status": "modified", "additions": 149, "deletions": 61, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -2,6 +2,7 @@\n //! found or is otherwise invalid.\n \n use crate::check::FnCtxt;\n+use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n@@ -30,7 +31,7 @@ use rustc_trait_selection::traits::{\n use std::cmp::Ordering;\n use std::iter;\n \n-use super::probe::{IsSuggestion, Mode, ProbeScope};\n+use super::probe::{AutorefOrPtrAdjustment, IsSuggestion, Mode, ProbeScope};\n use super::{CandidateSource, MethodError, NoMatchData};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -983,7 +984,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.check_for_field_method(&mut err, source, span, actual, item_name);\n                 }\n \n-                self.check_for_unwrap_self(&mut err, source, span, actual, item_name);\n+                self.check_for_inner_self(&mut err, source, span, actual, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n@@ -1395,7 +1396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_for_unwrap_self(\n+    fn check_for_inner_self(\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n@@ -1408,81 +1409,168 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n \n         let ty::Adt(kind, substs) = actual.kind() else { return; };\n-        if !kind.is_enum() {\n-            return;\n-        }\n+        match kind.adt_kind() {\n+            ty::AdtKind::Enum => {\n+                let matching_variants: Vec<_> = kind\n+                    .variants()\n+                    .iter()\n+                    .flat_map(|variant| {\n+                        let [field] = &variant.fields[..] else { return None; };\n+                        let field_ty = field.ty(tcx, substs);\n+\n+                        // Skip `_`, since that'll just lead to ambiguity.\n+                        if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n+                            return None;\n+                        }\n \n-        let matching_variants: Vec<_> = kind\n-            .variants()\n-            .iter()\n-            .flat_map(|variant| {\n-                let [field] = &variant.fields[..] else { return None; };\n-                let field_ty = field.ty(tcx, substs);\n+                        self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            field_ty,\n+                            call_expr,\n+                            ProbeScope::TraitsInScope,\n+                        )\n+                        .ok()\n+                        .map(|pick| (variant, field, pick))\n+                    })\n+                    .collect();\n+\n+                let ret_ty_matches = |diagnostic_item| {\n+                    if let Some(ret_ty) = self\n+                        .ret_coercion\n+                        .as_ref()\n+                        .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n+                        && let ty::Adt(kind, _) = ret_ty.kind()\n+                        && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n+                    {\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                };\n \n-                // Skip `_`, since that'll just lead to ambiguity.\n-                if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n-                    return None;\n+                match &matching_variants[..] {\n+                    [(_, field, pick)] => {\n+                        let self_ty = field.ty(tcx, substs);\n+                        err.span_note(\n+                            tcx.def_span(pick.item.def_id),\n+                            &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n+                        );\n+                        let (article, kind, variant, question) =\n+                            if tcx.is_diagnostic_item(sym::Result, kind.did()) {\n+                                (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n+                            } else if tcx.is_diagnostic_item(sym::Option, kind.did()) {\n+                                (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n+                            } else {\n+                                return;\n+                            };\n+                        if question {\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_hi(),\n+                                format!(\n+                                    \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n+                                    {article} `{kind}::{variant}` value to the caller\"\n+                                ),\n+                                \"?\",\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_hi(),\n+                                format!(\n+                                    \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n+                                    panicking if the value is {article} `{kind}::{variant}`\"\n+                                ),\n+                                \".expect(\\\"REASON\\\")\",\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                    }\n+                    // FIXME(compiler-errors): Support suggestions for other matching enum variants\n+                    _ => {}\n                 }\n-\n-                self.lookup_probe(span, item_name, field_ty, call_expr, ProbeScope::AllTraits)\n-                    .ok()\n-                    .map(|pick| (variant, field, pick))\n-            })\n-            .collect();\n-\n-        let ret_ty_matches = |diagnostic_item| {\n-            if let Some(ret_ty) = self\n-                .ret_coercion\n-                .as_ref()\n-                .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n-                && let ty::Adt(kind, _) = ret_ty.kind()\n-                && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n-            {\n-                true\n-            } else {\n-                false\n             }\n-        };\n+            // Target wrapper types - types that wrap or pretend to wrap another type,\n+            // perhaps this inner type is meant to be called?\n+            ty::AdtKind::Struct | ty::AdtKind::Union => {\n+                let [first] = ***substs else { return; };\n+                let ty::GenericArgKind::Type(ty) = first.unpack() else { return; };\n+                let Ok(pick) = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            ty,\n+                            call_expr,\n+                            ProbeScope::TraitsInScope,\n+                        )  else { return; };\n \n-        match &matching_variants[..] {\n-            [(_, field, pick)] => {\n-                let self_ty = field.ty(tcx, substs);\n-                err.span_note(\n-                    tcx.def_span(pick.item.def_id),\n-                    &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n-                );\n-                let (article, kind, variant, question) =\n-                    if Some(kind.did()) == tcx.get_diagnostic_item(sym::Result) {\n-                        (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n-                    } else if Some(kind.did()) == tcx.get_diagnostic_item(sym::Option) {\n-                        (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n-                    } else {\n-                        return;\n+                let name = self.ty_to_value_string(actual);\n+                let inner_id = kind.did();\n+                let mutable = if let Some(AutorefOrPtrAdjustment::Autoref { mutbl, .. }) =\n+                    pick.autoref_or_ptr_adjustment\n+                {\n+                    Some(mutbl)\n+                } else {\n+                    None\n+                };\n+\n+                if tcx.is_diagnostic_item(sym::LocalKey, inner_id) {\n+                    err.help(\"use `with` or `try_with` to access thread local storage\");\n+                } else if Some(kind.did()) == tcx.lang_items().maybe_uninit() {\n+                    err.help(format!(\n+                        \"if this `{name}` has been initialized, \\\n+                        use one of the `assume_init` methods to access the inner value\"\n+                    ));\n+                } else if tcx.is_diagnostic_item(sym::RefCell, inner_id) {\n+                    let (suggestion, borrow_kind, panic_if) = match mutable {\n+                        Some(Mutability::Not) => (\".borrow()\", \"borrow\", \"a mutable borrow exists\"),\n+                        Some(Mutability::Mut) => {\n+                            (\".borrow_mut()\", \"mutably borrow\", \"any borrows exist\")\n+                        }\n+                        None => return,\n                     };\n-                if question {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n                         format!(\n-                            \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n-                            {article} `{kind}::{variant}` value to the caller\"\n+                            \"use `{suggestion}` to {borrow_kind} the `{ty}`, \\\n+                            panicking if {panic_if}\"\n                         ),\n-                        \"?\",\n-                        Applicability::MachineApplicable,\n+                        suggestion,\n+                        Applicability::MaybeIncorrect,\n                     );\n-                } else {\n+                } else if tcx.is_diagnostic_item(sym::Mutex, inner_id) {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n                         format!(\n-                            \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n-                             panicking if the value is {article} `{kind}::{variant}`\"\n+                            \"use `.lock().unwrap()` to borrow the `{ty}`, \\\n+                            blocking the current thread until it can be acquired\"\n                         ),\n-                        \".expect(\\\"REASON\\\")\",\n-                        Applicability::HasPlaceholders,\n+                        \".lock().unwrap()\",\n+                        Applicability::MaybeIncorrect,\n                     );\n-                }\n+                } else if tcx.is_diagnostic_item(sym::RwLock, inner_id) {\n+                    let (suggestion, borrow_kind) = match mutable {\n+                        Some(Mutability::Not) => (\".read().unwrap()\", \"borrow\"),\n+                        Some(Mutability::Mut) => (\".write().unwrap()\", \"mutably borrow\"),\n+                        None => return,\n+                    };\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\n+                            \"use `{suggestion}` to {borrow_kind} the `{ty}`, \\\n+                            blocking the current thread until it can be acquired\"\n+                        ),\n+                        suggestion,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    return;\n+                };\n+\n+                err.span_note(\n+                    tcx.def_span(pick.item.def_id),\n+                    &format!(\"the method `{item_name}` exists on the type `{ty}`\"),\n+                );\n             }\n-            // FIXME(compiler-errors): Support suggestions for other matching enum variants\n-            _ => {}\n         }\n     }\n "}, {"sha": "67ffc573b990acd074c249faec5a23e1b5db34b1", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -224,6 +224,7 @@ symbols! {\n         Left,\n         LinkedList,\n         LintPass,\n+        LocalKey,\n         Mutex,\n         MutexGuard,\n         N,\n@@ -266,6 +267,7 @@ symbols! {\n         Rc,\n         Ready,\n         Receiver,\n+        RefCell,\n         Relaxed,\n         Release,\n         Result,\n@@ -274,6 +276,7 @@ symbols! {\n         Rust,\n         RustcDecodable,\n         RustcEncodable,\n+        RwLock,\n         RwLockReadGuard,\n         RwLockWriteGuard,\n         Send,"}, {"sha": "288cab1ef399470a93149829a93d369932276e00", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -614,6 +614,7 @@ impl<T, const N: usize> Cell<[T; N]> {\n /// A mutable memory location with dynamically checked borrow rules\n ///\n /// See the [module-level documentation](self) for more.\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"RefCell\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T: ?Sized> {\n     borrow: Cell<BorrowFlag>,"}, {"sha": "ee2c79b6669b8d94b8dc8f1acb26b3d10aa36c33", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -76,6 +76,7 @@ use crate::sys_common::rwlock as sys;\n ///\n /// [`Mutex`]: super::Mutex\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"RwLock\")]\n pub struct RwLock<T: ?Sized> {\n     inner: sys::MovableRwLock,\n     poison: poison::Flag,"}, {"sha": "ffd17dc99093aeb036898c96abe21b3f4bd03d9d", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -95,6 +95,7 @@ use crate::fmt;\n /// [loader lock]: https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices\n /// [`JoinHandle::join`]: crate::thread::JoinHandle::join\n /// [`with`]: LocalKey::with\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"LocalKey\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LocalKey<T: 'static> {\n     // This outer `LocalKey<T>` type is what's going to be stored in statics,"}, {"sha": "7af7391ca851d5148c2584869aa58e05979881fe", "filename": "src/test/ui/suggestions/inner_type.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -0,0 +1,40 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+fn main() {\n+    let other_item = std::cell::RefCell::new(Struct { p: 42_u32 });\n+\n+    other_item.borrow().method();\n+    //~^ ERROR no method named `method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP use `.borrow()` to borrow the `Struct<u32>`, panicking if a mutable borrow exists\n+\n+    other_item.borrow_mut().some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP .borrow_mut()` to mutably borrow the `Struct<u32>`, panicking if any borrows exist\n+\n+    let another_item = std::sync::Mutex::new(Struct { p: 42_u32 });\n+\n+    another_item.lock().unwrap().method();\n+    //~^ ERROR no method named `method` found for struct `Mutex` in the current scope [E0599]\n+    //~| HELP use `.lock().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+\n+    let another_item = std::sync::RwLock::new(Struct { p: 42_u32 });\n+\n+    another_item.read().unwrap().method();\n+    //~^ ERROR no method named `method` found for struct `RwLock` in the current scope [E0599]\n+    //~| HELP  use `.read().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+\n+    another_item.write().unwrap().some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RwLock` in the current scope [E0599]\n+    //~| HELP use `.write().unwrap()` to mutably borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+}"}, {"sha": "4aca50716258aa746a4b50ce87a7a4ba451bc983", "filename": "src/test/ui/suggestions/inner_type.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -0,0 +1,40 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+fn main() {\n+    let other_item = std::cell::RefCell::new(Struct { p: 42_u32 });\n+\n+    other_item.method();\n+    //~^ ERROR no method named `method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP use `.borrow()` to borrow the `Struct<u32>`, panicking if a mutable borrow exists\n+\n+    other_item.some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP .borrow_mut()` to mutably borrow the `Struct<u32>`, panicking if any borrows exist\n+\n+    let another_item = std::sync::Mutex::new(Struct { p: 42_u32 });\n+\n+    another_item.method();\n+    //~^ ERROR no method named `method` found for struct `Mutex` in the current scope [E0599]\n+    //~| HELP use `.lock().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+\n+    let another_item = std::sync::RwLock::new(Struct { p: 42_u32 });\n+\n+    another_item.method();\n+    //~^ ERROR no method named `method` found for struct `RwLock` in the current scope [E0599]\n+    //~| HELP  use `.read().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+\n+    another_item.some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RwLock` in the current scope [E0599]\n+    //~| HELP use `.write().unwrap()` to mutably borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+}"}, {"sha": "5ac3d04f104142d803267d33be1ef9ec72112c08", "filename": "src/test/ui/suggestions/inner_type.stderr", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -0,0 +1,83 @@\n+error[E0599]: no method named `method` found for struct `RefCell` in the current scope\n+  --> $DIR/inner_type.rs:17:16\n+   |\n+LL |     other_item.method();\n+   |                ^^^^^^ method not found in `RefCell<Struct<u32>>`\n+   |\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:9:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `.borrow()` to borrow the `Struct<u32>`, panicking if a mutable borrow exists\n+   |\n+LL |     other_item.borrow().method();\n+   |               +++++++++\n+\n+error[E0599]: no method named `some_mutable_method` found for struct `RefCell` in the current scope\n+  --> $DIR/inner_type.rs:21:16\n+   |\n+LL |     other_item.some_mutable_method();\n+   |                ^^^^^^^^^^^^^^^^^^^ method not found in `RefCell<Struct<u32>>`\n+   |\n+note: the method `some_mutable_method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:11:5\n+   |\n+LL |     pub fn some_mutable_method(&mut self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `.borrow_mut()` to mutably borrow the `Struct<u32>`, panicking if any borrows exist\n+   |\n+LL |     other_item.borrow_mut().some_mutable_method();\n+   |               +++++++++++++\n+\n+error[E0599]: no method named `method` found for struct `Mutex` in the current scope\n+  --> $DIR/inner_type.rs:27:18\n+   |\n+LL |     another_item.method();\n+   |                  ^^^^^^ method not found in `Mutex<Struct<u32>>`\n+   |\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:9:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `.lock().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+   |\n+LL |     another_item.lock().unwrap().method();\n+   |                 ++++++++++++++++\n+\n+error[E0599]: no method named `method` found for struct `RwLock` in the current scope\n+  --> $DIR/inner_type.rs:33:18\n+   |\n+LL |     another_item.method();\n+   |                  ^^^^^^ method not found in `RwLock<Struct<u32>>`\n+   |\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:9:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `.read().unwrap()` to borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+   |\n+LL |     another_item.read().unwrap().method();\n+   |                 ++++++++++++++++\n+\n+error[E0599]: no method named `some_mutable_method` found for struct `RwLock` in the current scope\n+  --> $DIR/inner_type.rs:37:18\n+   |\n+LL |     another_item.some_mutable_method();\n+   |                  ^^^^^^^^^^^^^^^^^^^ method not found in `RwLock<Struct<u32>>`\n+   |\n+note: the method `some_mutable_method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:11:5\n+   |\n+LL |     pub fn some_mutable_method(&mut self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `.write().unwrap()` to mutably borrow the `Struct<u32>`, blocking the current thread until it can be acquired\n+   |\n+LL |     another_item.write().unwrap().some_mutable_method();\n+   |                 +++++++++++++++++\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "c56ea7c030d8e1b685dd34df73e7ddf95e9569cc", "filename": "src/test/ui/suggestions/inner_type2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -0,0 +1,26 @@\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+thread_local! {\n+    static STRUCT: Struct<u32> = Struct {\n+        p: 42_u32\n+    };\n+}\n+\n+fn main() {\n+    STRUCT.method();\n+    //~^ ERROR no method named `method` found for struct `LocalKey` in the current scope [E0599]\n+    //~| HELP use `with` or `try_with` to access thread local storage\n+\n+    let item = std::mem::MaybeUninit::new(Struct { p: 42_u32 });\n+    item.method();\n+    //~^ ERROR no method named `method` found for union `MaybeUninit` in the current scope [E0599]\n+    //~| HELP if this `MaybeUninit::<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n+}"}, {"sha": "eddfd9d63409d3d6eca49c29c3317ce2e4562e58", "filename": "src/test/ui/suggestions/inner_type2.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9436ffc226fa8e0359d19932c246b14d93d6e586/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr?ref=9436ffc226fa8e0359d19932c246b14d93d6e586", "patch": "@@ -0,0 +1,29 @@\n+error[E0599]: no method named `method` found for struct `LocalKey` in the current scope\n+  --> $DIR/inner_type2.rs:18:12\n+   |\n+LL |     STRUCT.method();\n+   |            ^^^^^^ method not found in `LocalKey<Struct<u32>>`\n+   |\n+   = help: use `with` or `try_with` to access thread local storage\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type2.rs:6:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `method` found for union `MaybeUninit` in the current scope\n+  --> $DIR/inner_type2.rs:23:10\n+   |\n+LL |     item.method();\n+   |          ^^^^^^ method not found in `MaybeUninit<Struct<u32>>`\n+   |\n+   = help: if this `MaybeUninit::<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type2.rs:6:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}