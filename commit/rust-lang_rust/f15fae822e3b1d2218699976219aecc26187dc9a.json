{"sha": "f15fae822e3b1d2218699976219aecc26187dc9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNWZhZTgyMmUzYjFkMjIxODY5OTk3NjIxOWFlY2MyNjE4N2RjOWE=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-29T23:14:33Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-01-11T20:13:26Z"}, "message": "rustc_serialize: fix incorrect signed LEB128 decoding\n\nThe signed LEB128 decoding function used a hardcoded constant of 64\ninstead of the number of bits in the type of integer being decoded,\nwhich resulted in incorrect results for some inputs. Fix this, make the\ndecoding more consistent with the unsigned version, and increase the\nLEB128 encoding and decoding test coverage.", "tree": {"sha": "d8c2a7905df00d736de11e5cb46c605ff6f1e13e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8c2a7905df00d736de11e5cb46c605ff6f1e13e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f15fae822e3b1d2218699976219aecc26187dc9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f15fae822e3b1d2218699976219aecc26187dc9a", "html_url": "https://github.com/rust-lang/rust/commit/f15fae822e3b1d2218699976219aecc26187dc9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f15fae822e3b1d2218699976219aecc26187dc9a/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52f21791fbec58e14a54b8c6f9146807a8ae8d84", "url": "https://api.github.com/repos/rust-lang/rust/commits/52f21791fbec58e14a54b8c6f9146807a8ae8d84", "html_url": "https://github.com/rust-lang/rust/commit/52f21791fbec58e14a54b8c6f9146807a8ae8d84"}], "stats": {"total": 147, "additions": 89, "deletions": 58}, "files": [{"sha": "ea2df80e641683b08017500a5659d4a78af331be", "filename": "compiler/rustc_serialize/src/leb128.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f15fae822e3b1d2218699976219aecc26187dc9a/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15fae822e3b1d2218699976219aecc26187dc9a/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fleb128.rs?ref=f15fae822e3b1d2218699976219aecc26187dc9a", "patch": "@@ -119,28 +119,38 @@ impl_write_signed_leb128!(write_i64_leb128, i64);\n impl_write_signed_leb128!(write_i128_leb128, i128);\n impl_write_signed_leb128!(write_isize_leb128, isize);\n \n-#[inline]\n-pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i128, usize) {\n-    let mut result = 0;\n-    let mut shift = 0;\n-    let mut position = start_position;\n-    let mut byte;\n-\n-    loop {\n-        byte = data[position];\n-        position += 1;\n-        result |= i128::from(byte & 0x7F) << shift;\n-        shift += 7;\n-\n-        if (byte & 0x80) == 0 {\n-            break;\n-        }\n-    }\n+macro_rules! impl_read_signed_leb128 {\n+    ($fn_name:ident, $int_ty:ty) => {\n+        #[inline]\n+        pub fn $fn_name(slice: &[u8]) -> ($int_ty, usize) {\n+            let mut result = 0;\n+            let mut shift = 0;\n+            let mut position = 0;\n+            let mut byte;\n+\n+            loop {\n+                byte = slice[position];\n+                position += 1;\n+                result |= <$int_ty>::from(byte & 0x7F) << shift;\n+                shift += 7;\n+\n+                if (byte & 0x80) == 0 {\n+                    break;\n+                }\n+            }\n \n-    if (shift < 64) && ((byte & 0x40) != 0) {\n-        // sign extend\n-        result |= -(1 << shift);\n-    }\n+            if (shift < <$int_ty>::BITS) && ((byte & 0x40) != 0) {\n+                // sign extend\n+                result |= (!0 << shift);\n+            }\n \n-    (result, position - start_position)\n+            (result, position)\n+        }\n+    };\n }\n+\n+impl_read_signed_leb128!(read_i16_leb128, i16);\n+impl_read_signed_leb128!(read_i32_leb128, i32);\n+impl_read_signed_leb128!(read_i64_leb128, i64);\n+impl_read_signed_leb128!(read_i128_leb128, i128);\n+impl_read_signed_leb128!(read_isize_leb128, isize);"}, {"sha": "53c3adcc20c02221e769f74004b77d8f612f5429", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f15fae822e3b1d2218699976219aecc26187dc9a/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15fae822e3b1d2218699976219aecc26187dc9a/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=f15fae822e3b1d2218699976219aecc26187dc9a", "patch": "@@ -17,6 +17,7 @@ Core encoding and decoding interfaces.\n #![feature(min_specialization)]\n #![feature(vec_spare_capacity)]\n #![feature(core_intrinsics)]\n+#![feature(int_bits_const)]\n #![feature(maybe_uninit_slice)]\n #![feature(new_uninit)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "3e37fc87ce6f9a92e30a81c3852b7474f3bff182", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f15fae822e3b1d2218699976219aecc26187dc9a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15fae822e3b1d2218699976219aecc26187dc9a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=f15fae822e3b1d2218699976219aecc26187dc9a", "patch": "@@ -1,4 +1,4 @@\n-use crate::leb128::{self, max_leb128_len, read_signed_leb128};\n+use crate::leb128::{self, max_leb128_len};\n use crate::serialize;\n use std::borrow::Cow;\n use std::fs::File;\n@@ -561,22 +561,14 @@ impl<'a> Decoder<'a> {\n     }\n }\n \n-macro_rules! read_uleb128 {\n+macro_rules! read_leb128 {\n     ($dec:expr, $fun:ident) => {{\n         let (value, bytes_read) = leb128::$fun(&$dec.data[$dec.position..]);\n         $dec.position += bytes_read;\n         Ok(value)\n     }};\n }\n \n-macro_rules! read_sleb128 {\n-    ($dec:expr, $t:ty) => {{\n-        let (value, bytes_read) = read_signed_leb128($dec.data, $dec.position);\n-        $dec.position += bytes_read;\n-        Ok(value as $t)\n-    }};\n-}\n-\n impl<'a> serialize::Decoder for Decoder<'a> {\n     type Error = String;\n \n@@ -587,22 +579,22 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n \n     #[inline]\n     fn read_u128(&mut self) -> Result<u128, Self::Error> {\n-        read_uleb128!(self, read_u128_leb128)\n+        read_leb128!(self, read_u128_leb128)\n     }\n \n     #[inline]\n     fn read_u64(&mut self) -> Result<u64, Self::Error> {\n-        read_uleb128!(self, read_u64_leb128)\n+        read_leb128!(self, read_u64_leb128)\n     }\n \n     #[inline]\n     fn read_u32(&mut self) -> Result<u32, Self::Error> {\n-        read_uleb128!(self, read_u32_leb128)\n+        read_leb128!(self, read_u32_leb128)\n     }\n \n     #[inline]\n     fn read_u16(&mut self) -> Result<u16, Self::Error> {\n-        read_uleb128!(self, read_u16_leb128)\n+        read_leb128!(self, read_u16_leb128)\n     }\n \n     #[inline]\n@@ -614,27 +606,27 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n \n     #[inline]\n     fn read_usize(&mut self) -> Result<usize, Self::Error> {\n-        read_uleb128!(self, read_usize_leb128)\n+        read_leb128!(self, read_usize_leb128)\n     }\n \n     #[inline]\n     fn read_i128(&mut self) -> Result<i128, Self::Error> {\n-        read_sleb128!(self, i128)\n+        read_leb128!(self, read_i128_leb128)\n     }\n \n     #[inline]\n     fn read_i64(&mut self) -> Result<i64, Self::Error> {\n-        read_sleb128!(self, i64)\n+        read_leb128!(self, read_i64_leb128)\n     }\n \n     #[inline]\n     fn read_i32(&mut self) -> Result<i32, Self::Error> {\n-        read_sleb128!(self, i32)\n+        read_leb128!(self, read_i32_leb128)\n     }\n \n     #[inline]\n     fn read_i16(&mut self) -> Result<i16, Self::Error> {\n-        read_sleb128!(self, i16)\n+        read_leb128!(self, read_i16_leb128)\n     }\n \n     #[inline]\n@@ -646,7 +638,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n \n     #[inline]\n     fn read_isize(&mut self) -> Result<isize, Self::Error> {\n-        read_sleb128!(self, isize)\n+        read_leb128!(self, read_isize_leb128)\n     }\n \n     #[inline]"}, {"sha": "a2bcf2c251d7ab1295f4293c9628819d956bcb20", "filename": "compiler/rustc_serialize/tests/leb128.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f15fae822e3b1d2218699976219aecc26187dc9a/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15fae822e3b1d2218699976219aecc26187dc9a/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs?ref=f15fae822e3b1d2218699976219aecc26187dc9a", "patch": "@@ -1,3 +1,4 @@\n+#![feature(int_bits_const)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n \n@@ -8,16 +9,28 @@ macro_rules! impl_test_unsigned_leb128 {\n     ($test_name:ident, $write_fn_name:ident, $read_fn_name:ident, $int_ty:ident) => {\n         #[test]\n         fn $test_name() {\n+            // Test 256 evenly spaced values of integer range,\n+            // integer max value, and some \"random\" numbers.\n+            let mut values = Vec::new();\n+\n+            let increment = (1 as $int_ty) << ($int_ty::BITS - 8);\n+            values.extend((0..256).map(|i| $int_ty::MIN + i * increment));\n+\n+            values.push($int_ty::MAX);\n+\n+            values.extend(\n+                (-500..500).map(|i| (i as $int_ty).wrapping_mul(0x12345789ABCDEFu64 as $int_ty)),\n+            );\n+\n             let mut stream = Vec::new();\n \n-            for x in 0..62 {\n+            for &x in &values {\n                 let mut buf = MaybeUninit::uninit_array();\n-                stream.extend($write_fn_name(&mut buf, (3u64 << x) as $int_ty));\n+                stream.extend($write_fn_name(&mut buf, x));\n             }\n \n             let mut position = 0;\n-            for x in 0..62 {\n-                let expected = (3u64 << x) as $int_ty;\n+            for &expected in &values {\n                 let (actual, bytes_read) = $read_fn_name(&stream[position..]);\n                 assert_eq!(expected, actual);\n                 position += bytes_read;\n@@ -34,12 +47,28 @@ impl_test_unsigned_leb128!(test_u128_leb128, write_u128_leb128, read_u128_leb128\n impl_test_unsigned_leb128!(test_usize_leb128, write_usize_leb128, read_usize_leb128, usize);\n \n macro_rules! impl_test_signed_leb128 {\n-    ($test_name:ident, $write_fn_name:ident, $int_ty:ident) => {\n+    ($test_name:ident, $write_fn_name:ident, $read_fn_name:ident, $int_ty:ident) => {\n         #[test]\n         fn $test_name() {\n-            let values: Vec<_> = (-500..500)\n-                .map(|i| ((i as $int_ty).wrapping_mul(0x12345789ABCDEF_i64 as $int_ty)))\n-                .collect();\n+            // Test 256 evenly spaced values of integer range,\n+            // integer max value, and some \"random\" numbers.\n+            let mut values = Vec::new();\n+\n+            let mut value = $int_ty::MIN;\n+            let increment = (1 as $int_ty) << ($int_ty::BITS - 8);\n+\n+            for _ in 0..256 {\n+                values.push(value);\n+                // The addition in the last loop iteration overflows.\n+                value = value.wrapping_add(increment);\n+            }\n+\n+            values.push($int_ty::MAX);\n+\n+            values.extend(\n+                (-500..500).map(|i| (i as $int_ty).wrapping_mul(0x12345789ABCDEFi64 as $int_ty)),\n+            );\n+\n             let mut stream = Vec::new();\n \n             for &x in &values {\n@@ -48,9 +77,8 @@ macro_rules! impl_test_signed_leb128 {\n             }\n \n             let mut position = 0;\n-            for &x in &values {\n-                let expected = x as i128;\n-                let (actual, bytes_read) = read_signed_leb128(&mut stream, position);\n+            for &expected in &values {\n+                let (actual, bytes_read) = $read_fn_name(&stream[position..]);\n                 assert_eq!(expected, actual);\n                 position += bytes_read;\n             }\n@@ -59,8 +87,8 @@ macro_rules! impl_test_signed_leb128 {\n     };\n }\n \n-impl_test_signed_leb128!(test_i16_leb128, write_i16_leb128, i16);\n-impl_test_signed_leb128!(test_i32_leb128, write_i32_leb128, i32);\n-impl_test_signed_leb128!(test_i64_leb128, write_i64_leb128, i64);\n-impl_test_signed_leb128!(test_i128_leb128, write_i128_leb128, i128);\n-impl_test_signed_leb128!(test_isize_leb128, write_isize_leb128, isize);\n+impl_test_signed_leb128!(test_i16_leb128, write_i16_leb128, read_i16_leb128, i16);\n+impl_test_signed_leb128!(test_i32_leb128, write_i32_leb128, read_i32_leb128, i32);\n+impl_test_signed_leb128!(test_i64_leb128, write_i64_leb128, read_i64_leb128, i64);\n+impl_test_signed_leb128!(test_i128_leb128, write_i128_leb128, read_i128_leb128, i128);\n+impl_test_signed_leb128!(test_isize_leb128, write_isize_leb128, read_isize_leb128, isize);"}]}