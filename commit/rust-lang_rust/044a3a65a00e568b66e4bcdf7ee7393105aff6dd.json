{"sha": "044a3a65a00e568b66e4bcdf7ee7393105aff6dd", "node_id": "C_kwDOAAsO6NoAKDA0NGEzYTY1YTAwZTU2OGI2NmU0YmNkZjdlZTczOTMxMDVhZmY2ZGQ", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-01-04T17:19:52Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-02-05T17:00:47Z"}, "message": "Support const and sym operands in inline asm", "tree": {"sha": "10a28c728ccf78bb26d1d04e3bbfd649a7c7ca6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10a28c728ccf78bb26d1d04e3bbfd649a7c7ca6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/044a3a65a00e568b66e4bcdf7ee7393105aff6dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/044a3a65a00e568b66e4bcdf7ee7393105aff6dd", "html_url": "https://github.com/rust-lang/rust/commit/044a3a65a00e568b66e4bcdf7ee7393105aff6dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/044a3a65a00e568b66e4bcdf7ee7393105aff6dd/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b481380394bad81054a4049b338c455dbf9d4d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b481380394bad81054a4049b338c455dbf9d4d7", "html_url": "https://github.com/rust-lang/rust/commit/8b481380394bad81054a4049b338c455dbf9d4d7"}], "stats": {"total": 168, "additions": 122, "deletions": 46}, "files": [{"sha": "aa0b51181f40a8b81f91ac43cbac1438e7c6057e", "filename": "src/inline_asm.rs", "status": "modified", "additions": 122, "deletions": 46, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/044a3a65a00e568b66e4bcdf7ee7393105aff6dd/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044a3a65a00e568b66e4bcdf7ee7393105aff6dd/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=044a3a65a00e568b66e4bcdf7ee7393105aff6dd", "patch": "@@ -6,12 +6,37 @@ use std::fmt::Write;\n \n use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir::InlineAsmOperand;\n+use rustc_middle::ty::SymbolName;\n use rustc_span::sym;\n use rustc_target::asm::*;\n \n+enum CInlineAsmOperand<'tcx> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        value: CValue<'tcx>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        place: Option<CPlace<'tcx>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        _late: bool,\n+        in_value: CValue<'tcx>,\n+        out_place: Option<CPlace<'tcx>>,\n+    },\n+    Const {\n+        value: String,\n+    },\n+    Symbol {\n+        symbol: SymbolName<'tcx>,\n+    },\n+}\n+\n pub(crate) fn codegen_inline_asm<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    _span: Span,\n+    span: Span,\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n@@ -198,6 +223,59 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         }\n     }\n \n+    let operands = operands\n+        .into_iter()\n+        .map(|operand| match *operand {\n+            InlineAsmOperand::In { reg, ref value } => {\n+                CInlineAsmOperand::In { reg, value: crate::base::codegen_operand(fx, value) }\n+            }\n+            InlineAsmOperand::Out { reg, late, ref place } => CInlineAsmOperand::Out {\n+                reg,\n+                late,\n+                place: place.map(|place| crate::base::codegen_place(fx, place)),\n+            },\n+            InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n+                CInlineAsmOperand::InOut {\n+                    reg,\n+                    _late: late,\n+                    in_value: crate::base::codegen_operand(fx, in_value),\n+                    out_place: out_place.map(|place| crate::base::codegen_place(fx, place)),\n+                }\n+            }\n+            InlineAsmOperand::Const { ref value } => {\n+                let (const_value, ty) = crate::constant::eval_mir_constant(fx, &*value)\n+                    .unwrap_or_else(|| span_bug!(span, \"asm const cannot be resolved\"));\n+                let value = rustc_codegen_ssa::common::asm_const_to_str(\n+                    fx.tcx,\n+                    span,\n+                    const_value,\n+                    fx.layout_of(ty),\n+                );\n+                CInlineAsmOperand::Const { value }\n+            }\n+            InlineAsmOperand::SymFn { ref value } => {\n+                let literal = fx.monomorphize(value.literal);\n+                if let ty::FnDef(def_id, substs) = *literal.ty().kind() {\n+                    let instance = ty::Instance::resolve_for_fn_ptr(\n+                        fx.tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        substs,\n+                    )\n+                    .unwrap();\n+                    CInlineAsmOperand::Symbol { symbol: fx.tcx.symbol_name(instance) }\n+                } else {\n+                    span_bug!(span, \"invalid type for asm sym (fn)\");\n+                }\n+            }\n+            InlineAsmOperand::SymStatic { def_id } => {\n+                assert!(fx.tcx.is_static(def_id));\n+                let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n+                CInlineAsmOperand::Symbol { symbol: fx.tcx.symbol_name(instance) }\n+            }\n+        })\n+        .collect::<Vec<_>>();\n+\n     let mut inputs = Vec::new();\n     let mut outputs = Vec::new();\n \n@@ -206,7 +284,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         arch: fx.tcx.sess.asm_arch.unwrap(),\n         enclosing_def_id: fx.instance.def_id(),\n         template,\n-        operands,\n+        operands: &operands,\n         options,\n         registers: Vec::new(),\n         stack_slots_clobber: Vec::new(),\n@@ -229,36 +307,22 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     fx.cx.global_asm.push_str(&generated_asm);\n \n     for (i, operand) in operands.iter().enumerate() {\n-        match *operand {\n-            InlineAsmOperand::In { reg: _, ref value } => {\n-                inputs.push((\n-                    asm_gen.stack_slots_input[i].unwrap(),\n-                    crate::base::codegen_operand(fx, value).load_scalar(fx),\n-                ));\n-            }\n-            InlineAsmOperand::Out { reg: _, late: _, place } => {\n+        match operand {\n+            CInlineAsmOperand::In { reg: _, value } => {\n+                inputs.push((asm_gen.stack_slots_input[i].unwrap(), value.load_scalar(fx)));\n+            }\n+            CInlineAsmOperand::Out { reg: _, late: _, place } => {\n                 if let Some(place) = place {\n-                    outputs.push((\n-                        asm_gen.stack_slots_output[i].unwrap(),\n-                        crate::base::codegen_place(fx, place),\n-                    ));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), place.clone()));\n                 }\n             }\n-            InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n-                inputs.push((\n-                    asm_gen.stack_slots_input[i].unwrap(),\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                ));\n+            CInlineAsmOperand::InOut { reg: _, _late: _, in_value, out_place } => {\n+                inputs.push((asm_gen.stack_slots_input[i].unwrap(), in_value.load_scalar(fx)));\n                 if let Some(out_place) = out_place {\n-                    outputs.push((\n-                        asm_gen.stack_slots_output[i].unwrap(),\n-                        crate::base::codegen_place(fx, out_place),\n-                    ));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), out_place.clone()));\n                 }\n             }\n-            InlineAsmOperand::Const { value: _ } => todo!(),\n-            InlineAsmOperand::SymFn { value: _ } => todo!(),\n-            InlineAsmOperand::SymStatic { def_id: _ } => todo!(),\n+            CInlineAsmOperand::Const { value: _ } | CInlineAsmOperand::Symbol { symbol: _ } => {}\n         }\n     }\n \n@@ -280,7 +344,7 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n     arch: InlineAsmArch,\n     enclosing_def_id: DefId,\n     template: &'a [InlineAsmTemplatePiece],\n-    operands: &'a [InlineAsmOperand<'tcx>],\n+    operands: &'a [CInlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n     registers: Vec<Option<InlineAsmReg>>,\n     stack_slots_clobber: Vec<Option<Size>>,\n@@ -304,18 +368,20 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Add explicit registers to the allocated set.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                CInlineAsmOperand::In { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().0 = true;\n                 }\n-                InlineAsmOperand::Out {\n-                    reg: InlineAsmRegOrRegClass::Reg(reg), late: true, ..\n+                CInlineAsmOperand::Out {\n+                    reg: InlineAsmRegOrRegClass::Reg(reg),\n+                    late: true,\n+                    ..\n                 } => {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().1 = true;\n                 }\n-                InlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(reg), .. }\n-                | InlineAsmOperand::InOut { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n+                CInlineAsmOperand::Out { reg: InlineAsmRegOrRegClass::Reg(reg), .. }\n+                | CInlineAsmOperand::InOut { reg: InlineAsmRegOrRegClass::Reg(reg), .. } => {\n                     regs[i] = Some(reg);\n                     allocated.insert(reg, (true, true));\n                 }\n@@ -326,12 +392,12 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate out/inout/inlateout registers first because they are more constrained.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::Out {\n+                CInlineAsmOperand::Out {\n                     reg: InlineAsmRegOrRegClass::RegClass(class),\n                     late: false,\n                     ..\n                 }\n-                | InlineAsmOperand::InOut {\n+                | CInlineAsmOperand::InOut {\n                     reg: InlineAsmRegOrRegClass::RegClass(class), ..\n                 } => {\n                     let mut alloc_reg = None;\n@@ -360,7 +426,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate in/lateout.\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg: InlineAsmRegOrRegClass::RegClass(class), .. } => {\n+                CInlineAsmOperand::In { reg: InlineAsmRegOrRegClass::RegClass(class), .. } => {\n                     let mut alloc_reg = None;\n                     for &reg in &map[&class] {\n                         let mut used = false;\n@@ -380,7 +446,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n                     regs[i] = Some(reg);\n                     allocated.entry(reg).or_default().0 = true;\n                 }\n-                InlineAsmOperand::Out {\n+                CInlineAsmOperand::Out {\n                     reg: InlineAsmRegOrRegClass::RegClass(class),\n                     late: true,\n                     ..\n@@ -455,7 +521,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for inout\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::InOut { reg, out_place: Some(_), .. } => {\n+                CInlineAsmOperand::InOut { reg, out_place: Some(_), .. } => {\n                     let slot = new_slot(reg.reg_class());\n                     slots_input[i] = Some(slot);\n                     slots_output[i] = Some(slot);\n@@ -470,8 +536,8 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for input\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg, .. }\n-                | InlineAsmOperand::InOut { reg, out_place: None, .. } => {\n+                CInlineAsmOperand::In { reg, .. }\n+                | CInlineAsmOperand::InOut { reg, out_place: None, .. } => {\n                     slots_input[i] = Some(new_slot(reg.reg_class()));\n                 }\n                 _ => (),\n@@ -487,7 +553,7 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         // Allocate stack slots for output\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::Out { reg, place: Some(_), .. } => {\n+                CInlineAsmOperand::Out { reg, place: Some(_), .. } => {\n                     slots_output[i] = Some(new_slot(reg.reg_class()));\n                 }\n                 _ => (),\n@@ -549,13 +615,23 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n                     generated_asm.push_str(s);\n                 }\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n-                    if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n-                        generated_asm.push('%');\n+                    match self.operands[*operand_idx] {\n+                        CInlineAsmOperand::In { .. }\n+                        | CInlineAsmOperand::Out { .. }\n+                        | CInlineAsmOperand::InOut { .. } => {\n+                            if self.options.contains(InlineAsmOptions::ATT_SYNTAX) {\n+                                generated_asm.push('%');\n+                            }\n+                            self.registers[*operand_idx]\n+                                .unwrap()\n+                                .emit(&mut generated_asm, self.arch, *modifier)\n+                                .unwrap();\n+                        }\n+                        CInlineAsmOperand::Const { ref value } => {\n+                            generated_asm.push_str(value);\n+                        }\n+                        CInlineAsmOperand::Symbol { symbol } => generated_asm.push_str(symbol.name),\n                     }\n-                    self.registers[*operand_idx]\n-                        .unwrap()\n-                        .emit(&mut generated_asm, self.arch, *modifier)\n-                        .unwrap();\n                 }\n             }\n         }"}]}