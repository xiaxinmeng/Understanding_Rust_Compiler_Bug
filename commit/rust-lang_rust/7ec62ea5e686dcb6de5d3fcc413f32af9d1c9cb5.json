{"sha": "7ec62ea5e686dcb6de5d3fcc413f32af9d1c9cb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYzYyZWE1ZTY4NmRjYjZkZTVkM2ZjYzQxM2YzMmFmOWQxYzljYjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-14T13:11:07Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-14T13:11:07Z"}, "message": "Push resolver up", "tree": {"sha": "6e4493dbe768700b440fd0a7d419856988887c9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e4493dbe768700b440fd0a7d419856988887c9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ec62ea5e686dcb6de5d3fcc413f32af9d1c9cb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ec62ea5e686dcb6de5d3fcc413f32af9d1c9cb5", "html_url": "https://github.com/rust-lang/rust/commit/7ec62ea5e686dcb6de5d3fcc413f32af9d1c9cb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ec62ea5e686dcb6de5d3fcc413f32af9d1c9cb5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec4775830c14194c1bd7bfcdbce25cf21bee0b44", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4775830c14194c1bd7bfcdbce25cf21bee0b44", "html_url": "https://github.com/rust-lang/rust/commit/ec4775830c14194c1bd7bfcdbce25cf21bee0b44"}], "stats": {"total": 72, "additions": 51, "deletions": 21}, "files": [{"sha": "e43fadf20e7a18fd1e8bcac8c6695eaba627c492", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 51, "deletions": 21, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7ec62ea5e686dcb6de5d3fcc413f32af9d1c9cb5/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ec62ea5e686dcb6de5d3fcc413f32af9d1c9cb5/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=7ec62ea5e686dcb6de5d3fcc413f32af9d1c9cb5", "patch": "@@ -12,7 +12,7 @@ use hir_def::{\n use hir_expand::name::Name;\n use ra_db::CrateId;\n use ra_prof::profile;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n use super::Substs;\n use crate::{\n@@ -177,6 +177,9 @@ pub fn iterate_method_candidates<T>(\n     mode: LookupMode,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n+    let traits_in_scope = resolver.traits_in_scope(db);\n+    let krate = resolver.krate()?;\n+    let env = TraitEnvironment::lower(db, resolver);\n     match mode {\n         LookupMode::MethodCall => {\n             // For method calls, rust first does any number of autoderef, and then one\n@@ -209,7 +212,9 @@ pub fn iterate_method_candidates<T>(\n                 if let Some(result) = iterate_method_candidates_with_autoref(\n                     &deref_chain[i..],\n                     db,\n-                    resolver,\n+                    env.clone(),\n+                    krate,\n+                    &traits_in_scope,\n                     name,\n                     &mut callback,\n                 ) {\n@@ -220,23 +225,35 @@ pub fn iterate_method_candidates<T>(\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n-            iterate_method_candidates_for_self_ty(&ty, db, resolver, name, &mut callback)\n+            iterate_method_candidates_for_self_ty(\n+                &ty,\n+                db,\n+                env,\n+                krate,\n+                &traits_in_scope,\n+                name,\n+                &mut callback,\n+            )\n         }\n     }\n }\n \n fn iterate_method_candidates_with_autoref<T>(\n     deref_chain: &[Canonical<Ty>],\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    env: Arc<TraitEnvironment>,\n+    krate: CrateId,\n+    traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     if let Some(result) = iterate_method_candidates_by_receiver(\n         &deref_chain[0],\n         &deref_chain[1..],\n         db,\n-        resolver,\n+        env.clone(),\n+        krate,\n+        &traits_in_scope,\n         name,\n         &mut callback,\n     ) {\n@@ -250,7 +267,9 @@ fn iterate_method_candidates_with_autoref<T>(\n         &refed,\n         deref_chain,\n         db,\n-        resolver,\n+        env.clone(),\n+        krate,\n+        &traits_in_scope,\n         name,\n         &mut callback,\n     ) {\n@@ -264,7 +283,9 @@ fn iterate_method_candidates_with_autoref<T>(\n         &ref_muted,\n         deref_chain,\n         db,\n-        resolver,\n+        env.clone(),\n+        krate,\n+        &traits_in_scope,\n         name,\n         &mut callback,\n     ) {\n@@ -277,14 +298,15 @@ fn iterate_method_candidates_by_receiver<T>(\n     receiver_ty: &Canonical<Ty>,\n     rest_of_deref_chain: &[Canonical<Ty>],\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    env: Arc<TraitEnvironment>,\n+    krate: CrateId,\n+    traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n     // We're looking for methods with *receiver* type receiver_ty. These could\n     // be found in any of the derefs of receiver_ty, so we have to go through\n     // that.\n-    let krate = resolver.krate()?;\n     for self_ty in std::iter::once(receiver_ty).chain(rest_of_deref_chain) {\n         if let Some(result) =\n             iterate_inherent_methods(self_ty, db, name, Some(receiver_ty), krate, &mut callback)\n@@ -296,7 +318,9 @@ fn iterate_method_candidates_by_receiver<T>(\n         if let Some(result) = iterate_trait_method_candidates(\n             self_ty,\n             db,\n-            resolver,\n+            env.clone(),\n+            krate,\n+            &traits_in_scope,\n             name,\n             Some(receiver_ty),\n             &mut callback,\n@@ -310,17 +334,25 @@ fn iterate_method_candidates_by_receiver<T>(\n fn iterate_method_candidates_for_self_ty<T>(\n     self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    env: Arc<TraitEnvironment>,\n+    krate: CrateId,\n+    traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    let krate = resolver.krate()?;\n     if let Some(result) = iterate_inherent_methods(self_ty, db, name, None, krate, &mut callback) {\n         return Some(result);\n     }\n-    if let Some(result) =\n-        iterate_trait_method_candidates(self_ty, db, resolver, name, None, &mut callback)\n-    {\n+    if let Some(result) = iterate_trait_method_candidates(\n+        self_ty,\n+        db,\n+        env,\n+        krate,\n+        traits_in_scope,\n+        name,\n+        None,\n+        &mut callback,\n+    ) {\n         return Some(result);\n     }\n     None\n@@ -329,23 +361,21 @@ fn iterate_method_candidates_for_self_ty<T>(\n fn iterate_trait_method_candidates<T>(\n     self_ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    env: Arc<TraitEnvironment>,\n+    krate: CrateId,\n+    traits_in_scope: &FxHashSet<TraitId>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     mut callback: impl FnMut(&Ty, AssocItemId) -> Option<T>,\n ) -> Option<T> {\n-    let krate = resolver.krate()?;\n-    // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n-    let env = TraitEnvironment::lower(db, resolver);\n     // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait = self_ty.value.inherent_trait().into_iter();\n     // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n     let traits_from_env = env\n         .trait_predicates_for_self_ty(&self_ty.value)\n         .map(|tr| tr.trait_)\n         .flat_map(|t| all_super_traits(db, t));\n-    let traits =\n-        inherent_trait.chain(traits_from_env).chain(resolver.traits_in_scope(db).into_iter());\n+    let traits = inherent_trait.chain(traits_from_env).chain(traits_in_scope.iter().copied());\n     'traits: for t in traits {\n         let data = db.trait_data(t);\n "}]}