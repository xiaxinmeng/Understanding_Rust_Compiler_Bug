{"sha": "fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMzAyYTk1ZTExOTdlNWY4NDAxZWNhYTE1ZjJjYjBmODFjODMwYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T00:41:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T00:41:13Z"}, "message": "Auto merge of #27808 - SimonSapin:utf16decoder, r=alexcrichton\n\n* Rename `Utf16Items` to `Utf16Decoder`. \"Items\" is meaningless.\r\n* Generalize it to any `u16` iterator, not just `[u16].iter()`\r\n* Make it yield `Result` instead of a custom `Utf16Item` enum that was isomorphic to `Result`. This enable using the `FromIterator for Result` impl.\r\n* Replace `Utf16Item::to_char_lossy` with a `Utf16Decoder::lossy` iterator adaptor.\r\n\r\nThis is a [breaking change], but only for users of the unstable `rustc_unicode` crate.\r\n\r\nI\u2019d like this functionality to be stabilized and re-exported in `std` eventually, as the \"low-level equivalent\" of `String::from_utf16` and `String::from_utf16_lossy` like #27784 is the low-level equivalent of #27714.\r\n\r\nCC @aturon, @alexcrichton", "tree": {"sha": "f067678d29ba74bb76bea9397da4b06ed975ea87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f067678d29ba74bb76bea9397da4b06ed975ea87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "html_url": "https://github.com/rust-lang/rust/commit/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80b971a9b86cf56eab5a6f707107175d4bf2bbe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/80b971a9b86cf56eab5a6f707107175d4bf2bbe1", "html_url": "https://github.com/rust-lang/rust/commit/80b971a9b86cf56eab5a6f707107175d4bf2bbe1"}, {"sha": "6174b8d726ed5764694e5404329d8b5e66517ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6174b8d726ed5764694e5404329d8b5e66517ed5", "html_url": "https://github.com/rust-lang/rust/commit/6174b8d726ed5764694e5404329d8b5e66517ed5"}], "stats": {"total": 464, "additions": 293, "deletions": 171}, "files": [{"sha": "b68d7976540a03d9cd8ca9fcf3ec1997bad9529a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -73,6 +73,7 @@ use boxed::Box;\n \n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n+use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n use core::mem::{align_of_val, size_of_val};\n@@ -1109,3 +1110,7 @@ mod tests {\n         assert!(y.upgrade().is_none());\n     }\n }\n+\n+impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}"}, {"sha": "a6e0f3a9bd97d3c1eac029aed9a160a3972fb80f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -57,6 +57,7 @@ use heap;\n use raw_vec::RawVec;\n \n use core::any::Any;\n+use core::borrow;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n@@ -562,3 +563,10 @@ impl<T: Clone> Clone for Box<[T]> {\n     }\n }\n \n+impl<T: ?Sized> borrow::Borrow<T> for Box<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+impl<T: ?Sized> borrow::BorrowMut<T> for Box<T> {\n+    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n+}"}, {"sha": "b1fb5be4d21bf63b68f4f09cb6fa487d808ec69d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -158,6 +158,7 @@ use boxed::Box;\n #[cfg(test)]\n use std::boxed::Box;\n \n+use core::borrow;\n use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n@@ -1091,3 +1092,7 @@ mod tests {\n         assert_eq!(foo, foo.clone());\n     }\n }\n+\n+impl<T: ?Sized> borrow::Borrow<T> for Rc<T> {\n+    fn borrow(&self) -> &T { &**self }\n+}"}, {"sha": "bd1864b28cdd3e24e22621733a2a5d3a2e909d0d", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 1, "deletions": 110, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -21,119 +21,10 @@ use core::ops::Deref;\n use core::option::Option;\n \n use fmt;\n-use alloc::{boxed, rc, arc};\n \n use self::Cow::*;\n \n-/// A trait for borrowing data.\n-///\n-/// In general, there may be several ways to \"borrow\" a piece of data.  The\n-/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n-/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n-/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n-///\n-/// When writing generic code, it is often desirable to abstract over all ways\n-/// of borrowing data from a given type. That is the role of the `Borrow`\n-/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n-/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n-/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n-///\n-/// If you are implementing `Borrow` and both `Self` and `Borrowed` implement\n-/// `Hash`, `Eq`, and/or `Ord`, they must produce the same result.\n-///\n-/// `Borrow` is very similar to, but different than, `AsRef`. See\n-/// [the book][book] for more.\n-///\n-/// [book]: ../../book/borrow-and-asref.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Borrow<Borrowed: ?Sized> {\n-    /// Immutably borrows from an owned value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::borrow::Borrow;\n-    ///\n-    /// fn check<T: Borrow<str>>(s: T) {\n-    ///     assert_eq!(\"Hello\", s.borrow());\n-    /// }\n-    ///\n-    /// let s = \"Hello\".to_string();\n-    ///\n-    /// check(s);\n-    ///\n-    /// let s = \"Hello\";\n-    ///\n-    /// check(s);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn borrow(&self) -> &Borrowed;\n-}\n-\n-/// A trait for mutably borrowing data.\n-///\n-/// Similar to `Borrow`, but for mutable borrows.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n-    /// Mutably borrows from an owned value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::borrow::BorrowMut;\n-    ///\n-    /// fn check<T: BorrowMut<[i32]>>(mut v: T) {\n-    ///     assert_eq!(&mut [1, 2, 3], v.borrow_mut());\n-    /// }\n-    ///\n-    /// let v = vec![1, 2, 3];\n-    ///\n-    /// check(v);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn borrow_mut(&mut self) -> &mut Borrowed;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Borrow<T> for T {\n-    fn borrow(&self) -> &T { self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> BorrowMut<T> for T {\n-    fn borrow_mut(&mut self) -> &mut T { self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> Borrow<T> for &'a T {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> Borrow<T> for &'a mut T {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n-    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n-}\n-\n-impl<T: ?Sized> Borrow<T> for boxed::Box<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-impl<T: ?Sized> BorrowMut<T> for boxed::Box<T> {\n-    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n-}\n-\n-impl<T: ?Sized> Borrow<T> for rc::Rc<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n-\n-impl<T: ?Sized> Borrow<T> for arc::Arc<T> {\n-    fn borrow(&self) -> &T { &**self }\n-}\n+pub use core::borrow::{Borrow, BorrowMut};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {"}, {"sha": "d1e91b28c46fd23028c7f451ecbe0150d16f4795", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -56,6 +56,7 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(decode_utf16)]\n #![feature(utf8_error)]\n #![cfg_attr(test, feature(rand, test))]\n "}, {"sha": "08ac64778bb02787ad99c03bb36070a322de507d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -20,8 +20,8 @@ use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n use core::slice;\n use core::str::pattern::Pattern;\n+use rustc_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use rustc_unicode::str as unicode_str;\n-use rustc_unicode::str::Utf16Item;\n \n use borrow::{Cow, IntoCow};\n use range::RangeArgument;\n@@ -267,14 +267,7 @@ impl String {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n-        let mut s = String::with_capacity(v.len());\n-        for c in unicode_str::utf16_items(v) {\n-            match c {\n-                Utf16Item::ScalarValue(c) => s.push(c),\n-                Utf16Item::LoneSurrogate(_) => return Err(FromUtf16Error(())),\n-            }\n-        }\n-        Ok(s)\n+        decode_utf16(v.iter().cloned()).collect::<Result<_, _>>().map_err(|_| FromUtf16Error(()))\n     }\n \n     /// Decode a UTF-16 encoded vector `v` into a string, replacing\n@@ -294,7 +287,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf16_lossy(v: &[u16]) -> String {\n-        unicode_str::utf16_items(v).map(|c| c.to_char_lossy()).collect()\n+        decode_utf16(v.iter().cloned()).map(|r| r.unwrap_or(REPLACEMENT_CHARACTER)).collect()\n     }\n \n     /// Creates a new `String` from a length, capacity, and pointer."}, {"sha": "79330d3a61ea7dcfedeb9f6da18513bf1f4b5f91", "filename": "src/libcore/borrow.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A module for working with borrowed data.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use marker::Sized;\n+\n+/// A trait for borrowing data.\n+///\n+/// In general, there may be several ways to \"borrow\" a piece of data.  The\n+/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n+/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n+/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+///\n+/// When writing generic code, it is often desirable to abstract over all ways\n+/// of borrowing data from a given type. That is the role of the `Borrow`\n+/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n+/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n+/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+///\n+/// If you are implementing `Borrow` and both `Self` and `Borrowed` implement\n+/// `Hash`, `Eq`, and/or `Ord`, they must produce the same result.\n+///\n+/// `Borrow` is very similar to, but different than, `AsRef`. See\n+/// [the book][book] for more.\n+///\n+/// [book]: ../../book/borrow-and-asref.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Borrow<Borrowed: ?Sized> {\n+    /// Immutably borrows from an owned value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::borrow::Borrow;\n+    ///\n+    /// fn check<T: Borrow<str>>(s: T) {\n+    ///     assert_eq!(\"Hello\", s.borrow());\n+    /// }\n+    ///\n+    /// let s = \"Hello\".to_string();\n+    ///\n+    /// check(s);\n+    ///\n+    /// let s = \"Hello\";\n+    ///\n+    /// check(s);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow(&self) -> &Borrowed;\n+}\n+\n+/// A trait for mutably borrowing data.\n+///\n+/// Similar to `Borrow`, but for mutable borrows.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n+    /// Mutably borrows from an owned value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::borrow::BorrowMut;\n+    ///\n+    /// fn check<T: BorrowMut<[i32]>>(mut v: T) {\n+    ///     assert_eq!(&mut [1, 2, 3], v.borrow_mut());\n+    /// }\n+    ///\n+    /// let v = vec![1, 2, 3];\n+    ///\n+    /// check(v);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn borrow_mut(&mut self) -> &mut Borrowed;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Borrow<T> for T {\n+    fn borrow(&self) -> &T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> BorrowMut<T> for T {\n+    fn borrow_mut(&mut self) -> &mut T { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> Borrow<T> for &'a mut T {\n+    fn borrow(&self) -> &T { &**self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: ?Sized> BorrowMut<T> for &'a mut T {\n+    fn borrow_mut(&mut self) -> &mut T { &mut **self }\n+}"}, {"sha": "78a467e365799125b2d5c3dde848bd61d2d133af", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -139,6 +139,7 @@ pub mod cmp;\n pub mod clone;\n pub mod default;\n pub mod convert;\n+pub mod borrow;\n \n /* Core types and methods on primitives */\n "}, {"sha": "d23442379bcd59095eb10767a480e5567539535f", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -207,3 +207,12 @@ fn test_len_utf16() {\n     assert!('\\u{a66e}'.len_utf16() == 1);\n     assert!('\\u{1f4a9}'.len_utf16() == 2);\n }\n+\n+#[test]\n+fn test_decode_utf16() {\n+    fn check(s: &[u16], expected: &[Result<char, u16>]) {\n+        assert_eq!(::std::char::decode_utf16(s.iter().cloned()).collect::<Vec<_>>(), expected);\n+    }\n+    check(&[0xD800, 0x41, 0x42], &[Err(0xD800), Ok('A'), Ok('B')]);\n+    check(&[0xD800, 0], &[Err(0xD800), Ok('\\0')]);\n+}"}, {"sha": "dda1b096e88ed68c202587a233b0daf61b9b0088", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -19,6 +19,7 @@\n #![feature(float_from_str_radix)]\n #![feature(flt2dec)]\n #![feature(dec2flt)]\n+#![feature(decode_utf16)]\n #![feature(fmt_radix)]\n #![feature(iter_arith)]\n #![feature(iter_arith)]"}, {"sha": "e08b3244109d579c2243f44dd79c4d38d8e145d5", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -503,3 +503,116 @@ impl char {\n         ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n     }\n }\n+\n+/// An iterator that decodes UTF-16 encoded codepoints from an iterator of `u16`s.\n+#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+#[derive(Clone)]\n+pub struct DecodeUtf16<I> where I: Iterator<Item=u16> {\n+    iter: I,\n+    buf: Option<u16>,\n+}\n+\n+/// Create an iterator over the UTF-16 encoded codepoints in `iterable`,\n+/// returning unpaired surrogates as `Err`s.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(decode_utf16)]\n+///\n+/// use std::char::decode_utf16;\n+///\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n+///\n+///     assert_eq!(decode_utf16(v.iter().cloned()).collect::<Vec<_>>(),\n+///                vec![Ok('\ud834\udd1e'),\n+///                     Ok('m'), Ok('u'), Ok('s'),\n+///                     Err(0xDD1E),\n+///                     Ok('i'), Ok('c'),\n+///                     Err(0xD834)]);\n+/// }\n+/// ```\n+///\n+/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n+///\n+/// ```\n+/// #![feature(decode_utf16)]\n+///\n+/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+///\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n+///\n+///     assert_eq!(decode_utf16(v.iter().cloned())\n+///                    .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+///                    .collect::<String>(),\n+///                \"\ud834\udd1emus\ufffdic\ufffd\");\n+/// }\n+/// ```\n+#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+#[inline]\n+pub fn decode_utf16<I: IntoIterator<Item=u16>>(iterable: I) -> DecodeUtf16<I::IntoIter> {\n+    DecodeUtf16 {\n+        iter: iterable.into_iter(),\n+        buf: None,\n+    }\n+}\n+\n+#[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n+impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n+    type Item = Result<char, u16>;\n+\n+    fn next(&mut self) -> Option<Result<char, u16>> {\n+        let u = match self.buf.take() {\n+            Some(buf) => buf,\n+            None => match self.iter.next() {\n+                Some(u) => u,\n+                None => return None\n+            }\n+        };\n+\n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(Ok(unsafe { from_u32_unchecked(u as u32) }))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(Err(u))\n+        } else {\n+            let u2 = match self.iter.next() {\n+                Some(u2) => u2,\n+                // eof\n+                None => return Some(Err(u))\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.buf = Some(u2);\n+                return Some(Err(u))\n+            }\n+\n+            // all ok, so lets decode it.\n+            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            Some(Ok(unsafe { from_u32_unchecked(c) }))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.iter.size_hint();\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n+        (low / 2, high)\n+    }\n+}\n+\n+/// U+FFFD REPLACEMENT CHARACTER (\ufffd) is used in Unicode to represent a decoding error.\n+/// It can occur, for example, when giving ill-formed UTF-8 bytes to `String::from_utf8_lossy`.\n+#[unstable(feature = \"decode_utf16\", reason = \"recently added\", issue = \"27830\")]\n+pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';"}, {"sha": "4f0aa69d7719930e6811d4224b71bd577a05730e", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -46,6 +46,7 @@ mod tables;\n mod u_str;\n pub mod char;\n \n+#[allow(deprecated)]\n pub mod str {\n     pub use u_str::{UnicodeStr, SplitWhitespace};\n     pub use u_str::{utf8_char_width, is_utf16, Utf16Items, Utf16Item};"}, {"sha": "67333c98fcf84bc5dd40e63fc6a323225995d3cf", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -13,8 +13,9 @@\n //! This module provides functionality to `str` that requires the Unicode methods provided by the\n //! unicode parts of the CharExt trait.\n \n+use char::{DecodeUtf16, decode_utf16};\n use core::char;\n-use core::iter::Filter;\n+use core::iter::{Cloned, Filter};\n use core::slice;\n use core::str::Split;\n \n@@ -119,11 +120,18 @@ pub fn is_utf16(v: &[u16]) -> bool {\n \n /// An iterator that decodes UTF-16 encoded codepoints from a vector\n /// of `u16`s.\n+#[deprecated(since = \"1.4.0\", reason = \"renamed to `char::DecodeUtf16`\")]\n+#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n+#[allow(deprecated)]\n #[derive(Clone)]\n pub struct Utf16Items<'a> {\n-    iter: slice::Iter<'a, u16>\n+    decoder: DecodeUtf16<Cloned<slice::Iter<'a, u16>>>\n }\n+\n /// The possibilities for values decoded from a `u16` stream.\n+#[deprecated(since = \"1.4.0\", reason = \"`char::DecodeUtf16` uses `Result<char, u16>` instead\")]\n+#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n+#[allow(deprecated)]\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n pub enum Utf16Item {\n     /// A valid codepoint.\n@@ -132,6 +140,7 @@ pub enum Utf16Item {\n     LoneSurrogate(u16)\n }\n \n+#[allow(deprecated)]\n impl Utf16Item {\n     /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n     /// replacement character (U+FFFD).\n@@ -144,49 +153,22 @@ impl Utf16Item {\n     }\n }\n \n+#[deprecated(since = \"1.4.0\", reason = \"use `char::DecodeUtf16` instead\")]\n+#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n+#[allow(deprecated)]\n impl<'a> Iterator for Utf16Items<'a> {\n     type Item = Utf16Item;\n \n     fn next(&mut self) -> Option<Utf16Item> {\n-        let u = match self.iter.next() {\n-            Some(u) => *u,\n-            None => return None\n-        };\n-\n-        if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n-            Some(Utf16Item::ScalarValue(unsafe { char::from_u32_unchecked(u as u32) }))\n-        } else if u >= 0xDC00 {\n-            // a trailing surrogate\n-            Some(Utf16Item::LoneSurrogate(u))\n-        } else {\n-            // preserve state for rewinding.\n-            let old = self.iter.clone();\n-\n-            let u2 = match self.iter.next() {\n-                Some(u2) => *u2,\n-                // eof\n-                None => return Some(Utf16Item::LoneSurrogate(u))\n-            };\n-            if u2 < 0xDC00 || u2 > 0xDFFF {\n-                // not a trailing surrogate so we're not a valid\n-                // surrogate pair, so rewind to redecode u2 next time.\n-                self.iter = old.clone();\n-                return Some(Utf16Item::LoneSurrogate(u))\n-            }\n-\n-            // all ok, so lets decode it.\n-            let c = (((u - 0xD800) as u32) << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(Utf16Item::ScalarValue(unsafe { char::from_u32_unchecked(c) }))\n-        }\n+        self.decoder.next().map(|result| match result {\n+            Ok(c) => Utf16Item::ScalarValue(c),\n+            Err(s) => Utf16Item::LoneSurrogate(s),\n+        })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.iter.size_hint();\n-        // we could be entirely valid surrogates (2 elements per\n-        // char), or entirely non-surrogates (1 element per char)\n-        (low / 2, high)\n+        self.decoder.size_hint()\n     }\n }\n \n@@ -196,7 +178,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(unicode)]\n+/// #![feature(unicode, decode_utf16)]\n ///\n /// extern crate rustc_unicode;\n ///\n@@ -216,8 +198,11 @@ impl<'a> Iterator for Utf16Items<'a> {\n ///                     LoneSurrogate(0xD834)]);\n /// }\n /// ```\n+#[deprecated(since = \"1.4.0\", reason = \"renamed to `char::decode_utf16`\")]\n+#[unstable(feature = \"decode_utf16\", reason = \"not exposed in std\", issue = \"27830\")]\n+#[allow(deprecated)]\n pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n-    Utf16Items { iter : v.iter() }\n+    Utf16Items { decoder: decode_utf16(v.iter().cloned()) }\n }\n \n /// Iterator adaptor for encoding `char`s to UTF-16."}, {"sha": "09f98978653e3b9418be3afefd305a67984e627c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -209,8 +209,6 @@ use std::str::FromStr;\n use std::string;\n use std::{char, f64, fmt, str};\n use std;\n-use rustc_unicode::str as unicode_str;\n-use rustc_unicode::str::Utf16Item;\n \n use Encodable;\n \n@@ -1712,11 +1710,13 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                                 _ => return self.error(UnexpectedEndOfHexEscape),\n                             }\n \n-                            let buf = [n1, try!(self.decode_hex_escape())];\n-                            match unicode_str::utf16_items(&buf).next() {\n-                                Some(Utf16Item::ScalarValue(c)) => res.push(c),\n-                                _ => return self.error(LoneLeadingSurrogateInHexEscape),\n+                            let n2 = try!(self.decode_hex_escape());\n+                            if n2 < 0xDC00 || n2 > 0xDFFF {\n+                                return self.error(LoneLeadingSurrogateInHexEscape)\n                             }\n+                            let c = (((n1 - 0xD800) as u32) << 10 |\n+                                     (n2 - 0xDC00) as u32) + 0x1_0000;\n+                            res.push(char::from_u32(c).unwrap());\n                         }\n \n                         n => match char::from_u32(n as u32) {"}, {"sha": "fca4c66112eb6c89e3ad878ef0f442abbb6cf1e2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -242,6 +242,7 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag, filling_drop)]\n+#![feature(decode_utf16)]\n #![feature(vec_push_all)]\n #![feature(vec_resize)]\n #![feature(wrapping)]"}, {"sha": "eb313d275a19178006b524dd392a98d7011d6c82", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd302a95e1197e5f8401ecaa15f2cb0f81c830c3/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=fd302a95e1197e5f8401ecaa15f2cb0f81c830c3", "patch": "@@ -37,7 +37,6 @@ use hash::{Hash, Hasher};\n use iter::FromIterator;\n use mem;\n use ops;\n-use rustc_unicode::str::{Utf16Item, utf16_items};\n use slice;\n use str;\n use string::String;\n@@ -186,14 +185,14 @@ impl Wtf8Buf {\n     /// will always return the original code units.\n     pub fn from_wide(v: &[u16]) -> Wtf8Buf {\n         let mut string = Wtf8Buf::with_capacity(v.len());\n-        for item in utf16_items(v) {\n+        for item in char::decode_utf16(v.iter().cloned()) {\n             match item {\n-                Utf16Item::ScalarValue(c) => string.push_char(c),\n-                Utf16Item::LoneSurrogate(s) => {\n+                Ok(ch) => string.push_char(ch),\n+                Err(surrogate) => {\n                     // Surrogates are known to be in the code point range.\n-                    let code_point = unsafe { CodePoint::from_u32_unchecked(s as u32) };\n+                    let code_point = unsafe { CodePoint::from_u32_unchecked(surrogate as u32) };\n                     // Skip the WTF-8 concatenation check,\n-                    // surrogate pairs are already decoded by utf16_items\n+                    // surrogate pairs are already decoded by decode_utf16\n                     string.push_code_point_unchecked(code_point)\n                 }\n             }"}]}