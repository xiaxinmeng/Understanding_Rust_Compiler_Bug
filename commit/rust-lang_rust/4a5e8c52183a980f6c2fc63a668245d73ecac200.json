{"sha": "4a5e8c52183a980f6c2fc63a668245d73ecac200", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNWU4YzUyMTgzYTk4MGY2YzJmYzYzYTY2ODI0NWQ3M2VjYWMyMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-21T17:20:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-21T17:20:43Z"}, "message": "auto merge of #5071 : luqmana/rust/derec, r=pcwalton\n\nRid libsyntax of records and get rid of the last piece in `librustc/front/test.rs`.", "tree": {"sha": "f3c2e2bbfecd1edc56f029c4cbe8f00bb70b647d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3c2e2bbfecd1edc56f029c4cbe8f00bb70b647d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a5e8c52183a980f6c2fc63a668245d73ecac200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5e8c52183a980f6c2fc63a668245d73ecac200", "html_url": "https://github.com/rust-lang/rust/commit/4a5e8c52183a980f6c2fc63a668245d73ecac200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a5e8c52183a980f6c2fc63a668245d73ecac200/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0218fb10667a198b41e4d140f8d0760e27ca5e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0218fb10667a198b41e4d140f8d0760e27ca5e7", "html_url": "https://github.com/rust-lang/rust/commit/c0218fb10667a198b41e4d140f8d0760e27ca5e7"}, {"sha": "b02f5c2090340a9007989b3eb384facb0f0286f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b02f5c2090340a9007989b3eb384facb0f0286f2", "html_url": "https://github.com/rust-lang/rust/commit/b02f5c2090340a9007989b3eb384facb0f0286f2"}], "stats": {"total": 571, "additions": 330, "deletions": 241}, "files": [{"sha": "a9ddfe8140455b75034bf0d7fcb36fba62c0fe7e", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -466,7 +466,7 @@ pub fn parse_and_print(code: @~str) -> ~str {\n                    sess.cm,\n                    // Assuming there are no token_trees\n                    syntax::parse::token::mk_fake_ident_interner(),\n-                   sess.span_diagnostic,\n+                   copy sess.span_diagnostic,\n                    crate,\n                    filename.to_str(),\n                    rdr, a,\n@@ -622,7 +622,7 @@ pub fn check_variants(files: &[Path], cx: Context) {\n                        sess.cm,\n                        // Assuming no token_trees\n                        syntax::parse::token::mk_fake_ident_interner(),\n-                       sess.span_diagnostic,\n+                       copy sess.span_diagnostic,\n                        crate,\n                        file_str,\n                        rdr, a,"}, {"sha": "2e8e4a6d51e0e7945ed1a6c7fa52b0f0627b13aa", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -25,7 +25,7 @@ use syntax::ast::node_id;\n use syntax::ast::{int_ty, uint_ty, float_ty};\n use syntax::codemap::span;\n use syntax::diagnostic;\n-use syntax::parse::parse_sess;\n+use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n use syntax;\n \n@@ -151,7 +151,7 @@ pub struct Session_ {\n     targ_cfg: @config,\n     opts: @options,\n     cstore: @mut metadata::cstore::CStore,\n-    parse_sess: parse_sess,\n+    parse_sess: @mut ParseSess,\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n     main_fn: @mut Option<(node_id, codemap::span)>,"}, {"sha": "f19b52661f210a91826c6f9adf661a03b9af9e89", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -10,10 +10,6 @@\n \n // Code that generates a test runner to run all the tests in a crate\n \n-// XXX - Need to finish off libsyntax first\n-#[legacy_records];\n-#[allow(structural_records)];\n-\n use core::prelude::*;\n \n use driver::session;\n@@ -25,7 +21,7 @@ use core::option;\n use core::vec;\n use syntax::ast_util::*;\n use syntax::attr;\n-use syntax::codemap::{dummy_sp, span, ExpandedFrom};\n+use syntax::codemap::{dummy_sp, span, ExpandedFrom, CallInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::fold;\n use syntax::print::pprust;\n@@ -81,11 +77,13 @@ fn generate_test_harness(sess: session::Session,\n         testfns: ~[]\n     };\n \n-    cx.ext_cx.bt_push(ExpandedFrom({\n-                        call_site: dummy_sp(),\n-                        callie: {\n-                            name: ~\"test\",\n-                            span: None}}));\n+    cx.ext_cx.bt_push(ExpandedFrom(CallInfo {\n+        call_site: dummy_sp(),\n+        callee: NameAndSpan {\n+            name: ~\"test\",\n+            span: None\n+        }\n+    }));\n \n     let precursor = @fold::AstFoldFns {\n         fold_crate: fold::wrap(|a,b| fold_crate(cx, a, b) ),"}, {"sha": "e7f1a89acc33d04faee694d80fb31164da352f33", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -1193,18 +1193,18 @@ fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n #[cfg(test)]\n trait fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg;\n-    fn parse_sess() -> parse::parse_sess;\n+    fn parse_sess() -> @mut parse::ParseSess;\n     fn call_site() -> span;\n     fn ident_of(+st: ~str) -> ast::ident;\n }\n \n #[cfg(test)]\n-type fake_session = parse::parse_sess;\n+type fake_session = @mut parse::ParseSess;\n \n #[cfg(test)]\n impl fake_ext_ctxt for fake_session {\n     fn cfg() -> ast::crate_cfg { ~[] }\n-    fn parse_sess() -> parse::parse_sess { self }\n+    fn parse_sess() -> @mut parse::ParseSess { self }\n     fn call_site() -> span {\n         codemap::span {\n             lo: codemap::BytePos(0),"}, {"sha": "3a863fc7ac5dc7cc4f1c441406d8d164611c8510", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -196,11 +196,16 @@ pub struct LocWithOpt {\n // used to be structural records. Better names, anyone?\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n+pub struct NameAndSpan {name: ~str, span: Option<span>}\n+\n+pub struct CallInfo {\n+    call_site: span,\n+    callee: NameAndSpan\n+}\n \n /// Extra information for tracking macro expansion of spans\n pub enum ExpnInfo {\n-    ExpandedFrom({call_site: span,\n-                  callie: {name: ~str, span: Option<span>}})\n+    ExpandedFrom(CallInfo)\n }\n \n pub type FileName = ~str;"}, {"sha": "da0e58b3e1fce6a34b4e14efdbc423e5e468c914", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -290,10 +290,10 @@ fn highlight_lines(cm: @codemap::CodeMap,\n \n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     do option::iter(&sp.expn_info) |ei| {\n-        let ss = option::map_default(&ei.callie.span, @~\"\",\n+        let ss = option::map_default(&ei.callee.span, @~\"\",\n                                      |span| @cm.span_to_str(*span));\n         print_diagnostic(*ss, note,\n-                         fmt!(\"in expansion of %s!\", ei.callie.name));\n+                         fmt!(\"in expansion of %s!\", ei.callee.name));\n         let ss = cm.span_to_str(ei.call_site);\n         print_diagnostic(ss, note, ~\"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);"}, {"sha": "38134d4321adb3c83353af94d0ef5279f46c9ddd", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -13,6 +13,7 @@ use core::prelude::*;\n use ast;\n use codemap;\n use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom, dummy_sp};\n+use codemap::{CallInfo, NameAndSpan};\n use diagnostic::span_handler;\n use ext;\n use parse;\n@@ -166,7 +167,7 @@ pub fn syntax_expander_table() -> SyntaxExtensions {\n // -> expn_info of their expansion context stored into their span.\n pub trait ext_ctxt {\n     fn codemap(@mut self) -> @CodeMap;\n-    fn parse_sess(@mut self) -> parse::parse_sess;\n+    fn parse_sess(@mut self) -> @mut parse::ParseSess;\n     fn cfg(@mut self) -> ast::crate_cfg;\n     fn call_site(@mut self) -> span;\n     fn print_backtrace(@mut self);\n@@ -190,22 +191,22 @@ pub trait ext_ctxt {\n     fn ident_of(@mut self, st: ~str) -> ast::ident;\n }\n \n-pub fn mk_ctxt(parse_sess: parse::parse_sess,\n+pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n                cfg: ast::crate_cfg) -> ext_ctxt {\n     struct CtxtRepr {\n-        parse_sess: parse::parse_sess,\n+        parse_sess: @mut parse::ParseSess,\n         cfg: ast::crate_cfg,\n         backtrace: Option<@ExpnInfo>,\n         mod_path: ~[ast::ident],\n         trace_mac: bool\n     }\n     impl ext_ctxt for CtxtRepr {\n         fn codemap(@mut self) -> @CodeMap { self.parse_sess.cm }\n-        fn parse_sess(@mut self) -> parse::parse_sess { self.parse_sess }\n+        fn parse_sess(@mut self) -> @mut parse::ParseSess { self.parse_sess }\n         fn cfg(@mut self) -> ast::crate_cfg { self.cfg }\n         fn call_site(@mut self) -> span {\n             match self.backtrace {\n-                Some(@ExpandedFrom({call_site: cs, _})) => cs,\n+                Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n                 None => self.bug(~\"missing top span\")\n             }\n         }\n@@ -216,18 +217,18 @@ pub fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn mod_path(@mut self) -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(@mut self, ei: codemap::ExpnInfo) {\n             match ei {\n-              ExpandedFrom({call_site: cs, callie: ref callie}) => {\n+              ExpandedFrom(CallInfo {call_site: cs, callee: ref callee}) => {\n                 self.backtrace =\n-                    Some(@ExpandedFrom({\n+                    Some(@ExpandedFrom(CallInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: self.backtrace},\n-                        callie: (*callie)}));\n+                        callee: (*callee)}));\n               }\n             }\n         }\n         fn bt_pop(@mut self) {\n             match self.backtrace {\n-              Some(@ExpandedFrom({\n+              Some(@ExpandedFrom(CallInfo {\n                   call_site: span {expn_info: prev, _}, _\n               })) => {\n                 self.backtrace = prev"}, {"sha": "55e5d5fbe17cc40996e8fdf3931c22fec1be04ee", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -19,6 +19,11 @@ use ext::build;\n use core::dvec;\n use core::option;\n \n+pub struct Field {\n+    ident: ast::ident,\n+    ex: @ast::expr\n+}\n+\n pub fn mk_expr(cx: ext_ctxt,\n                sp: codemap::span,\n                expr: ast::expr_)\n@@ -147,47 +152,37 @@ pub fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n pub fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n-pub fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n-             -> ast::field {\n+pub fn mk_field(sp: span, f: &Field) -> ast::field {\n     codemap::spanned {\n         node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n         span: sp,\n     }\n }\n-pub fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}])\n-              -> ~[ast::field] {\n+pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n     fields.map(|f| mk_field(sp, f))\n }\n-pub fn mk_rec_e(cx: ext_ctxt,\n-                sp: span,\n-                fields: ~[{ident: ast::ident, ex: @ast::expr}])\n-             -> @ast::expr {\n+pub fn mk_rec_e(cx: ext_ctxt, sp: span, fields: ~[Field]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_rec(mk_fields(sp, fields),\n                                   option::None::<@ast::expr>))\n }\n-pub fn mk_struct_e(cx: ext_ctxt,\n-                   sp: span,\n-                   ctor_path: ~[ast::ident],\n-                   fields: ~[{ident: ast::ident, ex: @ast::expr}])\n-                -> @ast::expr {\n+pub fn mk_struct_e(cx: ext_ctxt, sp: span, ctor_path: ~[ast::ident],\n+                   fields: ~[Field]) -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path(sp, ctor_path),\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_global_struct_e(cx: ext_ctxt,\n-                          sp: span,\n+pub fn mk_global_struct_e(cx: ext_ctxt, sp: span,\n                           ctor_path: ~[ast::ident],\n-                          fields: ~[{ident: ast::ident, ex: @ast::expr}])\n+                          fields: ~[Field])\n                        -> @ast::expr {\n     mk_expr(cx, sp,\n             ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_glob_use(cx: ext_ctxt,\n-                   sp: span,\n-                   path: ~[ast::ident]) -> @ast::view_item {\n+pub fn mk_glob_use(cx: ext_ctxt, sp: span, path: ~[ast::ident])\n+            -> @ast::view_item {\n     let glob = @codemap::spanned {\n         node: ast::view_path_glob(mk_raw_path(sp, path), cx.next_id()),\n         span: sp,"}, {"sha": "0b2aaa89d9b3a820c38b574582874eb06016319c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -14,7 +14,7 @@ use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n use ast::{tt_delim, tt_tok, item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n use ast;\n use attr;\n-use codemap::{span, ExpandedFrom};\n+use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan};\n use ext::base::*;\n use fold::*;\n use parse::{parser, parse_expr_from_source_str, new_parser_from_tts};\n@@ -48,8 +48,12 @@ pub fn expand_expr(exts: SyntaxExtensions, cx: ext_ctxt,\n                   }\n                   Some(NormalTT(SyntaxExpanderTT{expander: exp,\n                                                  span: exp_sp})) => {\n-                    cx.bt_push(ExpandedFrom({call_site: s,\n-                                callie: {name: *extname, span: exp_sp}}));\n+                    cx.bt_push(ExpandedFrom(CallInfo{\n+                        call_site: s,\n+                        callee: NameAndSpan {\n+                            name: *extname, span: exp_sp\n+                        }\n+                    }));\n \n                     let expanded = match exp(cx, (*mac).span, (*tts)) {\n                       MRExpr(e) => e,\n@@ -105,9 +109,13 @@ pub fn expand_mod_items(exts: SyntaxExtensions, cx: ext_ctxt,\n             match exts.find(&mname) {\n               None | Some(NormalTT(_)) | Some(ItemTT(*)) => items,\n               Some(ItemDecorator(dec_fn)) => {\n-                  cx.bt_push(ExpandedFrom({call_site: attr.span,\n-                                           callie: {name: /*bad*/ copy *mname,\n-                                                    span: None}}));\n+                  cx.bt_push(ExpandedFrom(CallInfo {\n+                      call_site: attr.span,\n+                      callee: NameAndSpan {\n+                          name: /*bad*/ copy *mname,\n+                          span: None\n+                      }\n+                  }));\n                   let r = dec_fn(cx, attr.span, attr.node.value, items);\n                   cx.bt_pop();\n                   r\n@@ -170,9 +178,13 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n                                     given '%s'\", *extname,\n                                    *cx.parse_sess().interner.get(it.ident)));\n             }\n-            cx.bt_push(ExpandedFrom({call_site: it.span,\n-                                     callie: {name: *extname,\n-                                              span: (*expand).span}}));\n+            cx.bt_push(ExpandedFrom(CallInfo {\n+                call_site: it.span,\n+                callee: NameAndSpan {\n+                    name: *extname,\n+                    span: (*expand).span\n+                }\n+            }));\n             ((*expand).expander)(cx, it.span, tts)\n         }\n         Some(ItemTT(ref expand)) => {\n@@ -181,9 +193,13 @@ pub fn expand_item_mac(exts: SyntaxExtensions,\n                               fmt!(\"macro %s! expects an ident argument\",\n                                    *extname));\n             }\n-            cx.bt_push(ExpandedFrom({call_site: it.span,\n-                                     callie: {name: *extname,\n-                                              span: (*expand).span}}));\n+            cx.bt_push(ExpandedFrom(CallInfo {\n+                call_site: it.span,\n+                callee: NameAndSpan {\n+                    name: *extname,\n+                    span: (*expand).span\n+                }\n+            }));\n             ((*expand).expander)(cx, it.span, it.ident, tts)\n         }\n         _ => cx.span_fatal(\n@@ -228,8 +244,10 @@ pub fn expand_stmt(exts: SyntaxExtensions, cx: ext_ctxt,\n \n         Some(NormalTT(\n             SyntaxExpanderTT{expander: exp, span: exp_sp})) => {\n-            cx.bt_push(ExpandedFrom(\n-                {call_site: sp, callie: {name: *extname, span: exp_sp}}));\n+            cx.bt_push(ExpandedFrom(CallInfo {\n+                call_site: sp,\n+                callee: NameAndSpan { name: *extname, span: exp_sp }\n+            }));\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n                     @codemap::spanned { node: stmt_expr(e, cx.next_id()),\n@@ -321,7 +339,7 @@ pub fn core_macros() -> ~str {\n }\";\n }\n \n-pub fn expand_crate(parse_sess: parse::parse_sess,\n+pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n                     cfg: ast::crate_cfg, c: @crate) -> @crate {\n     let exts = syntax_expander_table();\n     let afp = default_ast_fold();"}, {"sha": "e1e142d06eb49aaf97478f40f37baa2ee52aaf9d", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -118,10 +118,18 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                 sp,\n                 make_path_vec(cx, @~\"Conv\"),\n                 ~[\n-                    {ident: intr.intern(@~\"flags\"), ex: flags_expr},\n-                    {ident: intr.intern(@~\"width\"), ex: width_expr},\n-                    {ident: intr.intern(@~\"precision\"), ex: precision_expr},\n-                    {ident: intr.intern(@~\"ty\"), ex: ty_expr},\n+                    build::Field {\n+                        ident: intr.intern(@~\"flags\"), ex: flags_expr\n+                    },\n+                    build::Field {\n+                        ident: intr.intern(@~\"width\"), ex: width_expr\n+                    },\n+                    build::Field {\n+                        ident: intr.intern(@~\"precision\"), ex: precision_expr\n+                    },\n+                    build::Field {\n+                        ident: intr.intern(@~\"ty\"), ex: ty_expr\n+                    },\n                 ]\n             )\n         }"}, {"sha": "6d117f5ad235cda4e7e22d132bfeb12da313d407", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -68,7 +68,7 @@ pub fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n                 tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n+    let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n                                cx.parse_sess().interner, None, tt);\n     let rdr = tt_rdr as reader;\n     let rust_parser = Parser(sess, cfg, rdr.dup());"}, {"sha": "a2f881fc19f71bbb595789a73fb7b71a4c851abf", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -11,6 +11,7 @@\n // Parsing pipes protocols from token trees.\n \n use ext::pipes::pipec::*;\n+use parse::common::SeqSep;\n use parse::parser;\n use parse::token;\n \n@@ -26,9 +27,10 @@ pub impl proto_parser for parser::Parser {\n     fn parse_proto(&self, id: ~str) -> protocol {\n         let proto = protocol(id, self.span);\n \n-        self.parse_seq_to_before_end(token::EOF,\n-                                     {sep: None, trailing_sep_allowed: false},\n-                                     |self| self.parse_state(proto));\n+        self.parse_seq_to_before_end(token::EOF, SeqSep {\n+                                        sep: None,\n+                                        trailing_sep_allowed: false\n+                                     }, |self| self.parse_state(proto));\n \n         return proto;\n     }\n@@ -58,20 +60,21 @@ pub impl proto_parser for parser::Parser {\n \n         // parse the messages\n         self.parse_unspanned_seq(\n-            token::LBRACE, token::RBRACE,\n-            {sep: Some(token::COMMA), trailing_sep_allowed: true},\n-            |self| self.parse_message(state));\n+            token::LBRACE, token::RBRACE, SeqSep {\n+                sep: Some(token::COMMA),\n+                trailing_sep_allowed: true\n+            }, |self| self.parse_message(state));\n     }\n \n     fn parse_message(&self, state: state) {\n         let mname = *self.interner.get(self.parse_ident());\n \n         let args = if self.token == token::LPAREN {\n             self.parse_unspanned_seq(token::LPAREN,\n-                                     token::RPAREN,\n-                                     {sep: Some(token::COMMA),\n-                                      trailing_sep_allowed: true},\n-                                     |p| p.parse_ty(false))\n+                                     token::RPAREN, SeqSep {\n+                                        sep: Some(token::COMMA),\n+                                        trailing_sep_allowed: true\n+                                     }, |p| p.parse_ty(false))\n         }\n         else { ~[] };\n \n@@ -82,10 +85,10 @@ pub impl proto_parser for parser::Parser {\n             let name = *self.interner.get(self.parse_ident());\n             let ntys = if self.token == token::LT {\n                 self.parse_unspanned_seq(token::LT,\n-                                         token::GT,\n-                                         {sep: Some(token::COMMA),\n-                                          trailing_sep_allowed: true},\n-                                         |p| p.parse_ty(false))\n+                                         token::GT, SeqSep {\n+                                            sep: Some(token::COMMA),\n+                                            trailing_sep_allowed: true\n+                                         }, |p| p.parse_ty(false))\n             }\n             else { ~[] };\n             Some(next_state {state: name, tys: ntys})"}, {"sha": "26c38c945c7f144ee9149b942e73de13d6e22269", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -10,6 +10,7 @@\n \n use codemap;\n use codemap::{FileMap, Loc, Pos, ExpandedFrom, span};\n+use codemap::{CallInfo, NameAndSpan};\n use ext::base::*;\n use ext::base;\n use ext::build::{mk_base_vec_e, mk_uint, mk_u8, mk_base_str};\n@@ -22,10 +23,13 @@ use core::str;\n use core::vec;\n \n fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n-    let ExpandedFrom({call_site, _}) = *expn_info;\n+    let ExpandedFrom(CallInfo { call_site, _ }) = *expn_info;\n     match call_site.expn_info {\n         Some(next_expn_info) => {\n-            let ExpandedFrom({callie: {name, _}, _}) = *next_expn_info;\n+            let ExpandedFrom(CallInfo {\n+                callee: NameAndSpan {name, _},\n+                _\n+            }) = *next_expn_info;\n             // Don't recurse into file using \"include!\"\n             if name == ~\"include\" { return expn_info; }\n "}, {"sha": "f662f0337bfbcf5705d28d75bb598c6ddf504a9d", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -22,7 +22,7 @@ pub fn expand_trace_macros(cx: ext_ctxt, sp: span,\n                            tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n+    let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n                                cx.parse_sess().interner, None, tt);\n     let rdr = tt_rdr as reader;\n     let rust_parser = Parser(sess, cfg, rdr.dup());"}, {"sha": "d51ddae6db2f3d159d3d92f2a77c31a251a8927b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -14,7 +14,7 @@ use codemap::{BytePos, mk_sp};\n use codemap;\n use parse::common::*; //resolve bug?\n use parse::lexer::*; //resolve bug?\n-use parse::parse_sess;\n+use parse::ParseSess;\n use parse::parser::Parser;\n use parse::token::{Token, EOF, to_str, nonterminal};\n use parse::token;\n@@ -101,7 +101,7 @@ eof: [a $( a )* a b \u00b7]\n nonempty body. */\n \n pub enum matcher_pos_up { /* to break a circularity */\n-    matcher_pos_up(Option<matcher_pos>)\n+    matcher_pos_up(Option<~MatcherPos>)\n }\n \n pub fn is_some(&&mpu: matcher_pos_up) -> bool {\n@@ -111,17 +111,17 @@ pub fn is_some(&&mpu: matcher_pos_up) -> bool {\n     }\n }\n \n-pub type matcher_pos = ~{\n+pub struct MatcherPos {\n     elts: ~[ast::matcher], // maybe should be /&? Need to understand regions.\n     sep: Option<Token>,\n     mut idx: uint,\n     mut up: matcher_pos_up, // mutable for swapping only\n     matches: ~[DVec<@named_match>],\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n-};\n+}\n \n-pub fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n+pub fn copy_up(&& mpu: matcher_pos_up) -> ~MatcherPos {\n     match &mpu {\n       &matcher_pos_up(Some(ref mp)) => copy (*mp),\n       _ => fail!()\n@@ -139,7 +139,7 @@ pub fn count_names(ms: &[matcher]) -> uint {\n \n #[allow(non_implicitly_copyable_typarams)]\n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n-                        -> matcher_pos {\n+                        -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n     for ms.each() |elt| {\n         match elt.node {\n@@ -152,9 +152,16 @@ pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n           }\n         }\n     }\n-    ~{elts: ms, sep: sep, mut idx: 0u, mut up: matcher_pos_up(None),\n-      matches: copy vec::from_fn(count_names(ms), |_i| dvec::DVec()),\n-      match_lo: 0u, match_hi: match_idx_hi, sp_lo: lo}\n+    ~MatcherPos {\n+        elts: ms,\n+        sep: sep,\n+        mut idx: 0u,\n+        mut up: matcher_pos_up(None),\n+        matches: copy vec::from_fn(count_names(ms), |_i| dvec::DVec()),\n+        match_lo: 0u,\n+        match_hi: match_idx_hi,\n+        sp_lo: lo\n+    }\n }\n \n // named_match is a pattern-match result for a single ast::match_nonterminal:\n@@ -181,11 +188,11 @@ pub enum named_match {\n     matched_nonterminal(nonterminal)\n }\n \n-pub type earley_item = matcher_pos;\n+pub type earley_item = ~MatcherPos;\n \n-pub fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n+pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n             -> HashMap<ident,@named_match> {\n-    fn n_rec(p_s: parse_sess, m: matcher, res: ~[@named_match],\n+    fn n_rec(p_s: @mut ParseSess, m: matcher, res: ~[@named_match],\n              ret_val: HashMap<ident, @named_match>) {\n         match m {\n           codemap::spanned {node: match_tok(_), _} => (),\n@@ -216,7 +223,7 @@ pub enum parse_result {\n     error(codemap::span, ~str)\n }\n \n-pub fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n+pub fn parse_or_else(sess: @mut ParseSess, cfg: ast::crate_cfg, rdr: reader,\n                      ms: ~[matcher]) -> HashMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n@@ -225,7 +232,7 @@ pub fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n     }\n }\n \n-pub fn parse(sess: parse_sess,\n+pub fn parse(sess: @mut ParseSess,\n              cfg: ast::crate_cfg,\n              rdr: reader,\n              ms: ~[matcher])\n@@ -321,8 +328,10 @@ pub fn parse(sess: parse_sess,\n                     let matches = vec::map(ei.matches, // fresh, same size:\n                                            |_m| DVec::<@named_match>());\n                     let ei_t = ei;\n-                    cur_eis.push(~{\n-                        elts: (*matchers), sep: (*sep), mut idx: 0u,\n+                    cur_eis.push(~MatcherPos {\n+                        elts: (*matchers),\n+                        sep: (*sep),\n+                        mut idx: 0u,\n                         mut up: matcher_pos_up(Some(ei_t)),\n                         matches: matches,\n                         match_lo: match_idx_lo, match_hi: match_idx_hi,"}, {"sha": "f42bb01f7c21d3355baccfd20e8d6f66e6711423", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -53,7 +53,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n-    let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n+    let arg_reader = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n                                    cx.parse_sess().interner, None, arg);\n     let argument_map = parse_or_else(cx.parse_sess(), cx.cfg(),\n                                      arg_reader as reader, argument_gram);"}, {"sha": "5803c607191efbd5e95ebedef67eff46b997d39e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -24,7 +24,7 @@ pub trait parser_attr {\n     fn parse_attribute_naked(style: ast::attr_style, lo: BytePos) ->\n         ast::attribute;\n     fn parse_inner_attrs_and_next() ->\n-        {inner: ~[ast::attribute], next: ~[ast::attribute]};\n+        (~[ast::attribute], ~[ast::attribute]);\n     fn parse_meta_item() -> @ast::meta_item;\n     fn parse_meta_seq() -> ~[@ast::meta_item];\n     fn parse_optional_meta() -> ~[@ast::meta_item];\n@@ -82,7 +82,7 @@ impl parser_attr for Parser {\n     // is an inner attribute of the containing item or an outer attribute of\n     // the first contained item until we see the semi).\n     fn parse_inner_attrs_and_next() ->\n-        {inner: ~[ast::attribute], next: ~[ast::attribute]} {\n+        (~[ast::attribute], ~[ast::attribute]) {\n         let mut inner_attrs: ~[ast::attribute] = ~[];\n         let mut next_outer_attrs: ~[ast::attribute] = ~[];\n         loop {\n@@ -121,7 +121,7 @@ impl parser_attr for Parser {\n               _ => break\n             }\n         }\n-        return {inner: inner_attrs, next: next_outer_attrs};\n+        (inner_attrs, next_outer_attrs)\n     }\n \n     fn parse_meta_item() -> @ast::meta_item {"}, {"sha": "152bd9b0ce417317e03e02e9232825698d2ced7f", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -44,7 +44,11 @@ impl cmp::Eq for cmnt_style {\n     }\n }\n \n-pub type cmnt = {style: cmnt_style, lines: ~[~str], pos: BytePos};\n+pub struct cmnt {\n+    style: cmnt_style,\n+    lines: ~[~str],\n+    pos: BytePos\n+}\n \n pub fn is_doc_comment(s: &str) -> bool {\n     (s.starts_with(~\"///\") && !is_line_non_doc_comment(s)) ||\n@@ -147,7 +151,7 @@ fn consume_non_eol_whitespace(rdr: @mut StringReader) {\n fn push_blank_line_comment(rdr: @mut StringReader, comments: &mut ~[cmnt]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n-    comments.push({style: blank_line, lines: v, pos: rdr.last_pos});\n+    comments.push(cmnt {style: blank_line, lines: v, pos: rdr.last_pos});\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: @mut StringReader,\n@@ -166,7 +170,7 @@ fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n     debug!(\">>> shebang comment\");\n     let p = rdr.last_pos;\n     debug!(\"<<< shebang comment\");\n-    comments.push({\n+    comments.push(cmnt {\n         style: if code_to_the_left { trailing } else { isolated },\n         lines: ~[read_one_line_comment(rdr)],\n         pos: p\n@@ -189,7 +193,7 @@ fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n     }\n     debug!(\"<<< line comments\");\n     if !lines.is_empty() {\n-        comments.push({\n+        comments.push(cmnt {\n             style: if code_to_the_left { trailing } else { isolated },\n             lines: lines,\n             pos: p\n@@ -288,7 +292,7 @@ fn read_block_comment(rdr: @mut StringReader,\n         style = mixed;\n     }\n     debug!(\"<<< block comment\");\n-    comments.push({style: style, lines: lines, pos: p});\n+    comments.push(cmnt {style: style, lines: lines, pos: p});\n }\n \n fn peeking_at_comment(rdr: @mut StringReader) -> bool {\n@@ -311,12 +315,14 @@ fn consume_comment(rdr: @mut StringReader,\n     debug!(\"<<< consume comment\");\n }\n \n-pub type lit = {lit: ~str, pos: BytePos};\n+pub struct lit {\n+    lit: ~str,\n+    pos: BytePos\n+}\n \n pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n                                     path: ~str,\n-                                    srdr: io::Reader) ->\n-   {cmnts: ~[cmnt], lits: ~[lit]} {\n+                                    srdr: io::Reader) -> (~[cmnt], ~[lit]) {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = parse::token::mk_fake_ident_interner();\n     let cm = CodeMap::new();\n@@ -350,12 +356,13 @@ pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(tok) {\n             let s = get_str_from(rdr, bstart);\n-            literals.push({lit: s, pos: sp.lo});\n+            literals.push(lit {lit: s, pos: sp.lo});\n             log(debug, ~\"tok lit: \" + s);\n         } else {\n             log(debug, ~\"tok: \" + token::to_str(rdr.interner, tok));\n         }\n         first_read = false;\n     }\n-    return {cmnts: comments, lits: literals};\n+\n+    (comments, literals)\n }"}, {"sha": "22004be87adc6843c8d4c0c80f9b0dc84adfd978", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -20,21 +20,30 @@ use core::option::{None, Option, Some};\n use core::option;\n use std::oldmap::HashMap;\n \n-// seq_sep : a sequence separator (token)\n+// SeqSep : a sequence separator (token)\n // and whether a trailing separator is allowed.\n-pub type seq_sep = {\n+pub struct SeqSep {\n     sep: Option<token::Token>,\n     trailing_sep_allowed: bool\n-};\n+}\n \n-pub fn seq_sep_trailing_disallowed(t: token::Token) -> seq_sep {\n-    return {sep: option::Some(t), trailing_sep_allowed: false};\n+pub fn seq_sep_trailing_disallowed(t: token::Token) -> SeqSep {\n+    SeqSep {\n+        sep: option::Some(t),\n+        trailing_sep_allowed: false\n+    }\n }\n-pub fn seq_sep_trailing_allowed(t: token::Token) -> seq_sep {\n-    return {sep: option::Some(t), trailing_sep_allowed: true};\n+pub fn seq_sep_trailing_allowed(t: token::Token) -> SeqSep {\n+    SeqSep {\n+        sep: option::Some(t),\n+        trailing_sep_allowed: true\n+    }\n }\n-pub fn seq_sep_none() -> seq_sep {\n-    return {sep: option::None, trailing_sep_allowed: false};\n+pub fn seq_sep_none() -> SeqSep {\n+    SeqSep {\n+        sep: option::None,\n+        trailing_sep_allowed: false\n+    }\n }\n \n pub fn token_to_str(reader: reader, ++token: token::Token) -> ~str {\n@@ -253,7 +262,7 @@ pub impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_end<T:Copy>(ket: token::Token, sep: seq_sep,\n+    fn parse_seq_to_end<T:Copy>(ket: token::Token, sep: SeqSep,\n                                  f: fn(Parser) -> T) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -263,7 +272,7 @@ pub impl Parser {\n     // parse a sequence, not including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    fn parse_seq_to_before_end<T:Copy>(ket: token::Token, sep: seq_sep,\n+    fn parse_seq_to_before_end<T:Copy>(ket: token::Token, sep: SeqSep,\n                                         f: fn(Parser) -> T) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n@@ -286,7 +295,7 @@ pub impl Parser {\n     // closing bracket.\n     fn parse_unspanned_seq<T:Copy>(bra: token::Token,\n                                     ket: token::Token,\n-                                    sep: seq_sep,\n+                                    sep: SeqSep,\n                                     f: fn(Parser) -> T) -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);\n@@ -296,7 +305,7 @@ pub impl Parser {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    fn parse_seq<T:Copy>(bra: token::Token, ket: token::Token, sep: seq_sep,\n+    fn parse_seq<T:Copy>(bra: token::Token, ket: token::Token, sep: SeqSep,\n                           f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);"}, {"sha": "5d44db084d6000182ddd5baaa589cac5a9885ada", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -75,9 +75,9 @@ fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n         let p0 = new_sub_parser_from_file(cx.sess, cx.cfg,\n                                           modpath,\n                                           codemap::dummy_sp());\n-        let inner_attrs = p0.parse_inner_attrs_and_next();\n-        let m0 = p0.parse_mod_items(token::EOF, inner_attrs.next);\n-        return (m0.view_items, m0.items, inner_attrs.inner);\n+        let (inner, next) = p0.parse_inner_attrs_and_next();\n+        let m0 = p0.parse_mod_items(token::EOF, next);\n+        return (m0.view_items, m0.items, inner);\n     } else {\n         return (~[], ~[], ~[]);\n     }\n@@ -111,9 +111,9 @@ pub fn eval_src_mod_from_path(cx: ctx, prefix: &Path, path: &Path,\n     let p0 =\n         new_sub_parser_from_file(cx.sess, cx.cfg,\n                                  &full_path, sp);\n-    let inner_attrs = p0.parse_inner_attrs_and_next();\n-    let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n-    let first_item_outer_attrs = inner_attrs.next;\n+    let (inner, next) = p0.parse_inner_attrs_and_next();\n+    let mod_attrs = vec::append(outer_attrs, inner);\n+    let first_item_outer_attrs = next;\n     let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n     return (ast::item_mod(m0), mod_attrs);\n }"}, {"sha": "0ecd7917ac6dc579e32236b4c835fbd3f19843bf", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -47,33 +47,35 @@ pub mod classify;\n /// Reporting obsolete syntax\n pub mod obsolete;\n \n-pub type parse_sess = @{\n+pub struct ParseSess {\n     cm: @codemap::CodeMap,\n-    mut next_id: node_id,\n+    next_id: node_id,\n     span_diagnostic: span_handler,\n     interner: @ident_interner,\n-};\n+}\n \n-pub fn new_parse_sess(demitter: Option<Emitter>) -> parse_sess {\n+pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n     let cm = @CodeMap::new();\n-    return @{cm: cm,\n-             mut next_id: 1,\n-             span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n-             interner: mk_ident_interner(),\n-            };\n+    @mut ParseSess {\n+        cm: cm,\n+        next_id: 1,\n+        span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n+        interner: mk_ident_interner(),\n+    }\n }\n \n pub fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n-    -> parse_sess {\n-    return @{cm: cm,\n-             mut next_id: 1,\n-             span_diagnostic: sh,\n-             interner: mk_ident_interner(),\n-             };\n+    -> @mut ParseSess {\n+    @mut ParseSess {\n+        cm: cm,\n+        next_id: 1,\n+        span_diagnostic: sh,\n+        interner: mk_ident_interner(),\n+    }\n }\n \n pub fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n-                         sess: parse_sess) -> @ast::crate {\n+                         sess: @mut ParseSess) -> @ast::crate {\n     let p = new_crate_parser_from_file(sess, cfg, input);\n     let r = p.parse_crate_mod(cfg);\n     return r;\n@@ -82,7 +84,7 @@ pub fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n pub fn parse_crate_from_source_str(name: ~str,\n                                    source: @~str,\n                                    cfg: ast::crate_cfg,\n-                                   sess: parse_sess) -> @ast::crate {\n+                                   sess: @mut ParseSess) -> @ast::crate {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n     let r = p.parse_crate_mod(cfg);\n@@ -93,7 +95,7 @@ pub fn parse_crate_from_source_str(name: ~str,\n pub fn parse_expr_from_source_str(name: ~str,\n                                   source: @~str,\n                                   cfg: ast::crate_cfg,\n-                                  sess: parse_sess) -> @ast::expr {\n+                                  sess: @mut ParseSess) -> @ast::expr {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n     let r = p.parse_expr();\n@@ -105,7 +107,7 @@ pub fn parse_item_from_source_str(name: ~str,\n                                   source: @~str,\n                                   cfg: ast::crate_cfg,\n                                   +attrs: ~[ast::attribute],\n-                                  sess: parse_sess)\n+                                  sess: @mut ParseSess)\n                                -> Option<@ast::item> {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n@@ -118,7 +120,7 @@ pub fn parse_stmt_from_source_str(name: ~str,\n                                   source: @~str,\n                                   cfg: ast::crate_cfg,\n                                   +attrs: ~[ast::attribute],\n-                                  sess: parse_sess) -> @ast::stmt {\n+                                  sess: @mut ParseSess) -> @ast::stmt {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n     let r = p.parse_stmt(attrs);\n@@ -129,7 +131,7 @@ pub fn parse_stmt_from_source_str(name: ~str,\n pub fn parse_tts_from_source_str(name: ~str,\n                                  source: @~str,\n                                  cfg: ast::crate_cfg,\n-                                 sess: parse_sess) -> ~[ast::token_tree] {\n+                                 sess: @mut ParseSess) -> ~[ast::token_tree] {\n     let p = new_parser_from_source_str(sess, cfg, name,\n                                        codemap::FssNone, source);\n     p.quote_depth += 1u;\n@@ -141,7 +143,7 @@ pub fn parse_tts_from_source_str(name: ~str,\n pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n                             name: ~str, ss: codemap::FileSubstr,\n                             source: @~str, cfg: ast::crate_cfg,\n-                            sess: parse_sess)\n+                            sess: @mut ParseSess)\n     -> T\n {\n     let p = new_parser_from_source_str(sess, cfg, name, ss,\n@@ -154,33 +156,33 @@ pub fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n     r\n }\n \n-pub fn next_node_id(sess: parse_sess) -> node_id {\n+pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n     let rv = sess.next_id;\n     sess.next_id += 1;\n     // ID 0 is reserved for the crate and doesn't actually exist in the AST\n     assert rv != 0;\n     return rv;\n }\n \n-pub fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n+pub fn new_parser_from_source_str(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                               +name: ~str, +ss: codemap::FileSubstr,\n                               source: @~str) -> Parser {\n     let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n-    let srdr = lexer::new_string_reader(sess.span_diagnostic,\n+    let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n                                         filemap,\n                                         sess.interner);\n     return Parser(sess, cfg, srdr as reader);\n }\n \n-pub fn new_parser_from_file(sess: parse_sess,\n+pub fn new_parser_from_file(sess: @mut ParseSess,\n                             cfg: ast::crate_cfg,\n                             path: &Path)\n                          -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n       result::Ok(src) => {\n \n           let filemap = sess.cm.new_filemap(path.to_str(), @src);\n-          let srdr = lexer::new_string_reader(sess.span_diagnostic,\n+          let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n                                               filemap,\n                                               sess.interner);\n           Ok(Parser(sess, cfg, srdr as reader))\n@@ -192,7 +194,7 @@ pub fn new_parser_from_file(sess: parse_sess,\n \n /// Create a new parser for an entire crate, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+pub fn new_crate_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                               path: &Path) -> Parser {\n     match new_parser_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n@@ -204,7 +206,7 @@ pub fn new_crate_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n \n /// Create a new parser based on a span from an existing parser. Handles\n /// error messages correctly when the file does not exist.\n-pub fn new_sub_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+pub fn new_sub_parser_from_file(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                             path: &Path, sp: span) -> Parser {\n     match new_parser_from_file(sess, cfg, path) {\n         Ok(parser) => parser,\n@@ -214,9 +216,9 @@ pub fn new_sub_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n     }\n }\n \n-pub fn new_parser_from_tts(sess: parse_sess, cfg: ast::crate_cfg,\n+pub fn new_parser_from_tts(sess: @mut ParseSess, cfg: ast::crate_cfg,\n                        tts: ~[ast::token_tree]) -> Parser {\n-    let trdr = lexer::new_tt_reader(sess.span_diagnostic, sess.interner,\n+    let trdr = lexer::new_tt_reader(copy sess.span_diagnostic, sess.interner,\n                                     None, tts);\n     return Parser(sess, cfg, trdr as reader)\n }"}, {"sha": "d0c857d363b5ed6a7b693670cd3ada5cd781a7ac", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 63, "deletions": 58, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -80,7 +80,7 @@ use parse::prec::{as_prec, token_to_binop};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, special_idents};\n use parse::token;\n-use parse::{new_sub_parser_from_file, next_node_id, parse_sess};\n+use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n use print::pprust::expr_to_str;\n use util::interner::Interner;\n \n@@ -179,10 +179,16 @@ pure fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n }\n \n \n+struct ParsedItemsAndViewItems {\n+    attrs_remaining: ~[attribute],\n+    view_items: ~[@view_item],\n+    items: ~[@item],\n+    foreign_items: ~[@foreign_item]\n+}\n+\n /* ident is handled by common.rs */\n \n-pub fn Parser(sess: parse_sess\n-              ,\n+pub fn Parser(sess: @mut ParseSess,\n               cfg: ast::crate_cfg,\n               +rdr: reader) -> Parser {\n \n@@ -213,7 +219,7 @@ pub fn Parser(sess: parse_sess\n }\n \n pub struct Parser {\n-    sess: parse_sess,\n+    sess: @mut ParseSess,\n     cfg: crate_cfg,\n     mut token: token::Token,\n     mut span: span,\n@@ -1706,8 +1712,7 @@ pub impl Parser {\n             els = Some(elexpr);\n             hi = elexpr.span.hi;\n         }\n-        let q = {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n-        self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els))\n+        self.mk_expr(lo, hi, expr_if(cond, thn, els))\n     }\n \n     fn parse_fn_expr(sigil: Sigil) -> @expr {\n@@ -2470,11 +2475,11 @@ pub impl Parser {\n         maybe_whole!(pair_empty self, nt_block);\n \n         fn maybe_parse_inner_attrs_and_next(p: Parser, parse_attrs: bool) ->\n-            {inner: ~[attribute], next: ~[attribute]} {\n+            (~[attribute], ~[attribute]) {\n             if parse_attrs {\n                 p.parse_inner_attrs_and_next()\n             } else {\n-                {inner: ~[], next: ~[]}\n+                (~[], ~[])\n             }\n         }\n \n@@ -2483,7 +2488,7 @@ pub impl Parser {\n             self.obsolete(copy self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(token::LBRACE);\n-        let {inner: inner, next: next} =\n+        let (inner, next) =\n             maybe_parse_inner_attrs_and_next(self, parse_attrs);\n         return (inner, self.parse_block_tail_(lo, default_blk, next));\n     }\n@@ -2508,10 +2513,12 @@ pub impl Parser {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n-        let {attrs_remaining: attrs_remaining,\n-             view_items: view_items,\n-             items: items, _} =\n-            self.parse_items_and_view_items(first_item_attrs,\n+        let ParsedItemsAndViewItems {\n+            attrs_remaining: attrs_remaining,\n+            view_items: view_items,\n+            items: items,\n+            _\n+        } = self.parse_items_and_view_items(first_item_attrs,\n                                             IMPORTS_AND_ITEMS_ALLOWED, false);\n \n         for items.each |item| {\n@@ -2851,10 +2858,10 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_fn_header() -> {ident: ident, tps: ~[ty_param]} {\n+    fn parse_fn_header() -> (ident, ~[ty_param]) {\n         let id = self.parse_value_ident();\n         let ty_params = self.parse_ty_params();\n-        return {ident: id, tps: ty_params};\n+        (id, ty_params)\n     }\n \n     fn mk_item(+lo: BytePos, +hi: BytePos, +ident: ident,\n@@ -2869,10 +2876,10 @@ pub impl Parser {\n     }\n \n     fn parse_item_fn(purity: purity) -> item_info {\n-        let t = self.parse_fn_header();\n+        let (ident, tps) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n-        (t.ident, item_fn(decl, purity, t.tps, body), Some(inner_attrs))\n+        (ident, item_fn(decl, purity, tps, body), Some(inner_attrs))\n     }\n \n     fn parse_method_name() -> ident {\n@@ -3200,10 +3207,12 @@ pub impl Parser {\n     fn parse_mod_items(term: token::Token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining: attrs_remaining,\n-             view_items: view_items,\n-             items: starting_items, _} =\n-            self.parse_items_and_view_items(first_item_attrs,\n+        let ParsedItemsAndViewItems {\n+            attrs_remaining: attrs_remaining,\n+            view_items: view_items,\n+            items: starting_items,\n+            _\n+        } = self.parse_items_and_view_items(first_item_attrs,\n                                             VIEW_ITEMS_AND_ITEMS_ALLOWED,\n                                             true);\n         let mut items: ~[@item] = starting_items;\n@@ -3261,11 +3270,11 @@ pub impl Parser {\n         } else {\n             self.push_mod_path(id, outer_attrs);\n             self.expect(token::LBRACE);\n-            let inner_attrs = self.parse_inner_attrs_and_next();\n-            let m = self.parse_mod_items(token::RBRACE, inner_attrs.next);\n+            let (inner, next) = self.parse_inner_attrs_and_next();\n+            let m = self.parse_mod_items(token::RBRACE, next);\n             self.expect(token::RBRACE);\n             self.pop_mod_path();\n-            (id, item_mod(m), Some(inner_attrs.inner))\n+            (id, item_mod(m), Some(inner))\n         };\n \n         // XXX: Transitionary hack to do the template work inside core\n@@ -3355,9 +3364,9 @@ pub impl Parser {\n         let p0 =\n             new_sub_parser_from_file(self.sess, self.cfg,\n                                      &full_path, id_sp);\n-        let inner_attrs = p0.parse_inner_attrs_and_next();\n-        let mod_attrs = vec::append(outer_attrs, inner_attrs.inner);\n-        let first_item_outer_attrs = inner_attrs.next;\n+        let (inner, next) = p0.parse_inner_attrs_and_next();\n+        let mod_attrs = vec::append(outer_attrs, inner);\n+        let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return (ast::item_mod(m0), mod_attrs);\n \n@@ -3373,13 +3382,13 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n-        let t = self.parse_fn_header();\n+        let (ident, tps) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let mut hi = self.span.hi;\n         self.expect(token::SEMI);\n-        @ast::foreign_item { ident: t.ident,\n+        @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n-                             node: foreign_item_fn(decl, purity, t.tps),\n+                             node: foreign_item_fn(decl, purity, tps),\n                              id: self.get_id(),\n                              span: mk_sp(lo, hi),\n                              vis: vis }\n@@ -3428,11 +3437,12 @@ pub impl Parser {\n                                +first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining: attrs_remaining,\n-             view_items: view_items,\n-             items: _,\n-             foreign_items: foreign_items} =\n-            self.parse_items_and_view_items(first_item_attrs,\n+        let ParsedItemsAndViewItems {\n+            attrs_remaining: attrs_remaining,\n+            view_items: view_items,\n+            items: _,\n+            foreign_items: foreign_items\n+        } = self.parse_items_and_view_items(first_item_attrs,\n                                          VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED,\n                                             true);\n \n@@ -3504,17 +3514,13 @@ pub impl Parser {\n                 None => abi = special_idents::c_abi,\n             }\n \n-            let extra_attrs = self.parse_inner_attrs_and_next();\n-            let m = self.parse_foreign_mod_items(sort,\n-                                                 abi,\n-                                                 extra_attrs.next);\n+            let (inner, next) = self.parse_inner_attrs_and_next();\n+            let m = self.parse_foreign_mod_items(sort, abi, next);\n             self.expect(token::RBRACE);\n \n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n-                                          item_foreign_mod(m), visibility,\n-                                          maybe_append(attrs,\n-                                                       Some(extra_attrs.\n-                                                            inner))));\n+                                     item_foreign_mod(m), visibility,\n+                                     maybe_append(attrs, Some(inner))));\n         }\n \n         match abi_opt {\n@@ -3536,20 +3542,20 @@ pub impl Parser {\n         })\n     }\n \n-    fn parse_type_decl() -> {lo: BytePos, ident: ident} {\n+    fn parse_type_decl() -> (BytePos, ident) {\n         let lo = self.last_span.lo;\n         let id = self.parse_ident();\n-        return {lo: lo, ident: id};\n+        (lo, id)\n     }\n \n     fn parse_item_type() -> item_info {\n-        let t = self.parse_type_decl();\n+        let (_, ident) = self.parse_type_decl();\n         self.parse_region_param();\n         let tps = self.parse_ty_params();\n         self.expect(token::EQ);\n         let ty = self.parse_ty(false);\n         self.expect(token::SEMI);\n-        (t.ident, item_ty(ty, tps), None)\n+        (ident, item_ty(ty, tps), None)\n     }\n \n     fn parse_region_param() {\n@@ -4046,10 +4052,7 @@ pub impl Parser {\n     fn parse_items_and_view_items(+first_item_attrs: ~[attribute],\n                                   mode: view_item_parse_mode,\n                                   macros_allowed: bool)\n-                               -> {attrs_remaining: ~[attribute],\n-                                   view_items: ~[@view_item],\n-                                   items: ~[@item],\n-                                   foreign_items: ~[@foreign_item]} {\n+                                -> ParsedItemsAndViewItems {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n \n@@ -4100,21 +4103,23 @@ pub impl Parser {\n             attrs = self.parse_outer_attributes();\n         }\n \n-        {attrs_remaining: attrs,\n-         view_items: view_items,\n-         items: items,\n-         foreign_items: foreign_items}\n+        ParsedItemsAndViewItems {\n+            attrs_remaining: attrs,\n+            view_items: view_items,\n+            items: items,\n+            foreign_items: foreign_items\n+        }\n     }\n \n     // Parses a source module as a crate\n     fn parse_crate_mod(_cfg: crate_cfg) -> @crate {\n         let lo = self.span.lo;\n-        let crate_attrs = self.parse_inner_attrs_and_next();\n-        let first_item_outer_attrs = crate_attrs.next;\n+        let (inner, next) = self.parse_inner_attrs_and_next();\n+        let first_item_outer_attrs = next;\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n         @spanned(lo, self.span.lo,\n                  ast::crate_ { module: m,\n-                               attrs: crate_attrs.inner,\n+                               attrs: inner,\n                                config: self.cfg })\n     }\n "}, {"sha": "402c7c2663465ff3a7d5d184d6fa3b37088d95c6", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -72,9 +72,15 @@ use core::vec;\n #[deriving_eq]\n pub enum breaks { consistent, inconsistent, }\n \n-pub type break_t = {offset: int, blank_space: int};\n+pub struct break_t {\n+    offset: int,\n+    blank_space: int\n+}\n \n-pub type begin_t = {offset: int, breaks: breaks};\n+pub struct begin_t {\n+    offset: int,\n+    breaks: breaks\n+}\n \n pub enum token {\n     STRING(@~str, int),\n@@ -90,7 +96,10 @@ pub impl token {\n     }\n     fn is_hardbreak_tok(&self) -> bool {\n         match *self {\n-            BREAK({offset: 0, blank_space: bs }) if bs == size_infinity =>\n+            BREAK(break_t {\n+                offset: 0,\n+                blank_space: bs\n+            }) if bs == size_infinity =>\n                 true,\n             _ =>\n                 false\n@@ -128,7 +137,10 @@ pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n \n pub enum print_stack_break { fits, broken(breaks), }\n \n-pub type print_stack_elt = {offset: int, pbreak: print_stack_break};\n+pub struct print_stack_elt {\n+    offset: int,\n+    pbreak: print_stack_break\n+}\n \n pub const size_infinity: int = 0xffff;\n \n@@ -445,7 +457,10 @@ pub impl Printer {\n         if n != 0u {\n             self.print_stack[n - 1u]\n         } else {\n-            {offset: 0, pbreak: broken(inconsistent)}\n+            print_stack_elt {\n+                offset: 0,\n+                pbreak: broken(inconsistent)\n+            }\n         }\n     }\n     fn print_str(&mut self, s: ~str) {\n@@ -468,12 +483,16 @@ pub impl Printer {\n             if L > self.space {\n                 let col = self.margin - self.space + b.offset;\n                 debug!(\"print BEGIN -> push broken block at col %d\", col);\n-                self.print_stack.push({offset: col,\n-                                       pbreak: broken(b.breaks)});\n+                self.print_stack.push(print_stack_elt {\n+                    offset: col,\n+                    pbreak: broken(b.breaks)\n+                });\n             } else {\n                 debug!(\"print BEGIN -> push fitting block\");\n-                self.print_stack.push({offset: 0,\n-                                       pbreak: fits});\n+                self.print_stack.push(print_stack_elt {\n+                    offset: 0,\n+                    pbreak: fits\n+                });\n             }\n           }\n           END => {\n@@ -527,15 +546,21 @@ pub impl Printer {\n \n // Convenience functions to talk to the printer.\n pub fn box(p: @mut Printer, indent: uint, b: breaks) {\n-    p.pretty_print(BEGIN({offset: indent as int, breaks: b}));\n+    p.pretty_print(BEGIN(begin_t {\n+        offset: indent as int,\n+        breaks: b\n+    }));\n }\n \n pub fn ibox(p: @mut Printer, indent: uint) { box(p, indent, inconsistent); }\n \n pub fn cbox(p: @mut Printer, indent: uint) { box(p, indent, consistent); }\n \n pub fn break_offset(p: @mut Printer, n: uint, off: int) {\n-    p.pretty_print(BREAK({offset: off, blank_space: n as int}));\n+    p.pretty_print(BREAK(break_t {\n+        offset: off,\n+        blank_space: n as int\n+    }));\n }\n \n pub fn end(p: @mut Printer) { p.pretty_print(END); }\n@@ -563,7 +588,7 @@ pub fn space(p: @mut Printer) { spaces(p, 1u); }\n pub fn hardbreak(p: @mut Printer) { spaces(p, size_infinity as uint); }\n \n pub fn hardbreak_tok_offset(off: int) -> token {\n-    return BREAK({offset: off, blank_space: size_infinity});\n+    BREAK(break_t {offset: off, blank_space: size_infinity})\n }\n \n pub fn hardbreak_tok() -> token { return hardbreak_tok_offset(0); }"}, {"sha": "d5a09e087a02eb648d7f67c93209800b4c60e3da", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -108,17 +108,18 @@ pub fn print_crate(cm: @CodeMap, intr: @ident_interner,\n                    span_diagnostic: diagnostic::span_handler,\n                    crate: @ast::crate, filename: ~str, in: io::Reader,\n                    out: io::Writer, ann: pp_ann, is_expanded: bool) {\n-    let r = comments::gather_comments_and_literals(span_diagnostic,\n-                                                   filename, in);\n+    let (cmnts, lits) =\n+        comments::gather_comments_and_literals(span_diagnostic,\n+                                               filename, in);\n     let s = @ps {\n         s: pp::mk_printer(out, default_columns),\n         cm: Some(cm),\n         intr: intr,\n-        comments: Some(r.cmnts),\n+        comments: Some(cmnts),\n         // If the code is post expansion, don't use the table of\n         // literals, since it doesn't correspond with the literals\n         // in the AST anymore.\n-        literals: if is_expanded { None } else { Some(r.lits) },\n+        literals: if is_expanded { None } else { Some(lits) },\n         cur_cmnt_and_lit: @mut CurrentCommentAndLiteral {\n             cur_cmnt: 0,\n             cur_lit: 0"}, {"sha": "05bbe43ee9abfd25b627a6f167418b93b4862458", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4a5e8c52183a980f6c2fc63a668245d73ecac200/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=4a5e8c52183a980f6c2fc63a668245d73ecac200", "patch": "@@ -17,7 +17,6 @@\n #[crate_type = \"lib\"];\n \n #[legacy_modes];\n-#[legacy_records];\n \n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];"}]}