{"sha": "db753137a14b04886567a1f20768b96feba05594", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNzUzMTM3YTE0YjA0ODg2NTY3YTFmMjA3NjhiOTZmZWJhMDU1OTQ=", "commit": {"author": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-15T05:05:18Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-08-17T16:01:04Z"}, "message": "Fix stack overflow for recursive types.\n\nAdds a seen set to structurally_same_type to avoid recursing\nindefinitely when a reference or pointer member introduces a cycle in\nthe visited types.", "tree": {"sha": "03701c5624d6963e1e6539e017cb5eb55e5d9902", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03701c5624d6963e1e6539e017cb5eb55e5d9902"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db753137a14b04886567a1f20768b96feba05594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db753137a14b04886567a1f20768b96feba05594", "html_url": "https://github.com/rust-lang/rust/commit/db753137a14b04886567a1f20768b96feba05594", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db753137a14b04886567a1f20768b96feba05594/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0eb55a092506aa4cfe34969c56adfeca9616750", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0eb55a092506aa4cfe34969c56adfeca9616750", "html_url": "https://github.com/rust-lang/rust/commit/b0eb55a092506aa4cfe34969c56adfeca9616750"}], "stats": {"total": 289, "additions": 187, "deletions": 102}, "files": [{"sha": "0e578ac5034db2e577cceea74722313344273304", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 187, "deletions": 102, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/db753137a14b04886567a1f20768b96feba05594/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db753137a14b04886567a1f20768b96feba05594/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=db753137a14b04886567a1f20768b96feba05594", "patch": "@@ -2153,123 +2153,208 @@ impl ClashingExternDeclarations {\n         b: Ty<'tcx>,\n         ckind: CItemKind,\n     ) -> bool {\n-        debug!(\"structurally_same_type(cx, a = {:?}, b = {:?})\", a, b);\n-        let tcx = cx.tcx;\n-        if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n-            // All nominally-same types are structurally same, too.\n-            true\n-        } else {\n-            // Do a full, depth-first comparison between the two.\n-            use rustc_middle::ty::TyKind::*;\n-            let a_kind = &a.kind;\n-            let b_kind = &b.kind;\n-\n-            let compare_layouts = |a, b| -> bool {\n-                let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n-                let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n-                debug!(\"{:?} == {:?} = {}\", a_layout, b_layout, a_layout == b_layout);\n-                a_layout == b_layout\n-            };\n+        // In order to avoid endlessly recursing on recursive types, we maintain a \"seen\" set.\n+        // We'll need to store every combination of types we encounter anyway, so we also memoize\n+        // the result.\n+        struct SeenSet<'tcx>(FxHashMap<(Ty<'tcx>, Ty<'tcx>), Option<bool>>);\n+\n+        enum SeenSetResult {\n+            /// We've never seen this combination of types.\n+            Unseen,\n+            /// We've seen this combination of types, but are still computing the result.\n+            Computing,\n+            /// We've seen this combination of types, and have already computed the result.\n+            Computed(bool),\n+        }\n+\n+        impl<'tcx> SeenSet<'tcx> {\n+            fn new() -> Self {\n+                SeenSet(FxHashMap::default())\n+            }\n+            /// Mark (a, b) as `Computing`.\n+            fn mark_computing(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+                self.0.insert((a, b), None);\n+            }\n+            /// Mark (a, b) as `Computed(result)`.\n+            fn mark_computed(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, result: bool) {\n+                *self.0.get_mut(&(a, b)).expect(\"Missing prior call to mark_computing\") =\n+                    Some(result);\n+            }\n+            fn get(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> SeenSetResult {\n+                match self.0.get(&(a, b)) {\n+                    None => SeenSetResult::Unseen,\n+                    Some(None) => SeenSetResult::Computing,\n+                    Some(Some(b)) => SeenSetResult::Computed(*b),\n+                }\n+            }\n+        }\n+        fn structurally_same_type_impl<'tcx>(\n+            seen_types: &mut SeenSet<'tcx>,\n+            cx: &LateContext<'tcx>,\n+            a: Ty<'tcx>,\n+            b: Ty<'tcx>,\n+            ckind: CItemKind,\n+        ) -> bool {\n+            debug!(\"structurally_same_type_impl(cx, a = {:?}, b = {:?})\", a, b);\n+            match seen_types.get(a, b) {\n+                // If we've already computed the result, just return the memoized result.\n+                SeenSetResult::Computed(result) => result,\n+                // We are already in the process of computing structural sameness for this type,\n+                // meaning we've found a cycle. The types are structurally same, then.\n+                SeenSetResult::Computing => true,\n+                // We haven't seen this combination of types at all -- compute their sameness.\n+                SeenSetResult::Unseen => {\n+                    seen_types.mark_computing(a, b);\n+                    let tcx = cx.tcx;\n+                    let result = if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n+                        // All nominally-same types are structurally same, too.\n+                        true\n+                    } else {\n+                        // Do a full, depth-first comparison between the two.\n+                        use rustc_middle::ty::TyKind::*;\n+                        let a_kind = &a.kind;\n+                        let b_kind = &b.kind;\n+\n+                        let compare_layouts = |a, b| -> bool {\n+                            let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n+                            let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n+                            debug!(\"{:?} == {:?} = {}\", a_layout, b_layout, a_layout == b_layout);\n+                            a_layout == b_layout\n+                        };\n+\n+                        #[allow(rustc::usage_of_ty_tykind)]\n+                        let is_primitive_or_pointer = |kind: &ty::TyKind<'_>| {\n+                            kind.is_primitive() || matches!(kind, RawPtr(..))\n+                        };\n \n-            #[allow(rustc::usage_of_ty_tykind)]\n-            let is_primitive_or_pointer =\n-                |kind: &ty::TyKind<'_>| kind.is_primitive() || matches!(kind, RawPtr(..));\n-\n-            match (a_kind, b_kind) {\n-                (Adt(_, a_substs), Adt(_, b_substs)) => {\n-                    let a = a.subst(cx.tcx, a_substs);\n-                    let b = b.subst(cx.tcx, b_substs);\n-                    debug!(\"Comparing {:?} and {:?}\", a, b);\n-\n-                    if let (Adt(a_def, ..), Adt(b_def, ..)) = (&a.kind, &b.kind) {\n-                        // Grab a flattened representation of all fields.\n-                        let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n-                        let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n-                        compare_layouts(a, b)\n+                        match (a_kind, b_kind) {\n+                            (Adt(_, a_substs), Adt(_, b_substs)) => {\n+                                let a = a.subst(cx.tcx, a_substs);\n+                                let b = b.subst(cx.tcx, b_substs);\n+                                debug!(\"Comparing {:?} and {:?}\", a, b);\n+\n+                                if let (Adt(a_def, ..), Adt(b_def, ..)) = (&a.kind, &b.kind) {\n+                                    // Grab a flattened representation of all fields.\n+                                    let a_fields =\n+                                        a_def.variants.iter().flat_map(|v| v.fields.iter());\n+                                    let b_fields =\n+                                        b_def.variants.iter().flat_map(|v| v.fields.iter());\n+                                    compare_layouts(a, b)\n                             && a_fields.eq_by(\n                                 b_fields,\n                                 |&ty::FieldDef { did: a_did, .. },\n                                  &ty::FieldDef { did: b_did, .. }| {\n-                                    Self::structurally_same_type(\n+                                    structurally_same_type_impl(\n+                                        seen_types,\n                                         cx,\n                                         tcx.type_of(a_did),\n                                         tcx.type_of(b_did),\n                                         ckind,\n                                     )\n                                 },\n                             )\n-                    } else {\n-                        unreachable!()\n-                    }\n-                }\n-                (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n-                    // For arrays, we also check the constness of the type.\n-                    a_const.val == b_const.val\n-                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty, ckind)\n-                        && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n-                }\n-                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty, ckind),\n-                (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n-                    a_tymut.mutbl == b_tymut.mutbl\n-                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty, ckind)\n-                }\n-                (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n-                    // For structural sameness, we don't need the region to be same.\n-                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n-                }\n-                (FnDef(..), FnDef(..)) => {\n-                    let a_poly_sig = a.fn_sig(tcx);\n-                    let b_poly_sig = b.fn_sig(tcx);\n-\n-                    // As we don't compare regions, skip_binder is fine.\n-                    let a_sig = a_poly_sig.skip_binder();\n-                    let b_sig = b_poly_sig.skip_binder();\n-\n-                    (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n-                        == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n-                        && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                            Self::structurally_same_type(cx, a, b, ckind)\n-                        })\n-                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output(), ckind)\n-                }\n-                (Tuple(a_substs), Tuple(b_substs)) => {\n-                    a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n-                        Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n-                    })\n-                }\n-                // For these, it's not quite as easy to define structural-sameness quite so easily.\n-                // For the purposes of this lint, take the conservative approach and mark them as\n-                // not structurally same.\n-                (Dynamic(..), Dynamic(..))\n-                | (Error(..), Error(..))\n-                | (Closure(..), Closure(..))\n-                | (Generator(..), Generator(..))\n-                | (GeneratorWitness(..), GeneratorWitness(..))\n-                | (Projection(..), Projection(..))\n-                | (Opaque(..), Opaque(..)) => false,\n-\n-                // These definitely should have been caught above.\n-                (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n-\n-                // An Adt and a primitive type. This can be FFI-safe is the ADT is an enum with a\n-                // non-null field.\n-                (Adt(..), other_kind) | (other_kind, Adt(..))\n-                    if is_primitive_or_pointer(other_kind) =>\n-                {\n-                    let (primitive, adt) =\n-                        if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n-                    if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n-                        ty == primitive\n-                    } else {\n-                        compare_layouts(a, b)\n-                    }\n+                                } else {\n+                                    unreachable!()\n+                                }\n+                            }\n+                            (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n+                                // For arrays, we also check the constness of the type.\n+                                a_const.val == b_const.val\n+                                    && structurally_same_type_impl(\n+                                        seen_types, cx, a_const.ty, b_const.ty, ckind,\n+                                    )\n+                                    && structurally_same_type_impl(\n+                                        seen_types, cx, a_ty, b_ty, ckind,\n+                                    )\n+                            }\n+                            (Slice(a_ty), Slice(b_ty)) => {\n+                                structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                            }\n+                            (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n+                                a_tymut.mutbl == b_tymut.mutbl\n+                                    && structurally_same_type_impl(\n+                                        seen_types,\n+                                        cx,\n+                                        &a_tymut.ty,\n+                                        &b_tymut.ty,\n+                                        ckind,\n+                                    )\n+                            }\n+                            (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n+                                // For structural sameness, we don't need the region to be same.\n+                                a_mut == b_mut\n+                                    && structurally_same_type_impl(\n+                                        seen_types, cx, a_ty, b_ty, ckind,\n+                                    )\n+                            }\n+                            (FnDef(..), FnDef(..)) => {\n+                                let a_poly_sig = a.fn_sig(tcx);\n+                                let b_poly_sig = b.fn_sig(tcx);\n+\n+                                // As we don't compare regions, skip_binder is fine.\n+                                let a_sig = a_poly_sig.skip_binder();\n+                                let b_sig = b_poly_sig.skip_binder();\n+\n+                                (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n+                                    == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n+                                    && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n+                                        structurally_same_type_impl(seen_types, cx, a, b, ckind)\n+                                    })\n+                                    && structurally_same_type_impl(\n+                                        seen_types,\n+                                        cx,\n+                                        a_sig.output(),\n+                                        b_sig.output(),\n+                                        ckind,\n+                                    )\n+                            }\n+                            (Tuple(a_substs), Tuple(b_substs)) => {\n+                                a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n+                                    structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                                })\n+                            }\n+                            // For these, it's not quite as easy to define structural-sameness quite so easily.\n+                            // For the purposes of this lint, take the conservative approach and mark them as\n+                            // not structurally same.\n+                            (Dynamic(..), Dynamic(..))\n+                            | (Error(..), Error(..))\n+                            | (Closure(..), Closure(..))\n+                            | (Generator(..), Generator(..))\n+                            | (GeneratorWitness(..), GeneratorWitness(..))\n+                            | (Projection(..), Projection(..))\n+                            | (Opaque(..), Opaque(..)) => false,\n+\n+                            // These definitely should have been caught above.\n+                            (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => {\n+                                unreachable!()\n+                            }\n+\n+                            // An Adt and a primitive type. This can be FFI-safe is the ADT is an enum with a\n+                            // non-null field.\n+                            (Adt(..), other_kind) | (other_kind, Adt(..))\n+                                if is_primitive_or_pointer(other_kind) =>\n+                            {\n+                                let (primitive, adt) =\n+                                    if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n+                                if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n+                                    ty == primitive\n+                                } else {\n+                                    compare_layouts(a, b)\n+                                }\n+                            }\n+                            // Otherwise, just compare the layouts. This may fail to lint for some\n+                            // incompatible types, but at the very least, will stop reads into\n+                            // uninitialised memory.\n+                            _ => compare_layouts(a, b),\n+                        }\n+                    };\n+                    seen_types.mark_computed(a, b, result);\n+                    result\n                 }\n-                // Otherwise, just compare the layouts. This may fail to lint for some\n-                // incompatible types, but at the very least, will stop reads into\n-                // uninitialised memory.\n-                _ => compare_layouts(a, b),\n             }\n         }\n+        let mut seen_types = SeenSet::new();\n+        structurally_same_type_impl(&mut seen_types, cx, a, b, ckind)\n     }\n }\n "}]}