{"sha": "ba39b50943aa55790f79ccdebc446b0f7e6d0d3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMzliNTA5NDNhYTU1NzkwZjc5Y2NkZWJjNDQ2YjBmN2U2ZDBkM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-28T18:36:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-28T18:36:29Z"}, "message": "auto merge of #16553 : nick29581/rust/log, r=huon\n\nWhen specifying RUST_LOG, the programmer may append `/regex` to the end of the spec. All results will then be filtered using that regex.\r\n\r\nr?", "tree": {"sha": "b1e687dba466c420457c13e294f01cd2722a129e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1e687dba466c420457c13e294f01cd2722a129e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f", "html_url": "https://github.com/rust-lang/rust/commit/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5165321e48c1fd8422803fb40693afab7939c8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5165321e48c1fd8422803fb40693afab7939c8c", "html_url": "https://github.com/rust-lang/rust/commit/b5165321e48c1fd8422803fb40693afab7939c8c"}, {"sha": "cc9b2b055093dae76a9c9b17063bba72a89c2648", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9b2b055093dae76a9c9b17063bba72a89c2648", "html_url": "https://github.com/rust-lang/rust/commit/cc9b2b055093dae76a9c9b17063bba72a89c2648"}], "stats": {"total": 151, "additions": 128, "deletions": 23}, "files": [{"sha": "f830e1a9d958519f1de323e4096dff5fe6fb2efb", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=ba39b50943aa55790f79ccdebc446b0f7e6d0d3f", "patch": "@@ -96,7 +96,7 @@ DEPS_test := std getopts serialize rbml term time regex native:rust_test_helpers\n DEPS_time := std serialize\n DEPS_rand := core\n DEPS_url := std\n-DEPS_log := std\n+DEPS_log := std regex\n DEPS_regex := std\n DEPS_regex_macros = rustc syntax std regex\n DEPS_fmt_macros = std"}, {"sha": "a93cf4c15682fd83ef0bfc8cb4ace3c0b8bde85a", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=ba39b50943aa55790f79ccdebc446b0f7e6d0d3f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use regex::Regex;\n use std::ascii::AsciiExt;\n use std::cmp;\n \n@@ -28,14 +29,23 @@ fn parse_log_level(level: &str) -> Option<u32> {\n     }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n }\n \n-/// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1\")\n+/// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1/foo\")\n /// and return a vector with log directives.\n ///\n /// Valid log levels are 0-255, with the most likely ones being 1-4 (defined in\n /// std::).  Also supports string log levels of error, warn, info, and debug\n-pub fn parse_logging_spec(spec: &str) -> Vec<LogDirective> {\n+pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<Regex>) {\n     let mut dirs = Vec::new();\n-    for s in spec.split(',') {\n+\n+    let mut parts = spec.split('/');\n+    let mods = parts.next();\n+    let filter = parts.next();\n+    if parts.next().is_some() {\n+        println!(\"warning: invalid logging spec '{}', \\\n+                 ignoring it (too many '/'s)\", spec);\n+        return (dirs, None);\n+    }\n+    mods.map(|m| { for s in m.split(',') {\n         if s.len() == 0 { continue }\n         let mut parts = s.split('=');\n         let (log_level, name) = match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n@@ -68,8 +78,19 @@ pub fn parse_logging_spec(spec: &str) -> Vec<LogDirective> {\n             name: name.map(|s| s.to_string()),\n             level: log_level,\n         });\n-    }\n-    return dirs;\n+    }});\n+\n+    let filter = filter.map_or(None, |filter| {\n+        match Regex::new(filter) {\n+            Ok(re) => Some(re),\n+            Err(e) => {\n+                println!(\"warning: invalid regex filter - {}\", e);\n+                None\n+            }\n+        }\n+    });\n+\n+    return (dirs, filter);\n }\n \n #[cfg(test)]\n@@ -78,7 +99,7 @@ mod tests {\n \n     #[test]\n     fn parse_logging_spec_valid() {\n-        let dirs = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 3);\n         assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n@@ -89,57 +110,99 @@ mod tests {\n \n         assert_eq!(dirs[2].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[2].level, 4);\n+        assert!(filter.is_none());\n     }\n \n     #[test]\n     fn parse_logging_spec_invalid_crate() {\n         // test parse_logging_spec with multiple = in specification\n-        let dirs = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, 4);\n+        assert!(filter.is_none());\n     }\n \n     #[test]\n     fn parse_logging_spec_invalid_log_level() {\n         // test parse_logging_spec with 'noNumber' as log level\n-        let dirs = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, 4);\n+        assert!(filter.is_none());\n     }\n \n     #[test]\n     fn parse_logging_spec_string_log_level() {\n         // test parse_logging_spec with 'warn' as log level\n-        let dirs = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, ::WARN);\n+        assert!(filter.is_none());\n     }\n \n     #[test]\n     fn parse_logging_spec_empty_log_level() {\n         // test parse_logging_spec with '' as log level\n-        let dirs = parse_logging_spec(\"crate1::mod1=wrong,crate2=\");\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=wrong,crate2=\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 1);\n         assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[0].level, ::MAX_LOG_LEVEL);\n+        assert!(filter.is_none());\n     }\n \n     #[test]\n     fn parse_logging_spec_global() {\n         // test parse_logging_spec with no crate\n-        let dirs = parse_logging_spec(\"warn,crate2=4\");\n+        let (dirs, filter) = parse_logging_spec(\"warn,crate2=4\");\n         let dirs = dirs.as_slice();\n         assert_eq!(dirs.len(), 2);\n         assert_eq!(dirs[0].name, None);\n         assert_eq!(dirs[0].level, 2);\n         assert_eq!(dirs[1].name, Some(\"crate2\".to_string()));\n         assert_eq!(dirs[1].level, 4);\n+        assert!(filter.is_none());\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_valid_filter() {\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4/abc\");\n+        let dirs = dirs.as_slice();\n+        assert_eq!(dirs.len(), 3);\n+        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n+        assert_eq!(dirs[0].level, 1);\n+\n+        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_string()));\n+        assert_eq!(dirs[1].level, ::MAX_LOG_LEVEL);\n+\n+        assert_eq!(dirs[2].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[2].level, 4);\n+        assert!(filter.is_some() && filter.unwrap().to_string().as_slice() == \"abc\");\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_invalid_crate_filter() {\n+        let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1=2,crate2=4/a.c\");\n+        let dirs = dirs.as_slice();\n+        assert_eq!(dirs.len(), 1);\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].level, 4);\n+        assert!(filter.is_some() && filter.unwrap().to_string().as_slice() == \"a.c\");\n+    }\n+\n+    #[test]\n+    fn parse_logging_spec_empty_with_filter() {\n+        let (dirs, filter) = parse_logging_spec(\"crate1/a*c\");\n+        let dirs = dirs.as_slice();\n+        assert_eq!(dirs.len(), 1);\n+        assert_eq!(dirs[0].name, Some(\"crate1\".to_string()));\n+        assert_eq!(dirs[0].level, ::MAX_LOG_LEVEL);\n+        assert!(filter.is_some() && filter.unwrap().to_string().as_slice() == \"a*c\");\n     }\n }"}, {"sha": "0bad742933b1c2739d20fb175011a1f8090d5b85", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 53, "deletions": 11, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba39b50943aa55790f79ccdebc446b0f7e6d0d3f/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=ba39b50943aa55790f79ccdebc446b0f7e6d0d3f", "patch": "@@ -80,14 +80,32 @@ all modules is set to this value.\n \n Some examples of valid values of `RUST_LOG` are:\n \n-```text\n-hello                // turns on all logging for the 'hello' module\n-info                 // turns on all info logging\n-hello=debug          // turns on debug logging for 'hello'\n-hello=3              // turns on info logging for 'hello'\n-hello,std::option    // turns on hello, and std's option logging\n-error,hello=warn     // turn on global error logging and also warn for hello\n-```\n+* `hello` turns on all logging for the 'hello' module\n+* `info` turns on all info logging\n+* `hello=debug` turns on debug logging for 'hello'\n+* `hello=3` turns on info logging for 'hello'\n+* `hello,std::option` turns on hello, and std's option logging\n+* `error,hello=warn` turn on global error logging and also warn for hello\n+\n+## Filtering results\n+\n+A RUST_LOG directive may include a regex filter. The syntax is to append `/`\n+followed by a regex. Each message is checked against the regex, and is only\n+logged if it matches. Note that the matching is done after formatting the log\n+string but before adding any logging meta-data. There is a single filter for all\n+modules.\n+\n+Some examples:\n+\n+* `hello/foo` turns on all logging for the 'hello' module where the log message\n+includes 'foo'.\n+* `info/f.o` turns on all info logging where the log message includes 'foo',\n+'f1o', 'fao', etc.\n+* `hello=debug/foo*foo` turns on debug logging for 'hello' where the the log\n+message includes 'foofoo' or 'fofoo' or 'fooooooofoo', etc.\n+* `error,hello=warn/[0-9] scopes` turn on global error logging and also warn for\n+ hello. In both cases the log message must include a single digit number\n+ followed by 'scopes'\n \n ## Performance and Side Effects\n \n@@ -117,6 +135,9 @@ if logging is disabled, none of the components of the log will be executed.\n #![feature(macro_rules)]\n #![deny(missing_doc)]\n \n+extern crate regex;\n+\n+use regex::Regex;\n use std::fmt;\n use std::io::LineBufferedWriter;\n use std::io;\n@@ -146,6 +167,9 @@ static mut LOG_LEVEL: u32 = MAX_LOG_LEVEL;\n static mut DIRECTIVES: *const Vec<directive::LogDirective> =\n     0 as *const Vec<directive::LogDirective>;\n \n+/// Optional regex filter.\n+static mut FILTER: *const Regex = 0 as *const _;\n+\n /// Debug log level\n pub static DEBUG: u32 = 4;\n /// Info log level\n@@ -222,6 +246,13 @@ impl Drop for DefaultLogger {\n /// invoked through the logging family of macros.\n #[doc(hidden)]\n pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n+    // Test the literal string from args against the current filter, if there\n+    // is one.\n+    match unsafe { FILTER.to_option() } {\n+        Some(filter) if filter.is_match(args.to_string().as_slice()) => return,\n+        _ => {}\n+    }\n+\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n@@ -321,9 +352,9 @@ fn enabled(level: u32,\n /// This is not threadsafe at all, so initialization os performed through a\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n-    let mut directives = match os::getenv(\"RUST_LOG\") {\n+    let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n         Some(spec) => directive::parse_logging_spec(spec.as_slice()),\n-        None => Vec::new(),\n+        None => (Vec::new(), None),\n     };\n \n     // Sort the provided directives by length of their name, this allows a\n@@ -342,15 +373,26 @@ fn init() {\n     unsafe {\n         LOG_LEVEL = max_level;\n \n+        assert!(FILTER.is_null());\n+        match filter {\n+            Some(f) => FILTER = mem::transmute(box f),\n+            None => {}\n+        }\n+\n         assert!(DIRECTIVES.is_null());\n         DIRECTIVES = mem::transmute(box directives);\n \n-        // Schedule the cleanup for this global for when the runtime exits.\n+        // Schedule the cleanup for the globals for when the runtime exits.\n         rt::at_exit(proc() {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n                 mem::transmute(DIRECTIVES);\n             DIRECTIVES = 0 as *const Vec<directive::LogDirective>;\n+\n+            if !FILTER.is_null() {\n+                let _filter: Box<Regex> = mem::transmute(FILTER);\n+                FILTER = 0 as *const _;\n+            }\n         });\n     }\n }"}]}