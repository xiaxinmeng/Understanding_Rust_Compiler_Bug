{"sha": "0eb56e60d212fb53dcb2e0c7c33a4539b9203428", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYjU2ZTYwZDIxMmZiNTNkY2IyZTBjN2MzM2E0NTM5YjkyMDM0Mjg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-09T13:06:06Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-09T13:06:06Z"}, "message": "Get rid of trans::iter_sequence, use tvec::iter_vec instead", "tree": {"sha": "1ccb96c4e49d81d2dc57c245338f8e565d2a64ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ccb96c4e49d81d2dc57c245338f8e565d2a64ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eb56e60d212fb53dcb2e0c7c33a4539b9203428", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb56e60d212fb53dcb2e0c7c33a4539b9203428", "html_url": "https://github.com/rust-lang/rust/commit/0eb56e60d212fb53dcb2e0c7c33a4539b9203428", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eb56e60d212fb53dcb2e0c7c33a4539b9203428/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fb3ec95e049f7af53e0ae280d966c469307bf92", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb3ec95e049f7af53e0ae280d966c469307bf92", "html_url": "https://github.com/rust-lang/rust/commit/9fb3ec95e049f7af53e0ae280d966c469307bf92"}], "stats": {"total": 112, "additions": 15, "deletions": 97}, "files": [{"sha": "0bc28ca617eeb8522446f121b847225ca02d9f47", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 15, "deletions": 97, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0eb56e60d212fb53dcb2e0c7c33a4539b9203428/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb56e60d212fb53dcb2e0c7c33a4539b9203428/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0eb56e60d212fb53dcb2e0c7c33a4539b9203428", "patch": "@@ -1744,90 +1744,6 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n     ret cx;\n }\n \n-\n-// Iterates through a pointer range, until the src* hits the src_lim*.\n-fn iter_sequence_raw(cx: @block_ctxt, dst: ValueRef, src: ValueRef,\n-                     src_lim: ValueRef, elt_sz: ValueRef, f: &val_pair_fn) ->\n-   @block_ctxt {\n-    let bcx = cx;\n-    let dst_int: ValueRef = vp2i(bcx, dst);\n-    let src_int: ValueRef = vp2i(bcx, src);\n-    let src_lim_int: ValueRef = vp2i(bcx, src_lim);\n-    let cond_cx = new_scope_block_ctxt(cx, \"sequence-iter cond\");\n-    let body_cx = new_scope_block_ctxt(cx, \"sequence-iter body\");\n-    let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    Br(bcx, cond_cx.llbb);\n-    let dst_curr: ValueRef = Phi(cond_cx, T_int(), [dst_int], [bcx.llbb]);\n-    let src_curr: ValueRef = Phi(cond_cx, T_int(), [src_int], [bcx.llbb]);\n-    let end_test =\n-        ICmp(cond_cx, lib::llvm::LLVMIntULT, src_curr, src_lim_int);\n-    CondBr(cond_cx, end_test, body_cx.llbb, next_cx.llbb);\n-    let dst_curr_ptr = vi2p(body_cx, dst_curr, T_ptr(T_i8()));\n-    let src_curr_ptr = vi2p(body_cx, src_curr, T_ptr(T_i8()));\n-    let body_cx = f(body_cx, dst_curr_ptr, src_curr_ptr);\n-    let dst_next = Add(body_cx, dst_curr, elt_sz);\n-    let src_next = Add(body_cx, src_curr, elt_sz);\n-    Br(body_cx, cond_cx.llbb);\n-    AddIncomingToPhi(dst_curr, [dst_next], [body_cx.llbb]);\n-    AddIncomingToPhi(src_curr, [src_next], [body_cx.llbb]);\n-    ret next_cx;\n-}\n-\n-fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef, src_lim: ValueRef,\n-                       elt_ty: &ty::t, f: &val_and_ty_fn) -> @block_ctxt {\n-    fn adaptor_fn(f: val_and_ty_fn, elt_ty: ty::t, cx: &@block_ctxt,\n-                  _dst: ValueRef, src: ValueRef) -> @block_ctxt {\n-        let ccx = bcx_ccx(cx);\n-        let sp = cx.sp;\n-        let llptrty =\n-          if check type_has_static_size(ccx, elt_ty) {\n-              let llty = type_of(ccx, sp, elt_ty);\n-              T_ptr(llty)\n-          }\n-          else { T_ptr(T_ptr(T_i8())) };\n-\n-        let p = PointerCast(cx, src, llptrty);\n-        ret f(cx, load_if_immediate(cx, p, elt_ty), elt_ty);\n-    }\n-    let elt_sz = size_of(cx, elt_ty);\n-    ret iter_sequence_raw(elt_sz.bcx, src, src, src_lim, elt_sz.val,\n-                          bind adaptor_fn(f, elt_ty, _, _, _));\n-}\n-\n-\n-// Iterates through the elements of a vec or str.\n-fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn) ->\n-   @block_ctxt {\n-    fn iter_sequence_body(bcx: @block_ctxt, v: ValueRef, elt_ty: ty::t,\n-                          f: &val_and_ty_fn, trailing_null: bool) ->\n-       @block_ctxt {\n-        let llunit_ty = type_of_or_i8(bcx, elt_ty);\n-        let p0 = tvec::get_dataptr(bcx, v, llunit_ty);\n-        let len = tvec::get_fill(bcx, v);\n-\n-        if trailing_null {\n-            let unit_sz = size_of(bcx, elt_ty);\n-            bcx = unit_sz.bcx;\n-            len = Sub(bcx, len, unit_sz.val);\n-        }\n-        let p1 = vi2p(bcx, Add(bcx, vp2i(bcx, p0), len), T_ptr(llunit_ty));\n-        ret iter_sequence_inner(bcx, p0, p1, elt_ty, f);\n-    }\n-\n-\n-    alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_vec(elt) { ret iter_sequence_body(cx, v, elt.ty, f, false); }\n-      ty::ty_str. {\n-        let et = ty::mk_mach(bcx_tcx(cx), ast::ty_u8);\n-        ret iter_sequence_body(cx, v, et, f, true);\n-      }\n-      _ {\n-        bcx_ccx(cx).sess.bug(\"unexpected type in trans::iter_sequence: \" +\n-                                 ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n-      }\n-    }\n-}\n-\n fn lazily_emit_all_tydesc_glue(cx: &@block_ctxt,\n                                static_ti: &option::t<@tydesc_info>) {\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, static_ti);\n@@ -2559,8 +2475,6 @@ fn trans_if(cx: &@block_ctxt, cond: &@ast::expr, thn: &ast::blk,\n \n fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n              body: &ast::blk) -> result {\n-    // FIXME: We bind to an alias here to avoid a segfault... this is\n-    // obviously a bug.\n     fn inner(cx: &@block_ctxt, local: @ast::local, curr: ValueRef, t: ty::t,\n              body: &ast::blk, outer_next_cx: @block_ctxt) -> @block_ctxt {\n         let next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -2569,13 +2483,13 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n                                       option::some::<@block_ctxt>(next_cx),\n                                       outer_next_cx, \"for loop scope\");\n         Br(cx, scope_cx.llbb);\n-        let local_res = alloc_local(scope_cx, local);\n-        let bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t);\n-        add_clean(scope_cx, local_res.val, t);\n-        let bcx =\n-            trans_alt::bind_irrefutable_pat(bcx, local.node.pat,\n-                                            local_res.val, cx.fcx.lllocals,\n-                                            false);\n+        let {bcx, val: dst} = alloc_local(scope_cx, local);\n+        let val = load_if_immediate(bcx, PointerCast(bcx, curr,\n+                                                     val_ty(dst)), t);\n+        let bcx = copy_val(bcx, INIT, dst, val, t);\n+        add_clean(scope_cx, dst, t);\n+        let bcx = trans_alt::bind_irrefutable_pat(bcx, local.node.pat, dst,\n+                                                  cx.fcx.lllocals, false);\n         bcx = trans_block(bcx, body, return).bcx;\n         if !is_terminated(bcx) {\n             Br(bcx, next_cx.llbb);\n@@ -2585,10 +2499,14 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     }\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let seq_ty = ty::expr_ty(bcx_tcx(cx), seq);\n-    let seq_res = trans_expr(cx, seq);\n-    let bcx =\n-        iter_sequence(seq_res.bcx, seq_res.val, seq_ty,\n-                      bind inner(_, local, _, _, body, next_cx));\n+    let {bcx, val: seq} = trans_expr(cx, seq);\n+    let seq = PointerCast(bcx, seq, T_ptr(T_ptr(T_opaque_vec())));\n+    let fill = tvec::get_fill(bcx, seq);\n+    if ty::type_is_str(bcx_tcx(bcx), seq_ty) {\n+        fill = Sub(bcx, fill, C_int(1));\n+    }\n+    let bcx = tvec::iter_vec_raw(bcx, seq, seq_ty, fill,\n+                                 bind inner(_, local, _, _, body, next_cx));\n     Br(bcx, next_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }"}]}