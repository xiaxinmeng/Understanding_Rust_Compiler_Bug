{"sha": "5a28d178afcecfb6d2231bb461c5a66864c50f0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMjhkMTc4YWZjZWNmYjZkMjIzMWJiNDYxYzVhNjY4NjRjNTBmMGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-15T22:25:05Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-18T17:32:38Z"}, "message": "Allow impl's to have late-bound regions. Introduces another level of\nregion binding at the impl site, so for method types that come from impls,\nit is necessary to liberate/instantiate late-bound regions at multiple\ndepths.", "tree": {"sha": "39573028b7601a8acc4866a8579991bf619ab774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39573028b7601a8acc4866a8579991bf619ab774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a28d178afcecfb6d2231bb461c5a66864c50f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a28d178afcecfb6d2231bb461c5a66864c50f0d", "html_url": "https://github.com/rust-lang/rust/commit/5a28d178afcecfb6d2231bb461c5a66864c50f0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a28d178afcecfb6d2231bb461c5a66864c50f0d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fb68f1c813657f0fe6b43be008480822767b891", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fb68f1c813657f0fe6b43be008480822767b891", "html_url": "https://github.com/rust-lang/rust/commit/6fb68f1c813657f0fe6b43be008480822767b891"}], "stats": {"total": 990, "additions": 729, "deletions": 261}, "files": [{"sha": "a1257caf47ffaa09b6602786ca123e9a265c77dc", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -105,15 +105,21 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             ast::ItemTy(_, ref generics) |\n             ast::ItemEnum(_, ref generics) |\n             ast::ItemStruct(_, ref generics) |\n-            ast::ItemTrait(ref generics, _, _, _) |\n-            ast::ItemImpl(ref generics, _, _, _) => {\n+            ast::ItemTrait(ref generics, _, _, _) => {\n                 // These kinds of items have only early bound lifetime parameters.\n                 let lifetimes = &generics.lifetimes;\n                 self.with(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE), |this| {\n                     this.check_lifetime_defs(lifetimes);\n                     visit::walk_item(this, item);\n                 });\n             }\n+            ast::ItemImpl(ref generics, _, _, _) => {\n+                // Impls have both early- and late-bound lifetimes.\n+                self.visit_early_late(subst::TypeSpace, generics, |this| {\n+                    this.check_lifetime_defs(&generics.lifetimes);\n+                    visit::walk_item(this, item);\n+                })\n+            }\n         }\n     }\n \n@@ -493,10 +499,10 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n             FreeLifetimeCollector { early_bound: &mut early_bound,\n                                     late_bound: &mut late_bound };\n         for ty_param in generics.ty_params.iter() {\n-            visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds);\n+            visit::walk_ty_param_bounds_helper(&mut collector, &ty_param.bounds);\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            visit::walk_ty_param_bounds(&mut collector, &predicate.bounds);\n+            visit::walk_ty_param_bounds_helper(&mut collector, &predicate.bounds);\n         }\n     }\n "}, {"sha": "4fabdabf3db4bba35d2ff3f8b10e48ba8d3114ec", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -100,6 +100,17 @@ impl Substs {\n         regions_is_noop && self.types.is_empty()\n     }\n \n+    pub fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.types.iter().any(|&t| ty::type_escapes_depth(t, depth)) || {\n+            match self.regions {\n+                ErasedRegions =>\n+                    false,\n+                NonerasedRegions(ref regions) =>\n+                    regions.iter().any(|r| r.escapes_depth(depth)),\n+            }\n+        }\n+    }\n+\n     pub fn self_ty(&self) -> Option<ty::t> {\n         self.types.get_self().map(|&t| t)\n     }\n@@ -165,6 +176,13 @@ impl RegionSubsts {\n             NonerasedRegions(r) => NonerasedRegions(op(r, a))\n         }\n     }\n+\n+    pub fn is_erased(&self) -> bool {\n+        match *self {\n+            ErasedRegions => true,\n+            NonerasedRegions(_) => false,\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -391,6 +409,10 @@ impl<T> VecPerParamSpace<T> {\n         self.content.iter()\n     }\n \n+    pub fn iter_enumerated<'a>(&'a self) -> EnumeratedItems<'a,T> {\n+        EnumeratedItems::new(self)\n+    }\n+\n     pub fn as_slice(&self) -> &[T] {\n         self.content.as_slice()\n     }\n@@ -420,6 +442,14 @@ impl<T> VecPerParamSpace<T> {\n                                        self.assoc_limit)\n     }\n \n+    pub fn map_enumerated<U>(&self, pred: |(ParamSpace, uint, &T)| -> U) -> VecPerParamSpace<U> {\n+        let result = self.iter_enumerated().map(pred).collect();\n+        VecPerParamSpace::new_internal(result,\n+                                       self.type_limit,\n+                                       self.self_limit,\n+                                       self.assoc_limit)\n+    }\n+\n     pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n         let SeparateVecsPerParamSpace {\n             types: t,\n@@ -456,6 +486,49 @@ impl<T> VecPerParamSpace<T> {\n     }\n }\n \n+pub struct EnumeratedItems<'a,T:'a> {\n+    vec: &'a VecPerParamSpace<T>,\n+    space_index: uint,\n+    elem_index: uint\n+}\n+\n+impl<'a,T> EnumeratedItems<'a,T> {\n+    fn new(v: &'a VecPerParamSpace<T>) -> EnumeratedItems<'a,T> {\n+        let mut result = EnumeratedItems { vec: v, space_index: 0, elem_index: 0 };\n+        result.adjust_space();\n+        result\n+    }\n+\n+    fn adjust_space(&mut self) {\n+        let spaces = ParamSpace::all();\n+        while\n+            self.space_index < spaces.len() &&\n+            self.elem_index >= self.vec.len(spaces[self.space_index])\n+        {\n+            self.space_index += 1;\n+            self.elem_index = 0;\n+        }\n+    }\n+}\n+\n+impl<'a,T> Iterator<(ParamSpace, uint, &'a T)> for EnumeratedItems<'a,T> {\n+    fn next(&mut self) -> Option<(ParamSpace, uint, &'a T)> {\n+        let spaces = ParamSpace::all();\n+        if self.space_index < spaces.len() {\n+            let space = spaces[self.space_index];\n+            let index = self.elem_index;\n+            let item = self.vec.get(space, index);\n+\n+            self.elem_index += 1;\n+            self.adjust_space();\n+\n+            Some((space, index, item))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //\n@@ -485,7 +558,8 @@ impl<T:TypeFoldable> Subst for T {\n                                        substs: substs,\n                                        span: span,\n                                        root_ty: None,\n-                                       ty_stack_depth: 0 };\n+                                       ty_stack_depth: 0,\n+                                       region_binders_passed: 0 };\n         (*self).fold_with(&mut folder)\n     }\n }"}, {"sha": "405f6509e596d5b3b13b1432d22d892144cd1f2e", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -17,7 +17,7 @@ use super::util;\n use middle::subst;\n use middle::subst::Subst;\n use middle::ty;\n-use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::{mod, InferCtxt};\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use util::ppaux::Repr;\n@@ -38,14 +38,18 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n         util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n     let impl1_trait_ref =\n         ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()\n-            .subst(infcx.tcx, &impl1_substs);\n+                                                   .subst(infcx.tcx, &impl1_substs);\n+    let impl1_trait_ref =\n+        infcx.replace_late_bound_regions_with_fresh_var(DUMMY_SP,\n+                                                        infer::FnCall,\n+                                                        &impl1_trait_ref).0;\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n     let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n     let obligation = Obligation::misc(DUMMY_SP, impl1_trait_ref);\n-    debug!(\"impl_can_satisfy obligation={}\", obligation.repr(infcx.tcx));\n+    debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)\n }\n "}, {"sha": "c9c9e3bd4ffdc1df9d459e82586729ae9c6ada6a", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -281,33 +281,28 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n     coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n }\n \n-pub fn impl_obligations(tcx: &ty::ctxt,\n-                        cause: ObligationCause,\n-                        impl_def_id: ast::DefId,\n-                        impl_substs: &subst::Substs)\n-                        -> subst::VecPerParamSpace<Obligation>\n-{\n-    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n-    obligations_for_generics(tcx, cause, &impl_generics, impl_substs)\n-}\n-\n pub fn obligations_for_generics(tcx: &ty::ctxt,\n                                 cause: ObligationCause,\n-                                generics: &ty::Generics,\n-                                substs: &subst::Substs)\n+                                generic_bounds: &ty::GenericBounds,\n+                                type_substs: &subst::VecPerParamSpace<ty::t>)\n                                 -> subst::VecPerParamSpace<Obligation>\n {\n     /*!\n-     * Given generics for an impl like:\n+     * Given generic bounds from an impl like:\n      *\n      *    impl<A:Foo, B:Bar+Qux> ...\n      *\n-     * and a substs vector like `<A=A0, B=B0>`, yields a result like\n+     * along with the bindings for the types `A` and `B` (e.g.,\n+     * `<A=A0, B=B0>`), yields a result like\n      *\n      *    [[Foo for A0, Bar for B0, Qux for B0], [], []]\n+     *\n+     * Expects that `generic_bounds` have already been fully\n+     * substituted, late-bound regions liberated and so forth,\n+     * so that they are in the same namespace as `type_substs`.\n      */\n \n-    util::obligations_for_generics(tcx, cause, 0, generics, substs)\n+    util::obligations_for_generics(tcx, cause, 0, generic_bounds, type_substs)\n }\n \n pub fn obligation_for_builtin_bound(tcx: &ty::ctxt,"}, {"sha": "a941d2b079e21250411df2891cab723d9e838247", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -2017,10 +2017,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         impl_substs: &Substs)\n                         -> VecPerParamSpace<Obligation>\n     {\n-        let impl_generics = ty::lookup_item_type(self.tcx(),\n-                                                 impl_def_id).generics;\n+        let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n+        let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n         util::obligations_for_generics(self.tcx(), cause, recursion_depth,\n-                                       &impl_generics, impl_substs)\n+                                       &bounds, &impl_substs.types)\n     }\n }\n "}, {"sha": "8f8203f0281b1735b6345f5f903d28f09850b1bd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -10,7 +10,7 @@\n // except according to those terms.\n \n use middle::subst;\n-use middle::subst::{ParamSpace, Subst, Substs, VecPerParamSpace};\n+use middle::subst::{ParamSpace, Substs, VecPerParamSpace};\n use middle::typeck::infer::InferCtxt;\n use middle::ty;\n use std::collections::HashSet;\n@@ -173,25 +173,25 @@ impl fmt::Show for VtableParamData {\n pub fn obligations_for_generics(tcx: &ty::ctxt,\n                                 cause: ObligationCause,\n                                 recursion_depth: uint,\n-                                generics: &ty::Generics,\n-                                substs: &Substs)\n+                                generic_bounds: &ty::GenericBounds,\n+                                type_substs: &VecPerParamSpace<ty::t>)\n                                 -> VecPerParamSpace<Obligation>\n {\n     /*! See `super::obligations_for_generics` */\n \n-    debug!(\"obligations_for_generics(generics={}, substs={})\",\n-           generics.repr(tcx), substs.repr(tcx));\n+    debug!(\"obligations_for_generics(generic_bounds={}, type_substs={})\",\n+           generic_bounds.repr(tcx), type_substs.repr(tcx));\n \n     let mut obligations = VecPerParamSpace::empty();\n \n-    for def in generics.types.iter() {\n+    for (space, index, bounds) in generic_bounds.types.iter_enumerated() {\n         push_obligations_for_param_bounds(tcx,\n                                           cause,\n                                           recursion_depth,\n-                                          def.space,\n-                                          def.index,\n-                                          &def.bounds,\n-                                          substs,\n+                                          space,\n+                                          index,\n+                                          bounds,\n+                                          type_substs,\n                                           &mut obligations);\n     }\n \n@@ -207,11 +207,10 @@ fn push_obligations_for_param_bounds(\n     space: subst::ParamSpace,\n     index: uint,\n     param_bounds: &ty::ParamBounds,\n-    param_substs: &Substs,\n+    param_type_substs: &VecPerParamSpace<ty::t>,\n     obligations: &mut VecPerParamSpace<Obligation>)\n {\n-    let param_ty = *param_substs.types.get(space, index);\n-\n+    let param_ty = *param_type_substs.get(space, index);\n     for builtin_bound in param_bounds.builtin_bounds.iter() {\n         let obligation = obligation_for_builtin_bound(tcx,\n                                                       cause,\n@@ -225,12 +224,11 @@ fn push_obligations_for_param_bounds(\n     }\n \n     for bound_trait_ref in param_bounds.trait_bounds.iter() {\n-        let bound_trait_ref = bound_trait_ref.subst(tcx, param_substs);\n         obligations.push(\n             space,\n             Obligation { cause: cause,\n                          recursion_depth: recursion_depth,\n-                         trait_ref: bound_trait_ref });\n+                         trait_ref: (*bound_trait_ref).clone() });\n     }\n }\n "}, {"sha": "9f90afa37490c6e37d9f9dd7e30f93618eb02f71", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -1409,6 +1409,52 @@ impl Generics {\n     pub fn has_region_params(&self, space: subst::ParamSpace) -> bool {\n         !self.regions.is_empty_in(space)\n     }\n+\n+    pub fn to_bounds(&self, tcx: &ty::ctxt, substs: &Substs) -> GenericBounds {\n+        GenericBounds {\n+            types: self.types.map(|d| d.bounds.subst(tcx, substs)),\n+            regions: self.regions.map(|d| d.bounds.subst(tcx, substs)),\n+        }\n+    }\n+}\n+\n+/**\n+ * Represents the bounds declared on a particular set of type\n+ * parameters.  Should eventually be generalized into a flag list of\n+ * where clauses.  You can obtain a `GenericBounds` list from a\n+ * `Generics` by using the `to_bounds` method. Note that this method\n+ * reflects an important semantic invariant of `GenericBounds`: while\n+ * the bounds in a `Generics` are expressed in terms of the bound type\n+ * parameters of the impl/trait/whatever, a `GenericBounds` instance\n+ * represented a set of bounds for some particular instantiation,\n+ * meaning that the generic parameters have been substituted with\n+ * their values.\n+ *\n+ * Example:\n+ *\n+ *     struct Foo<T,U:Bar<T>> { ... }\n+ *\n+ * Here, the `Generics` for `Foo` would contain a list of bounds like\n+ * `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n+ * like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n+ * [uint:Bar<int>]]`.\n+ */\n+#[deriving(Clone, Show)]\n+pub struct GenericBounds {\n+    pub types: VecPerParamSpace<ParamBounds>,\n+    pub regions: VecPerParamSpace<Vec<Region>>,\n+}\n+\n+impl GenericBounds {\n+    pub fn empty() -> GenericBounds {\n+        GenericBounds { types: VecPerParamSpace::empty(),\n+                        regions: VecPerParamSpace::empty() }\n+    }\n+\n+    pub fn has_escaping_regions(&self) -> bool {\n+        self.types.any(|pb| pb.trait_bounds.iter().any(|tr| tr.has_escaping_regions())) ||\n+            self.regions.any(|rs| rs.iter().any(|r| r.escapes_depth(0)))\n+    }\n }\n \n impl TraitRef {\n@@ -5632,11 +5678,13 @@ pub fn construct_parameter_environment(\n     // Compute the bounds on Self and the type parameters.\n     //\n \n-    let mut bounds = VecPerParamSpace::empty();\n-    for &space in subst::ParamSpace::all().iter() {\n-        push_bounds_from_defs(tcx, &mut bounds, space, &free_substs,\n-                              generics.types.get_slice(space));\n-    }\n+    let bounds = generics.to_bounds(tcx, &free_substs);\n+    let bounds = liberate_late_bound_regions(tcx, free_id, &bind(bounds)).value;\n+    let obligations = traits::obligations_for_generics(tcx,\n+                                                       traits::ObligationCause::misc(span),\n+                                                       &bounds,\n+                                                       &free_substs.types);\n+    let type_bounds = bounds.types.subst(tcx, &free_substs);\n \n     //\n     // Compute region bounds. For now, these relations are stored in a\n@@ -5645,24 +5693,20 @@ pub fn construct_parameter_environment(\n     //\n \n     for &space in subst::ParamSpace::all().iter() {\n-        record_region_bounds_from_defs(tcx, space, &free_substs,\n-                                       generics.regions.get_slice(space));\n+        record_region_bounds(tcx, space, &free_substs, bounds.regions.get_slice(space));\n     }\n \n \n-    debug!(\"construct_parameter_environment: free_id={} \\\n-           free_subst={} \\\n-           bounds={}\",\n+    debug!(\"construct_parameter_environment: free_id={} free_subst={} \\\n+           obligations={} type_bounds={}\",\n            free_id,\n            free_substs.repr(tcx),\n-           bounds.repr(tcx));\n-\n-    let obligations = traits::obligations_for_generics(tcx, traits::ObligationCause::misc(span),\n-                                                       generics, &free_substs);\n+           obligations.repr(tcx),\n+           type_bounds.repr(tcx));\n \n     return ty::ParameterEnvironment {\n         free_substs: free_substs,\n-        bounds: bounds,\n+        bounds: bounds.types,\n         implicit_region_bound: ty::ReScope(free_id),\n         caller_obligations: obligations,\n         selection_cache: traits::SelectionCache::new(),\n@@ -5693,28 +5737,16 @@ pub fn construct_parameter_environment(\n         }\n     }\n \n-    fn push_bounds_from_defs(tcx: &ty::ctxt,\n-                             bounds: &mut subst::VecPerParamSpace<ParamBounds>,\n-                             space: subst::ParamSpace,\n-                             free_substs: &subst::Substs,\n-                             defs: &[TypeParameterDef]) {\n-        for def in defs.iter() {\n-            let b = def.bounds.subst(tcx, free_substs);\n-            bounds.push(space, b);\n-        }\n-    }\n-\n-    fn record_region_bounds_from_defs(tcx: &ty::ctxt,\n-                                      space: subst::ParamSpace,\n-                                      free_substs: &subst::Substs,\n-                                      defs: &[RegionParameterDef]) {\n-        for (subst_region, def) in\n+    fn record_region_bounds(tcx: &ty::ctxt,\n+                            space: subst::ParamSpace,\n+                            free_substs: &Substs,\n+                            bound_sets: &[Vec<ty::Region>]) {\n+        for (subst_region, bound_set) in\n             free_substs.regions().get_slice(space).iter().zip(\n-                defs.iter())\n+                bound_sets.iter())\n         {\n             // For each region parameter 'subst...\n-            let bounds = def.bounds.subst(tcx, free_substs);\n-            for bound_region in bounds.iter() {\n+            for bound_region in bound_set.iter() {\n                 // Which is declared with a bound like 'subst:'bound...\n                 match (subst_region, bound_region) {\n                     (&ty::ReFree(subst_fr), &ty::ReFree(bound_fr)) => {\n@@ -5725,7 +5757,7 @@ pub fn construct_parameter_environment(\n                     _ => {\n                         // All named regions are instantiated with free regions.\n                         tcx.sess.bug(\n-                            format!(\"push_region_bounds_from_defs: \\\n+                            format!(\"record_region_bounds: \\\n                                      non free region: {} / {}\",\n                                     subst_region.repr(tcx),\n                                     bound_region.repr(tcx)).as_slice());"}, {"sha": "4dfee673bca16c24d70446e4cf5c261de28a15da", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -410,6 +410,15 @@ impl TypeFoldable for ty::Generics {\n     }\n }\n \n+impl TypeFoldable for ty::GenericBounds {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds {\n+        ty::GenericBounds {\n+            types: self.types.fold_with(folder),\n+            regions: self.regions.fold_with(folder),\n+        }\n+    }\n+}\n+\n impl TypeFoldable for ty::UnsizeKind {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind {\n         match *self {"}, {"sha": "b4d22f117d4b7f2e0659ad34664bcf435c0cc51a", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "modified", "additions": 103, "deletions": 24, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -20,6 +20,7 @@ use middle::typeck::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n                      MethodParam, MethodStatic, MethodTraitObject, MethodTypeParam};\n use middle::typeck::infer;\n use middle::typeck::infer::InferCtxt;\n+use middle::ty_fold::HigherRankedFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n use std::rc::Rc;\n@@ -32,6 +33,27 @@ struct ConfirmContext<'a, 'tcx:'a> {\n     self_expr: &'a ast::Expr,\n }\n \n+struct InstantiatedMethodSig {\n+    /// Function signature of the method being invoked. The 0th\n+    /// argument is the receiver.\n+    method_sig: ty::FnSig,\n+\n+    /// Substitutions for all types/early-bound-regions declared on\n+    /// the method.\n+    all_substs: subst::Substs,\n+\n+    /// Substitution to use when adding obligations from the method\n+    /// bounds. Normally equal to `all_substs` except for object\n+    /// receivers. See FIXME in instantiate_method_sig() for\n+    /// explanation.\n+    method_bounds_substs: subst::Substs,\n+\n+    /// Generic bounds on the method's parameters which must be added\n+    /// as pending obligations.\n+    method_bounds: ty::GenericBounds,\n+}\n+\n+\n pub fn confirm(fcx: &FnCtxt,\n                span: Span,\n                self_expr: &ast::Expr,\n@@ -79,14 +101,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         debug!(\"all_substs={}\", all_substs.repr(self.tcx()));\n \n         // Create the final signature for the method, replacing late-bound regions.\n-        let method_sig = self.instantiate_method_sig(&pick, &all_substs);\n+        let InstantiatedMethodSig {\n+            method_sig, all_substs, method_bounds_substs, method_bounds\n+        } = self.instantiate_method_sig(&pick, all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(&pick, &all_substs);\n+        self.add_obligations(&pick, &method_bounds_substs, &method_bounds);\n \n         // Create the final `MethodCallee`.\n         let fty = ty::mk_bare_fn(self.tcx(), ty::BareFnTy {\n@@ -176,6 +200,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n          * where all type and region parameters are instantiated with\n          * fresh variables. This substitution does not include any\n          * parameters declared on the method itself.\n+         *\n+         * Note that this substitution may include late-bound regions\n+         * from the impl level. If so, these are instantiated later in\n+         * the `instantiate_method_sig` routine.\n          */\n \n         match pick.kind {\n@@ -354,20 +382,34 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick,\n-                              all_substs: &subst::Substs)\n-                              -> ty::FnSig\n+                              all_substs: subst::Substs)\n+                              -> InstantiatedMethodSig\n     {\n-        let ref bare_fn_ty = pick.method_ty.fty;\n-        let fn_sig = bare_fn_ty.sig.subst(self.tcx(), all_substs);\n-        self.infcx().replace_late_bound_regions_with_fresh_var(fn_sig.binder_id,\n-                                                               self.span,\n-                                                               infer::FnCall,\n-                                                               &fn_sig).0\n-    }\n-\n-    fn add_obligations(&mut self,\n-                       pick: &probe::Pick,\n-                       all_substs: &subst::Substs) {\n+        // If this method comes from an impl (as opposed to a trait),\n+        // it may have late-bound regions from the impl that appear in\n+        // the substitutions, method signature, and\n+        // bounds. Instantiate those at this point. (If it comes from\n+        // a trait, this step has no effect, as there are no\n+        // late-bound regions to instantiate.)\n+        //\n+        // The binder level here corresponds to the impl.\n+        let (all_substs, (method_sig, method_generics)) =\n+            self.replace_late_bound_regions_with_fresh_var(\n+                &ty::bind((all_substs,\n+                           (pick.method_ty.fty.sig.clone(),\n+                            pick.method_ty.generics.clone())))).value;\n+\n+        debug!(\"late-bound lifetimes from impl instantiated, \\\n+                all_substs={} method_sig={} method_generics={}\",\n+               all_substs.repr(self.tcx()),\n+               method_sig.repr(self.tcx()),\n+               method_generics.repr(self.tcx()));\n+\n+        // Instantiate the bounds on the method with the\n+        // type/early-bound-regions substitutions performed.  The only\n+        // late-bound-regions that can appear in bounds are from the\n+        // impl, and those were already instantiated above.\n+        //\n         // FIXME(DST). Super hack. For a method on a trait object\n         // `Trait`, the generic signature requires that\n         // `Self:Trait`. Since, for an object, we bind `Self` to the\n@@ -381,24 +423,54 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // obligations.  This causes us to generate the obligation\n         // `err:Trait`, and the error type is considered to implement\n         // all traits, so we're all good. Hack hack hack.\n-        match pick.kind {\n+        let method_bounds_substs = match pick.kind {\n             probe::ObjectPick(..) => {\n                 let mut temp_substs = all_substs.clone();\n                 temp_substs.types.get_mut_slice(subst::SelfSpace)[0] = ty::mk_err();\n-                self.fcx.add_obligations_for_parameters(\n-                    traits::ObligationCause::misc(self.span),\n-                    &temp_substs,\n-                    &pick.method_ty.generics);\n+                temp_substs\n             }\n             _ => {\n-                self.fcx.add_obligations_for_parameters(\n-                    traits::ObligationCause::misc(self.span),\n-                    all_substs,\n-                    &pick.method_ty.generics);\n+                all_substs.clone()\n             }\n+        };\n+        let method_bounds =\n+            method_generics.to_bounds(self.tcx(), &method_bounds_substs);\n+\n+        debug!(\"method_bounds after subst = {}\",\n+               method_bounds.repr(self.tcx()));\n+\n+        // Substitute the type/early-bound-regions into the method\n+        // signature. In addition, the method signature may bind\n+        // late-bound regions, so instantiate those.\n+        let method_sig = method_sig.subst(self.tcx(), &all_substs);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&method_sig);\n+\n+        debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n+               method_sig.repr(self.tcx()));\n+\n+        InstantiatedMethodSig {\n+            method_sig: method_sig,\n+            all_substs: all_substs,\n+            method_bounds_substs: method_bounds_substs,\n+            method_bounds: method_bounds,\n         }\n     }\n \n+    fn add_obligations(&mut self,\n+                       pick: &probe::Pick,\n+                       method_bounds_substs: &subst::Substs,\n+                       method_bounds: &ty::GenericBounds) {\n+        debug!(\"add_obligations: pick={} method_bounds_substs={} method_bounds={}\",\n+               pick.repr(self.tcx()),\n+               method_bounds_substs.repr(self.tcx()),\n+               method_bounds.repr(self.tcx()));\n+\n+        self.fcx.add_obligations_for_parameters(\n+            traits::ObligationCause::misc(self.span),\n+            method_bounds_substs,\n+            method_bounds);\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // RECONCILIATION\n \n@@ -591,6 +663,13 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     source_trait_ref.repr(self.tcx()),\n                     target_trait_def_id.repr(self.tcx()))[]);\n     }\n+\n+    fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &T) -> T\n+        where T : HigherRankedFoldable\n+    {\n+        self.infcx().replace_late_bound_regions_with_fresh_var(\n+            self.span, infer::FnCall, value).0\n+    }\n }\n \n fn wrap_autoref(mut deref: ty::AutoDerefRef,"}, {"sha": "6c7df2cd07ed2a17c0d34951a7fa09fd01ad9e52", "filename": "src/librustc/middle/typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -200,10 +200,12 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Substitute the trait parameters into the method type and\n     // instantiate late-bound regions to get the actual method type.\n+    //\n+    // Note that as the method comes from a trait, it can only have\n+    // late-bound regions from the fn itself, not the impl.\n     let ref bare_fn_ty = method_ty.fty;\n     let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n-    let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(fn_sig.binder_id,\n-                                                                       span,\n+    let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n                                                                        &fn_sig).0;\n     let transformed_self_ty = fn_sig.inputs[0];\n@@ -222,10 +224,15 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     // so this also effectively registers `obligation` as well.  (We\n     // used to register `obligation` explicitly, but that resulted in\n     // double error messages being reported.)\n+    //\n+    // Note that as the method comes from a trait, it should not have\n+    // any late-bound regions appearing in its bounds.\n+    let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), &trait_ref.substs);\n+    assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::misc(span),\n         &trait_ref.substs,\n-        &method_ty.generics);\n+        &method_bounds);\n \n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid"}, {"sha": "f9c3fa86752ea03cdf905047d45c061b18468ca2", "filename": "src/librustc/middle/typeck/check/method/probe.rs", "status": "modified", "additions": 95, "deletions": 24, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -17,6 +17,7 @@ use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n use middle::ty;\n+use middle::ty_fold::HigherRankedFoldable;\n use middle::typeck::check;\n use middle::typeck::check::{FnCtxt, NoPreference};\n use middle::typeck::{MethodObject};\n@@ -257,29 +258,28 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), def_id);\n \n         for impl_infos in self.tcx().inherent_impls.borrow().get(&def_id).iter() {\n-            for &impl_did in impl_infos.iter() {\n-                self.assemble_inherent_impl_probe(impl_did);\n+            for &impl_def_id in impl_infos.iter() {\n+                self.assemble_inherent_impl_probe(impl_def_id);\n             }\n         }\n     }\n \n-    fn assemble_inherent_impl_probe(&mut self, impl_did: ast::DefId) {\n-        if !self.impl_dups.insert(impl_did) {\n+    fn assemble_inherent_impl_probe(&mut self, impl_def_id: ast::DefId) {\n+        if !self.impl_dups.insert(impl_def_id) {\n             return; // already visited\n         }\n \n-        let method = match impl_method(self.tcx(), impl_did, self.method_name) {\n+        let method = match impl_method(self.tcx(), impl_def_id, self.method_name) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n         };\n \n         if !self.has_applicable_self(&*method) {\n             // No receiver declared. Not a candidate.\n-            return self.record_static_candidate(ImplSource(impl_did));\n+            return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        let impl_pty = check::impl_self_ty(self.fcx, self.span, impl_did);\n-        let impl_substs = impl_pty.substs;\n+        let impl_substs = self.impl_substs(impl_def_id);\n \n         // Determine the receiver type that the method itself expects.\n         let xform_self_ty =\n@@ -288,7 +288,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n             method_ty: method,\n-            kind: InherentImplCandidate(impl_did, impl_substs)\n+            kind: InherentImplCandidate(impl_def_id, impl_substs)\n         });\n     }\n \n@@ -496,8 +496,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 continue;\n             }\n \n-            let impl_pty = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n-            let impl_substs = impl_pty.substs;\n+            let impl_substs = self.impl_substs(impl_def_id);\n \n             debug!(\"impl_substs={}\", impl_substs.repr(self.tcx()));\n \n@@ -675,7 +674,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                            mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n                            -> Option<PickResult>\n     {\n-        let region = self.infcx().next_region_var(infer::Autoref(self.span));\n+        // In general, during probing we erase regions. See\n+        // `impl_self_ty()` for an explanation.\n+        let region = ty::ReStatic;\n \n         // Search through mutabilities in order to find one where pick works:\n         [ast::MutImmutable, ast::MutMutable]\n@@ -746,6 +747,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                probe.repr(self.tcx()));\n \n         self.infcx().probe(|| {\n+            // First check that the self type can be related.\n             match self.make_sub_ty(self_ty, probe.xform_self_ty) {\n                 Ok(()) => { }\n                 Err(_) => {\n@@ -754,23 +756,34 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 }\n             }\n \n+            // If so, impls may carry other conditions (e.g., where\n+            // clauses) that must be considered. Make sure that those\n+            // match as well (or at least may match, sometimes we\n+            // don't have enough information to fully evaluate).\n             match probe.kind {\n                 InherentImplCandidate(impl_def_id, ref substs) |\n                 ExtensionImplCandidate(impl_def_id, _, ref substs, _) => {\n                     // Check whether the impl imposes obligations we have to worry about.\n+                    let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n+                    let impl_bounds = impl_generics.to_bounds(self.tcx(), substs);\n+\n+                    // Erase any late-bound regions bound in the impl\n+                    // which appear in the bounds.\n+                    let impl_bounds = self.erase_late_bound_regions(&ty::bind(impl_bounds)).value;\n+\n+                    // Convert the bounds into obligations.\n                     let obligations =\n-                        traits::impl_obligations(\n+                        traits::obligations_for_generics(\n                             self.tcx(),\n                             traits::ObligationCause::misc(self.span),\n-                            impl_def_id,\n-                            substs);\n-\n+                            &impl_bounds,\n+                            &substs.types);\n                     debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n \n+                    // Evaluate those obligations to see if they might possibly hold.\n                     let mut selcx = traits::SelectionContext::new(self.infcx(),\n                                                                   &self.fcx.inh.param_env,\n                                                                   self.fcx);\n-\n                     obligations.all(|o| selcx.evaluate_obligation(o))\n                 }\n \n@@ -883,20 +896,78 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 self.infcx().next_ty_vars(\n                     method.generics.types.len(subst::FnSpace));\n \n+            // In general, during probe we erase regions. See\n+            // `impl_self_ty()` for an explanation.\n             let method_regions =\n-                self.infcx().region_vars_for_defs(\n-                    self.span,\n-                    method.generics.regions.get_slice(subst::FnSpace));\n+                method.generics.regions.get_slice(subst::FnSpace)\n+                .iter()\n+                .map(|_| ty::ReStatic)\n+                .collect();\n \n             placeholder = (*substs).clone().with_method(method_types, method_regions);\n             substs = &placeholder;\n         }\n \n+        // Replace early-bound regions and types.\n         let xform_self_ty = method.fty.sig.inputs[0].subst(self.tcx(), substs);\n-        self.infcx().replace_late_bound_regions_with_fresh_var(method.fty.sig.binder_id,\n-                                                               self.span,\n-                                                               infer::FnCall,\n-                                                               &xform_self_ty).0\n+\n+        // Replace late-bound regions bound in the impl or\n+        // where-clause (2 levels of binding).\n+        let xform_self_ty =\n+            self.erase_late_bound_regions(&ty::bind(ty::bind(xform_self_ty))).value.value;\n+\n+        // Replace late-bound regions bound in the method (1 level of binding).\n+        self.erase_late_bound_regions(&ty::bind(xform_self_ty)).value\n+    }\n+\n+    fn impl_substs(&self,\n+                   impl_def_id: ast::DefId)\n+                   -> subst::Substs\n+    {\n+        let impl_pty = ty::lookup_item_type(self.tcx(), impl_def_id);\n+\n+        let type_vars =\n+            impl_pty.generics.types.map(\n+                |_| self.infcx().next_ty_var());\n+\n+        let region_placeholders =\n+            impl_pty.generics.regions.map(\n+                |_| ty::ReStatic); // see erase_late_bound_regions() for an expl of why 'static\n+\n+        subst::Substs::new(type_vars, region_placeholders)\n+    }\n+\n+    fn erase_late_bound_regions<T>(&self, value: &T) -> T\n+        where T : HigherRankedFoldable\n+    {\n+        /*!\n+         * Replace late-bound-regions bound by `value` with `'static`\n+         * using `ty::erase_late_bound_regions`.\n+         *\n+         * This is only a reasonable thing to do during the *probe*\n+         * phase, not the *confirm* phase, of method matching. It is\n+         * reasonable during the probe phase because we don't consider\n+         * region relationships at all. Therefore, we can just replace\n+         * all the region variables with 'static rather than creating\n+         * fresh region variables. This is nice for two reasons:\n+         *\n+         * 1. Because the numbers of the region variables would\n+         *    otherwise be fairly unique to this particular method\n+         *    call, it winds up creating fewer types overall, which\n+         *    helps for memory usage. (Admittedly, this is a rather\n+         *    small effect, though measureable.)\n+         *\n+         * 2. It makes it easier to deal with higher-ranked trait\n+         *    bounds, because we can replace any late-bound regions\n+         *    with 'static. Otherwise, if we were going to replace\n+         *    late-bound regions with actual region variables as is\n+         *    proper, we'd have to ensure that the same region got\n+         *    replaced with the same variable, which requires a bit\n+         *    more coordination and/or tracking the substitution and\n+         *    so forth.\n+         */\n+\n+        ty::erase_late_bound_regions(self.tcx(), value)\n     }\n }\n "}, {"sha": "ea6028acf248e2295be9b6c0e0a8c9fbd863567c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 204, "deletions": 93, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -97,12 +97,12 @@ use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty;\n+use middle::ty::{replace_late_bound_regions, liberate_late_bound_regions};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n@@ -738,6 +738,11 @@ fn check_method_body(ccx: &CrateCtxt,\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, method.id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n+    debug!(\"fty (raw): {}\", fty.repr(ccx.tcx));\n+\n+    let body_id = method.pe_body().id;\n+    let fty = liberate_late_bound_regions(ccx.tcx, body_id, &ty::bind(fty)).value;\n+    debug!(\"fty (liberated): {}\", fty.repr(ccx.tcx));\n \n     check_bare_fn(ccx,\n                   &*method.pe_fn_decl(),\n@@ -782,7 +787,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                                                     impl_method.span,\n                                                     impl_method.pe_body().id,\n                                                     &**trait_method_ty,\n-                                                    &impl_trait_ref.substs);\n+                                                    impl_trait_ref);\n                             }\n                             _ => {\n                                 // This is span_bug as it should have already been\n@@ -927,11 +932,36 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                        impl_m_span: Span,\n                        impl_m_body_id: ast::NodeId,\n                        trait_m: &ty::Method,\n-                       trait_to_impl_substs: &subst::Substs) {\n-    debug!(\"compare_impl_method(trait_to_impl_substs={})\",\n-           trait_to_impl_substs.repr(tcx));\n+                       impl_trait_ref: &ty::TraitRef) {\n+    debug!(\"compare_impl_method(impl_trait_ref={})\",\n+           impl_trait_ref.repr(tcx));\n+\n+    // The impl's trait ref may bind late-bound regions from the impl.\n+    // Liberate them and assign them the scope of the method body.\n+    //\n+    // An example would be:\n+    //\n+    //     impl<'a> Foo<&'a T> for &'a U { ... }\n+    //\n+    // Here, the region parameter `'a` is late-bound, so the\n+    // trait reference associated with the impl will be\n+    //\n+    //     for<'a> Foo<&'a T>\n+    //\n+    // liberating will convert this into:\n+    //\n+    //     Foo<&'A T>\n+    //\n+    // where `'A` is the `ReFree` version of `'a`.\n+    let impl_trait_ref = liberate_late_bound_regions(tcx, impl_m_body_id, impl_trait_ref);\n+\n+    debug!(\"impl_trait_ref (liberated) = {}\",\n+           impl_trait_ref.repr(tcx));\n+\n     let infcx = infer::new_infer_ctxt(tcx);\n \n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n+\n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n@@ -995,22 +1025,23 @@ fn compare_impl_method(tcx: &ty::ctxt,\n \n     // This code is best explained by example. Consider a trait:\n     //\n-    //     trait Trait<T> {\n-    //          fn method<'a,M>(t: T, m: &'a M) -> Self;\n+    //     trait Trait<'t,T> {\n+    //          fn method<'a,M>(t: &'t T, m: &'a M) -> Self;\n     //     }\n     //\n     // And an impl:\n     //\n-    //     impl<'i, U> Trait<&'i U> for Foo {\n-    //          fn method<'b,N>(t: &'i U, m: &'b N) -> Foo;\n+    //     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n+    //          fn method<'b,N>(t: &'j &'i U, m: &'b N) -> Foo;\n     //     }\n     //\n     // We wish to decide if those two method types are compatible.\n     //\n-    // We start out with trait_to_impl_substs, that maps the trait type\n-    // parameters to impl type parameters:\n+    // We start out with trait_to_impl_substs, that maps the trait\n+    // type parameters to impl type parameters. This is taken from the\n+    // impl trait reference:\n     //\n-    //     trait_to_impl_substs = {T => &'i U, Self => Foo}\n+    //     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n     //\n     // We create a mapping `dummy_substs` that maps from the impl type\n     // parameters to fresh types and regions. For type parameters,\n@@ -1065,22 +1096,58 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     if !check_region_bounds_on_impl_method(tcx,\n                                            impl_m_span,\n                                            impl_m,\n+                                           impl_m_body_id,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n                                            &trait_to_skol_substs,\n                                            &impl_to_skol_substs) {\n         return;\n     }\n \n-    // Check bounds.\n-    let it = trait_m.generics.types.get_slice(subst::FnSpace).iter()\n-        .zip(impl_m.generics.types.get_slice(subst::FnSpace).iter());\n-    for (i, (trait_param_def, impl_param_def)) in it.enumerate() {\n+    // Check bounds. Note that the bounds from the impl may reference\n+    // late-bound regions declared on the impl, so liberate those.\n+    // This requires two artificial binding scopes -- one for the impl,\n+    // and one for the method.\n+    //\n+    // An example would be:\n+    //\n+    //     trait Foo<T> { fn method<U:Bound<T>>() { ... } }\n+    //\n+    //     impl<'a> Foo<&'a T> for &'a U {\n+    //         fn method<U:Bound<&'a T>>() { ... }\n+    //     }\n+    //\n+    // Here, the region parameter `'a` is late-bound, so in the bound\n+    // `Bound<&'a T>`, the lifetime `'a` will be late-bound with a\n+    // depth of 3 (it is nested within 3 binders: the impl, method,\n+    // and trait-ref itself). So when we do the liberation, we have\n+    // two introduce two `ty::bind` scopes, one for the impl and one\n+    // the method.\n+    //\n+    // The only late-bounded regions that can possibly appear here are\n+    // from the impl, not the method. This is because region\n+    // parameters declared on the method which appear in a type bound\n+    // would be early bound. On the trait side, there can be no\n+    // late-bound lifetimes because trait definitions do not introduce\n+    // a late region binder.\n+    let trait_bounds =\n+        trait_m.generics.types.get_slice(subst::FnSpace).iter()\n+        .map(|trait_param_def| &trait_param_def.bounds);\n+    let impl_bounds =\n+        impl_m.generics.types.get_slice(subst::FnSpace).iter()\n+        .map(|impl_param_def|\n+             liberate_late_bound_regions(\n+                 tcx,\n+                 impl_m_body_id,\n+                 &ty::bind(ty::bind(impl_param_def.bounds.clone()))).value.value);\n+    for (i, (trait_param_bounds, impl_param_bounds)) in\n+        trait_bounds.zip(impl_bounds).enumerate()\n+    {\n         // Check that the impl does not require any builtin-bounds\n         // that the trait does not guarantee:\n         let extra_bounds =\n-            impl_param_def.bounds.builtin_bounds -\n-            trait_param_def.bounds.builtin_bounds;\n+            impl_param_bounds.builtin_bounds -\n+            trait_param_bounds.builtin_bounds;\n         if !extra_bounds.is_empty() {\n             span_err!(tcx.sess, impl_m_span, E0051,\n                 \"in method `{}`, type parameter {} requires `{}`, \\\n@@ -1097,31 +1164,32 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         //\n         // FIXME(pcwalton): We could be laxer here regarding sub- and super-\n         // traits, but I doubt that'll be wanted often, so meh.\n-        for impl_trait_bound in impl_param_def.bounds.trait_bounds.iter() {\n+        for impl_trait_bound in impl_param_bounds.trait_bounds.iter() {\n             debug!(\"compare_impl_method(): impl-trait-bound subst\");\n             let impl_trait_bound =\n                 impl_trait_bound.subst(tcx, &impl_to_skol_substs);\n \n-            let mut ok = false;\n-            for trait_bound in trait_param_def.bounds.trait_bounds.iter() {\n-                debug!(\"compare_impl_method(): trait-bound subst\");\n-                let trait_bound =\n-                    trait_bound.subst(tcx, &trait_to_skol_substs);\n-                let infcx = infer::new_infer_ctxt(tcx);\n-                match infer::mk_sub_trait_refs(&infcx,\n-                                               true,\n-                                               infer::Misc(impl_m_span),\n-                                               trait_bound,\n-                                               impl_trait_bound.clone()) {\n-                    Ok(_) => {\n-                        ok = true;\n-                        break\n-                    }\n-                    Err(_) => continue,\n-                }\n-            }\n+            // There may be late-bound regions from the impl in the\n+            // impl's bound, so \"liberate\" those. Note that the\n+            // trait_to_skol_substs is derived from the impl's\n+            // trait-ref, and the late-bound regions appearing there\n+            // have already been liberated, so the result should match\n+            // up.\n+\n+            let found_match_in_trait =\n+                trait_param_bounds.trait_bounds.iter().any(|trait_bound| {\n+                    debug!(\"compare_impl_method(): trait-bound subst\");\n+                    let trait_bound =\n+                        trait_bound.subst(tcx, &trait_to_skol_substs);\n+                    let infcx = infer::new_infer_ctxt(tcx);\n+                    infer::mk_sub_trait_refs(&infcx,\n+                                             true,\n+                                             infer::Misc(impl_m_span),\n+                                             trait_bound,\n+                                             impl_trait_bound.clone()).is_ok()\n+                });\n \n-            if !ok {\n+            if !found_match_in_trait {\n                 span_err!(tcx.sess, impl_m_span, E0052,\n                     \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n                      required by the corresponding type parameter in the trait declaration\",\n@@ -1132,9 +1200,11 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         }\n     }\n \n-    // Compute skolemized form of impl and trait method tys.\n+    // Compute skolemized form of impl and trait method tys. Note\n+    // that we must liberate the late-bound regions from the impl.\n     let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n+    let impl_fty = liberate_late_bound_regions(tcx, impl_m_body_id, &ty::bind(impl_fty)).value;\n     let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n@@ -1169,6 +1239,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     fn check_region_bounds_on_impl_method(tcx: &ty::ctxt,\n                                           span: Span,\n                                           impl_m: &ty::Method,\n+                                          impl_m_body_id: ast::NodeId,\n                                           trait_generics: &ty::Generics,\n                                           impl_generics: &ty::Generics,\n                                           trait_to_skol_substs: &Substs,\n@@ -1214,9 +1285,13 @@ fn compare_impl_method(tcx: &ty::ctxt,\n \n         debug!(\"check_region_bounds_on_impl_method: \\\n                trait_generics={} \\\n-               impl_generics={}\",\n+               impl_generics={} \\\n+               trait_to_skol_substs={} \\\n+               impl_to_skol_substs={}\",\n                trait_generics.repr(tcx),\n-               impl_generics.repr(tcx));\n+               impl_generics.repr(tcx),\n+               trait_to_skol_substs.repr(tcx),\n+               impl_to_skol_substs.repr(tcx));\n \n         // Must have same number of early-bound lifetime parameters.\n         // Unfortunately, if the user screws up the bounds, then this\n@@ -1247,6 +1322,18 @@ fn compare_impl_method(tcx: &ty::ctxt,\n             let impl_bounds =\n                 impl_param.bounds.subst(tcx, impl_to_skol_substs);\n \n+            // The bounds may reference late-bound regions from the\n+            // impl declaration. In that case, we want to replace\n+            // those with the liberated variety so as to match the\n+            // versions appearing in the `trait_to_skol_substs`.\n+            // There are two-levels of binder to be aware of: the\n+            // impl, and the method.\n+            let impl_bounds =\n+                ty::liberate_late_bound_regions(\n+                    tcx,\n+                    impl_m_body_id,\n+                    &ty::bind(ty::bind(impl_bounds))).value.value;\n+\n             debug!(\"check_region_bounds_on_impl_method: \\\n                    trait_param={} \\\n                    impl_param={} \\\n@@ -1601,15 +1688,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn write_ty_substs(&self,\n-                           node_id: ast::NodeId,\n-                           ty: ty::t,\n-                           substs: ty::ItemSubsts) {\n-        let ty = ty.subst(self.tcx(), &substs.substs);\n-        self.write_ty(node_id, ty);\n-        self.write_substs(node_id, substs);\n-    }\n-\n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n                                       span: Span,\n@@ -1707,17 +1785,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn instantiate_item_type(&self,\n-                                 span: Span,\n-                                 def_id: ast::DefId)\n-                                 -> TypeAndSubsts\n+    pub fn instantiate_type(&self,\n+                            span: Span,\n+                            def_id: ast::DefId)\n+                            -> TypeAndSubsts\n     {\n         /*!\n          * Returns the type of `def_id` with all generics replaced by\n          * by fresh type/region variables. Also returns the\n          * substitution from the type parameters on `def_id` to the\n-         * fresh variables.  Registers any trait obligations specified\n+         * fresh variables. Registers any trait obligations specified\n          * on `def_id` at the same time.\n+         *\n+         * Note that function is only intended to be used with types\n+         * (notably, not impls). This is because it doesn't do any\n+         * instantiation of late-bound regions.\n          */\n \n         let polytype =\n@@ -1726,12 +1808,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.infcx().fresh_substs_for_generics(\n                 span,\n                 &polytype.generics);\n+        let bounds =\n+            polytype.generics.to_bounds(self.tcx(), &substs);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 span,\n                 traits::ItemObligation(def_id)),\n             &substs,\n-            &polytype.generics);\n+            &bounds);\n         let monotype =\n             polytype.ty.subst(self.tcx(), &substs);\n \n@@ -1956,8 +2040,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut region_obligations = self.inh.region_obligations.borrow_mut();\n         let region_obligation = RegionObligation { sub_region: r,\n-                                  sup_type: ty,\n-                                  origin: origin };\n+                                                   sup_type: ty,\n+                                                   origin: origin };\n \n         match region_obligations.entry(self.body_id) {\n             Vacant(entry) => { entry.set(vec![region_obligation]); },\n@@ -1968,12 +2052,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn add_obligations_for_parameters(&self,\n                                           cause: traits::ObligationCause,\n                                           substs: &Substs,\n-                                          generics: &ty::Generics)\n+                                          generic_bounds: &ty::GenericBounds)\n     {\n         /*!\n-         * Given a set of generic parameter definitions (`generics`)\n-         * and the values provided for each of them (`substs`),\n-         * creates and registers suitable region obligations.\n+         * Given a fully substituted set of bounds (`generic_bounds`),\n+         * and the values with which each type/region parameter was\n+         * instantiated (`substs`), creates and registers suitable\n+         * trait/region obligations.\n          *\n          * For example, if there is a function:\n          *\n@@ -1989,60 +2074,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n          * locally.\n          */\n \n-        debug!(\"add_obligations_for_parameters(substs={}, generics={})\",\n+        assert!(!generic_bounds.has_escaping_regions());\n+\n+        debug!(\"add_obligations_for_parameters(substs={}, generic_bounds={})\",\n                substs.repr(self.tcx()),\n-               generics.repr(self.tcx()));\n+               generic_bounds.repr(self.tcx()));\n \n-        self.add_trait_obligations_for_generics(cause, substs, generics);\n-        self.add_region_obligations_for_generics(cause, substs, generics);\n+        self.add_trait_obligations_for_generics(cause, substs, generic_bounds);\n+        self.add_region_obligations_for_generics(cause, substs, generic_bounds);\n     }\n \n     fn add_trait_obligations_for_generics(&self,\n                                           cause: traits::ObligationCause,\n                                           substs: &Substs,\n-                                          generics: &ty::Generics) {\n+                                          generic_bounds: &ty::GenericBounds) {\n+        assert!(!generic_bounds.has_escaping_regions());\n+        assert!(!substs.has_regions_escaping_depth(0));\n+\n         let obligations =\n             traits::obligations_for_generics(self.tcx(),\n                                              cause,\n-                                             generics,\n-                                             substs);\n+                                             generic_bounds,\n+                                             &substs.types);\n         obligations.map_move(|o| self.register_obligation(o));\n     }\n \n     fn add_region_obligations_for_generics(&self,\n                                            cause: traits::ObligationCause,\n                                            substs: &Substs,\n-                                           generics: &ty::Generics)\n+                                           generic_bounds: &ty::GenericBounds)\n     {\n-        assert_eq!(generics.types.iter().len(),\n-                   substs.types.iter().len());\n-        for (type_def, &type_param) in\n-            generics.types.iter().zip(\n+        assert!(!generic_bounds.has_escaping_regions());\n+        assert_eq!(generic_bounds.types.iter().len(), substs.types.iter().len());\n+\n+        for (type_bounds, &type_param) in\n+            generic_bounds.types.iter().zip(\n                 substs.types.iter())\n         {\n-            let param_ty = ty::ParamTy { space: type_def.space,\n-                                         idx: type_def.index,\n-                                         def_id: type_def.def_id };\n-            let bounds = type_def.bounds.subst(self.tcx(), substs);\n             self.add_region_obligations_for_type_parameter(\n-                cause.span, param_ty, &bounds, type_param);\n+                cause.span, type_bounds, type_param);\n         }\n \n-        assert_eq!(generics.regions.iter().len(),\n+        assert_eq!(generic_bounds.regions.iter().len(),\n                    substs.regions().iter().len());\n-        for (region_def, &region_param) in\n-            generics.regions.iter().zip(\n+        for (region_bounds, &region_param) in\n+            generic_bounds.regions.iter().zip(\n                 substs.regions().iter())\n         {\n-            let bounds = region_def.bounds.subst(self.tcx(), substs);\n             self.add_region_obligations_for_region_parameter(\n-                cause.span, bounds.as_slice(), region_param);\n+                cause.span, region_bounds.as_slice(), region_param);\n         }\n     }\n \n     fn add_region_obligations_for_type_parameter(&self,\n                                                  span: Span,\n-                                                 param_ty: ty::ParamTy,\n                                                  param_bound: &ty::ParamBounds,\n                                                  ty: ty::t)\n     {\n@@ -2054,7 +2139,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 param_bound.builtin_bounds,\n                 param_bound.trait_bounds.as_slice());\n         for &r in region_bounds.iter() {\n-            let origin = infer::RelateParamBound(span, param_ty, ty);\n+            let origin = infer::RelateParamBound(span, ty);\n             self.register_region_obligation(origin, ty, r);\n         }\n     }\n@@ -3816,7 +3901,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let TypeAndSubsts {\n             ty: mut struct_type,\n             substs: struct_substs\n-        } = fcx.instantiate_item_type(span, class_id);\n+        } = fcx.instantiate_type(span, class_id);\n \n         // Look up and check the fields.\n         let class_fields = ty::lookup_struct_fields(tcx, class_id);\n@@ -3858,7 +3943,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let TypeAndSubsts {\n             ty: enum_type,\n             substs: substitutions\n-        } = fcx.instantiate_item_type(span, enum_id);\n+        } = fcx.instantiate_type(span, enum_id);\n \n         // Look up and check the enum variant fields.\n         let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n@@ -5336,14 +5421,39 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         assert_eq!(substs.regions().len(space), region_defs.len(space));\n     }\n \n+    // The things we are substituting into the type should not contain\n+    // escaping late-bound regions.\n+    assert!(!substs.has_regions_escaping_depth(0));\n+\n+    // In the case of static items taken from impls, there may be\n+    // late-bound regions associated with the impl (not declared on\n+    // the fn itself). Those should be replaced with fresh variables\n+    // now. These can appear either on the type being referenced, or\n+    // on the associated bounds.\n+    let bounds = polytype.generics.to_bounds(fcx.tcx(), &substs);\n+    let (ty_late_bound, bounds) =\n+        fcx.infcx().replace_late_bound_regions_with_fresh_var(\n+            span,\n+            infer::FnCall,\n+            &ty::bind((polytype.ty, bounds))).0.value;\n+\n+    debug!(\"after late-bounds have been replaced: ty_late_bound={}\", ty_late_bound.repr(fcx.tcx()));\n+    debug!(\"after late-bounds have been replaced: bounds={}\", bounds.repr(fcx.tcx()));\n+\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::new(span, traits::ItemObligation(def.def_id())),\n         &substs,\n-        &polytype.generics);\n+        &bounds);\n \n-    fcx.write_ty_substs(node_id, polytype.ty, ty::ItemSubsts {\n-        substs: substs,\n-    });\n+    // Substitute the values for the type parameters into the type of\n+    // the referenced item.\n+    let ty_substituted = ty_late_bound.subst(fcx.tcx(), &substs);\n+\n+    debug!(\"ty_substituted: ty_substituted={}\", ty_substituted.repr(fcx.tcx()));\n+\n+    fcx.write_ty(node_id, ty_substituted);\n+    fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n+    return;\n \n     fn report_error_if_segment_contains_type_parameters(\n         fcx: &FnCtxt,\n@@ -5736,7 +5846,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"move_val_init\" => {\n                 (1u,\n                  vec!(\n-                    ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),\n+                    ty::mk_mut_rptr(tcx, ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(0)),\n+                                    param(ccx, 0)),\n                     param(ccx, 0u)\n                   ),\n                ty::mk_nil(tcx))"}, {"sha": "041d21a8baf3669319349422687f9b7285f09711", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -300,14 +300,14 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n }\n \n fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n-                     -> (ty::TraitRef, ty::t)\n+                     -> (Rc<ty::TraitRef>, ty::t)\n {\n     let trait_ref =\n         fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n             &*obligation.trait_ref);\n     let self_ty =\n         trait_ref.substs.self_ty().unwrap();\n-    (trait_ref, self_ty)\n+    (Rc::new(trait_ref), self_ty)\n }\n \n pub fn report_fulfillment_errors(fcx: &FnCtxt,"}, {"sha": "8e02f9f7bfd572917d8023d146fe20ed55287795", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -12,10 +12,10 @@ use middle::subst;\n use middle::subst::{Subst};\n use middle::traits;\n use middle::ty;\n+use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n use util::ppaux::Repr;\n \n@@ -166,16 +166,24 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n \n+            // Find the impl self type as seen from the \"inside\" --\n+            // that is, with all type parameters converted from bound\n+            // to free, and any late-bound regions on the impl\n+            // liberated.\n             let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n             let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let self_ty = liberate_late_bound_regions(fcx.tcx(), item.id, &ty::bind(self_ty)).value;\n \n             bounds_checker.check_traits_in_ty(self_ty);\n \n+            // Similarly, obtain an \"inside\" reference to the trait\n+            // that the impl implements.\n             let trait_ref = match ty::impl_trait_ref(fcx.tcx(), local_def(item.id)) {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n             let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let trait_ref = liberate_late_bound_regions(fcx.tcx(), item.id, &trait_ref);\n \n             // There are special rules that apply to drop.\n             if\n@@ -215,7 +223,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // FIXME -- This is a bit ill-factored. There is very similar\n             // code in traits::util::obligations_for_generics.\n             fcx.add_region_obligations_for_type_parameter(item.span,\n-                                                          ty::ParamTy::for_self(trait_ref.def_id),\n                                                           &trait_def.bounds,\n                                                           trait_ref.self_ty());\n             for builtin_bound in trait_def.bounds.builtin_bounds.iter() {\n@@ -280,12 +287,13 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n \n         let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n \n+        let bounds = trait_def.generics.to_bounds(self.tcx(), &trait_ref.substs);\n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 self.span,\n                 traits::ItemObligation(trait_ref.def_id)),\n             &trait_ref.substs,\n-            &trait_def.generics);\n+            &bounds);\n \n         for &ty in trait_ref.substs.types.iter() {\n             self.check_traits_in_ty(ty);\n@@ -335,7 +343,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                         traits::ObligationCause::new(self.span,\n                                                      traits::ItemObligation(type_id)),\n                         substs,\n-                        &polytype.generics);\n+                        &polytype.generics.to_bounds(self.tcx(), substs));\n                 } else {\n                     // There are two circumstances in which we ignore\n                     // region obligations.\n@@ -363,7 +371,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                         traits::ObligationCause::new(self.span,\n                                                      traits::ItemObligation(type_id)),\n                         substs,\n-                        &polytype.generics);\n+                        &polytype.generics.to_bounds(self.tcx(), substs));\n                 }\n \n                 self.fold_substs(substs);"}, {"sha": "a0b198a59c266b80230b260ebe43f37bede0b068", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -1112,10 +1112,12 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             for impl_item in impl_items.iter() {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n+                        let body_id = method.pe_body().id;\n                         check_method_self_type(ccx,\n-                                               &BindingRscope::new(method.id),\n+                                               &BindingRscope::new(),\n                                                selfty,\n-                                               method.pe_explicit_self());\n+                                               method.pe_explicit_self(),\n+                                               body_id);\n                         methods.push(&**method);\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n@@ -1170,17 +1172,19 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                              local_def(it.id));\n                 match *trait_method {\n                     ast::RequiredMethod(ref type_method) => {\n-                        let rscope = BindingRscope::new(type_method.id);\n+                        let rscope = BindingRscope::new();\n                         check_method_self_type(ccx,\n                                                &rscope,\n                                                self_type,\n-                                               &type_method.explicit_self)\n+                                               &type_method.explicit_self,\n+                                               it.id)\n                     }\n                     ast::ProvidedMethod(ref method) => {\n                         check_method_self_type(ccx,\n-                                               &BindingRscope::new(method.id),\n+                                               &BindingRscope::new(),\n                                                self_type,\n-                                               method.pe_explicit_self())\n+                                               method.pe_explicit_self(),\n+                                               it.id)\n                     }\n                     ast::TypeTraitItem(ref associated_type) => {\n                         convert_associated_type(ccx,\n@@ -2132,10 +2136,12 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n /// Verifies that the explicit self type of a method matches the impl or\n /// trait.\n fn check_method_self_type<RS:RegionScope>(\n-                          crate_context: &CrateCtxt,\n-                          rs: &RS,\n-                          required_type: ty::t,\n-                          explicit_self: &ast::ExplicitSelf) {\n+    crate_context: &CrateCtxt,\n+    rs: &RS,\n+    required_type: ty::t,\n+    explicit_self: &ast::ExplicitSelf,\n+    body_id: ast::NodeId)\n+{\n     match explicit_self.node {\n         ast::SelfExplicit(ref ast_type, _) => {\n             let typ = crate_context.to_ty(rs, &**ast_type);\n@@ -2144,13 +2150,44 @@ fn check_method_self_type<RS:RegionScope>(\n                 ty::ty_uniq(typ) => typ,\n                 _ => typ,\n             };\n+\n+            // \"Required type\" comes from the trait definition. It may\n+            // contain late-bound regions from the method, but not the\n+            // trait (since traits only have early-bound region\n+            // parameters).\n+            assert!(!ty::type_escapes_depth(required_type, 1));\n+            let required_type_free =\n+                ty::liberate_late_bound_regions(\n+                    crate_context.tcx,\n+                    body_id,\n+                    &ty::bind(required_type)).value;\n+\n+            // The \"base type\" comes from the impl. It may have late-bound\n+            // regions from the impl or the method.\n+            let base_type_free = // liberate impl regions:\n+                ty::liberate_late_bound_regions(\n+                    crate_context.tcx,\n+                    body_id,\n+                    &ty::bind(ty::bind(base_type))).value.value;\n+            let base_type_free = // liberate method regions:\n+                ty::liberate_late_bound_regions(\n+                    crate_context.tcx,\n+                    body_id,\n+                    &ty::bind(base_type_free)).value;\n+\n+            debug!(\"required_type={} required_type_free={} \\\n+                    base_type={} base_type_free={}\",\n+                   required_type.repr(crate_context.tcx),\n+                   required_type_free.repr(crate_context.tcx),\n+                   base_type.repr(crate_context.tcx),\n+                   base_type_free.repr(crate_context.tcx));\n             let infcx = infer::new_infer_ctxt(crate_context.tcx);\n             drop(typeck::require_same_types(crate_context.tcx,\n                                             Some(&infcx),\n                                             false,\n                                             explicit_self.span,\n-                                            base_type,\n-                                            required_type,\n+                                            base_type_free,\n+                                            required_type_free,\n                                             || {\n                 format!(\"mismatched self type: expected `{}`\",\n                         ppaux::ty_to_string(crate_context.tcx, required_type))"}, {"sha": "65bd21b14e02582354a78c975bd4eb9524e2f2ea", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -650,14 +650,12 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n-            infer::RelateParamBound(span, param_ty, ty) => {\n+            infer::RelateParamBound(span, ty) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"the type `{}` (provided as the value of \\\n-                             the parameter `{}`) does not fulfill the \\\n+                    format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty),\n-                            param_ty.user_string(self.tcx)).as_slice());\n+                            self.ty_to_string(ty)).as_slice());\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -1651,13 +1649,11 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                              does not outlive the data it points at\",\n                             self.ty_to_string(ty)).as_slice());\n             }\n-            infer::RelateParamBound(span, param_ty, t) => {\n+            infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that the parameter `{}`, \\\n-                             when instantiated with `{}`, \\\n-                             will meet its declared lifetime bounds.\",\n-                            param_ty.user_string(self.tcx),\n+                    format!(\"...so that the type `{}` \\\n+                             will meet the declared lifetime bounds.\",\n                             self.ty_to_string(t)).as_slice());\n             }\n             infer::RelateDefaultParamBound(span, t) => {"}, {"sha": "e69bd2157662e79414fc39570a2c2eca324d1fb4", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -184,9 +184,9 @@ pub enum SubregionOrigin {\n     // type of the variable outlives the lifetime bound.\n     RelateProcBound(Span, ast::NodeId, ty::t),\n \n-    // The given type parameter was instantiated with the given type,\n+    // Some type parameter was instantiated with the given type,\n     // and that type must outlive some region.\n-    RelateParamBound(Span, ty::ParamTy, ty::t),\n+    RelateParamBound(Span, ty::t),\n \n     // The given region parameter was instantiated with a region\n     // that must outlive some other region.\n@@ -1062,7 +1062,7 @@ impl SubregionOrigin {\n             IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             RelateProcBound(a, _, _) => a,\n-            RelateParamBound(a, _, _) => a,\n+            RelateParamBound(a, _) => a,\n             RelateRegionParamBound(a) => a,\n             RelateDefaultParamBound(a, _) => a,\n             Reborrow(a) => a,\n@@ -1112,11 +1112,10 @@ impl Repr for SubregionOrigin {\n                         b,\n                         c.repr(tcx))\n             }\n-            RelateParamBound(a, b, c) => {\n-                format!(\"RelateParamBound({},{},{})\",\n+            RelateParamBound(a, b) => {\n+                format!(\"RelateParamBound({},{})\",\n                         a.repr(tcx),\n-                        b.repr(tcx),\n-                        c.repr(tcx))\n+                        b.repr(tcx))\n             }\n             RelateRegionParamBound(a) => {\n                 format!(\"RelateRegionParamBound({})\","}, {"sha": "4ce783b37b73727e057f88e60283e8b1b148fe80", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -731,6 +731,9 @@ impl Repr for ty::ParamBounds {\n \n impl Repr for ty::TraitRef {\n     fn repr(&self, tcx: &ctxt) -> String {\n+        // when printing out the debug representation, we don't need\n+        // to enumerate the `for<...>` etc because the debruijn index\n+        // tells you everything you need to know.\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"<{} : {}>\",\n@@ -921,6 +924,14 @@ impl Repr for ty::Generics {\n     }\n }\n \n+impl Repr for ty::GenericBounds {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"GenericBounds(types: {}, regions: {})\",\n+                self.types.repr(tcx),\n+                self.regions.repr(tcx))\n+    }\n+}\n+\n impl Repr for ty::ItemVariances {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ItemVariances(types={}, \\\n@@ -1139,9 +1150,41 @@ impl UserString for ty::BuiltinBounds {\n \n impl UserString for ty::TraitRef {\n     fn user_string(&self, tcx: &ctxt) -> String {\n-        let base = ty::item_path_str(tcx, self.def_id);\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        let mut names = Vec::new();\n+        let (trait_ref, _) = ty::replace_late_bound_regions(tcx, self, |br, debruijn| {\n+            ty::ReLateBound(debruijn, match br {\n+                ty::BrNamed(_, name) => {\n+                    names.push(token::get_name(name));\n+                    br\n+                }\n+                ty::BrAnon(_) |\n+                ty::BrFresh(_) |\n+                ty::BrEnv => {\n+                    let name = token::gensym(\"r\");\n+                    names.push(token::get_name(name));\n+                    ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n+                }\n+            })\n+        });\n+        let names: Vec<_> = names.iter().map(|s| s.get()).collect();\n+\n+        // Let the base string be either `SomeTrait` for `for<'a,'b> SomeTrait`,\n+        // depending on whether there are bound regions.\n+        let path_str = ty::item_path_str(tcx, self.def_id);\n+        let base =\n+            if names.is_empty() {\n+                path_str\n+            } else {\n+                format!(\"for<{}> {}\", names.connect(\",\"), path_str)\n+            };\n+\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics)\n+        parameterized(tcx, base.as_slice(), &trait_ref.substs, &trait_def.generics)\n     }\n }\n "}, {"sha": "de49754fe7f9dfaac4f45779be723ab7685439a5", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a28d178afcecfb6d2231bb461c5a66864c50f0d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5a28d178afcecfb6d2231bb461c5a66864c50f0d", "patch": "@@ -467,9 +467,8 @@ pub fn trans_fn_ref_with_substs(\n             let impl_or_trait_item = ty::impl_or_trait_item(tcx, source_id);\n             match impl_or_trait_item {\n                 ty::MethodTraitItem(method) => {\n-                    let trait_ref = ty::impl_trait_ref(tcx, impl_id)\n-                        .expect(\"could not find trait_ref for impl with \\\n-                                 default methods\");\n+                    let trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n+                    let trait_ref = ty::erase_late_bound_regions(tcx, &trait_ref);\n \n                     // Compute the first substitution\n                     let first_subst ="}]}