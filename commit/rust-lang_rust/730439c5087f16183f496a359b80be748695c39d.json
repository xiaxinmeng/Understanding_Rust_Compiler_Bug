{"sha": "730439c5087f16183f496a359b80be748695c39d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMDQzOWM1MDg3ZjE2MTgzZjQ5NmEzNTliODBiZTc0ODY5NWMzOWQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-24T01:38:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-24T01:38:09Z"}, "message": "Improve LLVM builder wrapper-object.", "tree": {"sha": "0b86db8e0bc0cc2503abaf8f3f39769650530fae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b86db8e0bc0cc2503abaf8f3f39769650530fae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/730439c5087f16183f496a359b80be748695c39d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/730439c5087f16183f496a359b80be748695c39d", "html_url": "https://github.com/rust-lang/rust/commit/730439c5087f16183f496a359b80be748695c39d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/730439c5087f16183f496a359b80be748695c39d/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2db1f864e23e38d26b6dfb1e0a00829122a6aefd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2db1f864e23e38d26b6dfb1e0a00829122a6aefd", "html_url": "https://github.com/rust-lang/rust/commit/2db1f864e23e38d26b6dfb1e0a00829122a6aefd"}], "stats": {"total": 259, "additions": 206, "deletions": 53}, "files": [{"sha": "20b0cd9950506e65ffbb2e34826074a7ca471b03", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 206, "deletions": 53, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/730439c5087f16183f496a359b80be748695c39d/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/730439c5087f16183f496a359b80be748695c39d/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=730439c5087f16183f496a359b80be748695c39d", "patch": "@@ -1,3 +1,5 @@\n+import std._vec;\n+import std._str;\n import std._str.rustrt.sbuf;\n import std._vec.rustrt.vbuf;\n \n@@ -671,8 +673,10 @@ obj builder(BuilderRef B) {\n         ret llvm.LLVMBuildRet(B, V);\n     }\n \n-    fn AggregateRet(vbuf RetVals, uint N) -> ValueRef {\n-        ret llvm.LLVMBuildAggregateRet(B, RetVals, N);\n+    fn AggregateRet(vec[ValueRef] RetVals) -> ValueRef {\n+        ret llvm.LLVMBuildAggregateRet(B,\n+                                       _vec.buf[ValueRef](RetVals),\n+                                       _vec.len[ValueRef](RetVals));\n     }\n \n     fn Br(BasicBlockRef Dest) -> ValueRef {\n@@ -692,11 +696,15 @@ obj builder(BuilderRef B) {\n         ret llvm.LLVMBuildIndirectBr(B, Addr, NumDests);\n     }\n \n-    fn Invoke(ValueRef Fn, vbuf Args, uint NumArgs,\n-              BasicBlockRef Then, BasicBlockRef Catch,\n-              sbuf Name) -> ValueRef {\n-        ret llvm.LLVMBuildInvoke(B, Fn, Args, NumArgs,\n-                                 Then, Catch, Name);\n+    fn Invoke(ValueRef Fn,\n+              vec[ValueRef] Args,\n+              BasicBlockRef Then,\n+              BasicBlockRef Catch) -> ValueRef {\n+        ret llvm.LLVMBuildInvoke(B, Fn,\n+                                 _vec.buf[ValueRef](Args),\n+                                 _vec.len[ValueRef](Args),\n+                                 Then, Catch,\n+                                 _str.buf(\"\"));\n     }\n \n     fn Unwind() -> ValueRef {\n@@ -709,177 +717,322 @@ obj builder(BuilderRef B) {\n \n     /* Arithmetic */\n     fn Add(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildAdd(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildFAdd(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildFAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Sub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildSub(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildNSWSub(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildNSWSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildNUWSub(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildNUWSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildFSub(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildFSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Mul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildMul(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildNSWMul(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildNSWMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildNUWMul(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildNUWMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildFMul(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildFMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn UDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildUDiv(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildUDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn SDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildSDiv(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildSDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn ExactSDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildFDiv(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildFDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn URem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildURem(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildURem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn SRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildSRem(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildSRem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildFRem(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildFRem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Shl(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildShl(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildShl(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn LShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildLShr(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildLShr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn AShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildAShr(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildAShr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn And(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildAnd(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildAnd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Or(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildOr(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildOr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Xor(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildXor(B, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildXor(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn BinOp(Opcode Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, 0 as sbuf);\n+        ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Neg(ValueRef V) -> ValueRef {\n-        ret llvm.LLVMBuildNeg(B, V, 0 as sbuf);\n+        ret llvm.LLVMBuildNeg(B, V, _str.buf(\"\"));\n     }\n \n     fn NSWNeg(ValueRef V) -> ValueRef {\n-        ret llvm.LLVMBuildNSWNeg(B, V, 0 as sbuf);\n+        ret llvm.LLVMBuildNSWNeg(B, V, _str.buf(\"\"));\n     }\n \n     fn NUWNeg(ValueRef V) -> ValueRef {\n-        ret llvm.LLVMBuildNUWNeg(B, V, 0 as sbuf);\n+        ret llvm.LLVMBuildNUWNeg(B, V, _str.buf(\"\"));\n     }\n     fn FNeg(ValueRef V) -> ValueRef {\n-        ret llvm.LLVMBuildFNeg(B, V, 0 as sbuf);\n+        ret llvm.LLVMBuildFNeg(B, V, _str.buf(\"\"));\n     }\n     fn Not(ValueRef V) -> ValueRef {\n-        ret llvm.LLVMBuildNot(B, V, 0 as sbuf);\n+        ret llvm.LLVMBuildNot(B, V, _str.buf(\"\"));\n     }\n \n     /* Memory */\n     fn Malloc(TypeRef Ty) -> ValueRef {\n-        ret llvm.LLVMBuildMalloc(B, Ty, 0 as sbuf);\n+        ret llvm.LLVMBuildMalloc(B, Ty, _str.buf(\"\"));\n     }\n \n     fn ArrayMalloc(TypeRef Ty, ValueRef Val) -> ValueRef {\n-        ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, 0 as sbuf);\n+        ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, _str.buf(\"\"));\n     }\n \n     fn Alloca(TypeRef Ty) -> ValueRef {\n-        ret llvm.LLVMBuildAlloca(B, Ty, 0 as sbuf);\n+        ret llvm.LLVMBuildAlloca(B, Ty, _str.buf(\"\"));\n     }\n \n     fn ArrayAlloca(TypeRef Ty, ValueRef Val) -> ValueRef {\n-        ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, 0 as sbuf);\n+        ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, _str.buf(\"\"));\n     }\n \n     fn Free(ValueRef PointerVal) -> ValueRef {\n         ret llvm.LLVMBuildFree(B, PointerVal);\n     }\n \n     fn Load(ValueRef PointerVal) -> ValueRef {\n-        ret llvm.LLVMBuildLoad(B, PointerVal, 0 as sbuf);\n+        ret llvm.LLVMBuildLoad(B, PointerVal, _str.buf(\"\"));\n     }\n \n     fn Store(ValueRef Val, ValueRef Ptr) -> ValueRef {\n         ret llvm.LLVMBuildStore(B, Val, Ptr);\n     }\n \n-    fn GEP(ValueRef Pointer, vbuf Indices, uint NumIndices,\n-           sbuf Name) -> ValueRef {\n-        ret llvm.LLVMBuildGEP(B, Pointer, Indices, NumIndices, 0 as sbuf);\n+    fn GEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n+        ret llvm.LLVMBuildGEP(B, Pointer,\n+                              _vec.buf[ValueRef](Indices),\n+                              _vec.len[ValueRef](Indices),\n+                              _str.buf(\"\"));\n     }\n \n-    fn InBoundsGEP(ValueRef Pointer, vbuf Indices, uint NumIndices,\n-                   sbuf Name) -> ValueRef {\n-        ret llvm.LLVMBuildInBoundsGEP(B, Pointer, Indices,\n-                                      NumIndices, 0 as sbuf);\n+    fn InBoundsGEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n+        ret llvm.LLVMBuildInBoundsGEP(B, Pointer,\n+                                      _vec.buf[ValueRef](Indices),\n+                                      _vec.len[ValueRef](Indices),\n+                                      _str.buf(\"\"));\n     }\n \n     fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n-        ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, 0 as sbuf);\n+        ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, _str.buf(\"\"));\n     }\n \n     fn GlobalString(sbuf Str) -> ValueRef {\n-        ret llvm.LLVMBuildGlobalString(B, Str, 0 as sbuf);\n+        ret llvm.LLVMBuildGlobalString(B, Str, _str.buf(\"\"));\n     }\n \n     fn GlobalStringPtr(sbuf Str) -> ValueRef {\n-        ret llvm.LLVMBuildGlobalStringPtr(B, Str, 0 as sbuf);\n+        ret llvm.LLVMBuildGlobalStringPtr(B, Str, _str.buf(\"\"));\n+    }\n+\n+    /* Casts */\n+    fn Trunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildTrunc(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn ZExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildZExt(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn SExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildSExt(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn FPToUI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildFPToUI(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn FPToSI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildFPToSI(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn UIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildUIToFP(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn SIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildSIToFP(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn FPTrunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildFPTrunc(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn FPExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildFPExt(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn PtrToInt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildPtrToInt(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn IntToPtr(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildIntToPtr(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn BitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildBitCast(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn ZExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildZExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn SExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildSExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn TruncOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildTruncOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn Cast(Opcode Op, ValueRef Val, TypeRef DestTy, sbuf Name) -> ValueRef {\n+        ret llvm.LLVMBuildCast(B, Op, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn PointerCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildPointerCast(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn IntCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildIntCast(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+    fn FPCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        ret llvm.LLVMBuildFPCast(B, Val, DestTy, _str.buf(\"\"));\n+    }\n+\n+\n+    /* Comparisons */\n+    fn ICmp(IntPredicate Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, _str.buf(\"\"));\n+    }\n+\n+    fn FCmp(RealPredicate Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildFCmp(B, Op, LHS, RHS, _str.buf(\"\"));\n+    }\n+\n+\n+    /* Miscellaneous instructions */\n+    fn Phi(TypeRef Ty) -> ValueRef {\n+        ret llvm.LLVMBuildPhi(B, Ty, _str.buf(\"\"));\n+    }\n+\n+    fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n+        ret llvm.LLVMBuildCall(B, Fn,\n+                               _vec.buf[ValueRef](Args),\n+                               _vec.len[ValueRef](Args),\n+                               _str.buf(\"\"));\n+    }\n+\n+    fn Select(ValueRef If, ValueRef Then, ValueRef Else) -> ValueRef {\n+        ret llvm.LLVMBuildSelect(B, If, Then, Else, _str.buf(\"\"));\n+    }\n+\n+    fn VAArg(ValueRef List, TypeRef Ty) -> ValueRef {\n+        ret llvm.LLVMBuildVAArg(B, List, Ty, _str.buf(\"\"));\n+    }\n+\n+    fn ExtractElement(ValueRef VecVal, ValueRef Index) -> ValueRef {\n+        ret llvm.LLVMBuildExtractElement(B, VecVal, Index, _str.buf(\"\"));\n+    }\n+\n+    fn InsertElement(ValueRef VecVal, ValueRef EltVal,\n+                     ValueRef Index) -> ValueRef {\n+        ret llvm.LLVMBuildInsertElement(B, VecVal, EltVal, Index, _str.buf(\"\"));\n+    }\n+\n+    fn ShuffleVector(ValueRef V1, ValueRef V2, ValueRef Mask) -> ValueRef {\n+        ret llvm.LLVMBuildShuffleVector(B, V1, V2, Mask, _str.buf(\"\"));\n+    }\n+\n+    fn ExtractValue(ValueRef AggVal, uint Index) -> ValueRef {\n+        ret llvm.LLVMBuildExtractValue(B, AggVal, Index, _str.buf(\"\"));\n+    }\n+\n+    fn InsertValue(ValueRef AggVal, ValueRef EltVal,\n+                   uint Index) -> ValueRef {\n+        ret llvm.LLVMBuildInsertValue(B, AggVal, EltVal, Index, _str.buf(\"\"));\n+    }\n+\n+    fn IsNull(ValueRef Val) -> ValueRef {\n+        ret llvm.LLVMBuildIsNull(B, Val, _str.buf(\"\"));\n+    }\n+\n+    fn IsNotNull(ValueRef Val) -> ValueRef {\n+        ret llvm.LLVMBuildIsNotNull(B, Val, _str.buf(\"\"));\n+    }\n+\n+    fn PtrDiff(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        ret llvm.LLVMBuildPtrDiff(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     drop {"}]}