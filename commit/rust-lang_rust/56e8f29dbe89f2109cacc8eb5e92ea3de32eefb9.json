{"sha": "56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZThmMjlkYmU4OWYyMTA5Y2FjYzhlYjVlOTJlYTNkZTMyZWVmYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-23T09:02:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-23T09:02:45Z"}, "message": "Auto merge of #51580 - cramertj:async-await, r=eddyb\n\nasync/await\n\nThis PR implements `async`/`await` syntax for `async fn` in Rust 2015 and `async` closures and `async` blocks in Rust 2018 (tracking issue: https://github.com/rust-lang/rust/issues/50547). Limitations: non-`move` async closures with arguments are currently not supported, nor are `async fn` with multiple different input lifetimes. These limitations are not fundamental and will be removed in the future, however I'd like to go ahead and get this PR merged so we can start experimenting with this in combination with futures 0.3.\n\nBased on https://github.com/rust-lang/rust/pull/51414.\ncc @petrochenkov for parsing changes.\nr? @eddyb", "tree": {"sha": "8630b3d600677d35ce9c956fbfe12923b57e302d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8630b3d600677d35ce9c956fbfe12923b57e302d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "html_url": "https://github.com/rust-lang/rust/commit/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ea922a96d676ff84cd78421d314e6aac305b5e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea922a96d676ff84cd78421d314e6aac305b5e9", "html_url": "https://github.com/rust-lang/rust/commit/2ea922a96d676ff84cd78421d314e6aac305b5e9"}, {"sha": "30c17ccbffdbb88020e6ed42d89cc214fc3e6e5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/30c17ccbffdbb88020e6ed42d89cc214fc3e6e5f", "html_url": "https://github.com/rust-lang/rust/commit/30c17ccbffdbb88020e6ed42d89cc214fc3e6e5f"}], "stats": {"total": 2334, "additions": 1796, "deletions": 538}, "files": [{"sha": "09153c144ae805d29a29ca3b713375cb88f33426", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -2131,5 +2131,10 @@ register_diagnostics! {\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-    E0697, // closures cannot be static\n+\n+    E0906, // closures cannot be static\n+\n+    E0725, // multiple different lifetimes used in arguments of `async fn`\n+    E0726, // multiple elided lifetimes used in arguments of `async fn`\n+    E0727, // `async` non-`move` closures with arguments are not currently supported\n }"}, {"sha": "766909f5723b65ff64b4a4e439b6a9f213473f10", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -41,7 +41,6 @@\n //! This order consistency is required in a few places in rustc, for\n //! example generator inference, and possibly also HIR borrowck.\n \n-use rustc_target::spec::abi::Abi;\n use syntax::ast::{NodeId, CRATE_NODE_ID, Ident, Name, Attribute};\n use syntax_pos::Span;\n use hir::*;\n@@ -54,8 +53,8 @@ use std::u32;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n-    /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, &'a Visibility, &'a [Attribute]),\n+    /// #[xxx] pub async/const/extern \"Abi\" fn foo()\n+    ItemFn(Name, &'a Generics, FnHeader, &'a Visibility, &'a [Attribute]),\n \n     /// fn foo(&self)\n     Method(Name, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n@@ -479,12 +478,10 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n-        ItemFn(ref declaration, unsafety, constness, abi, ref generics, body_id) => {\n+        ItemFn(ref declaration, header, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name,\n                                             generics,\n-                                            unsafety,\n-                                            constness,\n-                                            abi,\n+                                            header,\n                                             &item.vis,\n                                             &item.attrs),\n                              declaration,"}, {"sha": "d6da2fce69a7469819fa05116467a98ab56148f4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 562, "deletions": 172, "changes": 734, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -168,6 +168,7 @@ pub trait Resolver {\n         span: Span,\n         crate_root: Option<&str>,\n         components: &[&str],\n+        params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path;\n }\n@@ -449,15 +450,15 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn allocate_hir_id_counter<T: Debug>(&mut self, owner: NodeId, debug: &T) {\n+    fn allocate_hir_id_counter<T: Debug>(&mut self, owner: NodeId, debug: &T) -> LoweredNodeId {\n         if self.item_local_id_counters.insert(owner, 0).is_some() {\n             bug!(\n                 \"Tried to allocate item_local_id_counter for {:?} twice\",\n                 debug\n             );\n         }\n         // Always allocate the first HirId for the owner itself\n-        self.lower_node_id_with_owner(owner, owner);\n+        self.lower_node_id_with_owner(owner, owner)\n     }\n \n     fn lower_node_id_generic<F>(&mut self, ast_node_id: NodeId, alloc_hir_id: F) -> LoweredNodeId\n@@ -501,7 +502,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let counter = self.item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n-            .unwrap();\n+            .unwrap_or_else(|| panic!(\"No item_local_id_counters entry for {:?}\", owner));\n         let def_index = self.resolver.definitions().opt_def_index(owner).unwrap();\n         self.current_hir_id_owner.push((def_index, counter));\n         let ret = f(self);\n@@ -840,6 +841,46 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn make_async_expr(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        closure_node_id: NodeId,\n+        ret_ty: Option<&Ty>,\n+        body: impl FnOnce(&mut LoweringContext) -> hir::Expr,\n+    ) -> hir::Expr_ {\n+        let prev_is_generator = mem::replace(&mut self.is_generator, true);\n+        let body_expr = body(self);\n+        let span = body_expr.span;\n+        let output = match ret_ty {\n+            Some(ty) => FunctionRetTy::Ty(P(ty.clone())),\n+            None => FunctionRetTy::Default(span),\n+        };\n+        let decl = FnDecl {\n+            inputs: vec![],\n+            output,\n+            variadic: false\n+        };\n+        let body_id = self.record_body(body_expr, Some(&decl));\n+        self.is_generator = prev_is_generator;\n+\n+        let capture_clause = self.lower_capture_clause(capture_clause);\n+        let closure_hir_id = self.lower_node_id(closure_node_id).hir_id;\n+        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, false);\n+        let generator = hir::Expr {\n+            id: closure_node_id,\n+            hir_id: closure_hir_id,\n+            node: hir::ExprClosure(capture_clause, decl, body_id, span,\n+                Some(hir::GeneratorMovability::Static)),\n+            span,\n+            attrs: ThinVec::new(),\n+        };\n+\n+        let unstable_span = self.allow_internal_unstable(CompilerDesugaringKind::Async, span);\n+        let gen_future = self.expr_std_path(\n+            unstable_span, &[\"future\", \"from_generator\"], None, ThinVec::new());\n+        hir::ExprCall(P(gen_future), hir_vec![generator])\n+    }\n+\n     fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n     where\n         F: FnOnce(&mut LoweringContext) -> hir::Expr,\n@@ -1067,7 +1108,7 @@ impl<'a> LoweringContext<'a> {\n                                 ),\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n-                                decl: this.lower_fn_decl(&f.decl, None, false),\n+                                decl: this.lower_fn_decl(&f.decl, None, false, false),\n                                 arg_names: this.lower_fn_args_to_names(&f.decl),\n                             }))\n                         },\n@@ -1132,92 +1173,8 @@ impl<'a> LoweringContext<'a> {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::Existential(fn_def_id) => {\n-\n-                        // We need to manually repeat the code of `next_id` because the lowering\n-                        // needs to happen while the owner_id is pointing to the item itself,\n-                        // because items are their own owners\n-                        let exist_ty_node_id = self.sess.next_node_id();\n-\n-                        // Make sure we know that some funky desugaring has been going on here.\n-                        // This is a first: there is code in other places like for loop\n-                        // desugaring that explicitly states that we don't want to track that.\n-                        // Not tracking it makes lints in rustc and clippy very fragile as\n-                        // frequently opened issues show.\n-                        let exist_ty_span = self.allow_internal_unstable(\n-                            CompilerDesugaringKind::ExistentialReturnType,\n-                            t.span,\n-                        );\n-\n-                        // Pull a new definition from the ether\n-                        let exist_ty_def_index = self\n-                            .resolver\n-                            .definitions()\n-                            .create_def_with_parent(\n-                            fn_def_id.index,\n-                            exist_ty_node_id,\n-                            DefPathData::ExistentialImplTrait,\n-                            DefIndexAddressSpace::High,\n-                            Mark::root(),\n-                            exist_ty_span,\n-                        );\n-\n-                        // the `t` is just for printing debug messages\n-                        self.allocate_hir_id_counter(exist_ty_node_id, t);\n-\n-                        let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-                            lctx.lower_param_bounds(bounds, itctx)\n-                        });\n-\n-                        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n-                            exist_ty_node_id,\n-                            exist_ty_def_index,\n-                            &hir_bounds,\n-                        );\n-\n-                        self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-                            let exist_ty_item_kind = hir::ItemExistential(hir::ExistTy {\n-                                generics: hir::Generics {\n-                                    params: lifetime_defs,\n-                                    where_clause: hir::WhereClause {\n-                                        id: lctx.next_id().node_id,\n-                                        predicates: Vec::new().into(),\n-                                    },\n-                                    span,\n-                                },\n-                                bounds: hir_bounds,\n-                                impl_trait_fn: Some(fn_def_id),\n-                            });\n-                            let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n-                            // Generate an `existential type Foo: Trait;` declaration\n-                            trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n-                            // Set the name to `impl Bound1 + Bound2`\n-                            let exist_ty_name = Symbol::intern(&pprust::ty_to_string(t));\n-\n-                            trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n-                            let exist_ty_item = hir::Item {\n-                                id: exist_ty_id.node_id,\n-                                hir_id: exist_ty_id.hir_id,\n-                                name: exist_ty_name,\n-                                attrs: Default::default(),\n-                                node: exist_ty_item_kind,\n-                                vis: hir::Visibility::Inherited,\n-                                span: exist_ty_span,\n-                            };\n-\n-                            // Insert the item into the global list. This usually happens\n-                            // automatically for all AST items. But this existential type item\n-                            // does not actually exist in the AST.\n-                            lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n-\n-                            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n-                            hir::TyImplTraitExistential(\n-                                hir::ItemId {\n-                                    id: exist_ty_id.node_id\n-                                },\n-                                DefId::local(exist_ty_def_index),\n-                                lifetimes,\n-                            )\n-                        })\n+                        self.lower_existential_impl_trait(\n+                            span, fn_def_id, |this| this.lower_param_bounds(bounds, itctx))\n                     }\n                     ImplTraitContext::Universal(def_id) => {\n                         let def_node_id = self.next_id().node_id;\n@@ -1281,6 +1238,94 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    fn lower_existential_impl_trait(\n+        &mut self,\n+        span: Span,\n+        fn_def_id: DefId,\n+        lower_bounds: impl FnOnce(&mut LoweringContext) -> hir::GenericBounds,\n+    ) -> hir::Ty_ {\n+        // We need to manually repeat the code of `next_id` because the lowering\n+        // needs to happen while the owner_id is pointing to the item itself,\n+        // because items are their own owners\n+        let exist_ty_node_id = self.sess.next_node_id();\n+\n+        // Make sure we know that some funky desugaring has been going on here.\n+        // This is a first: there is code in other places like for loop\n+        // desugaring that explicitly states that we don't want to track that.\n+        // Not tracking it makes lints in rustc and clippy very fragile as\n+        // frequently opened issues show.\n+        let exist_ty_span = self.allow_internal_unstable(\n+            CompilerDesugaringKind::ExistentialReturnType,\n+            span,\n+        );\n+\n+        // Pull a new definition from the ether\n+        let exist_ty_def_index = self\n+            .resolver\n+            .definitions()\n+            .create_def_with_parent(\n+            fn_def_id.index,\n+            exist_ty_node_id,\n+            DefPathData::ExistentialImplTrait,\n+            DefIndexAddressSpace::High,\n+            Mark::root(),\n+            exist_ty_span,\n+        );\n+\n+        self.allocate_hir_id_counter(exist_ty_node_id, &\"existential impl trait\");\n+\n+        let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, lower_bounds);\n+\n+        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n+            exist_ty_node_id,\n+            exist_ty_def_index,\n+            &hir_bounds,\n+        );\n+\n+        self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n+            let exist_ty_item_kind = hir::ItemExistential(hir::ExistTy {\n+                generics: hir::Generics {\n+                    params: lifetime_defs,\n+                    where_clause: hir::WhereClause {\n+                        id: lctx.next_id().node_id,\n+                        predicates: Vec::new().into(),\n+                    },\n+                    span,\n+                },\n+                bounds: hir_bounds,\n+                impl_trait_fn: Some(fn_def_id),\n+            });\n+            let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n+            // Generate an `existential type Foo: Trait;` declaration\n+            trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n+\n+            trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n+            let exist_ty_item = hir::Item {\n+                id: exist_ty_id.node_id,\n+                hir_id: exist_ty_id.hir_id,\n+                name: keywords::Invalid.name(),\n+                attrs: Default::default(),\n+                node: exist_ty_item_kind,\n+                vis: hir::Visibility::Inherited,\n+                span: exist_ty_span,\n+            };\n+\n+            // Insert the item into the global list. This usually happens\n+            // automatically for all AST items. But this existential type item\n+            // does not actually exist in the AST.\n+            lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n+\n+            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n+            hir::TyImplTraitExistential(\n+                hir::ItemId {\n+                    id: exist_ty_id.node_id\n+                },\n+                DefId::local(exist_ty_def_index),\n+                lifetimes,\n+            )\n+        })\n+    }\n+\n     fn lifetimes_from_impl_trait_bounds(\n         &mut self,\n         exist_ty_id: NodeId,\n@@ -1829,39 +1874,53 @@ impl<'a> LoweringContext<'a> {\n             .collect()\n     }\n \n+    // Lowers a function declaration.\n+    //\n+    // decl: the unlowered (ast) function declaration.\n+    // fn_def_id: if `Some`, impl Trait arguments are lowered into generic parameters on the\n+    //      given DefId, otherwise impl Trait is disallowed. Must be `Some` if\n+    //      make_ret_async is true.\n+    // impl_trait_return_allow: determines whether impl Trait can be used in return position.\n+    //      This guards against trait declarations and implementations where impl Trait is\n+    //      disallowed.\n+    // make_ret_async: if enabled, converts `-> T` into `-> impl Future<Output = T>` in the\n+    //      return type. This is used for `async fn` declarations.\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n         fn_def_id: Option<DefId>,\n         impl_trait_return_allow: bool,\n+        make_ret_async: bool,\n     ) -> P<hir::FnDecl> {\n-        // NOTE: The two last parameters here have to do with impl Trait. If fn_def_id is Some,\n-        //       then impl Trait arguments are lowered into generic parameters on the given\n-        //       fn_def_id, otherwise impl Trait is disallowed. (for now)\n-        //\n-        //       Furthermore, if impl_trait_return_allow is true, then impl Trait may be used in\n-        //       return positions as well. This guards against trait declarations and their impls\n-        //       where impl Trait is disallowed. (again for now)\n-        P(hir::FnDecl {\n-            inputs: decl.inputs\n-                .iter()\n-                .map(|arg| {\n-                    if let Some(def_id) = fn_def_id {\n-                        self.lower_ty(&arg.ty, ImplTraitContext::Universal(def_id))\n-                    } else {\n-                        self.lower_ty(&arg.ty, ImplTraitContext::Disallowed)\n-                    }\n-                })\n-                .collect(),\n-            output: match decl.output {\n+        let inputs = decl.inputs\n+            .iter()\n+            .map(|arg| {\n+                if let Some(def_id) = fn_def_id {\n+                    self.lower_ty(&arg.ty, ImplTraitContext::Universal(def_id))\n+                } else {\n+                    self.lower_ty(&arg.ty, ImplTraitContext::Disallowed)\n+                }\n+            })\n+            .collect::<HirVec<_>>();\n+\n+        let output = if make_ret_async {\n+            self.lower_async_fn_ret_ty(\n+                &inputs, &decl.output, fn_def_id.expect(\"make_ret_async but no fn_def_id\"))\n+        } else {\n+            match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match fn_def_id {\n                     Some(def_id) if impl_trait_return_allow => {\n                         hir::Return(self.lower_ty(ty, ImplTraitContext::Existential(def_id)))\n                     }\n                     _ => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n                 },\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n-            },\n+            }\n+        };\n+\n+        P(hir::FnDecl {\n+            inputs,\n+            output,\n             variadic: decl.variadic,\n             has_implicit_self: decl.inputs.get(0).map_or(false, |arg| match arg.ty.node {\n                 TyKind::ImplicitSelf => true,\n@@ -1871,6 +1930,231 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    // Transform `-> T` into `-> impl Future<Output = T>` for `async fn`\n+    //\n+    // fn_span: the span of the async function declaration. Used for error reporting.\n+    // inputs: lowered types of arguments to the function. Used to collect lifetimes.\n+    // output: unlowered output type (`T` in `-> T`)\n+    // fn_def_id: DefId of the parent function. Used to create child impl trait definition.\n+    fn lower_async_fn_ret_ty(\n+        &mut self,\n+        inputs: &[P<hir::Ty>],\n+        output: &FunctionRetTy,\n+        fn_def_id: DefId,\n+    ) -> hir::FunctionRetTy {\n+        // Get lifetimes used in the input arguments to the function. Our output type must also\n+        // have the same lifetime. FIXME(cramertj) multiple different lifetimes are not allowed\n+        // because `impl Trait + 'a + 'b` doesn't allow for capture `'a` and `'b` where neither\n+        // is a subset of the other. We really want some new lifetime that is a subset of all input\n+        // lifetimes, but that doesn't exist at the moment.\n+\n+        struct AsyncFnLifetimeCollector<'r, 'a: 'r> {\n+            context: &'r mut LoweringContext<'a>,\n+            // Lifetimes bound by HRTB\n+            currently_bound_lifetimes: Vec<hir::LifetimeName>,\n+            // Whether to count elided lifetimes.\n+            // Disabled inside of `Fn` or `fn` syntax.\n+            collect_elided_lifetimes: bool,\n+            // The lifetime found.\n+            // Multiple different or elided lifetimes cannot appear in async fn for now.\n+            output_lifetime: Option<(hir::LifetimeName, Span)>,\n+        }\n+\n+        impl<'r, 'a: 'r, 'v> hir::intravisit::Visitor<'v> for AsyncFnLifetimeCollector<'r, 'a> {\n+            fn nested_visit_map<'this>(\n+                &'this mut self,\n+            ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n+                hir::intravisit::NestedVisitorMap::None\n+            }\n+\n+            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs) {\n+                // Don't collect elided lifetimes used inside of `Fn()` syntax.\n+                if parameters.parenthesized {\n+                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                    self.collect_elided_lifetimes = false;\n+                    hir::intravisit::walk_generic_args(self, span, parameters);\n+                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+                } else {\n+                    hir::intravisit::walk_generic_args(self, span, parameters);\n+                }\n+            }\n+\n+            fn visit_ty(&mut self, t: &'v hir::Ty) {\n+                // Don't collect elided lifetimes used inside of `fn()` syntax\n+                if let &hir::Ty_::TyBareFn(_) = &t.node {\n+                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                    self.collect_elided_lifetimes = false;\n+\n+                    // Record the \"stack height\" of `for<'a>` lifetime bindings\n+                    // to be able to later fully undo their introduction.\n+                    let old_len = self.currently_bound_lifetimes.len();\n+                    hir::intravisit::walk_ty(self, t);\n+                    self.currently_bound_lifetimes.truncate(old_len);\n+\n+                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+                } else {\n+                    hir::intravisit::walk_ty(self, t);\n+                }\n+            }\n+\n+            fn visit_poly_trait_ref(\n+                &mut self,\n+                trait_ref: &'v hir::PolyTraitRef,\n+                modifier: hir::TraitBoundModifier,\n+            ) {\n+                // Record the \"stack height\" of `for<'a>` lifetime bindings\n+                // to be able to later fully undo their introduction.\n+                let old_len = self.currently_bound_lifetimes.len();\n+                hir::intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n+                self.currently_bound_lifetimes.truncate(old_len);\n+            }\n+\n+            fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n+                 // Record the introduction of 'a in `for<'a> ...`\n+                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n+                    // Introduce lifetimes one at a time so that we can handle\n+                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n+                    let lt_name = hir::LifetimeName::Param(param.name);\n+                    self.currently_bound_lifetimes.push(lt_name);\n+                }\n+\n+                hir::intravisit::walk_generic_param(self, param);\n+            }\n+\n+            fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n+                let name = match lifetime.name {\n+                    hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n+                        if self.collect_elided_lifetimes {\n+                            // Use `'_` for both implicit and underscore lifetimes in\n+                            // `abstract type Foo<'_>: SomeTrait<'_>;`\n+                            hir::LifetimeName::Underscore\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                    hir::LifetimeName::Param(_) => lifetime.name,\n+                    hir::LifetimeName::Static => return,\n+                };\n+\n+                if !self.currently_bound_lifetimes.contains(&name) {\n+                    if let Some((current_lt_name, current_lt_span)) = self.output_lifetime {\n+                        // We don't currently have a reliable way to desugar `async fn` with\n+                        // multiple potentially unrelated input lifetimes into\n+                        // `-> impl Trait + 'lt`, so we report an error in this case.\n+                        if current_lt_name != name {\n+                            struct_span_err!(\n+                                self.context.sess,\n+                                current_lt_span.between(lifetime.span),\n+                                E0725,\n+                                \"multiple different lifetimes used in arguments of `async fn`\",\n+                            )\n+                                .span_label(current_lt_span, \"first lifetime here\")\n+                                .span_label(lifetime.span, \"different lifetime here\")\n+                                .help(\"`async fn` can only accept borrowed values \\\n+                                      with identical lifetimes\")\n+                                .emit()\n+                        } else if current_lt_name.is_elided() && name.is_elided() {\n+                            struct_span_err!(\n+                                self.context.sess,\n+                                current_lt_span.between(lifetime.span),\n+                                E0726,\n+                                \"multiple elided lifetimes used in arguments of `async fn`\",\n+                            )\n+                                .span_label(current_lt_span, \"first lifetime here\")\n+                                .span_label(lifetime.span, \"different lifetime here\")\n+                                .help(\"consider giving these arguments named lifetimes\")\n+                                .emit()\n+                        }\n+                    } else {\n+                        self.output_lifetime = Some((name, lifetime.span));\n+                    }\n+                }\n+            }\n+        }\n+\n+        let bound_lifetime = {\n+            let mut lifetime_collector = AsyncFnLifetimeCollector {\n+                context: self,\n+                currently_bound_lifetimes: Vec::new(),\n+                collect_elided_lifetimes: true,\n+                output_lifetime: None,\n+            };\n+\n+            for arg in inputs {\n+                hir::intravisit::walk_ty(&mut lifetime_collector, arg);\n+            }\n+            lifetime_collector.output_lifetime\n+        };\n+\n+        let span = match output {\n+            FunctionRetTy::Ty(ty) => ty.span,\n+            FunctionRetTy::Default(span) => *span,\n+        };\n+\n+        let impl_trait_ty = self.lower_existential_impl_trait(\n+            span, fn_def_id, |this| {\n+            let output_ty = match output {\n+                FunctionRetTy::Ty(ty) =>\n+                    this.lower_ty(ty, ImplTraitContext::Existential(fn_def_id)),\n+                FunctionRetTy::Default(span) => {\n+                    let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                    P(hir::Ty {\n+                        id: node_id,\n+                        hir_id: hir_id,\n+                        node: hir::TyTup(hir_vec![]),\n+                        span: *span,\n+                    })\n+                }\n+            };\n+\n+            // \"<Output = T>\"\n+            let future_params = P(hir::GenericArgs {\n+                args: hir_vec![],\n+                bindings: hir_vec![hir::TypeBinding {\n+                    name: Symbol::intern(FN_OUTPUT_NAME),\n+                    ty: output_ty,\n+                    id: this.next_id().node_id,\n+                    span,\n+                }],\n+                parenthesized: false,\n+            });\n+\n+            let future_path =\n+                this.std_path(span, &[\"future\", \"Future\"], Some(future_params), false);\n+\n+            let mut bounds = vec![\n+                hir::GenericBound::Trait(\n+                    hir::PolyTraitRef {\n+                        trait_ref: hir::TraitRef {\n+                            path: future_path,\n+                            ref_id: this.next_id().node_id,\n+                        },\n+                        bound_generic_params: hir_vec![],\n+                        span,\n+                    },\n+                    hir::TraitBoundModifier::None\n+                ),\n+            ];\n+\n+            if let Some((name, span)) = bound_lifetime {\n+                bounds.push(hir::GenericBound::Outlives(\n+                    hir::Lifetime { id: this.next_id().node_id, name, span }));\n+            }\n+\n+            hir::HirVec::from(bounds)\n+        });\n+\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let impl_trait_ty = P(hir::Ty {\n+            id: node_id,\n+            node: impl_trait_ty,\n+            span,\n+            hir_id,\n+        });\n+\n+        hir::FunctionRetTy::Return(impl_trait_ty)\n+    }\n+\n     fn lower_param_bound(\n         &mut self,\n         tpb: &GenericBound,\n@@ -2284,25 +2568,40 @@ impl<'a> LoweringContext<'a> {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemConst(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n             }\n-            ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n+\n                 self.with_new_scopes(|this| {\n+                    // Note: we don't need to change the return type from `T` to\n+                    // `impl Future<Output = T>` here because lower_body\n+                    // only cares about the input argument patterns in the function\n+                    // declaration (decl), not the return types.\n                     let body_id = this.lower_body(Some(decl), |this| {\n-                        let body = this.lower_block(body, false);\n-                        this.expr_block(body, ThinVec::new())\n+                        if let IsAsync::Async(async_node_id) = header.asyncness {\n+                            let async_expr = this.make_async_expr(\n+                                CaptureBy::Value, async_node_id, None,\n+                                |this| {\n+                                    let body = this.lower_block(body, false);\n+                                    this.expr_block(body, ThinVec::new())\n+                                });\n+                            this.expr(body.span, async_expr, ThinVec::new())\n+                        } else {\n+                            let body = this.lower_block(body, false);\n+                            this.expr_block(body, ThinVec::new())\n+                        }\n                     });\n+\n                     let (generics, fn_decl) = this.add_in_band_defs(\n                         generics,\n                         fn_def_id,\n                         AnonymousLifetimeMode::PassThrough,\n-                        |this| this.lower_fn_decl(decl, Some(fn_def_id), true),\n+                        |this| this.lower_fn_decl(\n+                            decl, Some(fn_def_id), true, header.asyncness.is_async())\n                     );\n \n                     hir::ItemFn(\n                         fn_decl,\n-                        this.lower_unsafety(unsafety),\n-                        this.lower_constness(constness),\n-                        abi,\n+                        this.lower_fn_header(header),\n                         generics,\n                         body_id,\n                     )\n@@ -2620,7 +2919,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough,\n                     |this| {\n                         hir::TraitItemKind::Method(\n-                            this.lower_method_sig(sig, trait_item_def_id, false),\n+                            this.lower_method_sig(sig, trait_item_def_id, false, false),\n                             hir::TraitMethod::Required(names),\n                         )\n                     },\n@@ -2638,7 +2937,7 @@ impl<'a> LoweringContext<'a> {\n                     AnonymousLifetimeMode::PassThrough,\n                     |this| {\n                         hir::TraitItemKind::Method(\n-                            this.lower_method_sig(sig, trait_item_def_id, false),\n+                            this.lower_method_sig(sig, trait_item_def_id, false, false),\n                             hir::TraitMethod::Provided(body_id),\n                         )\n                     },\n@@ -2709,8 +3008,18 @@ impl<'a> LoweringContext<'a> {\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n                 let body_id = self.lower_body(Some(&sig.decl), |this| {\n-                    let body = this.lower_block(body, false);\n-                    this.expr_block(body, ThinVec::new())\n+                    if let IsAsync::Async(async_node_id) = sig.header.asyncness {\n+                        let async_expr = this.make_async_expr(\n+                            CaptureBy::Value, async_node_id, None,\n+                            |this| {\n+                                let body = this.lower_block(body, false);\n+                                this.expr_block(body, ThinVec::new())\n+                            });\n+                        this.expr(body.span, async_expr, ThinVec::new())\n+                    } else {\n+                        let body = this.lower_block(body, false);\n+                        this.expr_block(body, ThinVec::new())\n+                    }\n                 });\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n \n@@ -2724,6 +3033,7 @@ impl<'a> LoweringContext<'a> {\n                                 sig,\n                                 impl_item_def_id,\n                                 impl_trait_return_allow,\n+                                sig.header.asyncness.is_async(),\n                             ),\n                             body_id,\n                         )\n@@ -2865,7 +3175,7 @@ impl<'a> LoweringContext<'a> {\n                         |this| {\n                             (\n                                 // Disallow impl Trait in foreign items\n-                                this.lower_fn_decl(fdec, None, false),\n+                                this.lower_fn_decl(fdec, None, false, false),\n                                 this.lower_fn_args_to_names(fdec),\n                             )\n                         },\n@@ -2889,12 +3199,11 @@ impl<'a> LoweringContext<'a> {\n         sig: &MethodSig,\n         fn_def_id: DefId,\n         impl_trait_return_allow: bool,\n+        is_async: bool,\n     ) -> hir::MethodSig {\n         hir::MethodSig {\n-            abi: sig.abi,\n-            unsafety: self.lower_unsafety(sig.unsafety),\n-            constness: self.lower_constness(sig.constness),\n-            decl: self.lower_fn_decl(&sig.decl, Some(fn_def_id), impl_trait_return_allow),\n+            header: self.lower_fn_header(sig.header),\n+            decl: self.lower_fn_decl(&sig.decl, Some(fn_def_id), impl_trait_return_allow, is_async),\n         }\n     }\n \n@@ -2905,6 +3214,15 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n+        hir::FnHeader {\n+            unsafety: self.lower_unsafety(h.unsafety),\n+            asyncness: self.lower_asyncness(h.asyncness),\n+            constness: self.lower_constness(h.constness),\n+            abi: h.abi,\n+        }\n+    }\n+\n     fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {\n         match u {\n             Unsafety::Unsafe => hir::Unsafety::Unsafe,\n@@ -2919,6 +3237,13 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n+        match a {\n+            IsAsync::Async(_) => hir::IsAsync::Async,\n+            IsAsync::NotAsync => hir::IsAsync::NotAsync,\n+        }\n+    }\n+\n     fn lower_unop(&mut self, u: UnOp) -> hir::UnOp {\n         match u {\n             UnOp::Deref => hir::UnDeref,\n@@ -3206,46 +3531,101 @@ impl<'a> LoweringContext<'a> {\n                 arms.iter().map(|x| self.lower_arm(x)).collect(),\n                 hir::MatchSource::Normal,\n             ),\n-            ExprKind::Closure(capture_clause, movability, ref decl, ref body, fn_decl_span) => {\n+            ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n+                self.make_async_expr(capture_clause, closure_node_id, None, |this| {\n+                    this.with_new_scopes(|this| {\n+                        let block = this.lower_block(block, false);\n+                        this.expr_block(block, ThinVec::new())\n+                    })\n+                })\n+            },\n+            ExprKind::Closure(\n+                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span) =>\n+            {\n                 self.with_new_scopes(|this| {\n-                    let mut is_generator = false;\n-                    let body_id = this.lower_body(Some(decl), |this| {\n-                        let e = this.lower_expr(body);\n-                        is_generator = this.is_generator;\n-                        e\n-                    });\n-                    let generator_option = if is_generator {\n-                        if !decl.inputs.is_empty() {\n-                            span_err!(\n+                    if let IsAsync::Async(async_closure_node_id) = asyncness {\n+                        // FIXME(cramertj) allow `async` non-`move` closures with\n+                        if capture_clause == CaptureBy::Ref &&\n+                            !decl.inputs.is_empty()\n+                        {\n+                            struct_span_err!(\n                                 this.sess,\n                                 fn_decl_span,\n-                                E0628,\n-                                \"generators cannot have explicit arguments\"\n-                            );\n-                            this.sess.abort_if_errors();\n+                                E0727,\n+                                \"`async` non-`move` closures with arguments \\\n+                                are not currently supported\",\n+                            )\n+                                .help(\"consider using `let` statements to manually capture \\\n+                                        variables by reference before entering an \\\n+                                        `async move` closure\")\n+                                .emit();\n                         }\n-                        Some(match movability {\n-                            Movability::Movable => hir::GeneratorMovability::Movable,\n-                            Movability::Static => hir::GeneratorMovability::Static,\n-                        })\n+\n+                        // Transform `async |x: u8| -> X { ... }` into\n+                        // `|x: u8| future_from_generator(|| -> X { ... })`\n+                        let outer_decl = FnDecl {\n+                            inputs: decl.inputs.clone(),\n+                            output: FunctionRetTy::Default(fn_decl_span),\n+                            variadic: false,\n+                        };\n+                        let body_id = this.lower_body(Some(&outer_decl), |this| {\n+                            let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n+                                Some(&**ty)\n+                            } else { None };\n+                            let async_body = this.make_async_expr(\n+                                capture_clause, async_closure_node_id, async_ret_ty,\n+                                |this| {\n+                                    this.with_new_scopes(|this| this.lower_expr(body))\n+                                });\n+                            this.expr(fn_decl_span, async_body, ThinVec::new())\n+                        });\n+                        hir::ExprClosure(\n+                            this.lower_capture_clause(capture_clause),\n+                            this.lower_fn_decl(&outer_decl, None, false, false),\n+                            body_id,\n+                            fn_decl_span,\n+                            None,\n+                        )\n                     } else {\n-                        if movability == Movability::Static {\n-                            span_err!(\n-                                this.sess,\n-                                fn_decl_span,\n-                                E0697,\n-                                \"closures cannot be static\"\n-                            );\n-                        }\n-                        None\n-                    };\n-                    hir::ExprClosure(\n-                        this.lower_capture_clause(capture_clause),\n-                        this.lower_fn_decl(decl, None, false),\n-                        body_id,\n-                        fn_decl_span,\n-                        generator_option,\n-                    )\n+                        let mut is_generator = false;\n+                        let body_id = this.lower_body(Some(decl), |this| {\n+                            let e = this.lower_expr(body);\n+                            is_generator = this.is_generator;\n+                            e\n+                        });\n+                        let generator_option = if is_generator {\n+                            if !decl.inputs.is_empty() {\n+                                span_err!(\n+                                    this.sess,\n+                                    fn_decl_span,\n+                                    E0628,\n+                                    \"generators cannot have explicit arguments\"\n+                                );\n+                                this.sess.abort_if_errors();\n+                            }\n+                            Some(match movability {\n+                                Movability::Movable => hir::GeneratorMovability::Movable,\n+                                Movability::Static => hir::GeneratorMovability::Static,\n+                            })\n+                        } else {\n+                            if movability == Movability::Static {\n+                                span_err!(\n+                                    this.sess,\n+                                    fn_decl_span,\n+                                    E0906,\n+                                    \"closures cannot be static\"\n+                                );\n+                            }\n+                            None\n+                        };\n+                        hir::ExprClosure(\n+                            this.lower_capture_clause(capture_clause),\n+                            this.lower_fn_decl(decl, None, false, false),\n+                            body_id,\n+                            fn_decl_span,\n+                            generator_option,\n+                        )\n+                    }\n                 })\n             }\n             ExprKind::Block(ref blk, opt_label) => {\n@@ -3272,7 +3652,7 @@ impl<'a> LoweringContext<'a> {\n                 let id = self.next_id();\n                 let e1 = self.lower_expr(e1);\n                 let e2 = self.lower_expr(e2);\n-                let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], false));\n+                let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], None, false));\n                 let ty = self.ty_path(id, span, hir::QPath::Resolved(None, ty_path));\n                 let new_seg = P(hir::PathSegment::from_name(Symbol::intern(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n@@ -3312,7 +3692,7 @@ impl<'a> LoweringContext<'a> {\n                 let struct_path = iter::once(\"ops\")\n                     .chain(iter::once(path))\n                     .collect::<Vec<_>>();\n-                let struct_path = self.std_path(unstable_span, &struct_path, is_unit);\n+                let struct_path = self.std_path(unstable_span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n                 let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n@@ -3589,7 +3969,7 @@ impl<'a> LoweringContext<'a> {\n                     let iter = P(self.expr_ident(head_sp, iter, iter_pat.id));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n                     let next_path = &[\"iter\", \"Iterator\", \"next\"];\n-                    let next_path = P(self.expr_std_path(head_sp, next_path, ThinVec::new()));\n+                    let next_path = P(self.expr_std_path(head_sp, next_path, None, ThinVec::new()));\n                     let next_expr = P(self.expr_call(head_sp, next_path, hir_vec![ref_mut_iter]));\n                     let arms = hir_vec![pat_arm, break_arm];\n \n@@ -3647,7 +4027,8 @@ impl<'a> LoweringContext<'a> {\n                 // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                 let into_iter_expr = {\n                     let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n-                    let into_iter = P(self.expr_std_path(head_sp, into_iter_path, ThinVec::new()));\n+                    let into_iter = P(self.expr_std_path(\n+                            head_sp, into_iter_path, None, ThinVec::new()));\n                     P(self.expr_call(head_sp, into_iter, hir_vec![head]))\n                 };\n \n@@ -3693,7 +4074,8 @@ impl<'a> LoweringContext<'a> {\n                     let sub_expr = self.lower_expr(sub_expr);\n \n                     let path = &[\"ops\", \"Try\", \"into_result\"];\n-                    let path = P(self.expr_std_path(unstable_span, path, ThinVec::new()));\n+                    let path = P(self.expr_std_path(\n+                            unstable_span, path, None, ThinVec::new()));\n                     P(self.expr_call(e.span, path, hir_vec![sub_expr]))\n                 };\n \n@@ -3732,7 +4114,8 @@ impl<'a> LoweringContext<'a> {\n                     let err_local = self.pat_ident(e.span, err_ident);\n                     let from_expr = {\n                         let path = &[\"convert\", \"From\", \"from\"];\n-                        let from = P(self.expr_std_path(e.span, path, ThinVec::new()));\n+                        let from = P(self.expr_std_path(\n+                                e.span, path, None, ThinVec::new()));\n                         let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n                         self.expr_call(e.span, from, hir_vec![err_expr])\n@@ -3972,9 +4355,10 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         span: Span,\n         components: &[&str],\n+        params: Option<P<hir::GenericArgs>>,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n-        let path = self.std_path(span, components, true);\n+        let path = self.std_path(span, components, params, true);\n         self.expr(\n             span,\n             hir::ExprPath(hir::QPath::Resolved(None, P(path))),\n@@ -4099,7 +4483,7 @@ impl<'a> LoweringContext<'a> {\n         components: &[&str],\n         subpats: hir::HirVec<P<hir::Pat>>,\n     ) -> P<hir::Pat> {\n-        let path = self.std_path(span, components, true);\n+        let path = self.std_path(span, components, None, true);\n         let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(qpath)\n@@ -4146,9 +4530,15 @@ impl<'a> LoweringContext<'a> {\n     /// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n     /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n     /// The path is also resolved according to `is_value`.\n-    fn std_path(&mut self, span: Span, components: &[&str], is_value: bool) -> hir::Path {\n+    fn std_path(\n+        &mut self,\n+        span: Span,\n+        components: &[&str],\n+        params: Option<P<hir::GenericArgs>>,\n+        is_value: bool\n+    ) -> hir::Path {\n         self.resolver\n-            .resolve_str_path(span, self.crate_root, components, is_value)\n+            .resolve_str_path(span, self.crate_root, components, params, is_value)\n     }\n \n     fn ty_path(&mut self, id: LoweredNodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n@@ -4280,7 +4670,7 @@ impl<'a> LoweringContext<'a> {\n         unstable_span: Span,\n     ) -> P<hir::Expr> {\n         let path = &[\"ops\", \"Try\", method];\n-        let from_err = P(self.expr_std_path(unstable_span, path,\n+        let from_err = P(self.expr_std_path(unstable_span, path, None,\n                                             ThinVec::new()));\n         P(self.expr_call(e.span, from_err, hir_vec![e]))\n     }"}, {"sha": "f665ced3dbcf12de404a66590c2bab7e9b33d70c", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -25,7 +25,6 @@ use hir as ast;\n use hir::map::{self, Node};\n use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n-use rustc_target::spec::abi;\n use syntax::ast::{Attribute, Name, NodeId};\n use syntax_pos::Span;\n \n@@ -105,9 +104,7 @@ impl<'a> Code<'a> {\n struct ItemFnParts<'a> {\n     name:     Name,\n     decl:     &'a ast::FnDecl,\n-    unsafety: ast::Unsafety,\n-    constness: ast::Constness,\n-    abi:      abi::Abi,\n+    header:   ast::FnHeader,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n     body:     ast::BodyId,\n@@ -183,31 +180,31 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn constness(self) -> ast::Constness {\n         match self.kind() {\n-            FnKind::ItemFn(_, _, _, constness, ..) => {\n-                constness\n-            }\n-            FnKind::Method(_, m, ..) => {\n-                m.constness\n-            }\n+            FnKind::ItemFn(_, _, header, ..) => header.constness,\n+            FnKind::Method(_, m, ..) => m.header.constness,\n             _ => ast::Constness::NotConst\n         }\n     }\n \n+    pub fn asyncness(self) -> ast::IsAsync {\n+        match self.kind() {\n+            FnKind::ItemFn(_, _, header, ..) => header.asyncness,\n+            FnKind::Method(_, m, ..) => m.header.asyncness,\n+            _ => ast::IsAsync::NotAsync\n+        }\n+    }\n+\n     pub fn unsafety(self) -> ast::Unsafety {\n         match self.kind() {\n-            FnKind::ItemFn(_, _, unsafety, ..) => {\n-                unsafety\n-            }\n-            FnKind::Method(_, m, ..) => {\n-                m.unsafety\n-            }\n+            FnKind::ItemFn(_, _, header, ..) => header.unsafety,\n+            FnKind::Method(_, m, ..) => m.header.unsafety,\n             _ => ast::Unsafety::Normal\n         }\n     }\n \n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n-            FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis, p.attrs)\n+            FnKind::ItemFn(p.name, p.generics, p.header, p.vis, p.attrs)\n         };\n         let closure = |c: ClosureParts<'a>| {\n             FnKind::Closure(c.attrs)\n@@ -232,19 +229,17 @@ impl<'a> FnLikeNode<'a> {\n     {\n         match self.node {\n             map::NodeItem(i) => match i.node {\n-                ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, block) =>\n+                ast::ItemFn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n                         name: i.name,\n                         decl: &decl,\n-                        unsafety,\n                         body: block,\n-                        generics,\n-                        abi,\n                         vis: &i.vis,\n-                        constness,\n                         span: i.span,\n                         attrs: &i.attrs,\n+                        header,\n+                        generics,\n                     }),\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "7c71401c8b2e8cbc6f54a734a70322ddcf9f303d", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -73,6 +73,27 @@ impl<'a> DefCollector<'a> {\n         self.parent_def = parent;\n     }\n \n+    fn visit_async_fn(\n+        &mut self,\n+        id: NodeId,\n+        async_node_id: NodeId,\n+        name: Name,\n+        span: Span,\n+        visit_fn: impl FnOnce(&mut DefCollector<'a>)\n+    ) {\n+        // For async functions, we need to create their inner defs inside of a\n+        // closure to match their desugared representation.\n+        let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n+        let fn_def = self.create_def(id, fn_def_data, ITEM_LIKE_SPACE, span);\n+        return self.with_parent(fn_def, |this| {\n+            let closure_def = this.create_def(async_node_id,\n+                                  DefPathData::ClosureExpr,\n+                                  REGULAR_SPACE,\n+                                  span);\n+            this.with_parent(closure_def, visit_fn)\n+        })\n+    }\n+\n     fn visit_macro_invoc(&mut self, id: NodeId) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n@@ -99,6 +120,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n+            ItemKind::Fn(_, FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..) => {\n+                return self.visit_async_fn(\n+                    i.id,\n+                    async_node_id,\n+                    i.ident.name,\n+                    i.span,\n+                    |this| visit::walk_item(this, i)\n+                )\n+            }\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_interned_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_interned_str()),\n@@ -197,6 +227,17 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n+            ImplItemKind::Method(MethodSig {\n+                header: FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..\n+            }, ..) => {\n+                return self.visit_async_fn(\n+                    ii.id,\n+                    async_node_id,\n+                    ii.ident.name,\n+                    ii.span,\n+                    |this| visit::walk_impl_item(this, ii)\n+                )\n+            }\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name.as_interned_str()),\n             ImplItemKind::Type(..) => DefPathData::AssocTypeInImpl(ii.ident.name.as_interned_str()),\n@@ -227,15 +268,32 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         match expr.node {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n-            ExprKind::Closure(..) => {\n-                let def = self.create_def(expr.id,\n+            ExprKind::Closure(_, asyncness, ..) => {\n+                let closure_def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n                                           REGULAR_SPACE,\n                                           expr.span);\n-                self.parent_def = Some(def);\n+                self.parent_def = Some(closure_def);\n+\n+                // Async closures desugar to closures inside of closures, so\n+                // we must create two defs.\n+                if let IsAsync::Async(async_id) = asyncness {\n+                    let async_def = self.create_def(async_id,\n+                                                    DefPathData::ClosureExpr,\n+                                                    REGULAR_SPACE,\n+                                                    expr.span);\n+                    self.parent_def = Some(async_def);\n+                }\n+            }\n+            ExprKind::Async(_, async_id, _) => {\n+                let async_def = self.create_def(async_id,\n+                                                DefPathData::ClosureExpr,\n+                                                REGULAR_SPACE,\n+                                                expr.span);\n+                self.parent_def = Some(async_def);\n             }\n             _ => {}\n-        }\n+        };\n \n         visit::walk_expr(self, expr);\n         self.parent_def = parent_def;"}, {"sha": "1e03381861b9b82d4ecc3f556385515dcd2a2aaa", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -174,7 +174,7 @@ impl<'hir> MapEntry<'hir> {\n         match self {\n             EntryItem(_, _, ref item) => {\n                 match item.node {\n-                    ItemFn(ref fn_decl, _, _, _, _, _) => Some(&fn_decl),\n+                    ItemFn(ref fn_decl, _, _, _) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -210,7 +210,7 @@ impl<'hir> MapEntry<'hir> {\n                 match item.node {\n                     ItemConst(_, body) |\n                     ItemStatic(.., body) |\n-                    ItemFn(_, _, _, _, _, body) => Some(body),\n+                    ItemFn(_, _, _, body) => Some(body),\n                     _ => None,\n                 }\n             }"}, {"sha": "5e41c51abd98c2e8c596f25f3a386e3257c5cd5f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -255,7 +255,7 @@ impl LifetimeName {\n         }\n     }\n \n-    fn is_elided(&self) -> bool {\n+    pub fn is_elided(&self) -> bool {\n         use self::LifetimeName::*;\n         match self {\n             Implicit | Underscore => true,\n@@ -1506,9 +1506,7 @@ pub struct MutTy {\n /// Represents a method's signature in a trait declaration or implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MethodSig {\n-    pub unsafety: Unsafety,\n-    pub constness: Constness,\n-    pub abi: Abi,\n+    pub header: FnHeader,\n     pub decl: P<FnDecl>,\n }\n \n@@ -1736,7 +1734,13 @@ pub enum IsAuto {\n     No\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq,PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum IsAsync {\n+    Async,\n+    NotAsync,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,\n     Normal,\n@@ -2012,6 +2016,14 @@ pub struct Item {\n     pub span: Span,\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct FnHeader {\n+    pub unsafety: Unsafety,\n+    pub constness: Constness,\n+    pub asyncness: IsAsync,\n+    pub abi: Abi,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n@@ -2031,7 +2043,7 @@ pub enum Item_ {\n     /// A `const` item\n     ItemConst(P<Ty>, BodyId),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, BodyId),\n+    ItemFn(P<FnDecl>, FnHeader, Generics, BodyId),\n     /// A module\n     ItemMod(Mod),\n     /// An external module\n@@ -2096,7 +2108,7 @@ impl Item_ {\n \n     pub fn generics(&self) -> Option<&Generics> {\n         Some(match *self {\n-            ItemFn(_, _, _, _, ref generics, _) |\n+            ItemFn(_, _, ref generics, _) |\n             ItemTy(_, ref generics) |\n             ItemEnum(_, ref generics) |\n             ItemStruct(_, ref generics) |"}, {"sha": "51a7504efcfcb2e5aa55905b5f731de61b422508", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -459,9 +459,12 @@ impl<'a> State<'a> {\n             hir::ForeignItemFn(ref decl, ref arg_names, ref generics) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n-                              hir::Unsafety::Normal,\n-                              hir::Constness::NotConst,\n-                              Abi::Rust,\n+                              hir::FnHeader {\n+                                  unsafety: hir::Unsafety::Normal,\n+                                  constness: hir::Constness::NotConst,\n+                                  abi: Abi::Rust,\n+                                  asyncness: hir::IsAsync::NotAsync,\n+                              },\n                               Some(item.name),\n                               generics,\n                               &item.vis,\n@@ -598,12 +601,10 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, body) => {\n+            hir::ItemFn(ref decl, header, ref typarams, body) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n-                              unsafety,\n-                              constness,\n-                              abi,\n+                              header,\n                               Some(item.name),\n                               typarams,\n                               &item.vis,\n@@ -935,9 +936,7 @@ impl<'a> State<'a> {\n                             body_id: Option<hir::BodyId>)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n-                      m.unsafety,\n-                      m.constness,\n-                      m.abi,\n+                      m.header,\n                       Some(name),\n                       generics,\n                       vis,\n@@ -1986,16 +1985,14 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &hir::FnDecl,\n-                    unsafety: hir::Unsafety,\n-                    constness: hir::Constness,\n-                    abi: Abi,\n+                    header: hir::FnHeader,\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     vis: &hir::Visibility,\n                     arg_names: &[Spanned<ast::Name>],\n                     body_id: Option<hir::BodyId>)\n                     -> io::Result<()> {\n-        self.print_fn_header_info(unsafety, constness, abi, vis)?;\n+        self.print_fn_header_info(header, vis)?;\n \n         if let Some(name) = name {\n             self.nbsp()?;\n@@ -2260,9 +2257,12 @@ impl<'a> State<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n-                      unsafety,\n-                      hir::Constness::NotConst,\n-                      abi,\n+                      hir::FnHeader {\n+                          unsafety,\n+                          abi,\n+                          constness: hir::Constness::NotConst,\n+                          asyncness: hir::IsAsync::NotAsync,\n+                      },\n                       name,\n                       &generics,\n                       &hir::Inherited,\n@@ -2333,22 +2333,26 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                unsafety: hir::Unsafety,\n-                                constness: hir::Constness,\n-                                abi: Abi,\n+                                header: hir::FnHeader,\n                                 vis: &hir::Visibility)\n                                 -> io::Result<()> {\n         self.s.word(&visibility_qualified(vis, \"\"))?;\n-        self.print_unsafety(unsafety)?;\n \n-        match constness {\n+        match header.constness {\n             hir::Constness::NotConst => {}\n             hir::Constness::Const => self.word_nbsp(\"const\")?,\n         }\n \n-        if abi != Abi::Rust {\n+        match header.asyncness {\n+            hir::IsAsync::NotAsync => {}\n+            hir::IsAsync::Async => self.word_nbsp(\"async\")?,\n+        }\n+\n+        self.print_unsafety(header.unsafety)?;\n+\n+        if header.abi != Abi::Rust {\n             self.word_nbsp(\"extern\")?;\n-            self.word_nbsp(&abi.to_string())?;\n+            self.word_nbsp(&header.abi.to_string())?;\n         }\n \n         self.s.word(\"fn\")"}, {"sha": "b1429247ab0718b6ca624e41143cb3e0fe534363", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -272,9 +272,7 @@ impl_stable_hash_for!(struct hir::MutTy {\n });\n \n impl_stable_hash_for!(struct hir::MethodSig {\n-    unsafety,\n-    constness,\n-    abi,\n+    header,\n     decl\n });\n \n@@ -285,6 +283,13 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n+impl_stable_hash_for!(struct hir::FnHeader {\n+    unsafety,\n+    constness,\n+    asyncness,\n+    abi\n+});\n+\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -897,7 +902,7 @@ impl_stable_hash_for!(enum hir::Item_ {\n     ItemUse(path, use_kind),\n     ItemStatic(ty, mutability, body_id),\n     ItemConst(ty, body_id),\n-    ItemFn(fn_decl, unsafety, constness, abi, generics, body_id),\n+    ItemFn(fn_decl, header, generics, body_id),\n     ItemMod(module),\n     ItemForeignMod(foreign_mod),\n     ItemGlobalAsm(global_asm),\n@@ -1100,6 +1105,10 @@ impl_stable_hash_for!(enum hir::Unsafety {\n     Normal\n });\n \n+impl_stable_hash_for!(enum hir::IsAsync {\n+    Async,\n+    NotAsync\n+});\n \n impl_stable_hash_for!(enum hir::Constness {\n     Const,"}, {"sha": "0f4603be39d326612d3a782abd69613853cc4ffd", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -409,6 +409,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n });\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n+    Async,\n     DotFill,\n     QuestionMark,\n     ExistentialReturnType,"}, {"sha": "95829346ede8ff07d009ec34c5c3c41530a7c688", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -238,8 +238,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n             if let hir_map::NodeItem(item) = *node {\n-                let reachable = if let hir::ItemFn(.., abi, _, _) = item.node {\n-                    abi != Abi::Rust\n+                let reachable = if let hir::ItemFn(_, header, ..) = item.node {\n+                    header.abi != Abi::Rust\n                 } else {\n                     false\n                 };"}, {"sha": "efb3eecd691f2dc47d3930af098c0b49166ff05b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -476,7 +476,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+            hir::ItemFn(ref decl, _, ref generics, _) => {\n                 self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });"}, {"sha": "78406e88c75720756e3c19e7c1eae99c155e6d43", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -10,12 +10,11 @@\n \n use rustc::middle::allocator::AllocatorKind;\n use rustc_errors;\n-use rustc_target::spec::abi::Abi;\n use syntax::ast::{Attribute, Crate, LitKind, StrStyle};\n-use syntax::ast::{Arg, Constness, Generics, Mac, Mutability, Ty, Unsafety};\n+use syntax::ast::{Arg, FnHeader, Generics, Mac, Mutability, Ty, Unsafety};\n use syntax::ast::{self, Expr, Ident, Item, ItemKind, TyKind, VisibilityKind};\n use syntax::attr;\n-use syntax::codemap::{dummy_spanned, respan};\n+use syntax::codemap::respan;\n use syntax::codemap::{ExpnInfo, MacroAttribute, NameAndSpan};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::base::Resolver;\n@@ -152,9 +151,10 @@ impl<'a> AllocFnFactory<'a> {\n         let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n         let kind = ItemKind::Fn(\n             self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n-            Unsafety::Unsafe,\n-            dummy_spanned(Constness::NotConst),\n-            Abi::Rust,\n+            FnHeader {\n+                unsafety: Unsafety::Unsafe,\n+                ..FnHeader::default()\n+            },\n             Generics::default(),\n             self.cx.block_expr(output_expr),\n         );"}, {"sha": "38ecbf5ca8ada5000191815c96870f7980a02c5a", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -712,8 +712,8 @@ impl<'a> fold::Folder for ReplaceBodyWithLoop<'a> {\n     fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n         let is_const = match i {\n             ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n-            ast::ItemKind::Fn(ref decl, _, ref constness, _, _, _) =>\n-                constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            ast::ItemKind::Fn(ref decl, ref header, _, _) =>\n+                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n         self.run(is_const, |s| fold::noop_fold_item_kind(i, s))\n@@ -722,8 +722,8 @@ impl<'a> fold::Folder for ReplaceBodyWithLoop<'a> {\n     fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n         let is_const = match i.node {\n             ast::TraitItemKind::Const(..) => true,\n-            ast::TraitItemKind::Method(ast::MethodSig { ref decl, ref constness, .. }, _) =>\n-                constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            ast::TraitItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n+                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n         self.run(is_const, |s| fold::noop_fold_trait_item(i, s))\n@@ -732,8 +732,8 @@ impl<'a> fold::Folder for ReplaceBodyWithLoop<'a> {\n     fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n         let is_const = match i.node {\n             ast::ImplItemKind::Const(..) => true,\n-            ast::ImplItemKind::Method(ast::MethodSig { ref decl, ref constness, .. }, _) =>\n-                constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n+            ast::ImplItemKind::Method(ast::MethodSig { ref decl, ref header, .. }, _) =>\n+                header.constness.node == ast::Constness::Const || Self::should_ignore_fn(decl),\n             _ => false,\n         };\n         self.run(is_const, |s| fold::noop_fold_impl_item(i, s))"}, {"sha": "1b5361187f36a4b016903512588ebb0a0f7f3152", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -284,9 +284,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n                     _ => (),\n                 }\n             }\n-            FnKind::ItemFn(name, _, _, _, abi, _, attrs) => {\n+            FnKind::ItemFn(name, _, header, _, attrs) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n-                if abi != Abi::Rust && attr::find_by_name(attrs, \"no_mangle\").is_some() {\n+                if header.abi != Abi::Rust && attr::find_by_name(attrs, \"no_mangle\").is_some() {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", &name.as_str(), Some(span))"}, {"sha": "d6120ab207924b2206a05eab6d4f45e29c716bd9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -259,12 +259,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n                 span: Span,\n                 _: ast::NodeId) {\n         match fk {\n-            FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, ..) => {\n+            FnKind::ItemFn(_, _, hir::FnHeader { unsafety: hir::Unsafety::Unsafe, .. }, ..) => {\n                 self.report_unsafe(cx, span, \"declaration of an `unsafe` function\")\n             }\n \n             FnKind::Method(_, sig, ..) => {\n-                if sig.unsafety == hir::Unsafety::Unsafe {\n+                if sig.header.unsafety == hir::Unsafety::Unsafe {\n                     self.report_unsafe(cx, span, \"implementation of an `unsafe` method\")\n                 }\n             }\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n         if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) = item.node {\n-            if sig.unsafety == hir::Unsafety::Unsafe {\n+            if sig.header.unsafety == hir::Unsafety::Unsafe {\n                 self.report_unsafe(cx, item.span, \"declaration of an `unsafe` method\")\n             }\n         }"}, {"sha": "ce270006a9d0ad187d1a1e213363238804dbc545", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -917,7 +917,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n                     FnData {\n-                        constness: sig.constness,\n+                        constness: sig.header.constness,\n                         arg_names: self.encode_fn_arg_names_for_body(body),\n                         sig: self.lazy(&tcx.fn_sig(def_id)),\n                     }\n@@ -941,7 +941,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     let needs_inline = (generics.requires_monomorphization(self.tcx) ||\n                                         tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                                         !self.metadata_output_only();\n-                    let is_const_fn = sig.constness == hir::Constness::Const;\n+                    let is_const_fn = sig.header.constness == hir::Constness::Const;\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     needs_inline || is_const_fn || always_encode_mir\n                 },\n@@ -1045,9 +1045,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     self.encode_rendered_const_for_body(body_id)\n                 )\n             }\n-            hir::ItemFn(_, _, constness, .., body) => {\n+            hir::ItemFn(_, header, .., body) => {\n                 let data = FnData {\n-                    constness,\n+                    constness: header.constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n                     sig: self.lazy(&tcx.fn_sig(def_id)),\n                 };\n@@ -1235,7 +1235,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     self.encode_optimized_mir(def_id)\n                 }\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n-                hir::ItemFn(_, _, constness, ..) => {\n+                hir::ItemFn(_, header, ..) => {\n                     let generics = tcx.generics_of(def_id);\n                     let has_types = generics.params.iter().any(|param| match param.kind {\n                         ty::GenericParamDefKind::Type { .. } => true,\n@@ -1245,7 +1245,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                         (has_types || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                             !self.metadata_output_only();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                    if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n+                    if needs_inline\n+                        || header.constness == hir::Constness::Const\n+                        || always_encode_mir\n+                    {\n                         self.encode_optimized_mir(def_id)\n                     } else {\n                         None"}, {"sha": "00e064fbb4717ce541a61a629ab05e021bfd8367", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -380,10 +380,10 @@ fn is_enclosed(tcx: TyCtxt,\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(hir::map::NodeItem(&hir::Item {\n-            node: hir::ItemFn(_, fn_unsafety, _, _, _, _),\n+            node: hir::ItemFn(_, header, _, _),\n             ..\n         })) = tcx.hir.find(parent_id) {\n-            match fn_unsafety {\n+            match header.unsafety {\n                 hir::Unsafety::Unsafe => Some((\"fn\".to_string(), parent_id)),\n                 hir::Unsafety::Normal => None,\n             }"}, {"sha": "25187032fb47365bbb393100237b54893e0cc1e5", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -87,6 +87,13 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n+    fn check_trait_fn_not_async(&self, span: Span, asyncness: IsAsync) {\n+        if asyncness.is_async() {\n+            struct_span_err!(self.session, span, E0706,\n+                             \"trait fns cannot be declared `async`\").emit()\n+        }\n+    }\n+\n     fn check_trait_fn_not_const(&self, constness: Spanned<Constness>) {\n         match constness.node {\n             Constness::Const => {\n@@ -257,7 +264,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 for impl_item in impl_items {\n                     self.invalid_visibility(&impl_item.vis, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                        self.check_trait_fn_not_const(sig.constness);\n+                        self.check_trait_fn_not_const(sig.header.constness);\n+                        self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness);\n                     }\n                 }\n             }\n@@ -309,7 +317,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n-                        self.check_trait_fn_not_const(sig.constness);\n+                        self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness);\n+                        self.check_trait_fn_not_const(sig.header.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, mut_ident| {\n                                 if mut_ident {"}, {"sha": "f1ec3371c3b9ab0400bd0b3a60daecff1497dcd3", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -310,4 +310,5 @@ register_diagnostics! {\n     E0666, // nested `impl Trait` is illegal\n     E0667, // `impl Trait` in projections\n     E0696, // `continue` pointing to a labeled block\n+    E0706, // `async fn` in trait\n }"}, {"sha": "792edf4d12b1d25a3cc28ea7463ee30a0bd6852b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -55,7 +55,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n use syntax::attr;\n-use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n+use syntax::ast::{Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n@@ -746,15 +746,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 function_kind: FnKind<'tcx>,\n                 declaration: &'tcx FnDecl,\n                 _: Span,\n-                node_id: NodeId) {\n-        let rib_kind = match function_kind {\n-            FnKind::ItemFn(..) => {\n-                ItemRibKind\n-            }\n-            FnKind::Method(_, _, _, _) => {\n-                TraitOrImplItemRibKind\n-            }\n-            FnKind::Closure(_) => ClosureRibKind(node_id),\n+                node_id: NodeId)\n+    {\n+        let (rib_kind, asyncness) = match function_kind {\n+            FnKind::ItemFn(_, ref header, ..) =>\n+                (ItemRibKind, header.asyncness),\n+            FnKind::Method(_, ref sig, _, _) =>\n+                (TraitOrImplItemRibKind, sig.header.asyncness),\n+            FnKind::Closure(_) =>\n+                // Async closures aren't resolved through `visit_fn`-- they're\n+                // processed separately\n+                (ClosureRibKind(node_id), IsAsync::NotAsync),\n         };\n \n         // Create a value rib for the function.\n@@ -774,7 +776,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         }\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n-        // Resolve the function body.\n+        // Resolve the function body, potentially inside the body of an async closure\n+        if let IsAsync::Async(async_closure_id) = asyncness {\n+            let rib_kind = ClosureRibKind(async_closure_id);\n+            self.ribs[ValueNS].push(Rib::new(rib_kind));\n+            self.label_ribs.push(Rib::new(rib_kind));\n+        }\n+\n         match function_kind {\n             FnKind::ItemFn(.., body) |\n             FnKind::Method(.., body) => {\n@@ -785,6 +793,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             }\n         };\n \n+        // Leave the body of the async closure\n+        if asyncness.is_async() {\n+            self.label_ribs.pop();\n+            self.ribs[ValueNS].pop();\n+        }\n+\n         debug!(\"(resolving function) leaving function\");\n \n         self.label_ribs.pop();\n@@ -1475,14 +1489,34 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n                                  |resolver, span, error| resolve_error(resolver, span, error))\n     }\n \n-    fn resolve_str_path(&mut self, span: Span, crate_root: Option<&str>,\n-                        components: &[&str], is_value: bool) -> hir::Path {\n+    fn resolve_str_path(\n+        &mut self,\n+        span: Span,\n+        crate_root: Option<&str>,\n+        components: &[&str],\n+        args: Option<P<hir::GenericArgs>>,\n+        is_value: bool\n+    ) -> hir::Path {\n+        let mut segments = iter::once(keywords::CrateRoot.name())\n+            .chain(\n+                crate_root.into_iter()\n+                    .chain(components.iter().cloned())\n+                    .map(Symbol::intern)\n+            ).map(hir::PathSegment::from_name).collect::<Vec<_>>();\n+\n+        if let Some(args) = args {\n+            let name = segments.last().unwrap().name;\n+            *segments.last_mut().unwrap() = hir::PathSegment {\n+                name,\n+                args: Some(args),\n+                infer_types: true,\n+            };\n+        }\n+\n         let mut path = hir::Path {\n             span,\n             def: Def::Err,\n-            segments: iter::once(keywords::CrateRoot.name()).chain({\n-                crate_root.into_iter().chain(components.iter().cloned()).map(Symbol::intern)\n-            }).map(hir::PathSegment::from_name).collect(),\n+            segments: segments.into(),\n         };\n \n         self.resolve_hir_path(&mut path, is_value);\n@@ -2058,9 +2092,9 @@ impl<'a> Resolver<'a> {\n             ItemKind::Ty(_, ref generics) |\n             ItemKind::Struct(_, ref generics) |\n             ItemKind::Union(_, ref generics) |\n-            ItemKind::Fn(.., ref generics, _) => {\n+            ItemKind::Fn(_, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n+                                         |this| visit::walk_item(this, item));\n             }\n \n             ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n@@ -2374,7 +2408,7 @@ impl<'a> Resolver<'a> {\n                                                 visit::walk_impl_item(this, impl_item)\n                                             );\n                                         }\n-                                        ImplItemKind::Method(_, _) => {\n+                                        ImplItemKind::Method(..) => {\n                                             // If this is a trait impl, ensure the method\n                                             // exists in trait\n                                             this.check_trait_item(impl_item.ident,\n@@ -3888,6 +3922,49 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n                 self.current_type_ascription.pop();\n             }\n+            // Resolve the body of async exprs inside the async closure to which they desugar\n+            ExprKind::Async(_, async_closure_id, ref block) => {\n+                let rib_kind = ClosureRibKind(async_closure_id);\n+                self.ribs[ValueNS].push(Rib::new(rib_kind));\n+                self.label_ribs.push(Rib::new(rib_kind));\n+                self.visit_block(&block);\n+                self.label_ribs.pop();\n+                self.ribs[ValueNS].pop();\n+            }\n+            // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n+            // resolve the arguments within the proper scopes so that usages of them inside the\n+            // closure are detected as upvars rather than normal closure arg usages.\n+            ExprKind::Closure(\n+                _, IsAsync::Async(inner_closure_id), _, ref fn_decl, ref body, _span) =>\n+            {\n+                let rib_kind = ClosureRibKind(expr.id);\n+                self.ribs[ValueNS].push(Rib::new(rib_kind));\n+                self.label_ribs.push(Rib::new(rib_kind));\n+                // Resolve arguments:\n+                let mut bindings_list = FxHashMap();\n+                for argument in &fn_decl.inputs {\n+                    self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+                    self.visit_ty(&argument.ty);\n+                }\n+                // No need to resolve return type-- the outer closure return type is\n+                // FunctionRetTy::Default\n+\n+                // Now resolve the inner closure\n+                {\n+                    let rib_kind = ClosureRibKind(inner_closure_id);\n+                    self.ribs[ValueNS].push(Rib::new(rib_kind));\n+                    self.label_ribs.push(Rib::new(rib_kind));\n+                    // No need to resolve arguments: the inner closure has none.\n+                    // Resolve the return type:\n+                    visit::walk_fn_ret_ty(self, &fn_decl.output);\n+                    // Resolve the body\n+                    self.visit_expr(body);\n+                    self.label_ribs.pop();\n+                    self.ribs[ValueNS].pop();\n+                }\n+                self.label_ribs.pop();\n+                self.ribs[ValueNS].pop();\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "262c0e40abc549788d487b01c192a83e6bdbfd33", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -1555,7 +1555,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     }\n                 }\n             }\n-            ast::ExprKind::Closure(_, _, ref decl, ref body, _fn_decl_span) => {\n+            ast::ExprKind::Closure(_, _, _, ref decl, ref body, _fn_decl_span) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());\n "}, {"sha": "9f2ca20276cdc00910a12e149932f41fc88fb0cc", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -380,17 +380,20 @@ impl Sig for ast::Item {\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, header, ref generics, _) => {\n                 let mut text = String::new();\n-                if constness.node == ast::Constness::Const {\n+                if header.constness.node == ast::Constness::Const {\n                     text.push_str(\"const \");\n                 }\n-                if unsafety == ast::Unsafety::Unsafe {\n+                if header.asyncness.is_async() {\n+                    text.push_str(\"async \");\n+                }\n+                if header.unsafety == ast::Unsafety::Unsafe {\n                     text.push_str(\"unsafe \");\n                 }\n-                if abi != ::rustc_target::spec::abi::Abi::Rust {\n+                if header.abi != ::rustc_target::spec::abi::Abi::Rust {\n                     text.push_str(\"extern\");\n-                    text.push_str(&abi.to_string());\n+                    text.push_str(&header.abi.to_string());\n                     text.push(' ');\n                 }\n                 text.push_str(\"fn \");\n@@ -914,15 +917,18 @@ fn make_method_signature(\n ) -> Result {\n     // FIXME code dup with function signature\n     let mut text = String::new();\n-    if m.constness.node == ast::Constness::Const {\n+    if m.header.constness.node == ast::Constness::Const {\n         text.push_str(\"const \");\n     }\n-    if m.unsafety == ast::Unsafety::Unsafe {\n+    if m.header.asyncness.is_async() {\n+        text.push_str(\"async \");\n+    }\n+    if m.header.unsafety == ast::Unsafety::Unsafe {\n         text.push_str(\"unsafe \");\n     }\n-    if m.abi != ::rustc_target::spec::abi::Abi::Rust {\n+    if m.header.abi != ::rustc_target::spec::abi::Abi::Rust {\n         text.push_str(\"extern\");\n-        text.push_str(&m.abi.to_string());\n+        text.push_str(&m.header.abi.to_string());\n         text.push(' ');\n     }\n     text.push_str(\"fn \");"}, {"sha": "f149a9fe57140637b649cba5b9c1b76ac10670ad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -1164,7 +1164,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                     }\n \n                     if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n-                        if let Item_::ItemFn(_, _, _, _, ref generics, _) = item.node {\n+                        if let Item_::ItemFn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,"}, {"sha": "824346dab94fc326e49763054fe50bd764abbe7a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -1181,13 +1181,13 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeTraitItem(&hir::TraitItem { node: TraitItemKind::Method(ref sig, _), .. }) |\n-        NodeImplItem(&hir::ImplItem { node: ImplItemKind::Method(ref sig, _), .. }) => {\n-            AstConv::ty_of_fn(&icx, sig.unsafety, sig.abi, &sig.decl)\n+        NodeTraitItem(hir::TraitItem { node: TraitItemKind::Method(sig, _), .. }) |\n+        NodeImplItem(hir::ImplItem { node: ImplItemKind::Method(sig, _), .. }) => {\n+            AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl)\n         }\n \n-        NodeItem(&hir::Item { node: ItemFn(ref decl, unsafety, _, abi, _, _), .. }) => {\n-            AstConv::ty_of_fn(&icx, unsafety, abi, decl)\n+        NodeItem(hir::Item { node: ItemFn(decl, header, _, _), .. }) => {\n+            AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl)\n         }\n \n         NodeForeignItem(&hir::ForeignItem { node: ForeignItemFn(ref fn_decl, _, _), .. }) => {"}, {"sha": "ad7389db729ec7f3151300a6ecc5f24c933a23e1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -198,9 +198,12 @@ fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n     clean::Function {\n         decl: (did, sig).clean(cx),\n         generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n-        unsafety: sig.unsafety(),\n-        constness,\n-        abi: sig.abi(),\n+        header: hir::FnHeader {\n+            unsafety: sig.unsafety(),\n+            abi: sig.abi(),\n+            constness,\n+            asyncness: hir::IsAsync::NotAsync,\n+        }\n     }\n }\n "}, {"sha": "057e7f3ab843354d88dc3d4f15fe261cee302087", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -18,8 +18,8 @@ pub use self::SelfTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::Visibility::{Public, Inherited};\n \n-use syntax;\n use rustc_target::spec::abi::Abi;\n+use syntax;\n use syntax::ast::{self, AttrStyle, NodeId, Ident};\n use syntax::attr;\n use syntax::codemap::{dummy_spanned, Spanned};\n@@ -2074,10 +2074,8 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Method {\n     pub generics: Generics,\n-    pub unsafety: hir::Unsafety,\n-    pub constness: hir::Constness,\n     pub decl: FnDecl,\n-    pub abi: Abi,\n+    pub header: hir::FnHeader,\n }\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId) {\n@@ -2088,28 +2086,23 @@ impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId)\n         Method {\n             decl,\n             generics,\n-            unsafety: self.0.unsafety,\n-            constness: self.0.constness,\n-            abi: self.0.abi\n+            header: self.0.header,\n         }\n     }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TyMethod {\n-    pub unsafety: hir::Unsafety,\n+    pub header: hir::FnHeader,\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub abi: Abi,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub unsafety: hir::Unsafety,\n-    pub constness: hir::Constness,\n-    pub abi: Abi,\n+    pub header: hir::FnHeader,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -2128,9 +2121,7 @@ impl Clean<Item> for doctree::Function {\n             inner: FunctionItem(Function {\n                 decl,\n                 generics,\n-                unsafety: self.unsafety,\n-                constness: self.constness,\n-                abi: self.abi,\n+                header: self.header,\n             }),\n         }\n     }\n@@ -2359,10 +2350,9 @@ impl Clean<Item> for hir::TraitItem {\n                     (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                 });\n                 TyMethodItem(TyMethod {\n-                    unsafety: sig.unsafety.clone(),\n+                    header: sig.header,\n                     decl,\n                     generics,\n-                    abi: sig.abi\n                 })\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -2461,18 +2451,25 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                         hir::Constness::NotConst\n                     };\n                     MethodItem(Method {\n-                        unsafety: sig.unsafety(),\n                         generics,\n                         decl,\n-                        abi: sig.abi(),\n-                        constness,\n+                        header: hir::FnHeader {\n+                            unsafety: sig.unsafety(),\n+                            abi: sig.abi(),\n+                            constness,\n+                            asyncness: hir::IsAsync::NotAsync,\n+                        }\n                     })\n                 } else {\n                     TyMethodItem(TyMethod {\n-                        unsafety: sig.unsafety(),\n                         generics,\n                         decl,\n-                        abi: sig.abi(),\n+                        header: hir::FnHeader {\n+                            unsafety: sig.unsafety(),\n+                            abi: sig.abi(),\n+                            constness: hir::Constness::NotConst,\n+                            asyncness: hir::IsAsync::NotAsync,\n+                        }\n                     })\n                 }\n             }\n@@ -3697,9 +3694,9 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy {\n         });\n         BareFunctionDecl {\n             unsafety: self.unsafety,\n+            abi: self.abi,\n             decl,\n             generic_params,\n-            abi: self.abi,\n         }\n     }\n }\n@@ -3994,7 +3991,7 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n         let mut items = self.items.clean(cx);\n         for item in &mut items {\n             if let ForeignFunctionItem(ref mut f) = item.inner {\n-                f.abi = self.abi;\n+                f.header.abi = self.abi;\n             }\n         }\n         items\n@@ -4011,9 +4008,12 @@ impl Clean<Item> for hir::ForeignItem {\n                 ForeignFunctionItem(Function {\n                     decl,\n                     generics,\n-                    unsafety: hir::Unsafety::Unsafe,\n-                    abi: Abi::Rust,\n-                    constness: hir::Constness::NotConst,\n+                    header: hir::FnHeader {\n+                        unsafety: hir::Unsafety::Unsafe,\n+                        abi: Abi::Rust,\n+                        constness: hir::Constness::NotConst,\n+                        asyncness: hir::IsAsync::NotAsync,\n+                    },\n                 })\n             }\n             hir::ForeignItemStatic(ref ty, mutbl) => {"}, {"sha": "0807db2997626fadc34b8a4de1432792a06cf4e6", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -13,7 +13,6 @@\n pub use self::StructType::*;\n pub use self::TypeBound::*;\n \n-use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n@@ -149,11 +148,9 @@ pub struct Function {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub unsafety: hir::Unsafety,\n-    pub constness: hir::Constness,\n+    pub header: hir::FnHeader,\n     pub whence: Span,\n     pub generics: hir::Generics,\n-    pub abi: abi::Abi,\n     pub body: hir::BodyId,\n }\n "}, {"sha": "2377354b85f6bf587e41d17a2cab2ea8db90afa4", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -39,6 +39,10 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n /// with a space after it.\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n+/// Similarly to VisSpace, this structure is used to render a function asyncness\n+/// with a space after it.\n+#[derive(Copy, Clone)]\n+pub struct AsyncSpace(pub hir::IsAsync);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n@@ -962,6 +966,15 @@ impl fmt::Display for ConstnessSpace {\n     }\n }\n \n+impl fmt::Display for AsyncSpace {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {\n+            hir::IsAsync::Async => write!(f, \"async \"),\n+            hir::IsAsync::NotAsync => Ok(()),\n+        }\n+    }\n+}\n+\n impl fmt::Display for clean::Import {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "f7be4f58dfb577e2bcd55f473f66695e160dd580", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -62,13 +62,12 @@ use rustc::middle::stability;\n use rustc::hir;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::flock;\n-use rustc_target::spec::abi;\n \n use clean::{self, AttributesExt, GetDefId, SelfTy, Mutability};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n-use html::format::{ConstnessSpace};\n+use html::format::{AsyncSpace, ConstnessSpace};\n use html::format::{GenericBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n@@ -2405,7 +2404,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n                 let unsafety_flag = match myitem.inner {\n                     clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n-                    if func.unsafety == hir::Unsafety::Unsafe => {\n+                    if func.header.unsafety == hir::Unsafety::Unsafe => {\n                         \"<a title='unsafe function' href='#'><sup>\u26a0</sup></a>\"\n                     }\n                     _ => \"\",\n@@ -2575,21 +2574,24 @@ fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n-    let name_len = format!(\"{}{}{}{:#}fn {}{:#}\",\n+    let name_len = format!(\"{}{}{}{}{:#}fn {}{:#}\",\n                            VisSpace(&it.visibility),\n-                           ConstnessSpace(f.constness),\n-                           UnsafetySpace(f.unsafety),\n-                           AbiSpace(f.abi),\n+                           ConstnessSpace(f.header.constness),\n+                           UnsafetySpace(f.header.unsafety),\n+                           AsyncSpace(f.header.asyncness),\n+                           AbiSpace(f.header.abi),\n                            it.name.as_ref().unwrap(),\n                            f.generics).len();\n     write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it)?)?;\n     render_attributes(w, it)?;\n     write!(w,\n-           \"{vis}{constness}{unsafety}{abi}fn {name}{generics}{decl}{where_clause}</pre>\",\n+           \"{vis}{constness}{unsafety}{asyncness}{abi}fn \\\n+           {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(&it.visibility),\n-           constness = ConstnessSpace(f.constness),\n-           unsafety = UnsafetySpace(f.unsafety),\n-           abi = AbiSpace(f.abi),\n+           constness = ConstnessSpace(f.header.constness),\n+           unsafety = UnsafetySpace(f.header.unsafety),\n+           asyncness = AsyncSpace(f.header.asyncness),\n+           abi = AbiSpace(f.header.abi),\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n            where_clause = WhereClause { gens: &f.generics, indent: 0, end_newline: true },\n@@ -2999,9 +3001,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                      parent: ItemType) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter,\n               meth: &clean::Item,\n-              unsafety: hir::Unsafety,\n-              constness: hir::Constness,\n-              abi: abi::Abi,\n+              header: hir::FnHeader,\n               g: &clean::Generics,\n               d: &clean::FnDecl,\n               link: AssocItemLink,\n@@ -3024,11 +3024,12 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                 href(did).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n             }\n         };\n-        let mut head_len = format!(\"{}{}{}{:#}fn {}{:#}\",\n+        let mut head_len = format!(\"{}{}{}{}{:#}fn {}{:#}\",\n                                    VisSpace(&meth.visibility),\n-                                   ConstnessSpace(constness),\n-                                   UnsafetySpace(unsafety),\n-                                   AbiSpace(abi),\n+                                   ConstnessSpace(header.constness),\n+                                   UnsafetySpace(header.unsafety),\n+                                   AsyncSpace(header.asyncness),\n+                                   AbiSpace(header.abi),\n                                    name,\n                                    *g).len();\n         let (indent, end_newline) = if parent == ItemType::Trait {\n@@ -3038,12 +3039,13 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n             (0, true)\n         };\n         render_attributes(w, meth)?;\n-        write!(w, \"{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n+        write!(w, \"{}{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                VisSpace(&meth.visibility),\n-               ConstnessSpace(constness),\n-               UnsafetySpace(unsafety),\n-               AbiSpace(abi),\n+               ConstnessSpace(header.constness),\n+               UnsafetySpace(header.unsafety),\n+               AsyncSpace(header.asyncness),\n+               AbiSpace(header.abi),\n                href = href,\n                name = name,\n                generics = *g,\n@@ -3061,12 +3063,10 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n     match item.inner {\n         clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n-            method(w, item, m.unsafety, hir::Constness::NotConst,\n-                   m.abi, &m.generics, &m.decl, link, parent)\n+            method(w, item, m.header, &m.generics, &m.decl, link, parent)\n         }\n         clean::MethodItem(ref m) => {\n-            method(w, item, m.unsafety, m.constness,\n-                   m.abi, &m.generics, &m.decl, link, parent)\n+            method(w, item, m.header, &m.generics, &m.decl, link, parent)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n             assoc_const(w, item, ty, default.as_ref(), link)"}, {"sha": "6bf1931e468dece633fd29456b204a28fe24cf35", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -13,7 +13,6 @@\n \n use std::mem;\n \n-use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n@@ -172,9 +171,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n \n     pub fn visit_fn(&mut self, item: &hir::Item,\n                     name: ast::Name, fd: &hir::FnDecl,\n-                    unsafety: &hir::Unsafety,\n-                    constness: hir::Constness,\n-                    abi: &abi::Abi,\n+                    header: hir::FnHeader,\n                     gen: &hir::Generics,\n                     body: hir::BodyId) -> Function {\n         debug!(\"Visiting fn\");\n@@ -188,9 +185,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             name,\n             whence: item.span,\n             generics: gen.clone(),\n-            unsafety: *unsafety,\n-            constness,\n-            abi: *abi,\n+            header,\n             body,\n         }\n     }\n@@ -463,9 +458,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 om.structs.push(self.visit_variant_data(item, name, sd, gen)),\n             hir::ItemUnion(ref sd, ref gen) =>\n                 om.unions.push(self.visit_union_data(item, name, sd, gen)),\n-            hir::ItemFn(ref fd, ref unsafety, constness, ref abi, ref gen, body) =>\n-                om.fns.push(self.visit_fn(item, name, &**fd, unsafety,\n-                                          constness, abi, gen, body)),\n+            hir::ItemFn(ref fd, header, ref gen, body) =>\n+                om.fns.push(self.visit_fn(item, name, &**fd, header, gen, body)),\n             hir::ItemTy(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),"}, {"sha": "2da775fdc949e20f0be1cefcfddbe2333881aa26", "filename": "src/libstd/future.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Asynchronous values.\n+\n+use core::cell::Cell;\n+use core::marker::Unpin;\n+use core::mem::PinMut;\n+use core::option::Option;\n+use core::ptr::NonNull;\n+use core::task::{self, Poll};\n+use core::ops::{Drop, Generator, GeneratorState};\n+\n+#[doc(inline)]\n+pub use core::future::*;\n+\n+/// Wrap a future in a generator.\n+///\n+/// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n+/// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+pub fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T::Return> {\n+    GenFuture(x)\n+}\n+\n+/// A wrapper around generators used to implement `Future` for `async`/`await` code.\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+struct GenFuture<T: Generator<Yield = ()>>(T);\n+\n+// We rely on the fact that async/await futures are immovable in order to create\n+// self-referential borrows in the underlying generator.\n+impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n+    type Output = T::Return;\n+    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        set_task_cx(cx, || match unsafe { PinMut::get_mut(self).0.resume() } {\n+            GeneratorState::Yielded(()) => Poll::Pending,\n+            GeneratorState::Complete(x) => Poll::Ready(x),\n+        })\n+    }\n+}\n+\n+thread_local! {\n+    static TLS_CX: Cell<Option<NonNull<task::Context<'static>>>> = Cell::new(None);\n+}\n+\n+struct SetOnDrop(Option<NonNull<task::Context<'static>>>);\n+\n+impl Drop for SetOnDrop {\n+    fn drop(&mut self) {\n+        TLS_CX.with(|tls_cx| {\n+            tls_cx.set(self.0.take());\n+        });\n+    }\n+}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+/// Sets the thread-local task context used by async/await futures.\n+pub fn set_task_cx<F, R>(cx: &mut task::Context, f: F) -> R\n+where\n+    F: FnOnce() -> R\n+{\n+    let old_cx = TLS_CX.with(|tls_cx| {\n+        tls_cx.replace(NonNull::new(\n+            cx\n+                as *mut task::Context\n+                as *mut ()\n+                as *mut task::Context<'static>\n+        ))\n+    });\n+    let _reset_cx = SetOnDrop(old_cx);\n+    f()\n+}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+/// Retrieves the thread-local task context used by async/await futures.\n+///\n+/// This function acquires exclusive access to the task context.\n+///\n+/// Panics if no task has been set or if the task context has already been\n+/// retrived by a surrounding call to get_task_cx.\n+pub fn get_task_cx<F, R>(f: F) -> R\n+where\n+    F: FnOnce(&mut task::Context) -> R\n+{\n+    let cx_ptr = TLS_CX.with(|tls_cx| {\n+        // Clear the entry so that nested `with_get_cx` calls\n+        // will fail or set their own value.\n+        tls_cx.replace(None)\n+    });\n+    let _reset_cx = SetOnDrop(cx_ptr);\n+\n+    let mut cx_ptr = cx_ptr.expect(\n+        \"TLS task::Context not set. This is a rustc bug. \\\n+        Please file an issue on https://github.com/rust-lang/rust.\");\n+    unsafe { f(cx_ptr.as_mut()) }\n+}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+/// Polls a future in the current thread-local task context.\n+pub fn poll_in_task_cx<F>(f: &mut PinMut<F>) -> Poll<F::Output>\n+where\n+    F: Future\n+{\n+    get_task_cx(|cx| f.reborrow().poll(cx))\n+}"}, {"sha": "caad924ea5b5f0af581e0db5a1041bd99c811df5", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -263,6 +263,7 @@\n #![feature(fn_traits)]\n #![feature(fnbox)]\n #![feature(futures_api)]\n+#![feature(generator_trait)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(integer_atomics)]\n@@ -462,22 +463,6 @@ pub use core::u128;\n #[stable(feature = \"core_hint\", since = \"1.27.0\")]\n pub use core::hint;\n \n-#[unstable(feature = \"futures_api\",\n-           reason = \"futures in libcore are unstable\",\n-           issue = \"50547\")]\n-pub mod task {\n-    //! Types and Traits for working with asynchronous tasks.\n-    #[doc(inline)]\n-    pub use core::task::*;\n-    #[doc(inline)]\n-    pub use alloc_crate::task::*;\n-}\n-\n-#[unstable(feature = \"futures_api\",\n-           reason = \"futures in libcore are unstable\",\n-           issue = \"50547\")]\n-pub use core::future;\n-\n pub mod f32;\n pub mod f64;\n \n@@ -499,6 +484,22 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n+#[unstable(feature = \"futures_api\",\n+           reason = \"futures in libcore are unstable\",\n+           issue = \"50547\")]\n+pub mod task {\n+    //! Types and Traits for working with asynchronous tasks.\n+    #[doc(inline)]\n+    pub use core::task::*;\n+    #[doc(inline)]\n+    pub use alloc_crate::task::*;\n+}\n+\n+#[unstable(feature = \"futures_api\",\n+           reason = \"futures in libcore are unstable\",\n+           issue = \"50547\")]\n+pub mod future;\n+\n // Platform-abstraction modules\n #[macro_use]\n mod sys_common;"}, {"sha": "a856e7736fbaab1e2882827dcbabb77a4b15d55b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -213,6 +213,25 @@ macro_rules! eprintln {\n     ($fmt:expr, $($arg:tt)*) => (eprint!(concat!($fmt, \"\\n\"), $($arg)*));\n }\n \n+#[macro_export]\n+#[unstable(feature = \"await_macro\", issue = \"50547\")]\n+#[allow_internal_unstable]\n+#[allow_internal_unsafe]\n+macro_rules! await {\n+    ($e:expr) => { {\n+        let mut pinned = $e;\n+        let mut pinned = unsafe { $crate::mem::PinMut::new_unchecked(&mut pinned) };\n+        loop {\n+            match $crate::future::poll_in_task_cx(&mut pinned) {\n+                // FIXME(cramertj) prior to stabilizing await, we have to ensure that this\n+                // can't be used to create a generator on stable via `|| await!()`.\n+                $crate::task::Poll::Pending => yield,\n+                $crate::task::Poll::Ready(x) => break x,\n+            }\n+        }\n+    } }\n+}\n+\n /// A macro to select an event from a number of receivers.\n ///\n /// This macro is used to wait for the first event to occur on a number of"}, {"sha": "a57a9b95e5f776f3ad616aec9bc8de95cd7573a5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -17,7 +17,7 @@ pub use util::ThinVec;\n pub use util::parser::ExprPrecedence;\n \n use syntax_pos::{Span, DUMMY_SP};\n-use codemap::{respan, Spanned};\n+use codemap::{dummy_spanned, respan, Spanned};\n use rustc_target::spec::abi::Abi;\n use ext::hygiene::{Mark, SyntaxContext};\n use print::pprust;\n@@ -987,6 +987,7 @@ impl Expr {\n             ExprKind::Closure(..) => ExprPrecedence::Closure,\n             ExprKind::Block(..) => ExprPrecedence::Block,\n             ExprKind::Catch(..) => ExprPrecedence::Catch,\n+            ExprKind::Async(..) => ExprPrecedence::Async,\n             ExprKind::Assign(..) => ExprPrecedence::Assign,\n             ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n             ExprKind::Field(..) => ExprPrecedence::Field,\n@@ -1094,9 +1095,18 @@ pub enum ExprKind {\n     /// A closure (for example, `move |a, b, c| a + b + c`)\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    Closure(CaptureBy, Movability, P<FnDecl>, P<Expr>, Span),\n+    Closure(CaptureBy, IsAsync, Movability, P<FnDecl>, P<Expr>, Span),\n     /// A block (`'label: { ... }`)\n     Block(P<Block>, Option<Label>),\n+    /// An async block (`async move { ... }`)\n+    ///\n+    /// The `NodeId` is the `NodeId` for the closure that results from\n+    /// desugaring an async block, just like the NodeId field in the\n+    /// `IsAsync` enum. This is necessary in order to create a def for the\n+    /// closure which can be used as a parent of any child defs. Defs\n+    /// created during lowering cannot be made the parent of any other\n+    /// preexisting defs.\n+    Async(CaptureBy, NodeId, P<Block>),\n     /// A catch block (`catch { ... }`)\n     Catch(P<Block>),\n \n@@ -1325,9 +1335,7 @@ pub struct MutTy {\n /// or in an implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MethodSig {\n-    pub unsafety: Unsafety,\n-    pub constness: Spanned<Constness>,\n-    pub abi: Abi,\n+    pub header: FnHeader,\n     pub decl: P<FnDecl>,\n }\n \n@@ -1708,6 +1716,22 @@ pub enum Unsafety {\n     Normal,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum IsAsync {\n+    Async(NodeId),\n+    NotAsync,\n+}\n+\n+impl IsAsync {\n+    pub fn is_async(self) -> bool {\n+        if let IsAsync::Async(_) = self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Constness {\n     Const,\n@@ -2009,6 +2033,29 @@ pub struct Item {\n     pub tokens: Option<TokenStream>,\n }\n \n+/// A function header\n+///\n+/// All the information between the visibility & the name of the function is\n+/// included in this struct (e.g. `async unsafe fn` or `const extern \"C\" fn`)\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct FnHeader {\n+    pub unsafety: Unsafety,\n+    pub asyncness: IsAsync,\n+    pub constness: Spanned<Constness>,\n+    pub abi: Abi,\n+}\n+\n+impl Default for FnHeader {\n+    fn default() -> FnHeader {\n+        FnHeader {\n+            unsafety: Unsafety::Normal,\n+            asyncness: IsAsync::NotAsync,\n+            constness: dummy_spanned(Constness::NotConst),\n+            abi: Abi::Rust,\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n@@ -2030,7 +2077,7 @@ pub enum ItemKind {\n     /// A function declaration (`fn` or `pub fn`).\n     ///\n     /// E.g. `fn foo(bar: usize) -> usize { .. }`\n-    Fn(P<FnDecl>, Unsafety, Spanned<Constness>, Abi, Generics, P<Block>),\n+    Fn(P<FnDecl>, FnHeader, Generics, P<Block>),\n     /// A module declaration (`mod` or `pub mod`).\n     ///\n     /// E.g. `mod foo;` or `mod foo { .. }`"}, {"sha": "6135650766569ece2945ac5c94e56f9feb9da821", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -915,6 +915,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                       fn_decl_span: Span) // span of the `|...|` part\n                       -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref,\n+                                               ast::IsAsync::NotAsync,\n                                                ast::Movability::Movable,\n                                                fn_decl,\n                                                body,\n@@ -935,6 +936,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         // the entire lambda body. Probably we should extend the API\n         // here, but that's not entirely clear.\n         self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref,\n+                                               ast::IsAsync::NotAsync,\n                                                ast::Movability::Movable,\n                                                fn_decl,\n                                                body,\n@@ -1008,9 +1010,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                   name,\n                   Vec::new(),\n                   ast::ItemKind::Fn(self.fn_decl(inputs, ast::FunctionRetTy::Ty(output)),\n-                              ast::Unsafety::Normal,\n-                              dummy_spanned(ast::Constness::NotConst),\n-                              Abi::Rust,\n+                              ast::FnHeader {\n+                                  unsafety: ast::Unsafety::Normal,\n+                                  asyncness: ast::IsAsync::NotAsync,\n+                                  constness: dummy_spanned(ast::Constness::NotConst),\n+                                  abi: Abi::Rust,\n+                              },\n                               generics,\n                               body))\n     }"}, {"sha": "ccb2f51f9641bd0d3a11c669b9e2e492bdacb7ed", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -29,7 +29,6 @@ use rustc_target::spec::abi::Abi;\n use ast::{self, NodeId, PatKind, RangeEnd};\n use attr;\n use edition::{ALL_EDITIONS, Edition};\n-use codemap::Spanned;\n use syntax_pos::{Span, DUMMY_SP};\n use errors::{DiagnosticBuilder, Handler, FatalError};\n use visit::{self, FnKind, Visitor};\n@@ -309,7 +308,7 @@ declare_features! (\n     // Declarative macros 2.0 (`macro`).\n     (active, decl_macro, \"1.17.0\", Some(39412), None),\n \n-    // Allows #[link(kind=\"static-nobundle\"...]\n+    // Allows #[link(kind=\"static-nobundle\"...)]\n     (active, static_nobundle, \"1.16.0\", Some(37403), None),\n \n     // `extern \"msp430-interrupt\" fn()`\n@@ -468,12 +467,14 @@ declare_features! (\n     // 'a: { break 'a; }\n     (active, label_break_value, \"1.28.0\", Some(48594), None),\n \n-\n     // #[panic_implementation]\n     (active, panic_implementation, \"1.28.0\", Some(44489), None),\n \n     // #[doc(keyword = \"...\")]\n     (active, doc_keyword, \"1.28.0\", Some(51315), None),\n+\n+    // Allows async and await syntax\n+    (active, async_await, \"1.28.0\", Some(50547), None),\n );\n \n declare_features! (\n@@ -1721,6 +1722,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                     \"labels on blocks are unstable\");\n                 }\n             }\n+            ast::ExprKind::Closure(_, ast::IsAsync::Async(_), ..) => {\n+                gate_feature_post!(&self, async_await, e.span, \"async closures are unstable\");\n+            }\n+            ast::ExprKind::Async(..) => {\n+                gate_feature_post!(&self, async_await, e.span, \"async blocks are unstable\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);\n@@ -1760,20 +1767,24 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 fn_decl: &'a ast::FnDecl,\n                 span: Span,\n                 _node_id: NodeId) {\n-        // check for const fn declarations\n-        if let FnKind::ItemFn(_, _, Spanned { node: ast::Constness::Const, .. }, _, _, _) =\n-            fn_kind {\n-            gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n-        }\n-        // stability of const fn methods are covered in\n-        // visit_trait_item and visit_impl_item below; this is\n-        // because default methods don't pass through this\n-        // point.\n-\n         match fn_kind {\n-            FnKind::ItemFn(_, _, _, abi, _, _) |\n-            FnKind::Method(_, &ast::MethodSig { abi, .. }, _, _) => {\n-                self.check_abi(abi, span);\n+            FnKind::ItemFn(_, header, _, _) => {\n+                // check for const fn and async fn declarations\n+                if header.asyncness.is_async() {\n+                    gate_feature_post!(&self, async_await, span, \"async fn is unstable\");\n+                }\n+                if header.constness.node == ast::Constness::Const {\n+                    gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n+                }\n+                // stability of const fn methods are covered in\n+                // visit_trait_item and visit_impl_item below; this is\n+                // because default methods don't pass through this\n+                // point.\n+\n+                self.check_abi(header.abi, span);\n+            }\n+            FnKind::Method(_, sig, _, _) => {\n+                self.check_abi(sig.header.abi, span);\n             }\n             _ => {}\n         }\n@@ -1784,9 +1795,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match ti.node {\n             ast::TraitItemKind::Method(ref sig, ref block) => {\n                 if block.is_none() {\n-                    self.check_abi(sig.abi, ti.span);\n+                    self.check_abi(sig.header.abi, ti.span);\n                 }\n-                if sig.constness.node == ast::Constness::Const {\n+                if sig.header.constness.node == ast::Constness::Const {\n                     gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n                 }\n             }\n@@ -1820,7 +1831,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n         match ii.node {\n             ast::ImplItemKind::Method(ref sig, _) => {\n-                if sig.constness.node == ast::Constness::Const {\n+                if sig.header.constness.node == ast::Constness::Const {\n                     gate_feature_post!(&self, const_fn, ii.span, \"const fn is unstable\");\n                 }\n             }"}, {"sha": "ffea713f4ec76a359082178993b6fa09e1b5796e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -76,6 +76,10 @@ pub trait Folder : Sized {\n         noop_fold_item_simple(i, self)\n     }\n \n+    fn fold_fn_header(&mut self, header: FnHeader) -> FnHeader {\n+        noop_fold_fn_header(header, self)\n+    }\n+\n     fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n         noop_fold_struct_field(sf, self)\n     }\n@@ -881,11 +885,12 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n         ItemKind::Const(t, e) => {\n             ItemKind::Const(folder.fold_ty(t), folder.fold_expr(e))\n         }\n-        ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n+        ItemKind::Fn(decl, header, generics, body) => {\n             let generics = folder.fold_generics(generics);\n+            let header = folder.fold_fn_header(header);\n             let decl = folder.fold_fn_decl(decl);\n             let body = folder.fold_block(body);\n-            ItemKind::Fn(decl, unsafety, constness, abi, generics, body)\n+            ItemKind::Fn(decl, header, generics, body)\n         }\n         ItemKind::Mod(m) => ItemKind::Mod(folder.fold_mod(m)),\n         ItemKind::ForeignMod(nm) => ItemKind::ForeignMod(folder.fold_foreign_mod(nm)),\n@@ -990,6 +995,14 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n     })\n }\n \n+pub fn noop_fold_fn_header<T: Folder>(mut header: FnHeader, folder: &mut T) -> FnHeader {\n+    header.asyncness = match header.asyncness {\n+        IsAsync::Async(node_id) => IsAsync::Async(folder.new_id(node_id)),\n+        IsAsync::NotAsync => IsAsync::NotAsync,\n+    };\n+    header\n+}\n+\n pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n@@ -1082,9 +1095,7 @@ pub fn noop_fold_foreign_item_simple<T: Folder>(ni: ForeignItem, folder: &mut T)\n \n pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n     MethodSig {\n-        abi: sig.abi,\n-        unsafety: sig.unsafety,\n-        constness: sig.constness,\n+        header: folder.fold_fn_header(sig.header),\n         decl: folder.fold_fn_decl(sig.decl)\n     }\n }\n@@ -1237,8 +1248,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::Match(folder.fold_expr(expr),\n                           arms.move_map(|x| folder.fold_arm(x)))\n             }\n-            ExprKind::Closure(capture_clause, movability, decl, body, span) => {\n+            ExprKind::Closure(capture_clause, asyncness, movability, decl, body, span) => {\n+                let asyncness = match asyncness {\n+                    IsAsync::Async(node_id) => IsAsync::Async(folder.new_id(node_id)),\n+                    IsAsync::NotAsync => IsAsync::NotAsync,\n+                };\n                 ExprKind::Closure(capture_clause,\n+                                  asyncness,\n                                   movability,\n                                   folder.fold_fn_decl(decl),\n                                   folder.fold_expr(body),\n@@ -1248,6 +1264,9 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::Block(folder.fold_block(blk),\n                                 opt_label.map(|label| folder.fold_label(label)))\n             }\n+            ExprKind::Async(capture_clause, node_id, body) => {\n+                ExprKind::Async(capture_clause, folder.new_id(node_id), folder.fold_block(body))\n+            }\n             ExprKind::Assign(el, er) => {\n                 ExprKind::Assign(folder.fold_expr(el), folder.fold_expr(er))\n             }"}, {"sha": "cce8da1dcbd53f9291aa08bab5d6e032920e9938", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -928,12 +928,15 @@ mod tests {\n                                     output: ast::FunctionRetTy::Default(sp(15, 15)),\n                                     variadic: false\n                                 }),\n-                                        ast::Unsafety::Normal,\n-                                        Spanned {\n-                                            span: sp(0,2),\n-                                            node: ast::Constness::NotConst,\n+                                        ast::FnHeader {\n+                                            unsafety: ast::Unsafety::Normal,\n+                                            asyncness: ast::IsAsync::NotAsync,\n+                                            constness: Spanned {\n+                                                span: sp(0,2),\n+                                                node: ast::Constness::NotConst,\n+                                            },\n+                                            abi: Abi::Rust,\n                                         },\n-                                        Abi::Rust,\n                                         ast::Generics{\n                                             params: Vec::new(),\n                                             where_clause: ast::WhereClause {"}, {"sha": "5970f94b97d52f12f4cfc9737033c8703900875a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 117, "deletions": 18, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -19,11 +19,11 @@ use ast::{Constness, Crate};\n use ast::Defaultness;\n use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n-use ast::{Field, FnDecl};\n+use ast::{Field, FnDecl, FnHeader};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use ast::{GenericParam, GenericParamKind};\n use ast::GenericArg;\n-use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n+use ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n use ast::{Label, Lifetime, Lit, LitKind};\n use ast::Local;\n use ast::MacStmtStyle;\n@@ -43,7 +43,7 @@ use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, respan};\n-use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, DUMMY_SP};\n+use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, DUMMY_SP, edition::Edition};\n use errors::{self, Applicability, DiagnosticBuilder};\n use parse::{self, SeqSep, classify, token};\n use parse::lexer::TokenAndSpan;\n@@ -1296,6 +1296,15 @@ impl<'a> Parser<'a> {\n         })))\n     }\n \n+    /// Parse asyncness: `async` or nothing\n+    fn parse_asyncness(&mut self) -> IsAsync {\n+        if self.eat_keyword(keywords::Async) {\n+            IsAsync::Async(ast::DUMMY_NODE_ID)\n+        } else {\n+            IsAsync::NotAsync\n+        }\n+    }\n+\n     /// Parse unsafety: `unsafe` or nothing.\n     fn parse_unsafety(&mut self) -> Unsafety {\n         if self.eat_keyword(keywords::Unsafe) {\n@@ -1345,7 +1354,7 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n         } else {\n-            let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n \n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n@@ -1359,10 +1368,13 @@ impl<'a> Parser<'a> {\n             generics.where_clause = self.parse_where_clause()?;\n \n             let sig = ast::MethodSig {\n-                unsafety,\n-                constness,\n+                header: FnHeader {\n+                    unsafety,\n+                    constness,\n+                    abi,\n+                    asyncness,\n+                },\n                 decl: d,\n-                abi,\n             };\n \n             let body = match self.token {\n@@ -2258,6 +2270,15 @@ impl<'a> Parser<'a> {\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n+                if self.span.edition() >= Edition::Edition2018 &&\n+                    self.check_keyword(keywords::Async)\n+                {\n+                    if self.is_async_block() { // check for `async {` and `async move {`\n+                        return self.parse_async_block(attrs);\n+                    } else {\n+                        return self.parse_lambda_expr(attrs);\n+                    }\n+                }\n                 if self.check_keyword(keywords::Move) || self.check_keyword(keywords::Static) {\n                     return self.parse_lambda_expr(attrs);\n                 }\n@@ -3258,6 +3279,13 @@ impl<'a> Parser<'a> {\n         } else {\n             Movability::Movable\n         };\n+        let asyncness = if self.span.edition() >= Edition::Edition2018\n+            && self.eat_keyword(keywords::Async)\n+        {\n+            IsAsync::Async(ast::DUMMY_NODE_ID)\n+        } else {\n+            IsAsync::NotAsync\n+        };\n         let capture_clause = if self.eat_keyword(keywords::Move) {\n             CaptureBy::Value\n         } else {\n@@ -3280,7 +3308,7 @@ impl<'a> Parser<'a> {\n \n         Ok(self.mk_expr(\n             lo.to(body.span),\n-            ExprKind::Closure(capture_clause, movability, decl, body, lo.to(decl_hi)),\n+            ExprKind::Closure(capture_clause, asyncness, movability, decl, body, lo.to(decl_hi)),\n             attrs))\n     }\n \n@@ -3358,6 +3386,24 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(span, ExprKind::Loop(body, opt_label), attrs))\n     }\n \n+    /// Parse an `async move {...}` expression\n+    pub fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>)\n+        -> PResult<'a, P<Expr>>\n+    {\n+        let span_lo = self.span;\n+        self.expect_keyword(keywords::Async)?;\n+        let capture_clause = if self.eat_keyword(keywords::Move) {\n+            CaptureBy::Value\n+        } else {\n+            CaptureBy::Ref\n+        };\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        Ok(self.mk_expr(\n+            span_lo.to(body.span),\n+            ExprKind::Async(capture_clause, ast::DUMMY_NODE_ID, body), attrs))\n+    }\n+\n     /// Parse a `do catch {...}` expression (`do catch` token already eaten)\n     fn parse_catch_expr(&mut self, span_lo: Span, mut attrs: ThinVec<Attribute>)\n         -> PResult<'a, P<Expr>>\n@@ -4292,6 +4338,18 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn is_async_block(&mut self) -> bool {\n+        self.token.is_keyword(keywords::Async) &&\n+        (\n+            ( // `async move {`\n+                self.look_ahead(1, |t| t.is_keyword(keywords::Move)) &&\n+                self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n+            ) || ( // `async {`\n+                self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n+            )\n+        )\n+    }\n+\n     fn is_catch_expr(&mut self) -> bool {\n         self.token.is_keyword(keywords::Do) &&\n         self.look_ahead(1, |t| t.is_keyword(keywords::Catch)) &&\n@@ -5358,14 +5416,16 @@ impl<'a> Parser<'a> {\n     /// Parse an item-position function declaration.\n     fn parse_item_fn(&mut self,\n                      unsafety: Unsafety,\n+                     asyncness: IsAsync,\n                      constness: Spanned<Constness>,\n                      abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n         let (ident, mut generics) = self.parse_fn_header()?;\n         let decl = self.parse_fn_decl(false)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        Ok((ident, ItemKind::Fn(decl, unsafety, constness, abi, generics, body), Some(inner_attrs)))\n+        let header = FnHeader { unsafety, asyncness, constness, abi };\n+        Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n     }\n \n     /// true if we are looking at `const ID`, false for things like `const fn` etc\n@@ -5383,10 +5443,18 @@ impl<'a> Parser<'a> {\n     /// - `const unsafe fn`\n     /// - `extern fn`\n     /// - etc\n-    fn parse_fn_front_matter(&mut self) -> PResult<'a, (Spanned<Constness>, Unsafety, Abi)> {\n+    fn parse_fn_front_matter(&mut self)\n+        -> PResult<'a, (\n+            Spanned<Constness>,\n+            Unsafety,\n+            IsAsync,\n+            Abi\n+        )>\n+    {\n         let is_const_fn = self.eat_keyword(keywords::Const);\n         let const_span = self.prev_span;\n         let unsafety = self.parse_unsafety();\n+        let asyncness = self.parse_asyncness();\n         let (constness, unsafety, abi) = if is_const_fn {\n             (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n         } else {\n@@ -5398,7 +5466,7 @@ impl<'a> Parser<'a> {\n             (respan(self.prev_span, Constness::NotConst), unsafety, abi)\n         };\n         self.expect_keyword(keywords::Fn)?;\n-        Ok((constness, unsafety, abi))\n+        Ok((constness, unsafety, asyncness, abi))\n     }\n \n     /// Parse an impl item.\n@@ -5533,19 +5601,18 @@ impl<'a> Parser<'a> {\n             Ok((keywords::Invalid.ident(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n             let decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n             generics.where_clause = self.parse_where_clause()?;\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(ast::MethodSig {\n-                abi,\n-                unsafety,\n-                constness,\n-                decl,\n-             }, body)))\n+            let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n+            Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(\n+                ast::MethodSig { header, decl },\n+                body\n+            )))\n         }\n     }\n \n@@ -6631,6 +6698,7 @@ impl<'a> Parser<'a> {\n                 let abi = opt_abi.unwrap_or(Abi::C);\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(Unsafety::Normal,\n+                                       IsAsync::NotAsync,\n                                        respan(fn_span, Constness::NotConst),\n                                        abi)?;\n                 let prev_span = self.prev_span;\n@@ -6674,6 +6742,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(unsafety,\n+                                       IsAsync::NotAsync,\n                                        respan(const_span, Constness::Const),\n                                        Abi::Rust)?;\n                 let prev_span = self.prev_span;\n@@ -6701,6 +6770,34 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n+\n+        // `unsafe async fn` or `async fn`\n+        if (\n+            self.check_keyword(keywords::Unsafe) &&\n+            self.look_ahead(1, |t| t.is_keyword(keywords::Async))\n+        ) || (\n+            self.check_keyword(keywords::Async) &&\n+            self.look_ahead(1, |t| t.is_keyword(keywords::Fn))\n+        )\n+        {\n+            // ASYNC FUNCTION ITEM\n+            let unsafety = self.parse_unsafety();\n+            self.expect_keyword(keywords::Async)?;\n+            self.expect_keyword(keywords::Fn)?;\n+            let fn_span = self.prev_span;\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_fn(unsafety,\n+                                   IsAsync::Async(ast::DUMMY_NODE_ID),\n+                                   respan(fn_span, Constness::NotConst),\n+                                   Abi::Rust)?;\n+            let prev_span = self.prev_span;\n+            let item = self.mk_item(lo.to(prev_span),\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n         if self.check_keyword(keywords::Unsafe) &&\n             (self.look_ahead(1, |t| t.is_keyword(keywords::Trait)) ||\n             self.look_ahead(1, |t| t.is_keyword(keywords::Auto)))\n@@ -6746,6 +6843,7 @@ impl<'a> Parser<'a> {\n             let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(Unsafety::Normal,\n+                                   IsAsync::NotAsync,\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n             let prev_span = self.prev_span;\n@@ -6771,6 +6869,7 @@ impl<'a> Parser<'a> {\n             let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(Unsafety::Unsafe,\n+                                   IsAsync::NotAsync,\n                                    respan(fn_span, Constness::NotConst),\n                                    abi)?;\n             let prev_span = self.prev_span;"}, {"sha": "ac8088507dde7b6941d0fc211d4aa06ec726a112", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -373,14 +373,13 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl,\n-                     unsafety: ast::Unsafety,\n-                     constness: ast::Constness,\n+                     header: ast::FnHeader,\n                      name: ast::Ident,\n                      generics: &ast::Generics)\n                      -> String {\n     to_string(|s| {\n         s.head(\"\")?;\n-        s.print_fn(decl, unsafety, constness, Abi::Rust, Some(name),\n+        s.print_fn(decl, header, Some(name),\n                    generics, &codemap::dummy_spanned(ast::VisibilityKind::Inherited))?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n@@ -1118,9 +1117,8 @@ impl<'a> State<'a> {\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 self.head(\"\")?;\n-                self.print_fn(decl, ast::Unsafety::Normal,\n-                              ast::Constness::NotConst,\n-                              Abi::Rust, Some(item.ident),\n+                self.print_fn(decl, ast::FnHeader::default(),\n+                              Some(item.ident),\n                               generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n                 self.s.word(\";\")?;\n@@ -1249,13 +1247,11 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n+            ast::ItemKind::Fn(ref decl, header, ref typarams, ref body) => {\n                 self.head(\"\")?;\n                 self.print_fn(\n                     decl,\n-                    unsafety,\n-                    constness.node,\n-                    abi,\n+                    header,\n                     Some(item.ident),\n                     typarams,\n                     &item.vis\n@@ -1582,9 +1578,7 @@ impl<'a> State<'a> {\n                             vis: &ast::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n-                      m.unsafety,\n-                      m.constness.node,\n-                      m.abi,\n+                      m.header,\n                       Some(ident),\n                       &generics,\n                       vis)\n@@ -2177,8 +2171,10 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, INDENT_UNIT)?;\n             }\n-            ast::ExprKind::Closure(capture_clause, movability, ref decl, ref body, _) => {\n+            ast::ExprKind::Closure(\n+                capture_clause, asyncness, movability, ref decl, ref body, _) => {\n                 self.print_movability(movability)?;\n+                self.print_asyncness(asyncness)?;\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_fn_block_args(decl)?;\n@@ -2202,6 +2198,12 @@ impl<'a> State<'a> {\n                 self.ibox(0)?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n+            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n+                self.word_nbsp(\"async\")?;\n+                self.print_capture_clause(capture_clause)?;\n+                self.s.space()?;\n+                self.print_block_with_attrs(blk, attrs)?;\n+            }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1)?;\n@@ -2740,13 +2742,11 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    unsafety: ast::Unsafety,\n-                    constness: ast::Constness,\n-                    abi: abi::Abi,\n+                    header: ast::FnHeader,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     vis: &ast::Visibility) -> io::Result<()> {\n-        self.print_fn_header_info(unsafety, constness, abi, vis)?;\n+        self.print_fn_header_info(header, vis)?;\n \n         if let Some(name) = name {\n             self.nbsp()?;\n@@ -2800,6 +2800,14 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n+                                -> io::Result<()> {\n+        if asyncness.is_async() {\n+            self.word_nbsp(\"async\")?;\n+        }\n+        Ok(())\n+    }\n+\n     pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy)\n                                 -> io::Result<()> {\n         match capture_clause {\n@@ -3058,9 +3066,7 @@ impl<'a> State<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n-                      unsafety,\n-                      ast::Constness::NotConst,\n-                      abi,\n+                      ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n                       name,\n                       &generics,\n                       &codemap::dummy_spanned(ast::VisibilityKind::Inherited))?;\n@@ -3123,22 +3129,21 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                unsafety: ast::Unsafety,\n-                                constness: ast::Constness,\n-                                abi: Abi,\n+                                header: ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n         self.s.word(&visibility_qualified(vis, \"\"))?;\n \n-        match constness {\n+        match header.constness.node {\n             ast::Constness::NotConst => {}\n             ast::Constness::Const => self.word_nbsp(\"const\")?\n         }\n \n-        self.print_unsafety(unsafety)?;\n+        self.print_asyncness(header.asyncness)?;\n+        self.print_unsafety(header.unsafety)?;\n \n-        if abi != Abi::Rust {\n+        if header.abi != Abi::Rust {\n             self.word_nbsp(\"extern\")?;\n-            self.word_nbsp(&abi.to_string())?;\n+            self.word_nbsp(&header.abi.to_string())?;\n         }\n \n         self.s.word(\"fn\")\n@@ -3181,10 +3186,20 @@ mod tests {\n                 variadic: false\n             };\n             let generics = ast::Generics::default();\n-            assert_eq!(fun_to_string(&decl, ast::Unsafety::Normal,\n-                                    ast::Constness::NotConst,\n-                                    abba_ident, &generics),\n-                    \"fn abba()\");\n+            assert_eq!(\n+                fun_to_string(\n+                    &decl,\n+                    ast::FnHeader {\n+                        unsafety: ast::Unsafety::Normal,\n+                        constness: codemap::dummy_spanned(ast::Constness::NotConst),\n+                        asyncness: ast::IsAsync::NotAsync,\n+                        abi: Abi::Rust,\n+                    },\n+                    abba_ident,\n+                    &generics\n+                ),\n+                \"fn abba()\"\n+            );\n         })\n     }\n "}, {"sha": "7722558514197cfc86faafb859afe267f87f33a1", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -124,24 +124,36 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n             match i.node {\n-                ast::ItemKind::Fn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n-                    let diag = self.cx.span_diagnostic;\n-                    diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\").raise();\n-                }\n-                _ => {\n-                    debug!(\"this is a test function\");\n-                    let test = Test {\n-                        span: i.span,\n-                        path: self.cx.path.clone(),\n-                        bench: is_bench_fn(&self.cx, &i),\n-                        ignore: is_ignored(&i),\n-                        should_panic: should_panic(&i, &self.cx),\n-                        allow_fail: is_allowed_fail(&i),\n-                    };\n-                    self.cx.testfns.push(test);\n-                    self.tests.push(i.ident);\n+                ast::ItemKind::Fn(_, header, _, _) => {\n+                    if header.unsafety == ast::Unsafety::Unsafe {\n+                        let diag = self.cx.span_diagnostic;\n+                        diag.span_fatal(\n+                            i.span,\n+                            \"unsafe functions cannot be used for tests\"\n+                        ).raise();\n+                    }\n+                    if header.asyncness.is_async() {\n+                        let diag = self.cx.span_diagnostic;\n+                        diag.span_fatal(\n+                            i.span,\n+                            \"async functions cannot be used for tests\"\n+                        ).raise();\n+                    }\n                 }\n+                _ => {},\n             }\n+\n+            debug!(\"this is a test function\");\n+            let test = Test {\n+                span: i.span,\n+                path: self.cx.path.clone(),\n+                bench: is_bench_fn(&self.cx, &i),\n+                ignore: is_ignored(&i),\n+                should_panic: should_panic(&i, &self.cx),\n+                allow_fail: is_allowed_fail(&i),\n+            };\n+            self.cx.testfns.push(test);\n+            self.tests.push(i.ident);\n         }\n \n         let mut item = i.into_inner();\n@@ -338,7 +350,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     fn has_test_signature(_cx: &TestCtxt, i: &ast::Item) -> HasTestSignature {\n         let has_should_panic_attr = attr::contains_name(&i.attrs, \"should_panic\");\n         match i.node {\n-            ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, _, ref generics, _) => {\n                 // If the termination trait is active, the compiler will check that the output\n                 // type implements the `Termination` trait as `libtest` enforces that.\n                 let has_output = match decl.output {\n@@ -396,7 +408,7 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n     fn has_bench_signature(_cx: &TestCtxt, i: &ast::Item) -> bool {\n         match i.node {\n-            ast::ItemKind::Fn(ref decl, _, _, _, _, _) => {\n+            ast::ItemKind::Fn(ref decl, _, _, _) => {\n                 // NB: inadequate check, but we're running\n                 // well before resolve, can't get too deep.\n                 decl.inputs.len() == 1\n@@ -537,9 +549,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n     let main_body = ecx.block(sp, vec![call_test_main]);\n     let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], ast::FunctionRetTy::Ty(main_ret_ty)),\n-                           ast::Unsafety::Normal,\n-                           dummy_spanned(ast::Constness::NotConst),\n-                           ::rustc_target::spec::abi::Abi::Rust,\n+                           ast::FnHeader::default(),\n                            ast::Generics::default(),\n                            main_body);\n     P(ast::Item {"}, {"sha": "15d910b33b064c9a3a37ca59b70421d965b0c930", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -277,6 +277,7 @@ pub enum ExprPrecedence {\n     Block,\n     Catch,\n     Struct,\n+    Async,\n }\n \n impl PartialOrd for ExprPrecedence {\n@@ -346,6 +347,7 @@ impl ExprPrecedence {\n             ExprPrecedence::Match |\n             ExprPrecedence::Block |\n             ExprPrecedence::Catch |\n+            ExprPrecedence::Async |\n             ExprPrecedence::Struct => PREC_PAREN,\n         }\n     }"}, {"sha": "41e3ad9d4f4b1c944d9e122b83f508c2c91b86e2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -23,17 +23,15 @@\n //! instance, a walker looking for item names in a module will miss all of\n //! those that are created by the expansion of a macro.\n \n-use rustc_target::spec::abi::Abi;\n use ast::*;\n use syntax_pos::Span;\n-use codemap::Spanned;\n use parse::token::Token;\n use tokenstream::{TokenTree, TokenStream};\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Ident, Unsafety, Spanned<Constness>, Abi, &'a Visibility, &'a Block),\n+    ItemFn(Ident, FnHeader, &'a Visibility, &'a Block),\n \n     /// fn foo(&self)\n     Method(Ident, &'a MethodSig, Option<&'a Visibility>, &'a Block),\n@@ -235,10 +233,10 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             visitor.visit_ty(typ);\n             visitor.visit_expr(expr);\n         }\n-        ItemKind::Fn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+        ItemKind::Fn(ref declaration, header, ref generics, ref body) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_fn(FnKind::ItemFn(item.ident, unsafety,\n-                                            constness, abi, &item.vis, body),\n+            visitor.visit_fn(FnKind::ItemFn(item.ident, header,\n+                                            &item.vis, body),\n                              declaration,\n                              item.span,\n                              item.id)\n@@ -544,7 +542,7 @@ pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl\n     where V: Visitor<'a>,\n {\n     match kind {\n-        FnKind::ItemFn(_, _, _, _, _, body) => {\n+        FnKind::ItemFn(_, _, _, body) => {\n             walk_fn_decl(visitor, declaration);\n             visitor.visit_block(body);\n         }\n@@ -737,7 +735,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprKind::Closure(_, _, ref function_declaration, ref body, _decl_span) => {\n+        ExprKind::Closure(_, _, _, ref function_declaration, ref body, _decl_span) => {\n             visitor.visit_fn(FnKind::Closure(body),\n                              function_declaration,\n                              expression.span,\n@@ -747,6 +745,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n+        ExprKind::Async(_, _, ref body) => {\n+            visitor.visit_block(body);\n+        }\n         ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(left_hand_expression);\n             visitor.visit_expr(right_hand_expression);"}, {"sha": "3ea0eb8bbd842e63155a3c1369b9116a540892fa", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -197,7 +197,7 @@ use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::{self, dummy_spanned, respan};\n+use syntax::codemap::{self, respan};\n use syntax::util::move_map::MoveMap;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n@@ -971,10 +971,10 @@ impl<'a> MethodDef<'a> {\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n             node: ast::ImplItemKind::Method(ast::MethodSig {\n-                                                abi,\n-                                                unsafety,\n-                                                constness:\n-                                                    dummy_spanned(ast::Constness::NotConst),\n+                                                header: ast::FnHeader {\n+                                                    unsafety, abi,\n+                                                    ..ast::FnHeader::default()\n+                                                },\n                                                 decl: fn_decl,\n                                             },\n                                             body_block),"}, {"sha": "0ca42169b8ec5bbd18bd2d7df9c4a49e8b40c8a7", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -493,12 +493,14 @@ pub enum CompilerDesugaringKind {\n     /// to an `existential type Foo: Trait;` + replacing the\n     /// `impl Trait` with `Foo`.\n     ExistentialReturnType,\n+    Async,\n }\n \n impl CompilerDesugaringKind {\n     pub fn as_symbol(&self) -> Symbol {\n         use CompilerDesugaringKind::*;\n         let s = match *self {\n+            Async => \"async\",\n             DotFill => \"...\",\n             QuestionMark => \"?\",\n             Catch => \"do catch\","}, {"sha": "05df16d21d85bcf5d65268fe57c0a696aa1c6758", "filename": "src/test/parse-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -16,6 +16,6 @@ impl Foo {\n     fn foo() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`\n+} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or\n \n fn main() {}"}, {"sha": "f30e20ad7dbdb3968194a357a6e399e7097d1e58", "filename": "src/test/parse-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-20711.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -14,6 +14,6 @@ struct Foo;\n \n impl Foo {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`\n+} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or\n \n fn main() {}"}, {"sha": "fbc6848f372f5666e9cd27c664941c24cbea6733", "filename": "src/test/parse-fail/removed-syntax-static-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -15,4 +15,4 @@ struct S;\n impl S {\n     static fn f() {}\n }\n-//~^^ ERROR expected one of `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`\n+//~^^ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`,"}, {"sha": "9f94d5d41fda7d1375daa8ddadb013c3c55bedb0", "filename": "src/test/parse-fail/trait-non-item-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-non-item-macros.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -10,7 +10,7 @@\n \n macro_rules! bah {\n     ($a:expr) => ($a)\n-    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, or `unsafe`, found `2`\n+    //~^ ERROR expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`, found `2`\n }\n \n trait bar {"}, {"sha": "cce6b5c4cbf750cb0cc69fb70fcf47d62649e18d", "filename": "src/test/parse-fail/trait-pub-assoc-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-const.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     pub const Foo: u32;\n-    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `pub`\n+    //~^ ERROR expected one of `async`, `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found\n }\n \n fn main() {}"}, {"sha": "d6a4e5e021d3876704f01db5ebabd855581f0128", "filename": "src/test/parse-fail/trait-pub-assoc-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-assoc-ty.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     pub type Foo;\n-    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `pub`\n+    //~^ ERROR expected one of `async`, `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found\n }\n \n fn main() {}"}, {"sha": "286cb4dbff7e183992d1925834307900bdb4e2af", "filename": "src/test/parse-fail/trait-pub-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-pub-method.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     pub fn foo();\n-    //~^ ERROR expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `pub`\n+    //~^ ERROR expected one of `async`, `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found\n }\n \n fn main() {}"}, {"sha": "bbd81e790b838d5f303cd12d1c82354dbc0bc9b7", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -124,6 +124,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(\n                         ExprKind::Closure(CaptureBy::Value,\n+                                          IsAsync::NotAsync,\n                                           Movability::Movable,\n                                           decl.clone(),\n                                           e,"}, {"sha": "817db4bb79ec3a4a586b49cea88bef37731fc259", "filename": "src/test/run-pass/async-await.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,152 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+\n+use std::boxed::PinBox;\n+use std::mem::PinMut;\n+use std::future::Future;\n+use std::sync::{\n+    Arc,\n+    atomic::{self, AtomicUsize},\n+};\n+use std::task::{\n+    Context, Poll, Wake,\n+    Executor, TaskObj, SpawnObjError,\n+    local_waker_from_nonlocal,\n+};\n+\n+struct Counter {\n+    wakes: AtomicUsize,\n+}\n+\n+impl Wake for Counter {\n+    fn wake(this: &Arc<Self>) {\n+        this.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+    }\n+}\n+\n+struct NoopExecutor;\n+impl Executor for NoopExecutor {\n+    fn spawn_obj(&mut self, _: TaskObj) -> Result<(), SpawnObjError> {\n+        Ok(())\n+    }\n+}\n+\n+struct WakeOnceThenComplete(bool);\n+\n+fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n+\n+impl Future for WakeOnceThenComplete {\n+    type Output = ();\n+    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n+        if self.0 {\n+            Poll::Ready(())\n+        } else {\n+            cx.waker().wake();\n+            self.0 = true;\n+            Poll::Pending\n+        }\n+    }\n+}\n+\n+fn async_block(x: u8) -> impl Future<Output = u8> {\n+    async move {\n+        await!(wake_and_yield_once());\n+        x\n+    }\n+}\n+\n+fn async_nonmove_block(x: u8) -> impl Future<Output = u8> {\n+    async move {\n+        let future = async {\n+            await!(wake_and_yield_once());\n+            x\n+        };\n+        await!(future)\n+    }\n+}\n+\n+fn async_closure(x: u8) -> impl Future<Output = u8> {\n+    (async move |x: u8| -> u8 {\n+        await!(wake_and_yield_once());\n+        x\n+    })(x)\n+}\n+\n+async fn async_fn(x: u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    x\n+}\n+\n+async fn async_fn_with_borrow(x: &u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+\n+fn async_fn_with_internal_borrow(y: u8) -> impl Future<Output = u8> {\n+    async move {\n+        await!(async_fn_with_borrow(&y))\n+    }\n+}\n+\n+unsafe async fn unsafe_async_fn(x: u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    x\n+}\n+\n+struct Foo;\n+\n+trait Bar {\n+    fn foo() {}\n+}\n+\n+impl Foo {\n+    async fn async_method(x: u8) -> u8 {\n+        unsafe {\n+            await!(unsafe_async_fn(x))\n+        }\n+    }\n+}\n+\n+fn test_future_yields_once_then_returns<F, Fut>(f: F)\n+where\n+    F: FnOnce(u8) -> Fut,\n+    Fut: Future<Output = u8>,\n+{\n+    let mut fut = PinBox::new(f(9));\n+    let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n+    let waker = local_waker_from_nonlocal(counter.clone());\n+    let executor = &mut NoopExecutor;\n+    let cx = &mut Context::new(&waker, executor);\n+\n+    assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(Poll::Pending, fut.as_pin_mut().poll(cx));\n+    assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(Poll::Ready(9), fut.as_pin_mut().poll(cx));\n+}\n+\n+fn main() {\n+    macro_rules! test {\n+        ($($fn_name:ident,)*) => { $(\n+            test_future_yields_once_then_returns($fn_name);\n+        )* }\n+    }\n+\n+    test! {\n+        async_block,\n+        async_nonmove_block,\n+        async_closure,\n+        async_fn,\n+        async_fn_with_internal_borrow,\n+    }\n+}"}, {"sha": "ce062ded7f73f03ddb7f9a619823424a23ac3d8f", "filename": "src/test/ui/async-fn-multiple-lifetimes.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+\n+use std::ops::Add;\n+\n+async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n+//~^ ERROR multiple different lifetimes used in arguments of `async fn`\n+\n+async fn multiple_hrtb_and_single_named_lifetime_ok<'c>(\n+    _: impl for<'a> Add<&'a u8>,\n+    _: impl for<'b> Add<&'b u8>,\n+    _: &'c u8,\n+) {}\n+\n+async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n+//~^ ERROR multiple elided lifetimes used\n+//~^^ ERROR missing lifetime specifier\n+\n+fn main() {}"}, {"sha": "d76bfc5d0e1abb810e9c74225750351a92c203a2", "filename": "src/test/ui/async-fn-multiple-lifetimes.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,32 @@\n+error[E0725]: multiple different lifetimes used in arguments of `async fn`\n+  --> $DIR/async-fn-multiple-lifetimes.rs:17:49\n+   |\n+LL | async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n+   |                                               --^^^^^^^^^-- different lifetime here\n+   |                                               |\n+   |                                               first lifetime here\n+   |\n+   = help: `async fn` can only accept borrowed values with identical lifetimes\n+\n+error[E0726]: multiple elided lifetimes used in arguments of `async fn`\n+  --> $DIR/async-fn-multiple-lifetimes.rs:26:39\n+   |\n+LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n+   |                                       -^^^^^^^- different lifetime here\n+   |                                       |\n+   |                                       first lifetime here\n+   |\n+   = help: consider giving these arguments named lifetimes\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/async-fn-multiple-lifetimes.rs:26:39\n+   |\n+LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n+   |                                       ^ expected lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `_` or `_`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0106, E0725, E0726.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "d3ce2cf12f2969c6d0bad31d4cfeded6b3b5cf39", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -38,11 +38,11 @@ LL |       L = M; //~ ERROR missing\n LL | |     Z = { 2 + 3 }; //~ ERROR expected one of\n    | |____^ missing `fn`, `type`, or `const`\n \n-error: expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `;`\n+error: expected one of `async`, `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `;`\n   --> $DIR/issue-40006.rs:23:18\n    |\n LL |     Z = { 2 + 3 }; //~ ERROR expected one of\n-   |                  ^ expected one of `const`, `extern`, `fn`, `type`, `unsafe`, or `}` here\n+   |                  ^ expected one of 7 possible tokens here\n \n error: expected one of `!` or `::`, found `(`\n   --> $DIR/issue-40006.rs:24:9"}, {"sha": "02dc8c8795675c34313c00a516449075e0eb0a20", "filename": "src/test/ui/edition-keywords-2018-2015-parsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -25,7 +25,7 @@ pub fn check_async() {\n     r#async = consumes_async_raw!(async); //~ ERROR no rules expected the token `async`\n     r#async = consumes_async_raw!(r#async); // OK\n \n-    if passes_ident!(async) == 1 {} //~ ERROR expected expression, found reserved keyword `async`\n+    if passes_ident!(async) == 1 {}\n     if passes_ident!(r#async) == 1 {} // OK\n     module::async(); //~ ERROR expected identifier, found reserved keyword `async`\n     module::r#async(); // OK"}, {"sha": "ceab5ea730ea88ee41ec45245fad64da2b84ecdb", "filename": "src/test/ui/edition-keywords-2018-2015-parsing.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.stderr?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -22,11 +22,11 @@ error: no rules expected the token `async`\n LL |     r#async = consumes_async_raw!(async); //~ ERROR no rules expected the token `async`\n    |                                   ^^^^^\n \n-error: expected expression, found reserved keyword `async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:28:22\n+error: expected one of `move`, `|`, or `||`, found `<eof>`\n+  --> <passes_ident macros>:1:22\n    |\n-LL |     if passes_ident!(async) == 1 {} //~ ERROR expected expression, found reserved keyword `async`\n-   |                      ^^^^^ expected expression\n+LL | ( $ i : ident ) => ( $ i )\n+   |                      ^^^ expected one of `move`, `|`, or `||` here\n \n error: aborting due to 5 previous errors\n "}, {"sha": "f9b4d0e18c14b3e9c6d954a43287e3af3d3ab113", "filename": "src/test/ui/edition-keywords-2018-2018-parsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -25,7 +25,7 @@ pub fn check_async() {\n     r#async = consumes_async_raw!(async); //~ ERROR no rules expected the token `async`\n     r#async = consumes_async_raw!(r#async); // OK\n \n-    if passes_ident!(async) == 1 {} //~ ERROR expected expression, found reserved keyword `async`\n+    if passes_ident!(async) == 1 {}\n     if passes_ident!(r#async) == 1 {} // OK\n     module::async(); //~ ERROR expected identifier, found reserved keyword `async`\n     module::r#async(); // OK"}, {"sha": "e48aac0a2bba9397512535d3ebce84ead33506e2", "filename": "src/test/ui/edition-keywords-2018-2018-parsing.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.stderr?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -22,11 +22,11 @@ error: no rules expected the token `async`\n LL |     r#async = consumes_async_raw!(async); //~ ERROR no rules expected the token `async`\n    |                                   ^^^^^\n \n-error: expected expression, found reserved keyword `async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:28:22\n+error: expected one of `move`, `|`, or `||`, found `<eof>`\n+  --> <passes_ident macros>:1:22\n    |\n-LL |     if passes_ident!(async) == 1 {} //~ ERROR expected expression, found reserved keyword `async`\n-   |                      ^^^^^ expected expression\n+LL | ( $ i : ident ) => ( $ i )\n+   |                      ^^^ expected one of `move`, `|`, or `||` here\n \n error: aborting due to 5 previous errors\n "}, {"sha": "b1dd6a77e976a740bfa7ee3146adbed10918ae77", "filename": "src/test/ui/feature-gate-async-await-2015-edition.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2015\n+\n+#![feature(futures_api)]\n+\n+async fn foo() {} //~ ERROR async fn is unstable\n+\n+fn main() {\n+    let _ = async {}; //~ ERROR cannot find struct, variant or union type `async`\n+    let _ = async || {}; //~ ERROR cannot find value `async` in this scope\n+}"}, {"sha": "3db90a48e90b971d145bf3a1bc7bf1ee39a3bede", "filename": "src/test/ui/feature-gate-async-await-2015-edition.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.stderr?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,24 @@\n+error[E0422]: cannot find struct, variant or union type `async` in this scope\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:18:13\n+   |\n+LL |     let _ = async {}; //~ ERROR cannot find struct, variant or union type `async`\n+   |             ^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `async` in this scope\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:19:13\n+   |\n+LL |     let _ = async || {}; //~ ERROR cannot find value `async` in this scope\n+   |             ^^^^^ not found in this scope\n+\n+error[E0658]: async fn is unstable (see issue #50547)\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:15:1\n+   |\n+LL | async fn foo() {} //~ ERROR async fn is unstable\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(async_await)] to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0422, E0425, E0658.\n+For more information about an error, try `rustc --explain E0422`."}, {"sha": "971b75c6dd03653f286792e674e6297549301905", "filename": "src/test/ui/feature-gate-async-await.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ffeature-gate-async-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ffeature-gate-async-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-async-await.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2018\n+#![feature(futures_api)]\n+\n+async fn foo() {} //~ ERROR async fn is unstable\n+\n+fn main() {\n+    let _ = async {}; //~ ERROR async blocks are unstable\n+    let _ = async || {}; //~ ERROR async closures are unstable\n+}"}, {"sha": "fdee6e205750b0f39384d8b9944d782212cd1bb4", "filename": "src/test/ui/feature-gate-async-await.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ffeature-gate-async-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ffeature-gate-async-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-async-await.stderr?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,27 @@\n+error[E0658]: async fn is unstable (see issue #50547)\n+  --> $DIR/feature-gate-async-await.rs:14:1\n+   |\n+LL | async fn foo() {} //~ ERROR async fn is unstable\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(async_await)] to the crate attributes to enable\n+\n+error[E0658]: async blocks are unstable (see issue #50547)\n+  --> $DIR/feature-gate-async-await.rs:17:13\n+   |\n+LL |     let _ = async {}; //~ ERROR async blocks are unstable\n+   |             ^^^^^^^^\n+   |\n+   = help: add #![feature(async_await)] to the crate attributes to enable\n+\n+error[E0658]: async closures are unstable (see issue #50547)\n+  --> $DIR/feature-gate-async-await.rs:18:13\n+   |\n+LL |     let _ = async || {}; //~ ERROR async closures are unstable\n+   |             ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(async_await)] to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "f2ecc44771883752d6296d7bbd38a82facf371e9", "filename": "src/test/ui/no-args-non-move-async-closure.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+\n+fn main() {\n+    let _ = async |x: u8| {};\n+    //~^ ERROR `async` non-`move` closures with arguments are not currently supported\n+}"}, {"sha": "34cd0069c041dfa470d367e63818ede22e186a41", "filename": "src/test/ui/no-args-non-move-async-closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.stderr?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -0,0 +1,11 @@\n+error[E0727]: `async` non-`move` closures with arguments are not currently supported\n+  --> $DIR/no-args-non-move-async-closure.rs:16:13\n+   |\n+LL |     let _ = async |x: u8| {};\n+   |             ^^^^^^^^^^^^^\n+   |\n+   = help: consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0727`."}, {"sha": "84dbc7ffc2f8f50826e597f4aacf69b5b254d43d", "filename": "src/test/ui/token/issue-41155.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ftoken%2Fissue-41155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9/src%2Ftest%2Fui%2Ftoken%2Fissue-41155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftoken%2Fissue-41155.stderr?ref=56e8f29dbe89f2109cacc8eb5e92ea3de32eefb9", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `const`, `default`, `extern`, `fn`, `type`, or `unsafe`, found `}`\n+error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `type`, or `unsafe`, found `}`\n   --> $DIR/issue-41155.rs:13:1\n    |\n LL |     pub\n-   |        - expected one of 7 possible tokens here\n+   |        - expected one of 8 possible tokens here\n LL | } //~ ERROR expected one of\n    | ^ unexpected token\n "}]}