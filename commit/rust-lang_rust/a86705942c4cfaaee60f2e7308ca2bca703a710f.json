{"sha": "a86705942c4cfaaee60f2e7308ca2bca703a710f", "node_id": "C_kwDOAAsO6NoAKGE4NjcwNTk0MmM0Y2ZhYWVlNjBmMmU3MzA4Y2EyYmNhNzAzYTcxMGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T22:57:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-25T22:57:23Z"}, "message": "Auto merge of #99735 - JohnTitor:rollup-d93jyr2, r=JohnTitor\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #92390 (Constify a few `(Partial)Ord` impls)\n - #97077 (Simplify some code that depend on Deref)\n - #98710 (correct the output of a `capacity` method example)\n - #99084 (clarify how write_bytes can lead to UB due to invalid values)\n - #99178 (Lighten up const_prop_lint, reusing const_prop)\n - #99673 (don't ICE on invalid dyn calls)\n - #99703 (Expose size_hint() for TokenStream's iterator)\n - #99709 (`Inherited` always has `TypeckResults` available)\n - #99713 (Fix sidebar background)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "133bd48f82d214929324a7e2337871b505adb8e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/133bd48f82d214929324a7e2337871b505adb8e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a86705942c4cfaaee60f2e7308ca2bca703a710f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a86705942c4cfaaee60f2e7308ca2bca703a710f", "html_url": "https://github.com/rust-lang/rust/commit/a86705942c4cfaaee60f2e7308ca2bca703a710f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a86705942c4cfaaee60f2e7308ca2bca703a710f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dbae3ad19309bb541d9e76638e6aa4b5449f29a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dbae3ad19309bb541d9e76638e6aa4b5449f29a", "html_url": "https://github.com/rust-lang/rust/commit/6dbae3ad19309bb541d9e76638e6aa4b5449f29a"}, {"sha": "e58bfacd90bea9fab8bdbd9cf6129290937fed63", "url": "https://api.github.com/repos/rust-lang/rust/commits/e58bfacd90bea9fab8bdbd9cf6129290937fed63", "html_url": "https://github.com/rust-lang/rust/commit/e58bfacd90bea9fab8bdbd9cf6129290937fed63"}], "stats": {"total": 628, "additions": 157, "deletions": 471}, "files": [{"sha": "268c4d765030568f074d975153a2bd6fa30a8f1b", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -435,18 +435,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             LocalRef::Place(place) => place,\n             LocalRef::UnsizedPlace(place) => bx.load_operand(place).deref(cx),\n             LocalRef::Operand(..) => {\n-                if let Some(elem) = place_ref\n-                    .projection\n-                    .iter()\n-                    .enumerate()\n-                    .find(|elem| matches!(elem.1, mir::ProjectionElem::Deref))\n-                {\n-                    base = elem.0 + 1;\n+                if place_ref.has_deref() {\n+                    base = 1;\n                     let cg_base = self.codegen_consume(\n                         bx,\n-                        mir::PlaceRef { projection: &place_ref.projection[..elem.0], ..place_ref },\n+                        mir::PlaceRef { projection: &place_ref.projection[..0], ..place_ref },\n                     );\n-\n                     cg_base.deref(bx.cx())\n                 } else {\n                     bug!(\"using operand local {:?} as place\", place_ref);"}, {"sha": "d563e35f9102d1e059f89958c7c3891690323967", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -571,8 +571,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Now determine the actual method to call. We can do that in two different ways and\n                 // compare them to ensure everything fits.\n-                let ty::VtblEntry::Method(fn_inst) = self.get_vtable_entries(vptr)?[idx] else {\n-                    span_bug!(self.cur_span(), \"dyn call index points at something that is not a method\")\n+                let Some(ty::VtblEntry::Method(fn_inst)) = self.get_vtable_entries(vptr)?.get(idx).copied() else {\n+                    throw_ub_format!(\"`dyn` call trying to call something that is not a method\")\n                 };\n                 if cfg!(debug_assertions) {\n                     let tcx = *self.tcx;"}, {"sha": "f7311ebdabfd91bcb235b98cfa6236f146000206", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -1461,6 +1461,14 @@ impl<'tcx> Place<'tcx> {\n         self.projection.iter().any(|elem| elem.is_indirect())\n     }\n \n+    /// If MirPhase >= Derefered and if projection contains Deref,\n+    /// It's guaranteed to be in the first place\n+    pub fn has_deref(&self) -> bool {\n+        // To make sure this is not accidently used in wrong mir phase\n+        debug_assert!(!self.projection[1..].contains(&PlaceElem::Deref));\n+        self.projection.first() == Some(&PlaceElem::Deref)\n+    }\n+\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n     #[inline(always)]\n@@ -1533,6 +1541,12 @@ impl<'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n+    /// If MirPhase >= Derefered and if projection contains Deref,\n+    /// It's guaranteed to be in the first place\n+    pub fn has_deref(&self) -> bool {\n+        self.projection.first() == Some(&PlaceElem::Deref)\n+    }\n+\n     /// If this place represents a local variable like `_X` with no\n     /// projections, return `Some(_X)`.\n     #[inline]"}, {"sha": "9c5896c4e4aedef2008e849348559d97ffdabb9b", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -15,22 +15,9 @@ pub struct AddRetag;\n /// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n /// copies.  Data races are UB.)\n fn is_stable(place: PlaceRef<'_>) -> bool {\n-    place.projection.iter().all(|elem| {\n-        match elem {\n-            // Which place this evaluates to can change with any memory write,\n-            // so cannot assume this to be stable.\n-            ProjectionElem::Deref => false,\n-            // Array indices are interesting, but MIR building generates a *fresh*\n-            // temporary for every array access, so the index cannot be changed as\n-            // a side-effect.\n-            ProjectionElem::Index { .. } |\n-            // The rest is completely boring, they just offset by a constant.\n-            ProjectionElem::Field { .. } |\n-            ProjectionElem::ConstantIndex { .. } |\n-            ProjectionElem::Subslice { .. } |\n-            ProjectionElem::Downcast { .. } => true,\n-        }\n-    })\n+    // Which place this evaluates to can change with any memory write,\n+    // so cannot assume deref to be stable.\n+    !place.has_deref()\n }\n \n /// Determine whether this type may contain a reference (or box), and thus needs retagging.\n@@ -91,11 +78,8 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         };\n         let place_base_raw = |place: &Place<'tcx>| {\n             // If this is a `Deref`, get the type of what we are deref'ing.\n-            let deref_base =\n-                place.projection.iter().rposition(|p| matches!(p, ProjectionElem::Deref));\n-            if let Some(deref_base) = deref_base {\n-                let base_proj = &place.projection[..deref_base];\n-                let ty = Place::ty_from(place.local, base_proj, &*local_decls, tcx).ty;\n+            if place.has_deref() {\n+                let ty = &local_decls[place.local].ty;\n                 ty.is_unsafe_ptr()\n             } else {\n                 // Not a deref, and thus not raw."}, {"sha": "85ad6b8f2feff052b70b19c74fb2a3244a1f5226", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -155,18 +155,18 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n     }\n }\n \n-struct ConstPropMachine<'mir, 'tcx> {\n+pub struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx>>,\n     /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n-    written_only_inside_own_block_locals: FxHashSet<Local>,\n+    pub written_only_inside_own_block_locals: FxHashSet<Local>,\n     /// Locals that need to be cleared after every block terminates.\n-    only_propagate_inside_block_locals: BitSet<Local>,\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n+    pub only_propagate_inside_block_locals: BitSet<Local>,\n+    pub can_const_prop: IndexVec<Local, ConstPropMode>,\n }\n \n impl ConstPropMachine<'_, '_> {\n-    fn new(\n+    pub fn new(\n         only_propagate_inside_block_locals: BitSet<Local>,\n         can_const_prop: IndexVec<Local, ConstPropMode>,\n     ) -> Self {\n@@ -816,7 +816,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n /// The mode that `ConstProp` is allowed to run in for a given `Local`.\n #[derive(Clone, Copy, Debug, PartialEq)]\n-enum ConstPropMode {\n+pub enum ConstPropMode {\n     /// The `Local` can be propagated into and reads of this `Local` can also be propagated.\n     FullConstProp,\n     /// The `Local` can only be propagated into and from its own block.\n@@ -828,7 +828,7 @@ enum ConstPropMode {\n     NoPropagation,\n }\n \n-struct CanConstProp {\n+pub struct CanConstProp {\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     // False at the beginning. Once set, no more assignments are allowed to that local.\n     found_assignment: BitSet<Local>,\n@@ -838,7 +838,7 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// Returns true if `local` can be propagated\n-    fn check<'tcx>(\n+    pub fn check<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n         body: &Body<'tcx>,"}, {"sha": "3ae6a88a140ead840ecbe322b11078fa74ad0202", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 15, "deletions": 336, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -1,19 +1,24 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use std::cell::Cell;\n-\n-use rustc_ast::Mutability;\n-use rustc_data_structures::fx::FxHashSet;\n+use crate::const_prop::CanConstProp;\n+use crate::const_prop::ConstPropMachine;\n+use crate::const_prop::ConstPropMode;\n+use crate::MirLint;\n+use rustc_const_eval::const_eval::ConstEvalErr;\n+use rustc_const_eval::interpret::{\n+    self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar,\n+    ScalarMaybeUninit, StackPopCleanup,\n+};\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{\n-    AssertKind, BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind,\n-    Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n-    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+    AssertKind, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, Location, Operand, Place,\n+    Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator,\n+    TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -22,42 +27,15 @@ use rustc_middle::ty::{\n     TypeVisitable,\n };\n use rustc_session::lint;\n-use rustc_span::{def_id::DefId, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n-use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n-\n-use crate::MirLint;\n-use rustc_const_eval::const_eval::ConstEvalErr;\n-use rustc_const_eval::interpret::{\n-    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalState, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n-    StackPopCleanup, StackPopUnwind,\n-};\n+use std::cell::Cell;\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n /// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n /// Severely regress performance.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n-\n-/// Macro for machine-specific `InterpError` without allocation.\n-/// (These will never be shown to the user, but they help diagnose ICEs.)\n-macro_rules! throw_machine_stop_str {\n-    ($($tt:tt)*) => {{\n-        // We make a new local type for it. The type itself does not carry any information,\n-        // but its vtable (for the `MachineStopType` trait) does.\n-        struct Zst;\n-        // Printing this type shows the desired string.\n-        impl std::fmt::Display for Zst {\n-            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-                write!(f, $($tt)*)\n-            }\n-        }\n-        impl rustc_middle::mir::interpret::MachineStopType for Zst {}\n-        throw_machine_stop!(Zst)\n-    }};\n-}\n-\n pub struct ConstProp;\n \n impl<'tcx> MirLint<'tcx> for ConstProp {\n@@ -151,172 +129,6 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n     }\n }\n \n-struct ConstPropMachine<'mir, 'tcx> {\n-    /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-    /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n-    written_only_inside_own_block_locals: FxHashSet<Local>,\n-    /// Locals that need to be cleared after every block terminates.\n-    only_propagate_inside_block_locals: BitSet<Local>,\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n-}\n-\n-impl ConstPropMachine<'_, '_> {\n-    fn new(\n-        only_propagate_inside_block_locals: BitSet<Local>,\n-        can_const_prop: IndexVec<Local, ConstPropMode>,\n-    ) -> Self {\n-        Self {\n-            stack: Vec::new(),\n-            written_only_inside_own_block_locals: Default::default(),\n-            only_propagate_inside_block_locals,\n-            can_const_prop,\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx> {\n-    compile_time_machine!(<'mir, 'tcx>);\n-    const PANIC_ON_ALLOC_FAIL: bool = true; // all allocations are small (see `MAX_ALLOC_LIMIT`)\n-\n-    type MemoryKind = !;\n-\n-    fn load_mir(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::InstanceDef<'tcx>,\n-    ) -> InterpResult<'tcx, &'tcx Body<'tcx>> {\n-        throw_machine_stop_str!(\"calling functions isn't supported in ConstProp\")\n-    }\n-\n-    fn find_mir_or_eval_fn(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _abi: CallAbi,\n-        _args: &[OpTy<'tcx>],\n-        _destination: &PlaceTy<'tcx>,\n-        _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx, Option<(&'mir Body<'tcx>, ty::Instance<'tcx>)>> {\n-        Ok(None)\n-    }\n-\n-    fn call_intrinsic(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _args: &[OpTy<'tcx>],\n-        _destination: &PlaceTy<'tcx>,\n-        _target: Option<BasicBlock>,\n-        _unwind: StackPopUnwind,\n-    ) -> InterpResult<'tcx> {\n-        throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n-    }\n-\n-    fn assert_panic(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _msg: &rustc_middle::mir::AssertMessage<'tcx>,\n-        _unwind: Option<rustc_middle::mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        bug!(\"panics terminators are not evaluated in ConstProp\")\n-    }\n-\n-    fn binary_ptr_op(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        _bin_op: BinOp,\n-        _left: &ImmTy<'tcx>,\n-        _right: &ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        // We can't do this because aliasing of memory can differ between const eval and llvm\n-        throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n-    }\n-\n-    fn access_local<'a>(\n-        frame: &'a Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>,\n-        local: Local,\n-    ) -> InterpResult<'tcx, &'a interpret::Operand<Self::Provenance>> {\n-        let l = &frame.locals[local];\n-\n-        if matches!(\n-            l.value,\n-            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-        ) {\n-            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n-            // So stop here.\n-            throw_machine_stop_str!(\"tried to access a local with unknown value\")\n-        }\n-\n-        l.access()\n-    }\n-\n-    fn access_local_mut<'a>(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-        frame: usize,\n-        local: Local,\n-    ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::Provenance>> {\n-        if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n-            throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n-        }\n-        if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n-            trace!(\n-                \"mutating local {:?} which is restricted to its block. \\\n-                Will remove it from const-prop after block is finished.\",\n-                local\n-            );\n-            ecx.machine.written_only_inside_own_block_locals.insert(local);\n-        }\n-        ecx.machine.stack[frame].locals[local].access_mut()\n-    }\n-\n-    fn before_access_global(\n-        _tcx: TyCtxt<'tcx>,\n-        _machine: &Self,\n-        _alloc_id: AllocId,\n-        alloc: ConstAllocation<'tcx, Self::Provenance, Self::AllocExtra>,\n-        _static_def_id: Option<DefId>,\n-        is_write: bool,\n-    ) -> InterpResult<'tcx> {\n-        if is_write {\n-            throw_machine_stop_str!(\"can't write to global\");\n-        }\n-        // If the static allocation is mutable, then we can't const prop it as its content\n-        // might be different at runtime.\n-        if alloc.inner().mutability == Mutability::Mut {\n-            throw_machine_stop_str!(\"can't access mutable globals in ConstProp\");\n-        }\n-\n-        Ok(())\n-    }\n-\n-    #[inline(always)]\n-    fn expose_ptr(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _ptr: Pointer<AllocId>,\n-    ) -> InterpResult<'tcx> {\n-        throw_machine_stop_str!(\"exposing pointers isn't supported in ConstProp\")\n-    }\n-\n-    #[inline(always)]\n-    fn init_frame_extra(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx>> {\n-        Ok(frame)\n-    }\n-\n-    #[inline(always)]\n-    fn stack<'a>(\n-        ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>] {\n-        &ecx.machine.stack\n-    }\n-\n-    #[inline(always)]\n-    fn stack_mut<'a>(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>> {\n-        &mut ecx.machine.stack\n-    }\n-}\n-\n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n@@ -711,139 +523,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n }\n \n-/// The mode that `ConstProp` is allowed to run in for a given `Local`.\n-#[derive(Clone, Copy, Debug, PartialEq)]\n-enum ConstPropMode {\n-    /// The `Local` can be propagated into and reads of this `Local` can also be propagated.\n-    FullConstProp,\n-    /// The `Local` can only be propagated into and from its own block.\n-    OnlyInsideOwnBlock,\n-    /// The `Local` can be propagated into but reads cannot be propagated.\n-    OnlyPropagateInto,\n-    /// The `Local` cannot be part of propagation at all. Any statement\n-    /// referencing it either for reading or writing will not get propagated.\n-    NoPropagation,\n-}\n-\n-struct CanConstProp {\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n-    // False at the beginning. Once set, no more assignments are allowed to that local.\n-    found_assignment: BitSet<Local>,\n-    // Cache of locals' information\n-    local_kinds: IndexVec<Local, LocalKind>,\n-}\n-\n-impl CanConstProp {\n-    /// Returns true if `local` can be propagated\n-    fn check<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-        body: &Body<'tcx>,\n-    ) -> IndexVec<Local, ConstPropMode> {\n-        let mut cpv = CanConstProp {\n-            can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n-            found_assignment: BitSet::new_empty(body.local_decls.len()),\n-            local_kinds: IndexVec::from_fn_n(\n-                |local| body.local_kind(local),\n-                body.local_decls.len(),\n-            ),\n-        };\n-        for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n-            let ty = body.local_decls[local].ty;\n-            match tcx.layout_of(param_env.and(ty)) {\n-                Ok(layout) if layout.size < Size::from_bytes(MAX_ALLOC_LIMIT) => {}\n-                // Either the layout fails to compute, then we can't use this local anyway\n-                // or the local is too large, then we don't want to.\n-                _ => {\n-                    *val = ConstPropMode::NoPropagation;\n-                    continue;\n-                }\n-            }\n-            // Cannot use args at all\n-            // Cannot use locals because if x < y { y - x } else { x - y } would\n-            //        lint for x != y\n-            // FIXME(oli-obk): lint variables until they are used in a condition\n-            // FIXME(oli-obk): lint if return value is constant\n-            if cpv.local_kinds[local] == LocalKind::Arg {\n-                *val = ConstPropMode::OnlyPropagateInto;\n-                trace!(\n-                    \"local {:?} can't be const propagated because it's a function argument\",\n-                    local\n-                );\n-            } else if cpv.local_kinds[local] == LocalKind::Var {\n-                *val = ConstPropMode::OnlyInsideOwnBlock;\n-                trace!(\n-                    \"local {:?} will only be propagated inside its block, because it's a user variable\",\n-                    local\n-                );\n-            }\n-        }\n-        cpv.visit_body(&body);\n-        cpv.can_const_prop\n-    }\n-}\n-\n-impl Visitor<'_> for CanConstProp {\n-    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n-        use rustc_middle::mir::visit::PlaceContext::*;\n-        match context {\n-            // Projections are fine, because `&mut foo.x` will be caught by\n-            // `MutatingUseContext::Borrow` elsewhere.\n-            MutatingUse(MutatingUseContext::Projection)\n-            // These are just stores, where the storing is not propagatable, but there may be later\n-            // mutations of the same local via `Store`\n-            | MutatingUse(MutatingUseContext::Call)\n-            | MutatingUse(MutatingUseContext::AsmOutput)\n-            | MutatingUse(MutatingUseContext::Deinit)\n-            // Actual store that can possibly even propagate a value\n-            | MutatingUse(MutatingUseContext::SetDiscriminant)\n-            | MutatingUse(MutatingUseContext::Store) => {\n-                if !self.found_assignment.insert(local) {\n-                    match &mut self.can_const_prop[local] {\n-                        // If the local can only get propagated in its own block, then we don't have\n-                        // to worry about multiple assignments, as we'll nuke the const state at the\n-                        // end of the block anyway, and inside the block we overwrite previous\n-                        // states as applicable.\n-                        ConstPropMode::OnlyInsideOwnBlock => {}\n-                        ConstPropMode::NoPropagation => {}\n-                        ConstPropMode::OnlyPropagateInto => {}\n-                        other @ ConstPropMode::FullConstProp => {\n-                            trace!(\n-                                \"local {:?} can't be propagated because of multiple assignments. Previous state: {:?}\",\n-                                local, other,\n-                            );\n-                            *other = ConstPropMode::OnlyInsideOwnBlock;\n-                        }\n-                    }\n-                }\n-            }\n-            // Reading constants is allowed an arbitrary number of times\n-            NonMutatingUse(NonMutatingUseContext::Copy)\n-            | NonMutatingUse(NonMutatingUseContext::Move)\n-            | NonMutatingUse(NonMutatingUseContext::Inspect)\n-            | NonMutatingUse(NonMutatingUseContext::Projection)\n-            | NonUse(_) => {}\n-\n-            // These could be propagated with a smarter analysis or just some careful thinking about\n-            // whether they'd be fine right now.\n-            MutatingUse(MutatingUseContext::Yield)\n-            | MutatingUse(MutatingUseContext::Drop)\n-            | MutatingUse(MutatingUseContext::Retag)\n-            // These can't ever be propagated under any scheme, as we can't reason about indirect\n-            // mutation.\n-            | NonMutatingUse(NonMutatingUseContext::SharedBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::ShallowBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::UniqueBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::AddressOf)\n-            | MutatingUse(MutatingUseContext::Borrow)\n-            | MutatingUse(MutatingUseContext::AddressOf) => {\n-                trace!(\"local {:?} can't be propagaged because it's used: {:?}\", local, context);\n-                self.can_const_prop[local] = ConstPropMode::NoPropagation;\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_body(&mut self, body: &Body<'tcx>) {\n         for (bb, data) in body.basic_blocks().iter_enumerated() {"}, {"sha": "a499179b95f107c70be5c30e40743ee5fcb2fa29", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -1,5 +1,4 @@\n use super::callee::DeferredCallResolution;\n-use super::MaybeInProgressTables;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -29,7 +28,7 @@ use std::ops::Deref;\n pub struct Inherited<'a, 'tcx> {\n     pub(super) infcx: InferCtxt<'a, 'tcx>,\n \n-    pub(super) typeck_results: super::MaybeInProgressTables<'a, 'tcx>,\n+    pub(super) typeck_results: &'a RefCell<ty::TypeckResults<'tcx>>,\n \n     pub(super) locals: RefCell<HirIdMap<super::LocalTy<'tcx>>>,\n \n@@ -110,11 +109,11 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = tcx.hir().maybe_body_owned_by(item_id);\n+        let typeck_results =\n+            infcx.in_progress_typeck_results.expect(\"building `FnCtxt` without typeck results\");\n \n         Inherited {\n-            typeck_results: MaybeInProgressTables {\n-                maybe_typeck_results: infcx.in_progress_typeck_results,\n-            },\n+            typeck_results,\n             infcx,\n             fulfillment_cx: RefCell::new(<dyn TraitEngine<'_>>::new(tcx)),\n             locals: RefCell::new(Default::default()),"}, {"sha": "17c2e4868aac70e3e03eacd37fae0dc9d74b5a2d", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -128,8 +128,7 @@ use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n-\n-use std::cell::{Ref, RefCell, RefMut};\n+use std::cell::RefCell;\n \n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n@@ -900,32 +899,6 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n-/// A wrapper for `InferCtxt`'s `in_progress_typeck_results` field.\n-#[derive(Copy, Clone)]\n-struct MaybeInProgressTables<'a, 'tcx> {\n-    maybe_typeck_results: Option<&'a RefCell<ty::TypeckResults<'tcx>>>,\n-}\n-\n-impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n-    fn borrow(self) -> Ref<'a, ty::TypeckResults<'tcx>> {\n-        match self.maybe_typeck_results {\n-            Some(typeck_results) => typeck_results.borrow(),\n-            None => bug!(\n-                \"MaybeInProgressTables: inh/fcx.typeck_results.borrow() with no typeck results\"\n-            ),\n-        }\n-    }\n-\n-    fn borrow_mut(self) -> RefMut<'a, ty::TypeckResults<'tcx>> {\n-        match self.maybe_typeck_results {\n-            Some(typeck_results) => typeck_results.borrow_mut(),\n-            None => bug!(\n-                \"MaybeInProgressTables: inh/fcx.typeck_results.borrow_mut() with no typeck results\"\n-            ),\n-        }\n-    }\n-}\n-\n fn typeck_item_bodies(tcx: TyCtxt<'_>, (): ()) {\n     tcx.hir().par_body_owners(|body_owner_def_id| tcx.ensure().typeck(body_owner_def_id));\n }"}, {"sha": "a5118e5333b825776e36a84ecb0b44f4f2523d3a", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -317,11 +317,11 @@ use crate::vec::Vec;\n ///\n /// ```text\n /// 0\n-/// 5\n-/// 10\n-/// 20\n-/// 20\n-/// 40\n+/// 8\n+/// 16\n+/// 16\n+/// 32\n+/// 32\n /// ```\n ///\n /// At first, we have no memory allocated at all, but as we append to the"}, {"sha": "ac286c171f0809078c48df25f184a3506575fc0f", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 55, "deletions": 19, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -22,6 +22,8 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use crate::marker::Destruct;\n+\n use self::Ordering::*;\n \n /// Trait for equality comparisons which are [partial equivalence\n@@ -603,7 +605,8 @@ impl Ordering {\n pub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n \n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n-impl<T: PartialOrd> PartialOrd for Reverse<T> {\n+#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+impl<T: ~const PartialOrd> const PartialOrd for Reverse<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n         other.0.partial_cmp(&self.0)\n@@ -761,6 +764,7 @@ impl<T: Clone> Clone for Reverse<T> {\n #[doc(alias = \">=\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Ord\"]\n+#[const_trait]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an [`Ordering`] between `self` and `other`.\n     ///\n@@ -796,8 +800,15 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn max(self, other: Self) -> Self\n     where\n         Self: Sized,\n+        Self: ~const Destruct,\n     {\n-        max_by(self, other, Ord::cmp)\n+        // HACK(fee1-dead): go back to using `self.max_by(other, Ord::cmp)`\n+        // when trait methods are allowed to be used when a const closure is\n+        // expected.\n+        match self.cmp(&other) {\n+            Ordering::Less | Ordering::Equal => other,\n+            Ordering::Greater => self,\n+        }\n     }\n \n     /// Compares and returns the minimum of two values.\n@@ -816,8 +827,15 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn min(self, other: Self) -> Self\n     where\n         Self: Sized,\n+        Self: ~const Destruct,\n     {\n-        min_by(self, other, Ord::cmp)\n+        // HACK(fee1-dead): go back to using `self.min_by(other, Ord::cmp)`\n+        // when trait methods are allowed to be used when a const closure is\n+        // expected.\n+        match self.cmp(&other) {\n+            Ordering::Less | Ordering::Equal => self,\n+            Ordering::Greater => other,\n+        }\n     }\n \n     /// Restrict a value to a certain interval.\n@@ -841,6 +859,8 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn clamp(self, min: Self, max: Self) -> Self\n     where\n         Self: Sized,\n+        Self: ~const Destruct,\n+        Self: ~const PartialOrd,\n     {\n         assert!(min <= max);\n         if self < min {\n@@ -862,15 +882,17 @@ pub macro Ord($item:item) {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for Ordering {\n+#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+impl const Ord for Ordering {\n     #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n         (*self as i32).cmp(&(*other as i32))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for Ordering {\n+#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+impl const PartialOrd for Ordering {\n     #[inline]\n     fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n         (*self as i32).partial_cmp(&(*other as i32))\n@@ -1187,8 +1209,9 @@ pub macro PartialOrd($item:item) {\n #[inline]\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"cmp_min\")]\n-pub fn min<T: Ord>(v1: T, v2: T) -> T {\n+pub const fn min<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n     v1.min(v2)\n }\n \n@@ -1250,8 +1273,9 @@ pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n #[inline]\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"cmp_max\")]\n-pub fn max<T: Ord>(v1: T, v2: T) -> T {\n+pub const fn max<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n     v1.max(v2)\n }\n \n@@ -1304,7 +1328,8 @@ mod impls {\n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl PartialEq for $t {\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl const PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n                 #[inline]\n@@ -1314,7 +1339,8 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl PartialEq for () {\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl const PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool {\n             true\n@@ -1341,7 +1367,8 @@ mod impls {\n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl PartialOrd for $t {\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl const PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                     match (*self <= *other, *self >= *other) {\n@@ -1364,15 +1391,17 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl PartialOrd for () {\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl const PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl PartialOrd for bool {\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl const PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n             Some(self.cmp(other))\n@@ -1384,7 +1413,8 @@ mod impls {\n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl PartialOrd for $t {\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl const PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                     Some(self.cmp(other))\n@@ -1400,7 +1430,8 @@ mod impls {\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl Ord for $t {\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl const Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n                     // The order here is important to generate more optimal assembly.\n@@ -1414,15 +1445,17 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Ord for () {\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl const Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering {\n             Equal\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Ord for bool {\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl const Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n             // Casting to i8's and converting the difference to an Ordering generates\n@@ -1441,7 +1474,8 @@ mod impls {\n     ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    impl PartialEq for ! {\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl const PartialEq for ! {\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n@@ -1451,14 +1485,16 @@ mod impls {\n     impl Eq for ! {}\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    impl PartialOrd for ! {\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl const PartialOrd for ! {\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    impl Ord for ! {\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl const Ord for ! {\n         fn cmp(&self, _: &!) -> Ordering {\n             *self\n         }"}, {"sha": "7e65f4ebdad8ae0c9ca4356559ce2469ec89b889", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -2566,14 +2566,23 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n ///\n /// * `dst` must be properly aligned.\n ///\n-/// Additionally, the caller must ensure that writing `count *\n-/// size_of::<T>()` bytes to the given region of memory results in a valid\n-/// value of `T`. Using a region of memory typed as a `T` that contains an\n-/// invalid value of `T` is undefined behavior.\n-///\n /// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n /// `0`, the pointer must be non-null and properly aligned.\n ///\n+/// Additionally, note that changing `*dst` in this way can easily lead to undefined behavior (UB)\n+/// later if the written bytes are not a valid representation of some `T`. For instance, the\n+/// following is an **incorrect** use of this function:\n+///\n+/// ```rust,no_run\n+/// unsafe {\n+///     let mut value: u8 = 0;\n+///     let ptr: *mut bool = &mut value as *mut u8 as *mut bool;\n+///     let _bool = ptr.read(); // This is fine, `ptr` points to a valid `bool`.\n+///     ptr.write_bytes(42u8, 1); // This function itself does not cause UB...\n+///     let _bool = ptr.read(); // ...but it makes this operation UB! \u26a0\ufe0f\n+/// }\n+/// ```\n+///\n /// [valid]: crate::ptr#safety\n ///\n /// # Examples\n@@ -2590,38 +2599,6 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n /// }\n /// assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);\n /// ```\n-///\n-/// Creating an invalid value:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// let mut v = Box::new(0i32);\n-///\n-/// unsafe {\n-///     // Leaks the previously held value by overwriting the `Box<T>` with\n-///     // a null pointer.\n-///     ptr::write_bytes(&mut v as *mut Box<i32>, 0, 1);\n-/// }\n-///\n-/// // At this point, using or dropping `v` results in undefined behavior.\n-/// // drop(v); // ERROR\n-///\n-/// // Even leaking `v` \"uses\" it, and hence is undefined behavior.\n-/// // mem::forget(v); // ERROR\n-///\n-/// // In fact, `v` is invalid according to basic type layout invariants, so *any*\n-/// // operation touching it is undefined behavior.\n-/// // let v2 = v; // ERROR\n-///\n-/// unsafe {\n-///     // Let us instead put in a valid value\n-///     ptr::write(&mut v as *mut Box<i32>, Box::new(42i32));\n-/// }\n-///\n-/// // Now the box is fine\n-/// assert_eq!(*v, 42);\n-/// ```\n #[doc(alias = \"memset\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(bootstrap), rustc_allowed_through_unstable_modules)]"}, {"sha": "30f2f0ee05c259db5508884732d1e14653f95990", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -105,6 +105,7 @@\n #![feature(const_cell_into_inner)]\n #![feature(const_char_convert)]\n #![feature(const_clone)]\n+#![feature(const_cmp)]\n #![feature(const_discriminant)]\n #![feature(const_eval_select)]\n #![feature(const_float_bits_conv)]"}, {"sha": "8e478cd7bc8a2f9ade1430d59e247a4edbc295ce", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -382,6 +382,14 @@ pub mod token_stream {\n                 bridge::TokenTree::Literal(tt) => TokenTree::Literal(Literal(tt)),\n             })\n         }\n+\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            self.0.size_hint()\n+        }\n+\n+        fn count(self) -> usize {\n+            self.0.count()\n+        }\n     }\n \n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]"}, {"sha": "025157713498e07c4d2afe68689d4546a95e85bd", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -1855,7 +1855,6 @@ in storage.js plus the media query with (min-width: 701px)\n \t\t   the sidebar stays visible for screen readers, which is useful for navigation. */\n \t\tleft: -1000px;\n \t\tmargin-left: 0;\n-\t\tbackground-color: rgba(0,0,0,0);\n \t\tmargin: 0;\n \t\tpadding: 0;\n \t\tz-index: 11;"}, {"sha": "033c65783498fb89143fde3e4ee638a2e19baa5b", "filename": "src/test/rustdoc-gui/sidebar-mobile.goml", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a86705942c4cfaaee60f2e7308ca2bca703a710f/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/a86705942c4cfaaee60f2e7308ca2bca703a710f/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile.goml?ref=a86705942c4cfaaee60f2e7308ca2bca703a710f", "patch": "@@ -40,3 +40,25 @@ assert-position: (\"#method\\.must_use\", {\"y\": 45})\n click: \".sidebar-menu-toggle\"\n scroll-to: \".block.keyword li:nth-child(1)\"\n compare-elements-position-near: (\".block.keyword li:nth-child(1)\", \".mobile-topbar\", {\"y\": 543})\n+\n+// Now checking the background color of the sidebar.\n+local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"dark\"}\n+reload:\n+\n+// Open the sidebar menu.\n+click: \".sidebar-menu-toggle\"\n+assert-css: (\".sidebar\", {\"background-color\": \"rgb(80, 80, 80)\"})\n+\n+local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"ayu\"}\n+reload:\n+\n+// Open the sidebar menu.\n+click: \".sidebar-menu-toggle\"\n+assert-css: (\".sidebar\", {\"background-color\": \"rgb(20, 25, 31)\"})\n+\n+local-storage: {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": \"light\"}\n+reload:\n+\n+// Open the sidebar menu.\n+click: \".sidebar-menu-toggle\"\n+assert-css: (\".sidebar\", {\"background-color\": \"rgb(245, 245, 245)\"})"}]}