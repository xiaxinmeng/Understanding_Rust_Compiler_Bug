{"sha": "9601724b11bbd9081b1bee6f7e478a5d2b9ace41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MDE3MjRiMTFiYmQ5MDgxYjFiZWU2ZjdlNDc4YTVkMmI5YWNlNDE=", "commit": {"author": {"name": "Tamir Duberstein", "email": "tamird@google.com", "date": "2020-10-04T12:39:39Z"}, "committer": {"name": "Tamir Duberstein", "email": "tamird@google.com", "date": "2020-10-04T16:57:54Z"}, "message": "Avoid unchecked casts in net parser", "tree": {"sha": "25b297ea07dd09f512f7f14bd17aa55ab2106e7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25b297ea07dd09f512f7f14bd17aa55ab2106e7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9601724b11bbd9081b1bee6f7e478a5d2b9ace41", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEGdbxTRDxXfPwlFQKMuM+wV4f7zwFAl95/xIACgkQMuM+wV4f\n7zwMbwv8CBfR0AHbOWhfjRhIre9MMZMGhSaeuWZWZE/c2XVzOIaE7TqNCgmnjItL\n4Ymrn/JFKq8+Uw1zrzyl780Q+vAeWBKMYx1wi+gNtBlFcZnM+3jD0Y/rg+5RzSP3\nYZ2W4X/bPxpLmJxKPgfu2VP3nFwMuQwFEmdMB28Cs607/iHazWokZ/VjhU4NEY9t\nf07GbvNUgq8ELYja+LvrmuCbFvI/uqtkN4n1OfbmI3H5fC0jwrpZpLqcI4pE9SRD\nTzxLU7W5WQuK1jJmdWXyZwS3lOSRs9KziFD6XWOCjL1TGibHV2z9xiTxhQoFpaA5\nTDMmNbzfdKSSMPNV33EsmsSOYELvQTxB2TL8VCWbcLqwjLbIASD3ZN5mi86nVjh6\nN/Wl4nu/CLcvW51oeZ2APELWBYBvLdWEFk1evfS5FMgGFgHH4Gf7hyVg/jm7E4s7\nbuRbS0vsvxXETcLNJ+VidOwFaH/oaF52RxsDuVoV/SLwpQ5E8yoW/evsLypnkOJU\n6UlSw1R4\n=BH8r\n-----END PGP SIGNATURE-----", "payload": "tree 25b297ea07dd09f512f7f14bd17aa55ab2106e7c\nparent 0d37dca25a51fb900a402c94c8818ad1c2789e30\nauthor Tamir Duberstein <tamird@google.com> 1601815179 +0000\ncommitter Tamir Duberstein <tamird@google.com> 1601830674 +0000\n\nAvoid unchecked casts in net parser\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9601724b11bbd9081b1bee6f7e478a5d2b9ace41", "html_url": "https://github.com/rust-lang/rust/commit/9601724b11bbd9081b1bee6f7e478a5d2b9ace41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9601724b11bbd9081b1bee6f7e478a5d2b9ace41/comments", "author": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d37dca25a51fb900a402c94c8818ad1c2789e30", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d37dca25a51fb900a402c94c8818ad1c2789e30", "html_url": "https://github.com/rust-lang/rust/commit/0d37dca25a51fb900a402c94c8818ad1c2789e30"}], "stats": {"total": 69, "additions": 46, "deletions": 23}, "files": [{"sha": "da94a5735034fbc344485faead46eab6e38907c9", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9601724b11bbd9081b1bee6f7e478a5d2b9ace41/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9601724b11bbd9081b1bee6f7e478a5d2b9ace41/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=9601724b11bbd9081b1bee6f7e478a5d2b9ace41", "patch": "@@ -6,11 +6,34 @@\n #[cfg(test)]\n mod tests;\n \n+use crate::convert::TryInto as _;\n use crate::error::Error;\n use crate::fmt;\n use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n use crate::str::FromStr;\n \n+trait ReadNumberHelper: crate::marker::Sized {\n+    const ZERO: Self;\n+    fn checked_mul(&self, other: u32) -> Option<Self>;\n+    fn checked_add(&self, other: u32) -> Option<Self>;\n+}\n+\n+macro_rules! impl_helper {\n+    ($($t:ty)*) => ($(impl ReadNumberHelper for $t {\n+        const ZERO: Self = 0;\n+        #[inline]\n+        fn checked_mul(&self, other: u32) -> Option<Self> {\n+            Self::checked_mul(*self, other.try_into().ok()?)\n+        }\n+        #[inline]\n+        fn checked_add(&self, other: u32) -> Option<Self> {\n+            Self::checked_add(*self, other.try_into().ok()?)\n+        }\n+    })*)\n+}\n+\n+impl_helper! { u8 u16 }\n+\n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n     state: &'a [u8],\n@@ -59,7 +82,7 @@ impl<'a> Parser<'a> {\n     fn read_char(&mut self) -> Option<char> {\n         self.state.split_first().map(|(&b, tail)| {\n             self.state = tail;\n-            b as char\n+            char::from(b)\n         })\n     }\n \n@@ -84,25 +107,26 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    // Read a single digit in the given radix. For instance, 0-9 in radix 10;\n-    // 0-9A-F in radix 16.\n-    fn read_digit(&mut self, radix: u32) -> Option<u32> {\n-        self.read_atomically(move |p| p.read_char()?.to_digit(radix))\n-    }\n-\n     // Read a number off the front of the input in the given radix, stopping\n     // at the first non-digit character or eof. Fails if the number has more\n-    // digits than max_digits, or the value is >= upto, or if there is no number.\n-    fn read_number(&mut self, radix: u32, max_digits: u32, upto: u32) -> Option<u32> {\n+    // digits than max_digits or if there is no number.\n+    fn read_number<T: ReadNumberHelper>(\n+        &mut self,\n+        radix: u32,\n+        max_digits: Option<usize>,\n+    ) -> Option<T> {\n         self.read_atomically(move |p| {\n-            let mut result = 0;\n+            let mut result = T::ZERO;\n             let mut digit_count = 0;\n \n-            while let Some(digit) = p.read_digit(radix) {\n-                result = (result * radix) + digit;\n+            while let Some(digit) = p.read_atomically(|p| p.read_char()?.to_digit(radix)) {\n+                result = result.checked_mul(radix)?;\n+                result = result.checked_add(digit)?;\n                 digit_count += 1;\n-                if digit_count > max_digits || result >= upto {\n-                    return None;\n+                if let Some(max_digits) = max_digits {\n+                    if digit_count > max_digits {\n+                        return None;\n+                    }\n                 }\n             }\n \n@@ -116,7 +140,7 @@ impl<'a> Parser<'a> {\n             let mut groups = [0; 4];\n \n             for (i, slot) in groups.iter_mut().enumerate() {\n-                *slot = p.read_separator('.', i, |p| p.read_number(10, 3, 0x100))? as u8;\n+                *slot = p.read_separator('.', i, |p| p.read_number(10, None))?;\n             }\n \n             Some(groups.into())\n@@ -140,17 +164,17 @@ impl<'a> Parser<'a> {\n                     let ipv4 = p.read_separator(':', i, |p| p.read_ipv4_addr());\n \n                     if let Some(v4_addr) = ipv4 {\n-                        let octets = v4_addr.octets();\n-                        groups[i + 0] = ((octets[0] as u16) << 8) | (octets[1] as u16);\n-                        groups[i + 1] = ((octets[2] as u16) << 8) | (octets[3] as u16);\n+                        let [one, two, three, four] = v4_addr.octets();\n+                        groups[i + 0] = u16::from_be_bytes([one, two]);\n+                        groups[i + 1] = u16::from_be_bytes([three, four]);\n                         return (i + 2, true);\n                     }\n                 }\n \n-                let group = p.read_separator(':', i, |p| p.read_number(16, 4, 0x10000));\n+                let group = p.read_separator(':', i, |p| p.read_number(16, Some(4)));\n \n                 match group {\n-                    Some(g) => *slot = g as u16,\n+                    Some(g) => *slot = g,\n                     None => return (i, false),\n                 }\n             }\n@@ -195,12 +219,11 @@ impl<'a> Parser<'a> {\n         self.read_ipv4_addr().map(IpAddr::V4).or_else(move || self.read_ipv6_addr().map(IpAddr::V6))\n     }\n \n-    /// Read a : followed by a port in base 10\n+    /// Read a : followed by a port in base 10.\n     fn read_port(&mut self) -> Option<u16> {\n         self.read_atomically(|p| {\n             let _ = p.read_given_char(':')?;\n-            let port = p.read_number(10, 5, 0x10000)?;\n-            Some(port as u16)\n+            p.read_number(10, None)\n         })\n     }\n "}]}