{"sha": "505fd09f9e020b096d014e68b667268e743c2dd6", "node_id": "C_kwDOAAsO6NoAKDUwNWZkMDlmOWUwMjBiMDk2ZDAxNGU2OGI2NjcyNjhlNzQzYzJkZDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-28T13:26:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-28T13:26:51Z"}, "message": "Auto merge of #14916 - Veykril:typed-hole, r=Veykril\n\nfeat: Add diagnostic for `_` expressions (typed holes)", "tree": {"sha": "04fa0954ba272887cb446fbc03927c7621bd351c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04fa0954ba272887cb446fbc03927c7621bd351c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/505fd09f9e020b096d014e68b667268e743c2dd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/505fd09f9e020b096d014e68b667268e743c2dd6", "html_url": "https://github.com/rust-lang/rust/commit/505fd09f9e020b096d014e68b667268e743c2dd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/505fd09f9e020b096d014e68b667268e743c2dd6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "150082b0e3df91d08301c1547defd4d65f3cba07", "url": "https://api.github.com/repos/rust-lang/rust/commits/150082b0e3df91d08301c1547defd4d65f3cba07", "html_url": "https://github.com/rust-lang/rust/commit/150082b0e3df91d08301c1547defd4d65f3cba07"}, {"sha": "8bc826dd53a7a88798531d7c79d74dbf4d809e56", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc826dd53a7a88798531d7c79d74dbf4d809e56", "html_url": "https://github.com/rust-lang/rust/commit/8bc826dd53a7a88798531d7c79d74dbf4d809e56"}], "stats": {"total": 429, "additions": 368, "deletions": 61}, "files": [{"sha": "5b11343173b300396535bbfd0a714ed642343220", "filename": "crates/base-db/src/fixture.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -21,6 +21,7 @@ use crate::{\n pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n+    #[track_caller]\n     fn with_single_file(ra_fixture: &str) -> (Self, FileId) {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();\n@@ -29,6 +30,7 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         (db, fixture.files[0])\n     }\n \n+    #[track_caller]\n     fn with_many_files(ra_fixture: &str) -> (Self, Vec<FileId>) {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();\n@@ -37,6 +39,7 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         (db, fixture.files)\n     }\n \n+    #[track_caller]\n     fn with_files(ra_fixture: &str) -> Self {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();\n@@ -45,6 +48,7 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         db\n     }\n \n+    #[track_caller]\n     fn with_files_extra_proc_macros(\n         ra_fixture: &str,\n         proc_macros: Vec<(String, ProcMacro)>,\n@@ -56,18 +60,21 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         db\n     }\n \n+    #[track_caller]\n     fn with_position(ra_fixture: &str) -> (Self, FilePosition) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n         let offset = range_or_offset.expect_offset();\n         (db, FilePosition { file_id, offset })\n     }\n \n+    #[track_caller]\n     fn with_range(ra_fixture: &str) -> (Self, FileRange) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n         let range = range_or_offset.expect_range();\n         (db, FileRange { file_id, range })\n     }\n \n+    #[track_caller]\n     fn with_range_or_offset(ra_fixture: &str) -> (Self, FileId, RangeOrOffset) {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();"}, {"sha": "3eaff61b154a041d8812c3eb2bb15a6fdce56eca", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -1046,6 +1046,12 @@ impl HasResolver for GenericDefId {\n     }\n }\n \n+impl HasResolver for EnumVariantId {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n+        self.parent.resolver(db)\n+    }\n+}\n+\n impl HasResolver for VariantId {\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         match self {"}, {"sha": "eec57ba3f80f15c88b9b343c66782e803e2a2792", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -194,6 +194,19 @@ impl TyBuilder<()> {\n         params.placeholder_subst(db)\n     }\n \n+    pub fn unknown_subst(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> Substitution {\n+        let params = generics(db.upcast(), def.into());\n+        Substitution::from_iter(\n+            Interner,\n+            params.iter_id().map(|id| match id {\n+                either::Either::Left(_) => TyKind::Error.intern(Interner).cast(Interner),\n+                either::Either::Right(id) => {\n+                    unknown_const_as_generic(db.const_param_ty(id)).cast(Interner)\n+                }\n+            }),\n+        )\n+    }\n+\n     pub fn subst_for_def(\n         db: &dyn HirDatabase,\n         def: impl Into<GenericDefId>,"}, {"sha": "11c0ccf547d51b4276aba0c1c4b169c7ee4afc29", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -215,6 +215,10 @@ pub enum InferenceDiagnostic {\n         call_expr: ExprId,\n         found: Ty,\n     },\n+    TypedHole {\n+        expr: ExprId,\n+        expected: Ty,\n+    },\n }\n \n /// A mismatch between an expected and an inferred type.\n@@ -600,29 +604,30 @@ impl<'a> InferenceContext<'a> {\n             mismatch.actual = table.resolve_completely(mismatch.actual.clone());\n         }\n         result.diagnostics.retain_mut(|diagnostic| {\n-            if let InferenceDiagnostic::ExpectedFunction { found: ty, .. }\n-            | InferenceDiagnostic::UnresolvedField { receiver: ty, .. }\n-            | InferenceDiagnostic::UnresolvedMethodCall { receiver: ty, .. } = diagnostic\n-            {\n-                *ty = table.resolve_completely(ty.clone());\n-                // FIXME: Remove this when we are on par with rustc in terms of inference\n-                if ty.contains_unknown() {\n-                    return false;\n-                }\n+            use InferenceDiagnostic::*;\n+            match diagnostic {\n+                ExpectedFunction { found: ty, .. }\n+                | UnresolvedField { receiver: ty, .. }\n+                | UnresolvedMethodCall { receiver: ty, .. } => {\n+                    *ty = table.resolve_completely(ty.clone());\n+                    // FIXME: Remove this when we are on par with rustc in terms of inference\n+                    if ty.contains_unknown() {\n+                        return false;\n+                    }\n \n-                if let InferenceDiagnostic::UnresolvedMethodCall { field_with_same_name, .. } =\n-                    diagnostic\n-                {\n-                    let clear = if let Some(ty) = field_with_same_name {\n-                        *ty = table.resolve_completely(ty.clone());\n-                        ty.contains_unknown()\n-                    } else {\n-                        false\n-                    };\n-                    if clear {\n-                        *field_with_same_name = None;\n+                    if let UnresolvedMethodCall { field_with_same_name, .. } = diagnostic {\n+                        if let Some(ty) = field_with_same_name {\n+                            *ty = table.resolve_completely(ty.clone());\n+                            if ty.contains_unknown() {\n+                                *field_with_same_name = None;\n+                            }\n+                        }\n                     }\n                 }\n+                TypedHole { expected: ty, .. } => {\n+                    *ty = table.resolve_completely(ty.clone());\n+                }\n+                _ => (),\n             }\n             true\n         });"}, {"sha": "d7c6691ea0c7a47f6c096dec6555665ccd47b4b7", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -874,9 +874,15 @@ impl<'a> InferenceContext<'a> {\n             },\n             Expr::Underscore => {\n                 // Underscore expressions may only appear in assignee expressions,\n-                // which are handled by `infer_assignee_expr()`, so any underscore\n-                // expression reaching this branch is an error.\n-                self.err_ty()\n+                // which are handled by `infer_assignee_expr()`.\n+                // Any other underscore expression is an error, we render a specialized diagnostic\n+                // to let the user know what type is expected though.\n+                let expected = expected.to_option(&mut self.table).unwrap_or_else(|| self.err_ty());\n+                self.push_diagnostic(InferenceDiagnostic::TypedHole {\n+                    expr: tgt_expr,\n+                    expected: expected.clone(),\n+                });\n+                expected\n             }\n         };\n         // use a new type variable if we got unknown here\n@@ -1001,12 +1007,13 @@ impl<'a> InferenceContext<'a> {\n             }\n             &Array::Repeat { initializer, repeat } => {\n                 self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty.clone()));\n-                self.infer_expr(\n-                    repeat,\n-                    &Expectation::HasType(\n-                        TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n-                    ),\n-                );\n+                let usize = TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner);\n+                match self.body[repeat] {\n+                    Expr::Underscore => {\n+                        self.write_expr_ty(repeat, usize);\n+                    }\n+                    _ => _ = self.infer_expr(repeat, &Expectation::HasType(usize)),\n+                }\n \n                 (\n                     elem_ty,"}, {"sha": "b64d81490bb11e77e5abd61bccef907fa1deeb43", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -52,6 +52,7 @@ diagnostics![\n     PrivateAssocItem,\n     PrivateField,\n     ReplaceFilterMapNextWithFindMap,\n+    TypedHole,\n     TypeMismatch,\n     UndeclaredLabel,\n     UnimplementedBuiltinMacro,\n@@ -73,6 +74,12 @@ pub struct BreakOutsideOfLoop {\n     pub bad_value_break: bool,\n }\n \n+#[derive(Debug)]\n+pub struct TypedHole {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub expected: Type,\n+}\n+\n #[derive(Debug)]\n pub struct UnresolvedModule {\n     pub decl: InFile<AstPtr<ast::Module>>,"}, {"sha": "5392cb6a32a175d886a5361f1a059deff2cfa924", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 60, "deletions": 32, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -69,7 +69,8 @@ use hir_ty::{\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n     GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n-    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, WhereClause,\n+    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, ValueTyDefId,\n+    WhereClause,\n };\n use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n@@ -91,10 +92,10 @@ pub use crate::{\n         IncorrectCase, InvalidDeriveTarget, MacroDefError, MacroError, MacroExpansionParseError,\n         MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms, MissingUnsafe,\n         MovedOutOfRef, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n-        ReplaceFilterMapNextWithFindMap, TypeMismatch, UndeclaredLabel, UnimplementedBuiltinMacro,\n-        UnreachableLabel, UnresolvedExternCrate, UnresolvedField, UnresolvedImport,\n-        UnresolvedMacroCall, UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro,\n-        UnusedMut,\n+        ReplaceFilterMapNextWithFindMap, TypeMismatch, TypedHole, UndeclaredLabel,\n+        UnimplementedBuiltinMacro, UnreachableLabel, UnresolvedExternCrate, UnresolvedField,\n+        UnresolvedImport, UnresolvedMacroCall, UnresolvedMethodCall, UnresolvedModule,\n+        UnresolvedProcMacro, UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1005,6 +1006,10 @@ impl Struct {\n         Type::from_def(db, self.id)\n     }\n \n+    pub fn constructor_ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_value_def(db, self.id)\n+    }\n+\n     pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprOptions> {\n         db.struct_data(self.id).repr\n     }\n@@ -1042,6 +1047,10 @@ impl Union {\n         Type::from_def(db, self.id)\n     }\n \n+    pub fn constructor_ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_value_def(db, self.id)\n+    }\n+\n     pub fn fields(self, db: &dyn HirDatabase) -> Vec<Field> {\n         db.union_data(self.id)\n             .variant_data\n@@ -1173,6 +1182,10 @@ impl Variant {\n         self.parent\n     }\n \n+    pub fn constructor_ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_value_def(db, EnumVariantId { parent: self.parent.id, local_id: self.id })\n+    }\n+\n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n         db.enum_data(self.parent.id).variants[self.id].name.clone()\n     }\n@@ -1574,6 +1587,16 @@ impl DefWithBody {\n                     let expr = expr_syntax(expr);\n                     acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n                 }\n+                hir_ty::InferenceDiagnostic::TypedHole { expr, expected } => {\n+                    let expr = expr_syntax(*expr);\n+                    acc.push(\n+                        TypedHole {\n+                            expr,\n+                            expected: Type::new(db, DefWithBodyId::from(self), expected.clone()),\n+                        }\n+                        .into(),\n+                    )\n+                }\n             }\n         }\n         for (pat_or_expr, mismatch) in infer.type_mismatches() {\n@@ -1806,6 +1829,10 @@ impl Function {\n         db.function_data(self.id).name.clone()\n     }\n \n+    pub fn ty(self, db: &dyn HirDatabase) -> Type {\n+        Type::from_value_def(db, self.id)\n+    }\n+\n     /// Get this function's return type\n     pub fn ret_type(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.resolver(db.upcast());\n@@ -2085,11 +2112,7 @@ impl Const {\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let data = db.const_data(self.id);\n-        let resolver = self.id.resolver(db.upcast());\n-        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n-        let ty = ctx.lower_ty(&data.type_ref);\n-        Type::new_with_resolver_inner(db, &resolver, ty)\n+        Type::from_value_def(db, self.id)\n     }\n \n     pub fn render_eval(self, db: &dyn HirDatabase) -> Result<String, ConstEvalError> {\n@@ -2136,11 +2159,7 @@ impl Static {\n     }\n \n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n-        let data = db.static_data(self.id);\n-        let resolver = self.id.resolver(db.upcast());\n-        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n-        let ty = ctx.lower_ty(&data.type_ref);\n-        Type::new_with_resolver_inner(db, &resolver, ty)\n+        Type::from_value_def(db, self.id)\n     }\n }\n \n@@ -3409,24 +3428,33 @@ impl Type {\n         Type { env: environment, ty }\n     }\n \n-    fn from_def(db: &dyn HirDatabase, def: impl HasResolver + Into<TyDefId>) -> Type {\n-        let ty_def = def.into();\n-        let parent_subst = match ty_def {\n-            TyDefId::TypeAliasId(id) => match id.lookup(db.upcast()).container {\n-                ItemContainerId::TraitId(id) => {\n-                    let subst = TyBuilder::subst_for_def(db, id, None).fill_with_unknown().build();\n-                    Some(subst)\n-                }\n-                ItemContainerId::ImplId(id) => {\n-                    let subst = TyBuilder::subst_for_def(db, id, None).fill_with_unknown().build();\n-                    Some(subst)\n-                }\n-                _ => None,\n+    fn from_def(db: &dyn HirDatabase, def: impl Into<TyDefId> + HasResolver) -> Type {\n+        let ty = db.ty(def.into());\n+        let substs = TyBuilder::unknown_subst(\n+            db,\n+            match def.into() {\n+                TyDefId::AdtId(it) => GenericDefId::AdtId(it),\n+                TyDefId::TypeAliasId(it) => GenericDefId::TypeAliasId(it),\n+                TyDefId::BuiltinType(_) => return Type::new(db, def, ty.skip_binders().clone()),\n             },\n-            _ => None,\n-        };\n-        let ty = TyBuilder::def_ty(db, ty_def, parent_subst).fill_with_unknown().build();\n-        Type::new(db, def, ty)\n+        );\n+        Type::new(db, def, ty.substitute(Interner, &substs))\n+    }\n+\n+    fn from_value_def(db: &dyn HirDatabase, def: impl Into<ValueTyDefId> + HasResolver) -> Type {\n+        let ty = db.value_ty(def.into());\n+        let substs = TyBuilder::unknown_subst(\n+            db,\n+            match def.into() {\n+                ValueTyDefId::ConstId(it) => GenericDefId::ConstId(it),\n+                ValueTyDefId::FunctionId(it) => GenericDefId::FunctionId(it),\n+                ValueTyDefId::StructId(it) => GenericDefId::AdtId(AdtId::StructId(it)),\n+                ValueTyDefId::UnionId(it) => GenericDefId::AdtId(AdtId::UnionId(it)),\n+                ValueTyDefId::EnumVariantId(it) => GenericDefId::EnumVariantId(it),\n+                ValueTyDefId::StaticId(_) => return Type::new(db, def, ty.skip_binders().clone()),\n+            },\n+        );\n+        Type::new(db, def, ty.substitute(Interner, &substs))\n     }\n \n     pub fn new_slice(ty: Type) -> Type {"}, {"sha": "e12bbcf6820686bd1cffa274105c6e4a2b6368b7", "filename": "crates/ide-diagnostics/src/handlers/typed_hole.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftyped_hole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftyped_hole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftyped_hole.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -0,0 +1,232 @@\n+use hir::{db::ExpandDatabase, ClosureStyle, HirDisplay, StructKind};\n+use ide_db::{\n+    assists::{Assist, AssistId, AssistKind, GroupLabel},\n+    label::Label,\n+    source_change::SourceChange,\n+};\n+use syntax::AstNode;\n+use text_edit::TextEdit;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: typed-hole\n+//\n+// This diagnostic is triggered when an underscore expression is used in an invalid position.\n+pub(crate) fn typed_hole(ctx: &DiagnosticsContext<'_>, d: &hir::TypedHole) -> Diagnostic {\n+    let display_range = ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into()));\n+    let (message, fixes) = if d.expected.is_unknown() {\n+        (\"`_` expressions may only appear on the left-hand side of an assignment\".to_owned(), None)\n+    } else {\n+        (\n+            format!(\n+                \"invalid `_` expression, expected type `{}`\",\n+                d.expected.display(ctx.sema.db).with_closure_style(ClosureStyle::ClosureWithId),\n+            ),\n+            fixes(ctx, d),\n+        )\n+    };\n+\n+    Diagnostic::new(\"typed-hole\", message, display_range.range).with_fixes(fixes)\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypedHole) -> Option<Vec<Assist>> {\n+    let db = ctx.sema.db;\n+    let root = db.parse_or_expand(d.expr.file_id);\n+    let original_range =\n+        d.expr.as_ref().map(|it| it.to_node(&root)).syntax().original_file_range_opt(db)?;\n+    let scope = ctx.sema.scope(d.expr.value.to_node(&root).syntax())?;\n+    let mut assists = vec![];\n+    scope.process_all_names(&mut |name, def| {\n+        let ty = match def {\n+            hir::ScopeDef::ModuleDef(it) => match it {\n+                hir::ModuleDef::Function(it) => it.ty(db),\n+                hir::ModuleDef::Adt(hir::Adt::Struct(it)) if it.kind(db) != StructKind::Record => {\n+                    it.constructor_ty(db)\n+                }\n+                hir::ModuleDef::Variant(it) if it.kind(db) != StructKind::Record => {\n+                    it.constructor_ty(db)\n+                }\n+                hir::ModuleDef::Const(it) => it.ty(db),\n+                hir::ModuleDef::Static(it) => it.ty(db),\n+                _ => return,\n+            },\n+            hir::ScopeDef::GenericParam(hir::GenericParam::ConstParam(it)) => it.ty(db),\n+            hir::ScopeDef::Local(it) => it.ty(db),\n+            _ => return,\n+        };\n+        // FIXME: should also check coercions if it is at a coercion site\n+        if !ty.contains_unknown() && ty.could_unify_with(db, &d.expected) {\n+            assists.push(Assist {\n+                id: AssistId(\"typed-hole\", AssistKind::QuickFix),\n+                label: Label::new(format!(\"Replace `_` with `{}`\", name.display(db))),\n+                group: Some(GroupLabel(\"Replace `_` with a matching entity in scope\".to_owned())),\n+                target: original_range.range,\n+                source_change: Some(SourceChange::from_text_edit(\n+                    original_range.file_id,\n+                    TextEdit::replace(original_range.range, name.display(db).to_string()),\n+                )),\n+                trigger_signature_help: false,\n+            });\n+        }\n+    });\n+    if assists.is_empty() {\n+        None\n+    } else {\n+        Some(assists)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fixes};\n+\n+    #[test]\n+    fn unknown() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    _;\n+  //^ error: `_` expressions may only appear on the left-hand side of an assignment\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn concrete_expectation() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    if _ {}\n+     //^ error: invalid `_` expression, expected type `bool`\n+    let _: fn() -> i32 = _;\n+                       //^ error: invalid `_` expression, expected type `fn() -> i32`\n+    let _: fn() -> () = _; // FIXME: This should trigger an assist because `main` matches via *coercion*\n+                      //^ error: invalid `_` expression, expected type `fn()`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn integer_ty_var() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let mut x = 3;\n+    x = _;\n+      //^ \ud83d\udca1 error: invalid `_` expression, expected type `i32`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ty_var_resolved() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let mut x = t();\n+    x = _;\n+      //^ \ud83d\udca1 error: invalid `_` expression, expected type `&str`\n+    x = \"\";\n+}\n+fn t<T>() -> T { loop {} }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn valid_positions() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = [(); _];\n+    let y: [(); 10] = [(); _];\n+    _ = 0;\n+    (_,) = (1,);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn check_quick_fix() {\n+        check_fixes(\n+            r#\"\n+enum Foo {\n+    Bar\n+}\n+use Foo::Bar;\n+const C: Foo = Foo::Bar;\n+fn main<const CP: Foo>(param: Foo) {\n+    let local = Foo::Bar;\n+    let _: Foo = _$0;\n+               //^ error: invalid `_` expression, expected type `fn()`\n+}\n+\"#,\n+            vec![\n+                r#\"\n+enum Foo {\n+    Bar\n+}\n+use Foo::Bar;\n+const C: Foo = Foo::Bar;\n+fn main<const CP: Foo>(param: Foo) {\n+    let local = Foo::Bar;\n+    let _: Foo = local;\n+               //^ error: invalid `_` expression, expected type `fn()`\n+}\n+\"#,\n+                r#\"\n+enum Foo {\n+    Bar\n+}\n+use Foo::Bar;\n+const C: Foo = Foo::Bar;\n+fn main<const CP: Foo>(param: Foo) {\n+    let local = Foo::Bar;\n+    let _: Foo = param;\n+               //^ error: invalid `_` expression, expected type `fn()`\n+}\n+\"#,\n+                r#\"\n+enum Foo {\n+    Bar\n+}\n+use Foo::Bar;\n+const C: Foo = Foo::Bar;\n+fn main<const CP: Foo>(param: Foo) {\n+    let local = Foo::Bar;\n+    let _: Foo = CP;\n+               //^ error: invalid `_` expression, expected type `fn()`\n+}\n+\"#,\n+                r#\"\n+enum Foo {\n+    Bar\n+}\n+use Foo::Bar;\n+const C: Foo = Foo::Bar;\n+fn main<const CP: Foo>(param: Foo) {\n+    let local = Foo::Bar;\n+    let _: Foo = Bar;\n+               //^ error: invalid `_` expression, expected type `fn()`\n+}\n+\"#,\n+                r#\"\n+enum Foo {\n+    Bar\n+}\n+use Foo::Bar;\n+const C: Foo = Foo::Bar;\n+fn main<const CP: Foo>(param: Foo) {\n+    let local = Foo::Bar;\n+    let _: Foo = C;\n+               //^ error: invalid `_` expression, expected type `fn()`\n+}\n+\"#,\n+            ],\n+        );\n+    }\n+}"}, {"sha": "55a4a482d3b289cd33bc7ed163f22f262837181d", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505fd09f9e020b096d014e68b667268e743c2dd6/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=505fd09f9e020b096d014e68b667268e743c2dd6", "patch": "@@ -44,6 +44,7 @@ mod handlers {\n     pub(crate) mod private_assoc_item;\n     pub(crate) mod private_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n+    pub(crate) mod typed_hole;\n     pub(crate) mod type_mismatch;\n     pub(crate) mod unimplemented_builtin_macro;\n     pub(crate) mod unresolved_extern_crate;\n@@ -290,6 +291,7 @@ pub fn diagnostics(\n             AnyDiagnostic::PrivateAssocItem(d) => handlers::private_assoc_item::private_assoc_item(&ctx, &d),\n             AnyDiagnostic::PrivateField(d) => handlers::private_field::private_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n+            AnyDiagnostic::TypedHole(d) => handlers::typed_hole::typed_hole(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),\n             AnyDiagnostic::UndeclaredLabel(d) => handlers::undeclared_label::undeclared_label(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => handlers::unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),"}]}