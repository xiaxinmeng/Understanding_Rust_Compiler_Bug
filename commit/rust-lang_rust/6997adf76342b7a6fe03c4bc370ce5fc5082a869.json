{"sha": "6997adf76342b7a6fe03c4bc370ce5fc5082a869", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OTdhZGY3NjM0MmI3YTZmZTAzYzRiYzM3MGNlNWZjNTA4MmE4Njk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-14T01:38:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-14T01:38:28Z"}, "message": "Remove rustboot from the repository.", "tree": {"sha": "10e8f3cdea19ae3869264db58ff0870ac70f3dfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10e8f3cdea19ae3869264db58ff0870ac70f3dfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6997adf76342b7a6fe03c4bc370ce5fc5082a869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6997adf76342b7a6fe03c4bc370ce5fc5082a869", "html_url": "https://github.com/rust-lang/rust/commit/6997adf76342b7a6fe03c4bc370ce5fc5082a869", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6997adf76342b7a6fe03c4bc370ce5fc5082a869/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef75860a0a72f79f97216f8aaa5b388d98da6480", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef75860a0a72f79f97216f8aaa5b388d98da6480", "html_url": "https://github.com/rust-lang/rust/commit/ef75860a0a72f79f97216f8aaa5b388d98da6480"}], "stats": {"total": 37558, "additions": 2, "deletions": 37556}, "files": [{"sha": "00827e6238d0ced81282c22cec29700d988b3453", "filename": "configure", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6997adf76342b7a6fe03c4bc370ce5fc5082a869/configure", "raw_url": "https://github.com/rust-lang/rust/raw/6997adf76342b7a6fe03c4bc370ce5fc5082a869/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=6997adf76342b7a6fe03c4bc370ce5fc5082a869", "patch": "@@ -176,7 +176,6 @@ fi\n step_msg \"making directories\"\n for i in \\\n     doc \\\n-    boot/fe boot/me boot/be boot/driver boot/util \\\n     rt rt/isaac rt/bigint rt/sync rt/test \\\n     rustllvm \\\n     dl stage0 stage1 stage2 stage3 \\\n@@ -203,11 +202,6 @@ probe CFG_CLANG            clang++\n probe CFG_GCC              gcc\n probe CFG_LLVM_CONFIG      llvm-config\n probe CFG_VALGRIND         valgrind\n-probe CFG_OCAMLC           ocamlc\n-probe CFG_OCAMLOPT         ocamlopt\n-probe CFG_OCAMLC_OPT       ocamlc.opt\n-probe CFG_OCAMLOPT_OPT     ocamlopt.opt\n-probe CFG_FLEXLINK         flexlink\n probe CFG_MAKEINFO         makeinfo\n probe CFG_TEXI2PDF         texi2pdf\n probe CFG_TEX              tex"}, {"sha": "a6ab5ccca59717b731ffa518d5a163e13da2751e", "filename": "mk/boot.mk", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/mk%2Fboot.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/mk%2Fboot.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fboot.mk?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,98 +0,0 @@\n-######################################################################\n-# Bootstrap compiler variables and rules\n-######################################################################\n-\n-ifdef CFG_BOOT_PROFILE\n-  $(info cfg: forcing native bootstrap compiler (CFG_BOOT_PROFILE))\n-  CFG_BOOT_NATIVE := 1\n-  CFG_OCAMLOPT_PROFILE_FLAGS := -p\n-endif\n-\n-ifdef CFG_BOOT_DEBUG\n-  $(info cfg: forcing bytecode bootstrap compiler (CFG_BOOT_DEBUG))\n-  CFG_BOOT_NATIVE :=\n-endif\n-\n-ifdef CFG_BOOT_NATIVE\n-  $(info cfg: building native bootstrap compiler)\n-else\n-  $(info cfg: building bytecode bootstrap compiler)\n-endif\n-\n-GENERATED := boot/fe/lexer.ml boot/version.ml\n-\n-\n-# We must list them in link order.\n-# Nobody calculates the link-order DAG automatically, sadly.\n-\n-BOOT_MLS :=                                              \\\n-    $(addsuffix .ml,                                     \\\n-        boot/version                                     \\\n-        $(addprefix boot/util/, fmt common bits)         \\\n-        $(addprefix boot/driver/, session)               \\\n-        $(addprefix boot/fe/, ast token lexer parser     \\\n-          extfmt pexp item cexp fuzz)                    \\\n-        $(addprefix boot/be/, asm il abi)                \\\n-        $(addprefix boot/me/, walk semant resolve alias  \\\n-          simplify type dead layer typestate             \\\n-         loop layout transutil trans dwarf)              \\\n-        $(addprefix boot/be/, x86 ra pe elf macho)       \\\n-        $(addprefix boot/driver/, lib glue main))        \\\n-\n-BOOT_CMOS := $(BOOT_MLS:.ml=.cmo)\n-BOOT_CMXS := $(BOOT_MLS:.ml=.cmx)\n-BOOT_OBJS := $(BOOT_MLS:.ml=.o)\n-BOOT_CMIS := $(BOOT_MLS:.ml=.cmi)\n-\n-BS := $(S)src/boot\n-\n-BOOT_ML_DEP_INCS := -I $(BS)/fe   -I $(BS)/me      \\\n-                    -I $(BS)/be   -I $(BS)/driver  \\\n-                    -I $(BS)/util -I boot\n-\n-BOOT_ML_INCS    :=  -I boot/fe   -I boot/me      \\\n-                    -I boot/be   -I boot/driver  \\\n-                    -I boot/util -I boot\n-\n-BOOT_ML_LIBS        := unix.cma  nums.cma  bigarray.cma\n-BOOT_ML_NATIVE_LIBS := unix.cmxa nums.cmxa bigarray.cmxa\n-BOOT_OCAMLC_FLAGS   := -g $(BOOT_ML_INCS) -w Ael -warn-error Ael\n-BOOT_OCAMLOPT_FLAGS := -g $(BOOT_ML_INCS) -w Ael -warn-error Ael\n-\n-ifdef CFG_FLEXLINK\n-  BOOT_OCAMLOPT_FLAGS += -cclib -L/usr/lib\n-endif\n-\n-BOOT := $(Q)OCAMLRUNPARAM=\"b1\" boot/rustboot$(X) $(CFG_BOOT_FLAGS) -L stage0\n-\n-\n-ifdef CFG_BOOT_NATIVE\n-boot/rustboot$(X): $(BOOT_CMXS) $(MKFILES)\n-\t@$(call E, link: $@)\n-\t$(Q)ocamlopt$(OPT) -o $@ $(BOOT_OCAMLOPT_FLAGS) $(BOOT_ML_NATIVE_LIBS) \\\n-        $(BOOT_CMXS)\n-else\n-boot/rustboot$(X): $(BOOT_CMOS) $(MKFILES)\n-\t@$(call E, link: $@)\n-\t$(Q)ocamlc$(OPT) -o $@ $(BOOT_OCAMLC_FLAGS) $(BOOT_ML_LIBS) $(BOOT_CMOS)\n-endif\n-\n-boot/version.ml: $(MKFILES)\n-\t@$(call E, git: $@)\n-\t$(Q)(cd $(S) && git log -1 \\\n-      --pretty=format:'let version = \"prerelease (%h %ci)\";;') >$@ || exit 1\n-\n-%.cmo: %.ml $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)ocamlc$(OPT) -c -o $@ $(BOOT_OCAMLC_FLAGS) $<\n-\n-%.cmo: %.cmi $(MKFILES)\n-\n-%.cmx %.o: %.ml $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)ocamlopt$(OPT) -c -o $@ $(BOOT_OCAMLOPT_FLAGS) $<\n-\n-%.ml: %.mll $(MKFILES)\n-\t@$(call E, lex-gen: $@)\n-\t$(Q)ocamllex$(OPT) -q -o $@ $<\n-"}, {"sha": "3f19953929e557c6791c4a34171a8c34fa867f7a", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6997adf76342b7a6fe03c4bc370ce5fc5082a869/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6997adf76342b7a6fe03c4bc370ce5fc5082a869/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=6997adf76342b7a6fe03c4bc370ce5fc5082a869", "patch": "@@ -17,7 +17,6 @@ clean:\n \t@$(call E, cleaning)\n \t$(Q)rm -f $(RUNTIME_OBJS) $(RUNTIME_DEF)\n \t$(Q)rm -f $(RUSTLLVM_LIB_OBJS) $(RUSTLLVM_OBJS_OBJS) $(RUSTLLVM_DEF)\n-\t$(Q)rm -f $(BOOT_CMOS) $(BOOT_CMIS) $(BOOT_CMXS) $(BOOT_OBJS)\n \t$(Q)rm -f $(ML_DEPFILES) $(C_DEPFILES) $(CRATE_DEPFILES)\n \t$(Q)rm -f $(ML_DEPFILES:%.d=%.d.tmp)\n \t$(Q)rm -f $(C_DEPFILES:%.d=%.d.tmp)"}, {"sha": "cbab19d3d6d657a9b73ad046eb7d5c18a7f9ade8", "filename": "mk/platform.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6997adf76342b7a6fe03c4bc370ce5fc5082a869/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6997adf76342b7a6fe03c4bc370ce5fc5082a869/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=6997adf76342b7a6fe03c4bc370ce5fc5082a869", "patch": "@@ -87,9 +87,6 @@ ifdef CFG_WINDOWSY\n   CFG_PATH_MUNGE := $(strip perl -i.bak -p             \\\n                            -e 's@\\\\(\\S)@/\\1@go;'       \\\n                            -e 's@^/([a-zA-Z])/@\\1:/@o;')\n-  ifdef CFG_FLEXLINK\n-    CFG_BOOT_NATIVE := 1\n-  endif\n   CFG_GCCISH_CFLAGS += -march=i686 -O2\n   CFG_GCCISH_LINK_FLAGS += -shared -fPIC\n   CFG_DEF_SUFFIX := .def\n@@ -106,8 +103,6 @@ ifdef CFG_UNIXY\n       $(CFG_LDENV)=$(call CFG_TESTLIB,$(1)):$(CFG_LDPATH) \\\n       $(CFG_VALGRIND) $(1)\n \n-  CFG_BOOT_NATIVE := 1\n-\n   ifdef MINGW_CROSS\n     CFG_EXE_SUFFIX := .exe\n     CFG_LIB_NAME=$(1).dll\n@@ -118,7 +113,6 @@ ifdef CFG_UNIXY\n \n     CFG_INFO := $(info cfg: mingw-cross)\n     CFG_GCCISH_CROSS := i586-mingw32msvc-\n-    CFG_BOOT_FLAGS += -t win32-x86-pe\n     ifdef CFG_VALGRIND\n       CFG_VALGRIND += wine\n     endif"}, {"sha": "4a843a64a092d52548e704d33776e46fe081b9e1", "filename": "src/README", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6997adf76342b7a6fe03c4bc370ce5fc5082a869/src%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/6997adf76342b7a6fe03c4bc370ce5fc5082a869/src%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME?ref=6997adf76342b7a6fe03c4bc370ce5fc5082a869", "patch": "@@ -2,16 +2,7 @@ This is preliminary version of the Rust compiler(s).\n \n Source layout:\n \n-boot/              The bootstrap compiler\n-boot/README        - More-detailed guide to it.\n-boot/fe            - Front end (lexer, parser, AST)\n-boot/me            - Middle end (resolve, check, layout, trans)\n-boot/be            - Back end (IL, RA, insns, asm, objfiles)\n-boot/util          - Ubiquitous helpers\n-boot/driver        - Compiler driver\n-\n-comp/              The self-hosted compiler (\"rustc\": incomplete)\n-comp/*             - Similar structure as in boot/\n+comp/              The self-hosted compiler\n \n rt/                The runtime system\n rt/rust_*.cpp      - The majority of the runtime services"}, {"sha": "e17bfd791accbf4e588c3526d78effe659248d0b", "filename": "src/boot/README", "status": "removed", "additions": 0, "deletions": 405, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2FREADME?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,405 +0,0 @@\n-An informal guide to reading and working on the rustboot compiler.\n-==================================================================\n-\n-First off, know that our current state of development is \"bootstrapping\";\n-this means we've got two compilers on the go and one of them is being used\n-to develop the other. Rustboot is written in ocaml and rustc in rust. The\n-one you *probably* ought to be working on at present is rustc. Rustboot is\n-more for historical comparison and bug-fixing whenever necessary to un-block\n-development of rustc.\n-\n-There's a document similar to this next door, then, in comp/README. The\n-comp directory is where we do work on rustc.\n-\n-If you wish to expand on this document, or have one of the\n-slightly-more-familiar authors add anything else to it, please get in touch or\n-file a bug. Your concerns are probably the same as someone else's.\n-\n-\n-\n-High-level concepts, invariants, 30,000-ft view\n-===============================================\n-\n-Rustboot has 3 main subdirectories: fe, me, and be (front, mid, back\n-end). Helper modules and ubiquitous types are found in util/.\n-\n-The entry-point for the compiler is driver/main.ml, and this file sequences\n-the various parts together.\n-\n-\n-The 4 central data structures:\n-------------------------------\n-\n-#1: fe/ast.ml defines the AST. The AST is treated as immutable after parsing\n-    despite containing some mutable types (hashtbl and such). Many -- though\n-    not all -- nodes within this data structure are wrapped in the type 'a\n-    identified. This is important. An \"identified\" AST node is one that the\n-    parser has marked with a unique node_id value. This node_id is used both\n-    to denote a source location and, more importantly, to key into a large\n-    number of tables later in the compiler. Most additional calculated\n-    properties of a program that the compiler derives are keyed to the node_id\n-    of an identified node.\n-\n-    The types 'a identified, node_id and such are in util/common.ml\n-\n-\n-#2: me/semant.ml defines the Semant.ctxt structure. This is a record of\n-    tables, almost all of which are keyed by node_id. See previous comment\n-    regrding node_id. The Semant module is open in most of the modules within\n-    the me/ directory, and they all refer liberally to the ctxt tables, either\n-    directly or via helper functions in semant. Semant also defines the\n-    mid-end pass-management logic, lookup routines, type folds, and a variety\n-    of other miscallaneous semantic-analysis helpers.\n-\n-\n-#3: be/il.ml defines the IL. This is a small, typed IL based on a type system\n-    that is relatively LLVM-ish, and a control-flow system that is *not*\n-    expression/SSA based like LLVM. It's much dumber than that. The root of\n-    the interesting types in this file is the type 'emitter', which is a\n-    growable buffer along with a few counters.  An emitter is essentially a\n-    buffer of quads. A quad, in turn, is a primitive virtual instruction\n-    ('quad' because it is in its limit a 3-address machine, plus opcode) which\n-    we then ... tend to turn directly into x86 anyways. Sorry; it wasn't clear\n-    during initial construction that we'd wind up stopping at x86, so the IL\n-    is probably superfluous, but there it is.\n-\n-    The IL types are operand = cell | immediate, and cell = reg | mem. Plus a\n-    certain quantity of special-casing and noise for constant-pointer\n-    propagation and addressing modes and whatnot.\n-\n-\n-#4: be/asm.ml defines the Asm.frag type, which is a \"chunk of binary-ish\n-    stuff\" to put in an output file. Words, bytes, lazily-resolved fixups,\n-    constant expressions, 0-terminated strings, alignment boundaries, etc. You\n-    will hopefully not need to produce a lot of this yourself; most of this is\n-    already being emitted.\n-\n-    An important type that gets resolved here is fixup, from util/common.ml.\n-    Fixups are things you can wrap around a frag using an Asm.DEF frag, which\n-    get their size and position (both in-file and in-memory) calculated at\n-    asm-time; but you can refer to them before they're resolved. So any time\n-    the compiler needs to refer to \"the place / size this thingy will be, when\n-    it finally gets boiled down to frags and emitted\" we generate a fixup and\n-    use that. Functions and static data structures, for example, tend to get\n-    fixups assigned to them early on in the middle-end of the compiler.\n-\n-\n-Control and information flow within the compiler:\n--------------------------------------------------\n-\n-- driver/main.ml assumes control on startup. Options are parsed, platform is\n-  detected, etc.\n-\n-\n-- fe/lexer.ml does lexing in any case; fe/parser.ml holds the fundamental\n-  parser-state and parser-combinator functions. Parsing rules are split\n-  between 3 files: fe/cexp.ml, fe/pexp.ml, and fe/item.ml. This split\n-  represents the general structure of the grammar(s):\n-\n-    - The outermost grammar is called \"cexp\" (crate expression), and is an\n-      expression language that describes the crate directives found in crate\n-      files. It's evaluated inside the compiler.\n-\n-    - The next grammar is \"item\", which is a statement language that describes\n-      the directives, declarations and statements found in source files. If\n-      you compile a naked source file, you jump straight to item and then\n-      synthesize a simple crate structure around the result.\n-\n-    - The innermost grammar is \"pexp\" (parsed expression), and is an\n-      expression language used for the shared expression grammar within both\n-      cexp and item. Pexps within cexp are evaluated in the compiler\n-      (non-constant, complex cexps are errors) whereas pexps within items are\n-      desugared to statements and primitive expressions.\n-\n-    - The AST is the output from the item grammar. Pexp and cexp do not escape\n-      the front-end.\n-\n-\n-- driver/main.ml then builds a Semant.ctxt and threads it through the various\n-  middle-end passes. Each pass defines one or more visitors, which is an FRU\n-  copy of the empty_visitor in me/walk.ml. Each visitor performs a particular\n-  task, encapsulates some local state in local variables, and leaves its\n-  results in a table. If the table it's calculating is pass-local, it will be\n-  a local binding within the pass; if it's to be shared with later passes, it\n-  will be a table in Semant.ctxt. Pass order is therefore somewhat important,\n-  so I'll describe it here:\n-\n-    - me/resolve.ml looks up names and connects them to definitions. This\n-      includes expanding all types (as types can occur within names, as part\n-      of a parametric name) and performing all import/export/visibility\n-      judgments. After resolve, we should not be doing any further name-based\n-      lookups (with one exception: typestate does some more name\n-      lookup. Subtle reason, will return to it).\n-\n-      Resolve populates several of the tables near the top of Semant.ctxt:\n-\n-          ctxt_all_cast_types\n-          ctxt_all_defns\n-          ctxt_all_item_names\n-          ctxt_all_item_types\n-          ctxt_all_lvals\n-          ctxt_all_stmts\n-          ctxt_all_type_items\n-          ctxt_block_items\n-          ctxt_block_slots\n-          ctxt_frame_args\n-          ctxt_lval_to_referent\n-          ctxt_node_referenced\n-          ctxt_required_items\n-          ctxt_slot_is_arg\n-          ctxt_slot_keys\n-\n-      The most obviously critical of these are lval_to_referent and all_defns,\n-      which connect subsequent visitors from a reference node to its referent\n-      node, and catalogue all the possible things a referent may be.\n-\n-      Part of resolving that is perhaps not obvious is the task of resolving\n-      and normalizing recursive types. This is what TY_iso is for. Recursive\n-      types in rust have to pass through a tag type on their recursive edge;\n-      TY_iso is an iso-recursive group of tags that refer only to one another;\n-      within a TY_iso, the type term \"TY_idx n\" refers to \"the nth member of\n-      the current TY_iso\". Resolve is responsible for finding such groups and\n-      tying them into such closed-form knots.\n-\n-      TY_name should be completely eliminated in any of the types exiting\n-      resolve.\n-\n-\n-    - me/type.ml is a unification-based typechecker and inference engine. This\n-      is as textbook-y as we could make it. It rewrites \"auto\" slots in the\n-      ctxt_all_defns table when it completes (these are the slots with None as\n-      their Ast.slot_ty).\n-\n-      This file is organized around tyspecs and tyvars.  A tyspec is a\n-      constraint on an unknown type that is implied by its use; tyspecs are\n-      generated during the AST-walk, placed in ref cells (tyvars), and the\n-      cells are and unified with one another. If two tyvars unify, then a new\n-      constraint is created with the tighter of the two and the two previous\n-      tyvars are updated to point to the unified spec. Ideally all constraints\n-      eventually run into a source of a concrete type (or a type otherwise\n-      uniquely-determined by its tyspecs). If not, the type is underdetermined\n-      and we get a type error. Similarly if two tyvars that are supposed to\n-      unify clash in some way (integer unify-with string, say) then there is\n-      also a type error.\n-\n-\n-    - me/typestate.ml is a dataflow-based typestate checker. It is responsible\n-      for ensuring all preconditions are met, including init-before-use. It\n-      also determines slot lifecycle boundaries, and populates the context\n-      tables:\n-\n-          ctxt_constr_ids\n-          ctxt_constrs\n-          ctxt_copy_stmt_is_init\n-          ctxt_post_stmt_slot_drops\n-          ctxt_postconditions\n-          ctxt_poststates\n-          ctxt_preconditions\n-          ctxt_prestates\n-\n-      It is organized around constr_keys, a bunch of bitsets, and a CFG.\n-\n-      A constr_key is a normalized value representing a single constraint that\n-      we wish to be able to refer to within a typestate. Every constr_key gets\n-      a bit number assigned to it. A condition (and a typestate) is a\n-      bit-vector, in which the set bits indicate the constr_keys (indexed by\n-      associatd number) that hold in the condition/typestate.\n-\n-      There are 4 such bitsets generated for each node in the CFG:\n-      precondition/postcondition and prestate/poststate. The visitors here\n-      figure out all the constr_keys we'll need, then assign all the pre/post\n-      conditions, generate the CFG, calculate the typestates from the CFG, and\n-      check that every typestate satisfies its precondition.\n-\n-      (Due to the peculiarity that types are pure terms and are not 'a\n-      identified in our AST, we have to do some name-lookup in here as well\n-      when normalizing the const_keys).\n-\n-\n-    - Effect is relatively simple: it calculates the effect of each type and\n-      item, and checks that they either match their declarations or are\n-      authorized to be lying.\n-\n-\n-    - Loop is even simpler: it calculates loop-depth information for later use\n-      generating foreach loops. It populates the context tables:\n-\n-          ctxt_block_is_loop_body\n-          ctxt_slot_loop_depths\n-          ctxt_stmt_loop_depths\n-\n-\n-    - Alias checks slot-aliasing to ensure none of the rules are broken about\n-      simultaneous aliases and such. It also populates the table\n-      ctxt_slot_is_aliased.\n-\n-\n-    - Layout determines the layout of frames, arguments, objects, closures and\n-      such. This includes deciding which slot should go in a vreg and\n-      generating fixups for all frame-spill regions. It populates the context\n-      tables:\n-\n-          ctxt_block_is_loop_body\n-          ctxt_call_sizes\n-          ctxt_frame_blocks\n-          ctxt_frame_sizes\n-          ctxt_slot_is_obj_state\n-          ctxt_slot_offsets\n-          ctxt_slot_vregs\n-          ctxt_spill_fixups\n-\n-      There is a useful chunk of ASCII-art in the leading comment of layout,\n-      if you want to see how a frame goes together, I recommend reading it.\n-\n-\n-    - Trans is the big one. This is the \"translate AST to IL\" pass, and it's a\n-      bit of a dumping ground, sadly. Probably 4x the size of any other\n-      pass. Stuff that is common to the x86 and LLVM backends is factored out\n-      into transutil.ml, but it hardly helps. Suggestions welcome for\n-      splitting it further.\n-\n-      Trans works *imperatively*. It maintains a stack of emitters, one per\n-      function (or helper-function) and emits Il.quads into the top-of-stack\n-      emitter into while it walks the statements of each function. If at any\n-      point it needs to pause to emit a helper function (\"glue function\") it\n-      pushes a new emitter onto the stack and emits into that.\n-\n-      Trans populates the context tables:\n-\n-          ctxt_all_item_code\n-          ctxt_block_fixups\n-          ctxt_data\n-          ctxt_file_code\n-          ctxt_file_fixups\n-          ctxt_fn_fixups\n-          ctxt_glue_code\n-\n-      The entries in the tables ending in _code are of type Semant.code, which\n-      is an abstract type covering both function and glue-function code; each\n-      holds an executable block of quads, plus an aggregate count of vregs and\n-      a reference to the spill fixup for that code.\n-\n-\n-- Once it completes trans, driver/main.ml does the \"finishing touches\":\n-  register allocates each emitted code value (be/ra.ml), emits dwarf for the\n-  crate (me/dwarf.ml), selects instructions (be/x86.ml), then selects one of\n-  the object-file backends (be/elf.ml, be/macho.ml or be/pe.ml) and emits the\n-  selected Asm.frag to it. Hopefully little of this will require further work;\n-  the most incomplete module here is probably dwarf.ml but the remainder are\n-  mostly stable and don't tend to change much, aside from picking bugs out of\n-  them.\n-\n-\n-\n-Details and curiosities to note along the way:\n-==============================================\n-\n-- Where you might expect there to be a general recursive expression type for\n-  'expr', you'll find only a very limited non-recursive 3-way switch: binary,\n-  unary, or atom; where atom is either a literal or an lval. This is because\n-  all the \"big\" expressions (pexps) were boiled off during the desugaring\n-  phase in the frontend.\n-\n-\n-- There are multiple ways to refer to a path. Names, lvals and cargs all\n-  appear to have similar structure (and do). They're all subsets of the\n-  general path grammar, so all follow the rough shape of being either a base\n-  anchor-path or an ext (extension) path with structural recursion to the\n-  left.\n-\n-  Cargs (constraint arguments) are the sort of paths that can be passed to\n-  constraints in the typestate system, and can contain the special symbol \"*\"\n-  in the grammar, meaning \"thing I am attached to\".  This is the symbol\n-  BASE_formal in the carg_base type.\n-\n-  Names are the sort of paths that refer to types or other items. Not slots.\n-\n-  Lvals are the sort of paths that *might* refer to slots, but we don't\n-  generally know. So they can contain the dynamic-indexing component\n-  COMP_atom. For example, x.(1 + 2).y is an lval.\n-\n-\n-- Only one of these forms is 'a identified: an lval. And moreover, only the\n-  lval *base* is identified; the remainder of the path has to be projected\n-  forward through the referent after lookup. This also means that when you\n-  lookup anything else by name, you have to be using the result immediately,\n-  not storing it in a table for later.\n-\n-\n-- Types are not 'a identified. This means that you (generally) cannot refer to\n-  a *particular* occurrence of a type in the AST and associate information\n-  with it. Instead, we treat types as \"pure terms\" (not carrying identity) and\n-  calculate properties of them on the fly. For this we use a general fold\n-  defined in me/semant.ml, the family of functions held in a ty_fold\n-  structure, and passed to fold_ty.\n-\n-\n-- There is a possibly-surprising type called \"size\" in util/common. This is a\n-  type representing a \"size expression\" that may depend on runtime\n-  information, such as the type descriptors passed to a frame at runtime. This\n-  exists because our type-parameterization scheme is, at the moment,\n-  implemented by passing type descriptors around at runtime, not\n-  code-expansion a la C++ templates. So any time we have a translated indexing\n-  operation or such that depends on a type parameter, we wind up with a size\n-  expression including SIZE_param_size or SIZE_param_align, and have to do\n-  size arithmetic at runtime. Upstream of trans, we generate sizes willy-nilly\n-  and then decide in trans, x86, and dwarf whether they can be emitted\n-  statically or via runtime calculation at the point of use.\n-\n-\n-- Trans generates position-independent code (PIC). This means that it never\n-  refers to the exact position of a fixup in memory at load-time, always the\n-  distance-to-a-fixup from some other fixup, and/or current PC. On x86 this\n-  means we wind up copying the \"get next pc thunk\" trick used on linux\n-  systems, and/or storing \"crate relative\" addresses. The runtime and compiler\n-  \"know\" (unfortunately sometimes quite obscurely) that an immediate pointer\n-  should be encoded as relative-to a given displacement base, and work with\n-  those as necessary.  Similarly, they emit code to reify pointer immediates\n-  (add the displacements to displacement-bases) before handing them off to\n-  (say) C library functions that expect \"real\" pointers. This is all somewhat\n-  messy.\n-\n-\n-- There is one central static data structure, \"rust_crate\", which is emitted\n-  into the final loadable object and contains pointers to all subsequent\n-  information the runtime may be interested in. It also serves as the\n-  displacement base for a variety of PIC-ish displacements stored\n-  elsewhere. When the runtime loads a crate, it dlsym()s rust_crate, and then\n-  digs around in there. It's the entry-point for crawling the crate's\n-  structure from outside. Importantly: it also contains pointers to the dwarf.\n-\n-\n-- Currently we drive linking off dwarf. That is: when a crate needs to 'use'\n-  an item from another dwarf crate, we dlopen / LoadLibrary and find the\n-  \"rust_crate\" value, follow its pointers to dwarf tables, and scan around the\n-  dwarf DIE tree resolving the hierarchical name of the used item. This may\n-  change, we decided to recycle dwarf for this purpose early in the language\n-  evolution and may, given the number of simplifications that have occurred\n-  along the way, be able to fall back to C \"mangled name\" linkage at some\n-  point. Though that decision carries a number of serious constraints, and\n-  should not be taken lightly.\n-\n-\n-\n-Probably-bad ideas we will want to do differently in the self-hosted compiler:\n-==============================================================================\n-\n-- We desugar too early in rustboot and should preserve the pexp structure\n-  until later. Dherman is likely to argue for movement to a more\n-  expression-focused grammar. This may well happen.\n-\n-- Multiple kinds of paths enforced by numerous nearly-isomorphic ML type\n-  constructors is pointless once we're in rust; we can just make type\n-  abbreviations that carry constraints like path : is_name(*) or such.\n-\n-- Storing auxiliary information in semant tables is awkward, and we should\n-  figure out a suitably rusty idiom for decorating AST nodes in-place.\n-  Inter-pass dependencies should be managed by augmenting the AST with\n-  ever-more constraints (is_resolved(ast), is_typechecked(ast), etc.)\n-\n-- Trans should be organized as pure and value-producing code, not imperatively\n-  emitting quads into emitters. LLVM will enforce this anyways. See what\n-  happened in lltrans.ml if you're curious what it'll look (more) like.\n-\n-- The PIC scheme will have to change, hopefully get much easier.\n-"}, {"sha": "3ae3b84350a592039fa8e725b1bdc289fbfe641e", "filename": "src/boot/be/abi.ml", "status": "removed", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,253 +0,0 @@\n-\n-(*\n- * The 'abi' structure is pretty much just a grab-bag of machine\n- * dependencies and structure-layout information. Part of the latter\n- * is shared with trans and semant.\n- *\n- * Make some attempt to factor it as time goes by.\n- *)\n-\n-(* Word offsets for structure fields in rust-internal.h, and elsewhere in\n-   compiler. *)\n-\n-let rc_base_field_refcnt = 0;;\n-\n-(* FIXME: this needs updating if you ever want to work on 64 bit. *)\n-let const_refcount = 0x7badfaceL;;\n-\n-let task_field_refcnt = rc_base_field_refcnt;;\n-let task_field_stk = task_field_refcnt + 2;;\n-let task_field_runtime_sp = task_field_stk + 1;;\n-let task_field_rust_sp = task_field_runtime_sp + 1;;\n-let task_field_gc_alloc_chain = task_field_rust_sp + 1;;\n-let task_field_dom = task_field_gc_alloc_chain + 1;;\n-let n_visible_task_fields = task_field_dom + 1;;\n-\n-let dom_field_interrupt_flag = 1;;\n-\n-let frame_glue_fns_field_mark = 0;;\n-let frame_glue_fns_field_drop = 1;;\n-let frame_glue_fns_field_reloc = 2;;\n-\n-let box_rc_field_refcnt = 0;;\n-let box_rc_field_body = 1;;\n-\n-let box_gc_alloc_base = (-3);;\n-let box_gc_field_prev = (-3);;\n-let box_gc_field_next = (-2);;\n-let box_gc_field_ctrl = (-1);;\n-let box_gc_field_refcnt = 0;;\n-let box_gc_field_body = 1;;\n-\n-let box_rc_header_size = 1;;\n-let box_gc_header_size = 4;;\n-\n-let box_gc_malloc_return_adjustment = 3;;\n-\n-let stk_field_valgrind_id = 0;;\n-let stk_field_limit = stk_field_valgrind_id + 1;;\n-let stk_field_data = stk_field_limit + 1;;\n-\n-(* Both obj and fn are two-word \"bindings\": One word points to some static\n- * dispatch information (vtbl, thunk, callee), and the other points to some\n- * box of bound data (object-body or closure).\n- *)\n-\n-let binding_field_dispatch = 0;;\n-let binding_field_bound_data = 1;;\n-\n-let obj_field_vtbl = binding_field_dispatch;;\n-let obj_field_box = binding_field_bound_data;;\n-\n-let obj_body_elt_tydesc = 0;;\n-let obj_body_elt_fields = 1;;\n-\n-let fn_field_code = binding_field_dispatch;;\n-let fn_field_box = binding_field_bound_data;;\n-\n-(* NB: bound ty params come last to facilitate ignoring them on\n- * closure-dropping. *)\n-let closure_body_elt_bound_args_tydesc = 0;;\n-let closure_body_elt_target = 1;;\n-let closure_body_elt_bound_args = 2;;\n-let closure_body_elt_bound_ty_params = 3;;\n-\n-let tag_elt_discriminant = 0;;\n-let tag_elt_variant = 1;;\n-\n-let general_code_alignment = 16;;\n-\n-let tydesc_field_first_param = 0;;\n-let tydesc_field_size = 1;;\n-let tydesc_field_align = 2;;\n-let tydesc_field_take_glue = 3;;\n-let tydesc_field_drop_glue = 4;;\n-let tydesc_field_free_glue = 5;;\n-let tydesc_field_sever_glue = 6;;\n-let tydesc_field_mark_glue = 7;;\n-let tydesc_field_obj_drop_glue = 8;;\n-let tydesc_field_cmp_glue = 9;;   (* FIXME these two aren't in the *)\n-let tydesc_field_hash_glue = 10;; (* runtime's type_desc struct.   *)\n-let tydesc_field_stateflag = 11;;\n-\n-let vec_elt_rc = 0;;\n-let vec_elt_alloc = 1;;\n-let vec_elt_fill = 2;;\n-let vec_elt_pad = 3;;\n-let vec_elt_data = 4;;\n-\n-let calltup_elt_out_ptr = 0;;\n-let calltup_elt_task_ptr = 1;;\n-let calltup_elt_indirect_args = 2;;\n-let calltup_elt_ty_params = 3;;\n-let calltup_elt_args = 4;;\n-let calltup_elt_iterator_args = 5;;\n-\n-let iterator_args_elt_block_fn = 0;;\n-let iterator_args_elt_outer_frame_ptr = 1;;\n-\n-let indirect_args_elt_closure = 0;;\n-\n-(* Current worst case is by vec grow glue *)\n-let worst_case_glue_call_args = 8;;\n-\n-(* \n- * ABI tags used to inform the runtime which sort of frame to set up for new\n- * spawned functions. FIXME: There is almost certainly a better abstraction to\n- * use.\n- *)\n-let abi_x86_rustboot_cdecl = 1;;\n-let abi_x86_rustc_fastcall = 2;;\n-\n-type abi =\n-    {\n-      abi_word_sz: int64;\n-      abi_word_bits: Il.bits;\n-      abi_word_ty: Common.ty_mach;\n-\n-      abi_tag: int;\n-\n-      abi_has_pcrel_data: bool;\n-      abi_has_pcrel_code: bool;\n-\n-      abi_n_hardregs: int;\n-      abi_str_of_hardreg: (int -> string);\n-\n-      abi_emit_target_specific: (Il.emitter -> Il.quad -> unit);\n-      abi_constrain_vregs: (Il.quad -> (Il.vreg,Bits.t) Hashtbl.t -> unit);\n-\n-      abi_emit_fn_prologue: (Il.emitter\n-                             -> Common.size        (* framesz *)\n-                             -> Common.size      (* callsz  *)\n-                               -> Common.nabi\n-                                 -> Common.fixup (* grow_task *)\n-                                   -> bool       (* is_obj_fn *)\n-                                     -> bool     (* minimal *)\n-                                       -> unit);\n-\n-    abi_emit_fn_epilogue: (Il.emitter -> unit);\n-\n-    abi_emit_fn_tail_call: (Il.emitter\n-                            -> int64            (* caller_callsz *)\n-                              -> int64          (* caller_argsz  *)\n-                                -> Il.code      (* callee_code   *)\n-                                  -> int64      (* callee_argsz  *)\n-                                    -> unit);\n-\n-    abi_clobbers: (Il.quad -> Il.hreg list);\n-\n-    abi_emit_native_call: (Il.emitter\n-                           -> Il.cell                 (* ret    *)\n-                             -> Common.nabi\n-                               -> Common.fixup        (* callee *)\n-                                 -> Il.operand array  (* args   *)\n-                                   -> unit);\n-\n-    abi_emit_native_void_call: (Il.emitter\n-                                -> Common.nabi\n-                                  -> Common.fixup             (* callee *)\n-                                    -> Il.operand array       (* args   *)\n-                                      -> unit);\n-\n-    abi_emit_native_call_in_thunk: (Il.emitter\n-                                    -> Il.cell option         (* ret    *)\n-                                      -> Common.nabi\n-                                        -> Il.operand         (* callee *)\n-                                          -> Il.operand array (* args   *)\n-                                            -> unit);\n-    abi_emit_inline_memcpy: (Il.emitter\n-                             -> int64           (* n_bytes   *)\n-                               -> Il.reg        (* dst_ptr   *)\n-                                 -> Il.reg      (* src_ptr   *)\n-                                   -> Il.reg    (* tmp_reg   *)\n-                                     -> bool    (* ascending *)\n-                                       -> unit);\n-\n-    (* Global glue. *)\n-    abi_activate: (Il.emitter -> unit);\n-    abi_yield: (Il.emitter -> unit);\n-    abi_unwind: (Il.emitter -> Common.nabi -> Common.fixup -> unit);\n-    abi_gc: (Il.emitter -> unit);\n-    abi_get_next_pc_thunk:\n-      ((Il.reg                   (* output            *)\n-        * Common.fixup           (* thunk in objfile  *)\n-        * (Il.emitter -> unit))  (* fn to make thunk  *)\n-         option);\n-\n-    abi_sp_reg: Il.reg;\n-    abi_fp_reg: Il.reg;\n-    abi_dwarf_fp_reg: int;\n-    abi_tp_cell: Il.cell;\n-    abi_implicit_args_sz: int64;\n-    abi_frame_base_sz: int64;\n-    abi_callee_saves_sz: int64;\n-    abi_frame_info_sz: int64;\n-    abi_spill_slot: (Il.spill -> Il.mem);\n-  }\n-;;\n-\n-let load_fixup_addr\n-    (e:Il.emitter)\n-    (out_reg:Il.reg)\n-    (fix:Common.fixup)\n-    (rty:Il.referent_ty)\n-    : unit =\n-\n-  let cell = Il.Reg (out_reg, Il.AddrTy rty) in\n-  let op = Il.ImmPtr (fix, rty) in\n-    Il.emit e (Il.lea cell op);\n-;;\n-\n-let load_fixup_codeptr\n-    (e:Il.emitter)\n-    (out_reg:Il.reg)\n-    (fixup:Common.fixup)\n-    (has_pcrel_code:bool)\n-    (indirect:bool)\n-    : Il.code =\n-  if indirect\n-  then\n-    begin\n-      load_fixup_addr e out_reg fixup (Il.ScalarTy (Il.AddrTy Il.CodeTy));\n-      Il.CodePtr (Il.Cell (Il.Mem (Il.RegIn (out_reg, None),\n-                                   Il.ScalarTy (Il.AddrTy Il.CodeTy))))\n-    end\n-  else\n-    if has_pcrel_code\n-    then (Il.CodePtr (Il.ImmPtr (fixup, Il.CodeTy)))\n-    else\n-      begin\n-        load_fixup_addr e out_reg fixup Il.CodeTy;\n-        Il.CodePtr (Il.Cell (Il.Reg (out_reg, Il.AddrTy Il.CodeTy)))\n-      end\n-;;\n-\n-\n-(* \n- * Local Variables:\n- * fill-column: 78; \n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\"; \n- * End:\n- *)"}, {"sha": "f8284beffa07b73edaae4a0700ae8186de6b8aef", "filename": "src/boot/be/asm.ml", "status": "removed", "additions": 0, "deletions": 831, "changes": 831, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fasm.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fasm.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fasm.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,831 +0,0 @@\n-(*\n-\n-   Our assembler is an all-at-once, buffer-in-memory job, very simple\n-   minded. I have 1gb of memory on my laptop: I don't expect to ever\n-   emit a program that large with this code.\n-\n-   It is based on the 'frag' type, which has a variant for every major\n-   type of machine-blob we know how to write (bytes, zstrings, BSS\n-   blocks, words of various sorts).\n-\n-   A frag can contain symbolic references between the sub-parts of\n-   it. These are accomplished through ref cells we call fixups, and a\n-   2-pass (resolution and writing) process defined recursively over\n-   the frag structure.\n-\n-   Fixups are defined by wrapping a frag in a DEF pseudo-frag with\n-   a fixup attached. This will record information about the wrapped\n-   frag -- positions and sizes -- in the fixup during resolution.\n-\n-   We say \"positions\" and \"sizes\" there, in plural, because both a\n-   file number and a memory number is recorded for each concept.\n-\n-   File numbers refer to positions and sizes in the file we're\n-   generating, and are based on the native int type for the host\n-   platform -- usually 31 or 62 bits -- whereas the expressions that\n-   *use* position fixups tend to promote them up to 32 or 64 bits\n-   somehow. On a 32 bit platform, you can't generate output buffers\n-   with 64-bit positions (ocaml limitation!)\n-\n-   Memory numbers are 64 bit, always, and refer to sizes and positions\n-   of frags when they are loaded into memory in the target. When\n-   you're generating code for a 32-bit target, or using a memory\n-   number in a context that's less than 64 bits, the value is\n-   range-checked and truncated. But in all other respects, we imagine\n-   a 32-bit address space is just the prefix of the continuing 64-bit\n-   address space. If you need to pin an object at a particular place\n-   from the point 2^32-1, say, you will need to do arithmetic and use\n-   the MEMPOS pseudo-frag, that sets the current memory position as\n-   it's being processed.\n-\n-   Fixups can be *used* anywhere else in the frag tree, as many times\n-   as you like. If you try to write an unresolved fixup, the emitter\n-   faults. When you specify the use of a fixup, you need to specify\n-   whether you want to use its file size, file position, memory size,\n-   or memory position.\n-\n-   Positions, addresses, sizes and such, of course, are in bytes.\n-\n-   Expressions are evaluated to an int64 (signed), even if the\n-   expression is an int32 or less. Depending on how you use the result\n-   of the expression, a range check error may fire (for example, if\n-   the expression evaluates to -2^24 and you're emitting a word16).\n-\n-   Word endianness is per-file. At the moment this seems acceptable.\n-\n-   Because we want to be *very specific* about the time and place\n-   arithmetic promotions occur, we define two separate expression-tree\n-   types (with the same polymorphic constructors) and two separate\n-   evaluation functions, with an explicit operator for marking the\n-   promotion-points.\n-\n-*)\n-\n-open Common;;\n-open Fmt;;\n-\n-let log (sess:Session.sess) =\n-  Session.log \"asm\"\n-    sess.Session.sess_log_asm\n-    sess.Session.sess_log_out\n-;;\n-\n-let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n-  if sess.Session.sess_log_asm\n-  then thunk ()\n-  else ()\n-;;\n-\n-exception Bad_fit of string;;\n-exception Undef_sym of string;;\n-\n-type ('a, 'b) expr =\n-    IMM of 'a\n-  | ADD of (('a, 'b) expr) * (('a, 'b) expr)\n-  | SUB of (('a, 'b) expr) * (('a, 'b) expr)\n-  | MUL of (('a, 'b) expr) * (('a, 'b) expr)\n-  | DIV of (('a, 'b) expr) * (('a, 'b) expr)\n-  | REM of (('a, 'b) expr) * (('a, 'b) expr)\n-  | MAX of (('a, 'b) expr) * (('a, 'b) expr)\n-  | ALIGN of (('a, 'b) expr) * (('a, 'b) expr)\n-  | SLL of (('a, 'b) expr) * int\n-  | SLR of (('a, 'b) expr) * int\n-  | SAR of (('a, 'b) expr) * int\n-  | AND of (('a, 'b) expr) * (('a, 'b) expr)\n-  | XOR of (('a, 'b) expr) * (('a, 'b) expr)\n-  | OR of (('a, 'b) expr) * (('a, 'b) expr)\n-  | NOT of (('a, 'b) expr)\n-  | NEG of (('a, 'b) expr)\n-  | F_POS of fixup\n-  | F_SZ of fixup\n-  | M_POS of fixup\n-  | M_SZ of fixup\n-  | EXT of 'b\n-\n-type expr32 = (int32, int) expr\n-;;\n-\n-type expr64 = (int64, expr32) expr\n-;;\n-\n-\n-let rec eval32 (e:expr32)\n-    : int32  =\n-  let chop64 kind name v =\n-    let x = Int64.to_int32 v in\n-      if (Int64.compare v (Int64.of_int32 x)) = 0 then\n-        x\n-      else raise (Bad_fit (kind\n-                           ^ \" fixup \"\n-                           ^ name\n-                           ^ \" overflowed 32 bits in eval32: \"\n-                           ^ Int64.to_string v))\n-  in\n-  let expandInt _ _ v = Int32.of_int v in\n-  let checkdef kind name v inj =\n-    match v with\n-        None ->\n-          raise (Undef_sym (kind ^ \" fixup \" ^ name\n-                            ^ \" undefined in eval32\"))\n-      | Some x -> inj kind name x\n-  in\n-  match e with\n-      IMM i -> i\n-    | ADD (a, b) -> Int32.add (eval32 a) (eval32 b)\n-    | SUB (a, b) -> Int32.sub (eval32 a) (eval32 b)\n-    | MUL (a, b) -> Int32.mul (eval32 a) (eval32 b)\n-    | DIV (a, b) -> Int32.div (eval32 a) (eval32 b)\n-    | REM (a, b) -> Int32.rem (eval32 a) (eval32 b)\n-    | MAX (a, b) -> i32_max (eval32 a) (eval32 b)\n-    | ALIGN (a, b) -> i32_align (eval32 a) (eval32 b)\n-    | SLL (a, b) -> Int32.shift_left (eval32 a) b\n-    | SLR (a, b) -> Int32.shift_right_logical (eval32 a) b\n-    | SAR (a, b) -> Int32.shift_right (eval32 a) b\n-    | AND (a, b) -> Int32.logand (eval32 a) (eval32 b)\n-    | XOR (a, b) -> Int32.logxor (eval32 a) (eval32 b)\n-    | OR (a, b) -> Int32.logor (eval32 a) (eval32 b)\n-    | NOT a -> Int32.lognot (eval32 a)\n-    | NEG a -> Int32.neg (eval32 a)\n-    | F_POS f ->\n-        checkdef \"file position\"\n-          f.fixup_name f.fixup_file_pos expandInt\n-    | F_SZ f ->\n-        checkdef \"file size\"\n-          f.fixup_name f.fixup_file_sz expandInt\n-    | M_POS f ->\n-        checkdef \"mem position\"\n-          f.fixup_name f.fixup_mem_pos chop64\n-    | M_SZ f ->\n-        checkdef \"mem size\" f.fixup_name f.fixup_mem_sz chop64\n-    | EXT i -> Int32.of_int i\n-;;\n-\n-let rec eval64 (e:expr64)\n-    : int64  =\n-  let checkdef kind name v inj =\n-    match v with\n-        None ->\n-          raise (Undef_sym (kind ^ \" fixup '\"\n-                            ^ name ^ \"' undefined in eval64\"))\n-      | Some x -> inj x\n-  in\n-  match e with\n-      IMM i -> i\n-    | ADD (a, b) -> Int64.add (eval64 a) (eval64 b)\n-    | SUB (a, b) -> Int64.sub (eval64 a) (eval64 b)\n-    | MUL (a, b) -> Int64.mul (eval64 a) (eval64 b)\n-    | DIV (a, b) -> Int64.div (eval64 a) (eval64 b)\n-    | REM (a, b) -> Int64.rem (eval64 a) (eval64 b)\n-    | MAX (a, b) -> i64_max (eval64 a) (eval64 b)\n-    | ALIGN (a, b) -> i64_align (eval64 a) (eval64 b)\n-    | SLL (a, b) -> Int64.shift_left (eval64 a) b\n-    | SLR (a, b) -> Int64.shift_right_logical (eval64 a) b\n-    | SAR (a, b) -> Int64.shift_right (eval64 a) b\n-    | AND (a, b) -> Int64.logand (eval64 a) (eval64 b)\n-    | XOR (a, b) -> Int64.logxor (eval64 a) (eval64 b)\n-    | OR (a, b) -> Int64.logor (eval64 a) (eval64 b)\n-    | NOT a -> Int64.lognot (eval64 a)\n-    | NEG a -> Int64.neg (eval64 a)\n-    | F_POS f ->\n-        checkdef \"file position\"\n-          f.fixup_name f.fixup_file_pos Int64.of_int\n-    | F_SZ f ->\n-        checkdef \"file size\"\n-          f.fixup_name f.fixup_file_sz Int64.of_int\n-    | M_POS f ->\n-        checkdef \"mem position\"\n-          f.fixup_name f.fixup_mem_pos (fun x -> x)\n-    | M_SZ f ->\n-        checkdef \"mem size\"\n-          f.fixup_name f.fixup_mem_sz (fun x -> x)\n-    | EXT e -> Int64.of_int32 (eval32 e)\n-;;\n-\n-let rec string_of_expr64 (e64:expr64) : string =\n-  let bin op a b =\n-    Printf.sprintf \"(%s %s %s)\" (string_of_expr64 a) op (string_of_expr64 b)\n-  in\n-  let bini op a b =\n-    Printf.sprintf \"(%s %s %d)\" (string_of_expr64 a) op b\n-  in\n-    match e64 with\n-        IMM i when (i64_lt i 0L) -> Printf.sprintf \"-0x%Lx\" (Int64.neg i)\n-      | IMM i -> Printf.sprintf \"0x%Lx\" i\n-      | ADD (a,b) -> bin \"+\" a b\n-      | SUB (a,b) -> bin \"-\" a b\n-      | MUL (a,b) -> bin \"*\" a b\n-      | DIV (a,b) -> bin \"/\" a b\n-      | REM (a,b) -> bin \"%\" a b\n-      | MAX (a,b) ->\n-          Printf.sprintf \"(max %s %s)\"\n-            (string_of_expr64 a) (string_of_expr64 b)\n-      | ALIGN (a,b) ->\n-          Printf.sprintf \"(align %s %s)\"\n-            (string_of_expr64 a) (string_of_expr64 b)\n-      | SLL (a,b) -> bini \"<<\" a b\n-      | SLR (a,b) -> bini \">>\" a b\n-      | SAR (a,b) -> bini \">>>\" a b\n-      | AND (a,b) -> bin \"&\" a b\n-      | XOR (a,b) -> bin \"xor\" a b\n-      | OR (a,b) -> bin \"|\" a b\n-      | NOT a -> Printf.sprintf \"(not %s)\" (string_of_expr64 a)\n-      | NEG a -> Printf.sprintf \"-%s\" (string_of_expr64 a)\n-      | F_POS f -> Printf.sprintf \"<%s>.fpos\" f.fixup_name\n-      | F_SZ f -> Printf.sprintf \"<%s>.fsz\" f.fixup_name\n-      | M_POS f -> Printf.sprintf \"<%s>.mpos\" f.fixup_name\n-      | M_SZ f -> Printf.sprintf \"<%s>.msz\" f.fixup_name\n-      | EXT _ -> \"??ext??\"\n-;;\n-\n-type frag =\n-    MARK  (* MARK == 'PAD (IMM 0L)' *)\n-  | SEQ of frag array\n-  | PAD of int\n-  | BSS of int64\n-  | MEMPOS of int64\n-  | BYTE of int\n-  | BYTES of int array\n-  | CHAR of char\n-  | STRING of string\n-  | ZSTRING of string\n-  | ULEB128 of expr64\n-  | SLEB128 of expr64\n-  | WORD of (ty_mach * expr64)\n-  | ALIGN_FILE of (int * frag)\n-  | ALIGN_MEM of (int * frag)\n-  | DEF of (fixup * frag)\n-  | RELAX of relaxation\n-\n-and relaxation =\n-    { relax_options: frag array;\n-      relax_choice: int ref; }\n-;;\n-\n-\n-let rec fmt_frag (ff:Format.formatter) (f:frag) : unit =\n-  match f with\n-    MARK -> fmt ff \"MARK\"\n-  | SEQ fs -> fmt_bracketed_arr_sep \"[\" \"]\" \", \" fmt_frag ff fs\n-  | PAD i -> fmt ff \"PAD(%d)\" i\n-  | BSS i -> fmt ff \"BSZ(%Ld)\" i\n-  | MEMPOS i -> fmt ff \"MEMPOS(%Ld)\" i\n-  | BYTE i -> fmt ff \"0x%x\" i\n-  | BYTES iz ->\n-      fmt ff \"BYTES\";\n-      fmt_bracketed_arr_sep \"(\" \")\" \", \"\n-        (fun ff i -> fmt ff \"0x%x\" i) ff iz\n-  | CHAR c -> fmt ff \"CHAR(%s)\" (Char.escaped c)\n-  | STRING s -> fmt ff \"STRING(%s)\" (String.escaped s)\n-  | ZSTRING s -> fmt ff \"ZSTRING(%s)\" (String.escaped s)\n-  | ULEB128 e -> fmt ff \"ULEB128(%s)\" (string_of_expr64 e)\n-  | SLEB128 e -> fmt ff \"SLEB128(%s)\" (string_of_expr64 e)\n-  | WORD (tm, e) ->\n-      fmt ff \"%s:%s\"\n-        (string_of_ty_mach tm) (string_of_expr64 e)\n-  | ALIGN_FILE (i, f) ->\n-      fmt ff \"ALIGN_FILE(%d, \" i;\n-      fmt_frag ff f;\n-      fmt ff \")\"\n-  | ALIGN_MEM (i, f) ->\n-      fmt ff \"ALIGN_MEM(%d, \" i;\n-      fmt_frag ff f;\n-      fmt ff \")\"\n-  | DEF (fix, f) ->\n-      fmt ff \"DEF(%s, \" fix.fixup_name;\n-      fmt_frag ff f;\n-      fmt ff \")\"\n-  | RELAX r ->\n-      fmt ff \"RELAX(\";\n-      fmt_arr_sep \", \" fmt_frag ff r.relax_options\n-;;\n-\n-let sprintf_frag = Fmt.sprintf_fmt fmt_frag;;\n-\n-exception Relax_more of relaxation;;\n-\n-let new_relaxation (frags:frag array) =\n-  RELAX { relax_options = frags;\n-          relax_choice = ref ((Array.length frags) - 1); }\n-;;\n-\n-\n-let rec write_frag\n-    ~(sess:Session.sess)\n-    ~(lsb0:bool)\n-    ~(buf:Buffer.t)\n-    ~(frag:frag)\n-    : unit =\n-  let relax = Queue.create () in\n-  let bump_relax r =\n-    iflog sess (fun _ ->\n-                  log sess \"bumping relaxation to position %d\"\n-                    ((!(r.relax_choice)) - 1));\n-    r.relax_choice := (!(r.relax_choice)) - 1;\n-    if !(r.relax_choice) < 0\n-    then bug () \"relaxation ran out of options\"\n-  in\n-  let rec loop _ =\n-    Queue.clear relax;\n-    Buffer.clear buf;\n-    resolve_frag_full relax frag;\n-    lower_frag ~sess ~lsb0 ~buf ~relax ~frag;\n-    if Queue.is_empty relax\n-    then ()\n-    else\n-      begin\n-        iflog sess (fun _ -> log sess \"relaxing\");\n-        Queue.iter bump_relax relax;\n-        loop ()\n-      end\n-  in\n-    loop ()\n-\n-\n-and resolve_frag_full (relax:relaxation Queue.t) (frag:frag)\n-    : unit =\n-  let file_pos = ref 0 in\n-  let mem_pos = ref 0L in\n-  let bump i =\n-    mem_pos := Int64.add (!mem_pos) (Int64.of_int i);\n-    file_pos := (!file_pos) + i\n-  in\n-\n-  let uleb (e:expr64) : unit =\n-    let rec loop value =\n-      let value = Int64.shift_right_logical value 7 in\n-        if value = 0L\n-        then bump 1\n-        else\n-          begin\n-            bump 1;\n-            loop value\n-          end\n-    in\n-      loop (eval64 e)\n-  in\n-\n-  let sleb (e:expr64) : unit =\n-    let rec loop value =\n-      let byte = Int64.logand value 0xf7L in\n-      let value = Int64.shift_right value 7 in\n-      let signbit = Int64.logand byte 0x40L in\n-        if (((value = 0L) && (signbit = 0L)) ||\n-              ((value = -1L) && (signbit = 0x40L)))\n-        then bump 1\n-        else\n-          begin\n-            bump 1;\n-            loop value\n-          end\n-    in\n-      loop (eval64 e)\n-  in\n-  let rec resolve_frag it =\n-    match it with\n-      | MARK -> ()\n-      | SEQ frags -> Array.iter resolve_frag frags\n-      | PAD i -> bump i\n-      | BSS i -> mem_pos := Int64.add (!mem_pos) i\n-      | MEMPOS i -> mem_pos := i\n-      | BYTE _ -> bump 1\n-      | BYTES ia -> bump (Array.length ia)\n-      | CHAR _ -> bump 1\n-      | STRING s -> bump (String.length s)\n-      | ZSTRING s -> bump ((String.length s) + 1)\n-      | ULEB128 e -> uleb e\n-      | SLEB128 e -> sleb e\n-      | WORD (mach,_) -> bump (bytes_of_ty_mach mach)\n-      | ALIGN_FILE (n, frag) ->\n-          let spill = (!file_pos) mod n in\n-          let pad = (n - spill) mod n in\n-            file_pos := (!file_pos) + pad;\n-            (*\n-             * NB: aligning the file *causes* likewise alignment of\n-             * memory, since we implement \"file alignment\" by\n-             * padding!\n-             *)\n-            mem_pos := Int64.add (!mem_pos) (Int64.of_int pad);\n-            resolve_frag frag\n-\n-      | ALIGN_MEM (n, frag) ->\n-          let n64 = Int64.of_int n in\n-          let spill = Int64.rem (!mem_pos) n64 in\n-          let pad = Int64.rem (Int64.sub n64 spill) n64 in\n-            mem_pos := Int64.add (!mem_pos) pad;\n-            resolve_frag frag\n-\n-      | DEF (f, i) ->\n-          let fpos1 = !file_pos in\n-          let mpos1 = !mem_pos in\n-            resolve_frag i;\n-            f.fixup_file_pos <- Some fpos1;\n-            f.fixup_mem_pos <- Some mpos1;\n-            f.fixup_file_sz <- Some ((!file_pos) - fpos1);\n-            f.fixup_mem_sz <- Some (Int64.sub (!mem_pos) mpos1)\n-\n-      | RELAX rel ->\n-          begin\n-            try\n-              resolve_frag rel.relax_options.(!(rel.relax_choice))\n-            with\n-                Bad_fit _ -> Queue.add rel relax\n-          end\n-  in\n-    resolve_frag frag\n-\n-and lower_frag\n-    ~(sess:Session.sess)\n-    ~(lsb0:bool)\n-    ~(buf:Buffer.t)\n-    ~(relax:relaxation Queue.t)\n-    ~(frag:frag)\n-    : unit =\n-  let byte (i:int) =\n-    if i < 0\n-    then raise (Bad_fit \"byte underflow\")\n-    else\n-      if i > 255\n-      then raise (Bad_fit \"byte overflow\")\n-      else Buffer.add_char buf (Char.chr i)\n-  in\n-\n-  let uleb (e:expr64) : unit =\n-    let emit1 k = Buffer.add_char buf (Char.chr (Int64.to_int k)) in\n-    let rec loop value =\n-      let byte = Int64.logand value 0x7fL in\n-      let value = Int64.shift_right_logical value 7 in\n-        if value = 0L\n-        then emit1 byte\n-        else\n-          begin\n-            emit1 (Int64.logor byte 0x80L);\n-            loop value\n-          end\n-    in\n-      loop (eval64 e)\n-  in\n-\n-  let sleb (e:expr64) : unit =\n-    let emit1 k = Buffer.add_char buf (Char.chr (Int64.to_int k)) in\n-    let rec loop value =\n-      let byte = Int64.logand value 0x7fL in\n-      let value = Int64.shift_right value 7 in\n-      let signbit = Int64.logand byte 0x40L in\n-        if (((value = 0L) && (signbit = 0L)) ||\n-              ((value = -1L) && (signbit = 0x40L)))\n-        then emit1 byte\n-        else\n-          begin\n-            emit1 (Int64.logor byte 0x80L);\n-            loop value\n-          end\n-    in\n-      loop (eval64 e)\n-  in\n-\n-  let word (nbytes:int) (signed:bool) (e:expr64) =\n-    let i = eval64 e in\n-\n-    (*\n-       FIXME:\n-\n-       We should really base the entire assembler and memory-position\n-       system on Big_int.big_int, but in ocaml the big_int type lacks,\n-       oh, just about every useful function (no format string spec, no\n-       bitwise ops, blah blah) so it's useless; we're stuck on int64\n-       for bootstrapping.\n-\n-       For the time being we're just going to require you to represent\n-       those few unsigned 64 bit terms you have in mind via their\n-       signed bit pattern. Suboptimal but it's the best we can do.\n-    *)\n-\n-    let (top,bot) =\n-      if nbytes >= 8\n-      then\n-        if signed\n-        then (Int64.max_int,Int64.min_int)\n-        else (Int64.max_int,0L)\n-      else\n-        if signed\n-        then\n-          let bound = (Int64.shift_left 1L ((8 * nbytes) - 1)) in\n-            (Int64.sub bound 1L, Int64.neg bound)\n-        else\n-          let bound = (Int64.shift_left 1L (8 * nbytes)) in\n-            (Int64.sub bound 1L, 0L)\n-    in\n-\n-    let mask1 = Int64.logand 0xffL in\n-    let shift = Int64.shift_right_logical in\n-    let emit1 k = Buffer.add_char buf (Char.chr (Int64.to_int k)) in\n-      if Int64.compare i bot = (-1)\n-      then raise (Bad_fit (\"word underflow: \"\n-                           ^ (Int64.to_string i)\n-                           ^ \" into \"\n-                           ^ (string_of_int nbytes)\n-                           ^ (if signed then \" signed\" else \" unsigned\")\n-                           ^ \" bytes\"))\n-      else\n-        if Int64.compare i top = 1\n-        then raise (Bad_fit (\"word overflow: \"\n-                             ^ (Int64.to_string i)\n-                             ^ \" into \"\n-                             ^ (string_of_int nbytes)\n-                             ^ (if signed then \" signed\" else \" unsigned\")\n-                             ^ \" bytes\"))\n-        else\n-          if lsb0\n-          then\n-            for n = 0 to (nbytes - 1) do\n-              emit1 (mask1 (shift i (8*n)))\n-            done\n-          else\n-            for n = (nbytes - 1) downto 0 do\n-              emit1 (mask1 (shift i (8*n)))\n-            done\n-  in\n-    match frag with\n-        MARK -> ()\n-\n-      | SEQ frags ->\n-          Array.iter\n-            begin\n-              fun frag ->\n-                lower_frag ~sess ~lsb0 ~buf ~relax ~frag\n-            end frags\n-\n-      | PAD c ->\n-          for i = 1 to c do\n-            Buffer.add_char buf '\\x00'\n-          done\n-\n-      | BSS _ -> ()\n-\n-      | MEMPOS _ -> ()\n-\n-      | BYTE i -> byte i\n-\n-      | BYTES bs ->\n-          iflog sess (fun _ -> log sess \"lowering %d bytes\"\n-                        (Array.length bs));\n-          Array.iter byte bs\n-\n-      | CHAR c ->\n-          iflog sess (fun _ -> log sess \"lowering char: %c\" c);\n-          Buffer.add_char buf c\n-\n-      | STRING s ->\n-          iflog sess (fun _ -> log sess \"lowering string: %s\" s);\n-          Buffer.add_string buf s\n-\n-      | ZSTRING s ->\n-          iflog sess (fun _ -> log sess \"lowering zstring: %s\" s);\n-          Buffer.add_string buf s;\n-          byte 0\n-\n-      | ULEB128 e -> uleb e\n-      | SLEB128 e -> sleb e\n-\n-      | WORD (m,e) ->\n-          iflog sess\n-            (fun _ ->\n-               log sess \"lowering word %s with val %s\"\n-                 (string_of_ty_mach m)\n-                 (fmt_to_str fmt_frag frag));\n-          word (bytes_of_ty_mach m) (mach_is_signed m) e\n-\n-      | ALIGN_FILE (n, frag) ->\n-          let spill = (Buffer.length buf) mod n in\n-          let pad = (n - spill) mod n in\n-            for i = 1 to pad do\n-              Buffer.add_char buf '\\x00'\n-            done;\n-            lower_frag sess lsb0 buf relax frag\n-\n-      | ALIGN_MEM (_, i) -> lower_frag sess lsb0 buf relax i\n-      | DEF (f, i) ->\n-          iflog sess (fun _ -> log sess \"lowering fixup: %s\" f.fixup_name);\n-          lower_frag sess lsb0 buf relax i;\n-\n-      | RELAX rel ->\n-          begin\n-            try\n-              lower_frag sess lsb0 buf relax\n-                rel.relax_options.(!(rel.relax_choice))\n-            with\n-                Bad_fit _ -> Queue.add rel relax\n-          end\n-;;\n-\n-let fold_flags (f:'a -> int64) (flags:'a list) : int64 =\n-  List.fold_left (Int64.logor) 0x0L (List.map f flags)\n-;;\n-\n-let write_out_frag sess lsb0 frag =\n-  let buf = Buffer.create 0xffff in\n-  let file = Session.filename_of sess.Session.sess_out in\n-  let out = open_out_bin file in\n-    write_frag ~sess ~lsb0 ~buf ~frag;\n-    Buffer.output_buffer out buf;\n-    flush out;\n-    close_out out;\n-    Unix.chmod file 0o755\n-;;\n-\n-(* Asm-reader stuff for loading info back from mapped files. *)\n-(*\n- * Unfortunately the ocaml Bigarray interface takes 'int' indices, so\n- * f.e. can't do 64-bit offsets / files when running on a 32bit platform.\n- * Despite the fact that we can possibly produce them. Sigh. Yet another\n- * \"bootstrap compiler limitation\".\n- *)\n-type asm_reader =\n-    {\n-      asm_seek: int -> unit;\n-      asm_get_u32: unit -> int;\n-      asm_get_u16: unit -> int;\n-      asm_get_u8: unit -> int;\n-      asm_get_uleb: unit -> int;\n-      asm_get_zstr: unit -> string;\n-      asm_get_zstr_padded: int -> string;\n-      asm_get_off: unit -> int;\n-      asm_adv: int -> unit;\n-      asm_adv_u32: unit -> unit;\n-      asm_adv_u16: unit -> unit;\n-      asm_adv_u8: unit -> unit;\n-      asm_adv_zstr: unit -> unit;\n-      asm_close: unit -> unit;\n-    }\n-;;\n-\n-type mmap_arr =\n-    (int, Bigarray.int8_unsigned_elt, Bigarray.c_layout)\n-      Bigarray.Array1.t\n-;;\n-\n-let new_asm_reader (sess:Session.sess) (s:filename) : asm_reader =\n-  iflog sess (fun _ -> log sess \"opening file %s\" s);\n-  let fd = Unix.openfile s [ Unix.O_RDONLY ] 0 in\n-  let arr = (Bigarray.Array1.map_file\n-               fd ~pos:0L\n-               Bigarray.int8_unsigned\n-               Bigarray.c_layout\n-               false (-1))\n-  in\n-  let tmp = ref Nativeint.zero in\n-  let buf = Buffer.create 16 in\n-  let off = ref 0 in\n-  let is_open = ref true in\n-  let get_word_as_int (nbytes:int) : int =\n-    assert (!is_open);\n-    let lsb0 = true in\n-      tmp := Nativeint.zero;\n-      if lsb0\n-      then\n-        for j = nbytes-1 downto 0 do\n-          tmp := Nativeint.shift_left (!tmp) 8;\n-          tmp := Nativeint.logor (!tmp) (Nativeint.of_int arr.{(!off) + j})\n-        done\n-      else\n-        for j = 0 to nbytes-1 do\n-          tmp := Nativeint.shift_left (!tmp) 8;\n-          tmp := Nativeint.logor (!tmp) (Nativeint.of_int arr.{(!off) + j})\n-        done;\n-      off := (!off) + nbytes;\n-      Nativeint.to_int (!tmp)\n-  in\n-  let get_zstr_padded pad_opt =\n-    assert (!is_open);\n-    let i = ref (!off) in\n-      Buffer.clear buf;\n-      let buflen_ok _ =\n-        match pad_opt with\n-            None -> true\n-          | Some pad -> (Buffer.length buf) < pad\n-      in\n-      while arr.{!i} != 0 && (buflen_ok()) do\n-        Buffer.add_char buf (Char.chr arr.{!i});\n-        incr i\n-      done;\n-      begin\n-        match pad_opt with\n-            None -> off := (!off) + (Buffer.length buf) + 1\n-          | Some pad ->\n-              begin\n-                assert ((Buffer.length buf) <= pad);\n-                off := (!off) + pad\n-              end\n-      end;\n-      Buffer.contents buf\n-  in\n-  let bump i =\n-    assert (!is_open);\n-    off := (!off) + i\n-  in\n-    {\n-      asm_seek = (fun i -> off := i);\n-      asm_get_u32 = (fun _ -> get_word_as_int 4);\n-      asm_get_u16 = (fun _ -> get_word_as_int 2);\n-      asm_get_u8 = (fun _ -> get_word_as_int 1);\n-      asm_get_uleb =\n-        begin\n-          fun _ ->\n-            let rec loop result shift =\n-              let byte = arr.{!off} in\n-                incr off;\n-                let result = result lor ((byte land 0x7f) lsl shift) in\n-                  if (byte land 0x80) = 0\n-                  then result\n-                  else loop result (shift+7)\n-            in\n-              loop 0 0\n-        end;\n-      asm_get_zstr = (fun _ -> get_zstr_padded None);\n-      asm_get_zstr_padded = (fun pad -> get_zstr_padded (Some pad));\n-      asm_get_off = (fun _ -> !off);\n-      asm_adv = bump;\n-      asm_adv_u32 = (fun _ -> bump 4);\n-      asm_adv_u16 = (fun _ -> bump 2);\n-      asm_adv_u8 = (fun _ -> bump 1);\n-      asm_adv_zstr = (fun _ -> while arr.{!off} != 0\n-                      do incr off done);\n-      asm_close = (fun _ ->\n-                     assert (!is_open);\n-                     Unix.close fd;\n-                     is_open := false)\n-    }\n-;;\n-\n-\n-(* \n- * Metadata note-section encoding / decoding.\n- * \n- * Since the only object format that defines a \"note\" section at all is\n- * ELF, we model the contents of the metadata section on ELF's\n- * notes. But the same blob of data is stuck into PE and Mach-O files\n- * too.\n- * \n- * The format is essentially just the ELF note format:\n- * \n- *    <un-padded-size-of-name:u32>\n- *    <size-of-desc:u32>\n- *    <type-code=0:u32>\n- *    <name=\"rust\":zstr>\n- *    <0-pad to 4-byte boundary>\n- *    <n=meta-count:u32>\n- *    <k1:zstr> <v1:zstr>\n- *    ...\n- *    <kn:zstr> <vn:zstr>\n- *    <0-pad to 4-byte boundary>\n- * \n- *)\n-let note_rust_frags (meta:(Ast.ident * string) array) : frag =\n-  let desc_fixup = new_fixup \".rust.note metadata\" in\n-  let desc =\n-    DEF (desc_fixup,\n-         SEQ [|\n-           WORD (TY_u32, IMM (Int64.of_int (Array.length meta)));\n-           SEQ (Array.map\n-                  (fun (k,v) -> SEQ [| ZSTRING k; ZSTRING v; |])\n-                  meta);\n-           ALIGN_FILE (4, MARK) |])\n-  in\n-  let name = \"rust\" in\n-  let ty = 0L in\n-  let padded_name = SEQ [| ZSTRING name;\n-                           ALIGN_FILE (4, MARK) |]\n-  in\n-  let name_sz = IMM (Int64.of_int ((String.length name) + 1)) in\n-    SEQ [| WORD (TY_u32, name_sz);\n-           WORD (TY_u32, F_SZ desc_fixup);\n-           WORD (TY_u32, IMM ty);\n-           padded_name;\n-           desc;|]\n-;;\n-\n-let read_rust_note (ar:asm_reader) : (Ast.ident * string) array =\n-  ar.asm_adv_u32 ();\n-  ar.asm_adv_u32 ();\n-  assert ((ar.asm_get_u32 ()) = 0);\n-  let rust_name = ar.asm_get_zstr_padded 8 in\n-    assert (rust_name = \"rust\");\n-    let n = ar.asm_get_u32() in\n-    let meta = Queue.create () in\n-      for i = 1 to n\n-      do\n-        let k = ar.asm_get_zstr() in\n-        let v = ar.asm_get_zstr() in\n-          Queue.add (k,v) meta\n-      done;\n-      queue_to_arr meta\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "9ca1b3b6f88669fed90b7487a967ce6ce6f552d3", "filename": "src/boot/be/elf.ml", "status": "removed", "additions": 0, "deletions": 1784, "changes": 1784, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Felf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Felf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Felf.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,1784 +0,0 @@\n-(*\n- * Module for writing System V ELF files.\n- *\n- * FIXME: Presently heavily infected with x86 and elf32 specificities,\n- * though they are reasonably well marked. Needs to be refactored to\n- * depend on abi fields if it's to be usable for other elf\n- * configurations.\n- *)\n-\n-open Asm;;\n-open Common;;\n-\n-let log (sess:Session.sess) =\n-  Session.log \"obj (elf)\"\n-    sess.Session.sess_log_obj\n-    sess.Session.sess_log_out\n-;;\n-\n-let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n-  if sess.Session.sess_log_obj\n-  then thunk ()\n-  else ()\n-;;\n-\n-\n-(* Fixed sizes of structs involved in elf32 spec. *)\n-let elf32_ehsize = 52L;;\n-let elf32_phentsize = 32L;;\n-let elf32_shentsize = 40L;;\n-let elf32_symsize = 16L;;\n-let elf32_rela_entsz = 0xcL;;\n-\n-type ei_class =\n-    ELFCLASSNONE\n-  | ELFCLASS32\n-  | ELFCLASS64\n-;;\n-\n-\n-type ei_data =\n-    ELFDATANONE\n-  | ELFDATA2LSB\n-  | ELFDATA2MSB\n-;;\n-\n-\n-let elf_identification sess ei_class ei_data =\n-  SEQ\n-    [|\n-      STRING \"\\x7fELF\";\n-      BYTES\n-        [|\n-          (match ei_class with  (* EI_CLASS *)\n-               ELFCLASSNONE -> 0\n-             | ELFCLASS32 -> 1\n-             | ELFCLASS64 -> 2);\n-          (match ei_data with   (* EI_DATA *)\n-               ELFDATANONE -> 0\n-             | ELFDATA2LSB -> 1\n-             | ELFDATA2MSB -> 2);\n-\n-          1;                    (* EI_VERSION = EV_CURRENT *)\n-\n-                                (* EI_OSABI *)\n-          (match sess.Session.sess_targ with\n-               FreeBSD_x86_elf -> 9\n-             | _ -> 0);\n-\n-          0;                    (* EI_ABIVERSION *)\n-\n-          0;                    (* EI_PAD #9 *)\n-          0;                    (* EI_PAD #A *)\n-          0;                    (* EI_PAD #B *)\n-          0;                    (* EI_PAD #C *)\n-          0;                    (* EI_PAD #D *)\n-          0;                    (* EI_PAD #E *)\n-          0;                    (* EI_PAD #F *)\n-        |]\n-    |]\n-;;\n-\n-\n-type e_type =\n-    ET_NONE\n-  | ET_REL\n-  | ET_EXEC\n-  | ET_DYN\n-  | ET_CORE\n-;;\n-\n-\n-type e_machine =\n-    (* Maybe support more later. *)\n-    EM_NONE\n-  | EM_386\n-  | EM_X86_64\n-;;\n-\n-\n-type e_version =\n-    EV_NONE\n-  | EV_CURRENT\n-;;\n-\n-\n-let elf32_header\n-    ~(sess:Session.sess)\n-    ~(ei_data:ei_data)\n-    ~(e_type:e_type)\n-    ~(e_machine:e_machine)\n-    ~(e_version:e_version)\n-    ~(e_entry_fixup:fixup)\n-    ~(e_phoff_fixup:fixup)\n-    ~(e_shoff_fixup:fixup)\n-    ~(e_phnum:int64)\n-    ~(e_shnum:int64)\n-    ~(e_shstrndx:int64)\n-    : frag =\n-  let elf_header_fixup = new_fixup \"elf header\" in\n-  let entry_pos =\n-    if sess.Session.sess_library_mode\n-    then (IMM 0L)\n-    else (M_POS e_entry_fixup)\n-  in\n-    DEF\n-      (elf_header_fixup,\n-       SEQ [| elf_identification sess ELFCLASS32 ei_data;\n-              WORD (TY_u16, (IMM (match e_type with\n-                                      ET_NONE -> 0L\n-                                    | ET_REL -> 1L\n-                                    | ET_EXEC -> 2L\n-                                    | ET_DYN -> 3L\n-                                    | ET_CORE -> 4L)));\n-              WORD (TY_u16, (IMM (match e_machine with\n-                                      EM_NONE -> 0L\n-                                    | EM_386 -> 3L\n-                                    | EM_X86_64 -> 62L)));\n-              WORD (TY_u32, (IMM (match e_version with\n-                                      EV_NONE -> 0L\n-                                    | EV_CURRENT -> 1L)));\n-              WORD (TY_u32, entry_pos);\n-              WORD (TY_u32, (F_POS e_phoff_fixup));\n-              WORD (TY_u32, (F_POS e_shoff_fixup));\n-              WORD (TY_u32, (IMM 0L)); (* e_flags *)\n-              WORD (TY_u16, (IMM elf32_ehsize));\n-              WORD (TY_u16, (IMM elf32_phentsize));\n-              WORD (TY_u16, (IMM e_phnum));\n-              WORD (TY_u16, (IMM elf32_shentsize));\n-              WORD (TY_u16, (IMM e_shnum));\n-              WORD (TY_u16, (IMM e_shstrndx));\n-           |])\n-;;\n-\n-\n-type sh_type =\n-    SHT_NULL\n-  | SHT_PROGBITS\n-  | SHT_SYMTAB\n-  | SHT_STRTAB\n-  | SHT_RELA\n-  | SHT_HASH\n-  | SHT_DYNAMIC\n-  | SHT_NOTE\n-  | SHT_NOBITS\n-  | SHT_REL\n-  | SHT_SHLIB\n-  | SHT_DYNSYM\n-;;\n-\n-\n-type sh_flags =\n-    SHF_WRITE\n-  | SHF_ALLOC\n-  | SHF_EXECINSTR\n-;;\n-\n-\n-let section_header\n-    ?(sh_link:int64 option=None)\n-    ?(sh_info:int64 option=None)\n-    ?(zero_sh_addr:bool=false)\n-    ?(sh_flags:sh_flags list=[])\n-    ?(section_fixup:fixup option=None)\n-    ?(sh_addralign:int64=1L)\n-    ?(sh_entsize:int64=0L)\n-    ~(shstring_table_fixup:fixup)\n-    ~(shname_string_fixup:fixup)\n-    (sh_type:sh_type)\n-    : frag =\n-  SEQ\n-    [|\n-      WORD (TY_i32, (SUB\n-                       ((F_POS shname_string_fixup),\n-                        (F_POS shstring_table_fixup))));\n-      WORD (TY_u32, (IMM (match sh_type with\n-                              SHT_NULL -> 0L\n-                            | SHT_PROGBITS -> 1L\n-                            | SHT_SYMTAB -> 2L\n-                            | SHT_STRTAB -> 3L\n-                            | SHT_RELA -> 4L\n-                            | SHT_HASH -> 5L\n-                            | SHT_DYNAMIC -> 6L\n-                            | SHT_NOTE -> 7L\n-                            | SHT_NOBITS -> 8L\n-                            | SHT_REL -> 9L\n-                            | SHT_SHLIB -> 10L\n-                            | SHT_DYNSYM -> 11L)));\n-      WORD (TY_u32, (IMM (fold_flags\n-                            (fun f -> match f with\n-                                 SHF_WRITE -> 0x1L\n-                               | SHF_ALLOC -> 0x2L\n-                               | SHF_EXECINSTR -> 0x4L) sh_flags)));\n-      WORD (TY_u32,\n-            if zero_sh_addr\n-            then IMM 0L\n-            else (match section_fixup with\n-                      None -> (IMM 0L)\n-                    | Some s -> (M_POS s)));\n-      WORD (TY_u32, (match section_fixup with\n-                         None -> (IMM 0L)\n-                       | Some s -> (F_POS s)));\n-      WORD (TY_u32, (match section_fixup with\n-                         None -> (IMM 0L)\n-                       | Some s -> (F_SZ s)));\n-      WORD (TY_u32, (IMM (match sh_link with\n-                              None -> 0L\n-                            | Some i -> i)));\n-      WORD (TY_u32, (IMM (match sh_info with\n-                              None -> 0L\n-                            | Some i -> i)));\n-      WORD (TY_u32, (IMM sh_addralign));\n-      WORD (TY_u32, (IMM sh_entsize));\n-    |]\n-;;\n-\n-\n-type p_type =\n-    PT_NULL\n-  | PT_LOAD\n-  | PT_DYNAMIC\n-  | PT_INTERP\n-  | PT_NOTE\n-  | PT_SHLIB\n-  | PT_PHDR\n-;;\n-\n-\n-type p_flag =\n-    PF_X\n-  | PF_W\n-  | PF_R\n-;;\n-\n-\n-let program_header\n-    ~(p_type:p_type)\n-    ~(segment_fixup:fixup)\n-    ~(p_flags:p_flag list)\n-    ~(p_align:int64)\n-    : frag =\n-  SEQ\n-    [|\n-      WORD (TY_u32, (IMM (match p_type with\n-                              PT_NULL -> 0L\n-                            | PT_LOAD -> 1L\n-                            | PT_DYNAMIC -> 2L\n-                            | PT_INTERP -> 3L\n-                            | PT_NOTE -> 4L\n-                            | PT_SHLIB -> 5L\n-                            | PT_PHDR -> 6L)));\n-      WORD (TY_u32, (F_POS segment_fixup));\n-      WORD (TY_u32, (M_POS segment_fixup));\n-      WORD (TY_u32, (M_POS segment_fixup));\n-      WORD (TY_u32, (F_SZ segment_fixup));\n-      WORD (TY_u32, (M_SZ segment_fixup));\n-      WORD (TY_u32, (IMM (fold_flags\n-                            (fun f ->\n-                               match f with\n-                                   PF_X -> 0x1L\n-                                 | PF_W -> 0x2L\n-                                 | PF_R -> 0x4L)\n-                            p_flags)));\n-      WORD (TY_u32, (IMM p_align));\n-    |]\n-;;\n-\n-\n-type st_bind =\n-    STB_LOCAL\n-  | STB_GLOBAL\n-  | STB_WEAK\n-;;\n-\n-\n-type st_type =\n-    STT_NOTYPE\n-  | STT_OBJECT\n-  | STT_FUNC\n-  | STT_SECTION\n-  | STT_FILE\n-;;\n-\n-\n-(* Special symbol-section indices *)\n-let shn_UNDEF   = 0L;;\n-let shn_ABS     = 0xfff1L;;\n-let shn_ABS     = 0xfff2L;;\n-\n-\n-let symbol\n-    ~(string_table_fixup:fixup)\n-    ~(name_string_fixup:fixup)\n-    ~(sym_target_fixup:fixup option)\n-    ~(st_bind:st_bind)\n-    ~(st_type:st_type)\n-    ~(st_shndx:int64)\n-    : frag =\n-  let st_bind_num =\n-    match st_bind with\n-        STB_LOCAL -> 0L\n-      | STB_GLOBAL -> 1L\n-      | STB_WEAK -> 2L\n-  in\n-  let st_type_num =\n-    match st_type with\n-        STT_NOTYPE -> 0L\n-      | STT_OBJECT -> 1L\n-      | STT_FUNC -> 2L\n-      | STT_SECTION -> 3L\n-      | STT_FILE -> 4L\n-  in\n-    SEQ\n-      [|\n-        WORD (TY_u32, (SUB\n-                         ((F_POS name_string_fixup),\n-                          (F_POS string_table_fixup))));\n-        WORD (TY_u32, (match sym_target_fixup with\n-                           None -> (IMM 0L)\n-                         | Some f -> (M_POS f)));\n-        WORD (TY_u32, (match sym_target_fixup with\n-                           None -> (IMM 0L)\n-                         | Some f -> (M_SZ f)));\n-        WORD (TY_u8,           (* st_info *)\n-              (OR\n-                 ((SLL ((IMM st_bind_num), 4)),\n-                  (AND ((IMM st_type_num), (IMM 0xfL))))));\n-        WORD (TY_u8, (IMM 0L)); (* st_other *)\n-        WORD (TY_u16, (IMM st_shndx));\n-      |]\n-;;\n-\n-type d_tag =\n-    DT_NULL\n-  | DT_NEEDED\n-  | DT_PLTRELSZ\n-  | DT_PLTGOT\n-  | DT_HASH\n-  | DT_STRTAB\n-  | DT_SYMTAB\n-  | DT_RELA\n-  | DT_RELASZ\n-  | DT_RELAENT\n-  | DT_STRSZ\n-  | DT_SYMENT\n-  | DT_INIT\n-  | DT_FINI\n-  | DT_SONAME\n-  | DT_RPATH\n-  | DT_SYMBOLIC\n-  | DT_REL\n-  | DT_RELSZ\n-  | DT_RELENT\n-  | DT_PLTREL\n-  | DT_DEBUG\n-  | DT_TEXTREL\n-  | DT_JMPREL\n-  | DT_BIND_NOW\n-  | DT_INIT_ARRAY\n-  | DT_FINI_ARRAY\n-  | DT_INIT_ARRAYSZ\n-  | DT_FINI_ARRAYSZ\n-  | DT_RUNPATH\n-  | DT_FLAGS\n-  | DT_ENCODING\n-  | DT_PREINIT_ARRAY\n-  | DT_PREINIT_ARRAYSZ\n-;;\n-\n-type elf32_dyn = (d_tag * expr64);;\n-\n-let elf32_num_of_dyn_tag tag =\n-  match tag with\n-      DT_NULL -> 0L\n-    | DT_NEEDED -> 1L\n-    | DT_PLTRELSZ -> 2L\n-    | DT_PLTGOT -> 3L\n-    | DT_HASH -> 4L\n-    | DT_STRTAB -> 5L\n-    | DT_SYMTAB -> 6L\n-    | DT_RELA -> 7L\n-    | DT_RELASZ -> 8L\n-    | DT_RELAENT -> 9L\n-    | DT_STRSZ -> 10L\n-    | DT_SYMENT -> 11L\n-    | DT_INIT -> 12L\n-    | DT_FINI -> 13L\n-    | DT_SONAME -> 14L\n-    | DT_RPATH -> 15L\n-    | DT_SYMBOLIC -> 16L\n-    | DT_REL -> 17L\n-    | DT_RELSZ -> 18L\n-    | DT_RELENT -> 19L\n-    | DT_PLTREL -> 20L\n-    | DT_DEBUG -> 21L\n-    | DT_TEXTREL -> 22L\n-    | DT_JMPREL -> 23L\n-    | DT_BIND_NOW -> 24L\n-    | DT_INIT_ARRAY -> 25L\n-    | DT_FINI_ARRAY -> 26L\n-    | DT_INIT_ARRAYSZ -> 27L\n-    | DT_FINI_ARRAYSZ -> 28L\n-    | DT_RUNPATH -> 29L\n-    | DT_FLAGS -> 30L\n-    | DT_ENCODING -> 31L\n-    | DT_PREINIT_ARRAY -> 32L\n-    | DT_PREINIT_ARRAYSZ -> 33L\n-;;\n-\n-let elf32_dyn_frag d =\n-  let (tag, expr) = d in\n-  let tagval = elf32_num_of_dyn_tag tag in\n-    SEQ [| WORD (TY_u32, (IMM tagval)); WORD (TY_u32, expr) |]\n-;;\n-\n-type elf32_386_reloc_type =\n-    R_386_NONE\n-  | R_386_32\n-  | R_386_PC32\n-  | R_386_GOT32\n-  | R_386_PLT32\n-  | R_386_COPY\n-  | R_386_GLOB_DAT\n-  | R_386_JMP_SLOT\n-  | R_386_RELATIVE\n-  | R_386_GOTOFF\n-  | R_386_GOTPC\n-;;\n-\n-\n-type elf32_386_rela =\n-    { elf32_386_rela_type: elf32_386_reloc_type;\n-      elf32_386_rela_offset: expr64;\n-      elf32_386_rela_sym: expr64;\n-      elf32_386_rela_addend: expr64 }\n-;;\n-\n-let elf32_386_rela_frag r =\n-  let type_val =\n-    match r.elf32_386_rela_type with\n-        R_386_NONE -> 0L\n-      | R_386_32 -> 1L\n-      | R_386_PC32 -> 2L\n-      | R_386_GOT32 -> 3L\n-      | R_386_PLT32 -> 4L\n-      | R_386_COPY -> 5L\n-      | R_386_GLOB_DAT -> 6L\n-      | R_386_JMP_SLOT -> 7L\n-      | R_386_RELATIVE -> 8L\n-      | R_386_GOTOFF -> 9L\n-      | R_386_GOTPC -> 10L\n-  in\n-  let info_expr =\n-    WORD (TY_u32,\n-          (OR\n-             (SLL ((r.elf32_386_rela_sym), 8),\n-              AND ((IMM 0xffL), (IMM type_val)))))\n-  in\n-    SEQ [| WORD (TY_u32, r.elf32_386_rela_offset);\n-           info_expr;\n-           WORD (TY_u32, r.elf32_386_rela_addend) |]\n-;;\n-\n-\n-let elf32_linux_x86_file\n-    ~(sess:Session.sess)\n-    ~(crate:Ast.crate)\n-    ~(entry_name:string)\n-    ~(text_frags:(string option, frag) Hashtbl.t)\n-    ~(data_frags:(string option, frag) Hashtbl.t)\n-    ~(bss_frags:(string option, frag) Hashtbl.t)\n-    ~(rodata_frags:(string option, frag) Hashtbl.t)\n-    ~(required_fixups:(string, fixup) Hashtbl.t)\n-    ~(dwarf:Dwarf.debug_records)\n-    ~(sem:Semant.ctxt)\n-    ~(needed_libs:string array)\n-    : frag =\n-\n-  (* Procedure Linkage Tables (PLTs), Global Offset Tables\n-   * (GOTs), and the relocations that set them up:\n-   *\n-   * The PLT goes in a section called .plt and GOT in a section called\n-   * .got. The portion of the GOT that holds PLT jump slots goes in a\n-   * section called .got.plt. Dynamic relocations for these jump slots go in\n-   * section .rela.plt.\n-   *\n-   * The easiest way to understand the PLT/GOT system is to draw it:\n-   *\n-   *     PLT                          GOT\n-   *   +----------------------+     +----------------------+\n-   *  0| push &<GOT[1]>            0| <reserved>\n-   *   | jmp *GOT[2]               1| <libcookie>\n-   *   |                           2| & <ld.so:resolve-a-sym>\n-   *  1| jmp *GOT[3]               3| & <'push 0' in PLT[1]>\n-   *   | push 0                    4| & <'push 1' in PLT[2]>\n-   *   | jmp *PLT[0]               5| & <'push 2' in PLT[3]>\n-   *   |\n-   *  2| jmp *GOT[4]\n-   *   | push 1\n-   *   | jmp *PLT[0]\n-   *   |\n-   *  2| jmp *GOT[5]\n-   *   | push 2\n-   *   | jmp *PLT[0]\n-   *\n-   *\n-   * In normal user code, we call PLT entries with a call to a\n-   * PC-relative address, the PLT entry, which itself does an indirect\n-   * jump through a slot in the GOT that it also addresses\n-   * PC-relative. This makes the whole scheme PIC.\n-   *\n-   * The linker fills in the GOT on startup. For the first 3, it uses\n-   * its own thinking. For the remainder it needs to be instructed to\n-   * fill them in with \"jump slot relocs\", type R_386_JUMP_SLOT, each\n-   * of which says in effect which PLT entry it's to point back to and\n-   * which symbol it's to be resolved to later. These relocs go in the\n-   * section .rela.plt.\n-   *)\n-\n-    let plt0_fixup = new_fixup \"PLT[0]\" in\n-    let got_prefix = SEQ [| WORD (TY_u32, (IMM 0L));\n-                            WORD (TY_u32, (IMM 0L));\n-                            WORD (TY_u32, (IMM 0L)); |]\n-    in\n-\n-    let got_cell reg i =\n-      let got_entry_off = Int64.of_int (i*4) in\n-      let got_entry_mem = Il.RegIn (reg, (Some (Asm.IMM got_entry_off))) in\n-        Il.Mem (got_entry_mem, Il.ScalarTy (Il.AddrTy Il.CodeTy))\n-    in\n-\n-    let got_code_cell reg i =\n-      Il.CodePtr (Il.Cell (got_cell reg i))\n-    in\n-\n-    let plt0_frag =\n-      let reg = Il.Hreg X86.eax in\n-      let e = X86.new_emitter_without_vregs () in\n-        Il.emit e (Il.Push (Il.Cell (got_cell reg 1)));\n-        Il.emit e (Il.jmp Il.JMP (got_code_cell reg 2));\n-        Il.emit e Il.Nop;\n-        Il.emit e Il.Nop;\n-        Il.emit e Il.Nop;\n-        Il.emit e Il.Nop;\n-        DEF (plt0_fixup, (X86.frags_of_emitted_quads sess e))\n-    in\n-\n-  (*\n-   * The existence of the GOT/PLT mish-mash causes, therefore, the\n-   * following new sections:\n-   *\n-   *   .plt       - the PLT itself, in the r/x text segment\n-   *   .got.plt   - the PLT-used portion of the GOT, in the r/w segment\n-   *   .rela.plt  - the dynamic relocs for the GOT-PLT, in the r/x segment\n-   *\n-   * In addition, because we're starting up a dynamically linked executable,\n-   * we have to have several more sections!\n-   *\n-   *   .interp    - the read-only section that names ld.so\n-   *   .dynsym    - symbols named by the PLT/GOT entries, r/x segment\n-   *   .dynstr    - string-names used in those symbols, r/x segment\n-   *   .hash      - hashtable in which to look these up, r/x segment\n-   *   .dynamic   - the machine-readable description of the dynamic\n-   *                linkage requirements of this elf file, in the\n-   *                r/w _DYNAMIC segment\n-   *\n-   * The Dynamic section contains a sequence of 2-word records of type\n-   * d_tag.\n-   *\n-   *)\n-\n-    (* There are 17 official section headers in the file we're making:  *)\n-    (*                                                                  *)\n-    (* section 0: <null section>                                        *)\n-    (*                                                                  *)\n-    (* section 1:  .interp            (segment 1: R+X, INTERP)          *)\n-    (*                                                                  *)\n-    (* section 2:  .text              (segment 2: R+X, LOAD)            *)\n-    (* section 3:  .rodata                   ...                        *)\n-    (* section 4:  .dynsym                   ...                        *)\n-    (* section 5:  .dynstr                   ...                        *)\n-    (* section 6:  .hash                     ...                        *)\n-    (* section 7:  .plt                      ...                        *)\n-    (* section 8:  .got                      ...                        *)\n-    (* section 9:  .rela.plt                 ...                        *)\n-    (*                                                                  *)\n-    (* section 10: .data              (segment 3: R+W, LOAD)            *)\n-    (* section 11: .bss                      ...                        *)\n-    (*                                                                  *)\n-    (* section 12: .dynamic           (segment 4: R+W, DYNAMIC)         *)\n-    (*                                                                  *)\n-    (* section 13: .shstrtab          (not in a segment)                *)\n-    (* section 14: .debug_aranges     (segment 2: cont'd)               *)\n-    (* section 15: .debug_pubnames           ...                        *)\n-    (* section 14: .debug_info               ...                        *)\n-    (* section 15: .debug_abbrev             ...                        *)\n-    (* section 14: .debug_line               ...                        *)\n-    (* section 15: .debug_frame              ...                        *)\n-    (* section 16: .note..rust        (segment 5: NOTE)                 *)\n-\n-    let sname s =\n-      new_fixup (Printf.sprintf \"string name of '%s' section\" s)\n-    in\n-    let null_section_name_fixup = sname \"<null>\" in\n-    let interp_section_name_fixup = sname \".interp\"in\n-    let text_section_name_fixup = sname \".text\" in\n-    let rodata_section_name_fixup = sname \".rodata\" in\n-    let dynsym_section_name_fixup = sname \".dynsym\" in\n-    let dynstr_section_name_fixup = sname \".dynstr\" in\n-    let hash_section_name_fixup = sname \".hash\" in\n-    let plt_section_name_fixup = sname \".plt\" in\n-    let got_plt_section_name_fixup = sname \".got.plt\" in\n-    let rela_plt_section_name_fixup = sname \".rela.plt\" in\n-    let data_section_name_fixup = sname \".data\" in\n-    let bss_section_name_fixup = sname \".bss\" in\n-    let dynamic_section_name_fixup = sname \".dynamic\" in\n-    let shstrtab_section_name_fixup = sname \".shstrtab\" in\n-    let debug_aranges_section_name_fixup = sname \".debug_aranges\" in\n-    let debug_pubnames_section_name_fixup = sname \".debug_pubnames\" in\n-    let debug_info_section_name_fixup = sname \".debug_info\" in\n-    let debug_abbrev_section_name_fixup = sname \".debug_abbrev\" in\n-    let debug_line_section_name_fixup = sname \".debug_line\" in\n-    let debug_frame_section_name_fixup = sname \".debug_frame\" in\n-    let note_rust_section_name_fixup = sname \".note.rust\" in\n-\n-  (* let interpndx      = 1L in *)  (* Section index of .interp *)\n-  let textndx        = 2L in  (* Section index of .text *)\n-  let rodatandx      = 3L in  (* Section index of .rodata *)\n-  let dynsymndx      = 4L in  (* Section index of .dynsym *)\n-  let dynstrndx      = 5L in  (* Section index of .dynstr *)\n-  (* let hashndx        = 6L in *)  (* Section index of .hash *)\n-  let pltndx         = 7L in  (* Section index of .plt *)\n-  (* let gotpltndx      = 8L in *)  (* Section index of .got.plt *)\n-  (* let relapltndx     = 9L in *)  (* Section index of .rela.plt *)\n-  let datandx        = 10L in  (* Section index of .data *)\n-  let bssndx         = 11L in  (* Section index of .bss *)\n-  (* let dynamicndx     = 12L in *) (* Section index of .dynamic *)\n-  let shstrtabndx    = 13L in (* Section index of .shstrtab *)\n-\n-  let section_header_table_fixup = new_fixup \".section header table\" in\n-  let interp_section_fixup = new_fixup \".interp section\" in\n-  let text_section_fixup = new_fixup \".text section\" in\n-  let rodata_section_fixup = new_fixup \".rodata section\" in\n-  let dynsym_section_fixup = new_fixup \".dynsym section\" in\n-  let dynstr_section_fixup = new_fixup \".dynstr section\" in\n-  let hash_section_fixup = new_fixup \".hash section\" in\n-  let plt_section_fixup = new_fixup \".plt section\" in\n-  let got_plt_section_fixup = new_fixup \".got.plt section\" in\n-  let rela_plt_section_fixup = new_fixup \".rela.plt section\" in\n-  let data_section_fixup = new_fixup \".data section\" in\n-  let bss_section_fixup = new_fixup \".bss section\" in\n-  let dynamic_section_fixup = new_fixup \".dynamic section\" in\n-  let shstrtab_section_fixup = new_fixup \".shstrtab section\" in\n-  let note_rust_section_fixup = new_fixup \".shstrtab section\" in\n-\n-  let shstrtab_section =\n-    SEQ\n-      [|\n-        DEF (null_section_name_fixup, ZSTRING \"\");\n-        DEF (interp_section_name_fixup, ZSTRING \".interp\");\n-        DEF (text_section_name_fixup, ZSTRING \".text\");\n-        DEF (rodata_section_name_fixup, ZSTRING \".rodata\");\n-        DEF (dynsym_section_name_fixup, ZSTRING \".dynsym\");\n-        DEF (dynstr_section_name_fixup, ZSTRING \".dynstr\");\n-        DEF (hash_section_name_fixup, ZSTRING \".hash\");\n-        DEF (plt_section_name_fixup, ZSTRING \".plt\");\n-        DEF (got_plt_section_name_fixup, ZSTRING \".got.plt\");\n-        DEF (rela_plt_section_name_fixup, ZSTRING \".rela.plt\");\n-        DEF (data_section_name_fixup, ZSTRING \".data\");\n-        DEF (bss_section_name_fixup, ZSTRING \".bss\");\n-        DEF (dynamic_section_name_fixup, ZSTRING \".dynamic\");\n-        DEF (shstrtab_section_name_fixup, ZSTRING \".shstrtab\");\n-        DEF (debug_aranges_section_name_fixup, ZSTRING \".debug_aranges\");\n-        DEF (debug_pubnames_section_name_fixup, ZSTRING \".debug_pubnames\");\n-        DEF (debug_info_section_name_fixup, ZSTRING \".debug_info\");\n-        DEF (debug_abbrev_section_name_fixup, ZSTRING \".debug_abbrev\");\n-        DEF (debug_line_section_name_fixup, ZSTRING \".debug_line\");\n-        DEF (debug_frame_section_name_fixup, ZSTRING \".debug_frame\");\n-        DEF (note_rust_section_name_fixup, ZSTRING \".note.rust\");\n-      |]\n-  in\n-\n-  let section_headers =\n-    [|\n-        (* <null> *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: null_section_name_fixup\n-           ~section_fixup: None\n-           ~sh_addralign: 0L\n-           SHT_NULL);\n-\n-        (* .interp *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: interp_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC ]\n-           ~section_fixup: (Some interp_section_fixup)\n-           SHT_PROGBITS);\n-\n-        (* .text *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: text_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC; SHF_EXECINSTR ]\n-           ~section_fixup: (Some text_section_fixup)\n-           ~sh_addralign: 32L\n-           SHT_PROGBITS);\n-\n-        (* .rodata *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: rodata_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC ]\n-           ~section_fixup: (Some rodata_section_fixup)\n-           ~sh_addralign: 32L\n-           SHT_PROGBITS);\n-\n-        (* .dynsym *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: dynsym_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC ]\n-           ~section_fixup: (Some dynsym_section_fixup)\n-           ~sh_addralign: 4L\n-           ~sh_entsize: elf32_symsize\n-           ~sh_link: (Some dynstrndx)\n-           SHT_DYNSYM);\n-\n-        (* .dynstr *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: dynstr_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC ]\n-           ~section_fixup: (Some dynstr_section_fixup)\n-           SHT_STRTAB);\n-\n-        (* .hash *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: hash_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC ]\n-           ~section_fixup: (Some hash_section_fixup)\n-           ~sh_addralign: 4L\n-           ~sh_entsize: 4L\n-           SHT_PROGBITS);\n-\n-        (* .plt *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: plt_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC; SHF_EXECINSTR ]\n-           ~section_fixup: (Some plt_section_fixup)\n-           ~sh_addralign: 4L\n-           SHT_PROGBITS);\n-\n-        (* .got.plt *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: got_plt_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC; SHF_WRITE ]\n-           ~section_fixup: (Some got_plt_section_fixup)\n-           ~sh_addralign: 4L\n-           SHT_PROGBITS);\n-\n-        (* .rela.plt *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: rela_plt_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC ]\n-           ~section_fixup: (Some rela_plt_section_fixup)\n-           ~sh_addralign: 4L\n-           ~sh_entsize: elf32_rela_entsz\n-           ~sh_link: (Some dynsymndx)\n-           ~sh_info: (Some pltndx)\n-           SHT_RELA);\n-\n-        (* .data *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: data_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC; SHF_WRITE ]\n-           ~section_fixup: (Some data_section_fixup)\n-           ~sh_addralign: 32L\n-           SHT_PROGBITS);\n-\n-        (* .bss *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: bss_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC; SHF_WRITE ]\n-           ~section_fixup: (Some bss_section_fixup)\n-           ~sh_addralign: 32L\n-           SHT_NOBITS);\n-\n-        (* .dynamic *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: dynamic_section_name_fixup\n-           ~sh_flags: [ SHF_ALLOC; SHF_WRITE ]\n-           ~section_fixup: (Some dynamic_section_fixup)\n-           ~sh_addralign: 8L\n-           ~sh_link: (Some dynstrndx)\n-           SHT_DYNAMIC);\n-\n-        (* .shstrtab *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: shstrtab_section_name_fixup\n-           ~section_fixup: (Some shstrtab_section_fixup)\n-           SHT_STRTAB);\n-\n-(* \n-   FIXME: uncomment the dwarf section headers as you make use of them;\n-   recent gdb versions have got fussier about parsing dwarf and don't\n-   like seeing junk there. \n-*)\n-\n-        (* .debug_aranges *)\n-(*\n-\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: debug_aranges_section_name_fixup\n-           ~section_fixup: (Some sem.Semant.ctxt_debug_aranges_fixup)\n-           ~sh_addralign: 8L\n-           ~zero_sh_addr: true\n-           SHT_PROGBITS);\n-*)\n-        (* .debug_pubnames *)\n-(*\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: debug_pubnames_section_name_fixup\n-           ~section_fixup: (Some sem.Semant.ctxt_debug_pubnames_fixup)\n-           ~zero_sh_addr: true\n-           SHT_PROGBITS);\n-*)\n-\n-        (* .debug_info *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: debug_info_section_name_fixup\n-           ~section_fixup: (Some sem.Semant.ctxt_debug_info_fixup)\n-           ~zero_sh_addr: true\n-           SHT_PROGBITS);\n-\n-        (* .debug_abbrev *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: debug_abbrev_section_name_fixup\n-           ~section_fixup: (Some sem.Semant.ctxt_debug_abbrev_fixup)\n-           ~zero_sh_addr: true\n-           SHT_PROGBITS);\n-\n-        (* .debug_line *)\n-(*\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: debug_line_section_name_fixup\n-           ~section_fixup: (Some sem.Semant.ctxt_debug_line_fixup)\n-           ~zero_sh_addr: true\n-           SHT_PROGBITS);\n-*)\n-\n-        (* .debug_frame *)\n-(*\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: debug_frame_section_name_fixup\n-           ~section_fixup: (Some sem.Semant.ctxt_debug_frame_fixup)\n-           ~sh_addralign: 4L\n-           ~zero_sh_addr: true\n-           SHT_PROGBITS);\n-*)\n-\n-        (* .note.rust *)\n-        (section_header\n-           ~shstring_table_fixup: shstrtab_section_fixup\n-           ~shname_string_fixup: note_rust_section_name_fixup\n-           ~section_fixup: (Some note_rust_section_fixup)\n-           SHT_NOTE);\n-\n-      |]\n-  in\n-  let section_header_table = SEQ section_headers in\n-\n-\n-  (* There are 6 official program headers in the file we're making:   *)\n-  (* segment 0: RX / PHDR                                             *)\n-  (* segment 1: R  / INTERP                                           *)\n-  (* segment 2: RX / LOAD                                             *)\n-  (* segment 3: RW / LOAD                                             *)\n-  (* segment 4: RW / DYNAMIC                                          *)\n-  (* segment 5: R                                                     *)\n-\n-  let program_header_table_fixup = new_fixup \"program header table\" in\n-  let segment_0_fixup = new_fixup \"segment 0\" in\n-  let segment_1_fixup = new_fixup \"segment 1\" in\n-  let segment_2_fixup = new_fixup \"segment 2\" in\n-  let segment_3_fixup = new_fixup \"segment 3\" in\n-  let segment_4_fixup = new_fixup \"segment 4\" in\n-  let segment_5_fixup = new_fixup \"segment 5\" in\n-\n-  let segment_0_align = 4 in\n-  let segment_1_align = 1 in\n-  let segment_2_align = 0x1000 in\n-  let segment_3_align = 0x1000 in\n-  let segment_4_align = 0x1000 in\n-  let segment_5_align = 1 in\n-\n-  let program_headers = [|\n-        (program_header\n-           ~p_type: PT_PHDR\n-           ~segment_fixup: segment_0_fixup\n-           ~p_flags: [ PF_R; PF_X ]\n-           ~p_align: (Int64.of_int segment_0_align));\n-        (program_header\n-           ~p_type: PT_INTERP\n-           ~segment_fixup: segment_1_fixup\n-           ~p_flags: [ PF_R ]\n-           ~p_align: (Int64.of_int segment_1_align));\n-        (program_header\n-           ~p_type: PT_LOAD\n-           ~segment_fixup: segment_2_fixup\n-           ~p_flags: [ PF_R; PF_X ]\n-           ~p_align: (Int64.of_int segment_2_align));\n-        (program_header\n-           ~p_type: PT_LOAD\n-           ~segment_fixup: segment_3_fixup\n-           ~p_flags: [ PF_R; PF_W ]\n-           ~p_align: (Int64.of_int segment_3_align));\n-        (program_header\n-           ~p_type: PT_DYNAMIC\n-           ~segment_fixup: segment_4_fixup\n-           ~p_flags: [ PF_R; PF_W ]\n-           ~p_align: (Int64.of_int segment_4_align));\n-        (program_header\n-           ~p_type: PT_NOTE\n-           ~segment_fixup: segment_5_fixup\n-           ~p_flags: [ PF_R;]\n-           ~p_align: (Int64.of_int segment_5_align));\n-      |]\n-  in\n-  let program_header_table = SEQ program_headers in\n-\n-  let e_entry_fixup = new_fixup \"entry symbol\" in\n-\n-  let elf_header =\n-    elf32_header\n-      ~sess\n-      ~ei_data: ELFDATA2LSB\n-      ~e_type: (if sess.Session.sess_library_mode then ET_DYN else ET_EXEC)\n-      ~e_machine: EM_386\n-      ~e_version: EV_CURRENT\n-\n-      ~e_entry_fixup: e_entry_fixup\n-      ~e_phoff_fixup: program_header_table_fixup\n-      ~e_shoff_fixup: section_header_table_fixup\n-      ~e_phnum: (Int64.of_int (Array.length program_headers))\n-      ~e_shnum: (Int64.of_int (Array.length section_headers))\n-      ~e_shstrndx: shstrtabndx\n-  in\n-\n-  let n_syms = ref 1 in (* The empty symbol, implicit. *)\n-\n-  let data_sym name st_bind fixup =\n-    let name_fixup = new_fixup (\"data symbol name fixup: '\" ^ name ^ \"'\") in\n-    let strtab_entry = DEF (name_fixup, ZSTRING name) in\n-    let symtab_entry =\n-      symbol\n-        ~string_table_fixup: dynstr_section_fixup\n-        ~name_string_fixup: name_fixup\n-        ~sym_target_fixup: (Some fixup)\n-        ~st_bind\n-        ~st_type: STT_OBJECT\n-        ~st_shndx: datandx\n-    in\n-      incr n_syms;\n-      (strtab_entry, symtab_entry)\n-  in\n-\n-  let bss_sym name st_bind fixup =\n-    let name_fixup = new_fixup (\"bss symbol name fixup: '\" ^ name ^ \"'\") in\n-    let strtab_entry = DEF (name_fixup, ZSTRING name) in\n-    let symtab_entry =\n-      symbol\n-        ~string_table_fixup: dynstr_section_fixup\n-        ~name_string_fixup: name_fixup\n-        ~sym_target_fixup: (Some fixup)\n-        ~st_bind\n-        ~st_type: STT_OBJECT\n-        ~st_shndx: bssndx\n-    in\n-      incr n_syms;\n-      (strtab_entry, symtab_entry)\n-  in\n-\n-  let rodata_sym name st_bind fixup =\n-    let name_fixup = new_fixup (\"rodata symbol name fixup: '\" ^ name ^ \"'\") in\n-    let strtab_entry = DEF (name_fixup, ZSTRING name) in\n-    let symtab_entry =\n-      symbol\n-        ~string_table_fixup: dynstr_section_fixup\n-        ~name_string_fixup: name_fixup\n-        ~sym_target_fixup: (Some fixup)\n-        ~st_bind\n-        ~st_type: STT_OBJECT\n-        ~st_shndx: rodatandx\n-    in\n-      incr n_syms;\n-      (strtab_entry, symtab_entry)\n-  in\n-\n-  let text_sym name st_bind fixup =\n-    let name_fixup = new_fixup (\"text symbol name fixup: '\" ^ name ^ \"'\") in\n-    let strtab_frag = DEF (name_fixup, ZSTRING name) in\n-    let symtab_frag =\n-      symbol\n-        ~string_table_fixup: dynstr_section_fixup\n-        ~name_string_fixup: name_fixup\n-        ~sym_target_fixup: (Some fixup)\n-        ~st_bind: st_bind\n-        ~st_type: STT_FUNC\n-        ~st_shndx: textndx\n-    in\n-      incr n_syms;\n-      (strtab_frag, symtab_frag)\n-  in\n-\n-  let require_sym name st_bind _(*fixup*) =\n-    let name_fixup =\n-      new_fixup (\"require symbol name fixup: '\" ^ name ^ \"'\")\n-    in\n-    let strtab_frag = DEF (name_fixup, ZSTRING name) in\n-    let symtab_frag =\n-      symbol\n-        ~string_table_fixup: dynstr_section_fixup\n-        ~name_string_fixup: name_fixup\n-        ~sym_target_fixup: None\n-        ~st_bind\n-        ~st_type: STT_FUNC\n-        ~st_shndx: shn_UNDEF\n-    in\n-      incr n_syms;\n-      (strtab_frag, symtab_frag)\n-  in\n-\n-  let frags_of_symbol sym_emitter st_bind symname_opt symbody x =\n-    let (strtab_frags, symtab_frags, body_frags) = x in\n-    let (strtab_frag, symtab_frag, body_frag) =\n-      match symname_opt with\n-          None -> (MARK, MARK, symbody)\n-        | Some symname ->\n-            let body_fixup =\n-              new_fixup (\"symbol body fixup: '\" ^ symname ^ \"'\")\n-            in\n-            let body =\n-              if symname = entry_name\n-              then DEF (e_entry_fixup, DEF (body_fixup, symbody))\n-              else DEF (body_fixup, symbody)\n-            in\n-            let (str, sym) = sym_emitter symname st_bind body_fixup in\n-              (str, sym, body)\n-    in\n-      ((strtab_frag :: strtab_frags),\n-       (symtab_frag :: symtab_frags),\n-       (body_frag :: body_frags))\n-  in\n-\n-  let frags_of_require_symbol sym_emitter st_bind symname plt_entry_fixup x =\n-    let (i, strtab_frags, symtab_frags,\n-         plt_frags, got_plt_frags, rela_plt_frags) = x in\n-    let (strtab_frag, symtab_frag) = sym_emitter symname st_bind None in\n-    let e = X86.new_emitter_without_vregs () in\n-    let jump_slot_fixup = new_fixup (\"jump slot #\" ^ string_of_int i) in\n-    let jump_slot_initial_target_fixup =\n-      new_fixup (\"jump slot #\" ^ string_of_int i ^ \" initial target\") in\n-\n-    (* You may notice this PLT entry doesn't look like either of the\n-     * types of \"normal\" PLT entries outlined in the ELF manual. It is,\n-     * however, just what you get when you combine a PIC PLT entry with\n-     * inline calls to the horrible __i686.get_pc_thunk.ax kludge used\n-     * on x86 to support entering PIC PLTs. We're just doing it *in*\n-     * the PLT entries rather than infecting all the callers with the\n-     * obligation of having the GOT address in a register on\n-     * PLT-entry.\n-     *)\n-\n-    let plt_frag =\n-      let (reg, _, _) = X86.get_next_pc_thunk in\n-\n-        Il.emit_full e (Some plt_entry_fixup) Il.Dead;\n-\n-        Abi.load_fixup_addr e reg got_plt_section_fixup Il.CodeTy;\n-\n-        Il.emit e (Il.jmp Il.JMP (got_code_cell reg (2+i)));\n-\n-        Il.emit_full e (Some jump_slot_initial_target_fixup)\n-          (Il.Push (X86.immi (Int64.of_int i)));\n-\n-        Il.emit e (Il.jmp Il.JMP (Il.direct_code_ptr plt0_fixup));\n-        X86.frags_of_emitted_quads sess e\n-    in\n-    let got_plt_frag =\n-      DEF (jump_slot_fixup,\n-           WORD (TY_u32, (M_POS jump_slot_initial_target_fixup)))\n-    in\n-    let rela_plt =\n-      { elf32_386_rela_type = R_386_JMP_SLOT;\n-        elf32_386_rela_offset = (M_POS jump_slot_fixup);\n-        elf32_386_rela_sym = (IMM (Int64.of_int i));\n-        elf32_386_rela_addend = (IMM 0L) }\n-    in\n-    let rela_plt_frag = elf32_386_rela_frag rela_plt in\n-      (i+1,\n-       (strtab_frag :: strtab_frags),\n-       (symtab_frag :: symtab_frags),\n-       (plt_frag :: plt_frags),\n-       (got_plt_frag :: got_plt_frags),\n-       (rela_plt_frag :: rela_plt_frags))\n-  in\n-\n-  (* Emit text export symbols. *)\n-  let (global_text_strtab_frags, global_text_symtab_frags) =\n-    match htab_search sem.Semant.ctxt_native_provided SEG_text with\n-        None -> ([], [])\n-      | Some etab ->\n-          Hashtbl.fold\n-            begin\n-              fun name fix x ->\n-                let (strtab_frags, symtab_frags) = x in\n-                let (str, sym) = text_sym name STB_GLOBAL fix in\n-                  (str :: strtab_frags,\n-                   sym :: symtab_frags)\n-            end\n-            etab\n-            ([],[])\n-  in\n-\n-  (* Emit text fragments (possibly named). *)\n-  let (global_text_strtab_frags,\n-       global_text_symtab_frags,\n-       text_body_frags) =\n-    Hashtbl.fold\n-      (frags_of_symbol text_sym STB_GLOBAL)\n-      text_frags\n-      (global_text_strtab_frags, global_text_symtab_frags, [])\n-  in\n-\n-  let (local_text_strtab_frags,\n-       local_text_symtab_frags) =\n-\n-    let symbol_frags_of_code _ code accum =\n-      let (strtab_frags, symtab_frags) = accum in\n-      let fix = code.Semant.code_fixup in\n-      let (strtab_frag, symtab_frag) =\n-        text_sym fix.fixup_name STB_LOCAL fix\n-      in\n-      (strtab_frag :: strtab_frags,\n-       symtab_frag :: symtab_frags)\n-    in\n-\n-    let symbol_frags_of_glue_code g code accum =\n-      let (strtab_frags, symtab_frags) = accum in\n-      let fix = code.Semant.code_fixup in\n-      let (strtab_frag, symtab_frag) =\n-        text_sym (Semant.glue_str sem g) STB_LOCAL fix\n-      in\n-      (strtab_frag :: strtab_frags,\n-       symtab_frag :: symtab_frags)\n-    in\n-\n-    let item_str_frags, item_sym_frags =\n-      Hashtbl.fold symbol_frags_of_code\n-        sem.Semant.ctxt_all_item_code ([], [])\n-    in\n-    let glue_str_frags, glue_sym_frags =\n-      Hashtbl.fold symbol_frags_of_glue_code\n-        sem.Semant.ctxt_glue_code ([], [])\n-    in\n-      (item_str_frags @ glue_str_frags,\n-       item_sym_frags @ glue_sym_frags)\n-  in\n-\n-  (* Emit rodata export symbols. *)\n-  let (rodata_strtab_frags, rodata_symtab_frags) =\n-    match htab_search sem.Semant.ctxt_native_provided SEG_data with\n-        None -> ([], [])\n-      | Some etab ->\n-          Hashtbl.fold\n-            begin\n-              fun name fix x ->\n-                let (strtab_frags, symtab_frags) = x in\n-                let (str, sym) = rodata_sym name STB_GLOBAL fix in\n-                  (str :: strtab_frags,\n-                   sym :: symtab_frags)\n-            end\n-            etab\n-            ([],[])\n-  in\n-\n-  (* Emit rodata fragments (possibly named). *)\n-  let (rodata_strtab_frags,\n-       rodata_symtab_frags,\n-       rodata_body_frags) =\n-    Hashtbl.fold\n-      (frags_of_symbol rodata_sym STB_GLOBAL)\n-      rodata_frags\n-      (rodata_strtab_frags, rodata_symtab_frags, [])\n-  in\n-\n-\n-  let (data_strtab_frags,\n-       data_symtab_frags,\n-       data_body_frags) =\n-    Hashtbl.fold (frags_of_symbol data_sym STB_GLOBAL) data_frags ([],[],[])\n-  in\n-\n-  let (bss_strtab_frags,\n-       bss_symtab_frags,\n-       bss_body_frags) =\n-    Hashtbl.fold (frags_of_symbol bss_sym STB_GLOBAL) bss_frags ([],[],[])\n-  in\n-\n-  let (_,\n-       require_strtab_frags,\n-       require_symtab_frags,\n-       plt_frags,\n-       got_plt_frags,\n-       rela_plt_frags) =\n-    Hashtbl.fold (frags_of_require_symbol require_sym STB_GLOBAL)\n-      required_fixups\n-      (1,[],[],[plt0_frag],[got_prefix],[])\n-  in\n-  let require_symtab_frags = List.rev require_symtab_frags in\n-  let plt_frags = List.rev plt_frags in\n-  let got_plt_frags = List.rev got_plt_frags in\n-  let rela_plt_frags = List.rev rela_plt_frags in\n-\n-  let dynamic_needed_strtab_frags =\n-    Array.make (Array.length needed_libs) MARK\n-  in\n-\n-  let dynamic_frags =\n-    let dynamic_needed_frags = Array.make (Array.length needed_libs) MARK in\n-      for i = 0 to (Array.length needed_libs) - 1 do\n-        let fixup =\n-          new_fixup (\"needed library name fixup: \" ^ needed_libs.(i))\n-        in\n-          dynamic_needed_frags.(i) <-\n-            elf32_dyn_frag (DT_NEEDED, SUB (M_POS fixup,\n-                                            M_POS dynstr_section_fixup));\n-          dynamic_needed_strtab_frags.(i) <-\n-            DEF (fixup, ZSTRING needed_libs.(i))\n-      done;\n-      (SEQ [|\n-         SEQ dynamic_needed_frags;\n-         elf32_dyn_frag (DT_STRTAB, M_POS dynstr_section_fixup);\n-         elf32_dyn_frag (DT_STRSZ, M_SZ dynstr_section_fixup);\n-\n-         elf32_dyn_frag (DT_SYMTAB, M_POS dynsym_section_fixup);\n-         elf32_dyn_frag (DT_SYMENT, IMM elf32_symsize);\n-\n-         elf32_dyn_frag (DT_HASH, M_POS hash_section_fixup);\n-         elf32_dyn_frag (DT_PLTGOT, M_POS got_plt_section_fixup);\n-\n-         elf32_dyn_frag (DT_PLTREL, IMM (elf32_num_of_dyn_tag DT_RELA));\n-         elf32_dyn_frag (DT_PLTRELSZ, M_SZ rela_plt_section_fixup);\n-         elf32_dyn_frag (DT_JMPREL, M_POS rela_plt_section_fixup);\n-\n-         elf32_dyn_frag (DT_NULL, IMM 0L)\n-       |])\n-  in\n-\n-  let null_strtab_fixup = new_fixup \"null dynstrtab entry\" in\n-  let null_strtab_frag = DEF (null_strtab_fixup, ZSTRING \"\") in\n-  let null_symtab_frag = (symbol\n-                            ~string_table_fixup: dynstr_section_fixup\n-                            ~name_string_fixup: null_strtab_fixup\n-                            ~sym_target_fixup: None\n-                            ~st_bind: STB_LOCAL\n-                            ~st_type: STT_NOTYPE\n-                            ~st_shndx: 0L) in\n-\n-  let dynsym_frags = (null_symtab_frag ::\n-                        (require_symtab_frags @\n-                           global_text_symtab_frags @\n-                           local_text_symtab_frags @\n-                           rodata_symtab_frags @\n-                           data_symtab_frags @\n-                           bss_symtab_frags))\n-  in\n-\n-  let dynstr_frags = (null_strtab_frag ::\n-                        (require_strtab_frags @\n-                           global_text_strtab_frags @\n-                           local_text_strtab_frags @\n-                           rodata_strtab_frags @\n-                           data_strtab_frags @\n-                           bss_strtab_frags @\n-                           (Array.to_list dynamic_needed_strtab_frags)))\n-  in\n-\n-  let interp_section =\n-\n-    DEF (interp_section_fixup, ZSTRING\n-           (if sess.Session.sess_targ = FreeBSD_x86_elf\n-            then \"/libexec/ld-elf.so.1\"\n-            else \"/lib/ld-linux.so.2\"))\n-  in\n-\n-  let text_section =\n-    DEF (text_section_fixup,\n-         SEQ (Array.of_list text_body_frags))\n-  in\n-  let rodata_section =\n-    DEF (rodata_section_fixup,\n-         SEQ (Array.of_list rodata_body_frags))\n-  in\n-  let data_section =\n-    DEF (data_section_fixup,\n-         SEQ (Array.of_list data_body_frags))\n-  in\n-  let bss_section =\n-    DEF (bss_section_fixup,\n-         SEQ (Array.of_list bss_body_frags))\n-  in\n-  let dynsym_section =\n-    DEF (dynsym_section_fixup,\n-         SEQ (Array.of_list dynsym_frags))\n-  in\n-  let dynstr_section =\n-    DEF (dynstr_section_fixup,\n-         SEQ (Array.of_list dynstr_frags))\n-  in\n-\n-  let hash_section =\n-    let n_syms = !n_syms in\n-\n-    DEF (hash_section_fixup,\n-         (* Worst hashtable ever: one chain. *)\n-         SEQ [|\n-           WORD (TY_u32, IMM 1L);          (* nbucket *)\n-           WORD (TY_u32,                   (* nchain *)\n-                 IMM (Int64.of_int n_syms));\n-           WORD (TY_u32, IMM 1L);          (* bucket 0 => symbol 1. *)\n-           SEQ\n-             begin\n-               Array.init\n-                 n_syms\n-                 (fun i ->\n-                    let next = (* chain[i] => if last then 0 else i+1 *)\n-                      if i > 0 && i < (n_syms-1)\n-                      then Int64.of_int (i+1)\n-                      else 0L\n-                    in\n-                      WORD (TY_u32, IMM next))\n-             end;\n-         |])\n-  in\n-\n-  let plt_section =\n-    DEF (plt_section_fixup,\n-         SEQ (Array.of_list plt_frags))\n-  in\n-\n-  let got_plt_section =\n-    DEF (got_plt_section_fixup,\n-         SEQ (Array.of_list got_plt_frags))\n-  in\n-\n-  let rela_plt_section =\n-    DEF (rela_plt_section_fixup,\n-         SEQ (Array.of_list rela_plt_frags))\n-  in\n-\n-  let dynamic_section =\n-    DEF (dynamic_section_fixup, dynamic_frags)\n-  in\n-\n-  let note_rust_section =\n-    DEF (note_rust_section_fixup,\n-         (Asm.note_rust_frags crate.node.Ast.crate_meta))\n-  in\n-\n-\n-  let page_alignment = 0x1000 in\n-\n-  let align_both i =\n-    ALIGN_FILE (page_alignment,\n-                (ALIGN_MEM (page_alignment, i)))\n-  in\n-\n-  let def_aligned f i =\n-    align_both\n-      (SEQ [| DEF(f,i);\n-              (align_both MARK)|])\n-  in\n-\n-  let debug_aranges_section =\n-    def_aligned\n-      sem.Semant.ctxt_debug_aranges_fixup\n-      dwarf.Dwarf.debug_aranges\n-  in\n-  let debug_pubnames_section =\n-    def_aligned\n-      sem.Semant.ctxt_debug_pubnames_fixup\n-      dwarf.Dwarf.debug_pubnames\n-  in\n-  let debug_info_section =\n-    def_aligned\n-      sem.Semant.ctxt_debug_info_fixup\n-      dwarf.Dwarf.debug_info\n-  in\n-  let debug_abbrev_section =\n-    def_aligned\n-      sem.Semant.ctxt_debug_abbrev_fixup\n-      dwarf.Dwarf.debug_abbrev\n-  in\n-  let debug_line_section =\n-    def_aligned\n-      sem.Semant.ctxt_debug_line_fixup\n-      dwarf.Dwarf.debug_line\n-  in\n-  let debug_frame_section =\n-    def_aligned sem.Semant.ctxt_debug_frame_fixup dwarf.Dwarf.debug_frame\n-  in\n-\n-  let load_address = 0x0804_8000L in\n-\n-    SEQ\n-      [|\n-        MEMPOS load_address;\n-        ALIGN_FILE\n-          (segment_2_align,\n-           DEF\n-             (segment_2_fixup,\n-              SEQ\n-                [|\n-                  DEF (sem.Semant.ctxt_image_base_fixup, MARK);\n-                  elf_header;\n-                  ALIGN_FILE\n-                    (segment_0_align,\n-                     DEF\n-                       (segment_0_fixup,\n-                        SEQ\n-                          [|\n-                            DEF (program_header_table_fixup,\n-                                 program_header_table);\n-                          |]));\n-                  ALIGN_FILE\n-                    (segment_1_align,\n-                     DEF (segment_1_fixup, interp_section));\n-                  text_section;\n-                  rodata_section;\n-                  dynsym_section;\n-                  dynstr_section;\n-                  hash_section;\n-                  plt_section;\n-                  rela_plt_section;\n-                  debug_aranges_section;\n-                  debug_pubnames_section;\n-                  debug_info_section;\n-                  debug_abbrev_section;\n-                  debug_line_section;\n-                  debug_frame_section;\n-                |]));\n-        ALIGN_FILE\n-          (segment_3_align,\n-           DEF\n-             (segment_3_fixup,\n-              SEQ\n-                [|\n-                  data_section;\n-                  got_plt_section;\n-                  bss_section;\n-                  ALIGN_FILE\n-                    (segment_4_align,\n-                     DEF (segment_4_fixup,\n-                          dynamic_section));\n-                  ALIGN_FILE\n-                    (segment_5_align,\n-                     DEF (segment_5_fixup,\n-                          note_rust_section));\n-                |]));\n-        DEF (shstrtab_section_fixup,\n-             shstrtab_section);\n-        DEF (section_header_table_fixup,\n-             section_header_table);\n-      |]\n-;;\n-\n-let emit_file\n-    (sess:Session.sess)\n-    (crate:Ast.crate)\n-    (code:Asm.frag)\n-    (data:Asm.frag)\n-    (sem:Semant.ctxt)\n-    (dwarf:Dwarf.debug_records)\n-    : unit =\n-\n-  let text_frags = Hashtbl.create 4 in\n-  let rodata_frags = Hashtbl.create 4 in\n-  let data_frags = Hashtbl.create 4 in\n-  let bss_frags = Hashtbl.create 4 in\n-  let required_fixups = Hashtbl.create 4 in\n-\n-  (*\n-   * Startup on elf-linux is more complex than in win32. It's\n-   * thankfully documented in some detail around the net.\n-   *\n-   *   - The elf entry address is for _start.\n-   *\n-   *   - _start pushes:\n-   *\n-   *       eax   (should be zero)\n-   *       esp   (holding the kernel-provided stack end)\n-   *       edx   (address of _rtld_fini)\n-   *       address of _fini\n-   *       address of _init\n-   *       ecx   (argv)\n-   *       esi   (argc)\n-   *       address of main\n-   *\n-   *     and then calls __libc_start_main@plt.\n-   *\n-   *   - This means any sensible binary has a PLT. Fun. So\n-   *     We call into the PLT, which itself is just a bunch\n-   *     of indirect jumps through slots in the GOT, and wind\n-   *     up in __libc_start_main. Which calls _init, then\n-   *     essentially exit(main(argc,argv)).\n-   *)\n-\n-\n-  let init_fixup = new_fixup \"_init function entry\" in\n-  let fini_fixup = new_fixup \"_fini function entry\" in\n-  let (start_fixup, rust_start_fixup) =\n-    if sess.Session.sess_library_mode\n-    then (None, None)\n-    else (Some (new_fixup \"start function entry\"),\n-          Some (Semant.require_native sem REQUIRED_LIB_rustrt \"rust_start\"))\n-  in\n-  let libc_start_main_fixup = new_fixup \"__libc_start_main@plt stub\" in\n-\n-  let start_fn _ =\n-    let start_fixup =\n-      match start_fixup with\n-          None -> bug () \"missing start fixup in non-library mode\"\n-        | Some s -> s\n-    in\n-    let e = X86.new_emitter_without_vregs () in\n-    let push_r32 r = Il.emit e\n-      (Il.Push (Il.Cell (Il.Reg (Il.Hreg r, Il.ValTy Il.Bits32))))\n-    in\n-    let push_pos32 = X86.push_pos32 e in\n-\n-      Il.emit e (Il.unary Il.UMOV (X86.rc X86.ebp) (X86.immi 0L));\n-      Il.emit e (Il.Pop (X86.rc X86.esi));\n-      Il.emit e (Il.unary Il.UMOV (X86.rc X86.ecx) (X86.ro X86.esp));\n-      Il.emit e (Il.binary Il.AND\n-                   (X86.rc X86.esp) (X86.ro X86.esp)\n-                   (X86.immi 0xfffffffffffffff0L));\n-\n-      push_r32 X86.eax;\n-      push_r32 X86.esp;\n-      push_r32 X86.edx;\n-      push_pos32 fini_fixup;\n-      push_pos32 init_fixup;\n-      push_r32 X86.ecx;\n-      push_r32 X86.esi;\n-      push_pos32 start_fixup;\n-      Il.emit e (Il.call\n-                   (Il.Reg (Il.Hreg X86.eax, Il.ValTy Il.Bits32))\n-                   (Il.direct_code_ptr libc_start_main_fixup));\n-      X86.frags_of_emitted_quads sess e\n-  in\n-\n-  let do_nothing_fn _ =\n-    let e = X86.new_emitter_without_vregs () in\n-      Il.emit e Il.Ret;\n-      X86.frags_of_emitted_quads sess e\n-  in\n-\n-  let main_fn _ =\n-    match (start_fixup, rust_start_fixup, sem.Semant.ctxt_main_fn_fixup) with\n-        (None, _, _)\n-      | (_, None, _)\n-      | (_, _, None) -> MARK\n-      | (Some start_fixup,\n-         Some rust_start_fixup,\n-         Some main_fn_fixup) ->\n-          let e = X86.new_emitter_without_vregs () in\n-            X86.objfile_start e\n-              ~start_fixup\n-              ~rust_start_fixup\n-              ~main_fn_fixup\n-              ~crate_fixup: sem.Semant.ctxt_crate_fixup\n-              ~indirect_start: false;\n-            X86.frags_of_emitted_quads sess e\n-  in\n-\n-  let needed_libs =\n-    [|\n-      if sess.Session.sess_targ = FreeBSD_x86_elf\n-      then \"libc.so.7\"\n-      else \"libc.so.6\";\n-      \"librustrt.so\"\n-    |]\n-  in\n-\n-  let _ =\n-    if not sess.Session.sess_library_mode\n-    then\n-      begin\n-        htab_put text_frags (Some \"_start\") (start_fn());\n-        htab_put text_frags (Some \"_init\")\n-          (DEF (init_fixup, do_nothing_fn()));\n-        htab_put text_frags (Some \"_fini\")\n-          (DEF (fini_fixup, do_nothing_fn()));\n-        htab_put text_frags (Some \"main\") (main_fn ());\n-        htab_put required_fixups \"__libc_start_main\" libc_start_main_fixup;\n-      end;\n-    htab_put text_frags None code;\n-    htab_put rodata_frags None data;\n-\n-    if sess.Session.sess_targ = FreeBSD_x86_elf\n-    then\n-      (* \n-       * FreeBSD wants some extra symbols in .bss so its libc can fill\n-       * them in, I think.\n-       *)\n-      List.iter\n-        (fun x -> htab_put bss_frags (Some x) (WORD (TY_u32, (IMM 0L))))\n-        [\n-          \"environ\";\n-          \"optind\";\n-          \"optarg\";\n-          \"_CurrentRuneLocale\";\n-          \"__stack_chk_guard\";\n-          \"__mb_sb_limit\";\n-          \"__isthreaded\";\n-          \"__stdinp\";\n-          \"__stderrp\";\n-          \"__stdoutp\";\n-        ];\n-\n-    Hashtbl.iter\n-      begin\n-        fun _ tab ->\n-          Hashtbl.iter\n-            begin\n-              fun name fixup ->\n-                htab_put required_fixups name fixup\n-            end\n-            tab\n-      end\n-      sem.Semant.ctxt_native_required\n-  in\n-\n-  let all_frags =\n-    elf32_linux_x86_file\n-      ~sess\n-      ~crate\n-      ~entry_name: \"_start\"\n-      ~text_frags\n-      ~data_frags\n-      ~bss_frags\n-      ~dwarf\n-      ~sem\n-      ~rodata_frags\n-      ~required_fixups\n-      ~needed_libs\n-  in\n-    write_out_frag sess true all_frags\n-;;\n-\n-let elf_magic = \"\\x7fELF\";;\n-\n-let sniff\n-    (sess:Session.sess)\n-    (filename:filename)\n-    : asm_reader option =\n-  try\n-    let stat = Unix.stat filename in\n-      if (stat.Unix.st_kind = Unix.S_REG) &&\n-        (stat.Unix.st_size > 4)\n-      then\n-        let ar = new_asm_reader sess filename in\n-        let _ = log sess \"sniffing ELF file\" in\n-          if (ar.asm_get_zstr_padded 4) = elf_magic\n-          then (ar.asm_seek 0; Some ar)\n-          else None\n-      else\n-        None\n-  with\n-      _ -> None\n-;;\n-\n-let get_sections\n-    (sess:Session.sess)\n-    (ar:asm_reader)\n-    : (string,(int*int)) Hashtbl.t =\n-  let sects = Hashtbl.create 0 in\n-  let _ = log sess \"reading sections\" in\n-  let elf_id = ar.asm_get_zstr_padded 4 in\n-  let _ = assert (elf_id = elf_magic) in\n-\n-  let _ = ar.asm_seek 0x10 in\n-  let _ = ar.asm_adv_u16 () in (* e_type *)\n-  let _ = ar.asm_adv_u16 () in (* e_machine *)\n-  let _ = ar.asm_adv_u32 () in (* e_version *)\n-  let _ = ar.asm_adv_u32 () in (* e_entry *)\n-  let _ = ar.asm_adv_u32 () in (* e_phoff *)\n-  let e_shoff = ar.asm_get_u32 () in (* e_shoff *)\n-  let _ = ar.asm_adv_u32 () in (* e_flags *)\n-  let _ = ar.asm_adv_u16 () in (* e_ehsize *)\n-  let _ = ar.asm_adv_u16 () in (* e_phentsize *)\n-  let _ = ar.asm_adv_u16 () in (* e_phnum *)\n-  let e_shentsize = ar.asm_get_u16 () in\n-  let e_shnum = ar.asm_get_u16 () in\n-  let e_shstrndx = ar.asm_get_u16 () in\n-  let _ = log sess\n-    \"%d ELF section headers, %d bytes each, starting at 0x%x\"\n-    e_shnum e_shentsize e_shoff\n-  in\n-  let _ = log sess \"section %d is .shstrtab\" e_shstrndx in\n-\n-  let read_section_hdr n =\n-    let _ = ar.asm_seek (e_shoff + n * e_shentsize) in\n-    let str_off = ar.asm_get_u32() in\n-    let _ = ar.asm_adv_u32() in (* sh_type  *)\n-    let _ = ar.asm_adv_u32() in (* sh_flags *)\n-    let _ = ar.asm_adv_u32() in (* sh_addr *)\n-    let off = ar.asm_get_u32() in (* sh_off *)\n-    let size = ar.asm_get_u32() in (* sh_size *)\n-    let _ = ar.asm_adv_u32() in (* sh_link *)\n-    let _ = ar.asm_adv_u32() in (* sh_info *)\n-    let _ = ar.asm_adv_u32() in (* sh_addralign *)\n-    let _ = ar.asm_adv_u32() in (* sh_entsize *)\n-      (str_off, off, size)\n-  in\n-\n-  let (_, str_base, _) = read_section_hdr e_shstrndx in\n-\n-  let _ = ar.asm_seek e_shoff in\n-    for i = 0 to (e_shnum - 1) do\n-      let (str_off, off, size) = read_section_hdr i in\n-      let _ = ar.asm_seek (str_base + str_off) in\n-      let name = ar.asm_get_zstr() in\n-        log sess \"section %d: %s, size %d, offset 0x%x\" i name size off;\n-        Hashtbl.add sects name (off, size);\n-    done;\n-    sects\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "1539c00b87cad18b45e2499310c3e6f075f5c8d4", "filename": "src/boot/be/il.ml", "status": "removed", "additions": 0, "deletions": 937, "changes": 937, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fil.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,937 +0,0 @@\n-open Common;;\n-\n-(* FIXME (issue #1): thread a session object through this eventually. *)\n-let log_iltypes = ref false;;\n-\n-(* IL type system, very rudimentary. *)\n-\n-type bits =\n-    Bits8\n-  | Bits16\n-  | Bits32\n-  | Bits64\n-;;\n-\n-type scalar_ty =\n-    ValTy of bits\n-  | AddrTy of referent_ty\n-\n-and referent_ty =\n-    ScalarTy of scalar_ty\n-  | StructTy of referent_ty array\n-  | UnionTy of referent_ty array\n-  | ParamTy of ty_param_idx (* Thing of current-frame type-param #n *)\n-  | OpaqueTy                (* Unknown memory-resident thing. *)\n-  | CodeTy                  (* Executable machine code. *)\n-  | NilTy                   (* 0 bits of space. *)\n-;;\n-\n-let (voidptr_t:scalar_ty) = AddrTy OpaqueTy;;\n-let (codeptr_t:scalar_ty) = AddrTy CodeTy;;\n-\n-(* Operands. *)\n-\n-type vreg = int ;;\n-type hreg = int ;;\n-type label = int ;;\n-type spill = int ;;\n-\n-type reg =\n-    Vreg of vreg\n-  | Hreg of hreg\n-;;\n-\n-type mem =\n-    Abs of Asm.expr64\n-  | RegIn of (reg * (Asm.expr64 option))\n-  | Spill of spill\n-;;\n-\n-type typed_reg = (reg * scalar_ty);;\n-type typed_mem = (mem * referent_ty);;\n-type typed_imm = (Asm.expr64 * ty_mach);;\n-type typed_imm_ptr = (fixup * referent_ty);;\n-\n-type cell =\n-    Reg of typed_reg\n-  | Mem of typed_mem\n-;;\n-\n-(* \n- * ImmPtr (a, rty) can be assigned to anything of scalar_ty \n- * AddrTy rty; the difference is that ImmAddr carries its value\n- * so can be used in cases where we want to have an immediate\n- * address constant-propagated through the code to the backend.\n- *)\n-type operand =\n-    Cell of cell\n-  | Imm of typed_imm\n-  | ImmPtr of typed_imm_ptr\n-;;\n-\n-\n-type code =\n-    CodeLabel of label (* Index into current quad block. *)\n-  | CodePtr of operand\n-  | CodeNone\n-;;\n-\n-(* NB: for the most part, we let the register allocator assign spills\n- * from vregs, and we permanently allocate aliased slots to stack\n- * locations by static aliasing information early, in layout.\n- * \n- * The one awkward case this doesn't handle is when someone tries to\n- * pass a literal-atom to an alias-slot. This *requires* a memory slot\n- * but we only realize it rather late, much later than we'd normally\n- * have thougt to desugar the literal into a temporary.\n- * \n- * So in these cases, we let the trans module explicitly demand a\n- * \"Spill n\" operand, which the register allocator mops up before it\n- * gets started on the vregs.\n- * \n- * NOTE: if we were more clever we'd integrate vregs and spills like\n- * this together along with the general notion of a temporary way back\n- * at the desugaring stage, and use some kind of size-class\n- * consolidation so that spills with non-overlapping lifetimes could\n- * share memory. But we're not that clever yet.\n- *)\n-\n-\n-(* Helpers. *)\n-\n-let direct_code_ptr fix =\n-  (CodePtr (ImmPtr (fix, CodeTy)))\n-;;\n-\n-let cell_referent_ty c =\n-  match c with\n-      Reg (_, st) -> ScalarTy st\n-    | Mem (_, rt) -> rt\n-;;\n-\n-let cell_is_nil c =\n-  match c with\n-      Mem (_, NilTy) -> true\n-    | Reg (_, AddrTy NilTy) -> true\n-    | _ -> false\n-;;\n-\n-let operand_is_nil o =\n-  match o with\n-      Cell c -> cell_is_nil c\n-    | _ -> false\n-;;\n-\n-let mem_off (mem:mem) (off:Asm.expr64) : mem =\n-  let addto e = Asm.ADD (off, e) in\n-    match mem with\n-        Abs e -> Abs (addto e)\n-      | RegIn (r, None) -> RegIn (r, Some off)\n-      | RegIn (r, Some e) -> RegIn (r, Some (addto e))\n-      | Spill _ ->\n-          bug () \"Adding offset %s to spill slot\"\n-            (Asm.string_of_expr64 off)\n-;;\n-\n-let mem_off_imm (mem:mem) (imm:int64) : mem =\n-  mem_off mem (Asm.IMM imm)\n-;;\n-\n-\n-(* Quads. *)\n-\n-type binop =\n-    ADD | SUB\n-  | IMUL | UMUL\n-  | IDIV | UDIV\n-  | IMOD | UMOD\n-  | AND | OR | XOR\n-  | LSL | LSR | ASR\n-;;\n-\n-type unop =\n-    NEG | NOT\n-  | UMOV | IMOV\n-  | ZERO\n-;;\n-\n-type jmpop =\n-    JE | JNE\n-  | JZ | JNZ (* FIXME: Synonyms with JE/JNE in x86, others? *)\n-  | JL | JLE | JG | JGE (* Signed.   *)\n-  | JB | JBE | JA | JAE (* Unsigned. *)\n-  | JC | JNC | JO | JNO\n-  | JMP\n-;;\n-\n-type binary =\n-    {\n-      binary_op: binop;\n-      binary_dst: cell;\n-      binary_lhs: operand;\n-      binary_rhs: operand\n-    }\n-;;\n-\n-type unary =\n-    {\n-      unary_op: unop;\n-      unary_dst: cell;\n-      unary_src: operand\n-    }\n-;;\n-\n-type cmp =\n-    {\n-      cmp_lhs: operand;\n-      cmp_rhs: operand\n-    }\n-;;\n-\n-type lea =\n-    {\n-      lea_dst: cell;\n-      lea_src: operand\n-    }\n-;;\n-\n-type jmp =\n-    {\n-      jmp_op: jmpop;\n-      jmp_targ: code;\n-    }\n-;;\n-\n-type call =\n-    {\n-      call_dst: cell;\n-      call_targ: code\n-    }\n-\n-type quad' =\n-    Binary of binary\n-  | Unary of unary\n-  | Lea of lea\n-  | Cmp of cmp\n-  | Jmp of jmp\n-  | Push of operand\n-  | Pop of cell\n-  | Call of call\n-  | Debug          (* Debug-break pseudo-instruction. *)\n-  | Enter of fixup (* Enter-fixup-block pseudo-instruction. *)\n-  | Leave          (* Leave-fixup-block pseudo-instruction. *)\n-  | Ret            (* Return to caller. *)\n-  | Nop            (* Keep this quad here, emit CPU nop. *)\n-  | Dead           (* Keep this quad but emit nothing. *)\n-  | Regfence       (* Clobber all hregs. *)\n-  | End            (* Space past the end of quads to emit. *)\n-;;\n-\n-type quad =\n-    { quad_fixup: fixup option;\n-      quad_body: quad'; }\n-\n-type quads = quad array ;;\n-\n-(* Query functions. *)\n-\n-let cell_is_scalar (c:cell) : bool =\n-  match c with\n-      Reg (_, _) -> true\n-    | Mem (_, ScalarTy _) -> true\n-    | _ -> false\n-;;\n-\n-\n-let bits_of_ty_mach (tm:ty_mach) : bits =\n-  match tm with\n-    | TY_u8 -> Bits8\n-    | TY_i8 -> Bits8\n-    | TY_u16 -> Bits16\n-    | TY_i16 -> Bits16\n-    | TY_u32 -> Bits32\n-    | TY_i32 -> Bits32\n-    | TY_u64 -> Bits64\n-    | TY_i64 -> Bits64\n-    | TY_f32 -> Bits32\n-    | TY_f64 -> Bits64\n-;;\n-\n-let cell_scalar_ty (c:cell) : scalar_ty =\n-  match c with\n-      Reg (_, st) -> st\n-    | Mem (_, ScalarTy st) -> st\n-    | _ -> bug () \"mem of non-scalar in Il.cell_scalar_ty\"\n-;;\n-\n-let operand_scalar_ty (op:operand) : scalar_ty =\n-  match op with\n-      Cell c -> cell_scalar_ty c\n-    | Imm (_, t) -> ValTy (bits_of_ty_mach t)\n-    | ImmPtr (_, t) -> AddrTy t\n-;;\n-\n-\n-let scalar_ty_bits (word_bits:bits) (st:scalar_ty) : bits =\n-  match st with\n-      ValTy bits -> bits\n-    | AddrTy _ -> word_bits\n-;;\n-\n-let cell_bits (word_bits:bits) (c:cell) : bits =\n-  match c with\n-      Reg (_, st) -> scalar_ty_bits word_bits st\n-    | Mem (_, ScalarTy st) -> scalar_ty_bits word_bits st\n-    | Mem _ -> bug () \"mem of non-scalar in Il.cell_bits\"\n-;;\n-\n-let operand_bits (word_bits:bits) (op:operand) : bits =\n-  match op with\n-      Cell cell -> cell_bits word_bits cell\n-    | Imm (_, tm) -> bits_of_ty_mach tm\n-    | ImmPtr _ -> word_bits\n-;;\n-\n-let bits_size (bits:bits) : int64 =\n-  match bits with\n-      Bits8 -> 1L\n-    | Bits16 -> 2L\n-    | Bits32 -> 4L\n-    | Bits64 -> 8L\n-;;\n-\n-let bits_align (bits:bits) : int64 =\n-  match bits with\n-      Bits8 -> 1L\n-    | Bits16 -> 2L\n-    | Bits32 -> 4L\n-    | Bits64 -> 8L\n-;;\n-\n-let scalar_ty_size (word_bits:bits) (st:scalar_ty) : int64 =\n-  bits_size (scalar_ty_bits word_bits st)\n-;;\n-\n-let scalar_ty_align (word_bits:bits) (st:scalar_ty) : int64 =\n-  bits_align (scalar_ty_bits word_bits st)\n-;;\n-\n-let rec referent_ty_layout (word_bits:bits) (rt:referent_ty) : (size * size) =\n-  match rt with\n-      ScalarTy st -> (SIZE_fixed (scalar_ty_size word_bits st),\n-                      SIZE_fixed (scalar_ty_align word_bits st))\n-    | StructTy rts ->\n-        begin\n-          let accum (off,align) rt : (size * size) =\n-            let (elt_size, elt_align) = referent_ty_layout word_bits rt in\n-            let elt_off = align_sz elt_align off in\n-              (add_sz elt_off elt_size, max_sz elt_align align)\n-          in\n-            Array.fold_left accum (SIZE_fixed 0L, SIZE_fixed 1L) rts\n-        end\n-   | UnionTy rts ->\n-        begin\n-          let accum (sz,align) rt : (size * size) =\n-            let (elt_size, elt_align) = referent_ty_layout word_bits rt in\n-              (max_sz sz elt_size, max_sz elt_align align)\n-          in\n-            Array.fold_left accum (SIZE_fixed 0L, SIZE_fixed 1L) rts\n-        end\n-   | OpaqueTy -> bug () \"opaque ty in referent_ty_layout\"\n-   | CodeTy -> bug () \"code ty in referent_ty_layout\"\n-   | ParamTy i -> (SIZE_param_size i, SIZE_param_align i)\n-   | NilTy -> (SIZE_fixed 0L, SIZE_fixed 1L)\n-\n-and referent_ty_size (word_bits:bits) (rt:referent_ty) : size =\n-  (fst (referent_ty_layout word_bits rt))\n-\n-and referent_ty_align (word_bits:bits) (rt:referent_ty) : size =\n-  (snd (referent_ty_layout word_bits rt))\n-\n-;;\n-\n-let get_element_offset\n-    (word_bits:bits)\n-    (elts:referent_ty array)\n-    (i:int)\n-    : size =\n-  let elts_before = Array.sub elts 0 i in\n-  let elt_rty = elts.(i) in\n-  let elts_before_size = referent_ty_size word_bits (StructTy elts_before) in\n-  let elt_align = referent_ty_align word_bits elt_rty in\n-  let elt_off = align_sz elt_align elts_before_size in\n-    elt_off\n-;;\n-\n-(* Processor. *)\n-\n-type quad_processor =\n-    { qp_reg:  (quad_processor -> reg -> reg);\n-      qp_mem:  (quad_processor -> mem -> mem);\n-      qp_cell_read: (quad_processor -> cell -> cell);\n-      qp_cell_write: (quad_processor -> cell -> cell);\n-      qp_code: (quad_processor -> code -> code);\n-      qp_op: (quad_processor -> operand -> operand); }\n-;;\n-\n-let identity_processor =\n-  let qp_cell = (fun qp c -> match c with\n-                     Reg (r, b) -> Reg (qp.qp_reg qp r, b)\n-                   | Mem (a, b) -> Mem (qp.qp_mem qp a, b))\n-  in\n-    { qp_reg = (fun _ r -> r);\n-      qp_mem = (fun qp a -> match a with\n-                     RegIn (r, o) -> RegIn (qp.qp_reg qp r, o)\n-                   | Abs _\n-                   | Spill _ -> a);\n-      qp_cell_read = qp_cell;\n-      qp_cell_write = qp_cell;\n-      qp_code = (fun qp c -> match c with\n-                     CodePtr op -> CodePtr (qp.qp_op qp op)\n-                   | CodeLabel _\n-                   | CodeNone -> c);\n-      qp_op = (fun qp op -> match op with\n-                   Cell c -> Cell (qp.qp_cell_read qp c)\n-                 | ImmPtr _ -> op\n-                 | Imm _ -> op) }\n-;;\n-\n-let process_quad (qp:quad_processor) (q:quad) : quad =\n-  { q with\n-      quad_body = match q.quad_body with\n-          Binary b ->\n-            Binary { b with\n-                       binary_dst = qp.qp_cell_write qp b.binary_dst;\n-                       binary_lhs = qp.qp_op qp b.binary_lhs;\n-                       binary_rhs = qp.qp_op qp b.binary_rhs }\n-        | Unary u ->\n-            Unary { u with\n-                      unary_dst = qp.qp_cell_write qp u.unary_dst;\n-                      unary_src = qp.qp_op qp u.unary_src }\n-\n-        | Lea le ->\n-            Lea { lea_dst = qp.qp_cell_write qp le.lea_dst;\n-                  lea_src = qp.qp_op qp le.lea_src }\n-\n-        | Cmp c ->\n-            Cmp { cmp_lhs = qp.qp_op qp c.cmp_lhs;\n-                  cmp_rhs = qp.qp_op qp c.cmp_rhs }\n-\n-        | Jmp j ->\n-            Jmp { j with\n-                    jmp_targ = qp.qp_code qp j.jmp_targ }\n-\n-        | Push op ->\n-            Push (qp.qp_op qp op)\n-\n-        | Pop c ->\n-            Pop (qp.qp_cell_write qp c)\n-\n-        | Call c ->\n-            Call { call_dst = qp.qp_cell_write qp c.call_dst;\n-                   call_targ = qp.qp_code qp c.call_targ }\n-\n-        | Ret -> Ret\n-        | Nop -> Nop\n-        | Debug -> Debug\n-        | Regfence -> Regfence\n-        | Enter f -> Enter f\n-        | Leave -> Leave\n-        | Dead -> Dead\n-        | End -> End }\n-;;\n-\n-let visit_quads (qp:quad_processor) (qs:quads) : unit =\n-  Array.iter (fun x ->ignore ( process_quad qp x); ()) qs\n-;;\n-\n-let process_quads (qp:quad_processor) (qs:quads) : quads =\n-  Array.map (process_quad qp) qs\n-;;\n-\n-let rewrite_quads (qp:quad_processor) (qs:quads) : unit =\n-  for i = 0 to ((Array.length qs) - 1) do\n-    qs.(i) <- process_quad qp qs.(i)\n-  done\n-;;\n-\n-\n-(* A little partial-evaluator to help lowering sizes. *)\n-\n-let rec size_to_expr64 (a:size) : Asm.expr64 option =\n-  let binary a b f =\n-    match (size_to_expr64 a, size_to_expr64 b) with\n-        (Some a, Some b) -> Some (f a b)\n-      | _ -> None\n-  in\n-    match a with\n-        SIZE_fixed i -> Some (Asm.IMM i)\n-      | SIZE_fixup_mem_sz f -> Some (Asm.M_SZ f)\n-      | SIZE_fixup_mem_pos f -> Some (Asm.M_POS f)\n-      | SIZE_rt_neg s ->\n-          begin\n-            match (size_to_expr64 s) with\n-                None -> None\n-              | Some s -> Some (Asm.NEG s)\n-          end\n-      | SIZE_rt_add (a, b) -> binary a b (fun a b -> Asm.ADD (a,b))\n-      | SIZE_rt_mul (a, b) -> binary a b (fun a b -> Asm.MUL (a,b))\n-      | SIZE_rt_max (a, b) -> binary a b (fun a b -> Asm.MAX (a,b))\n-      | SIZE_rt_align (a, b) -> binary a b (fun a b -> Asm.ALIGN (a,b))\n-      | _ -> None\n-;;\n-\n-\n-(* Formatters. *)\n-\n-let string_of_bits (b:bits) : string =\n-  match b with\n-      Bits8 -> \"b8\"\n-    | Bits16 -> \"b16\"\n-    | Bits32 -> \"b32\"\n-    | Bits64 -> \"b64\"\n-;;\n-\n-let rec string_of_scalar_ty (s:scalar_ty) : string =\n-  match s with\n-      ValTy b -> (string_of_bits b)\n-    | AddrTy r -> (string_of_referent_ty r) ^ \"*\"\n-\n-and string_of_referent_ty (r:referent_ty) : string =\n-  match r with\n-      ScalarTy s ->  (string_of_scalar_ty s)\n-    | StructTy rs ->\n-        Printf.sprintf \"[%s]\"\n-          (String.concat \",\"\n-             (Array.to_list (Array.map string_of_referent_ty rs)))\n-    | UnionTy rs ->\n-        Printf.sprintf \"(%s)\"\n-          (String.concat \"|\"\n-             (Array.to_list (Array.map string_of_referent_ty rs)))\n-    | ParamTy i -> Printf.sprintf \"#%d\" i\n-    | OpaqueTy -> \"?\"\n-    | CodeTy -> \"!\"\n-    | NilTy -> \"()\"\n-;;\n-\n-\n-type hreg_formatter = hreg -> string;;\n-\n-let string_of_reg (f:hreg_formatter) (r:reg) : string =\n-  match r with\n-      Vreg i -> Printf.sprintf \"<v%d>\" i\n-    | Hreg i -> f i\n-;;\n-\n-let string_of_off (e:Asm.expr64 option) : string =\n-  match e with\n-      None -> \"\"\n-    | Some (Asm.IMM i) when (i64_lt i 0L) ->\n-        Printf.sprintf \" - 0x%Lx\" (Int64.neg i)\n-    | Some e' -> \" + \" ^ (Asm.string_of_expr64 e')\n-;;\n-\n-let string_of_mem (f:hreg_formatter) (a:mem) : string =\n-  match a with\n-      Abs e ->\n-        Printf.sprintf \"[%s]\" (Asm.string_of_expr64 e)\n-    | RegIn (r, off) ->\n-        Printf.sprintf \"[%s%s]\" (string_of_reg f r) (string_of_off off)\n-    | Spill i ->\n-        Printf.sprintf \"[<spill %d>]\" i\n-;;\n-let string_of_cell (f:hreg_formatter) (c:cell) : string =\n-  match c with\n-      Reg (r,ty) ->\n-        if !log_iltypes\n-        then\n-          Printf.sprintf \"%s:%s\" (string_of_reg f r) (string_of_scalar_ty ty)\n-        else\n-          Printf.sprintf \"%s\" (string_of_reg f r)\n-    | Mem (a,ty) ->\n-        if !log_iltypes\n-        then\n-          Printf.sprintf \"%s:%s\"\n-            (string_of_mem f a) (string_of_referent_ty ty)\n-        else\n-          Printf.sprintf \"%s\" (string_of_mem f a)\n-;;\n-\n-let string_of_operand (f:hreg_formatter) (op:operand) : string =\n-  match op with\n-      Cell c -> string_of_cell f c\n-    | ImmPtr (f, ty) ->\n-        if !log_iltypes\n-        then\n-          Printf.sprintf \"$<%s>.mpos:%s*\"\n-            f.fixup_name (string_of_referent_ty ty)\n-        else\n-          Printf.sprintf \"$<%s>.mpos\" f.fixup_name\n-    | Imm (i, ty) ->\n-        if !log_iltypes\n-        then\n-          Printf.sprintf \"$%s:%s\"\n-            (Asm.string_of_expr64 i) (string_of_ty_mach ty)\n-        else\n-          Printf.sprintf \"$%s\" (Asm.string_of_expr64 i)\n-;;\n-\n-\n-let string_of_code (f:hreg_formatter) (c:code) : string =\n-  match c with\n-      CodeLabel lab -> Printf.sprintf \"<label %d>\" lab\n-    | CodePtr op -> string_of_operand f op\n-    | CodeNone -> \"<none>\"\n-;;\n-\n-\n-let string_of_binop (op:binop) : string =\n-  match op with\n-      ADD -> \"add\"\n-    | SUB -> \"sub\"\n-    | IMUL -> \"imul\"\n-    | UMUL -> \"umul\"\n-    | IDIV -> \"idiv\"\n-    | UDIV -> \"udiv\"\n-    | IMOD -> \"imod\"\n-    | UMOD -> \"umod\"\n-    | AND -> \"and\"\n-    | OR -> \"or\"\n-    | XOR -> \"xor\"\n-    | LSL -> \"lsl\"\n-    | LSR -> \"lsr\"\n-    | ASR -> \"asr\"\n-;;\n-\n-let string_of_unop (op:unop) : string =\n-  match op with\n-      NEG -> \"neg\"\n-    | NOT -> \"not\"\n-    | UMOV -> \"umov\"\n-    | IMOV -> \"imov\"\n-    | ZERO -> \"zero\"\n-;;\n-\n-let string_of_jmpop (op:jmpop) : string =\n-  match op with\n-      JE -> \"je\"\n-    | JNE -> \"jne\"\n-    | JL -> \"jl\"\n-    | JLE -> \"jle\"\n-    | JG -> \"jg\"\n-    | JGE -> \"jge\"\n-    | JB -> \"jb\"\n-    | JBE -> \"jbe\"\n-    | JA -> \"ja\"\n-    | JAE -> \"jae\"\n-    | JC -> \"jc\"\n-    | JNC ->\"jnc\"\n-    | JO -> \"jo\"\n-    | JNO -> \"jno\"\n-    | JZ -> \"jz\"\n-    | JNZ ->\"jnz\"\n-    | JMP -> \"jmp\"\n-;;\n-\n-let string_of_quad (f:hreg_formatter) (q:quad) : string =\n-  match q.quad_body with\n-      Binary b ->\n-        Printf.sprintf \"%s = %s %s %s\"\n-          (string_of_cell f b.binary_dst)\n-          (string_of_operand f b.binary_lhs)\n-          (string_of_binop b.binary_op)\n-          (string_of_operand f b.binary_rhs)\n-\n-    | Unary u ->\n-        Printf.sprintf \"%s = %s %s\"\n-          (string_of_cell f u.unary_dst)\n-          (string_of_unop u.unary_op)\n-          (string_of_operand f u.unary_src)\n-\n-    | Cmp c ->\n-        Printf.sprintf \"cmp %s %s\"\n-          (string_of_operand f c.cmp_lhs)\n-          (string_of_operand f c.cmp_rhs)\n-\n-    | Lea le ->\n-        Printf.sprintf \"lea %s %s\"\n-          (string_of_cell f le.lea_dst)\n-          (string_of_operand f le.lea_src)\n-\n-    | Jmp j ->\n-        Printf.sprintf \"%s %s\"\n-          (string_of_jmpop j.jmp_op)\n-          (string_of_code f j.jmp_targ)\n-\n-    | Push op ->\n-        Printf.sprintf \"push %s\"\n-          (string_of_operand f op)\n-\n-    | Pop c ->\n-        Printf.sprintf \"%s = pop\"\n-          (string_of_cell f c)\n-\n-    | Call c ->\n-        Printf.sprintf \"%s = call %s\"\n-          (string_of_cell f c.call_dst)\n-          (string_of_code f c.call_targ)\n-\n-    | Ret -> \"ret\"\n-    | Nop -> \"nop\"\n-    | Dead -> \"dead\"\n-    | Debug -> \"debug\"\n-    | Regfence -> \"regfence\"\n-    | Enter _ -> \"enter lexical block\"\n-    | Leave -> \"leave lexical block\"\n-    | End -> \"---\"\n-;;\n-\n-\n-\n-(* Emitters. *)\n-\n-\n-type emitter = { mutable emit_pc: int;\n-                 mutable emit_next_vreg: int option;\n-                 mutable emit_next_spill: int;\n-                 emit_target_specific: (emitter -> quad -> unit);\n-                 mutable emit_quads: quads;\n-                 emit_annotations: (int,string) Hashtbl.t;\n-                 emit_size_cache: (size,operand) Hashtbl.t;\n-                 emit_node: node_id option;\n-               }\n-\n-\n-let badq = { quad_fixup = None;\n-             quad_body = End }\n-;;\n-\n-\n-let deadq = { quad_fixup = None;\n-              quad_body = Dead }\n-;;\n-\n-\n-let new_emitter\n-    (emit_target_specific:emitter -> quad -> unit)\n-    (vregs_ok:bool)\n-    (node:node_id option)\n-    : emitter =\n-  {\n-    emit_pc = 0;\n-    emit_next_vreg = (if vregs_ok then Some 0 else None);\n-    emit_next_spill = 0;\n-    emit_target_specific = emit_target_specific;\n-    emit_quads = Array.create 4 badq;\n-    emit_annotations = Hashtbl.create 0;\n-    emit_size_cache = Hashtbl.create 0;\n-    emit_node = node;\n-  }\n-;;\n-\n-\n-let num_vregs (e:emitter) : int =\n-  match e.emit_next_vreg with\n-      None -> 0\n-    | Some i -> i\n-;;\n-\n-let next_vreg_num (e:emitter) : vreg =\n-  match e.emit_next_vreg with\n-      None -> bug () \"Il.next_vreg_num on non-vreg emitter\"\n-    | Some i ->\n-        e.emit_next_vreg <- Some (i + 1);\n-        i\n-;;\n-\n-let next_vreg (e:emitter) : reg =\n-  Vreg (next_vreg_num e)\n-;;\n-\n-let next_vreg_cell (e:emitter) (s:scalar_ty) : cell =\n-  Reg ((next_vreg e), s)\n-;;\n-\n-let next_spill (e:emitter) : spill =\n-  let i = e.emit_next_spill in\n-    e.emit_next_spill <- i + 1;\n-    i\n-;;\n-\n-let next_spill_slot (e:emitter) (r:referent_ty) : typed_mem =\n-  (Spill (next_spill e), r);\n-;;\n-\n-\n-let grow_if_necessary e =\n-  let len = Array.length e.emit_quads in\n-    if e.emit_pc >= len - 1\n-    then\n-      let n = Array.create (2 * len) badq in\n-        Array.blit e.emit_quads 0 n 0 len;\n-        e.emit_quads <- n\n-;;\n-\n-\n-let binary (op:binop) (dst:cell) (lhs:operand) (rhs:operand) : quad' =\n-  Binary { binary_op = op;\n-           binary_dst = dst;\n-           binary_lhs = lhs;\n-           binary_rhs = rhs }\n-;;\n-\n-let unary (op:unop) (dst:cell) (src:operand) : quad' =\n-  Unary { unary_op = op;\n-          unary_dst = dst;\n-          unary_src = src }\n-\n-let jmp (op:jmpop) (targ:code) : quad' =\n-  Jmp { jmp_op = op;\n-        jmp_targ = targ; }\n-;;\n-\n-\n-let lea (dst:cell) (src:operand) : quad' =\n-  Lea { lea_dst = dst;\n-        lea_src = src; }\n-;;\n-\n-let cmp (lhs:operand) (rhs:operand) : quad' =\n-  Cmp { cmp_lhs = lhs;\n-        cmp_rhs = rhs; }\n-;;\n-\n-let call (dst:cell) (targ:code) : quad' =\n-  Call { call_dst = dst;\n-         call_targ = targ; }\n-;;\n-\n-let umov (dst:cell) (src:operand) : quad' =\n-    if (cell_is_nil dst || operand_is_nil src)\n-    then Dead\n-    else unary UMOV dst src\n-;;\n-\n-let imov (dst:cell) (src:operand) : quad' =\n-    if (cell_is_nil dst || operand_is_nil src)\n-    then Dead\n-    else unary IMOV dst src\n-;;\n-\n-let zero (dst:cell) (count:operand) : quad' =\n-  unary ZERO dst count\n-;;\n-\n-let is_mov uop =\n-  match uop with\n-      UMOV | IMOV -> true\n-    | _ -> false\n-;;\n-\n-let mk_quad (q':quad') : quad =\n-  { quad_body = q';\n-    quad_fixup = None }\n-;;\n-\n-let append_quad\n-    (e:emitter)\n-    (q:quad)\n-    : unit =\n-  grow_if_necessary e;\n-  e.emit_quads.(e.emit_pc) <- q;\n-  e.emit_pc <- e.emit_pc + 1\n-;;\n-\n-let default_mov q' =\n-  match q' with\n-      Binary b ->\n-        begin\n-          match b.binary_op with\n-              IDIV | IMUL | IMOD -> IMOV\n-            | _ -> UMOV\n-        end\n-    | Unary u ->\n-        begin\n-          match u.unary_op with\n-              IMOV -> IMOV\n-            | _ -> UMOV\n-        end\n-    | _ -> UMOV\n-;;\n-\n-let emit_full\n-    (e:emitter)\n-    (fix:fixup option)\n-    (q':quad')\n-    : unit =\n-  e.emit_target_specific e { quad_body = q';\n-                             quad_fixup = fix }\n-;;\n-\n-let emit (e:emitter) (q':quad') : unit =\n-  emit_full e None q'\n-;;\n-\n-let patch_jump (e:emitter) (jmp:int) (targ:int) : unit =\n-  let q = e.emit_quads.(jmp) in\n-    match q.quad_body with\n-        Jmp j ->\n-          assert (j.jmp_targ = CodeNone);\n-          e.emit_quads.(jmp) <-\n-            { q with quad_body =\n-                Jmp { j with jmp_targ = CodeLabel targ } }\n-      | _ -> ()\n-;;\n-\n-(* More query functions. *)\n-\n-let get_element_ptr\n-    (word_bits:bits)\n-    (fmt:hreg_formatter)\n-    (mem_cell:cell)\n-    (i:int)\n-    : cell =\n-  match mem_cell with\n-      Mem (mem, StructTy elts) when i >= 0 && i < (Array.length elts) ->\n-        assert ((Array.length elts) != 0);\n-        begin\n-          let elt_rty = elts.(i) in\n-          let elt_off = get_element_offset word_bits elts i in\n-            match elt_off with\n-                SIZE_fixed fixed_off ->\n-                  Mem (mem_off_imm mem fixed_off, elt_rty)\n-              | _ -> bug ()\n-                  \"get_element_ptr %d on dynamic-size cell: offset %s\"\n-                    i (string_of_size elt_off)\n-        end\n-\n-    | _ -> bug () \"get_element_ptr %d on cell %s\" i\n-        (string_of_cell fmt mem_cell)\n-;;\n-\n-let cell_cast (cell:cell) (rty:referent_ty) : cell =\n-  match cell with\n-      Mem (mem, _) -> Mem (mem, rty)\n-    | Reg (reg, _) ->\n-        begin\n-          match rty with\n-              ScalarTy st -> Reg (reg, st)\n-            | _ -> bug () \"expected scalar type in Il.cell_cast on register\"\n-        end\n-\n-\n-let ptr_cast (cell:cell) (rty:referent_ty) : cell =\n-  match cell with\n-      Mem (mem, ScalarTy (AddrTy _)) -> Mem (mem, ScalarTy (AddrTy rty))\n-    | Reg (reg, AddrTy _) -> Reg (reg, AddrTy rty)\n-    | _ -> bug () \"expected address cell in Il.ptr_cast\"\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "61b1514eed1977fb05f78c4c7a8dc239c6dda8a6", "filename": "src/boot/be/macho.ml", "status": "removed", "additions": 0, "deletions": 1194, "changes": 1194, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fmacho.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fmacho.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fmacho.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,1194 +0,0 @@\n-open Asm;;\n-open Common;;\n-\n-(* Mach-O writer. *)\n-\n-let log (sess:Session.sess) =\n-  Session.log \"obj (mach-o)\"\n-    sess.Session.sess_log_obj\n-    sess.Session.sess_log_out\n-;;\n-\n-let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n-  if sess.Session.sess_log_obj\n-  then thunk ()\n-  else ()\n-;;\n-\n-let filter_marks (orig:frag array) : frag array =\n-  let not_mark (elem:frag) =\n-    match elem with\n-        MARK -> None\n-      | x -> Some x\n-  in arr_map_partial orig not_mark\n-;;\n-\n-let (cpu_arch_abi64:int64) = 0x01000000L\n-;;\n-\n-let (mh_magic:int64) = 0xfeedfaceL\n-;;\n-\n-let cpu_subtype_intel (f:int64) (m:int64) : int64 =\n-  Int64.add f (Int64.shift_left m 4)\n-;;\n-\n-type cpu_type =\n-    (* Maybe support more later. *)\n-    CPU_TYPE_X86\n-  | CPU_TYPE_X86_64\n-  | CPU_TYPE_ARM\n-  | CPU_TYPE_POWERPC\n-;;\n-\n-type cpu_subtype =\n-    (* Maybe support more later. *)\n-    CPU_SUBTYPE_X86_ALL\n-  | CPU_SUBTYPE_X86_64_ALL\n-  | CPU_SUBTYPE_ARM_ALL\n-  | CPU_SUBTYPE_POWERPC_ALL\n-;;\n-\n-type file_type =\n-    MH_OBJECT\n-  | MH_EXECUTE\n-  | MH_FVMLIB\n-  | MH_CORE\n-  | MH_PRELOAD\n-  | MH_DYLIB\n-  | MH_DYLINKER\n-  | MH_BUNDLE\n-  | MH_DYLIB_STUB\n-  | MH_DSYM\n-;;\n-\n-let file_type_code (ft:file_type) : int64 =\n-  match ft with\n-      MH_OBJECT ->0x1L      (* object *)\n-    | MH_EXECUTE -> 0x2L    (* executable *)\n-    | MH_FVMLIB -> 0x3L     (* fixed-VM shared lib *)\n-    | MH_CORE -> 0x4L       (* core *)\n-    | MH_PRELOAD -> 0x5L    (* preloaded executable *)\n-    | MH_DYLIB -> 0x6L      (* dynamic lib *)\n-    | MH_DYLINKER -> 0x7L   (* dynamic linker *)\n-    | MH_BUNDLE -> 0x8L     (* bundle *)\n-    | MH_DYLIB_STUB -> 0x9L (* shared lib stub *)\n-    | MH_DSYM -> 0xaL       (* debuginfo only *)\n-;;\n-\n-type file_flag =\n-    MH_NOUNDEFS\n-  | MH_INCRLINK\n-  | MH_DYLDLINK\n-  | MH_BINDATLOAD\n-  | MH_PREBOUND\n-  | MH_SPLIT_SEGS\n-  | MH_LAZY_INIT\n-  | MH_TWOLEVEL\n-  | MH_FORCE_FLAT\n-  | MH_NOMULTIDEFS\n-  | MH_NOFIXPREBINDING\n-  | MH_PREBINDABLE\n-  | MH_ALLMODSBOUND\n-  | MH_SUBSECTIONS_VIA_SYMBOLS\n-  | MH_CANONICAL\n-  | MH_WEAK_DEFINES\n-  | MH_BINDS_TO_WEAK\n-  | MH_ALLOW_STACK_EXECUTION\n-  | MH_ROOT_SAFE\n-  | MH_SETUID_SAFE\n-  | MH_NO_REEXPORTED_DYLIBS\n-  | MH_PIE\n-;;\n-\n-let file_flag_code (ff:file_flag) : int64 =\n-  match ff with\n-      MH_NOUNDEFS -> 0x1L\n-    | MH_INCRLINK -> 0x2L\n-    | MH_DYLDLINK -> 0x4L\n-    | MH_BINDATLOAD -> 0x8L\n-    | MH_PREBOUND -> 0x10L\n-    | MH_SPLIT_SEGS -> 0x20L\n-    | MH_LAZY_INIT -> 0x40L\n-    | MH_TWOLEVEL -> 0x80L\n-    | MH_FORCE_FLAT -> 0x100L\n-    | MH_NOMULTIDEFS -> 0x200L\n-    | MH_NOFIXPREBINDING -> 0x400L\n-    | MH_PREBINDABLE -> 0x800L\n-    | MH_ALLMODSBOUND -> 0x1000L\n-    | MH_SUBSECTIONS_VIA_SYMBOLS -> 0x2000L\n-    | MH_CANONICAL -> 0x4000L\n-    | MH_WEAK_DEFINES -> 0x8000L\n-    | MH_BINDS_TO_WEAK -> 0x10000L\n-    | MH_ALLOW_STACK_EXECUTION -> 0x20000L\n-    | MH_ROOT_SAFE -> 0x40000L\n-    | MH_SETUID_SAFE -> 0x80000L\n-    | MH_NO_REEXPORTED_DYLIBS -> 0x100000L\n-    | MH_PIE -> 0x200000L\n-;;\n-\n-\n-type vm_prot =\n-    VM_PROT_NONE\n-  | VM_PROT_READ\n-  | VM_PROT_WRITE\n-  | VM_PROT_EXECUTE\n-;;\n-\n-\n-type load_command =\n-    LC_SEGMENT\n-  | LC_SYMTAB\n-  | LC_SYMSEG\n-  | LC_THREAD\n-  | LC_UNIXTHREAD\n-  | LC_LOADFVMLIB\n-  | LC_IDFVMLIB\n-  | LC_IDENT\n-  | LC_FVMFILE\n-  | LC_PREPAGE\n-  | LC_DYSYMTAB\n-  | LC_LOAD_DYLIB\n-  | LC_ID_DYLIB\n-  | LC_LOAD_DYLINKER\n-  | LC_ID_DYLINKER\n-  | LC_PREBOUND_DYLIB\n-  | LC_ROUTINES\n-  | LC_SUB_FRAMEWORK\n-  | LC_SUB_UMBRELLA\n-  | LC_SUB_CLIENT\n-  | LC_SUB_LIBRARY\n-  | LC_TWOLEVEL_HINTS\n-  | LC_PREBIND_CKSUM\n-  | LC_LOAD_WEAK_DYLIB\n-  | LC_SEGMENT_64\n-  | LC_ROUTINES_64\n-  | LC_UUID\n-  | LC_RPATH\n-  | LC_CODE_SIGNATURE\n-  | LC_SEGMENT_SPLIT_INFO\n-  | LC_REEXPORT_DYLIB\n-  | LC_LAZY_LOAD_DYLIB\n-  | LC_ENCRYPTION_INFO\n-;;\n-\n-\n-let cpu_type_code (cpu:cpu_type) : int64 =\n-  match cpu with\n-      CPU_TYPE_X86 -> 7L\n-    | CPU_TYPE_X86_64 -> Int64.logor 7L cpu_arch_abi64\n-    | CPU_TYPE_ARM -> 12L\n-    | CPU_TYPE_POWERPC -> 18L\n-;;\n-\n-let cpu_subtype_code (cpu:cpu_subtype) : int64 =\n-  match cpu with\n-      CPU_SUBTYPE_X86_ALL -> 3L\n-    | CPU_SUBTYPE_X86_64_ALL -> 3L\n-    | CPU_SUBTYPE_ARM_ALL -> 0L\n-    | CPU_SUBTYPE_POWERPC_ALL -> 0L\n-;;\n-\n-\n-let vm_prot_code (vmp:vm_prot) : int64 =\n-  match vmp with\n-    VM_PROT_NONE -> 0L\n-  | VM_PROT_READ -> 1L\n-  | VM_PROT_WRITE -> 2L\n-  | VM_PROT_EXECUTE -> 4L\n-;;\n-\n-\n-let lc_req_dyld = 0x80000000L;;\n-\n-let load_command_code (lc:load_command) =\n-  match lc with\n-    | LC_SEGMENT -> 0x1L\n-    | LC_SYMTAB -> 0x2L\n-    | LC_SYMSEG -> 0x3L\n-    | LC_THREAD -> 0x4L\n-    | LC_UNIXTHREAD -> 0x5L\n-    | LC_LOADFVMLIB -> 0x6L\n-    | LC_IDFVMLIB -> 0x7L\n-    | LC_IDENT -> 0x8L\n-    | LC_FVMFILE -> 0x9L\n-    | LC_PREPAGE -> 0xaL\n-    | LC_DYSYMTAB -> 0xbL\n-    | LC_LOAD_DYLIB -> 0xcL\n-    | LC_ID_DYLIB -> 0xdL\n-    | LC_LOAD_DYLINKER -> 0xeL\n-    | LC_ID_DYLINKER -> 0xfL\n-    | LC_PREBOUND_DYLIB -> 0x10L\n-    | LC_ROUTINES -> 0x11L\n-    | LC_SUB_FRAMEWORK -> 0x12L\n-    | LC_SUB_UMBRELLA -> 0x13L\n-    | LC_SUB_CLIENT -> 0x14L\n-    | LC_SUB_LIBRARY -> 0x15L\n-    | LC_TWOLEVEL_HINTS -> 0x16L\n-    | LC_PREBIND_CKSUM -> 0x17L\n-    | LC_LOAD_WEAK_DYLIB -> Int64.logor lc_req_dyld 0x18L\n-    | LC_SEGMENT_64 -> 0x19L\n-    | LC_ROUTINES_64 -> 0x1aL\n-    | LC_UUID -> 0x1bL\n-    | LC_RPATH -> Int64.logor lc_req_dyld 0x1cL\n-    | LC_CODE_SIGNATURE -> 0x1dL\n-    | LC_SEGMENT_SPLIT_INFO -> 0x1eL\n-    | LC_REEXPORT_DYLIB -> Int64.logor lc_req_dyld 0x1fL\n-    | LC_LAZY_LOAD_DYLIB -> 0x20L\n-    | LC_ENCRYPTION_INFO -> 0x21L\n-;;\n-\n-\n-let fixed_sz_string (sz:int) (str:string) : frag =\n-  if String.length str > sz\n-  then STRING (String.sub str 0 sz)\n-  else SEQ [| STRING str; PAD (sz - (String.length str)) |]\n-;;\n-\n-type sect_type =\n-    S_REGULAR\n-  | S_ZEROFILL\n-  | S_CSTRING_LITERALS\n-  | S_4BYTE_LITERALS\n-  | S_8BYTE_LITERALS\n-  | S_LITERAL_POINTERS\n-  | S_NON_LAZY_SYMBOL_POINTERS\n-  | S_LAZY_SYMBOL_POINTERS\n-  | S_SYMBOL_STUBS\n-  | S_MOD_INIT_FUNC_POINTERS\n-  | S_MOD_TERM_FUNC_POINTERS\n-  | S_COALESCED\n-  | S_GB_ZEROFILL\n-  | S_INTERPOSING\n-  | S_16BYTE_LITERALS\n-  | S_DTRACE_DOF\n-  | S_LAZY_DYLIB_SYMBOL_POINTERS\n-;;\n-\n-let sect_type_code (s:sect_type) : int64 =\n-  match s with\n-    S_REGULAR -> 0x0L\n-  | S_ZEROFILL -> 0x1L\n-  | S_CSTRING_LITERALS -> 0x2L\n-  | S_4BYTE_LITERALS -> 0x3L\n-  | S_8BYTE_LITERALS -> 0x4L\n-  | S_LITERAL_POINTERS -> 0x5L\n-  | S_NON_LAZY_SYMBOL_POINTERS -> 0x6L\n-  | S_LAZY_SYMBOL_POINTERS -> 0x7L\n-  | S_SYMBOL_STUBS -> 0x8L\n-  | S_MOD_INIT_FUNC_POINTERS -> 0x9L\n-  | S_MOD_TERM_FUNC_POINTERS -> 0xaL\n-  | S_COALESCED -> 0xbL\n-  | S_GB_ZEROFILL -> 0xcL\n-  | S_INTERPOSING -> 0xdL\n-  | S_16BYTE_LITERALS -> 0xeL\n-  | S_DTRACE_DOF -> 0xfL\n-  | S_LAZY_DYLIB_SYMBOL_POINTERS -> 0x10L\n-;;\n-\n-type sect_attr =\n-    S_ATTR_PURE_INSTRUCTIONS\n-  | S_ATTR_NO_TOC\n-  | S_ATTR_STRIP_STATIC_SYMS\n-  | S_ATTR_NO_DEAD_STRIP\n-  | S_ATTR_LIVE_SUPPORT\n-  | S_ATTR_SELF_MODIFYING_CODE\n-  | S_ATTR_DEBUG\n-  | S_ATTR_SOME_INSTRUCTIONS\n-  | S_ATTR_EXT_RELOC\n-  | S_ATTR_LOC_RELOC\n-;;\n-\n-let sect_attr_code (s:sect_attr) : int64 =\n-  match s with\n-    S_ATTR_PURE_INSTRUCTIONS -> 0x80000000L\n-  | S_ATTR_NO_TOC -> 0x40000000L\n-  | S_ATTR_STRIP_STATIC_SYMS -> 0x20000000L\n-  | S_ATTR_NO_DEAD_STRIP -> 0x10000000L\n-  | S_ATTR_LIVE_SUPPORT -> 0x08000000L\n-  | S_ATTR_SELF_MODIFYING_CODE -> 0x04000000L\n-  | S_ATTR_DEBUG -> 0x02000000L\n-  | S_ATTR_SOME_INSTRUCTIONS -> 0x00000400L\n-  | S_ATTR_EXT_RELOC -> 0x00000200L\n-  | S_ATTR_LOC_RELOC -> 0x00000100L\n-;;\n-\n-type n_type =\n-  | N_EXT\n-  | N_UNDF\n-  | N_ABS\n-  | N_SECT\n-  | N_PBUD\n-  | N_INDIR\n-;;\n-\n-let n_type_code (n:n_type) : int64 =\n-  match n with\n-      N_EXT -> 0x1L\n-    | N_UNDF -> 0x0L\n-    | N_ABS -> 0x2L\n-    | N_SECT -> 0xeL\n-    | N_PBUD -> 0xcL\n-    | N_INDIR -> 0xaL\n-;;\n-\n-\n-type n_desc_reference_type =\n-    REFERENCE_FLAG_UNDEFINED_NON_LAZY\n-  | REFERENCE_FLAG_UNDEFINED_LAZY\n-  | REFERENCE_FLAG_DEFINED\n-  | REFERENCE_FLAG_PRIVATE_DEFINED\n-  | REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY\n-  | REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY\n-;;\n-\n-let n_desc_reference_type_code (n:n_desc_reference_type) : int64 =\n-  match n with\n-      REFERENCE_FLAG_UNDEFINED_NON_LAZY -> 0x0L\n-    | REFERENCE_FLAG_UNDEFINED_LAZY -> 0x1L\n-    | REFERENCE_FLAG_DEFINED -> 0x2L\n-    | REFERENCE_FLAG_PRIVATE_DEFINED -> 0x3L\n-    | REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY -> 0x4L\n-    | REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY -> 0x5L\n-;;\n-\n-type n_desc_flags =\n-    REFERENCED_DYNAMICALLY\n-  | N_DESC_DISCARDED\n-  | N_NO_DEAD_STRIP\n-  | N_WEAK_REF\n-  | N_WEAK_DEF\n-;;\n-\n-let n_desc_flags_code (n:n_desc_flags) : int64 =\n-  match n with\n-      REFERENCED_DYNAMICALLY -> 0x10L\n-    | N_DESC_DISCARDED -> 0x20L\n-    | N_NO_DEAD_STRIP -> 0x20L (* Yes, they reuse 0x20. *)\n-    | N_WEAK_REF -> 0x40L\n-    | N_WEAK_DEF -> 0x80L\n-;;\n-\n-type n_desc_dylib_ordinal = int;;\n-\n-type n_desc = (n_desc_dylib_ordinal *\n-                 (n_desc_flags list) *\n-                 n_desc_reference_type)\n-;;\n-\n-let n_desc_code (n:n_desc) : int64 =\n-  let (dylib_ordinal, flags, ty) = n in\n-    Int64.logor\n-      (Int64.of_int (dylib_ordinal lsl 8))\n-      (Int64.logor\n-         (fold_flags n_desc_flags_code flags)\n-         (n_desc_reference_type_code ty))\n-;;\n-\n-\n-let macho_section_command\n-    (seg_name:string)\n-    (sect:(string * int * (sect_attr list) * sect_type * fixup))\n-    : frag =\n-  let (sect_name, sect_align, sect_attrs, sect_type, sect_fixup) = sect in\n-    SEQ [|\n-      fixed_sz_string 16 sect_name;\n-      fixed_sz_string 16 seg_name;\n-      WORD (TY_u32, M_POS sect_fixup);\n-      WORD (TY_u32, M_SZ sect_fixup);\n-      WORD (TY_u32, F_POS sect_fixup);\n-      WORD (TY_u32, IMM (Int64.of_int sect_align));\n-      WORD (TY_u32, IMM 0L); (* reloff *)\n-      WORD (TY_u32, IMM 0L); (* nreloc *)\n-      WORD (TY_u32, (IMM (Int64.logor (* flags (and attrs) *)\n-                            (fold_flags sect_attr_code sect_attrs)\n-                            (sect_type_code sect_type))));\n-      WORD (TY_u32, IMM 0L); (* reserved1 *)\n-      WORD (TY_u32, IMM 0L); (* reserved2 *)\n-  |]\n-;;\n-\n-let macho_segment_command\n-    (seg_name:string)\n-    (seg_fixup:fixup)\n-    (maxprot:vm_prot list)\n-    (initprot:vm_prot list)\n-    (sects:(string * int * (sect_attr list) * sect_type * fixup) array)\n-    : frag =\n-\n-  let cmd_fixup = new_fixup \"segment command\" in\n-  let cmd =\n-    SEQ [|\n-      WORD (TY_u32, IMM (load_command_code LC_SEGMENT));\n-      WORD (TY_u32, F_SZ cmd_fixup);\n-      fixed_sz_string 16 seg_name;\n-      WORD (TY_u32, M_POS seg_fixup);\n-      WORD (TY_u32, M_SZ seg_fixup);\n-      WORD (TY_u32, F_POS seg_fixup);\n-      WORD (TY_u32, F_SZ seg_fixup);\n-      WORD (TY_u32, IMM (fold_flags vm_prot_code maxprot));\n-      WORD (TY_u32, IMM (fold_flags vm_prot_code initprot));\n-      WORD (TY_u32, IMM (Int64.of_int (Array.length sects)));\n-      WORD (TY_u32, IMM 0L); (* Flags? *)\n-    |]\n-  in\n-    DEF (cmd_fixup,\n-         SEQ [|\n-           cmd;\n-           SEQ (Array.map (macho_section_command seg_name) sects);\n-         |])\n-;;\n-\n-let macho_thread_command\n-    (entry:fixup)\n-    : frag =\n-  let cmd_fixup = new_fixup \"thread command\" in\n-  let x86_THREAD_STATE32 = 1L in\n-  let regs =\n-    [|\n-      WORD (TY_u32, IMM 0x0L); (* eax *)\n-      WORD (TY_u32, IMM 0x0L); (* ebx *)\n-      WORD (TY_u32, IMM 0x0L); (* ecx *)\n-      WORD (TY_u32, IMM 0x0L); (* edx *)\n-\n-      WORD (TY_u32, IMM 0x0L); (* edi *)\n-      WORD (TY_u32, IMM 0x0L); (* esi *)\n-      WORD (TY_u32, IMM 0x0L); (* ebp *)\n-      WORD (TY_u32, IMM 0x0L); (* esp *)\n-\n-      WORD (TY_u32, IMM 0x0L);    (* ss     *)\n-      WORD (TY_u32, IMM 0x0L);    (* eflags *)\n-      WORD (TY_u32, M_POS entry); (* eip    *)\n-      WORD (TY_u32, IMM 0x0L);    (* cs     *)\n-\n-      WORD (TY_u32, IMM 0x0L); (* ds *)\n-      WORD (TY_u32, IMM 0x0L); (* es *)\n-      WORD (TY_u32, IMM 0x0L); (* fs *)\n-      WORD (TY_u32, IMM 0x0L); (* gs *)\n-    |]\n-  in\n-  let cmd =\n-    SEQ [|\n-      WORD (TY_u32, IMM (load_command_code LC_UNIXTHREAD));\n-      WORD (TY_u32, F_SZ cmd_fixup);\n-      WORD (TY_u32, IMM x86_THREAD_STATE32); (* \"flavour\" *)\n-      WORD (TY_u32, IMM (Int64.of_int (Array.length regs)));\n-      SEQ regs\n-    |]\n-  in\n-    DEF (cmd_fixup, cmd)\n-;;\n-\n-let macho_dylinker_command : frag =\n-  let cmd_fixup = new_fixup \"dylinker command\" in\n-  let str_fixup = new_fixup \"dylinker lc_str fixup\" in\n-  let cmd =\n-    SEQ\n-      [|\n-        WORD (TY_u32, IMM (load_command_code LC_LOAD_DYLINKER));\n-        WORD (TY_u32, F_SZ cmd_fixup);\n-\n-        (* see definition of lc_str; these things are weird. *)\n-        WORD (TY_u32, SUB (F_POS (str_fixup), F_POS (cmd_fixup)));\n-        DEF (str_fixup, ZSTRING \"/usr/lib/dyld\");\n-        ALIGN_FILE (4, MARK);\n-      |]\n-  in\n-    DEF (cmd_fixup, cmd);\n-;;\n-\n-let macho_dylib_command (dylib:string) : frag =\n-\n-  let cmd_fixup = new_fixup \"dylib command\" in\n-  let str_fixup = new_fixup \"dylib lc_str fixup\" in\n-  let cmd =\n-    SEQ\n-      [|\n-        WORD (TY_u32, IMM (load_command_code LC_LOAD_DYLIB));\n-        WORD (TY_u32, F_SZ cmd_fixup);\n-\n-        (* see definition of lc_str; these things are weird. *)\n-        WORD (TY_u32, SUB (F_POS (str_fixup), F_POS (cmd_fixup)));\n-\n-        WORD (TY_u32, IMM 0L); (* timestamp *)\n-        WORD (TY_u32, IMM 0L); (* current_version *)\n-        WORD (TY_u32, IMM 0L); (* compatibility_version *)\n-\n-        (* Payload-and-alignment of an lc_str goes at end of command. *)\n-        DEF (str_fixup, ZSTRING dylib);\n-        ALIGN_FILE (4, MARK);\n-\n-      |]\n-  in\n-    DEF (cmd_fixup, cmd)\n-;;\n-\n-\n-let macho_symtab_command\n-    (symtab_fixup:fixup)\n-    (nsyms:int64)\n-    (strtab_fixup:fixup)\n-    : frag =\n-  let cmd_fixup = new_fixup \"symtab command\" in\n-  let cmd =\n-    SEQ\n-      [|\n-        WORD (TY_u32, IMM (load_command_code LC_SYMTAB));\n-        WORD (TY_u32, F_SZ cmd_fixup);\n-\n-        WORD (TY_u32, F_POS symtab_fixup); (* symoff *)\n-        WORD (TY_u32, IMM nsyms);          (* nsyms *)\n-\n-        WORD (TY_u32, F_POS strtab_fixup); (* stroff *)\n-        WORD (TY_u32, F_SZ strtab_fixup);  (* strsz *)\n-      |]\n-  in\n-    DEF (cmd_fixup, cmd)\n-;;\n-\n-let macho_dysymtab_command\n-    (local_defined_syms_index:int64)\n-    (local_defined_syms_count:int64)\n-    (external_defined_syms_index:int64)\n-    (external_defined_syms_count:int64)\n-    (undefined_syms_index:int64)\n-    (undefined_syms_count:int64)\n-    (indirect_symtab_fixup:fixup)  : frag =\n-  let cmd_fixup = new_fixup \"dysymtab command\" in\n-  let cmd =\n-    SEQ\n-      [|\n-        WORD (TY_u32, IMM (load_command_code LC_DYSYMTAB));\n-        WORD (TY_u32, F_SZ cmd_fixup);\n-\n-        WORD (TY_u32, IMM local_defined_syms_index); (* ilocalsym *)\n-        WORD (TY_u32, IMM local_defined_syms_count); (* nlocalsym *)\n-\n-        WORD (TY_u32, IMM external_defined_syms_index); (* iextdefsym *)\n-        WORD (TY_u32, IMM external_defined_syms_count); (* nextdefsym *)\n-\n-        WORD (TY_u32, IMM undefined_syms_index); (* iundefsym *)\n-        WORD (TY_u32, IMM undefined_syms_count); (* nundefsym *)\n-\n-        WORD (TY_u32, IMM 0L); (* tocoff *)\n-        WORD (TY_u32, IMM 0L); (* ntoc *)\n-\n-        WORD (TY_u32, IMM 0L); (* modtaboff *)\n-        WORD (TY_u32, IMM 0L); (* nmodtab *)\n-\n-        WORD (TY_u32, IMM 0L); (* extrefsymoff *)\n-        WORD (TY_u32, IMM 0L); (* nextrefsyms *)\n-\n-        WORD (TY_u32, F_POS indirect_symtab_fixup); (* indirectsymoff *)\n-        WORD (TY_u32, IMM undefined_syms_count);    (* nindirectsyms *)\n-\n-        WORD (TY_u32, IMM 0L); (* extreloff *)\n-        WORD (TY_u32, IMM 0L); (* nextrel *)\n-\n-        WORD (TY_u32, IMM 0L); (* locreloff *)\n-        WORD (TY_u32, IMM 0L); (* nlocrel *)\n-      |]\n-  in\n-    DEF (cmd_fixup, cmd)\n-;;\n-\n-let macho_header_32\n-    (cpu:cpu_type)\n-    (sub:cpu_subtype)\n-    (ftype:file_type)\n-    (flags:file_flag list)\n-    (loadcmds:frag array) : frag =\n-  let load_commands_fixup = new_fixup \"load commands\" in\n-  let cmds = DEF (load_commands_fixup, SEQ loadcmds) in\n-    SEQ\n-    [|\n-      WORD (TY_u32, IMM mh_magic);\n-      WORD (TY_u32, IMM (cpu_type_code cpu));\n-      WORD (TY_u32, IMM (cpu_subtype_code sub));\n-      WORD (TY_u32, IMM (file_type_code ftype));\n-      WORD (TY_u32, IMM (Int64.of_int (Array.length loadcmds)));\n-      WORD (TY_u32, F_SZ load_commands_fixup);\n-      WORD (TY_u32, IMM (fold_flags file_flag_code flags));\n-      cmds\n-    |]\n-;;\n-\n-let emit_file\n-    (sess:Session.sess)\n-    (crate:Ast.crate)\n-    (code:Asm.frag)\n-    (data:Asm.frag)\n-    (sem:Semant.ctxt)\n-    (dwarf:Dwarf.debug_records)\n-    : unit =\n-\n-  (* FIXME: alignment? *)\n-\n-  let mh_execute_header_fixup = new_fixup \"__mh_execute header\" in\n-\n-  let nxargc_fixup = (Semant.provide_native sem SEG_data \"NXArgc\") in\n-  let nxargv_fixup = (Semant.provide_native sem SEG_data \"NXArgv\") in\n-  let progname_fixup = (Semant.provide_native sem SEG_data \"__progname\") in\n-  let environ_fixup = (Semant.provide_native sem SEG_data \"environ\") in\n-  let exit_fixup = (Semant.require_native sem REQUIRED_LIB_crt \"exit\") in\n-  let (start_fixup, rust_start_fixup) =\n-    if sess.Session.sess_library_mode\n-    then (None, None)\n-    else (Some (new_fixup \"start function entry\"),\n-          Some (Semant.require_native sem REQUIRED_LIB_rustrt \"rust_start\"))\n-  in\n-\n-  let text_sect_align_log2 = 2 in\n-  let data_sect_align_log2 = 2 in\n-\n-  let seg_align = 0x1000 in\n-  let text_sect_align = 2 lsl text_sect_align_log2 in\n-  let data_sect_align = 2 lsl data_sect_align_log2 in\n-\n-  let align_both align i =\n-    ALIGN_FILE (align,\n-                (ALIGN_MEM (align, i)))\n-  in\n-\n-  let def_aligned a f i =\n-    align_both a\n-      (SEQ [| DEF(f, i);\n-              (align_both a MARK)|])\n-  in\n-\n-  (* Segments. *)\n-  let zero_segment_fixup = new_fixup \"__PAGEZERO segment\" in\n-  let text_segment_fixup = new_fixup \"__TEXT segment\" in\n-  let data_segment_fixup = new_fixup \"__DATA segment\" in\n-  let dwarf_segment_fixup = new_fixup \"__DWARF segment\" in\n-  let linkedit_segment_fixup = new_fixup \"__LINKEDIT segment\" in\n-\n-  (* Sections in the text segment. *)\n-  let text_section_fixup = new_fixup \"__text section\" in\n-\n-  (* Sections in the data segment. *)\n-  let data_section_fixup = new_fixup \"__data section\" in\n-  let const_section_fixup = new_fixup \"__const section\" in\n-  let bss_section_fixup = new_fixup \"__bss section\" in\n-  let note_rust_section_fixup = new_fixup \"__note.rust section\" in\n-  let nl_symbol_ptr_section_fixup = new_fixup \"__nl_symbol_ptr section\" in\n-\n-  let data_section = def_aligned data_sect_align data_section_fixup data in\n-  let const_section =\n-    def_aligned data_sect_align const_section_fixup (SEQ [| |])\n-  in\n-  let bss_section =\n-    def_aligned data_sect_align bss_section_fixup (SEQ [| |])\n-  in\n-  let note_rust_section =\n-    def_aligned\n-      data_sect_align note_rust_section_fixup\n-      (Asm.note_rust_frags crate.node.Ast.crate_meta)\n-  in\n-\n-  (* Officially Apple doesn't claim to support DWARF sections like this, but\n-     they work. *)\n-  let debug_info_section =\n-    def_aligned data_sect_align\n-      sem.Semant.ctxt_debug_info_fixup\n-      dwarf.Dwarf.debug_info\n-  in\n-  let debug_abbrev_section =\n-    def_aligned data_sect_align\n-      sem.Semant.ctxt_debug_abbrev_fixup\n-      dwarf.Dwarf.debug_abbrev\n-  in\n-\n-\n-  (* String, symbol and parallel \"nonlazy-pointer\" tables. *)\n-  let symtab_fixup = new_fixup \"symtab\" in\n-  let strtab_fixup = new_fixup \"strtab\" in\n-\n-  let symbol_nlist_entry\n-      (sect_index:int)\n-      (nty:n_type list)\n-      (nd:n_desc)\n-      (nv:Asm.expr64)\n-      : (frag * fixup) =\n-    let strtab_entry_fixup = new_fixup \"strtab entry\" in\n-      (SEQ\n-         [|\n-           WORD (TY_u32, SUB ((F_POS strtab_entry_fixup),\n-                              (F_POS strtab_fixup)));\n-           BYTE (Int64.to_int (fold_flags n_type_code nty));\n-           BYTE sect_index;\n-           WORD (TY_u16, IMM (n_desc_code nd));\n-           WORD (TY_u32, nv);\n-         |], strtab_entry_fixup)\n-  in\n-\n-  let sect_symbol_nlist_entry\n-      (seg:segment)\n-      (fixup_to_use:fixup)\n-      : (frag * fixup) =\n-    let nty = [ N_SECT; N_EXT ] in\n-    let nd = (0, [], REFERENCE_FLAG_UNDEFINED_NON_LAZY) in\n-    let (sect_index, _(*seg_fix*)) =\n-      match seg with\n-          SEG_text -> (1, text_segment_fixup)\n-        | SEG_data -> (2, data_segment_fixup)\n-    in\n-      symbol_nlist_entry sect_index nty nd (M_POS fixup_to_use)\n-  in\n-\n-  let sect_private_symbol_nlist_entry\n-      (seg:segment)\n-      (fixup_to_use:fixup)\n-      : (frag * fixup) =\n-    let nty = [ N_SECT; ] in\n-    let nd = (0, [], REFERENCE_FLAG_UNDEFINED_NON_LAZY) in\n-    let (sect_index, _(*seg_fix*)) =\n-      match seg with\n-          SEG_text -> (1, text_segment_fixup)\n-        | SEG_data -> (2, data_segment_fixup)\n-    in\n-      symbol_nlist_entry sect_index nty nd (M_POS fixup_to_use)\n-  in\n-\n-  let indirect_symbol_nlist_entry (dylib_index:int) : (frag * fixup) =\n-    let nty = [ N_UNDF; N_EXT ] in\n-    let nd = (dylib_index, [], REFERENCE_FLAG_UNDEFINED_NON_LAZY) in\n-      symbol_nlist_entry 0 nty nd (IMM 0L)\n-  in\n-\n-  let indirect_symbols =\n-    Array.of_list\n-      (List.concat\n-         (List.map\n-            (fun (lib, tab) ->\n-               (List.map\n-                  (fun (name,fix) -> (lib,name,fix))\n-                  (htab_pairs tab)))\n-            (htab_pairs sem.Semant.ctxt_native_required)))\n-  in\n-\n-  let dylib_index (lib:required_lib) : int =\n-    match lib with\n-        REQUIRED_LIB_rustrt -> 1\n-      | REQUIRED_LIB_crt -> 2\n-      | _ -> bug () \"Macho.dylib_index on nonstandard required lib.\"\n-  in\n-\n-  (* Make undef symbols for native imports. *)\n-  let (undefined_symbols:(string * (frag * fixup)) array) =\n-    Array.map (fun (lib,name,_) ->\n-                 (\"_\" ^ name,\n-                  indirect_symbol_nlist_entry (dylib_index lib)))\n-      indirect_symbols\n-  in\n-\n-  (* Make symbols for exports. *)\n-  let (export_symbols:(string * (frag * fixup)) array) =\n-    let export_symbols_of_seg (seg, tab) =\n-      List.map\n-        begin\n-          fun (name, fix) ->\n-            let name = \"_\" ^ name in\n-            let sym = sect_symbol_nlist_entry seg fix in\n-              (name, sym)\n-        end\n-        (htab_pairs tab)\n-    in\n-      Array.of_list\n-        (List.concat\n-           (List.map export_symbols_of_seg\n-              (htab_pairs sem.Semant.ctxt_native_provided)))\n-  in\n-\n-  (* Make private symbols for items. *)\n-  let (local_item_symbols:(string * (frag * fixup)) array) =\n-    Array.map (fun code ->\n-                 let fix = code.Semant.code_fixup in\n-                   (\"_\" ^ fix.fixup_name,\n-                    sect_private_symbol_nlist_entry SEG_text fix))\n-      (Array.of_list (htab_vals sem.Semant.ctxt_all_item_code))\n-  in\n-\n-  (* Make private symbols for glue. *)\n-  let (local_glue_symbols:(string * (frag * fixup)) array) =\n-    Array.map (fun (g, code) ->\n-                 let fix = code.Semant.code_fixup in\n-                   (\"_\" ^ (Semant.glue_str sem g),\n-                    sect_private_symbol_nlist_entry SEG_text fix))\n-      (Array.of_list (htab_pairs sem.Semant.ctxt_glue_code))\n-  in\n-\n-  let (export_header_symbols:(string * (frag * fixup)) array) =\n-    let name =\n-      if sess.Session.sess_library_mode\n-      then \"__mh_dylib_header\"\n-      else \"__mh_execute_header\"\n-    in\n-      [|\n-        (name, sect_symbol_nlist_entry SEG_text mh_execute_header_fixup);\n-      |]\n-  in\n-\n-  let export_symbols = Array.concat [ export_symbols;\n-                                      export_header_symbols ]\n-  in\n-\n-  let local_symbols = Array.concat [ local_item_symbols;\n-                                     local_glue_symbols ]\n-  in\n-\n-  let symbols = Array.concat [ local_symbols;\n-                               export_symbols;\n-                               undefined_symbols ]\n-  in\n-  let n_local_syms = Array.length local_symbols in\n-  let n_export_syms = Array.length export_symbols in\n-  let n_undef_syms = Array.length undefined_symbols in\n-\n-  let indirect_symbols_off = n_local_syms + n_export_syms in\n-  let indirect_symtab_fixup = new_fixup \"indirect symbol table\" in\n-  let indirect_symtab =\n-    DEF (indirect_symtab_fixup,\n-         SEQ (Array.mapi\n-                (fun i _ -> WORD (TY_u32,\n-                                  IMM (Int64.of_int\n-                                         (i + indirect_symbols_off))))\n-                indirect_symbols))\n-  in\n-\n-  let nl_symbol_ptr_section =\n-    def_aligned data_sect_align nl_symbol_ptr_section_fixup\n-      (SEQ (Array.map\n-              (fun (_, _, fix) ->\n-                 DEF(fix, WORD(TY_u32, IMM 0L)))\n-              indirect_symbols))\n-  in\n-  let strtab = DEF (strtab_fixup,\n-                    SEQ (Array.map\n-                           (fun (name, (_, fix)) -> DEF(fix, ZSTRING name))\n-                           symbols))\n-  in\n-  let symtab = DEF (symtab_fixup,\n-                    SEQ (Array.map (fun (_, (frag, _)) -> frag) symbols))\n-  in\n-\n-\n-  let load_commands =\n-    [|\n-      if sess.Session.sess_library_mode\n-      then MARK\n-      else (macho_segment_command \"__PAGEZERO\" zero_segment_fixup\n-              [] [] [||]);\n-\n-      macho_segment_command \"__TEXT\" text_segment_fixup\n-        [VM_PROT_READ; VM_PROT_EXECUTE]\n-        [VM_PROT_READ; VM_PROT_EXECUTE]\n-        [|\n-          (\"__text\", text_sect_align_log2, [], S_REGULAR, text_section_fixup)\n-        |];\n-\n-      macho_segment_command \"__DATA\" data_segment_fixup\n-        [VM_PROT_READ; VM_PROT_WRITE]\n-        [VM_PROT_READ; VM_PROT_WRITE]\n-        [|\n-          (\"__data\", data_sect_align_log2, [],\n-           S_REGULAR, data_section_fixup);\n-          (\"__const\", data_sect_align_log2, [],\n-           S_REGULAR, const_section_fixup);\n-          (\"__bss\", data_sect_align_log2, [],\n-           S_REGULAR, bss_section_fixup);\n-          (\"__note.rust\", data_sect_align_log2, [],\n-           S_REGULAR, note_rust_section_fixup);\n-          (\"__nl_symbol_ptr\", data_sect_align_log2, [],\n-           S_NON_LAZY_SYMBOL_POINTERS, nl_symbol_ptr_section_fixup)\n-        |];\n-\n-      macho_segment_command \"__DWARF\" dwarf_segment_fixup\n-        [VM_PROT_READ]\n-        [VM_PROT_READ]\n-        [|\n-          (\"__debug_info\", data_sect_align_log2, [],\n-           S_REGULAR, sem.Semant.ctxt_debug_info_fixup);\n-          (\"__debug_abbrev\", data_sect_align_log2, [],\n-           S_REGULAR, sem.Semant.ctxt_debug_abbrev_fixup);\n-        |];\n-\n-      macho_segment_command \"__LINKEDIT\" linkedit_segment_fixup\n-        [VM_PROT_READ]\n-        [VM_PROT_READ]\n-        [|\n-        |];\n-\n-      macho_symtab_command\n-        symtab_fixup (Int64.of_int (Array.length symbols)) strtab_fixup;\n-\n-\n-      macho_dysymtab_command\n-        0L\n-        (Int64.of_int n_local_syms)\n-        (Int64.of_int n_local_syms)\n-        (Int64.of_int n_export_syms)\n-        (Int64.of_int (n_local_syms + n_export_syms))\n-        (Int64.of_int n_undef_syms)\n-        indirect_symtab_fixup;\n-\n-      macho_dylinker_command;\n-\n-      macho_dylib_command \"librustrt.dylib\";\n-\n-      macho_dylib_command \"/usr/lib/libSystem.B.dylib\";\n-\n-      begin\n-        match start_fixup with\n-            None -> MARK\n-          | Some start_fixup ->\n-              macho_thread_command start_fixup\n-      end;\n-    |]\n-  in\n-\n-  let header_and_commands =\n-    macho_header_32\n-      CPU_TYPE_X86\n-      CPU_SUBTYPE_X86_ALL\n-      (if sess.Session.sess_library_mode then MH_DYLIB else MH_EXECUTE)\n-      [ MH_BINDATLOAD; MH_DYLDLINK; MH_TWOLEVEL ]\n-      (filter_marks load_commands)\n-  in\n-\n-  let objfile_start e start_fixup rust_start_fixup main_fn_fixup =\n-    let edx = X86.h X86.edx in\n-    let edx_pointee =\n-      Il.Mem ((Il.RegIn (edx, None)), Il.ScalarTy (Il.AddrTy Il.OpaqueTy))\n-    in\n-      Il.emit_full e (Some start_fixup) Il.Dead;\n-\n-      (* zero marks the bottom of the frame chain. *)\n-      Il.emit e (Il.Push (X86.imm (Asm.IMM 0L)));\n-      Il.emit e (Il.umov (X86.rc X86.ebp) (X86.ro X86.esp));\n-\n-      (* 16-byte align stack for SSE. *)\n-      Il.emit e (Il.binary Il.AND (X86.rc X86.esp) (X86.ro X86.esp)\n-                   (X86.imm (Asm.IMM 0xfffffffffffffff0L)));\n-\n-      (* Store argv. *)\n-      Abi.load_fixup_addr e edx nxargv_fixup Il.OpaqueTy;\n-      Il.emit e (Il.lea (X86.rc X86.ecx)\n-                   (Il.Cell (Il.Mem ((Il.RegIn (Il.Hreg X86.ebp,\n-                                                Some (X86.word_off_n 2))),\n-                                     Il.OpaqueTy))));\n-      Il.emit e (Il.umov edx_pointee (X86.ro X86.ecx));\n-      Il.emit e (Il.Push (X86.ro X86.ecx));\n-\n-      (* Store argc. *)\n-      Abi.load_fixup_addr e edx nxargc_fixup Il.OpaqueTy;\n-      Il.emit e (Il.umov (X86.rc X86.eax)\n-                   (X86.c (X86.word_n (Il.Hreg X86.ebp) 1)));\n-      Il.emit e (Il.umov edx_pointee (X86.ro X86.eax));\n-      Il.emit e (Il.Push (X86.ro X86.eax));\n-\n-      (* Calculate and store envp. *)\n-      Il.emit e (Il.binary Il.ADD\n-                   (X86.rc X86.eax) (X86.ro X86.eax)\n-                   (X86.imm (Asm.IMM 1L)));\n-      Il.emit e (Il.binary Il.UMUL\n-                   (X86.rc X86.eax) (X86.ro X86.eax)\n-                   (X86.imm (Asm.IMM X86.word_sz)));\n-      Il.emit e (Il.binary Il.ADD (X86.rc X86.eax)\n-                   (X86.ro X86.eax) (X86.ro X86.ecx));\n-      Abi.load_fixup_addr e edx environ_fixup Il.OpaqueTy;\n-      Il.emit e (Il.umov edx_pointee (X86.ro X86.eax));\n-\n-      (* Push 16 bytes to preserve SSE alignment. *)\n-      Abi.load_fixup_addr e edx sem.Semant.ctxt_crate_fixup Il.OpaqueTy;\n-      Il.emit e (Il.Push (X86.ro X86.edx));\n-      Abi.load_fixup_addr e edx main_fn_fixup Il.OpaqueTy;\n-      Il.emit e (Il.Push (X86.ro X86.edx));\n-      let fptr = Abi.load_fixup_codeptr e edx rust_start_fixup true true in\n-        Il.emit e (Il.call (X86.rc X86.eax) fptr);\n-        Il.emit e (Il.Pop (X86.rc X86.ecx));\n-        Il.emit e (Il.Push (X86.ro X86.eax));\n-        let fptr = Abi.load_fixup_codeptr e edx exit_fixup true true in\n-          Il.emit e (Il.call (X86.rc X86.eax) fptr);\n-          Il.emit e (Il.Pop (X86.rc X86.ecx));\n-          Il.emit e (Il.Pop (X86.rc X86.ecx));\n-          Il.emit e (Il.Pop (X86.rc X86.ecx));\n-          Il.emit e (Il.Pop (X86.rc X86.ecx));\n-\n-          Il.emit e Il.Ret;\n-  in\n-\n-  let text_section =\n-    let start_code =\n-      match (start_fixup, rust_start_fixup,\n-             sem.Semant.ctxt_main_fn_fixup) with\n-          (None, _, _)\n-        | (_, None, _)\n-        | (_, _, None) -> MARK\n-        | (Some start_fixup,\n-           Some rust_start_fixup,\n-           Some main_fn_fixup) ->\n-            let e = X86.new_emitter_without_vregs () in\n-              objfile_start e start_fixup rust_start_fixup main_fn_fixup;\n-              X86.frags_of_emitted_quads sess e\n-    in\n-      def_aligned text_sect_align text_section_fixup\n-        (SEQ [|\n-           start_code;\n-           code\n-         |])\n-  in\n-\n-  let text_segment =\n-      def_aligned seg_align text_segment_fixup\n-        (SEQ [|\n-           DEF (mh_execute_header_fixup, header_and_commands);\n-           text_section;\n-           align_both seg_align MARK;\n-         |]);\n-  in\n-\n-  let zero_segment = align_both seg_align\n-    (SEQ [| MEMPOS 0L; DEF (zero_segment_fixup,\n-                            SEQ [| MEMPOS 0x1000L; MARK |] ) |])\n-  in\n-\n-  let data_segment = def_aligned seg_align data_segment_fixup\n-    (SEQ [|\n-       DEF(nxargc_fixup, WORD (TY_u32, IMM 0L));\n-       DEF(nxargv_fixup, WORD (TY_u32, IMM 0L));\n-       DEF(environ_fixup, WORD (TY_u32, IMM 0L));\n-       DEF(progname_fixup, WORD (TY_u32, IMM 0L));\n-       data_section;\n-       const_section;\n-       bss_section;\n-       note_rust_section;\n-       nl_symbol_ptr_section\n-     |])\n-  in\n-\n-  let dwarf_segment = def_aligned seg_align dwarf_segment_fixup\n-    (SEQ [|\n-       debug_info_section;\n-       debug_abbrev_section;\n-     |])\n-  in\n-\n-  let linkedit_segment = def_aligned seg_align linkedit_segment_fixup\n-    (SEQ [|\n-       symtab;\n-       strtab;\n-       indirect_symtab;\n-     |])\n-  in\n-\n-  let segments =\n-    SEQ [|\n-      DEF (sem.Semant.ctxt_image_base_fixup, MARK);\n-      zero_segment;\n-      text_segment;\n-      data_segment;\n-      dwarf_segment;\n-      linkedit_segment;\n-    |]\n-  in\n-    write_out_frag sess true segments\n-;;\n-\n-\n-let sniff\n-    (sess:Session.sess)\n-    (filename:filename)\n-    : asm_reader option =\n-  try\n-    let stat = Unix.stat filename in\n-    if (stat.Unix.st_kind = Unix.S_REG) &&\n-      (stat.Unix.st_size > 4)\n-    then\n-      let ar = new_asm_reader sess filename in\n-      let _ = log sess \"sniffing Mach-O file\" in\n-        if (ar.asm_get_u32()) = (Int64.to_int mh_magic)\n-        then (ar.asm_seek 0; Some ar)\n-        else None\n-    else\n-      None\n-  with\n-      _ -> None\n-;;\n-\n-let get_sections\n-    (sess:Session.sess)\n-    (ar:asm_reader)\n-    : (string,(int*int)) Hashtbl.t =\n-  let sects = Hashtbl.create 0 in\n-  let _ = log sess \"reading sections\" in\n-  let magic = ar.asm_get_u32() in\n-  let _ = assert (magic = (Int64.to_int mh_magic)) in\n-  let _ = ar.asm_adv_u32() in (* cpu type *)\n-  let _ = ar.asm_adv_u32() in (* cpu subtype *)\n-  let _ = ar.asm_adv_u32() in (* file type *)\n-  let n_load_cmds = ar.asm_get_u32() in\n-  let _ = ar.asm_adv_u32() in\n-  let _ = log sess \"Mach-o file with %d load commands\" n_load_cmds in\n-  let _ = ar.asm_adv_u32() in (* flags *)\n-  let lc_seg = Int64.to_int (load_command_code LC_SEGMENT) in\n-    for i = 0 to n_load_cmds - 1 do\n-      let load_cmd_code = ar.asm_get_u32() in\n-      let load_cmd_size = ar.asm_get_u32() in\n-      let _ = log sess \"load command %d:\" i in\n-        if load_cmd_code != lc_seg\n-        then ar.asm_adv (load_cmd_size - 8)\n-        else\n-          begin\n-            let seg_name = ar.asm_get_zstr_padded 16 in\n-            let _ = log sess \"LC_SEGMENT %s\" seg_name in\n-            let _ = ar.asm_adv_u32() in (* seg mem pos *)\n-            let _ = ar.asm_adv_u32() in (* seg mem sz *)\n-            let _ = ar.asm_adv_u32() in (* seg file pos *)\n-            let _ = ar.asm_adv_u32() in (* seg file sz *)\n-            let _ = ar.asm_adv_u32() in (* maxprot *)\n-            let _ = ar.asm_adv_u32() in (* initprot *)\n-            let n_sects = ar.asm_get_u32() in\n-            let _ = ar.asm_get_u32() in (* flags *)\n-            let _ = log sess \"%d sections\" in\n-              for j = 0 to n_sects - 1 do\n-                let sect_name = ar.asm_get_zstr_padded 16 in\n-                let _ = ar.asm_adv 16 in (* seg name *)\n-                let _ = ar.asm_adv_u32() in (* sect mem pos *)\n-                let m_sz = ar.asm_get_u32() in\n-                let f_pos = ar.asm_get_u32() in\n-                let _ = ar.asm_adv_u32() in (* sect align *)\n-                let _ = ar.asm_adv_u32() in (* reloff *)\n-                let _ = ar.asm_adv_u32() in (* nreloc *)\n-                let _ = ar.asm_adv_u32() in (* flags *)\n-                let _ = ar.asm_adv_u32() in (* reserved1 *)\n-                let _ = ar.asm_adv_u32() in (* reserved2 *)\n-                let _ =\n-                  log sess\n-                    \"  section %d: 0x%x - 0x%x %s \"\n-                    j f_pos (f_pos + m_sz) sect_name\n-                in\n-                let len = String.length sect_name in\n-                let sect_name =\n-                  if (len > 2\n-                      && sect_name.[0] = '_'\n-                      && sect_name.[1] = '_')\n-                  then \".\" ^ (String.sub sect_name 2 (len-2))\n-                  else sect_name\n-                in\n-                  Hashtbl.add sects sect_name (f_pos, m_sz)\n-              done\n-          end\n-    done;\n-    sects\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "296d0ace51ef3254ee85279e2e6ada784ac7fc3e", "filename": "src/boot/be/pe.ml", "status": "removed", "additions": 0, "deletions": 1175, "changes": 1175, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fpe.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fpe.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fpe.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,1175 +0,0 @@\n-(*\n-\n-   Module for writing Microsoft PE files\n-\n-   Every image has a base address it's to be loaded at.\n-\n-   \"file pointer\" = offset in file\n-\n-   \"VA\" = address at runtime\n-\n-   \"RVA\" = VA - base address\n-\n-   If you write a non-RVA absolute address at any point you must put it\n-   in a rebasing list so the loader can adjust it when/if it has to load\n-   you at a different address.\n-\n-   Almost all addresses in the file are RVAs. Worry about the VAs.\n-\n-*)\n-\n-open Asm;;\n-open Common;;\n-\n-let log (sess:Session.sess) =\n-  Session.log \"obj (pe)\"\n-    sess.Session.sess_log_obj\n-    sess.Session.sess_log_out\n-;;\n-\n-let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n-  if sess.Session.sess_log_obj\n-  then thunk ()\n-  else ()\n-;;\n-\n-(*\n-\n-   The default image base (VA) for an executable on Win32 is 0x400000.\n-\n-   We use this too. RVAs are relative to this. RVA 0 = VA 0x400000.\n-\n-   Alignments are also relatively standard and fixed for Win32/PE32:\n-   4k memory pages, 512 byte disk sectors.\n-\n-   Since this is a stupid emitter, and we're not generating an awful\n-   lot of sections, we are not going to differentiate between these\n-   two kinds of alignment: we just align our sections to memory pages\n-   and sometimes waste most of them. Shucks.\n-\n-*)\n-\n-let pe_image_base = 0x400000L;;\n-let pe_file_alignment = 0x200;;\n-let pe_mem_alignment = 0x1000;;\n-\n-let rva (f:fixup) = (SUB ((M_POS f), (IMM pe_image_base)));;\n-\n-let def_file_aligned f i =\n-  ALIGN_FILE\n-    (pe_file_alignment,\n-     SEQ [|\n-       DEF(f,\n-           SEQ [| i;\n-                  ALIGN_FILE\n-                    (pe_file_alignment, MARK) |]) |] )\n-;;\n-\n-let def_mem_aligned f i =\n-  ALIGN_MEM\n-    (pe_mem_alignment,\n-     SEQ [|\n-       DEF(f,\n-           SEQ [| i;\n-                  ALIGN_MEM\n-                    (pe_mem_alignment, MARK) |]) |] )\n-;;\n-\n-let align_both i =\n-  ALIGN_FILE (pe_file_alignment,\n-              (ALIGN_MEM (pe_mem_alignment, i)))\n-;;\n-\n-let def_aligned f i =\n-  align_both\n-    (SEQ [| DEF(f,i);\n-            (align_both MARK)|])\n-;;\n-\n-\n-(*\n-\n-  At the beginning of a PE file there is an MS-DOS stub, 0x00 - 0x7F,\n-  that we just insert literally. It prints \"This program must be run\n-  under Win32\" and exits. Woo!\n-\n-  Within it, at offset 0x3C, there is an encoded offset of the PE\n-  header we actually care about. So 0x3C - 0x3F are 0x00000100 (LE)\n-  which say \"the PE header is actually at 0x100\", a nice sensible spot\n-  for it. We pad the next 128 bytes out to 0x100 and start there for\n-  real.\n-\n-  From then on in it's a sensible object file. Here's the MS-DOS bit.\n-*)\n-\n-let pe_msdos_header_and_padding\n-    : frag =\n-  SEQ [|\n-    BYTES\n-      [|\n-        (* 00000000 *)\n-        0x4d; 0x5a; 0x50; 0x00; 0x02; 0x00; 0x00; 0x00;\n-        0x04; 0x00; 0x0f; 0x00; 0xff; 0xff; 0x00; 0x00;\n-\n-        (* 00000010 *)\n-        0xb8; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n-        0x40; 0x00; 0x1a; 0x00; 0x00; 0x00; 0x00; 0x00;\n-\n-        (* 00000020 *)\n-        0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n-        0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n-\n-        (* 00000030 *)\n-        0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n-        0x00; 0x00; 0x00; 0x00; 0x00; 0x01; 0x00; 0x00;\n-        (*                      ^^^^PE HDR offset^^^^^ *)\n-\n-        (* 00000040 *)\n-        0xba; 0x10; 0x00; 0x0e; 0x1f; 0xb4; 0x09; 0xcd;\n-        0x21; 0xb8; 0x01; 0x4c; 0xcd; 0x21; 0x90; 0x90;\n-\n-        (* 00000050 *)\n-        0x54; 0x68; 0x69; 0x73; 0x20; 0x70; 0x72; 0x6f;  (* \"This pro\" *)\n-        0x67; 0x72; 0x61; 0x6d; 0x20; 0x6d; 0x75; 0x73;  (* \"gram mus\" *)\n-\n-        (* 00000060 *)\n-        0x74; 0x20; 0x62; 0x65; 0x20; 0x72; 0x75; 0x6e;  (* \"t be run\" *)\n-        0x20; 0x75; 0x6e; 0x64; 0x65; 0x72; 0x20; 0x57;  (* \" under W\" *)\n-\n-        (* 00000070 *)\n-        0x69; 0x6e; 0x33; 0x32; 0x0d; 0x0a; 0x24; 0x37;  (* \"in32\\r\\n\" *)\n-        0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n-      |];\n-    PAD 0x80\n-  |]\n-;;\n-\n-(*\n-  A work of art, is it not? Take a moment to appreciate the madness.\n-\n-  All done? Ok, now on to the PE header proper.\n-\n-  PE headers are just COFF headers with a little preamble.\n-*)\n-\n-type pe_machine =\n-    (* Maybe support more later. *)\n-    IMAGE_FILE_MACHINE_AMD64\n-  | IMAGE_FILE_MACHINE_I386\n-;;\n-\n-\n-let pe_timestamp _ =\n-  Int64.of_float (Unix.gettimeofday())\n-;;\n-\n-\n-type pe_characteristics =\n-    (* Maybe support more later. *)\n-    IMAGE_FILE_RELOCS_STRIPPED\n-  | IMAGE_FILE_EXECUTABLE_IMAGE\n-  | IMAGE_FILE_LINE_NUMS_STRIPPED\n-  | IMAGE_FILE_LOCAL_SYMS_STRIPPED\n-  | IMAGE_FILE_32BIT_MACHINE\n-  | IMAGE_FILE_DEBUG_STRIPPED\n-  | IMAGE_FILE_DLL\n-;;\n-\n-\n-let pe_header\n-    ~(machine:pe_machine)\n-    ~(symbol_table_fixup:fixup)\n-    ~(number_of_sections:int64)\n-    ~(number_of_symbols:int64)\n-    ~(loader_hdr_fixup:fixup)\n-    ~(characteristics:pe_characteristics list)\n-    : frag =\n-  ALIGN_FILE\n-    (8,\n-     SEQ [|\n-       STRING \"PE\\x00\\x00\";\n-       WORD (TY_u16, (IMM (match machine with\n-                               IMAGE_FILE_MACHINE_AMD64 -> 0x8664L\n-                             | IMAGE_FILE_MACHINE_I386 -> 0x014cL)));\n-       WORD (TY_u16, (IMM number_of_sections));\n-       WORD (TY_u32, (IMM (pe_timestamp())));\n-       WORD (TY_u32, (F_POS symbol_table_fixup));\n-       WORD (TY_u32, (IMM number_of_symbols));\n-       WORD (TY_u16, (F_SZ loader_hdr_fixup));\n-       WORD (TY_u16, (IMM (fold_flags\n-                      (fun c -> match c with\n-                           IMAGE_FILE_RELOCS_STRIPPED -> 0x1L\n-                         | IMAGE_FILE_EXECUTABLE_IMAGE -> 0x2L\n-                         | IMAGE_FILE_LINE_NUMS_STRIPPED -> 0x4L\n-                         | IMAGE_FILE_LOCAL_SYMS_STRIPPED -> 0x8L\n-                         | IMAGE_FILE_32BIT_MACHINE -> 0x100L\n-                         | IMAGE_FILE_DEBUG_STRIPPED -> 0x200L\n-                         | IMAGE_FILE_DLL -> 0x2000L)\n-                      characteristics)))\n-     |])\n-;;\n-\n-(*\n-\n-   After the PE header comes an \"optional\" header for the loader. In\n-   our case this is hardly optional since we are producing a file for\n-   the loader.\n-\n-*)\n-\n-type pe_subsystem =\n-    (* Maybe support more later. *)\n-    IMAGE_SUBSYSTEM_WINDOWS_GUI\n-  | IMAGE_SUBSYSTEM_WINDOWS_CUI\n-;;\n-\n-let zero32 = WORD (TY_u32, (IMM 0L))\n-;;\n-\n-let pe_loader_header\n-    ~(text_fixup:fixup)\n-    ~(init_data_fixup:fixup)\n-    ~(size_of_uninit_data:int64)\n-    ~(entry_point_fixup:fixup option)\n-    ~(image_fixup:fixup)\n-    ~(all_hdrs_fixup:fixup)\n-    ~(subsys:pe_subsystem)\n-    ~(loader_hdr_fixup:fixup)\n-    ~(import_dir_fixup:fixup)\n-    ~(export_dir_fixup:fixup)\n-    : frag =\n-  DEF\n-    (loader_hdr_fixup,\n-     SEQ [|\n-       WORD (TY_u16, (IMM 0x10bL));          (* COFF magic tag for PE32.  *)\n-       (* Snagged *)\n-       WORD (TY_u8, (IMM 0x2L));             (* Linker major version.     *)\n-       WORD (TY_u8, (IMM 0x38L));            (* Linker minor version.     *)\n-\n-       WORD (TY_u32, (F_SZ text_fixup));     (* \"size of code\"            *)\n-       WORD (TY_u32,                         (* \"size of all init data\"   *)\n-             (F_SZ init_data_fixup));\n-       WORD (TY_u32,\n-             (IMM size_of_uninit_data));\n-\n-       begin\n-         match entry_point_fixup with\n-             None -> zero32                  (* Library mode: DLLMain     *)\n-           | Some entry_point_fixup ->\n-               WORD (TY_u32,\n-                     (rva\n-                        entry_point_fixup))  (* \"address of entry point\"  *)\n-       end;\n-\n-       WORD (TY_u32, (rva text_fixup));      (* \"base of code\"            *)\n-       WORD (TY_u32, (rva init_data_fixup)); (* \"base of data\"            *)\n-       WORD (TY_u32, (IMM pe_image_base));\n-       WORD (TY_u32, (IMM (Int64.of_int\n-                      pe_mem_alignment)));\n-       WORD (TY_u32, (IMM (Int64.of_int\n-                      pe_file_alignment)));\n-\n-       WORD (TY_u16, (IMM 4L));             (* Major OS version: NT4.     *)\n-       WORD (TY_u16, (IMM 0L));             (* Minor OS version.          *)\n-       WORD (TY_u16, (IMM 1L));             (* Major image version.       *)\n-       WORD (TY_u16, (IMM 0L));             (* Minor image version.       *)\n-       WORD (TY_u16, (IMM 4L));             (* Major subsystem version.   *)\n-       WORD (TY_u16, (IMM 0L));             (* Minor subsystem version.   *)\n-\n-       zero32;                              (* Reserved.                  *)\n-\n-       WORD (TY_u32, (M_SZ image_fixup));\n-       WORD (TY_u32, (M_SZ all_hdrs_fixup));\n-\n-       zero32;                              (* Checksum, but OK if zero.  *)\n-       WORD (TY_u16, (IMM (match subsys with\n-                        IMAGE_SUBSYSTEM_WINDOWS_GUI -> 2L\n-                      | IMAGE_SUBSYSTEM_WINDOWS_CUI -> 3L)));\n-\n-       WORD (TY_u16, (IMM 0L));             (* DLL characteristics.       *)\n-\n-       WORD (TY_u32, (IMM 0x100000L));      (* Size of stack reserve.     *)\n-       WORD (TY_u32, (IMM 0x4000L));        (* Size of stack commit.      *)\n-\n-       WORD (TY_u32, (IMM 0x100000L));      (* Size of heap reserve.      *)\n-       WORD (TY_u32, (IMM 0x1000L));        (* Size of heap commit.       *)\n-\n-       zero32;                              (* Reserved.                  *)\n-       WORD (TY_u32, (IMM 16L));            (* Number of dir references.  *)\n-\n-       (* Begin directories, variable part of hdr.        *)\n-\n-       (*\n-\n-         Standard PE files have ~10 directories referenced from\n-         here. We only fill in two of them -- the export/import\n-         directories -- because we don't care about the others. We\n-         leave the rest as zero in case someone is looking for\n-         them. This may be superfluous or wrong.\n-\n-       *)\n-\n-\n-       WORD (TY_u32, (rva export_dir_fixup));\n-       WORD (TY_u32, (M_SZ export_dir_fixup));\n-\n-       WORD (TY_u32, (rva import_dir_fixup));\n-       WORD (TY_u32, (M_SZ import_dir_fixup));\n-\n-       zero32; zero32;    (* Resource dir.      *)\n-       zero32; zero32;    (* Exception dir.     *)\n-       zero32; zero32;    (* Security dir.      *)\n-       zero32; zero32;    (* Base reloc dir.    *)\n-       zero32; zero32;    (* Debug dir.         *)\n-       zero32; zero32;    (* Image desc dir.    *)\n-       zero32; zero32;    (* Mach spec dir.     *)\n-       zero32; zero32;    (* TLS dir.           *)\n-\n-       zero32; zero32;    (* Load config.       *)\n-       zero32; zero32;    (* Bound import.      *)\n-       zero32; zero32;    (* IAT                *)\n-       zero32; zero32;    (* Delay import.      *)\n-       zero32; zero32;    (* COM descriptor     *)\n-       zero32; zero32;    (* ????????           *)\n-     |])\n-\n-;;\n-\n-\n-type pe_section_id =\n-    (* Maybe support more later. *)\n-    SECTION_ID_TEXT\n-  | SECTION_ID_DATA\n-  | SECTION_ID_RDATA\n-  | SECTION_ID_BSS\n-  | SECTION_ID_IMPORTS\n-  | SECTION_ID_EXPORTS\n-  | SECTION_ID_DEBUG_ARANGES\n-  | SECTION_ID_DEBUG_PUBNAMES\n-  | SECTION_ID_DEBUG_INFO\n-  | SECTION_ID_DEBUG_ABBREV\n-  | SECTION_ID_DEBUG_LINE\n-  | SECTION_ID_DEBUG_FRAME\n-  | SECTION_ID_NOTE_RUST\n-;;\n-\n-type pe_section_characteristics =\n-    (* Maybe support more later. *)\n-    IMAGE_SCN_CNT_CODE\n-  | IMAGE_SCN_CNT_INITIALIZED_DATA\n-  | IMAGE_SCN_CNT_UNINITIALIZED_DATA\n-  | IMAGE_SCN_MEM_DISCARDABLE\n-  | IMAGE_SCN_MEM_SHARED\n-  | IMAGE_SCN_MEM_EXECUTE\n-  | IMAGE_SCN_MEM_READ\n-  | IMAGE_SCN_MEM_WRITE\n-\n-let pe_section_header\n-    ~(id:pe_section_id)\n-    ~(hdr_fixup:fixup)\n-    : frag =\n-  let\n-      characteristics =\n-    match id with\n-        SECTION_ID_TEXT -> [ IMAGE_SCN_CNT_CODE;\n-                             IMAGE_SCN_MEM_READ;\n-                             IMAGE_SCN_MEM_EXECUTE ]\n-      | SECTION_ID_DATA -> [ IMAGE_SCN_CNT_INITIALIZED_DATA;\n-                             IMAGE_SCN_MEM_READ;\n-                             IMAGE_SCN_MEM_WRITE ]\n-      | SECTION_ID_BSS -> [ IMAGE_SCN_CNT_UNINITIALIZED_DATA;\n-                            IMAGE_SCN_MEM_READ;\n-                            IMAGE_SCN_MEM_WRITE ]\n-      | SECTION_ID_IMPORTS -> [ IMAGE_SCN_CNT_INITIALIZED_DATA;\n-                                IMAGE_SCN_MEM_READ;\n-                                IMAGE_SCN_MEM_WRITE ]\n-      | SECTION_ID_EXPORTS -> [ IMAGE_SCN_CNT_INITIALIZED_DATA;\n-                                IMAGE_SCN_MEM_READ ]\n-      | SECTION_ID_RDATA\n-      | SECTION_ID_DEBUG_ARANGES\n-      | SECTION_ID_DEBUG_PUBNAMES\n-      | SECTION_ID_DEBUG_INFO\n-      | SECTION_ID_DEBUG_ABBREV\n-      | SECTION_ID_DEBUG_LINE\n-      | SECTION_ID_DEBUG_FRAME\n-      | SECTION_ID_NOTE_RUST -> [ IMAGE_SCN_CNT_INITIALIZED_DATA;\n-                                  IMAGE_SCN_MEM_READ ]\n-  in\n-    SEQ [|\n-      STRING\n-        begin\n-          match id with\n-              SECTION_ID_TEXT -> \".text\\x00\\x00\\x00\"\n-            | SECTION_ID_DATA -> \".data\\x00\\x00\\x00\"\n-            | SECTION_ID_RDATA -> \".rdata\\x00\\x00\"\n-            | SECTION_ID_BSS -> \".bss\\x00\\x00\\x00\\x00\"\n-            | SECTION_ID_IMPORTS -> \".idata\\x00\\x00\"\n-            | SECTION_ID_EXPORTS -> \".edata\\x00\\x00\"\n-\n-            (* There is a bizarre Microsoft COFF extension to account\n-             * for longer-than-8-char section names: you emit a single\n-             * '/' character then the ASCII-numeric encoding of the\n-             * offset within the file's string table of the full name.\n-             * So we put all our extended section names at the\n-             * beginning of the string table in a very specific order\n-             * and hard-wire the offsets as \"names\" here. You could\n-             * theoretically extend this to a \"new kind\" of fixup\n-             * reference (ASCII_POS or such), if you feel this is\n-             * something you want to twiddle with.\n-             *)\n-\n-            | SECTION_ID_DEBUG_ARANGES  -> \"/4\\x00\\x00\\x00\\x00\\x00\\x00\"\n-            | SECTION_ID_DEBUG_PUBNAMES -> \"/19\\x00\\x00\\x00\\x00\\x00\"\n-            | SECTION_ID_DEBUG_INFO     -> \"/35\\x00\\x00\\x00\\x00\\x00\"\n-            | SECTION_ID_DEBUG_ABBREV   -> \"/47\\x00\\x00\\x00\\x00\\x00\"\n-            | SECTION_ID_DEBUG_LINE     -> \"/61\\x00\\x00\\x00\\x00\\x00\"\n-            | SECTION_ID_DEBUG_FRAME    -> \"/73\\x00\\x00\\x00\\x00\\x00\"\n-            | SECTION_ID_NOTE_RUST      -> \"/86\\x00\\x00\\x00\\x00\\x00\"\n-        end;\n-\n-      (* The next two pairs are only supposed to be different if the\n-         file and section alignments differ. This is a stupid emitter\n-         so they're not, no problem. *)\n-\n-      WORD (TY_u32, (M_SZ hdr_fixup));  (* \"Virtual size\"    *)\n-      WORD (TY_u32, (rva hdr_fixup));   (* \"Virtual address\" *)\n-\n-      WORD (TY_u32, (F_SZ hdr_fixup));  (* \"Size of raw data\"    *)\n-      WORD (TY_u32, (F_POS hdr_fixup)); (* \"Pointer to raw data\" *)\n-\n-      zero32;      (* Reserved. *)\n-      zero32;      (* Reserved. *)\n-      zero32;      (* Reserved. *)\n-\n-      WORD (TY_u32, (IMM (fold_flags\n-                     (fun c -> match c with\n-                          IMAGE_SCN_CNT_CODE -> 0x20L\n-                        | IMAGE_SCN_CNT_INITIALIZED_DATA -> 0x40L\n-                        | IMAGE_SCN_CNT_UNINITIALIZED_DATA -> 0x80L\n-                        | IMAGE_SCN_MEM_DISCARDABLE -> 0x2000000L\n-                        | IMAGE_SCN_MEM_SHARED -> 0x10000000L\n-                        | IMAGE_SCN_MEM_EXECUTE -> 0x20000000L\n-                        | IMAGE_SCN_MEM_READ -> 0x40000000L\n-                        | IMAGE_SCN_MEM_WRITE -> 0x80000000L)\n-                     characteristics)))\n-    |]\n-;;\n-\n-\n-(*\n-\n-   \"Thunk\" is a misnomer here; the thunk RVA is the address of a word\n-   that the loader will store an address into. The stored address is\n-   the address of the imported object.\n-\n-   So if the imported object is X, and the thunk slot is Y, the loader\n-   is doing \"Y = &X\" and returning &Y as the thunk RVA. To load datum X\n-   after the imports are resolved, given the thunk RVA R, you load\n-   **R.\n-\n-*)\n-\n-type pe_import =\n-    {\n-      pe_import_name_fixup: fixup;\n-      pe_import_name: string;\n-      pe_import_address_fixup: fixup;\n-    }\n-\n-type pe_import_dll_entry =\n-    {\n-      pe_import_dll_name_fixup: fixup;\n-      pe_import_dll_name: string;\n-      pe_import_dll_ILT_fixup: fixup;\n-      pe_import_dll_IAT_fixup: fixup;\n-      pe_import_dll_imports: pe_import array;\n-    }\n-\n-  (*\n-\n-     The import section .idata has a mostly self-contained table\n-     structure. You feed it a list of DLL entries, each of which names\n-     a DLL and lists symbols in the DLL to import.\n-\n-     For each named symbol, a 4-byte slot will be reserved in an\n-     \"import lookup table\" (ILT, also in this section). The slot is\n-     a pointer to a string in this section giving the name.\n-\n-     Immediately *after* the ILT, there is an \"import address table\" (IAT),\n-     which is initially identical to the ILT. The loader replaces the entries\n-     in the IAT slots with the imported pointers at runtime.\n-\n-     A central directory at the start of the section lists all the the import\n-     thunk tables. Each entry in the import directory is 20 bytes (5 words)\n-     but only the last 2 are used: the second last is a pointer to the string\n-     name of the DLL in question (string also in this section) and the last is\n-     a pointer to the import thunk table itself (also in this section).\n-\n-     Curiously, of the 5 documents I've consulted on the nature of the\n-     first 3 fields, I find a variety of interpretations.\n-\n-  *)\n-\n-let pe_import_section\n-    ~(import_dir_fixup:fixup)\n-    ~(dlls:pe_import_dll_entry array)\n-    : frag =\n-\n-  let form_dir_entry\n-      (entry:pe_import_dll_entry)\n-      : frag =\n-    SEQ [|\n-      (* Note: documented opinions vary greatly about whether the\n-         first, last, or both of the slots in one of these rows points\n-         to the RVA of the name/hint used to look the import up. This\n-         table format is a mess!  *)\n-      WORD (TY_u32,\n-            (rva\n-               entry.pe_import_dll_ILT_fixup)); (* Import lookup table. *)\n-      WORD (TY_u32, (IMM 0L));                  (* Timestamp, unused.   *)\n-      WORD (TY_u32, (IMM 0x0L));                (* Forwarder chain, unused. *)\n-      WORD (TY_u32, (rva entry.pe_import_dll_name_fixup));\n-      WORD (TY_u32,\n-            (rva\n-               entry.pe_import_dll_IAT_fixup)); (* Import address table.*)\n-    |]\n-  in\n-\n-  let form_ILT_slot\n-      (import:pe_import)\n-      : frag =\n-    (WORD (TY_u32, (rva import.pe_import_name_fixup)))\n-  in\n-\n-  let form_IAT_slot\n-      (import:pe_import)\n-      : frag =\n-    (DEF (import.pe_import_address_fixup,\n-          (WORD (TY_u32, (rva import.pe_import_name_fixup)))))\n-  in\n-\n-  let form_tables_for_dll\n-      (dll:pe_import_dll_entry)\n-      : frag =\n-    let terminator = WORD (TY_u32, (IMM 0L)) in\n-    let ilt =\n-      SEQ [|\n-        SEQ (Array.map form_ILT_slot dll.pe_import_dll_imports);\n-        terminator\n-      |]\n-    in\n-    let iat =\n-      SEQ [|\n-        SEQ (Array.map form_IAT_slot dll.pe_import_dll_imports);\n-        terminator\n-      |]\n-    in\n-      if Array.length dll.pe_import_dll_imports < 1\n-      then bug () \"Pe.form_tables_for_dll: empty imports\"\n-      else\n-        SEQ [|\n-          DEF (dll.pe_import_dll_ILT_fixup, ilt);\n-          DEF (dll.pe_import_dll_IAT_fixup, iat)\n-        |]\n-\n-  in\n-\n-  let form_import_string\n-      (import:pe_import)\n-      : frag =\n-    DEF\n-      (import.pe_import_name_fixup,\n-       SEQ [|\n-         (* import string entries begin with a 2-byte \"hint\", but we just\n-            set it to zero.  *)\n-         (WORD (TY_u16, (IMM 0L)));\n-         ZSTRING import.pe_import_name;\n-         (if String.length import.pe_import_name mod 2 == 0\n-          then PAD 1\n-          else PAD 0)\n-       |])\n-  in\n-\n-  let form_dir_entry_string\n-      (dll:pe_import_dll_entry)\n-      : frag =\n-    DEF\n-      (dll.pe_import_dll_name_fixup,\n-       SEQ [| ZSTRING dll.pe_import_dll_name;\n-              (if String.length dll.pe_import_dll_name mod 2 == 0\n-               then PAD 1\n-               else PAD 0);\n-              SEQ (Array.map form_import_string dll.pe_import_dll_imports) |])\n-  in\n-\n-  let dir = SEQ (Array.map form_dir_entry dlls) in\n-  let dir_terminator = PAD 20 in\n-  let tables = SEQ (Array.map form_tables_for_dll dlls) in\n-  let strings = SEQ (Array.map form_dir_entry_string dlls)\n-  in\n-    def_aligned\n-      import_dir_fixup\n-      (SEQ\n-         [|\n-           dir;\n-           dir_terminator;\n-           tables;\n-           strings\n-         |])\n-\n-;;\n-\n-type pe_export =\n-    {\n-      pe_export_name_fixup: fixup;\n-      pe_export_name: string;\n-      pe_export_address_fixup: fixup;\n-    }\n-;;\n-\n-let pe_export_section\n-    ~(sess:Session.sess)\n-    ~(export_dir_fixup:fixup)\n-    ~(exports:pe_export array)\n-    : frag =\n-  Array.sort (fun a b -> compare a.pe_export_name b.pe_export_name) exports;\n-  let export_addr_table_fixup = new_fixup \"export address table\" in\n-  let export_addr_table =\n-    DEF\n-      (export_addr_table_fixup,\n-       SEQ\n-         (Array.map\n-            (fun e -> (WORD (TY_u32, rva e.pe_export_address_fixup)))\n-            exports))\n-  in\n-  let export_name_pointer_table_fixup =\n-      new_fixup \"export name pointer table\"\n-  in\n-  let export_name_pointer_table =\n-    DEF\n-      (export_name_pointer_table_fixup,\n-       SEQ\n-         (Array.map\n-            (fun e -> (WORD (TY_u32, rva e.pe_export_name_fixup)))\n-            exports))\n-  in\n-  let export_name_table_fixup = new_fixup \"export name table\" in\n-  let export_name_table =\n-    DEF\n-      (export_name_table_fixup,\n-       SEQ\n-         (Array.map\n-            (fun e -> (DEF (e.pe_export_name_fixup,\n-                            (ZSTRING e.pe_export_name))))\n-            exports))\n-  in\n-  let export_ordinal_table_fixup = new_fixup \"export ordinal table\" in\n-  let export_ordinal_table =\n-    DEF\n-      (export_ordinal_table_fixup,\n-       SEQ\n-         (Array.mapi\n-            (fun i _ -> (WORD (TY_u16, IMM (Int64.of_int (i)))))\n-            exports))\n-  in\n-  let image_name_fixup = new_fixup \"image name fixup\" in\n-  let n_exports = IMM (Int64.of_int (Array.length exports)) in\n-  let export_dir_table =\n-    SEQ [|\n-      WORD (TY_u32, IMM 0L);               (* Flags, reserved.    *)\n-      WORD (TY_u32, IMM 0L);               (* Timestamp, unused.  *)\n-      WORD (TY_u16, IMM 0L);               (* Major vers., unused *)\n-      WORD (TY_u16, IMM 0L);               (* Minor vers., unused *)\n-      WORD (TY_u32, rva image_name_fixup); (* Name RVA.           *)\n-      WORD (TY_u32, IMM 1L);               (* Ordinal base = 1.   *)\n-      WORD (TY_u32, n_exports);          (* # entries in EAT.     *)\n-      WORD (TY_u32, n_exports);          (* # entries in ENPT/EOT.*)\n-      WORD (TY_u32, rva export_addr_table_fixup);         (* EAT  *)\n-      WORD (TY_u32, rva export_name_pointer_table_fixup); (* ENPT *)\n-      WORD (TY_u32, rva export_ordinal_table_fixup);      (* EOT  *)\n-    |]\n-  in\n-    def_aligned export_dir_fixup\n-      (SEQ [|\n-         export_dir_table;\n-         export_addr_table;\n-         export_name_pointer_table;\n-         export_ordinal_table;\n-         DEF (image_name_fixup,\n-              ZSTRING (Session.filename_of sess.Session.sess_out));\n-         export_name_table\n-       |])\n-;;\n-\n-let pe_text_section\n-    ~(sess:Session.sess)\n-    ~(sem:Semant.ctxt)\n-    ~(start_fixup:fixup option)\n-    ~(rust_start_fixup:fixup option)\n-    ~(main_fn_fixup:fixup option)\n-    ~(text_fixup:fixup)\n-    ~(crate_code:frag)\n-    : frag =\n-  let startup =\n-    match (start_fixup, rust_start_fixup, main_fn_fixup) with\n-        (None, _, _)\n-      | (_, None, _)\n-      | (_, _, None) -> MARK\n-      | (Some start_fixup,\n-         Some rust_start_fixup,\n-         Some main_fn_fixup) ->\n-          let e = X86.new_emitter_without_vregs () in\n-            (*\n-             * We are called from the Microsoft C library startup routine,\n-             * and assumed to be stdcall; so we have to clean up our own\n-             * stack before returning.\n-             *)\n-            X86.objfile_start e\n-              ~start_fixup\n-              ~rust_start_fixup\n-              ~main_fn_fixup\n-              ~crate_fixup: sem.Semant.ctxt_crate_fixup\n-              ~indirect_start: true;\n-            X86.frags_of_emitted_quads sess e;\n-  in\n-    def_aligned\n-      text_fixup\n-      (SEQ [|\n-         startup;\n-         crate_code\n-       |])\n-;;\n-\n-let rustrt_imports sem =\n-  let make_imports_for_lib (lib, tab) =\n-    {\n-      pe_import_dll_name_fixup = new_fixup \"dll name\";\n-      pe_import_dll_name = (match lib with\n-                                REQUIRED_LIB_rustrt -> \"rustrt.dll\"\n-                              | REQUIRED_LIB_crt -> \"msvcrt.dll\"\n-                              | REQUIRED_LIB_rust ls\n-                              | REQUIRED_LIB_c ls -> ls.required_libname);\n-      pe_import_dll_ILT_fixup = new_fixup \"dll ILT\";\n-      pe_import_dll_IAT_fixup = new_fixup \"dll IAT\";\n-      pe_import_dll_imports =\n-        Array.of_list\n-          (List.map\n-             begin\n-               fun (name, fixup) ->\n-                 {\n-                   pe_import_name_fixup = new_fixup \"import name\";\n-                   pe_import_name = name;\n-                   pe_import_address_fixup = fixup;\n-                 }\n-             end\n-             (htab_pairs tab))\n-    }\n-  in\n-    Array.of_list\n-      (List.map\n-         make_imports_for_lib\n-         (htab_pairs sem.Semant.ctxt_native_required))\n-;;\n-\n-\n-let crate_exports (sem:Semant.ctxt) : pe_export array =\n-  let export_sym (name, fixup) =\n-    {\n-      pe_export_name_fixup = new_fixup \"export name fixup\";\n-      pe_export_name = name;\n-      pe_export_address_fixup = fixup;\n-    }\n-  in\n-  let export_seg (_, tab) =\n-    Array.of_list (List.map export_sym (htab_pairs tab))\n-  in\n-\n-  (* Make some fake symbol table entries to aid in debugging. *)\n-  let export_stab name fixup =\n-    {\n-      pe_export_name_fixup = new_fixup \"export name fixup\";\n-      pe_export_name = \"rust$\" ^ name;\n-      pe_export_address_fixup = fixup\n-    }\n-  in\n-  let export_stab_of_item (node_id, code) =\n-    let name = Hashtbl.find sem.Semant.ctxt_all_item_names node_id in\n-    let name' = \"item$\" ^ (Semant.string_of_name name) in\n-    export_stab name' code.Semant.code_fixup\n-  in\n-  let export_stab_of_glue (glue, code) =\n-    export_stab (Semant.glue_str sem glue) code.Semant.code_fixup\n-  in\n-\n-  let stabs =\n-    Array.of_list (List.concat [\n-      (List.map export_stab_of_item\n-        (htab_pairs sem.Semant.ctxt_all_item_code));\n-      (List.map export_stab_of_glue (htab_pairs sem.Semant.ctxt_glue_code))\n-    ])\n-  in\n-\n-    Array.concat\n-      (stabs::(List.map export_seg\n-         (htab_pairs sem.Semant.ctxt_native_provided)))\n-;;\n-\n-\n-let emit_file\n-    (sess:Session.sess)\n-    (crate:Ast.crate)\n-    (code:Asm.frag)\n-    (data:Asm.frag)\n-    (sem:Semant.ctxt)\n-    (dw:Dwarf.debug_records)\n-    : unit =\n-\n-  let all_hdrs_fixup = new_fixup \"all headers\" in\n-  let all_init_data_fixup = new_fixup \"all initialized data\" in\n-  let loader_hdr_fixup = new_fixup \"loader header\" in\n-  let import_dir_fixup = new_fixup \"import directory\" in\n-  let export_dir_fixup = new_fixup \"export directory\" in\n-  let text_fixup = new_fixup \"text section\" in\n-  let bss_fixup = new_fixup \"bss section\" in\n-  let data_fixup = new_fixup \"data section\" in\n-  let image_fixup = new_fixup \"image fixup\" in\n-  let symtab_fixup = new_fixup \"symbol table\" in\n-  let strtab_fixup = new_fixup \"string table\" in\n-  let note_rust_fixup = new_fixup \".note.rust section\" in\n-\n-  let (start_fixup, rust_start_fixup) =\n-    if sess.Session.sess_library_mode\n-    then (None, None)\n-    else\n-      (Some (new_fixup \"start\"),\n-       Some (Semant.require_native sem REQUIRED_LIB_rustrt \"rust_start\"))\n-  in\n-\n-  let header = (pe_header\n-                  ~machine: IMAGE_FILE_MACHINE_I386\n-                  ~symbol_table_fixup: symtab_fixup\n-                  ~number_of_sections: 8L\n-                  ~number_of_symbols: 0L\n-                  ~loader_hdr_fixup: loader_hdr_fixup\n-                  ~characteristics:([IMAGE_FILE_EXECUTABLE_IMAGE;\n-                                    IMAGE_FILE_LINE_NUMS_STRIPPED;\n-                                    IMAGE_FILE_32BIT_MACHINE;]\n-                                    @\n-                                    (if sess.Session.sess_library_mode\n-                                     then [ IMAGE_FILE_DLL ]\n-                                     else [ ])))\n-  in\n-  let symtab =\n-    (* \n-     * We're not actually presenting a \"symbol table\", but wish to\n-     * provide a \"string table\" which comes immediately *after* the\n-     * symbol table. It's a violation of the PE spec to put one of\n-     * these in an executable file (as opposed to just loadable) but\n-     * it's necessary to communicate the debug section names to GDB,\n-     * and nobody else complains.  \n-     *)\n-    (def_aligned\n-       symtab_fixup\n-       (def_aligned\n-          strtab_fixup\n-          (SEQ\n-             [|\n-               WORD (TY_u32, (F_SZ strtab_fixup));\n-               ZSTRING \".debug_aranges\";\n-               ZSTRING \".debug_pubnames\";\n-               ZSTRING \".debug_info\";\n-               ZSTRING \".debug_abbrev\";\n-               ZSTRING \".debug_line\";\n-               ZSTRING \".debug_frame\";\n-               ZSTRING \".note.rust\";\n-             |])))\n-  in\n-  let loader_header = (pe_loader_header\n-                         ~text_fixup\n-                         ~init_data_fixup: all_init_data_fixup\n-                         ~size_of_uninit_data: 0L\n-                         ~entry_point_fixup: start_fixup\n-                         ~image_fixup: image_fixup\n-                         ~subsys: IMAGE_SUBSYSTEM_WINDOWS_CUI\n-                         ~all_hdrs_fixup\n-                         ~loader_hdr_fixup\n-                         ~import_dir_fixup\n-                         ~export_dir_fixup)\n-  in\n-  let text_header = (pe_section_header\n-                       ~id: SECTION_ID_TEXT\n-                       ~hdr_fixup: text_fixup)\n-\n-  in\n-  let bss_header = (pe_section_header\n-                      ~id: SECTION_ID_BSS\n-                      ~hdr_fixup: bss_fixup)\n-  in\n-  let import_section = (pe_import_section\n-                          ~import_dir_fixup\n-                          ~dlls: (rustrt_imports sem))\n-  in\n-  let import_header = (pe_section_header\n-                         ~id: SECTION_ID_IMPORTS\n-                         ~hdr_fixup: import_dir_fixup)\n-  in\n-  let export_section = (pe_export_section\n-                          ~sess\n-                          ~export_dir_fixup\n-                          ~exports: (crate_exports sem))\n-  in\n-  let export_header = (pe_section_header\n-                         ~id: SECTION_ID_EXPORTS\n-                         ~hdr_fixup: export_dir_fixup)\n-  in\n-  let data_header = (pe_section_header\n-                       ~id: SECTION_ID_DATA\n-                       ~hdr_fixup: data_fixup)\n-  in\n-(*\n-  let debug_aranges_header =\n-    (pe_section_header\n-      ~id: SECTION_ID_DEBUG_ARANGES\n-      ~hdr_fixup: sem.Semant.ctxt_debug_aranges_fixup)\n-  in\n-  let debug_pubnames_header =\n-    (pe_section_header\n-      ~id: SECTION_ID_DEBUG_PUBNAMES\n-      ~hdr_fixup: sem.Semant.ctxt_debug_pubnames_fixup)\n-  in\n-*)\n-  let debug_info_header = (pe_section_header\n-                             ~id: SECTION_ID_DEBUG_INFO\n-                             ~hdr_fixup: sem.Semant.ctxt_debug_info_fixup)\n-  in\n-  let debug_abbrev_header = (pe_section_header\n-                               ~id: SECTION_ID_DEBUG_ABBREV\n-                               ~hdr_fixup: sem.Semant.ctxt_debug_abbrev_fixup)\n-  in\n-(*\n-  let debug_line_header =\n-    (pe_section_header\n-      ~id: SECTION_ID_DEBUG_LINE\n-      ~hdr_fixup: sem.Semant.ctxt_debug_line_fixup)\n-  in\n-  let debug_frame_header =\n-    (pe_section_header\n-      ~id: SECTION_ID_DEBUG_FRAME\n-      ~hdr_fixup: sem.Semant.ctxt_debug_frame_fixup)\n-  in\n-*)\n-  let note_rust_header = (pe_section_header\n-                            ~id: SECTION_ID_NOTE_RUST\n-                            ~hdr_fixup: note_rust_fixup)\n-  in\n-  let all_headers = (def_file_aligned\n-                       all_hdrs_fixup\n-                       (SEQ\n-                          [|\n-                            pe_msdos_header_and_padding;\n-                            header;\n-                            loader_header;\n-                            text_header;\n-                            bss_header;\n-                            import_header;\n-                            export_header;\n-                            data_header;\n-                            (*\n-                            debug_aranges_header;\n-                            debug_pubnames_header;\n-                            *)\n-                            debug_info_header;\n-                            debug_abbrev_header;\n-                            (*\n-                            debug_line_header;\n-                            debug_frame_header;\n-                            *)\n-                            note_rust_header;\n-                          |]))\n-  in\n-\n-  let text_section = (pe_text_section\n-                        ~sem\n-                        ~sess\n-                        ~start_fixup\n-                        ~rust_start_fixup\n-                        ~main_fn_fixup: sem.Semant.ctxt_main_fn_fixup\n-                        ~text_fixup\n-                        ~crate_code: code)\n-  in\n-  let bss_section = def_aligned bss_fixup (BSS 0x10L)\n-  in\n-  let data_section = (def_aligned data_fixup\n-                        (SEQ [| data; symtab; |]))\n-  in\n-  let all_init_data = (def_aligned\n-                         all_init_data_fixup\n-                         (SEQ [| import_section;\n-                                 export_section;\n-                                 data_section; |]))\n-  in\n-(*\n-  let debug_aranges_section =\n-    def_aligned sem.Semant.ctxt_debug_aranges_fixup dw.Dwarf.debug_aranges\n-  in\n-  let debug_pubnames_section =\n-    def_aligned sem.Semant.ctxt_debug_pubnames_fixup dw.Dwarf.debug_pubnames\n-  in\n-*)\n-  let debug_info_section =\n-    def_aligned sem.Semant.ctxt_debug_info_fixup dw.Dwarf.debug_info\n-  in\n-  let debug_abbrev_section =\n-    def_aligned sem.Semant.ctxt_debug_abbrev_fixup dw.Dwarf.debug_abbrev\n-  in\n-(*\n-  let debug_line_section =\n-    def_aligned sem.Semant.ctxt_debug_line_fixup dw.Dwarf.debug_line\n-  in\n-  let debug_frame_section =\n-    def_aligned sem.Semant.ctxt_debug_frame_fixup dw.Dwarf.debug_frame\n-  in\n-*)\n-  let note_rust_section =\n-    def_aligned note_rust_fixup\n-      (Asm.note_rust_frags crate.node.Ast.crate_meta)\n-  in\n-\n-  let all_frags = SEQ [| MEMPOS pe_image_base;\n-                         (def_file_aligned image_fixup\n-                            (SEQ [| DEF (sem.Semant.ctxt_image_base_fixup,\n-                                         MARK);\n-                                    all_headers;\n-                                    text_section;\n-                                    bss_section;\n-                                    all_init_data;\n-                                    (* debug_aranges_section; *)\n-                                    (* debug_pubnames_section; *)\n-                                    debug_info_section;\n-                                    debug_abbrev_section;\n-                                    (* debug_line_section; *)\n-                                    (* debug_frame_section; *)\n-                                    note_rust_section;\n-                                    ALIGN_MEM (pe_mem_alignment, MARK)\n-                                 |]\n-                            )\n-                         )\n-                      |]\n-  in\n-    write_out_frag sess true all_frags\n-;;\n-\n-let pe_magic = \"PE\";;\n-\n-let sniff\n-    (sess:Session.sess)\n-    (filename:filename)\n-    : asm_reader option =\n-  try\n-    let stat = Unix.stat filename in\n-    if (stat.Unix.st_kind = Unix.S_REG) &&\n-      (stat.Unix.st_size >= pe_file_alignment)\n-    then\n-      let ar = new_asm_reader sess filename in\n-      let _ = log sess \"sniffing PE file\" in\n-        (* PE header offset is at 0x3c in the MS-DOS compatibility header. *)\n-      let _ = ar.asm_seek 0x3c in\n-      let pe_hdr_off = ar.asm_get_u32() in\n-      let _ = log sess \"PE header offset: 0x%x\" pe_hdr_off in\n-\n-      let _ = ar.asm_seek pe_hdr_off in\n-      let pe_signature = ar.asm_get_zstr_padded 4 in\n-      let _ = log sess \"    PE signature: '%s'\" pe_signature in\n-        if pe_signature = pe_magic\n-        then (ar.asm_seek 0; Some ar)\n-        else None\n-    else\n-      None\n-  with\n-      _ -> None\n-;;\n-\n-\n-let get_sections\n-    (sess:Session.sess)\n-    (ar:asm_reader)\n-    : (string,(int*int)) Hashtbl.t =\n-  let _ = log sess \"reading sections\" in\n-  (* PE header offset is at 0x3c in the MS-DOS compatibility header. *)\n-  let _ = ar.asm_seek 0x3c in\n-  let pe_hdr_off = ar.asm_get_u32() in\n-  let _ = log sess \"PE header offset: 0x%x\" pe_hdr_off in\n-\n-  let _ = ar.asm_seek pe_hdr_off in\n-  let pe_signature = ar.asm_get_zstr_padded 4 in\n-  let _ = log sess \"    PE signature: '%s'\" pe_signature in\n-  let _ = assert (pe_signature = pe_magic) in\n-  let _ = ar.asm_adv_u16() in (* machine type *)\n-\n-  let num_sections = ar.asm_get_u16() in\n-  let _ = log sess \"    num sections: %d\" num_sections in\n-\n-  let _ = ar.asm_adv_u32() in (* timestamp *)\n-\n-  let symtab_off = ar.asm_get_u32() in\n-  let _ = log sess \"   symtab offset: 0x%x\" symtab_off in\n-\n-  let num_symbols = ar.asm_get_u32() in\n-  let _ = log sess \"     num symbols: %d\" num_symbols in\n-\n-  let loader_hdr_size = ar.asm_get_u16() in\n-  let _ = log sess \"loader header sz: %d\" loader_hdr_size in\n-\n-  let _ = ar.asm_adv_u16() in (* flags *)\n-  let sections_off = (ar.asm_get_off()) + loader_hdr_size in\n-\n-  let sects = Hashtbl.create 0 in\n-\n-  let _ =\n-    ar.asm_seek sections_off;\n-    for i = 0 to (num_sections - 1) do\n-      (* \n-       * Section-name encoding is crazy. ASCII-encoding offsets of\n-       * long names. See pe_section_header for details.\n-       *)\n-      let sect_name =\n-        let sect_name = ar.asm_get_zstr_padded 8 in\n-          assert ((String.length sect_name) > 0);\n-          if sect_name.[0] = '/'\n-          then\n-            let off_str =\n-              String.sub sect_name 1 ((String.length sect_name) - 1)\n-            in\n-            let i = int_of_string off_str in\n-            let curr = ar.asm_get_off() in\n-              ar.asm_seek (symtab_off + i);\n-              let ext_name = ar.asm_get_zstr() in\n-                ar.asm_seek curr;\n-                ext_name\n-          else\n-            sect_name\n-      in\n-      let _ = ar.asm_adv_u32() in (* virtual size *)\n-      let _ = ar.asm_adv_u32() in (* virtual address *)\n-      let file_sz = ar.asm_get_u32() in\n-      let file_off = ar.asm_get_u32() in\n-      let _ = ar.asm_adv_u32() in (* reserved *)\n-      let _ = ar.asm_adv_u32() in (* reserved *)\n-      let _ = ar.asm_adv_u32() in (* reserved *)\n-      let _ = ar.asm_adv_u32() in (* flags *)\n-        Hashtbl.add sects sect_name (file_off, file_sz);\n-        log sess \"       section %d: %s, size %d, offset 0x%x\"\n-          i sect_name file_sz file_off;\n-    done\n-  in\n-    sects\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "dca2c0b64eaaa7d016ad69cb0b4d3f3c781f6b38", "filename": "src/boot/be/ra.ml", "status": "removed", "additions": 0, "deletions": 688, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fra.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fra.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fra.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,688 +0,0 @@\n-open Il;;\n-open Common;;\n-\n-type ctxt =\n-    {\n-      ctxt_sess: Session.sess;\n-      ctxt_n_vregs: int;\n-      ctxt_abi: Abi.abi;\n-      mutable ctxt_quads: Il.quads;\n-      mutable ctxt_next_spill: int;\n-      mutable ctxt_next_label: int;\n-      (* More state as necessary. *)\n-    }\n-;;\n-\n-let new_ctxt\n-    (sess:Session.sess)\n-    (quads:Il.quads)\n-    (vregs:int)\n-    (abi:Abi.abi)\n-    : ctxt =\n-  {\n-    ctxt_sess = sess;\n-    ctxt_quads = quads;\n-    ctxt_n_vregs = vregs;\n-    ctxt_abi = abi;\n-    ctxt_next_spill = 0;\n-    ctxt_next_label = 0;\n-  }\n-;;\n-\n-let log (cx:ctxt) =\n-  Session.log \"ra\"\n-    cx.ctxt_sess.Session.sess_log_ra\n-    cx.ctxt_sess.Session.sess_log_out\n-;;\n-\n-let iflog (cx:ctxt) (thunk:(unit -> unit)) : unit =\n-  if cx.ctxt_sess.Session.sess_log_ra\n-  then thunk ()\n-  else ()\n-;;\n-\n-let list_to_str list eltstr =\n-  (String.concat \",\" (List.map eltstr (List.sort compare list)))\n-;;\n-\n-let next_spill (cx:ctxt) : int =\n-  let i = cx.ctxt_next_spill in\n-    cx.ctxt_next_spill <- i + 1;\n-    i\n-;;\n-\n-let next_label (cx:ctxt) : string =\n-  let i = cx.ctxt_next_label in\n-    cx.ctxt_next_label <- i + 1;\n-    (\".L\" ^ (string_of_int i))\n-;;\n-\n-exception Ra_error of string ;;\n-\n-let convert_labels (cx:ctxt) : unit =\n-  let quad_fixups = Array.map (fun q -> q.quad_fixup) cx.ctxt_quads in\n-  let qp_code (_:Il.quad_processor) (c:Il.code) : Il.code =\n-    match c with\n-        Il.CodeLabel lab ->\n-          let fix =\n-            match quad_fixups.(lab) with\n-                None ->\n-                  let fix = new_fixup (next_label cx) in\n-                    begin\n-                      quad_fixups.(lab) <- Some fix;\n-                      fix\n-                    end\n-              | Some f -> f\n-          in\n-            Il.CodePtr (Il.ImmPtr (fix, Il.CodeTy))\n-      | _ -> c\n-  in\n-  let qp = { Il.identity_processor\n-             with Il.qp_code = qp_code }\n-  in\n-    Il.rewrite_quads qp cx.ctxt_quads;\n-    Array.iteri (fun i fix ->\n-                   cx.ctxt_quads.(i) <- { cx.ctxt_quads.(i) with\n-                                            Il.quad_fixup = fix })\n-      quad_fixups;\n-;;\n-\n-let convert_pre_spills\n-    (cx:ctxt)\n-    (mkspill:(Il.spill -> Il.mem))\n-    : int =\n-  let n = ref 0 in\n-  let qp_mem (_:Il.quad_processor) (a:Il.mem) : Il.mem =\n-    match a with\n-        Il.Spill i ->\n-          begin\n-            if i+1 > (!n)\n-            then n := i+1;\n-            mkspill i\n-          end\n-      | _ -> a\n-  in\n-  let qp = Il.identity_processor in\n-  let qp = { qp with\n-               Il.qp_mem = qp_mem  }\n-  in\n-    begin\n-      Il.rewrite_quads qp cx.ctxt_quads;\n-      !n\n-    end\n-;;\n-\n-let kill_quad (i:int) (cx:ctxt) : unit =\n-  cx.ctxt_quads.(i) <-\n-    { Il.deadq with\n-        Il.quad_fixup = cx.ctxt_quads.(i).Il.quad_fixup }\n-;;\n-\n-let kill_redundant_moves (cx:ctxt) : unit =\n-  let process_quad i q =\n-    match q.Il.quad_body with\n-        Il.Unary u when\n-          ((Il.is_mov u.Il.unary_op) &&\n-             (Il.Cell u.Il.unary_dst) = u.Il.unary_src) ->\n-            kill_quad i cx\n-      | _ -> ()\n-  in\n-    Array.iteri process_quad cx.ctxt_quads\n-;;\n-\n-let quad_jump_target_labels (q:quad) : Il.label list =\n-  match q.Il.quad_body with\n-      Il.Jmp jmp ->\n-        begin\n-          match jmp.Il.jmp_targ with\n-              Il.CodeLabel lab  -> [ lab ]\n-            | _ -> []\n-        end\n-    | _ -> []\n-;;\n-\n-let quad_used_vregs (q:quad) : Il.vreg list =\n-  let vregs = ref [] in\n-  let qp_reg _ r =\n-    match r with\n-        Il.Vreg v -> (vregs := (v :: (!vregs)); r)\n-      | _ -> r\n-  in\n-  let qp_cell_write qp c =\n-    match c with\n-        Il.Reg _ -> c\n-      | Il.Mem (a, b) -> Il.Mem (qp.qp_mem qp a, b)\n-  in\n-  let qp = { Il.identity_processor with\n-               Il.qp_reg = qp_reg;\n-               Il.qp_cell_write = qp_cell_write }\n-  in\n-    ignore (Il.process_quad qp q);\n-    !vregs\n-;;\n-\n-let quad_defined_vregs (q:quad) : Il.vreg list =\n-  let vregs = ref [] in\n-  let qp_cell_write _ c =\n-    match c with\n-        Il.Reg (Il.Vreg v, _) -> (vregs := (v :: (!vregs)); c)\n-      | _ -> c\n-  in\n-  let qp = { Il.identity_processor with\n-               Il.qp_cell_write = qp_cell_write }\n-  in\n-    ignore (Il.process_quad qp q);\n-    !vregs\n-;;\n-\n-let quad_is_unconditional_jump (q:quad) : bool =\n-  match q.Il.quad_body with\n-      Il.Jmp { jmp_op = Il.JMP; jmp_targ = _ } -> true\n-    | Il.Ret -> true\n-    | _ -> false\n-;;\n-\n-let calculate_live_bitvectors\n-    (cx:ctxt)\n-    : ((Bits.t array) * (Bits.t array)) =\n-\n-  iflog cx (fun _ -> log cx \"calculating live bitvectors\");\n-\n-  let quads = cx.ctxt_quads in\n-  let n_quads = Array.length quads in\n-  let n_vregs = cx.ctxt_n_vregs in\n-  let new_bitv _ = Bits.create n_vregs false in\n-  let new_true_bitv _ = Bits.create n_vregs true in\n-  let (live_in_vregs:Bits.t array) = Array.init n_quads new_bitv in\n-  let (live_out_vregs:Bits.t array) = Array.init n_quads new_bitv in\n-\n-  let (quad_used_vrs:Bits.t array) = Array.init n_quads new_bitv in\n-  let (quad_not_defined_vrs:Bits.t array) =\n-    Array.init n_quads new_true_bitv\n-  in\n-  let (quad_uncond_jmp:bool array) = Array.make n_quads false in\n-  let (quad_jmp_targs:(Il.label list) array) = Array.make n_quads [] in\n-\n-  (* Working bit-vector. *)\n-  let scratch = new_bitv() in\n-  let changed = ref true in\n-\n-  (* bit-vector helpers. *)\n-    (* Setup pass. *)\n-    for i = 0 to n_quads - 1 do\n-      let q = quads.(i) in\n-        quad_uncond_jmp.(i) <- quad_is_unconditional_jump q;\n-        quad_jmp_targs.(i) <- quad_jump_target_labels q;\n-        List.iter\n-          (fun v -> Bits.set quad_used_vrs.(i) v true)\n-          (quad_used_vregs q);\n-        List.iter\n-          (fun v -> Bits.set quad_not_defined_vrs.(i) v false)\n-          (quad_defined_vregs q);\n-    done;\n-\n-    while !changed do\n-      changed := false;\n-      iflog cx\n-        (fun _ ->\n-           log cx \"iterating inner bitvector calculation over %d quads\"\n-             n_quads);\n-      for i = n_quads - 1 downto 0 do\n-\n-        let note_change b = if b then changed := true in\n-        let live_in = live_in_vregs.(i) in\n-        let live_out = live_out_vregs.(i) in\n-        let used = quad_used_vrs.(i) in\n-        let not_defined = quad_not_defined_vrs.(i) in\n-\n-          (* Union in the vregs we use. *)\n-          note_change (Bits.union live_in used);\n-\n-          (* Union in all our jump targets. *)\n-          List.iter\n-            (fun i -> note_change (Bits.union live_out live_in_vregs.(i)))\n-            (quad_jmp_targs.(i));\n-\n-          (* Union in our block successor if we have one *)\n-          if i < (n_quads - 1) && (not (quad_uncond_jmp.(i)))\n-          then note_change (Bits.union live_out live_in_vregs.(i+1));\n-\n-          (* Propagate live-out to live-in on anything we don't define. *)\n-          ignore (Bits.copy scratch not_defined);\n-          ignore (Bits.intersect scratch live_out);\n-          note_change (Bits.union live_in scratch);\n-\n-      done;\n-    done;\n-    iflog cx\n-      begin\n-        fun _ ->\n-          log cx \"finished calculating live bitvectors\";\n-          log cx \"=========================\";\n-          for q = 0 to n_quads - 1 do\n-            let buf = Buffer.create 128 in\n-              for v = 0 to (n_vregs - 1)\n-              do\n-                if ((Bits.get live_in_vregs.(q) v)\n-                    && (Bits.get live_out_vregs.(q) v))\n-                then Printf.bprintf buf \" %-2d\" v\n-                else Buffer.add_string buf \"   \"\n-              done;\n-              log cx \"[%6d] live vregs: %s\" q (Buffer.contents buf)\n-          done;\n-          log cx \"=========================\"\n-      end;\n-    (live_in_vregs, live_out_vregs)\n-;;\n-\n-\n-let is_end_of_basic_block (q:quad) : bool =\n-  match q.Il.quad_body with\n-      Il.Jmp _ -> true\n-    | Il.Ret -> true\n-    | _ -> false\n-;;\n-\n-let is_beginning_of_basic_block (q:quad) : bool =\n-  match q.Il.quad_fixup with\n-      None -> false\n-    | Some _ -> true\n-;;\n-\n-let dump_quads cx =\n-  let f = cx.ctxt_abi.Abi.abi_str_of_hardreg in\n-  let len = (Array.length cx.ctxt_quads) - 1 in\n-  let ndigits_of n = (int_of_float (log10 (float_of_int n))) in\n-  let padded_num n maxnum =\n-    let ndigits = ndigits_of n in\n-    let maxdigits = ndigits_of maxnum in\n-    let pad = String.make (maxdigits - ndigits) ' ' in\n-      Printf.sprintf \"%s%d\" pad n\n-  in\n-  let padded_str str maxlen =\n-    let pad = String.make (maxlen - (String.length str)) ' ' in\n-      Printf.sprintf \"%s%s\" pad str\n-  in\n-  let maxlablen = ref 0 in\n-  for i = 0 to len\n-  do\n-    let q = cx.ctxt_quads.(i) in\n-    match q.quad_fixup with\n-        None -> ()\n-      | Some f ->\n-          maxlablen := max (!maxlablen) ((String.length f.fixup_name) + 1)\n-  done;\n-  for i = 0 to len\n-  do\n-    let q = cx.ctxt_quads.(i) in\n-    let qs = (string_of_quad f q) in\n-    let lab = match q.quad_fixup with\n-        None -> \"\"\n-      | Some f -> f.fixup_name ^ \":\"\n-    in\n-      iflog cx\n-        (fun _ ->\n-           log cx \"[%s] %s %s\"\n-             (padded_num i len) (padded_str lab (!maxlablen)) qs)\n-  done\n-;;\n-\n-let calculate_vreg_constraints\n-    (cx:ctxt)\n-    (constraints:(Il.vreg,Bits.t) Hashtbl.t)\n-    (q:quad)\n-    : unit =\n-  let abi = cx.ctxt_abi in\n-    Hashtbl.clear constraints;\n-    abi.Abi.abi_constrain_vregs q constraints;\n-    iflog cx\n-      begin\n-        fun _ ->\n-          let hr_str = cx.ctxt_abi.Abi.abi_str_of_hardreg in\n-            log cx \"constraints for quad %s\"\n-              (string_of_quad hr_str q);\n-            let qp_reg _ r =\n-              begin\n-                match r with\n-                    Il.Hreg _ -> ()\n-                  | Il.Vreg v ->\n-                      match htab_search constraints v with\n-                          None -> log cx \"<v%d> unconstrained\" v\n-                        | Some c ->\n-                            let hregs = Bits.to_list c in\n-                              log cx \"<v%d> constrained to hregs: [%s]\"\n-                                v (list_to_str hregs hr_str)\n-              end;\n-              r\n-            in\n-              ignore (Il.process_quad { Il.identity_processor with\n-                                          Il.qp_reg = qp_reg } q)\n-      end\n-;;\n-\n-(* Simple local register allocator. Nothing fancy. *)\n-let reg_alloc\n-    (sess:Session.sess)\n-    (quads:Il.quads)\n-    (vregs:int)\n-    (abi:Abi.abi) =\n- try\n-    let cx = new_ctxt sess quads vregs abi in\n-    let _ =\n-      iflog cx\n-        begin\n-          fun _ ->\n-            log cx \"un-allocated quads:\";\n-            dump_quads cx\n-        end\n-    in\n-\n-    (* Work out pre-spilled slots and allocate 'em. *)\n-    let spill_slot (s:Il.spill) = abi.Abi.abi_spill_slot s in\n-    let n_pre_spills = convert_pre_spills cx spill_slot in\n-\n-    let (live_in_vregs, live_out_vregs) =\n-      calculate_live_bitvectors cx\n-    in\n-      (* vreg idx -> hreg bits.t *)\n-    let (vreg_constraints:(Il.vreg,Bits.t) Hashtbl.t) =\n-      Hashtbl.create 0\n-    in\n-    let inactive_hregs = ref [] in (* [hreg] *)\n-    let active_hregs = ref [] in (* [hreg] *)\n-    let dirty_vregs = Hashtbl.create 0 in (* vreg -> () *)\n-    let hreg_to_vreg = Hashtbl.create 0 in  (* hreg -> vreg *)\n-    let vreg_to_hreg = Hashtbl.create 0 in (* vreg -> hreg *)\n-    let vreg_to_spill = Hashtbl.create 0 in (* vreg -> spill *)\n-    let (word_ty:Il.scalar_ty) = Il.ValTy abi.Abi.abi_word_bits in\n-    let vreg_spill_cell v =\n-      Il.Mem ((spill_slot (Hashtbl.find vreg_to_spill v)),\n-              Il.ScalarTy word_ty)\n-    in\n-    let newq = ref [] in\n-    let fixup = ref None in\n-    let prepend q =\n-      newq := {q with quad_fixup = !fixup} :: (!newq);\n-      fixup := None\n-    in\n-    let hr h = Il.Reg (Il.Hreg h, Il.voidptr_t) in\n-    let hr_str = cx.ctxt_abi.Abi.abi_str_of_hardreg in\n-    let clean_hreg i hreg =\n-      if (Hashtbl.mem hreg_to_vreg hreg) &&\n-        (hreg < cx.ctxt_abi.Abi.abi_n_hardregs)\n-      then\n-        let vreg = Hashtbl.find hreg_to_vreg hreg in\n-          if Hashtbl.mem dirty_vregs vreg\n-          then\n-            begin\n-              Hashtbl.remove dirty_vregs vreg;\n-              if (Bits.get (live_out_vregs.(i)) vreg) ||\n-                (Bits.get (live_in_vregs.(i)) vreg)\n-              then\n-                let spill_idx =\n-                  if Hashtbl.mem vreg_to_spill vreg\n-                  then Hashtbl.find vreg_to_spill vreg\n-                  else\n-                    begin\n-                      let s = next_spill cx in\n-                        Hashtbl.replace vreg_to_spill vreg s;\n-                        s\n-                    end\n-                in\n-                let spill_mem = spill_slot spill_idx in\n-                let spill_cell = Il.Mem (spill_mem, Il.ScalarTy word_ty) in\n-                  iflog cx\n-                    (fun _ ->\n-                       log cx \"spilling <%d> from %s to %s\"\n-                         vreg (hr_str hreg) (string_of_mem\n-                                               hr_str spill_mem));\n-                  prepend (Il.mk_quad\n-                             (Il.umov spill_cell (Il.Cell (hr hreg))));\n-              else ()\n-            end\n-          else ()\n-      else ()\n-    in\n-\n-    let inactivate_hreg hreg =\n-      if (Hashtbl.mem hreg_to_vreg hreg) &&\n-        (hreg < cx.ctxt_abi.Abi.abi_n_hardregs)\n-      then\n-        let vreg = Hashtbl.find hreg_to_vreg hreg in\n-          Hashtbl.remove vreg_to_hreg vreg;\n-          Hashtbl.remove hreg_to_vreg hreg;\n-          active_hregs := List.filter (fun x -> x != hreg) (!active_hregs);\n-          inactive_hregs := hreg :: (!inactive_hregs);\n-      else ()\n-    in\n-\n-    let spill_specific_hreg i hreg =\n-      clean_hreg i hreg;\n-      inactivate_hreg hreg\n-    in\n-\n-    let rec select_constrained\n-        (constraints:Bits.t)\n-        (hregs:Il.hreg list)\n-        : Il.hreg option =\n-      match hregs with\n-          [] -> None\n-        | h::hs ->\n-            if Bits.get constraints h\n-            then Some h\n-            else select_constrained constraints hs\n-    in\n-\n-    let spill_constrained constrs i =\n-      match select_constrained constrs (!active_hregs) with\n-          None ->\n-            raise (Ra_error (\"unable to spill according to constraint\"));\n-        | Some h ->\n-            begin\n-              spill_specific_hreg i h;\n-              h\n-            end\n-    in\n-\n-    let all_hregs = Bits.create abi.Abi.abi_n_hardregs true in\n-\n-    let spill_all_regs i =\n-      while (!active_hregs) != []\n-      do\n-        let _ = spill_constrained all_hregs i in\n-          ()\n-      done\n-    in\n-\n-    let reload vreg hreg =\n-      if Hashtbl.mem vreg_to_spill vreg\n-      then\n-        prepend (Il.mk_quad\n-                   (Il.umov\n-                      (hr hreg)\n-                      (Il.Cell (vreg_spill_cell vreg))))\n-      else ()\n-    in\n-\n-    let get_vreg_constraints v =\n-      match htab_search vreg_constraints v with\n-          None -> all_hregs\n-        | Some c -> c\n-    in\n-\n-\n-    let use_vreg def i vreg =\n-      if Hashtbl.mem vreg_to_hreg vreg\n-      then\n-        begin\n-          let h = Hashtbl.find vreg_to_hreg vreg in\n-          iflog cx (fun _ -> log cx \"found cached assignment %s for <v%d>\"\n-                      (hr_str h) vreg);\n-            h\n-        end\n-      else\n-        let hreg =\n-          let constrs = get_vreg_constraints vreg in\n-            match select_constrained constrs (!inactive_hregs) with\n-                None ->\n-                  let h = spill_constrained constrs i in\n-                    iflog cx\n-                      (fun _ ->\n-                         log cx \"selected %s to spill and use for <v%d>\"\n-                         (hr_str h) vreg);\n-                    h\n-              | Some h ->\n-                  iflog cx (fun _ -> log cx \"selected inactive %s for <v%d>\"\n-                              (hr_str h) vreg);\n-                  h\n-        in\n-          inactive_hregs :=\n-            List.filter (fun x -> x != hreg) (!inactive_hregs);\n-          active_hregs := (!active_hregs) @ [hreg];\n-          Hashtbl.replace hreg_to_vreg hreg vreg;\n-          Hashtbl.replace vreg_to_hreg vreg hreg;\n-          if def\n-          then ()\n-          else\n-            reload vreg hreg;\n-          hreg\n-    in\n-    let qp_reg def i _ r =\n-      match r with\n-          Il.Hreg h -> (spill_specific_hreg i h; r)\n-        | Il.Vreg v -> (Il.Hreg (use_vreg def i v))\n-    in\n-    let qp_cell def i qp c =\n-      match c with\n-          Il.Reg (r, b) -> Il.Reg (qp_reg def i qp r, b)\n-        | Il.Mem  (a, b) ->\n-            let qp = { qp with Il.qp_reg = qp_reg false i } in\n-              Il.Mem (qp.qp_mem qp a, b)\n-    in\n-    let qp i = { Il.identity_processor with\n-                   Il.qp_cell_read = qp_cell false i;\n-                   Il.qp_cell_write = qp_cell true i;\n-                   Il.qp_reg = qp_reg false i }\n-    in\n-      cx.ctxt_next_spill <- n_pre_spills;\n-      convert_labels cx;\n-      for i = 0 to cx.ctxt_abi.Abi.abi_n_hardregs - 1\n-      do\n-        inactive_hregs := i :: (!inactive_hregs)\n-      done;\n-      for i = 0 to (Array.length cx.ctxt_quads) - 1\n-      do\n-        let quad = cx.ctxt_quads.(i) in\n-        let _ = calculate_vreg_constraints cx vreg_constraints quad in\n-        let clobbers = cx.ctxt_abi.Abi.abi_clobbers quad in\n-        let used = quad_used_vregs quad in\n-        let defined = quad_defined_vregs quad in\n-\n-          begin\n-\n-            (* If the quad has any nontrivial vreg constraints, regfence.\n-             * This is awful but it saves us from cached/constrained\n-             * interference as was found in issue #152. *)\n-            if List.exists\n-              (fun v -> not (Bits.equal (get_vreg_constraints v) all_hregs))\n-              used\n-            then\n-              begin\n-                (* Regfence. *)\n-                spill_all_regs i;\n-                (* Check for over-constrained-ness after any such regfence. *)\n-                let vreg_constrs v =\n-                  (v, Bits.to_list (get_vreg_constraints v))\n-                in\n-                let constrs = List.map vreg_constrs (used @ defined) in\n-                let constrs_collide (v1,c1) =\n-                  if List.length c1 <> 1\n-                  then false\n-                  else\n-                    List.exists\n-                      (fun (v2,c2) -> if v1 = v2 then false else c1 = c2)\n-                      constrs\n-                in\n-                  if List.exists constrs_collide constrs\n-                  then raise (Ra_error (\"over-constrained vregs\"));\n-              end;\n-\n-            if List.exists (fun def -> List.mem def clobbers) defined\n-            then raise (Ra_error (\"clobber and defined sets overlap\"));\n-            iflog cx\n-              begin\n-                fun _ ->\n-                  let hr (v:int) : string =\n-                    if Hashtbl.mem vreg_to_hreg v\n-                    then hr_str (Hashtbl.find vreg_to_hreg v)\n-                    else \"??\"\n-                  in\n-                  let vr_str (v:int) : string =\n-                    Printf.sprintf \"v%d=%s\" v (hr v)\n-                  in\n-                  let lstr lab ls fn =\n-                    if List.length ls = 0\n-                    then ()\n-                    else log cx \"\\t%s: [%s]\" lab (list_to_str ls fn)\n-                  in\n-                    log cx \"processing quad %d = %s\"\n-                      i (string_of_quad hr_str quad);\n-                    (lstr \"dirt\" (htab_keys dirty_vregs) vr_str);\n-                    (lstr \"clob\" clobbers hr_str);\n-                    (lstr \"in\" (Bits.to_list live_in_vregs.(i)) vr_str);\n-                    (lstr \"out\" (Bits.to_list live_out_vregs.(i)) vr_str);\n-                    (lstr \"use\" used vr_str);\n-                    (lstr \"def\" defined vr_str);\n-              end;\n-            List.iter (clean_hreg i) clobbers;\n-            if is_beginning_of_basic_block quad\n-            then\n-              begin\n-                spill_all_regs i;\n-                fixup := quad.quad_fixup;\n-                prepend (Il.process_quad (qp i) quad)\n-              end\n-            else\n-              begin\n-                fixup := quad.quad_fixup;\n-                let newq = (Il.process_quad (qp i) quad) in\n-                  begin\n-                    if is_end_of_basic_block quad\n-                    then spill_all_regs i\n-                    else ()\n-                  end;\n-                  prepend newq\n-              end\n-          end;\n-          List.iter inactivate_hreg clobbers;\n-          List.iter (fun i -> Hashtbl.replace dirty_vregs i ()) defined;\n-      done;\n-      cx.ctxt_quads <- Array.of_list (List.rev (!newq));\n-      kill_redundant_moves cx;\n-\n-      iflog cx\n-        begin\n-          fun _ ->\n-            log cx \"spills: %d pre-spilled, %d total\"\n-              n_pre_spills cx.ctxt_next_spill;\n-            log cx \"register-allocated quads:\";\n-            dump_quads cx;\n-        end;\n-      (cx.ctxt_quads, cx.ctxt_next_spill)\n-\n- with\n-     Ra_error s ->\n-       Session.fail sess \"RA error: %s\\n\" s;\n-       (quads, 0)\n-\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "949df5c9502623cf66fe68e3b95863aef2ee6d1b", "filename": "src/boot/be/x86.ml", "status": "removed", "additions": 0, "deletions": 2582, "changes": 2582, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,2582 +0,0 @@\n-(*\n- * x86/ia32 instructions have 6 parts:\n- *\n- *    [pre][op][modrm][sib][disp][imm]\n- *\n- * [pre] = 0..4 bytes of prefix\n- * [op] = 1..3 byte opcode\n- * [modrm] = 0 or 1 byte: [mod:2][reg/op:3][r/m:3]\n- * [sib] = 0 or 1 byte: [scale:2][index:3][base:3]\n- * [disp] = 1, 2 or 4 byte displacement\n- * [imm] = 1, 2 or 4 byte immediate\n- *\n- * So between 1 and 17 bytes total.\n- *\n- * We're not going to use sib, but modrm is worth discussing.\n- *\n- * The high two bits of modrm denote an addressing mode. The modes are:\n- *\n- *   00 - \"mostly\" *(reg)\n- *   01 - \"mostly\" *(reg) + disp8\n- *   10 - \"mostly\" *(reg) + disp32\n- *   11 - reg\n- *\n- * The next-lowest 3 bits denote a specific register, or a subopcode if\n- * there is a fixed register or only one operand. The instruction format\n- * reference will say \"/<n>\" for some number n, if a fixed subopcode is used.\n- * It'll say \"/r\" if the instruction uses this field to specify a register.\n- *\n- * The registers specified in this field are:\n- *\n- *   000 - EAX or XMM0\n- *   001 - ECX or XMM1\n- *   010 - EDX or XMM2\n- *   011 - EBX or XMM3\n- *   100 - ESP or XMM4\n- *   101 - EBP or XMM5\n- *   110 - ESI or XMM6\n- *   111 - EDI or XMM7\n- *\n- * The final low 3 bits denote sub-modes of the primary mode selected\n- * with the top 2 bits. In particular, they \"mostly\" select the reg that is\n- * to be used for effective address calculation.\n- *\n- * For the most part, these follow the same numbering order: EAX, ECX, EDX,\n- * EBX, ESP, EBP, ESI, EDI. There are two unusual deviations from the rule\n- * though:\n- *\n- *  - In primary modes 00, 01 and 10, r/m=100 means \"use SIB byte\".  You can\n- *    use (unscaled) ESP as the base register in these modes by appending the\n- *    SIB byte 0x24. We do that in our rm_r operand-encoder function.\n- *\n- *  - In primary mode 00, r/m=101 means \"just disp32\", no register is\n- *    involved.  There is no way to use EBP in primary mode 00. If you try, we\n- *    just decay into a mode 01 with an appended 8-bit immediate displacement.\n- *\n- * Some opcodes are written 0xNN +rd. This means \"we decided to chew up a\n- * whole pile of opcodes here, with each opcode including a hard-wired\n- * reference to a register\". For example, POP is \"0x58 +rd\", which means that\n- * the 1-byte insns 0x58..0x5f are chewed up for \"POP EAX\" ... \"POP EDI\"\n- * (again, the canonical order of register numberings)\n- *)\n-\n-(*\n- * Notes on register availability of x86:\n- *\n- * There are 8 GPRs but we use 2 of them for specific purposes:\n- *\n- *   - ESP always points to the current stack frame.\n- *   - EBP always points to the current frame base.\n- *\n- * We tell IL that we have 6 GPRs then, and permit most register-register ops\n- * on any of these 6, mostly-unconstrained.\n- *\n- *)\n-\n-\n-let log (sess:Session.sess) =\n-  Session.log \"insn\"\n-    sess.Session.sess_log_insn\n-    sess.Session.sess_log_out\n-;;\n-\n-let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n-  if sess.Session.sess_log_insn\n-  then thunk ()\n-  else ()\n-;;\n-\n-open Common;;\n-\n-exception Unrecognized\n-;;\n-\n-let modrm m rm reg_or_subopcode =\n-  if (((m land 0b11) != m) or\n-        ((rm land 0b111) != rm) or\n-        ((reg_or_subopcode land 0b111) != reg_or_subopcode))\n-  then raise (Invalid_argument \"X86.modrm_deref\")\n-  else\n-    ((((m land 0b11) lsl 6)\n-      lor\n-      (rm land 0b111))\n-     lor\n-      ((reg_or_subopcode land 0b111) lsl 3))\n-;;\n-\n-let modrm_deref_reg = modrm 0b00 ;;\n-let modrm_deref_disp32 = modrm 0b00 0b101 ;;\n-let modrm_deref_reg_plus_disp8 = modrm 0b01 ;;\n-let modrm_deref_reg_plus_disp32 = modrm 0b10 ;;\n-let modrm_reg = modrm 0b11 ;;\n-\n-let slash0 = 0;;\n-let slash1 = 1;;\n-let slash2 = 2;;\n-let slash3 = 3;;\n-let slash4 = 4;;\n-let slash5 = 5;;\n-let slash6 = 6;;\n-let slash7 = 7;;\n-\n-\n-(*\n- * Translate an IL-level hwreg number from 0..nregs into the 3-bit code number\n- * used through the mod r/m byte and /r sub-register specifiers of the x86\n- * ISA.\n- *\n- * See \"Table 2-2: 32-Bit Addressing Forms with the ModR/M Byte\", in the IA32\n- * Architecture Software Developer's Manual, volume 2a.\n- *)\n-\n-let eax = 0\n-let ecx = 1\n-let ebx = 2\n-let esi = 3\n-let edi = 4\n-let edx = 5\n-let ebp = 6\n-let esp = 7\n-\n-let code_eax = 0b000;;\n-let code_ecx = 0b001;;\n-let code_edx = 0b010;;\n-let code_ebx = 0b011;;\n-let code_esp = 0b100;;\n-let code_ebp = 0b101;;\n-let code_esi = 0b110;;\n-let code_edi = 0b111;;\n-\n-let reg r =\n-  match r with\n-      0 -> code_eax\n-    | 1 -> code_ecx\n-    | 2 -> code_ebx\n-    | 3 -> code_esi\n-    | 4 -> code_edi\n-    | 5 -> code_edx\n-        (* Never assigned by the register allocator, but synthetic code uses\n-           them *)\n-    | 6 -> code_ebp\n-    | 7 -> code_esp\n-    | _ -> raise (Invalid_argument \"X86.reg\")\n-;;\n-\n-\n-let dwarf_eax = 0;;\n-let dwarf_ecx = 1;;\n-let dwarf_edx = 2;;\n-let dwarf_ebx = 3;;\n-let dwarf_esp = 4;;\n-let dwarf_ebp = 5;;\n-let dwarf_esi = 6;;\n-let dwarf_edi = 7;;\n-\n-let dwarf_reg r =\n-  match r with\n-      0 -> dwarf_eax\n-    | 1 -> dwarf_ecx\n-    | 2 -> dwarf_ebx\n-    | 3 -> dwarf_esi\n-    | 4 -> dwarf_edi\n-    | 5 -> dwarf_edx\n-    | 6 -> dwarf_ebp\n-    | 7 -> dwarf_esp\n-    | _ -> raise (Invalid_argument \"X86.dwarf_reg\")\n-\n-let reg_str r =\n-  match r with\n-      0 -> \"eax\"\n-    | 1 -> \"ecx\"\n-    | 2 -> \"ebx\"\n-    | 3 -> \"esi\"\n-    | 4 -> \"edi\"\n-    | 5 -> \"edx\"\n-    | 6 -> \"ebp\"\n-    | 7 -> \"esp\"\n-    | _ -> raise (Invalid_argument \"X86.reg_str\")\n-;;\n-\n-(* This is a basic ABI. You might need to customize it by platform. *)\n-let (n_hardregs:int) = 6;;\n-\n-(* Includes ebx, esi, edi; does *not* include ebp, which has ABI-specified\n- * rules concerning its location and save/restore sequence.\n- * \n- * See http://refspecs.freestandards.org/elf/abi386-4.pdf\n- * Page 36, Figure 3-15 and friends.\n- *)\n-let (n_callee_saves:int) = 3;;\n-\n-let is_ty32 (ty:Il.scalar_ty) : bool =\n-  match ty with\n-      Il.ValTy (Il.Bits32) -> true\n-    | Il.AddrTy _ -> true\n-    | _ -> false\n-;;\n-\n-let is_r32 (c:Il.cell) : bool =\n-  match c with\n-      Il.Reg (_, st) -> is_ty32 st\n-    | _ -> false\n-;;\n-\n-let is_rm32 (c:Il.cell) : bool =\n-  match c with\n-      Il.Mem (_, Il.ScalarTy st) -> is_ty32 st\n-    | Il.Reg (_, st) -> is_ty32 st\n-    | _ -> false\n-;;\n-\n-let is_ty8 (ty:Il.scalar_ty) : bool =\n-  match ty with\n-      Il.ValTy (Il.Bits8) -> true\n-    | _ -> false\n-;;\n-\n-let is_m32 (c:Il.cell) : bool =\n-  match c with\n-      Il.Mem (_, Il.ScalarTy st) -> is_ty32 st\n-    | _ -> false\n-;;\n-\n-let is_m8 (c:Il.cell) : bool =\n-  match c with\n-      Il.Mem (_, Il.ScalarTy st) -> is_ty8 st\n-    | _ -> false\n-;;\n-\n-let is_ok_r8 (r:Il.hreg) : bool =\n-  (r == eax || r == ebx || r == ecx || r == edx)\n-;;\n-\n-let is_r8 (c:Il.cell) : bool =\n-  match c with\n-      Il.Reg (Il.Hreg r, st) when is_ok_r8 r -> is_ty8 st\n-    | _ -> false\n-;;\n-\n-let is_rm8 (c:Il.cell) : bool =\n-  match c with\n-      Il.Mem (_, Il.ScalarTy st) -> is_ty8 st\n-    | _ -> is_r8 c\n-;;\n-\n-\n-let emit_target_specific\n-    (e:Il.emitter)\n-    (q:Il.quad)\n-    : unit =\n-  let fixup = ref q.Il.quad_fixup in\n-  let put q' =\n-    Il.append_quad e { Il.quad_body = q';\n-                       Il.quad_fixup = (!fixup) };\n-    fixup := None;\n-  in\n-  let op_vreg op =\n-    Il.next_vreg_cell e (Il.operand_scalar_ty op)\n-  in\n-  let cell_vreg cell = op_vreg (Il.Cell cell) in\n-  let mem_vreg mem = cell_vreg (Il.Mem mem) in\n-  let movop = Il.default_mov q.Il.quad_body in\n-  let mov dst src =\n-    (* Decay mem-mem moves to use a vreg. *)\n-    match dst, src with\n-        Il.Mem dm, Il.Cell (Il.Mem _) ->\n-          let v = mem_vreg dm in\n-            put (Il.unary movop v src);\n-            put (Il.unary movop dst (Il.Cell v))\n-      | _ -> put (Il.unary movop dst src)\n-  in\n-\n-  let hr_like_op hr op =\n-    Il.Reg (Il.Hreg hr, Il.operand_scalar_ty op)\n-  in\n-  let hr_like_cell hr c = hr_like_op hr (Il.Cell c) in\n-  let q = q.Il.quad_body in\n-\n-    match q with\n-        Il.Binary ({ Il.binary_op = op;\n-                     Il.binary_dst = dst;\n-                     Il.binary_lhs = lhs;\n-                     Il.binary_rhs = rhs; } as b) ->\n-          begin\n-            match op with\n-\n-                Il.IMUL | Il.UMUL\n-              | Il.IDIV | Il.UDIV\n-              | Il.IMOD | Il.UMOD ->\n-                  let dst_eax = hr_like_cell eax dst in\n-                  let lhs_eax = hr_like_op eax lhs in\n-                  let rhs_ecx = hr_like_op ecx rhs in\n-                    (* Horrible: we bounce mul/div/mod inputs off spill slots\n-                     * to ensure non-interference between the temporaries used\n-                     * during mem-base-reg reloads and the registers we're\n-                     * preparing.  *)\n-                  let next_spill_like op =\n-                    Il.Mem (Il.next_spill_slot e\n-                              (Il.ScalarTy (Il.operand_scalar_ty op)))\n-                  in\n-                  let is_eax cell =\n-                    match cell with\n-                        Il.Cell (Il.Reg (Il.Hreg hr, _)) -> hr = eax\n-                      | _ -> false\n-                  in\n-                    if is_eax lhs\n-                    then\n-                      mov rhs_ecx rhs\n-                    else\n-                      begin\n-                        let lhs_spill = next_spill_like lhs in\n-                        let rhs_spill = next_spill_like rhs in\n-\n-                          mov lhs_spill lhs;\n-                          mov rhs_spill rhs;\n-\n-                          mov lhs_eax (Il.Cell lhs_spill);\n-                          mov rhs_ecx (Il.Cell rhs_spill);\n-                      end;\n-\n-                    put (Il.Binary\n-                           { b with\n-                               Il.binary_lhs = (Il.Cell lhs_eax);\n-                               Il.binary_rhs = (Il.Cell rhs_ecx);\n-                               Il.binary_dst = dst_eax; });\n-                    if dst <> dst_eax\n-                    then mov dst (Il.Cell dst_eax);\n-\n-              | _ when (Il.Cell dst) <> lhs ->\n-                  mov dst lhs;\n-                  put (Il.Binary\n-                         { b with Il.binary_lhs = Il.Cell dst })\n-\n-              | _ -> put q\n-          end\n-\n-      | Il.Unary ({ Il.unary_op = op;\n-                    Il.unary_dst = dst;\n-                    Il.unary_src = src; } as u) ->\n-          begin\n-            match op with\n-\n-                Il.UMOV | Il.IMOV ->\n-                  mov dst src\n-\n-              (* x86 can only NEG or NOT in-place. *)\n-              | Il.NEG | Il.NOT when (Il.Cell dst) <> src ->\n-                  mov dst src;\n-                  put (Il.Unary { u with Il.unary_src = Il.Cell dst })\n-\n-              | _ -> put q\n-          end\n-\n-      | Il.Call c ->\n-          let dst_eax = hr_like_cell eax c.Il.call_dst in\n-            put (Il.Call { c with Il.call_dst = dst_eax });\n-            if c.Il.call_dst <> dst_eax\n-            then mov c.Il.call_dst (Il.Cell dst_eax)\n-\n-      (* \n-       * For the get-next-pc thunk hack to work, we need to lea an immptr\n-       * to eax, always.\n-       *)\n-      | Il.Lea ({ Il.lea_dst = dst;\n-                  Il.lea_src = Il.ImmPtr _  } as lea) ->\n-          let eax_dst = hr_like_cell eax dst in\n-            put (Il.Lea { lea with Il.lea_dst = eax_dst });\n-            if dst <> eax_dst\n-            then mov dst (Il.Cell eax_dst);\n-\n-      | q -> put q\n-;;\n-\n-\n-let constrain_vregs (q:Il.quad) (hregs:(Il.vreg,Bits.t) Hashtbl.t) : unit =\n-\n-  let involves_8bit_cell =\n-    let b = ref false in\n-    let qp_cell _ c =\n-      match c with\n-          Il.Reg (_, Il.ValTy Il.Bits8)\n-        | Il.Mem (_, Il.ScalarTy (Il.ValTy Il.Bits8)) ->\n-            (b := true; c)\n-        | _ -> c\n-    in\n-      ignore (Il.process_quad { Il.identity_processor with\n-                                  Il.qp_cell_read = qp_cell;\n-                                  Il.qp_cell_write = qp_cell } q);\n-      !b\n-  in\n-\n-  let get_hregs v =\n-    htab_search_or_add hregs v (fun _ -> Bits.create n_hardregs true)\n-  in\n-\n-  let qp_mem _ m = m in\n-  let qp_cell _ c =\n-    begin\n-      match c with\n-          Il.Reg (Il.Vreg v, _) when involves_8bit_cell ->\n-            (* 8-bit register cells must only be al, cl, dl, bl.\n-             * Not esi/edi. *)\n-            let hv = get_hregs v in\n-              List.iter (fun bad -> Bits.set hv bad false) [esi; edi]\n-        | _ -> ()\n-    end;\n-    c\n-  in\n-    begin\n-      match q.Il.quad_body with\n-          Il.Binary b ->\n-            begin\n-              match b.Il.binary_op with\n-                  (* Shifts *)\n-                | Il.LSL | Il.LSR | Il.ASR ->\n-                    begin\n-                      match b.Il.binary_rhs with\n-                          Il.Cell (Il.Reg (Il.Vreg v, _)) ->\n-                            let hv = get_hregs v in\n-                              (* Shift src has to be ecx. *)\n-                              List.iter\n-                                (fun bad -> Bits.set hv bad false)\n-                                [eax; edx; ebx; esi; edi]\n-                        | _ -> ()\n-                    end\n-                | _ -> ()\n-            end\n-        | _ -> ()\n-    end;\n-    ignore\n-      (Il.process_quad { Il.identity_processor with\n-                           Il.qp_mem = qp_mem;\n-                           Il.qp_cell_read = qp_cell;\n-                           Il.qp_cell_write = qp_cell } q)\n-;;\n-\n-\n-let clobbers (quad:Il.quad) : Il.hreg list =\n-  match quad.Il.quad_body with\n-      Il.Binary bin ->\n-        begin\n-          match bin.Il.binary_op with\n-              Il.IMUL | Il.UMUL\n-            | Il.IDIV | Il.UDIV -> [ edx ]\n-            | Il.IMOD | Il.UMOD -> [ edx ]\n-            | _ -> []\n-        end\n-    | Il.Unary un ->\n-        begin\n-          match un.Il.unary_op with\n-              Il.ZERO -> [ eax; edi; ecx ]\n-            | _ -> [ ]\n-        end\n-    | Il.Call _ -> [ eax; ecx; edx; ]\n-    | Il.Regfence -> [ eax; ecx; ebx; edx; edi; esi; ]\n-    | _ -> []\n-;;\n-\n-\n-let word_sz = 4L\n-;;\n-\n-let word_bits = Il.Bits32\n-;;\n-\n-let word_ty = TY_u32\n-;;\n-\n-let annotate (e:Il.emitter) (str:string) =\n-  Hashtbl.add e.Il.emit_annotations e.Il.emit_pc str\n-;;\n-\n-let c (c:Il.cell) : Il.operand = Il.Cell c ;;\n-let r (r:Il.reg) : Il.cell = Il.Reg ( r, (Il.ValTy word_bits) ) ;;\n-let h (x:Il.hreg) : Il.reg = Il.Hreg x ;;\n-let rc (x:Il.hreg) : Il.cell = r (h x) ;;\n-let ro (x:Il.hreg) : Il.operand = c (rc x) ;;\n-let vreg (e:Il.emitter) : (Il.reg * Il.cell) =\n-  let vr = Il.next_vreg e in\n-    (vr, (Il.Reg (vr, (Il.ValTy word_bits))))\n-;;\n-let imm (x:Asm.expr64) : Il.operand =\n-  Il.Imm (x, word_ty)\n-;;\n-let immi (x:int64) : Il.operand =\n-  imm (Asm.IMM x)\n-;;\n-\n-let imm_byte (x:Asm.expr64) : Il.operand =\n-  Il.Imm (x, TY_u8)\n-;;\n-let immi_byte (x:int64) : Il.operand =\n-  imm_byte (Asm.IMM x)\n-;;\n-\n-\n-let byte_off_n (i:int) : Asm.expr64 =\n-  Asm.IMM (Int64.of_int i)\n-;;\n-\n-let byte_n (reg:Il.reg) (i:int) : Il.cell =\n-  let imm = byte_off_n i in\n-  let mem = Il.RegIn (reg, Some imm) in\n-    Il.Mem (mem, Il.ScalarTy (Il.ValTy Il.Bits8))\n-;;\n-\n-let word_off_n (i:int) : Asm.expr64 =\n-  Asm.IMM (Int64.mul (Int64.of_int i) word_sz)\n-;;\n-\n-let word_at (reg:Il.reg) : Il.cell =\n-  let mem = Il.RegIn (reg, None) in\n-    Il.Mem (mem, Il.ScalarTy (Il.ValTy word_bits))\n-;;\n-\n-let word_at_off (reg:Il.reg) (off:Asm.expr64) : Il.cell =\n-  let mem = Il.RegIn (reg, Some off) in\n-    Il.Mem (mem, Il.ScalarTy (Il.ValTy word_bits))\n-;;\n-\n-let word_n (reg:Il.reg) (i:int) : Il.cell =\n-  word_at_off reg (word_off_n i)\n-;;\n-\n-let reg_codeptr (reg:Il.reg) : Il.code =\n-  Il.CodePtr (Il.Cell (Il.Reg (reg, Il.AddrTy Il.CodeTy)))\n-;;\n-\n-let word_n_low_byte (reg:Il.reg) (i:int) : Il.cell =\n-  let imm = word_off_n i in\n-  let mem = Il.RegIn (reg, Some imm) in\n-    Il.Mem (mem, Il.ScalarTy (Il.ValTy Il.Bits8))\n-;;\n-\n-let wordptr_n (reg:Il.reg) (i:int) : Il.cell =\n-  let imm = word_off_n i in\n-  let mem = Il.RegIn (reg, Some imm) in\n-    Il.Mem (mem, Il.ScalarTy (Il.AddrTy (Il.ScalarTy (Il.ValTy word_bits))))\n-;;\n-\n-let get_element_ptr = Il.get_element_ptr word_bits reg_str ;;\n-\n-let establish_frame_base (e:Il.emitter) : unit =\n-    (* Establish i386-ABI-compliant frame base. *)\n-    Il.emit e (Il.Push (ro ebp));\n-    Il.emit e (Il.umov (rc ebp) (ro esp));\n-;;\n-\n-let save_callee_saves (e:Il.emitter) : unit =\n-    Il.emit e (Il.Push (ro edi));\n-    Il.emit e (Il.Push (ro esi));\n-    Il.emit e (Il.Push (ro ebx));\n-;;\n-\n-let restore_callee_saves (e:Il.emitter) : unit =\n-    Il.emit e (Il.Pop (rc ebx));\n-    Il.emit e (Il.Pop (rc esi));\n-    Il.emit e (Il.Pop (rc edi));\n-;;\n-\n-let leave_frame (e:Il.emitter) : unit =\n-    Il.emit e (Il.Pop (rc ebp));\n-;;\n-\n-\n-(* restores registers from the frame base without updating esp:\n- *   - restores the callee-saves: edi, esi, ebx\n- *   - restores ebp to stored values from frame base\n- *   - sets `retpc' register to stored retpc from frame base\n- *   - sets `base' register to current fp\n- *)\n-let restore_frame_regs (e:Il.emitter) (base:Il.reg) (retpc:Il.reg)\n-    : unit =\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-    mov (r base) (ro ebp);\n-    mov (rc ebx) (c (word_n base (-3)));\n-    mov (rc esi) (c (word_n base (-2)));\n-    mov (rc edi) (c (word_n base (-1)));\n-    mov (rc ebp) (c (word_at base));\n-    mov (r retpc) (c (word_n base 1));\n-;;\n-\n-\n-(*\n- * Our arrangement on x86 is this:\n- *\n- *   *ebp+8+(4*N)  = [argN   ]\n- *   ...\n- *   *ebp+16       = [arg2   ] = obj/closure ptr\n- *   *ebp+12       = [arg1   ] = task ptr\n- *   *ebp+8        = [arg0   ] = out ptr\n- *   *ebp+4        = [retpc  ]\n- *   *ebp          = [old_ebp]\n- *   *ebp-4        = [old_edi]\n- *   *ebp-8        = [old_esi]\n- *   *ebp-12       = [old_ebx]\n- *\n- * For x86-cdecl:\n- *\n- *  %eax, %ecx, %edx are \"caller save\" registers\n- *  %ebp, %ebx, %esi, %edi are \"callee save\" registers\n- *\n- *)\n-\n-let frame_base_words = 2 (* eip,ebp *) ;;\n-let frame_base_sz = Int64.mul (Int64.of_int frame_base_words) word_sz;;\n-\n-let frame_info_words = 2 (* crate ptr, crate-rel frame info disp *) ;;\n-let frame_info_sz = Int64.mul (Int64.of_int frame_info_words) word_sz;;\n-\n-let implicit_arg_words = 3 (* task ptr, out ptr, closure ptr *);;\n-let implicit_args_sz = Int64.mul (Int64.of_int implicit_arg_words) word_sz;;\n-\n-let callee_saves_sz = Int64.mul (Int64.of_int n_callee_saves) word_sz;;\n-\n-let out_ptr = wordptr_n (Il.Hreg ebp) (frame_base_words);;\n-let task_ptr = wordptr_n (Il.Hreg ebp) (frame_base_words+1);;\n-let closure_ptr = wordptr_n (Il.Hreg ebp) (frame_base_words+2);;\n-let ty_param_n i =\n-  wordptr_n (Il.Hreg ebp) (frame_base_words + implicit_arg_words + i);;\n-\n-let spill_slot (i:Il.spill) : Il.mem =\n-  let imm = (Asm.IMM\n-               (Int64.neg\n-                  (Int64.add\n-                     (Int64.add frame_info_sz callee_saves_sz)\n-                     (Int64.mul word_sz\n-                        (Int64.of_int (i+1))))))\n-  in\n-    Il.RegIn ((Il.Hreg ebp), Some imm)\n-;;\n-\n-\n-let get_next_pc_thunk_fixup = new_fixup \"glue$get_next_pc\"\n-;;\n-\n-let emit_get_next_pc_thunk (e:Il.emitter) : unit =\n-  let sty = Il.AddrTy Il.CodeTy in\n-  let rty = Il.ScalarTy sty in\n-  let deref_esp = Il.Mem (Il.RegIn (Il.Hreg esp, None), rty) in\n-  let eax = (Il.Reg (Il.Hreg eax, sty)) in\n-    Il.emit_full e (Some get_next_pc_thunk_fixup)\n-      (Il.umov eax (Il.Cell deref_esp));\n-    Il.emit e Il.Ret;\n-;;\n-\n-let get_next_pc_thunk : (Il.reg * fixup * (Il.emitter -> unit)) =\n-    (Il.Hreg eax, get_next_pc_thunk_fixup, emit_get_next_pc_thunk)\n-;;\n-\n-let emit_c_call\n-    (e:Il.emitter)\n-    (ret:Il.cell)\n-    (tmp1:Il.reg)\n-    (tmp2:Il.reg)\n-    (nabi:nabi)\n-    (in_prologue:bool)\n-    (fptr:Il.code)\n-    (args:Il.operand array)\n-    : unit =\n-\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let imov dst src = emit (Il.imov dst src) in\n-  let add dst src = emit (Il.binary Il.ADD dst (Il.Cell dst) src) in\n-  let binary op dst imm = emit (Il.binary op dst (c dst) (immi imm)) in\n-\n-  (* rust calls get task as arg0  *)\n-  let args =\n-    if nabi.nabi_convention = CONV_rust\n-    then Array.append [| c task_ptr |] args\n-    else args\n-  in\n-  let nargs = Array.length args in\n-  let arg_sz = Int64.mul (Int64.of_int nargs) word_sz\n-  in\n-\n-    mov (r tmp1) (c task_ptr);               (* tmp1 = task from argv[-1] *)\n-    mov (r tmp2) (ro esp);                   (* tmp2 = esp                *)\n-    mov                                      (* task->rust_sp = tmp2      *)\n-      (word_n tmp1 Abi.task_field_rust_sp)\n-      (c (r tmp2));\n-    mov                                      (* esp = task->runtime_sp    *)\n-      (rc esp)\n-      (c (word_n tmp1 Abi.task_field_runtime_sp));\n-\n-    binary Il.SUB (rc esp) arg_sz;           (* make room on the stack    *)\n-    binary Il.AND (rc esp)                   (* and 16-byte align sp      *)\n-      0xfffffffffffffff0L;\n-\n-    Array.iteri\n-      begin\n-        fun i (arg:Il.operand) ->   (* write args to C stack     *)\n-          match arg with\n-              Il.Cell (Il.Mem (a, ty)) ->\n-                begin\n-                  match a with\n-                      Il.RegIn (Il.Hreg base, off) when base == esp ->\n-                        mov (r tmp1) (c (Il.Mem (Il.RegIn (tmp2, off), ty)));\n-                        mov (word_n (h esp) i) (c (r tmp1));\n-                    | _ ->\n-                        mov (r tmp1) arg;\n-                        mov (word_n (h esp) i) (c (r tmp1));\n-                end\n-            | Il.Imm (_, tm) when mach_is_signed tm ->\n-                imov (word_n (h esp) i) arg\n-            | _ ->\n-                mov (word_n (h esp) i) arg\n-      end\n-      args;\n-\n-    match ret with\n-        Il.Mem (Il.RegIn (Il.Hreg base, _), _) when base == esp ->\n-          assert (not in_prologue);\n-\n-          (* If ret is esp-relative, use a temporary register until we\n-             switched stacks. *)\n-\n-          emit (Il.call (r tmp1) fptr);\n-          mov (r tmp2) (c task_ptr);\n-          mov (rc esp) (c (word_n tmp2 Abi.task_field_rust_sp));\n-          mov ret (c (r tmp1));\n-\n-      | _ when in_prologue ->\n-          (*\n-           * We have to do something a little surprising here:\n-           * we're doing a 'grow' call so ebp is going to point\n-           * into a dead stack frame on call-return. So we\n-           * temporarily store task-ptr into ebp and then reload\n-           * esp *and* ebp via ebp->rust_sp on the other side of\n-           * the call.\n-           *)\n-          mov (rc ebp) (c task_ptr);\n-          emit (Il.call ret fptr);\n-          mov (rc esp) (c (word_n (h ebp) Abi.task_field_rust_sp));\n-          mov (rc ebp) (ro esp);\n-          add (rc ebp) (immi callee_saves_sz);\n-\n-      | _ ->\n-          emit (Il.call ret fptr);\n-          mov (r tmp2) (c task_ptr);\n-          mov (rc esp) (c (word_n tmp2 Abi.task_field_rust_sp));\n-;;\n-\n-let emit_void_prologue_call\n-    (e:Il.emitter)\n-    (nabi:nabi)\n-    (fn:fixup)\n-    (args:Il.operand array)\n-    : unit =\n-  let callee = Abi.load_fixup_codeptr e (h eax) fn true nabi.nabi_indirect in\n-    emit_c_call e (rc eax) (h edx) (h ecx) nabi true callee args\n-;;\n-\n-let emit_native_call\n-    (e:Il.emitter)\n-    (ret:Il.cell)\n-    (nabi:nabi)\n-    (fn:fixup)\n-    (args:Il.operand array)\n-    : unit =\n-\n-  let (tmp1, _) = vreg e in\n-  let (tmp2, _) = vreg e in\n-  let (freg, _) = vreg e in\n-  let callee = Abi.load_fixup_codeptr e freg fn true nabi.nabi_indirect in\n-    emit_c_call e ret tmp1 tmp2 nabi false callee args\n-;;\n-\n-let emit_native_void_call\n-    (e:Il.emitter)\n-    (nabi:nabi)\n-    (fn:fixup)\n-    (args:Il.operand array)\n-    : unit =\n-\n-  let (ret, _) = vreg e in\n-    emit_native_call e (r ret) nabi fn args\n-;;\n-\n-let emit_native_call_in_thunk\n-    (e:Il.emitter)\n-    (ret:Il.cell option)\n-    (nabi:nabi)\n-    (fn:Il.operand)\n-    (args:Il.operand array)\n-    : unit =\n-\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-\n-    begin\n-      match fn with\n-          (*\n-           * NB: old path, remove when/if you're sure you don't\n-           * want native-linker-symbol-driven requirements.\n-           *)\n-          Il.ImmPtr (fix, _) ->\n-            let code =\n-              Abi.load_fixup_codeptr e (h eax) fix true nabi.nabi_indirect\n-            in\n-              emit_c_call e (rc eax) (h edx) (h ecx) nabi false code args;\n-\n-        | _ ->\n-            (*\n-             * NB: new path, ignores nabi_indirect, assumes\n-             * indirect via pointer from upcall_require_c_sym\n-             * or crate cache.\n-             *)\n-            mov (rc eax) fn;\n-            let cell = Il.Reg (h eax, Il.AddrTy Il.CodeTy) in\n-            let fptr = Il.CodePtr (Il.Cell cell) in\n-              emit_c_call e (rc eax) (h edx) (h ecx) nabi false fptr args;\n-    end;\n-\n-    match ret with\n-        Some (Il.Reg (r, _)) ->\n-          mov (word_at r) (ro eax)\n-      | Some ret ->\n-          mov (rc edx) (c ret);\n-          mov (word_at (h edx)) (ro eax)\n-      | _ -> ()\n-;;\n-\n-\n-let crawl_stack_calling_glue\n-    (e:Il.emitter)\n-    (glue_field:int)\n-    : unit =\n-\n-  let fp_n = word_n (Il.Hreg ebp) in\n-  let edi_n = word_n (Il.Hreg edi) in\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let push x = emit (Il.Push x) in\n-  let pop x = emit (Il.Pop x) in\n-  let add x y = emit (Il.binary Il.ADD (rc x) (ro x) (ro y)) in\n-  let codefix fix = Il.CodePtr (Il.ImmPtr (fix, Il.CodeTy)) in\n-  let mark fix = Il.emit_full e (Some fix) Il.Dead in\n-\n-  let repeat_jmp_fix = new_fixup \"repeat jump\" in\n-  let skip_jmp_fix = new_fixup \"skip jump\" in\n-  let exit_jmp_fix = new_fixup \"exit jump\" in\n-\n-    push (ro ebp);                      (* save ebp at entry            *)\n-\n-    mark repeat_jmp_fix;\n-\n-    mov (rc esi)                        (* esi <- crate ptr             *)\n-      (c (fp_n ((-1) - n_callee_saves)));\n-    mov (rc edi)                        (* edi <- frame glue functions. *)\n-      (c (fp_n ((-2) - n_callee_saves)));\n-    emit (Il.cmp (ro edi) (immi 0L));\n-\n-    emit\n-      (Il.jmp Il.JE\n-         (codefix skip_jmp_fix));       (* if struct* is nonzero        *)\n-    add edi esi;                        (* add crate ptr to disp.       *)\n-    mov\n-      (rc ecx)\n-      (c (edi_n glue_field));           (* ecx <-  glue                 *)\n-    emit (Il.cmp (ro ecx) (immi 0L));\n-\n-    emit\n-      (Il.jmp Il.JE\n-         (codefix skip_jmp_fix));       (* if glue-fn is nonzero        *)\n-    add ecx esi;                        (* add crate ptr to disp.       *)\n-    push (ro ebp);                      (* frame-arg                    *)\n-    push (immi 0L);                     (* null closure-ptr             *)\n-    push (c task_ptr);                  (* self-task ptr                *)\n-    push (immi 0L);                     (* outptr                       *)\n-    emit (Il.call (rc eax)\n-            (reg_codeptr (h ecx)));     (* call glue_fn, trashing eax.  *)\n-    pop (rc eax);\n-    pop (rc eax);\n-    pop (rc eax);\n-\n-    mark skip_jmp_fix;\n-    mov (rc edi) (c (fp_n 0));          (* load next fp (fp[0])           *)\n-    emit (Il.cmp (ro edi) (immi 0L));\n-    emit (Il.jmp Il.JE\n-            (codefix exit_jmp_fix));    (* if nonzero                     *)\n-    mov (rc ebp) (ro edi);              (* move to next frame             *)\n-    emit (Il.jmp Il.JMP\n-            (codefix repeat_jmp_fix));  (* loop                           *)\n-\n-    (* exit path. *)\n-    mark exit_jmp_fix;\n-    pop (rc ebp);                       (* restore ebp                    *)\n-;;\n-\n-let sweep_gc_chain\n-    (e:Il.emitter)\n-    (glue_field:int)\n-    (clear_mark:bool)\n-    : unit =\n-\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let push x = emit (Il.Push x) in\n-  let pop x = emit (Il.Pop x) in\n-  let band x y = emit (Il.binary Il.AND x (c x) y) in\n-  let add x y = emit (Il.binary Il.ADD (rc x) (ro x) (ro y)) in\n-  let edi_n = word_n (Il.Hreg edi) in\n-  let ecx_n = word_n (Il.Hreg ecx) in\n-  let codefix fix = Il.CodePtr (Il.ImmPtr (fix, Il.CodeTy)) in\n-  let mark fix = Il.emit_full e (Some fix) Il.Dead in\n-  let repeat_jmp_fix = new_fixup \"repeat jump\" in\n-  let skip_jmp_fix = new_fixup \"skip jump\" in\n-  let exit_jmp_fix = new_fixup \"exit jump\" in\n-\n-    mov (rc edi) (c task_ptr);\n-    mov (rc edi) (c (edi_n Abi.task_field_gc_alloc_chain));\n-    mark repeat_jmp_fix;\n-    emit (Il.cmp (ro edi) (immi 0L));\n-    emit (Il.jmp Il.JE\n-            (codefix exit_jmp_fix));            (* if nonzero             *)\n-    mov (rc ecx)                                (* Load GC ctrl word      *)\n-      (c (edi_n Abi.box_gc_field_ctrl));\n-    mov (rc eax) (ro ecx);\n-    band (rc eax) (immi 1L);                    (* Extract mark to eax.   *)\n-    band                                        (* Clear mark in ecx.     *)\n-      (rc ecx)\n-      (immi 0xfffffffffffffffeL);\n-\n-    if clear_mark\n-    then\n-      mov                                       (* Write-back cleared.    *)\n-        ((edi_n Abi.box_gc_field_ctrl))\n-        (ro ecx);\n-\n-    emit (Il.cmp (ro eax) (immi 0L));\n-    emit\n-      (Il.jmp Il.JNE\n-         (codefix skip_jmp_fix));               (* if unmarked (garbage)  *)\n-\n-    push (ro edi);                              (* Push gc_val.           *)\n-\n-    (* NB: ecx is a type descriptor now. *)\n-\n-    mov (rc eax)                                (* Load typarams ptr.     *)\n-      (c (ecx_n Abi.tydesc_field_first_param));\n-    push (ro eax);                              (* Push typarams ptr.     *)\n-\n-    push (immi 0L);                             (* Push null closure-ptr  *)\n-    push (c task_ptr);                          (* Push task ptr.         *)\n-    push (immi 0L);                             (* Push null outptr.      *)\n-\n-    mov (rc eax)                                (* Load glue tydesc-off.  *)\n-      (c (ecx_n glue_field));\n-    add eax ecx;                                (* Add to tydesc*         *)\n-    emit (Il.call (rc eax)\n-            (reg_codeptr (h eax)));             (* Call glue.             *)\n-    pop (rc eax);\n-    pop (rc eax);\n-    pop (rc eax);\n-    pop (rc eax);\n-\n-    mark skip_jmp_fix;\n-    mov (rc edi)                                (* Advance down chain     *)\n-      (c (edi_n Abi.box_gc_field_next));\n-    emit (Il.jmp Il.JMP\n-            (codefix repeat_jmp_fix));          (* loop                   *)\n-    mark exit_jmp_fix;\n-;;\n-\n-\n-\n-let gc_glue\n-    (e:Il.emitter)\n-    : unit =\n-\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let push x = emit (Il.Push x) in\n-  let pop x = emit (Il.Pop x) in\n-  let edi_n = word_n (Il.Hreg edi) in\n-\n-    mov (rc edi) (c task_ptr);            (* switch back to rust stack    *)\n-    mov\n-      (rc esp)\n-      (c (edi_n Abi.task_field_rust_sp));\n-\n-    (* Mark pass. *)\n-\n-    push (ro ebp);\n-    save_callee_saves e;\n-    push (ro eax);\n-    crawl_stack_calling_glue e Abi.frame_glue_fns_field_mark;\n-\n-    (* The sweep pass has two sub-passes over the GC chain:\n-     *\n-     *    - In pass #1, 'severing', we goes through and disposes of all\n-     *      mutable box slots in each record. That is, rc-- the referent,\n-     *      and then null-out.  If the rc-- gets to zero, that just means the\n-     *      mutable is part of the garbage set currently being collected. But\n-     *      a mutable may be live-and-outside; this detaches the garbage set\n-     *      from the non-garbage set within the mutable heap.\n-     *\n-     *    - In pass #2, 'freeing', we run the normal free-glue. This winds up\n-     *      running drop-glue on the zero-reference-reaching immutables only,\n-     *      since all the mutables were nulled out in pass #1. This is where\n-     *      you do the unlinking from the double-linked chain and call free(),\n-     *      also.\n-     *\n-     *)\n-    sweep_gc_chain e Abi.tydesc_field_sever_glue false;\n-    sweep_gc_chain e Abi.tydesc_field_free_glue true;\n-\n-    pop (rc eax);\n-    restore_callee_saves e;\n-    pop (rc ebp);\n-    Il.emit e Il.Ret;\n-;;\n-\n-\n-let unwind_glue\n-    (e:Il.emitter)\n-    (nabi:nabi)\n-    (exit_task_fixup:fixup)\n-    : unit =\n-\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let edi_n = word_n (Il.Hreg edi) in\n-\n-    mov (rc edi) (c task_ptr);          (* switch back to rust stack    *)\n-    mov\n-      (rc esp)\n-      (c (edi_n Abi.task_field_rust_sp));\n-\n-    crawl_stack_calling_glue e Abi.frame_glue_fns_field_drop;\n-    let callee =\n-      Abi.load_fixup_codeptr\n-        e (h eax) exit_task_fixup false nabi.nabi_indirect\n-    in\n-      emit_c_call\n-        e (rc eax) (h edi) (h ecx) nabi false callee [| (c task_ptr) |];\n-;;\n-\n-\n-(* Puts result in eax; clobbers ecx, edx in the process. *)\n-let rec calculate_sz\n-    (e:Il.emitter)\n-    (size:size)\n-    (in_obj:bool)\n-    : unit =\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let push x = emit (Il.Push x) in\n-  let pop x = emit (Il.Pop x) in\n-  let neg x = emit (Il.unary Il.NEG (rc x) (ro x)) in\n-  let bnot x = emit (Il.unary Il.NOT (rc x) (ro x)) in\n-  let band x y = emit (Il.binary Il.AND (rc x) (ro x) (ro y)) in\n-  let add x y = emit (Il.binary Il.ADD (rc x) (ro x) (ro y)) in\n-  let mul x y = emit (Il.binary Il.UMUL (rc x) (ro x) (ro y)) in\n-  let subi x y = emit (Il.binary Il.SUB (rc x) (ro x) (immi y)) in\n-  let eax_gets_a_and_ecx_gets_b a b =\n-    calculate_sz e b in_obj;\n-    push (ro eax);\n-    calculate_sz e a in_obj;\n-    pop (rc ecx);\n-  in\n-\n-  let ty_param_n_in_obj_fn i =\n-    (*\n-     * Here we are trying to immitate the obj-fn branch of\n-     * Trans.get_ty_params_of_current_frame while using\n-     * eax as our only register.\n-     *)\n-\n-    (* Bind all the referent types we'll need... *)\n-\n-    let obj_box_rty = Semant.obj_box_rty word_bits in\n-    let tydesc_rty = Semant.tydesc_rty word_bits in\n-    (* Note that we cheat here and pretend only to have i+1 tydescs (because\n-       we GEP to the i'th while still in this function, so no one outside\n-       finds out about the lie. *)\n-    let tydesc_rtys =\n-      Array.init (i + 1)\n-        (fun _ ->  (Il.ScalarTy (Il.AddrTy tydesc_rty)))\n-    in\n-    let ty_params_rty = Il.StructTy tydesc_rtys in\n-\n-      (* ... and fetch! *)\n-\n-      mov (rc eax) (Il.Cell closure_ptr);\n-      let obj_body = word_n (h eax) Abi.box_rc_field_body in\n-      let obj_body = Il.cell_cast obj_body obj_box_rty in\n-      let tydesc_ptr = get_element_ptr obj_body Abi.obj_body_elt_tydesc in\n-\n-        mov (rc eax) (Il.Cell tydesc_ptr);\n-        let tydesc = Il.cell_cast (word_at (h eax)) tydesc_rty in\n-        let ty_params_ptr =\n-          get_element_ptr tydesc Abi.tydesc_field_first_param\n-        in\n-\n-          mov (rc eax) (Il.Cell ty_params_ptr);\n-          let ty_params = Il.cell_cast (word_at (h eax)) ty_params_rty in\n-            get_element_ptr ty_params i\n-  in\n-\n-    match size with\n-        SIZE_fixed i ->\n-          mov (rc eax) (immi i)\n-\n-      | SIZE_fixup_mem_sz f ->\n-          mov (rc eax) (imm (Asm.M_SZ f))\n-\n-      | SIZE_fixup_mem_pos f ->\n-          mov (rc eax) (imm (Asm.M_POS f))\n-\n-      | SIZE_param_size i ->\n-          if in_obj\n-          then\n-            mov (rc eax) (Il.Cell (ty_param_n_in_obj_fn i))\n-          else\n-            mov (rc eax) (Il.Cell (ty_param_n i));\n-          mov (rc eax) (Il.Cell (word_n (h eax) Abi.tydesc_field_size))\n-\n-      | SIZE_param_align i ->\n-          if in_obj\n-          then\n-            mov (rc eax) (Il.Cell (ty_param_n_in_obj_fn i))\n-          else\n-            mov (rc eax) (Il.Cell (ty_param_n i));\n-          mov (rc eax) (Il.Cell (word_n (h eax) Abi.tydesc_field_align))\n-\n-      | SIZE_rt_neg a ->\n-          calculate_sz e a in_obj;\n-          neg eax\n-\n-      | SIZE_rt_add (a, b) ->\n-          eax_gets_a_and_ecx_gets_b a b;\n-          add eax ecx\n-\n-      | SIZE_rt_mul (a, b) ->\n-          eax_gets_a_and_ecx_gets_b a b;\n-          mul eax ecx\n-\n-      | SIZE_rt_max (a, b) ->\n-          eax_gets_a_and_ecx_gets_b a b;\n-          emit (Il.cmp (ro eax) (ro ecx));\n-          let jmp_pc = e.Il.emit_pc in\n-            emit (Il.jmp Il.JAE Il.CodeNone);\n-            mov (rc eax) (ro ecx);\n-            Il.patch_jump e jmp_pc e.Il.emit_pc;\n-\n-      | SIZE_rt_align (align, off) ->\n-          (*\n-           * calculate off + pad where:\n-           *\n-           * pad = (align - (off mod align)) mod align\n-           *\n-           * In our case it's always a power of two, \n-           * so we can just do:\n-           * \n-           * mask = align-1\n-           * off += mask\n-           * off &= ~mask\n-           * \n-           *)\n-          eax_gets_a_and_ecx_gets_b off align;\n-          subi ecx 1L;\n-          add eax ecx;\n-          bnot ecx;\n-          band eax ecx;\n-;;\n-\n-let rec size_calculation_stack_highwater (size:size) : int =\n-  match size with\n-      SIZE_fixed _\n-    | SIZE_fixup_mem_sz _\n-    | SIZE_fixup_mem_pos _\n-    | SIZE_param_size _\n-    | SIZE_param_align _ -> 0\n-    | SIZE_rt_neg a  ->\n-        (size_calculation_stack_highwater a)\n-    | SIZE_rt_max (a, b) ->\n-        (size_calculation_stack_highwater a)\n-        + (size_calculation_stack_highwater b)\n-    | SIZE_rt_add (a, b)\n-    | SIZE_rt_mul (a, b)\n-    | SIZE_rt_align (a, b) ->\n-        (size_calculation_stack_highwater a)\n-        + (size_calculation_stack_highwater b)\n-        + 1\n-;;\n-\n-let minimal_call_sz = Int64.add frame_base_sz callee_saves_sz;;\n-let boundary_sz =\n-  (Asm.IMM\n-     (Int64.add                   (* Extra non-frame room:           *)\n-        minimal_call_sz           (* to safely enter the next frame, *)\n-        minimal_call_sz))         (* and make a 'grow' upcall there. *)\n-;;\n-\n-let stack_growth_check\n-    (e:Il.emitter)\n-    (nabi:nabi)\n-    (grow_task_fixup:fixup)\n-    (growsz:Il.operand)\n-    (grow_jmp:Il.label option)\n-    (restart_pc:Il.label)\n-    (end_reg:Il.reg)              (* \n-                                   * stack limit on entry,\n-                                   * new stack pointer on exit \n-                                   *)\n-    (tmp_reg:Il.reg)              (* temporary (trashed) *)\n-    : unit =\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let add dst src = emit (Il.binary Il.ADD dst (Il.Cell dst) src) in\n-  let sub dst src = emit (Il.binary Il.SUB dst (Il.Cell dst) src) in\n-    mov (r tmp_reg) (ro esp);         (* tmp = esp                 *)\n-    sub (r tmp_reg) growsz;           (* tmp -= size-request       *)\n-    emit (Il.cmp (c (r end_reg)) (c (r tmp_reg)));\n-    (* \n-     * Jump *over* 'grow' upcall on non-underflow:\n-     * if end_reg <= tmp_reg\n-     *)\n-\n-    let bypass_grow_upcall_jmp_pc = e.Il.emit_pc in\n-      emit (Il.jmp Il.JBE Il.CodeNone);\n-\n-      begin\n-        match grow_jmp with\n-            None -> ()\n-          | Some j -> Il.patch_jump e j e.Il.emit_pc\n-      end;\n-      (* Extract growth-amount from tmp_reg. *)\n-      mov (r end_reg) (ro esp);\n-      sub (r end_reg) (c (r tmp_reg));\n-      add (r end_reg) (Il.Imm (boundary_sz, word_ty));\n-      (* Perform 'grow' upcall, then restart frame-entry. *)\n-      emit_void_prologue_call e nabi grow_task_fixup [| c (r end_reg) |];\n-      emit (Il.jmp Il.JMP (Il.CodeLabel restart_pc));\n-      Il.patch_jump e bypass_grow_upcall_jmp_pc e.Il.emit_pc\n-;;\n-\n-let n_glue_args = Int64.of_int Abi.worst_case_glue_call_args;;\n-let n_glue_words = Int64.mul word_sz n_glue_args;;\n-\n-let combined_frame_size\n-    (framesz:size)\n-    (callsz:size)\n-    : size =\n-  (*\n-   * We double the reserved callsz because we need a 'temporary tail-call\n-   * region' above the actual call region, in case there's a drop call at the\n-   * end of assembling the tail-call args and before copying them to callee\n-   * position.\n-   *)\n-\n-  let callsz = add_sz callsz callsz in\n-\n-  (*\n-   * Add in *another* word to handle an extra-awkward spill of the\n-   * callee address that might occur during an indirect tail call.\n-   *)\n-  let callsz = add_sz (SIZE_fixed word_sz) callsz in\n-\n-  (*\n-   * Add in enough words for a glue-call (these occur underneath esp)\n-   *)\n-  let callsz = add_sz (SIZE_fixed n_glue_words) callsz in\n-\n-    add_sz callsz framesz\n-;;\n-\n-let minimal_fn_prologue\n-    (e:Il.emitter)\n-    (call_and_frame_sz:Asm.expr64)\n-    : unit =\n-\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let add dst src = emit (Il.binary Il.ADD dst (Il.Cell dst) src) in\n-  let sub dst src = emit (Il.binary Il.SUB dst (Il.Cell dst) src) in\n-\n-    (* See diagram and explanation in full_fn_prologue, below.    *)\n-    establish_frame_base e;\n-    save_callee_saves e;\n-    sub (rc esp) (imm call_and_frame_sz);  (* Establish a frame.     *)\n-    mov (rc edi) (ro esp);                 (* Zero the frame. *)\n-    mov (rc ecx) (imm call_and_frame_sz);\n-    emit (Il.unary Il.ZERO (word_at (h edi)) (ro ecx));\n-    (* Move esp back up over the glue region. *)\n-    add (rc esp) (immi n_glue_words);\n-;;\n-\n-let full_fn_prologue\n-    (e:Il.emitter)\n-    (call_and_frame_sz:size)\n-    (nabi:nabi)\n-    (grow_task_fixup:fixup)\n-    (is_obj_fn:bool)\n-    : unit =\n-\n-  let esi_n = word_n (h esi) in\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let add dst src = emit (Il.binary Il.ADD dst (Il.Cell dst) src) in\n-  let sub dst src = emit (Il.binary Il.SUB dst (Il.Cell dst) src) in\n-\n-  (* We may be in a dynamic-sized frame. This makes matters complex,\n-   * as we can't just perform a simple growth check in terms of a\n-   * static size. The check is against a dynamic size, and we need to\n-   * calculate that size.\n-   *\n-   * Unlike size-calculations in 'trans', we do not use vregs to\n-   * calculate the frame size; instead we use a PUSH/POP stack-machine\n-   * translation that doesn't disturb the registers we're\n-   * somewhat-carefully *using* during frame setup.\n-   *\n-   * This only pushes the problem back a little ways though: we still\n-   * need to be sure we have enough room to do the PUSH/POP\n-   * calculation.  We refer to this amount of space as the 'primordial'\n-   * frame size, which can *thankfully* be calculated exactly from the\n-   * arithmetic expression we're aiming to calculate. So we make room\n-   * for the primordial frame, run the calculation of the full dynamic\n-   * frame size, then make room *again* for this dynamic size.\n-   *\n-   * Our caller reserved enough room for us to push our own frame-base,\n-   * as well as the frame-base that it will cost to do an upcall.\n-   *)\n-\n-  (*\n-   *  After we save callee-saves, We have a stack like this:\n-   *\n-   *  | ...           |\n-   *  | caller frame  |\n-   *  | + spill       |\n-   *  | caller arg K  |\n-   *  | ...           |\n-   *  | caller arg 0  |\n-   *  | retpc         | <-- sp we received, top of callee frame\n-   *  | callee save 1 | <-- ebp after frame-base setup\n-   *  | ...           |\n-   *  | callee save N | <-- esp after saving callee-saves\n-   *  | ...           |\n-   *  | callee frame  |\n-   *  | + spill       |\n-   *  | callee arg J  |\n-   *  | ...           |\n-   *  | callee arg 0  | <-- bottom of callee frame\n-   *  | next retpc    |\n-   *  | next save 1   |\n-   *  | ...           |\n-   *  | next save N   | <-- bottom of region we must reserve\n-   *  | ...           |\n-   *\n-   * A \"frame base\" is the retpc + ebp.\n-   *\n-   * We need to reserve room for our frame *and* the next frame-base and\n-   * callee-saves, because we're going to be blindly entering the next\n-   * frame-base (pushing eip and callee-saves) before we perform the next\n-   * check.\n-   *)\n-\n-    (* Already have room to save regs on entry. *)\n-    establish_frame_base e;\n-    save_callee_saves e;\n-\n-    let restart_pc = e.Il.emit_pc in\n-\n-      mov (rc esi) (c task_ptr);         (* esi = task                *)\n-      mov\n-        (rc esi)\n-        (c (esi_n Abi.task_field_stk));  (* esi = task->stk           *)\n-      add (rc esi) (imm\n-                      (Asm.ADD\n-                         ((word_off_n Abi.stk_field_data),\n-                          boundary_sz)));\n-\n-      let (dynamic_frame_sz, dynamic_grow_jmp) =\n-        match Il.size_to_expr64 call_and_frame_sz with\n-            None ->\n-              begin\n-                let primordial_frame_sz =\n-                  Asm.IMM\n-                    (Int64.mul word_sz\n-                       (Int64.of_int\n-                          (size_calculation_stack_highwater\n-                             call_and_frame_sz)))\n-                in\n-                  (* Primordial size-check. *)\n-                  mov (rc edi) (ro esp);  (* edi = esp            *)\n-                  sub                     (* edi -= size-request  *)\n-                    (rc edi)\n-                    (imm primordial_frame_sz);\n-                  emit (Il.cmp (ro esi) (ro edi));\n-\n-                  (* Jump to 'grow' upcall on underflow: if esi (bottom) is >\n-                     edi (proposed-esp) *)\n-\n-                  let primordial_underflow_jmp_pc = e.Il.emit_pc in\n-                    emit (Il.jmp Il.JA Il.CodeNone);\n-\n-                    (* Calculate dynamic frame size. *)\n-                    calculate_sz e call_and_frame_sz is_obj_fn;\n-                    ((ro eax), Some primordial_underflow_jmp_pc)\n-              end\n-          | Some e -> ((imm e), None)\n-      in\n-\n-        (* \"Full\" frame size-check. *)\n-        stack_growth_check e nabi grow_task_fixup\n-          dynamic_frame_sz dynamic_grow_jmp restart_pc (h esi) (h edi);\n-\n-        (* Establish a frame, wherever we landed. *)\n-        sub (rc esp) dynamic_frame_sz;\n-\n-        (* Zero the frame.\n-         * \n-         * FIXME (ssue 27): this is awful, will go away when we have proper\n-         * CFI.\n-         *)\n-\n-        mov (rc edi) (ro esp);\n-        mov (rc ecx) dynamic_frame_sz;\n-        emit (Il.unary Il.ZERO (word_at (h edi)) (ro ecx));\n-\n-        (* Move esp back up over the glue region. *)\n-        add (rc esp) (immi n_glue_words);\n-;;\n-\n-let fn_prologue\n-    (e:Il.emitter)\n-    (framesz:size)\n-    (callsz:size)\n-    (nabi:nabi)\n-    (grow_task_fixup:fixup)\n-    (is_obj_fn:bool)\n-    (minimal:bool)\n-    : unit =\n-\n-  let call_and_frame_sz = combined_frame_size framesz callsz in\n-\n-  let full _ =\n-    full_fn_prologue e call_and_frame_sz nabi grow_task_fixup is_obj_fn\n-  in\n-\n-    if minimal\n-    then\n-      match Il.size_to_expr64 call_and_frame_sz with\n-          None -> full()\n-        | Some sz -> minimal_fn_prologue e sz\n-    else\n-      full()\n-;;\n-\n-let fn_epilogue (e:Il.emitter) : unit =\n-  (* Tear down existing frame. *)\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let sub dst src = emit (Il.binary Il.SUB dst (Il.Cell dst) src) in\n-    sub (rc ebp) (immi callee_saves_sz);\n-    mov (rc esp) (ro ebp);\n-    restore_callee_saves e;\n-    leave_frame e;\n-    emit Il.Ret;\n-;;\n-\n-let inline_memcpy\n-    (e:Il.emitter)\n-    (n_bytes:int64)\n-    (dst_ptr:Il.reg)\n-    (src_ptr:Il.reg)\n-    (tmp_reg:Il.reg)\n-    (ascending:bool)\n-    : unit =\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let bpw = Int64.to_int word_sz in\n-  let w = Int64.to_int (Int64.div n_bytes word_sz) in\n-  let b = Int64.to_int (Int64.rem n_bytes word_sz) in\n-    if ascending\n-    then\n-      begin\n-        for i = 0 to (w-1) do\n-          mov (r tmp_reg) (c (word_n src_ptr i));\n-          mov (word_n dst_ptr i) (c (r tmp_reg));\n-        done;\n-        for i = 0 to (b-1) do\n-          let off = (w*bpw) + i in\n-            mov (r tmp_reg) (c (byte_n src_ptr off));\n-            mov (byte_n dst_ptr off) (c (r tmp_reg));\n-        done;\n-      end\n-    else\n-      begin\n-        for i = (b-1) downto 0 do\n-          let off = (w*bpw) + i in\n-            mov (r tmp_reg) (c (byte_n src_ptr off));\n-            mov (byte_n dst_ptr off) (c (r tmp_reg));\n-        done;\n-        for i = (w-1) downto 0 do\n-          mov (r tmp_reg) (c (word_n src_ptr i));\n-          mov (word_n dst_ptr i) (c (r tmp_reg));\n-        done;\n-      end\n-;;\n-\n-\n-\n-let fn_tail_call\n-    (e:Il.emitter)\n-    (caller_callsz:int64)\n-    (caller_argsz:int64)\n-    (callee_code:Il.code)\n-    (callee_argsz:int64)\n-    : unit =\n-  let emit = Il.emit e in\n-  let binary op dst imm = emit (Il.binary op dst (c dst) (immi imm)) in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let argsz_diff = Int64.sub caller_argsz callee_argsz in\n-  let callee_spill_cell = word_at_off (h esp) (Asm.IMM caller_callsz) in\n-\n-    (*\n-     * Our outgoing arguments were prepared in a region above the call region;\n-     * this is reserved for the purpose of making tail-calls *only*, so we do\n-     * not collide with glue calls we had to make while dropping the frame,\n-     * after assembling our arg region.\n-     *\n-     * Thus, esp points to the \"normal\" arg region, and we need to move it\n-     * to point to the tail-call arg region. To make matters simple, both\n-     * regions are the same size, one atop the other.\n-     *)\n-\n-    annotate e \"tail call: move esp to temporary tail call arg-prep area\";\n-    binary Il.ADD (rc esp) caller_callsz;\n-\n-    (*\n-     * If we're given a non-ImmPtr callee, we may need to move it to a known\n-     * cell to avoid clobbering its register while we do the argument shuffle\n-     * below.\n-     *\n-     * Sadly, we are too register-starved to just flush our callee to a reg;\n-     * so we carve out an extra word of the temporary call-region and use\n-     * it.\n-     *\n-     * This is ridiculous, but works.\n-     *)\n-    begin\n-      match callee_code with\n-          Il.CodePtr (Il.Cell c) ->\n-              annotate e \"tail call: spill callee-ptr to temporary memory\";\n-              mov callee_spill_cell (Il.Cell c);\n-\n-        | _ -> ()\n-    end;\n-\n-    (* edx <- ebp; restore ebp, edi, esi, ebx; ecx <- retpc *)\n-    annotate e \"tail call: restore registers from frame base\";\n-    restore_frame_regs e (h edx) (h ecx);\n-    (* move edx past frame base and adjust for difference in call sizes *)\n-    annotate e \"tail call: adjust temporary fp\";\n-    binary Il.ADD (rc edx) (Int64.add frame_base_sz argsz_diff);\n-\n-    (*\n-     * stack grows downwards; copy from high to low\n-     *\n-     *   bpw = word_sz\n-     *   w = floor(callee_argsz / word_sz)\n-     *   b = callee_argsz % word_sz\n-     *\n-     * byte copies:\n-     *   +------------------------+\n-     *   |                        |\n-     *   +------------------------+ <-- base + (w * word_sz) + (b - 1)\n-     *   .                        .\n-     *   +------------------------+\n-     *   |                        |\n-     *   +------------------------+ <-- base + (w * word_sz) + (b - b)\n-     * word copies:                     =\n-     *   +------------------------+ <-- base + ((w-0) * word_sz)\n-     *   | bytes                  |\n-     *   | (w-1)*bpw..w*bpw-1     |\n-     *   +------------------------+ <-- base + ((w-1) * word_sz)\n-     *   | bytes                  |\n-     *   | (w-2)*bpw..(w-1)*bpw-1 |\n-     *   +------------------------+ <-- base + ((w-2) * word_sz)\n-     *   .                        .\n-     *   .                        .\n-     *   .                        .\n-     *   +------------------------+\n-     *   | bytes                  |\n-     *   | 0..bpw - 1             |\n-     *   +------------------------+ <-- base + ((w-w) * word_sz)\n-     *)\n-\n-    annotate e \"tail call: move arg-tuple up to top of frame\";\n-    (* NOTE: must copy top-to-bottom in case the regions overlap *)\n-    inline_memcpy e callee_argsz (h edx) (h esp) (h eax) false;\n-\n-    (*\n-     * We're done with eax now; so in the case where we had to spill\n-     * our callee codeptr, we can reload it into eax here and rewrite\n-     * our callee into *eax.\n-     *)\n-    let callee_code =\n-      match callee_code with\n-          Il.CodePtr (Il.Cell _) ->\n-              annotate e \"tail call: reload callee-ptr from temporary memory\";\n-              mov (rc eax) (Il.Cell callee_spill_cell);\n-              reg_codeptr (h eax)\n-\n-        | _ -> callee_code\n-    in\n-\n-\n-    (* esp <- edx *)\n-    annotate e \"tail call: adjust stack pointer\";\n-    mov (rc esp) (ro edx);\n-    (* PUSH ecx (retpc) *)\n-    annotate e \"tail call: push retpc\";\n-    emit (Il.Push (ro ecx));\n-    (* JMP callee_code *)\n-    emit (Il.jmp Il.JMP callee_code);\n-;;\n-\n-\n-let activate_glue (e:Il.emitter) : unit =\n-  (*\n-   * This is a bit of glue-code. It should be emitted once per\n-   * compilation unit.\n-   *\n-   *   - save regs on C stack\n-   *   - align sp on a 16-byte boundary\n-   *   - save sp to task.runtime_sp (runtime_sp is thus always aligned)\n-   *   - load saved task sp (switch stack)\n-   *   - restore saved task regs\n-   *   - return to saved task pc\n-   *\n-   * Our incoming stack looks like this:\n-   *\n-   *   *esp+4        = [arg1   ] = task ptr\n-   *   *esp          = [retpc  ]\n-   *)\n-\n-  let sp_n = word_n (Il.Hreg esp) in\n-  let edx_n = word_n (Il.Hreg edx) in\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let binary op dst imm = emit (Il.binary op dst (c dst) (immi imm)) in\n-\n-    mov (rc edx) (c (sp_n 1));            (* edx <- task             *)\n-    establish_frame_base e;\n-    save_callee_saves e;\n-    mov\n-      (edx_n Abi.task_field_runtime_sp)\n-      (ro esp);                           (* task->runtime_sp <- esp *)\n-    mov\n-      (rc esp)\n-      (c (edx_n Abi.task_field_rust_sp)); (* esp <- task->rust_sp    *)\n-\n-    (*\n-     * There are two paths we can arrive at this code from:\n-     *\n-     *\n-     *   1. We are activating a task for the first time. When we switch into\n-     *      the task stack and 'ret' to its first instruction, we'll start\n-     *      doing whatever the first instruction says. Probably saving\n-     *      registers and starting to establish a frame. Harmless stuff,\n-     *      doesn't look at task->rust_sp again except when it clobbers it\n-     *      during a later upcall.\n-     *\n-     *\n-     *   2. We are resuming a task that was descheduled by the yield glue\n-     *      below.  When we switch into the task stack and 'ret', we'll be\n-     *      ret'ing to a very particular instruction:\n-     *\n-     *              \"esp <- task->rust_sp\"\n-     *\n-     *      this is the first instruction we 'ret' to after this glue, because\n-     *      it is the first instruction following *any* upcall, and the task\n-     *      we are activating was descheduled mid-upcall.\n-     *\n-     *      Unfortunately for us, we have already restored esp from\n-     *      task->rust_sp and are about to eat the 5 words off the top of it.\n-     *\n-     *\n-     *      | ...    | <-- where esp will be once we restore + ret, below,\n-     *      | retpc  |     and where we'd *like* task->rust_sp to wind up.\n-     *      | ebp    |\n-     *      | edi    |\n-     *      | esi    |\n-     *      | ebx    | <-- current task->rust_sp == current esp\n-     *\n-     * \n-     *      This is a problem. If we return to \"esp <- task->rust_sp\" it will\n-     *      push esp back down by 5 words. This manifests as a rust stack that\n-     *      grows by 5 words on each yield/reactivate. Not good.\n-     * \n-     *      So what we do here is just adjust task->rust_sp up 5 words as\n-     *      well, to mirror the movement in esp we're about to perform. That\n-     *      way the \"esp <- task->rust_sp\" we 'ret' to below will be a\n-     *      no-op. Esp won't move, and the task's stack won't grow.\n-     *)\n-\n-    binary Il.ADD (edx_n Abi.task_field_rust_sp)\n-      (Int64.mul (Int64.of_int (n_callee_saves + 2)) word_sz);\n-\n-    (**** IN TASK STACK ****)\n-    restore_callee_saves e;\n-    leave_frame e;\n-    emit Il.Ret;\n-    (***********************)\n-  ()\n-;;\n-\n-let yield_glue (e:Il.emitter) : unit =\n-\n-  (* More glue code, this time the 'bottom half' of yielding.\n-   *\n-   * We arrived here because an upcall decided to deschedule the\n-   * running task. So the upcall's return address got patched to the\n-   * first instruction of this glue code.\n-   *\n-   * When the upcall does 'ret' it will come here, and its esp will be\n-   * pointing to the last argument pushed on the C stack before making\n-   * the upcall: the 0th argument to the upcall, which is always the\n-   * task ptr performing the upcall. That's where we take over.\n-   *\n-   * Our goal is to complete the descheduling\n-   *\n-   *   - Switch over to the task stack temporarily.\n-   *\n-   *   - Save the task's callee-saves onto the task stack.\n-   *     (the task is now 'descheduled', safe to set aside)\n-   *\n-   *   - Switch *back* to the C stack.\n-   *\n-   *   - Restore the C-stack callee-saves.\n-   *\n-   *   - Return to the caller on the C stack that activated the task.\n-   *\n-   *)\n-  let esp_n = word_n (Il.Hreg esp) in\n-  let edx_n = word_n (Il.Hreg edx) in\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-\n-    mov\n-      (rc edx) (c (esp_n 0));                (* edx <- arg0 (task)      *)\n-    mov\n-      (rc esp)\n-      (c (edx_n Abi.task_field_rust_sp));    (* esp <- task->rust_sp    *)\n-    establish_frame_base e;\n-    save_callee_saves e;\n-    mov                                      (* task->rust_sp <- esp    *)\n-      (edx_n Abi.task_field_rust_sp)\n-      (ro esp);\n-    mov\n-      (rc esp)\n-      (c (edx_n Abi.task_field_runtime_sp)); (* esp <- task->runtime_sp *)\n-\n-    (**** IN C STACK ****)\n-    restore_callee_saves e;\n-    leave_frame e;\n-    emit Il.Ret;\n-    (***********************)\n-  ()\n-;;\n-\n-\n-let push_pos32 (e:Il.emitter) (fix:fixup) : unit =\n-  let (reg, _, _) = get_next_pc_thunk in\n-    Abi.load_fixup_addr e reg fix Il.OpaqueTy;\n-    Il.emit e (Il.Push (Il.Cell (Il.Reg (reg, Il.AddrTy Il.OpaqueTy))))\n-;;\n-\n-let objfile_start\n-    (e:Il.emitter)\n-    ~(start_fixup:fixup)\n-    ~(rust_start_fixup:fixup)\n-    ~(main_fn_fixup:fixup)\n-    ~(crate_fixup:fixup)\n-    ~(indirect_start:bool)\n-    : unit =\n-  let ebp_n = word_n (Il.Hreg ebp) in\n-  let emit = Il.emit e in\n-  let mov dst src = emit (Il.umov dst src) in\n-  let push_pos32 = push_pos32 e in\n-    Il.emit_full e (Some start_fixup) Il.Dead;\n-    establish_frame_base e;\n-    save_callee_saves e;\n-\n-    (* If we're very lucky, the platform will have left us with\n-     * something sensible in the startup stack like so:\n-     * \n-     *   *ebp+12       = [arg1   ] = argv\n-     *   *ebp+8        = [arg0   ] = argc\n-     *   *ebp+4        = [retpc  ]\n-     *   *ebp          = [old_ebp]\n-     *   *ebp-4        = [old_edi]\n-     *   *ebp-8        = [old_esi]\n-     *   *ebp-12       = [old_ebx]\n-     * \n-     * This is not the case everywhere, but we start with this\n-     * assumption and correct it in the runtime library.\n-     *)\n-\n-    (* Copy argv. *)\n-    mov (rc eax) (c (ebp_n 3));\n-    Il.emit e (Il.Push (ro eax));\n-\n-    (* Copy argc. *)\n-    mov (rc eax) (c (ebp_n 2));\n-    Il.emit e (Il.Push (ro eax));\n-\n-    push_pos32 crate_fixup;\n-    push_pos32 main_fn_fixup;\n-    let fptr =\n-      Abi.load_fixup_codeptr e (h eax) rust_start_fixup true indirect_start\n-    in\n-      Il.emit e (Il.call (rc eax) fptr);\n-      Il.emit e (Il.Pop (rc ecx));\n-      Il.emit e (Il.Pop (rc ecx));\n-      Il.emit e (Il.Pop (rc ecx));\n-      Il.emit e (Il.Pop (rc ecx));\n-      restore_callee_saves e;\n-      leave_frame e;\n-      Il.emit e Il.Ret;\n-;;\n-\n-let (abi:Abi.abi) =\n-  {\n-    Abi.abi_word_sz = word_sz;\n-    Abi.abi_word_bits = word_bits;\n-    Abi.abi_word_ty = word_ty;\n-\n-    Abi.abi_tag = Abi.abi_x86_rustboot_cdecl;\n-\n-    Abi.abi_has_pcrel_data = false;\n-    Abi.abi_has_pcrel_code = true;\n-\n-    Abi.abi_n_hardregs = n_hardregs;\n-    Abi.abi_str_of_hardreg = reg_str;\n-    Abi.abi_emit_target_specific = emit_target_specific;\n-    Abi.abi_constrain_vregs = constrain_vregs;\n-\n-    Abi.abi_emit_fn_prologue = fn_prologue;\n-    Abi.abi_emit_fn_epilogue = fn_epilogue;\n-    Abi.abi_emit_fn_tail_call = fn_tail_call;\n-    Abi.abi_clobbers = clobbers;\n-\n-    Abi.abi_emit_native_call = emit_native_call;\n-    Abi.abi_emit_native_void_call = emit_native_void_call;\n-    Abi.abi_emit_native_call_in_thunk = emit_native_call_in_thunk;\n-    Abi.abi_emit_inline_memcpy = inline_memcpy;\n-\n-    Abi.abi_activate = activate_glue;\n-    Abi.abi_yield = yield_glue;\n-    Abi.abi_unwind = unwind_glue;\n-    Abi.abi_gc = gc_glue;\n-    Abi.abi_get_next_pc_thunk = Some get_next_pc_thunk;\n-\n-    Abi.abi_sp_reg = (Il.Hreg esp);\n-    Abi.abi_fp_reg = (Il.Hreg ebp);\n-    Abi.abi_dwarf_fp_reg = dwarf_ebp;\n-    Abi.abi_tp_cell = task_ptr;\n-    Abi.abi_frame_base_sz = frame_base_sz;\n-    Abi.abi_callee_saves_sz = callee_saves_sz;\n-    Abi.abi_frame_info_sz = frame_info_sz;\n-    Abi.abi_implicit_args_sz = implicit_args_sz;\n-    Abi.abi_spill_slot = spill_slot;\n-  }\n-\n-\n-(*\n- * NB: factor the instruction selector often. There's lots of\n- * semi-redundancy in the ISA.\n- *)\n-\n-\n-let imm_is_signed_byte (n:int64) : bool =\n-  (i64_le (-128L) n) && (i64_le n 127L)\n-;;\n-\n-let imm_is_unsigned_byte (n:int64) : bool =\n-  (i64_le (0L) n) && (i64_le n 255L)\n-;;\n-\n-\n-let rm_r (c:Il.cell) (r:int) : Asm.frag =\n-  let reg_ebp = 6 in\n-  let reg_esp = 7 in\n-\n-  (*\n-   * We do a little contortion here to accommodate the special case of\n-   * being asked to form esp-relative addresses; these require SIB\n-   * bytes on x86. Of course!\n-   *)\n-  let sib_esp_base = Asm.BYTE 0x24 in\n-  let seq1 rm modrm =\n-    if rm = reg_esp\n-    then Asm.SEQ [| modrm; sib_esp_base |]\n-    else modrm\n-  in\n-  let seq2 rm modrm disp =\n-    if rm = reg_esp\n-    then Asm.SEQ [| modrm; sib_esp_base; disp |]\n-    else Asm.SEQ [| modrm; disp |]\n-  in\n-\n-    match c with\n-        Il.Reg ((Il.Hreg rm), _) ->\n-          Asm.BYTE (modrm_reg (reg rm) r)\n-      | Il.Mem (a, _) ->\n-          begin\n-            match a with\n-                Il.Abs disp ->\n-                  Asm.SEQ [| Asm.BYTE (modrm_deref_disp32 r);\n-                             Asm.WORD (TY_i32, disp) |]\n-\n-              | Il.RegIn ((Il.Hreg rm), None) when rm != reg_ebp ->\n-                  seq1 rm (Asm.BYTE (modrm_deref_reg (reg rm) r))\n-\n-              | Il.RegIn ((Il.Hreg rm), Some (Asm.IMM 0L))\n-                  when rm != reg_ebp ->\n-                  seq1 rm (Asm.BYTE (modrm_deref_reg (reg rm) r))\n-\n-              (* The next two are just to save the relaxation system some\n-               * churn.\n-               *)\n-\n-              | Il.RegIn ((Il.Hreg rm), Some (Asm.IMM n))\n-                  when imm_is_signed_byte n ->\n-                  seq2 rm\n-                    (Asm.BYTE (modrm_deref_reg_plus_disp8 (reg rm) r))\n-                    (Asm.WORD (TY_i8, Asm.IMM n))\n-\n-              | Il.RegIn ((Il.Hreg rm), Some (Asm.IMM n)) ->\n-                  seq2 rm\n-                    (Asm.BYTE (modrm_deref_reg_plus_disp32 (reg rm) r))\n-                    (Asm.WORD (TY_i32, Asm.IMM n))\n-\n-              | Il.RegIn ((Il.Hreg rm), Some disp) ->\n-                  Asm.new_relaxation\n-                    [|\n-                      seq2 rm\n-                        (Asm.BYTE (modrm_deref_reg_plus_disp32 (reg rm) r))\n-                        (Asm.WORD (TY_i32, disp));\n-                      seq2 rm\n-                        (Asm.BYTE (modrm_deref_reg_plus_disp8 (reg rm) r))\n-                        (Asm.WORD (TY_i8, disp))\n-                    |]\n-              | _ -> raise Unrecognized\n-          end\n-      | _ -> raise Unrecognized\n-;;\n-\n-\n-let insn_rm_r (op:int) (c:Il.cell) (r:int) : Asm.frag =\n-  Asm.SEQ [| Asm.BYTE op; rm_r c r |]\n-;;\n-\n-\n-let insn_rm_r_imm\n-    (op:int)\n-    (c:Il.cell)\n-    (r:int)\n-    (ty:ty_mach)\n-    (i:Asm.expr64)\n-    : Asm.frag =\n-  Asm.SEQ [| Asm.BYTE op; rm_r c r; Asm.WORD (ty, i) |]\n-;;\n-\n-let insn_rm_r_imm_s8_s32\n-    (op8:int)\n-    (op32:int)\n-    (c:Il.cell)\n-    (r:int)\n-    (i:Asm.expr64)\n-    : Asm.frag =\n-  match i with\n-      Asm.IMM n when imm_is_signed_byte n ->\n-        insn_rm_r_imm op8 c r TY_i8 i\n-    | _ ->\n-        Asm.new_relaxation\n-          [|\n-            insn_rm_r_imm op32 c r TY_i32 i;\n-            insn_rm_r_imm op8 c r TY_i8 i\n-          |]\n-;;\n-\n-let insn_rm_r_imm_u8_u32\n-    (op8:int)\n-    (op32:int)\n-    (c:Il.cell)\n-    (r:int)\n-    (i:Asm.expr64)\n-    : Asm.frag =\n-  match i with\n-      Asm.IMM n when imm_is_unsigned_byte n ->\n-        insn_rm_r_imm op8 c r TY_u8 i\n-    | _ ->\n-        Asm.new_relaxation\n-          [|\n-            insn_rm_r_imm op32 c r TY_u32 i;\n-            insn_rm_r_imm op8 c r TY_u8 i\n-          |]\n-;;\n-\n-\n-let insn_pcrel_relax\n-    (op8_frag:Asm.frag)\n-    (op32_frag:Asm.frag)\n-    (fix:fixup)\n-    : Asm.frag =\n-  let pcrel_mark_fixup = new_fixup \"pcrel mark fixup\" in\n-  let def = Asm.DEF (pcrel_mark_fixup, Asm.MARK) in\n-  let pcrel_expr = (Asm.SUB (Asm.M_POS fix,\n-                             Asm.M_POS pcrel_mark_fixup))\n-  in\n-    Asm.new_relaxation\n-      [|\n-        Asm.SEQ [| op32_frag; Asm.WORD (TY_i32, pcrel_expr); def |];\n-        Asm.SEQ [| op8_frag; Asm.WORD (TY_i8, pcrel_expr); def |];\n-      |]\n-;;\n-\n-let insn_pcrel_simple (op32:int) (fix:fixup) : Asm.frag =\n-  let pcrel_mark_fixup = new_fixup \"pcrel mark fixup\" in\n-  let def = Asm.DEF (pcrel_mark_fixup, Asm.MARK) in\n-  let pcrel_expr = (Asm.SUB (Asm.M_POS fix,\n-                             Asm.M_POS pcrel_mark_fixup))\n-  in\n-    Asm.SEQ [| Asm.BYTE op32; Asm.WORD (TY_i32, pcrel_expr); def |]\n-;;\n-\n-let insn_pcrel (op8:int) (op32:int) (fix:fixup) : Asm.frag =\n-  insn_pcrel_relax (Asm.BYTE op8) (Asm.BYTE op32) fix\n-;;\n-\n-let insn_pcrel_prefix32\n-    (op8:int)\n-    (prefix32:int)\n-    (op32:int)\n-    (fix:fixup)\n-    : Asm.frag =\n-  insn_pcrel_relax (Asm.BYTE op8) (Asm.BYTES [| prefix32; op32 |]) fix\n-;;\n-\n-(* FIXME: tighten imm-based dispatch by imm type. *)\n-let cmp (a:Il.operand) (b:Il.operand) : Asm.frag =\n-  match (a,b) with\n-      (Il.Cell c, Il.Imm (i, TY_i8)) when is_rm8 c ->\n-        insn_rm_r_imm 0x80 c slash7 TY_i8 i\n-    | (Il.Cell c, Il.Imm (i, TY_u8)) when is_rm8 c ->\n-        insn_rm_r_imm 0x80 c slash7 TY_u8 i\n-    | (Il.Cell c, Il.Imm (i, _)) when is_rm32 c ->\n-        (*\n-         * NB: We can't switch on signed-ness here, as 'cmp' is\n-         * defined to sign-extend its operand; i.e. we have to treat\n-         * it as though you're emitting a signed byte (in the sense of\n-         * immediate-size selection) even if the incoming value is\n-         * unsigned.\n-         *)\n-        insn_rm_r_imm_s8_s32 0x83 0x81 c slash7 i\n-    | (Il.Cell c, Il.Cell (Il.Reg (Il.Hreg r, _))) ->\n-        insn_rm_r 0x39 c (reg r)\n-    | (Il.Cell (Il.Reg (Il.Hreg r, _)), Il.Cell c) ->\n-        insn_rm_r 0x3b c (reg r)\n-    | _ -> raise Unrecognized\n-;;\n-\n-let zero (dst:Il.cell) (count:Il.operand) : Asm.frag =\n-  match (dst, count) with\n-\n-      ((Il.Mem (Il.RegIn ((Il.Hreg dst_ptr), None), _)),\n-       Il.Cell (Il.Reg ((Il.Hreg count), _)))\n-        when dst_ptr = edi && count = ecx ->\n-          Asm.BYTES [|\n-            0xb0; 0x0;  (* mov %eax, 0 : move a zero into al. *)\n-            0xf3; 0xaa; (* rep stos m8 : fill ecx bytes at [edi] with al *)\n-          |]\n-\n-    | _ -> raise Unrecognized\n-;;\n-\n-let mov (signed:bool) (dst:Il.cell) (src:Il.operand) : Asm.frag =\n-  if is_ty8 (Il.cell_scalar_ty dst)\n-  then\n-    begin\n-      match dst with\n-          Il.Reg (Il.Hreg r, _) -> assert (is_ok_r8 r)\n-        | _ -> ()\n-    end;\n-\n-  if is_ty8 (Il.operand_scalar_ty src)\n-  then\n-    begin\n-      match src with\n-          Il.Cell (Il.Reg (Il.Hreg r, _)) -> assert (is_ok_r8 r)\n-        | _ -> ()\n-    end;\n-\n-  match (signed, dst, src) with\n-\n-      (* m8 <- r??, r8 or truncate(r32). *)\n-      (_,  _, Il.Cell (Il.Reg ((Il.Hreg r), _)))\n-        when is_m8 dst ->\n-          insn_rm_r 0x88 dst (reg r)\n-\n-    (* r8 <- r8: treat as r32 <- r32. *)\n-    | (_,  Il.Reg ((Il.Hreg r), _), Il.Cell src_cell)\n-        when is_r8 dst && is_r8 src_cell ->\n-        insn_rm_r 0x8b src_cell (reg r)\n-\n-    (* rm32 <- r32 *)\n-    | (_,  _, Il.Cell (Il.Reg ((Il.Hreg r), src_ty)))\n-        when (is_r8 dst || is_rm32 dst) && is_ty32 src_ty ->\n-        insn_rm_r 0x89 dst (reg r)\n-\n-    (* r32 <- rm32 *)\n-    | (_,  (Il.Reg ((Il.Hreg r), dst_ty)), Il.Cell src_cell)\n-        when is_ty32 dst_ty && is_rm32 src_cell ->\n-          insn_rm_r 0x8b src_cell (reg r)\n-\n-    (* MOVZX: r8/r32 <- zx(rm8) *)\n-    | (false, Il.Reg ((Il.Hreg r, _)), Il.Cell src_cell)\n-        when (is_r8 dst || is_r32 dst) && is_rm8 src_cell ->\n-        Asm.SEQ [| Asm.BYTE 0x0f;\n-                   insn_rm_r 0xb6 src_cell (reg r) |]\n-\n-    (* MOVZX: m32 <- zx(r8) *)\n-    | (false, _, (Il.Cell (Il.Reg ((Il.Hreg r), _) as src_cell)))\n-        when (is_m32 dst) && is_r8 src_cell ->\n-        (* Fake with 2 insns:\n-         *\n-         * movzx r32 <- r8;   (in-place zero-extension)\n-         * mov m32 <- r32;    (NB: must happen in AL/CL/DL/BL)\n-         *)\n-        Asm.SEQ [| Asm.BYTE 0x0f;\n-                   insn_rm_r 0xb6 src_cell (reg r);\n-                   insn_rm_r 0x89 dst (reg r);\n-                |]\n-\n-    (* MOVSX: r8/r32 <- sx(rm8) *)\n-    | (true, Il.Reg ((Il.Hreg r), _), Il.Cell src_cell)\n-        when (is_r8 dst || is_r32 dst) && is_rm8 src_cell ->\n-        Asm.SEQ [| Asm.BYTE 0x0f;\n-                   insn_rm_r 0xbe src_cell (reg r) |]\n-\n-    (* MOVSX: m32 <- sx(r8) *)\n-    | (true, _, (Il.Cell (Il.Reg ((Il.Hreg r), _) as src_cell)))\n-        when (is_m32 dst) && is_r8 src_cell ->\n-        (* Fake with 2 insns:\n-         *\n-         * movsx r32 <- r8;   (in-place sign-extension)\n-         * mov m32 <- r32;    (NB: must happen in AL/CL/DL/BL)\n-         *)\n-        Asm.SEQ [| Asm.BYTE 0x0f;\n-                   insn_rm_r 0xbe src_cell (reg r);\n-                   insn_rm_r 0x89 dst (reg r);\n-                |]\n-\n-    (* m8 <- imm8 (signed) *)\n-    | (_, _, Il.Imm ((Asm.IMM n), _))\n-        when is_m8 dst && imm_is_signed_byte n && signed ->\n-          insn_rm_r_imm 0xc6 dst slash0 TY_i8 (Asm.IMM n)\n-\n-    (* m8 <- imm8 (unsigned) *)\n-    | (_, _, Il.Imm ((Asm.IMM n), _))\n-        when is_m8 dst && imm_is_unsigned_byte n && (not signed) ->\n-          insn_rm_r_imm 0xc6 dst slash0 TY_u8 (Asm.IMM n)\n-\n-    (* rm32 <- imm32 *)\n-    | (_, _, Il.Imm (i, _)) when is_rm32 dst || is_r8 dst ->\n-        let t = if signed then TY_i32 else TY_u32 in\n-          insn_rm_r_imm 0xc7 dst slash0 t i\n-\n-    | _ -> raise Unrecognized\n-;;\n-\n-\n-let lea (dst:Il.cell) (src:Il.operand) : Asm.frag =\n-  match (dst, src) with\n-      (Il.Reg ((Il.Hreg r), dst_ty),\n-       Il.Cell (Il.Mem (mem, _)))\n-        when is_ty32 dst_ty ->\n-          insn_rm_r 0x8d (Il.Mem (mem, Il.OpaqueTy)) (reg r)\n-\n-    | (Il.Reg ((Il.Hreg r), dst_ty),\n-       Il.ImmPtr (fix, _))\n-        when is_ty32 dst_ty && r = eax ->\n-        let anchor = new_fixup \"anchor\" in\n-        let fix_off = Asm.SUB ((Asm.M_POS fix),\n-                               (Asm.M_POS anchor))\n-        in\n-          (* NB: These instructions must come as a\n-           * cluster, w/o any separation.\n-           *)\n-          Asm.SEQ [|\n-            insn_pcrel_simple 0xe8 get_next_pc_thunk_fixup;\n-            Asm.DEF (anchor, insn_rm_r_imm 0x81 dst slash0 TY_i32 fix_off);\n-          |]\n-\n-    | _ -> raise Unrecognized\n-;;\n-\n-\n-let select_insn_misc (q:Il.quad') : Asm.frag =\n-\n-  match q with\n-      Il.Call c ->\n-        begin\n-          match c.Il.call_dst with\n-              Il.Reg ((Il.Hreg dst), _) when dst = eax ->\n-                begin\n-                  match c.Il.call_targ with\n-\n-                      Il.CodePtr (Il.Cell c)\n-                        when Il.cell_referent_ty c\n-                          = Il.ScalarTy (Il.AddrTy Il.CodeTy) ->\n-                        insn_rm_r 0xff c slash2\n-\n-                    | Il.CodePtr (Il.ImmPtr (f, Il.CodeTy)) ->\n-                        insn_pcrel_simple 0xe8 f\n-\n-                    | _ -> raise Unrecognized\n-                end\n-            | _ -> raise Unrecognized\n-        end\n-\n-    | Il.Push (Il.Cell (Il.Reg ((Il.Hreg r), t))) when is_ty32 t ->\n-        Asm.BYTE (0x50 + (reg r))\n-\n-    | Il.Push (Il.Cell c) when is_rm32 c ->\n-        insn_rm_r 0xff c slash6\n-\n-    | Il.Push (Il.Imm (Asm.IMM i, _)) when imm_is_unsigned_byte i ->\n-        Asm.SEQ [| Asm.BYTE 0x6a; Asm.WORD (TY_u8, (Asm.IMM i)) |]\n-\n-    | Il.Push (Il.Imm (i, _)) ->\n-        Asm.SEQ [| Asm.BYTE 0x68; Asm.WORD (TY_u32, i) |]\n-\n-    | Il.Pop (Il.Reg ((Il.Hreg r), t)) when is_ty32 t ->\n-        Asm.BYTE (0x58 + (reg r))\n-\n-    | Il.Pop c when is_rm32 c ->\n-        insn_rm_r 0x8f c slash0\n-\n-    | Il.Ret -> Asm.BYTE 0xc3\n-\n-    | Il.Jmp j ->\n-        begin\n-          match (j.Il.jmp_op, j.Il.jmp_targ) with\n-\n-              (Il.JMP, Il.CodePtr (Il.ImmPtr (f, Il.CodeTy))) ->\n-                insn_pcrel 0xeb 0xe9 f\n-\n-            | (Il.JMP, Il.CodePtr (Il.Cell c))\n-                when Il.cell_referent_ty c\n-                  = Il.ScalarTy (Il.AddrTy Il.CodeTy) ->\n-                insn_rm_r 0xff c slash4\n-\n-            (* FIXME: refactor this to handle cell-based jumps\n-             * if we ever need them. So far not. *)\n-            | (_, Il.CodePtr (Il.ImmPtr (f, Il.CodeTy))) ->\n-                let (op8, op32) =\n-                  match j.Il.jmp_op with\n-                    | Il.JC  -> (0x72, 0x82)\n-                    | Il.JNC -> (0x73, 0x83)\n-                    | Il.JZ  -> (0x74, 0x84)\n-                    | Il.JNZ -> (0x75, 0x85)\n-                    | Il.JO  -> (0x70, 0x80)\n-                    | Il.JNO -> (0x71, 0x81)\n-                    | Il.JE  -> (0x74, 0x84)\n-                    | Il.JNE -> (0x75, 0x85)\n-\n-                    | Il.JL  -> (0x7c, 0x8c)\n-                    | Il.JLE -> (0x7e, 0x8e)\n-                    | Il.JG  -> (0x7f, 0x8f)\n-                    | Il.JGE -> (0x7d, 0x8d)\n-\n-                    | Il.JB  -> (0x72, 0x82)\n-                    | Il.JBE -> (0x76, 0x86)\n-                    | Il.JA  -> (0x77, 0x87)\n-                    | Il.JAE -> (0x73, 0x83)\n-                    | _ -> raise Unrecognized\n-                in\n-                let prefix32 = 0x0f in\n-                  insn_pcrel_prefix32 op8 prefix32 op32 f\n-\n-            | _ -> raise Unrecognized\n-        end\n-\n-    | Il.Dead -> Asm.MARK\n-    | Il.Debug -> Asm.BYTES [| 0xcc |] (* int 3 *)\n-    | Il.Regfence -> Asm.MARK\n-    | Il.End -> Asm.BYTES [| 0x90 |]\n-    | Il.Nop -> Asm.BYTES [| 0x90 |]\n-    | _ -> raise Unrecognized\n-;;\n-\n-\n-type alu_binop_codes =\n-     {\n-       insn: string;\n-       immslash: int;    (* mod/rm \"slash\" code for imm-src variant *)\n-       rm_dst_op8: int;  (* opcode for 8-bit r/m dst variant *)\n-       rm_dst_op32: int; (* opcode for 32-bit r/m dst variant *)\n-       rm_src_op8: int;  (* opcode for 8-bit r/m src variant *)\n-       rm_src_op32: int; (* opcode for 32-bit r/m src variant *)\n-     }\n-;;\n-\n-let alu_binop\n-    (dst:Il.cell) (src:Il.operand) (codes:alu_binop_codes)\n-    : Asm.frag =\n-  match (dst, src) with\n-      (Il.Reg ((Il.Hreg r), dst_ty), Il.Cell c)\n-        when (is_ty32 dst_ty && is_rm32 c) || (is_ty8 dst_ty && is_rm8 c)\n-          -> insn_rm_r codes.rm_src_op32 c (reg r)\n-\n-    | (_, Il.Cell (Il.Reg ((Il.Hreg r), src_ty)))\n-        when (is_rm32 dst && is_ty32 src_ty) || (is_rm8 dst && is_ty8 src_ty)\n-          -> insn_rm_r codes.rm_dst_op32 dst (reg r)\n-\n-    | (_, Il.Imm (i, _)) when is_rm32 dst || is_rm8 dst\n-        -> insn_rm_r_imm_s8_s32 0x83 0x81 dst codes.immslash i\n-\n-    | _ -> raise Unrecognized\n-;;\n-\n-\n-let mul_like (src:Il.operand) (signed:bool) (slash:int)\n-    : Asm.frag =\n-  match src with\n-      Il.Cell src when is_rm32 src ->\n-        insn_rm_r 0xf7 src slash\n-\n-    | Il.Cell src when is_rm8 src ->\n-        insn_rm_r 0xf6 src slash\n-\n-    | Il.Imm (_, TY_u32)\n-    | Il.Imm (_, TY_i32) ->\n-        let tmp = Il.Reg ((Il.Hreg edx), Il.ValTy Il.Bits32) in\n-        Asm.SEQ [| mov signed tmp src;\n-                   insn_rm_r 0xf7 tmp slash |]\n-\n-    | Il.Imm (_, TY_u8)\n-    | Il.Imm (_, TY_i8) ->\n-        let tmp = Il.Reg ((Il.Hreg edx), Il.ValTy Il.Bits8) in\n-        Asm.SEQ [| mov signed tmp src;\n-                   insn_rm_r 0xf6 tmp slash |]\n-\n-    | _ -> raise Unrecognized\n-;;\n-\n-\n-let select_insn (q:Il.quad) : Asm.frag =\n-  match q.Il.quad_body with\n-      Il.Unary u ->\n-        let unop s =\n-          if u.Il.unary_src = Il.Cell u.Il.unary_dst\n-          then insn_rm_r 0xf7 u.Il.unary_dst s\n-          else raise Unrecognized\n-        in\n-          begin\n-            match u.Il.unary_op with\n-                Il.UMOV -> mov false u.Il.unary_dst u.Il.unary_src\n-              | Il.IMOV -> mov true u.Il.unary_dst u.Il.unary_src\n-              | Il.NEG -> unop slash3\n-              | Il.NOT -> unop slash2\n-              | Il.ZERO -> zero u.Il.unary_dst u.Il.unary_src\n-          end\n-\n-    | Il.Lea le -> lea le.Il.lea_dst le.Il.lea_src\n-\n-    | Il.Cmp c -> cmp c.Il.cmp_lhs c.Il.cmp_rhs\n-\n-    | Il.Binary b ->\n-        begin\n-          if Il.Cell b.Il.binary_dst = b.Il.binary_lhs\n-          then\n-            let binop = alu_binop b.Il.binary_dst b.Il.binary_rhs in\n-            let mulop = mul_like b.Il.binary_rhs in\n-\n-            let divop signed slash =\n-              Asm.SEQ [|\n-                (* xor edx edx, then mul_like. *)\n-                insn_rm_r 0x33 (rc edx) (reg edx);\n-                mul_like b.Il.binary_rhs signed slash\n-              |]\n-            in\n-\n-            let modop signed slash =\n-              Asm.SEQ [|\n-                (* divop, then mov remainder to eax instead. *)\n-                divop signed slash;\n-                mov false (rc eax) (ro edx)\n-              |]\n-            in\n-\n-            let shiftop slash =\n-              let src = b.Il.binary_rhs in\n-              let dst = b.Il.binary_dst in\n-              let mask i = Asm.AND (i, Asm.IMM 0xffL) in\n-              if is_rm8 dst\n-              then\n-                match src with\n-                    Il.Imm (i, _) ->\n-                      insn_rm_r_imm 0xC0 dst slash TY_u8 (mask i)\n-                  | Il.Cell (Il.Reg ((Il.Hreg r), _))\n-                      when r = ecx ->\n-                      Asm.SEQ [| Asm.BYTE 0xD2; rm_r dst slash |]\n-                  | _ -> raise Unrecognized\n-              else\n-                match src with\n-                    Il.Imm (i, _) ->\n-                        insn_rm_r_imm 0xC1 dst slash TY_u8 (mask i)\n-                  | Il.Cell (Il.Reg ((Il.Hreg r), _))\n-                      when r = ecx ->\n-                      Asm.SEQ [| Asm.BYTE 0xD3; rm_r dst slash |]\n-                  | _ -> raise Unrecognized\n-            in\n-\n-              match (b.Il.binary_dst, b.Il.binary_op) with\n-                  (_, Il.ADD) -> binop { insn=\"ADD\";\n-                                         immslash=slash0;\n-                                         rm_dst_op8=0x0;\n-                                         rm_dst_op32=0x1;\n-                                         rm_src_op8=0x2;\n-                                         rm_src_op32=0x3; }\n-                | (_, Il.SUB) -> binop { insn=\"SUB\";\n-                                         immslash=slash5;\n-                                         rm_dst_op8=0x28;\n-                                         rm_dst_op32=0x29;\n-                                         rm_src_op8=0x2a;\n-                                         rm_src_op32=0x2b; }\n-                | (_, Il.AND) -> binop { insn=\"AND\";\n-                                         immslash=slash4;\n-                                         rm_dst_op8=0x20;\n-                                         rm_dst_op32=0x21;\n-                                         rm_src_op8=0x22;\n-                                         rm_src_op32=0x23; }\n-                | (_, Il.OR) -> binop { insn=\"OR\";\n-                                        immslash=slash1;\n-                                        rm_dst_op8=0x08;\n-                                        rm_dst_op32=0x09;\n-                                        rm_src_op8=0x0a;\n-                                        rm_src_op32=0x0b; }\n-                | (_, Il.XOR) -> binop { insn=\"XOR\";\n-                                         immslash=slash6;\n-                                         rm_dst_op8=0x30;\n-                                         rm_dst_op32=0x31;\n-                                         rm_src_op8=0x32;\n-                                         rm_src_op32=0x33; }\n-\n-                | (_, Il.LSL) -> shiftop slash4\n-                | (_, Il.LSR) -> shiftop slash5\n-                | (_, Il.ASR) -> shiftop slash7\n-\n-                | (Il.Reg (Il.Hreg r, t), Il.UMUL)\n-                    when (is_ty32 t || is_ty8 t) && r = eax ->\n-                    mulop false slash4\n-\n-                | (Il.Reg (Il.Hreg r, t), Il.IMUL)\n-                    when (is_ty32 t || is_ty8 t) && r = eax ->\n-                    mulop true slash5\n-\n-                | (Il.Reg (Il.Hreg r, t), Il.UDIV)\n-                    when (is_ty32 t || is_ty8 t) && r = eax ->\n-                    divop false slash6\n-\n-                | (Il.Reg (Il.Hreg r, t), Il.IDIV)\n-                    when (is_ty32 t || is_ty8 t) && r = eax ->\n-                    divop true slash7\n-\n-                | (Il.Reg (Il.Hreg r, t), Il.UMOD)\n-                    when (is_ty32 t || is_ty8 t) && r = eax ->\n-                    modop false slash6\n-\n-                | (Il.Reg (Il.Hreg r, t), Il.IMOD)\n-                    when (is_ty32 t || is_ty8 t) && r = eax ->\n-                    modop true slash7\n-\n-                | _ -> raise Unrecognized\n-          else raise Unrecognized\n-        end\n-    | _ -> select_insn_misc q.Il.quad_body\n-;;\n-\n-\n-let new_emitter_without_vregs _ : Il.emitter =\n-  Il.new_emitter\n-    abi.Abi.abi_emit_target_specific\n-    false None\n-;;\n-\n-let select_insns (sess:Session.sess) (qs:Il.quads) : Asm.frag =\n-  let scopes = Stack.create () in\n-  let fixups = Stack.create () in\n-  let append frag =\n-    Queue.add frag (Stack.top scopes)\n-  in\n-  let pop_frags _ =\n-    Asm.SEQ (queue_to_arr (Stack.pop scopes))\n-  in\n-    ignore (Stack.push (Queue.create()) scopes);\n-    Array.iteri\n-      begin\n-        fun i q ->\n-          begin\n-            match q.Il.quad_fixup with\n-                None -> ()\n-              | Some f -> append (Asm.DEF (f, Asm.MARK))\n-          end;\n-          begin\n-            let qstr _ = Il.string_of_quad reg_str q in\n-              match q.Il.quad_body with\n-                  Il.Enter f ->\n-                    Stack.push f fixups;\n-                    Stack.push (Queue.create()) scopes;\n-                | Il.Leave ->\n-                    append (Asm.DEF (Stack.pop fixups, pop_frags ()))\n-                | _ ->\n-                    try\n-                      let _ =\n-                        iflog sess (fun _ ->\n-                                      log sess \"quad %d: %s\" i (qstr()))\n-                      in\n-                      let frag = select_insn q in\n-                      let _ =\n-                        iflog sess (fun _ ->\n-                                      log sess \"frag %d: %a\" i\n-                                        Asm.sprintf_frag frag)\n-                      in\n-                        append frag\n-                    with\n-                    Unrecognized ->\n-                      Session.fail sess\n-                        \"E:Assembly error: unrecognized quad %d: %s\\n%!\"\n-                        i (qstr());\n-                      ()\n-          end\n-      end\n-      qs;\n-      pop_frags()\n-;;\n-\n-let frags_of_emitted_quads (sess:Session.sess) (e:Il.emitter) : Asm.frag =\n-  let frag = select_insns sess e.Il.emit_quads in\n-    if sess.Session.sess_failed\n-    then raise Unrecognized\n-    else frag\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "fa7bee2f8593ab74d902628da316e6e2f43e163a", "filename": "src/boot/driver/glue.ml", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fdriver%2Fglue.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fdriver%2Fglue.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fglue.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,16 +0,0 @@\n-(*\n- * Glue, or lack thereof, for the standard x86 backend.\n- *)\n-\n-let alt_argspecs _ = [];;\n-let alt_pipeline _ _ _ = ();;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)\n-"}, {"sha": "113ed08643d34c6831be9ef8a9fd41afb69ac90e", "filename": "src/boot/driver/lib.ml", "status": "removed", "additions": 0, "deletions": 464, "changes": 464, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fdriver%2Flib.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fdriver%2Flib.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Flib.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,464 +0,0 @@\n-open Common;;\n-open Fmt;;\n-\n-let log (sess:Session.sess) =\n-  Session.log \"lib\"\n-    sess.Session.sess_log_lib\n-    sess.Session.sess_log_out\n-;;\n-\n-let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n-  if sess.Session.sess_log_lib\n-  then thunk ()\n-  else ()\n-;;\n-\n-(*\n- * Stuff associated with 'crate interfaces'.\n- * \n- * The interface of a crate used to be defined by the accompanying DWARF\n- * structure in the object file. This was an experiment -- we talked to\n- * DWARF hackers before hand and they thought it worth trying -- which did\n- * work, and had the advantage of economy of metadata-emitting, but several\n- * downsides:\n- *\n- *   - The reader -- which we want a copy of at runtime in the linker -- has\n- *     to know how to read DWARF. It's not the simplest format.\n- * \n- *   - The complexity of the encoding meant we didn't always keep pace with\n- *     the AST, and maintaining any degree of inter-change compatibility was\n- *     going ot be a serious challenge.\n- * \n- *   - Diagnostic tools are atrocious, as is the definition of\n- *     well-formedness. It's largely trial and error when talking to gdb,\n- *     say.\n- * \n- *   - Because it was doing double-duty as *driving linkage*, we were never\n- *     going to get to the linkage efficiency of native symbols (hash\n- *     lookup) anyway. Runtime linkage -- even when lazy -- really ought to\n- *     be fast.\n- * \n- *   - LLVM, our \"main\" backend (in rustc) does not really want to make\n- *     promises about preserving dwarf.\n- *\n- *   - LLVM also *is* going to emit native symbols; complete with relocs and\n- *     such.  We'd actually have to do *extra work* to inhibit that.\n- *\n- *   - Most tools are set up to think of DWARF as \"debug\", meaning\n- *     \"optional\", and may well strip it or otherwise mangle it.\n- *\n- *   - Many tools want native symbols anyways, and don't know how to look at\n- *     DWARF.\n- * \n- *   - All the tooling arguments go double on win32. Pretty much only\n- *     objdump and gdb understand DWARF-in-PE. Everything else is just blank\n- *     stares.\n- * \n- * For all these reasons we're moving to a self-made format for describing\n- * our interfaces. This will be stored in the .note.rust section as we\n- * presently store the meta tags. The encoding is ASCII-compatible (the set\n- * of \"numbers\" to encode is small enough, especially compared to dwarf,\n- * that we can just use a text form) and is very easy to read with a simple\n- * byte-at-a-time parser.\n- * \n- *)\n-\n-(*\n- * Encoding goals:\n- *\n- *   - Simple. Minimal state or read-ambiguity in reader.\n- *\n- *   - Compact. Shouldn't add a lot to the size of the binary to glue this\n- *     on to it.\n- *\n- *   - Front-end-y. Doesn't need to contain much beyond parse-level of the\n- *     crate's exported items; it'll be fed into the front-end of the\n- *     pipeline anyway. No need to have all types or names resolved.\n- *\n- *   - Testable. Human-legible and easy to identify/fix/test errors in.\n- *\n- *   - Very fast to read the 'identifying' prefix (version, meta tags, hash)\n- *\n- *   - Tolerably fast to read in its entirety.\n- *\n- *   - Safe from version-drift (or at least able to notice it and abort).\n- * \n- * Anti-goals:\n- * \n- *   - Random access.\n- * \n- *   - Generality to other languages.\n- *\n- * Structure:\n- *\n- *   - Line oriented.\n- *\n- *   - Whitespace-separated and whitespace-agnostic. Indent for legibility.\n- *\n- *   - Each line is a record. A record is either a full item, an item bracket,\n- *     a comment, or metadata.\n- *\n- *     - First byte describes type of record, unless first byte is +, in which\n- *       case it's oh-no-we-ran-out-of-tags and it's followed by 2 type-bytes.\n- *       (Continue to +++ if you happen to run out *there* as well. You\n- *       won't.)\n- *\n- *       - Metadata type is !\n- *\n- *       - Comment type is #\n- *\n- *       - Full item types are: y for type, c for const, f for fn, i for iter,\n- *         g for tag constructor.\n- *\n- *       - Item brackets are those that open/close a scope of\n- *         sub-records. These would be obj (o), mod (m), tag (t) to open. The\n- *         closer is always '.'.  So a mod looks like:\n- *\n- *            m foo\n- *                c bar\n- *            .\n- * \n- *     - After first byte of openers and full items is whitespace, then an\n- *       ident.\n- *\n- *     - After that, if it's a ty, fn, iter, obj or tag, there may be [, a\n- *        list of comma-separated ty param names, and ].\n- *\n- *     - After that, if it's a fn, iter, obj or tag constructor, there is a (,\n- *       a list of comma-separated type-encoded slot/ident pairs, and a ).\n- *\n- *     - After that, if it's a fn or iter, there's a '->' and a type-encoded\n- *       output.\n- *\n- *     - After that, a newline '\\n'.\n- *\n- *     - Type encoding is a longer issue! We'll get to that.\n- *)\n-\n-let fmt_iface (ff:Format.formatter) (crate:Ast.crate) : unit =\n-  let fmt_ty_param ff (p:Ast.ty_param identified) : unit =\n-    fmt ff \"%s\" (fst p.node)\n-  in\n-  let rec fmt_ty ff (t:Ast.ty) : unit =\n-    match t with\n-        Ast.TY_any -> fmt ff \"a\"\n-      | Ast.TY_nil -> fmt ff \"n\"\n-      | Ast.TY_bool -> fmt ff \"b\"\n-      | Ast.TY_mach tm -> fmt ff \"%s\" (string_of_ty_mach tm)\n-      | Ast.TY_int -> fmt ff \"i\"\n-      | Ast.TY_uint -> fmt ff \"u\"\n-      | Ast.TY_char -> fmt ff \"c\"\n-      | Ast.TY_str -> fmt ff \"s\"\n-\n-      | Ast.TY_tup ttup ->\n-          fmt_bracketed_arr_sep \"(\" \")\" \",\"\n-            fmt_ty ff ttup\n-      | Ast.TY_vec ty ->\n-          fmt ff \"v[\"; fmt_ty ff ty; fmt ff \"]\"\n-      | Ast.TY_chan ty ->\n-          fmt ff \"C[\"; fmt_ty ff ty; fmt ff \"]\"\n-\n-      | Ast.TY_port ty ->\n-          fmt ff \"P[\"; fmt_ty ff ty; fmt ff \"]\"\n-\n-      | Ast.TY_task ->\n-          fmt ff \"T\"\n-\n-      | Ast.TY_named n -> fmt ff \":\"; fmt_name ff n\n-      | Ast.TY_type -> fmt ff \"Y\"\n-\n-      | Ast.TY_box t -> fmt ff \"@@\"; fmt_ty ff t\n-      | Ast.TY_mutable t -> fmt ff \"~\"; fmt_ty ff t\n-\n-      (* FIXME: finish this. *)\n-      | Ast.TY_rec _\n-      | Ast.TY_tag _\n-      | Ast.TY_fn _\n-      | Ast.TY_obj _\n-      | Ast.TY_native _\n-      | Ast.TY_param _\n-      | Ast.TY_constrained _ -> fmt ff \"Z\"\n-\n-  and fmt_name ff n =\n-    match n with\n-        Ast.NAME_base (Ast.BASE_ident id) -> fmt ff \"%s\" id\n-      | Ast.NAME_base (Ast.BASE_temp _) -> failwith \"temp in fmt_name\"\n-      | Ast.NAME_base (Ast.BASE_app (id, tys)) ->\n-          fmt ff \"%s\" id;\n-          fmt_bracketed_arr_sep \"[\" \"]\" \",\"\n-            fmt_ty ff tys;\n-      | Ast.NAME_ext (n, Ast.COMP_ident id) ->\n-          fmt_name ff n;\n-          fmt ff \".%s\" id\n-      | Ast.NAME_ext (n, Ast.COMP_app (id, tys)) ->\n-          fmt_name ff n;\n-          fmt ff \".%s\" id;\n-          fmt_bracketed_arr_sep \"[\" \"]\" \",\"\n-            fmt_ty ff tys;\n-      | Ast.NAME_ext (n, Ast.COMP_idx i) ->\n-          fmt_name ff n;\n-          fmt ff \"._%d\" i\n-  in\n-  let rec fmt_mod_item (id:Ast.ident) (mi:Ast.mod_item) : unit =\n-    let i c = fmt ff \"@\\n%c %s\" c id in\n-\n-    let o c = fmt ff \"@\\n\"; fmt_obox ff; fmt ff \"%c %s\" c id in\n-    let p _ =\n-      if (Array.length mi.node.Ast.decl_params) <> 0\n-      then\n-        fmt_bracketed_arr_sep \"[\" \"]\" \",\"\n-          fmt_ty_param ff mi.node.Ast.decl_params\n-    in\n-    let c _ =  fmt_cbox ff; fmt ff \"@\\n.\" in\n-    match mi.node.Ast.decl_item with\n-        Ast.MOD_ITEM_type _ -> i 'y'; p()\n-      | Ast.MOD_ITEM_tag _ -> i 'g'; p()\n-      | Ast.MOD_ITEM_fn _ -> i 'f'; p();\n-      | Ast.MOD_ITEM_const _ -> i 'c'\n-      | Ast.MOD_ITEM_obj _ ->\n-          o 'o'; p();\n-          c ()\n-      | Ast.MOD_ITEM_mod (_, items) ->\n-          o 'm';\n-          fmt_mod_items items;\n-          c ()\n-  and fmt_mod_items items =\n-    sorted_htab_iter fmt_mod_item items\n-  in\n-  let (_,items) = crate.node.Ast.crate_items in\n-    fmt_mod_items items\n-;;\n-\n-(* Mechanisms for scanning libraries. *)\n-\n-(* FIXME (issue #67): move these to sess. *)\n-let ar_cache = Hashtbl.create 0 ;;\n-let sects_cache = Hashtbl.create 0;;\n-let meta_cache = Hashtbl.create 0;;\n-let die_cache = Hashtbl.create 0;;\n-\n-let get_ar\n-    (sess:Session.sess)\n-    (filename:filename)\n-    : Asm.asm_reader option =\n-  htab_search_or_add ar_cache filename\n-    begin\n-      fun _ ->\n-        let sniff =\n-          match sess.Session.sess_targ with\n-              Win32_x86_pe -> Pe.sniff\n-            | MacOS_x86_macho -> Macho.sniff\n-            | Linux_x86_elf -> Elf.sniff\n-            | FreeBSD_x86_elf -> Elf.sniff\n-        in\n-          sniff sess filename\n-    end\n-;;\n-\n-\n-let get_sects\n-    (sess:Session.sess)\n-    (filename:filename) :\n-    (Asm.asm_reader * ((string,(int*int)) Hashtbl.t)) option =\n-  htab_search_or_add sects_cache filename\n-    begin\n-      fun _ ->\n-        match get_ar sess filename with\n-            None -> None\n-          | Some ar ->\n-              let get_sections =\n-                match sess.Session.sess_targ with\n-                    Win32_x86_pe -> Pe.get_sections\n-                  | MacOS_x86_macho -> Macho.get_sections\n-                  | Linux_x86_elf -> Elf.get_sections\n-                  | FreeBSD_x86_elf -> Elf.get_sections\n-              in\n-                Some (ar, (get_sections sess ar))\n-    end\n-;;\n-\n-let get_meta\n-    (sess:Session.sess)\n-    (filename:filename)\n-    : Session.meta option =\n-  htab_search_or_add meta_cache filename\n-    begin\n-      fun _ ->\n-        match get_sects sess filename with\n-            None -> None\n-          | Some (ar, sects) ->\n-              match htab_search sects \".note.rust\" with\n-                  Some (off, _) ->\n-                    ar.Asm.asm_seek off;\n-                    Some (Asm.read_rust_note ar)\n-                | None -> None\n-    end\n-;;\n-\n-let get_dies_opt\n-    (sess:Session.sess)\n-    (filename:filename)\n-    : (Dwarf.rooted_dies option) =\n-  htab_search_or_add die_cache filename\n-    begin\n-      fun _ ->\n-        match get_sects sess filename with\n-            None -> None\n-          | Some (ar, sects) ->\n-              let debug_abbrev = Hashtbl.find sects \".debug_abbrev\" in\n-              let debug_info = Hashtbl.find sects \".debug_info\" in\n-              let abbrevs = Dwarf.read_abbrevs sess ar debug_abbrev in\n-              let dies = Dwarf.read_dies sess ar debug_info abbrevs in\n-                ar.Asm.asm_close ();\n-                Hashtbl.remove ar_cache filename;\n-                Some dies\n-    end\n-;;\n-\n-let get_dies\n-    (sess:Session.sess)\n-    (filename:filename)\n-    : Dwarf.rooted_dies =\n-  match get_dies_opt sess filename with\n-      None ->\n-        Printf.fprintf stderr \"Error: bad crate file: %s\\n%!\" filename;\n-        exit 1\n-    | Some dies -> dies\n-;;\n-\n-let get_file_mod\n-    (sess:Session.sess)\n-    (abi:Abi.abi)\n-    (filename:filename)\n-    : Ast.mod_items =\n-  let dies = get_dies sess filename in\n-  let items = Hashtbl.create 0 in\n-  let nref = sess.Session.sess_node_id_counter in\n-  let oref = sess.Session.sess_opaque_id_counter in\n-    Dwarf.extract_mod_items nref oref abi items dies;\n-    items\n-;;\n-\n-let get_mod\n-    (sess:Session.sess)\n-    (abi:Abi.abi)\n-    (meta:Ast.meta_pat)\n-    (use_id:node_id)\n-    (crate_item_cache:(crate_id, Ast.mod_items) Hashtbl.t)\n-    : (filename * Ast.mod_items) =\n-  let found = Queue.create () in\n-  let suffix =\n-    match sess.Session.sess_targ with\n-        Win32_x86_pe -> \".dll\"\n-      | MacOS_x86_macho -> \".dylib\"\n-      | Linux_x86_elf -> \".so\"\n-      | FreeBSD_x86_elf -> \".so\"\n-  in\n-  let rec meta_matches i f_meta =\n-    if i >= (Array.length meta)\n-    then true\n-    else\n-      match meta.(i) with\n-          (* FIXME (issue #68): bind the wildcards. *)\n-          (_, None) -> meta_matches (i+1) f_meta\n-        | (k, Some v) ->\n-            match atab_search f_meta k with\n-                None -> false\n-              | Some v' ->\n-                  if v = v'\n-                  then meta_matches (i+1) f_meta\n-                  else false\n-  in\n-  let file_matches file =\n-    log sess \"searching for metadata in %s\" file;\n-    match get_meta sess file with\n-        None -> false\n-      | Some f_meta ->\n-          log sess \"matching metadata in %s\" file;\n-          meta_matches 0 f_meta\n-  in\n-    iflog sess\n-      begin\n-        fun _ ->\n-          log sess \"searching for library matching:\";\n-          Array.iter\n-            begin\n-              fun (k,vo) ->\n-                match vo with\n-                    None -> ()\n-                  | Some v ->\n-                      log sess \"%s = %S\" k v\n-            end\n-            meta;\n-      end;\n-    Queue.iter\n-      begin\n-        fun dir ->\n-          let dh = Unix.opendir dir in\n-          let rec scan _ =\n-            try\n-              let basename = Unix.readdir dh in\n-              let file = dir ^ \"/\" ^ basename in\n-                log sess \"considering file %s\" file;\n-                if (Filename.check_suffix file suffix) &&\n-                  (file_matches file)\n-                then\n-                  begin\n-                    log sess \"matched against library %s\" file;\n-\n-                    let meta = get_meta sess file in\n-                    let crate_id =\n-                      match meta with\n-                          None -> Session.make_crate_id sess\n-                        | Some meta ->\n-                            iflog sess begin fun _ ->\n-                              Array.iter\n-                                (fun (k, v) -> log sess \"%s = %S\" k v)\n-                                meta\n-                            end;\n-                            htab_search_or_default\n-                              sess.Session.sess_crate_meta\n-                              meta\n-                              (fun () -> Session.make_crate_id sess)\n-                    in\n-                    Queue.add (file, crate_id) found;\n-                  end;\n-                scan()\n-            with\n-                End_of_file -> ()\n-          in\n-            scan ()\n-      end\n-      sess.Session.sess_lib_dirs;\n-    match Queue.length found with\n-        0 -> Common.err (Some use_id) \"unsatisfied 'use' clause\"\n-      | 1 ->\n-          let (filename, crate_id) = Queue.pop found in\n-          let items =\n-              htab_search_or_default crate_item_cache crate_id\n-                (fun () -> get_file_mod sess abi filename)\n-          in\n-            (filename, items)\n-      | _ -> Common.err (Some use_id) \"multiple crates match 'use' clause\"\n-;;\n-\n-let infer_lib_name\n-    (sess:Session.sess)\n-    (ident:filename)\n-    : filename =\n-  match sess.Session.sess_targ with\n-      Win32_x86_pe -> ident ^ \".dll\"\n-    | MacOS_x86_macho -> \"lib\" ^ ident ^ \".dylib\"\n-    | Linux_x86_elf -> \"lib\" ^ ident ^ \".so\"\n-    | FreeBSD_x86_elf -> \"lib\" ^ ident ^ \".so\"\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "0871d3065059fdd1e1c4bf685e9eb660234ba904", "filename": "src/boot/driver/main.ml", "status": "removed", "additions": 0, "deletions": 530, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fdriver%2Fmain.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fdriver%2Fmain.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fmain.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,530 +0,0 @@\n-\n-open Common;;\n-\n-let (targ:Common.target) =\n-  match Sys.os_type with\n-\n-    | \"Win32\"\n-    | \"Cygwin\" -> Win32_x86_pe\n-\n-    | \"Unix\"\n-        when Unix.system \"test `uname -s` = 'Linux'\" = Unix.WEXITED 0 ->\n-        Linux_x86_elf\n-    | \"Unix\"\n-        when Unix.system \"test `uname -s` = 'Darwin'\" = Unix.WEXITED 0 ->\n-        MacOS_x86_macho\n-    | \"Unix\"\n-        when Unix.system \"test `uname -s` = 'FreeBSD'\" = Unix.WEXITED 0 ->\n-        FreeBSD_x86_elf\n-    | _ ->\n-        Linux_x86_elf\n-;;\n-\n-let (abi:Abi.abi) = X86.abi;;\n-\n-let (sess:Session.sess) =\n-  {\n-    Session.sess_in = None;\n-    Session.sess_out = None;\n-    Session.sess_library_mode = false;\n-    Session.sess_alt_backend = false;\n-    Session.sess_minimal = false;\n-    Session.sess_use_pexps = false;\n-    (* FIXME (issue #69): need something fancier here for unix\n-     * sub-flavours.\n-     *)\n-    Session.sess_targ = targ;\n-    Session.sess_log_lex = false;\n-    Session.sess_log_parse = false;\n-    Session.sess_log_ast = false;\n-    Session.sess_log_sig = false;\n-    Session.sess_log_passes = false;\n-    Session.sess_log_resolve = false;\n-    Session.sess_log_type = false;\n-    Session.sess_log_simplify = false;\n-    Session.sess_log_layer = false;\n-    Session.sess_log_typestate = false;\n-    Session.sess_log_loop = false;\n-    Session.sess_log_alias = false;\n-    Session.sess_log_dead = false;\n-    Session.sess_log_layout = false;\n-    Session.sess_log_itype = false;\n-    Session.sess_log_trans = false;\n-    Session.sess_log_dwarf = false;\n-    Session.sess_log_ra = false;\n-    Session.sess_log_insn = false;\n-    Session.sess_log_asm = false;\n-    Session.sess_log_obj = false;\n-    Session.sess_log_lib = false;\n-    Session.sess_log_path = None;\n-    Session.sess_log_out = stdout;\n-    Session.sess_log_err = stderr;\n-    Session.sess_trace_block = false;\n-    Session.sess_trace_drop = false;\n-    Session.sess_trace_tag = false;\n-    Session.sess_trace_gc = false;\n-    Session.sess_failed = false;\n-    Session.sess_spans = Hashtbl.create 0;\n-    Session.sess_report_timing = false;\n-    Session.sess_report_quads = false;\n-    Session.sess_report_gc = false;\n-    Session.sess_report_deps = false;\n-    Session.sess_next_crate_id = 0;\n-    Session.sess_fuzz_item_count = 5;\n-    Session.sess_timings = Hashtbl.create 0;\n-    Session.sess_quad_counts = Hashtbl.create 0;\n-    Session.sess_lib_dirs = Queue.create ();\n-    Session.sess_crate_meta = Hashtbl.create 0;\n-    Session.sess_node_id_counter = ref (Node 0);\n-    Session.sess_opaque_id_counter = ref (Opaque 0);\n-    Session.sess_temp_id_counter = ref (Temp 0);\n-  }\n-;;\n-\n-let exit_if_failed _ =\n-  if sess.Session.sess_failed\n-  then exit 1\n-  else ()\n-;;\n-\n-let default_output_filename (sess:Session.sess) : filename option =\n-  match sess.Session.sess_in with\n-      None -> None\n-    | Some fname ->\n-        let base = Filename.chop_extension (Filename.basename fname) in\n-        let out =\n-          if sess.Session.sess_library_mode\n-          then\n-            Lib.infer_lib_name sess base\n-          else\n-            base ^ (match sess.Session.sess_targ with\n-                        Linux_x86_elf -> \"\"\n-                      | FreeBSD_x86_elf -> \"\"\n-                      | MacOS_x86_macho -> \"\"\n-                      | Win32_x86_pe -> \".exe\")\n-        in\n-          Some out\n-;;\n-\n-let set_default_output_filename (sess:Session.sess) : unit =\n-  match sess.Session.sess_out with\n-      None -> (sess.Session.sess_out <- default_output_filename sess)\n-    | _ -> ()\n-;;\n-\n-\n-let dump_sig (filename:filename) : unit =\n-  let items =\n-    Lib.get_file_mod sess abi filename in\n-    Printf.fprintf stdout \"%s\\n\" (Fmt.fmt_to_str Ast.fmt_mod_items items);\n-    exit_if_failed ();\n-    exit 0\n-;;\n-\n-\n-let dump_meta (filename:filename) : unit =\n-  begin\n-    match Lib.get_meta sess filename with\n-        None -> Printf.fprintf stderr \"Error: bad crate file: %s\\n\" filename\n-      | Some meta ->\n-          Array.iter\n-            begin\n-              fun (k,v) ->\n-                Printf.fprintf stdout \"%s = %S\\n\" k v;\n-            end\n-            meta\n-  end;\n-  exit 0\n-;;\n-\n-let print_version _ =\n-  Printf.fprintf stdout \"rustboot %s\\n\" Version.version;\n-  exit 0;\n-;;\n-\n-let flag f opt desc =\n-  (opt, Arg.Unit f, desc)\n-;;\n-\n-let argspecs =\n-  [\n-    (\"-t\", Arg.Symbol ([\"linux-x86-elf\";\n-                        \"win32-x86-pe\";\n-                        \"macos-x86-macho\";\n-                        \"freebsd-x86-elf\"],\n-                       fun s -> (sess.Session.sess_targ <-\n-                                   (match s with\n-                                        \"win32-x86-pe\" -> Win32_x86_pe\n-                                      | \"macos-x86-macho\" -> MacOS_x86_macho\n-                                      | \"freebsd-x86-elf\" -> FreeBSD_x86_elf\n-                                      | _ -> Linux_x86_elf))),\n-     (\" target (default: \" ^ (match sess.Session.sess_targ with\n-                                  Win32_x86_pe -> \"win32-x86-pe\"\n-                                | Linux_x86_elf -> \"linux-x86-elf\"\n-                                | MacOS_x86_macho -> \"macos-x86-macho\"\n-                                | FreeBSD_x86_elf -> \"freebsd-x86-elf\"\n-                             ) ^ \")\"));\n-    (\"-o\", Arg.String (fun s -> sess.Session.sess_out <- Some s),\n-     \"file to output (default: \"\n-     ^ (Session.filename_of sess.Session.sess_out) ^ \")\");\n-    (\"-shared\", Arg.Unit (fun _ -> sess.Session.sess_library_mode <- true),\n-     \"compile a shared-library crate\");\n-    (\"-L\", Arg.String (fun s -> Queue.add s sess.Session.sess_lib_dirs),\n-     \"dir to add to library path\");\n-    (\"-litype\", Arg.Unit (fun _ -> sess.Session.sess_log_itype <- true;\n-                            Il.log_iltypes := true), \"log IL types\");\n-    (flag (fun _ -> sess.Session.sess_log_lex <- true)\n-       \"-llex\"      \"log lexing\");\n-    (flag (fun _ -> sess.Session.sess_log_parse <- true)\n-       \"-lparse\"    \"log parsing\");\n-    (flag (fun _ -> sess.Session.sess_log_ast <- true)\n-       \"-last\"      \"log AST\");\n-    (flag (fun _ -> sess.Session.sess_log_sig <- true)\n-       \"-lsig\"      \"log signature\");\n-    (flag (fun _ -> sess.Session.sess_log_passes <- true)\n-       \"-lpasses\"  \"log passes at high-level\");\n-    (flag (fun _ -> sess.Session.sess_log_resolve <- true)\n-       \"-lresolve\"  \"log resolution\");\n-    (flag (fun _ -> sess.Session.sess_log_type <- true)\n-       \"-ltype\"     \"log type checking\");\n-    (flag (fun _ -> sess.Session.sess_log_simplify <- true)\n-       \"-lsimplify\" \"log simplification\");\n-    (flag (fun _ -> sess.Session.sess_log_layer <- true)\n-       \"-llayer\"  \"log layer checking\");\n-    (flag (fun _ -> sess.Session.sess_log_typestate <- true)\n-       \"-ltypestate\" \"log typestate pass\");\n-    (flag (fun _ -> sess.Session.sess_log_loop <- true)\n-       \"-lloop\"      \"log loop analysis\");\n-    (flag (fun _ -> sess.Session.sess_log_alias <- true)\n-       \"-lalias\"      \"log alias analysis\");\n-    (flag (fun _ -> sess.Session.sess_log_dead <- true)\n-       \"-ldead\"       \"log dead analysis\");\n-    (flag (fun _ -> sess.Session.sess_log_layout <- true)\n-       \"-llayout\"     \"log frame layout\");\n-    (flag (fun _ -> sess.Session.sess_log_trans <- true)\n-       \"-ltrans\"      \"log IR translation\");\n-    (flag (fun _ -> sess.Session.sess_log_dwarf <- true)\n-       \"-ldwarf\"      \"log DWARF generation\");\n-    (flag (fun _ -> sess.Session.sess_log_ra <- true)\n-       \"-lra\"         \"log register allocation\");\n-    (flag (fun _ -> sess.Session.sess_log_insn <- true)\n-       \"-linsn\"       \"log instruction selection\");\n-    (flag (fun _ -> sess.Session.sess_log_asm <- true)\n-       \"-lasm\"        \"log assembly\");\n-    (flag (fun _ -> sess.Session.sess_log_obj <- true)\n-       \"-lobj\"        \"log object-file generation\");\n-    (flag (fun _ -> sess.Session.sess_log_lib <- true)\n-       \"-llib\"        \"log library search\");\n-\n-    (\"-lpath\", Arg.String\n-       (fun s -> sess.Session.sess_log_path <- Some (split_string '.' s)),\n-     \"module path to restrict logging to\");\n-\n-    (flag (fun _ -> sess.Session.sess_trace_block <- true)\n-       \"-tblock\"      \"emit block-boundary tracing code\");\n-    (flag (fun _ -> sess.Session.sess_trace_drop <- true)\n-       \"-tdrop\"       \"emit slot-drop tracing code\");\n-    (flag (fun _ -> sess.Session.sess_trace_tag <- true)\n-       \"-ttag\"        \"emit tag-construction tracing code\");\n-    (flag (fun _ -> sess.Session.sess_trace_gc <- true)\n-       \"-tgc\"         \"emit GC tracing code\");\n-\n-    (\"-tall\", Arg.Unit (fun _ ->\n-                          sess.Session.sess_trace_block <- true;\n-                          sess.Session.sess_trace_drop <- true;\n-                          sess.Session.sess_trace_tag <- true ),\n-     \"emit all tracing code\");\n-\n-    (flag (fun _ -> sess.Session.sess_report_timing <- true)\n-       \"-rtime\"        \"report timing of compiler phases\");\n-    (flag (fun _ -> sess.Session.sess_report_quads <- true)\n-       \"-rquads\"       \"report categories of quad emitted\");\n-    (flag (fun _ -> sess.Session.sess_report_gc <- true)\n-       \"-rgc\"          \"report gc behavior of compiler\");\n-    (\"-rsig\", Arg.String dump_sig,\n-     \"report type-signature from DWARF info in compiled file, then exit\");\n-    (\"-rmeta\", Arg.String dump_meta,\n-     \"report metadata from DWARF info in compiled file, then exit\");\n-    (\"-rdeps\", Arg.Unit (fun _ -> sess.Session.sess_report_deps <- true),\n-     \"report dependencies of input, then exit\");\n-    (\"-version\", Arg.Unit (fun _ -> print_version()),\n-     \"print version information, then exit\");\n-\n-    (flag (fun _ -> sess.Session.sess_use_pexps <- true)\n-       \"-pexp\"         \"use pexp portion of AST\");\n-\n-    (flag (fun _ -> sess.Session.sess_minimal <- true)\n-       \"-minimal\"     (\"reduce code size by disabling various features\"\n-                       ^ \" (use at own risk)\"));\n-\n-    (\"-zc\", Arg.Int (fun i -> sess.Session.sess_fuzz_item_count <- i),\n-     \"count of items to generate when fuzzing\");\n-\n-    (\"-zs\", Arg.Int (fun i -> Fuzz.fuzz (Some i) sess),\n-     \"run fuzzer with given seed\");\n-\n-    (flag (fun _ -> Fuzz.fuzz None sess)\n-       \"-z\" \"run fuzzer with random seed\")\n-\n-  ] @ (Glue.alt_argspecs sess)\n-;;\n-\n-Arg.parse\n-  argspecs\n-  (fun arg -> sess.Session.sess_in <- (Some arg))\n-  (\"usage: \" ^ Sys.argv.(0) ^ \" [options] (CRATE_FILE.rc|SOURCE_FILE.rs)\\n\")\n-;;\n-\n-let _ = set_default_output_filename  sess\n-;;\n-\n-let _ =\n-  if sess.Session.sess_out = None\n-  then (Printf.fprintf stderr \"Error: no output file specified\\n\"; exit 1)\n-  else ()\n-;;\n-\n-let _ =\n-  if sess.Session.sess_in = None\n-  then (Printf.fprintf stderr \"Error: empty input filename\\n\"; exit 1)\n-  else ()\n-;;\n-\n-\n-let parse_input_crate\n-    (crate_cache:(crate_id, Ast.mod_items) Hashtbl.t)\n-    : Ast.crate =\n-  Session.time_inner \"parse\" sess\n-    begin\n-      fun _ ->\n-        let infile = Session.filename_of sess.Session.sess_in in\n-        let crate =\n-          if Filename.check_suffix infile \".rc\"\n-          then\n-            Cexp.parse_crate_file sess\n-              (Lib.get_mod sess abi)\n-              (Lib.infer_lib_name sess)\n-              crate_cache\n-          else\n-            if Filename.check_suffix infile \".rs\"\n-            then\n-              Cexp.parse_src_file sess\n-                (Lib.get_mod sess abi)\n-                (Lib.infer_lib_name sess)\n-                crate_cache\n-            else\n-              begin\n-                Printf.fprintf stderr\n-                  \"Error: unrecognized input file type: %s\\n\"\n-                  infile;\n-                exit 1\n-              end\n-        in\n-          exit_if_failed();\n-          if sess.Session.sess_report_deps\n-          then\n-            let outfile = (Session.filename_of sess.Session.sess_out) in\n-            let depfile =\n-              match sess.Session.sess_targ with\n-                  Linux_x86_elf\n-                | FreeBSD_x86_elf\n-                | MacOS_x86_macho -> outfile ^ \".d\"\n-                | Win32_x86_pe -> (Filename.chop_extension outfile) ^ \".d\"\n-            in\n-              begin\n-                Array.iter\n-                  begin\n-                    fun out ->\n-                      Printf.fprintf stdout \"%s: \\\\\\n\" out;\n-                      Hashtbl.iter\n-                        (fun _ file ->\n-                           Printf.fprintf stdout \"    %s \\\\\\n\" file)\n-                        crate.node.Ast.crate_files;\n-                      Printf.fprintf stdout \"\\n\"\n-                  end\n-                  [| outfile; depfile|];\n-                exit 0\n-              end\n-          else\n-            crate\n-    end\n-;;\n-\n-let (crate:Ast.crate) =\n-  try\n-    let crate_cache = Hashtbl.create 1 in\n-    parse_input_crate crate_cache\n-  with\n-      Not_implemented (ido, str) ->\n-        Session.report_err sess ido str;\n-        { node = Ast.empty_crate'; id = Common.Node 0 }\n-;;\n-\n-exit_if_failed ()\n-;;\n-\n-if sess.Session.sess_log_ast\n-then\n-  begin\n-    Printf.fprintf stdout \"Post-parse AST:\\n\";\n-    Format.set_margin 80;\n-    Printf.fprintf stdout \"%s\\n\" (Fmt.fmt_to_str Ast.fmt_crate crate)\n-  end\n-;;\n-\n-if sess.Session.sess_log_sig\n-then\n-  begin\n-    Printf.fprintf stdout \"Post-parse signature:\\n\";\n-    Format.set_margin 80;\n-    Printf.fprintf stdout \"%s\\n\" (Fmt.fmt_to_str Lib.fmt_iface crate);\n-  end\n-;;\n-\n-\n-let list_to_seq ls = Asm.SEQ (Array.of_list ls);;\n-let select_insns (quads:Il.quads) : Asm.frag =\n-  Session.time_inner \"insn\" sess\n-    (fun _ -> X86.select_insns sess quads)\n-;;\n-\n-\n-(* Semantic passes. *)\n-let sem_cx = Semant.new_ctxt sess abi crate.node\n-;;\n-\n-\n-let main_pipeline _ =\n-  let _ =\n-    Array.iter\n-      (fun proc ->\n-         proc sem_cx crate;\n-         exit_if_failed ())\n-      [| Resolve.process_crate;\n-         Simplify.process_crate;\n-         Type.process_crate;\n-         Typestate.process_crate;\n-         Layer.process_crate;\n-         Loop.process_crate;\n-         Alias.process_crate;\n-         Dead.process_crate;\n-         Layout.process_crate;\n-         Trans.process_crate |]\n-  in\n-\n-  (* Tying up various knots, allocating registers and selecting\n-   * instructions.\n-   *)\n-  let process_code _ (code:Semant.code) : Asm.frag =\n-    let frag =\n-      match code.Semant.code_vregs_and_spill with\n-          None ->\n-            X86.log sess \"selecting insns for %s\"\n-              code.Semant.code_fixup.fixup_name;\n-            select_insns code.Semant.code_quads\n-        | Some (n_vregs, spill_fix) ->\n-            let (quads', n_spills) =\n-              (Session.time_inner \"RA\" sess\n-                 (fun _ ->\n-                    Ra.reg_alloc sess\n-                      code.Semant.code_quads\n-                      n_vregs abi))\n-            in\n-            let _ =\n-              X86.log sess \"selecting insns for %s\"\n-                code.Semant.code_fixup.fixup_name\n-            in\n-            let insns = select_insns quads' in\n-              begin\n-                spill_fix.fixup_mem_sz <-\n-                  Some (Int64.mul\n-                          (Int64.of_int n_spills)\n-                          abi.Abi.abi_word_sz);\n-                insns\n-              end\n-    in\n-      Asm.ALIGN_FILE (Abi.general_code_alignment,\n-                      Asm.DEF (code.Semant.code_fixup, frag))\n-  in\n-\n-  let (file_frags:Asm.frag) =\n-    let process_file file_id frag_code =\n-      let file_fix = Hashtbl.find sem_cx.Semant.ctxt_file_fixups file_id in\n-        Asm.DEF (file_fix,\n-                 list_to_seq (reduce_hash_to_list process_code frag_code))\n-    in\n-      list_to_seq (reduce_hash_to_list\n-                     process_file sem_cx.Semant.ctxt_file_code)\n-  in\n-\n-    exit_if_failed ();\n-    let (glue_frags:Asm.frag) =\n-      list_to_seq (reduce_hash_to_list\n-                     process_code sem_cx.Semant.ctxt_glue_code)\n-    in\n-\n-      exit_if_failed ();\n-      let code = Asm.SEQ [| file_frags; glue_frags |] in\n-      let data = list_to_seq (reduce_hash_to_list\n-                                (fun _ (_, i) -> i) sem_cx.Semant.ctxt_data)\n-      in\n-      (* Emitting Dwarf and PE/ELF/Macho. *)\n-      let (dwarf:Dwarf.debug_records) =\n-        Session.time_inner \"dwarf\" sess\n-          (fun _ -> Dwarf.process_crate sem_cx crate)\n-      in\n-\n-        exit_if_failed ();\n-        let emitter =\n-          match sess.Session.sess_targ with\n-              Win32_x86_pe -> Pe.emit_file\n-            | MacOS_x86_macho -> Macho.emit_file\n-            | Linux_x86_elf -> Elf.emit_file\n-            | FreeBSD_x86_elf -> Elf.emit_file\n-        in\n-          Session.time_inner \"emit\" sess\n-            (fun _ -> emitter sess crate code data sem_cx dwarf);\n-          exit_if_failed ()\n-;;\n-\n-try\n-  if sess.Session.sess_alt_backend\n-  then Glue.alt_pipeline sess sem_cx crate\n-  else main_pipeline ()\n-with\n-    Not_implemented (ido, str) ->\n-      Session.report_err sess ido str\n-;;\n-\n-exit_if_failed ()\n-;;\n-\n-if sess.Session.sess_report_timing\n-then\n-  begin\n-    let cumulative = ref 0.0 in\n-    Printf.fprintf stdout \"timing:\\n\\n\";\n-    Array.iter\n-      begin\n-        fun name ->\n-          let t = Hashtbl.find sess.Session.sess_timings name in\n-          Printf.fprintf stdout \"%20s: %f\\n\" name t;\n-            cumulative := (!cumulative) +. t\n-      end\n-      (sorted_htab_keys sess.Session.sess_timings);\n-    Printf.fprintf stdout \"\\n%20s: %f\\n\" \"cumulative\" (!cumulative)\n-  end;\n-;;\n-\n-if sess.Session.sess_report_gc\n-then Gc.print_stat stdout;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "2f38ba4df9fa5dda8f67146b2118df0bb53b7969", "filename": "src/boot/driver/session.ml", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fdriver%2Fsession.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fdriver%2Fsession.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fsession.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,149 +0,0 @@\n-(*\n- * This module goes near the bottom of the dependency DAG, and holds option,\n- * and global-state machinery for a single run of the compiler.\n- *)\n-\n-open Common;;\n-\n-type meta = (string * string) array;;\n-\n-type sess =\n-{\n-  mutable sess_in: filename option;\n-  mutable sess_out: filename option;\n-  mutable sess_library_mode: bool;\n-  mutable sess_alt_backend: bool;\n-  mutable sess_minimal: bool;\n-  mutable sess_use_pexps: bool;\n-  mutable sess_targ: target;\n-  mutable sess_log_lex: bool;\n-  mutable sess_log_parse: bool;\n-  mutable sess_log_ast: bool;\n-  mutable sess_log_sig: bool;\n-  mutable sess_log_passes: bool;\n-  mutable sess_log_resolve: bool;\n-  mutable sess_log_type: bool;\n-  mutable sess_log_simplify: bool;\n-  mutable sess_log_layer: bool;\n-  mutable sess_log_typestate: bool;\n-  mutable sess_log_dead: bool;\n-  mutable sess_log_loop: bool;\n-  mutable sess_log_alias: bool;\n-  mutable sess_log_layout: bool;\n-  mutable sess_log_trans: bool;\n-  mutable sess_log_itype: bool;\n-  mutable sess_log_dwarf: bool;\n-  mutable sess_log_ra: bool;\n-  mutable sess_log_insn: bool;\n-  mutable sess_log_asm: bool;\n-  mutable sess_log_obj: bool;\n-  mutable sess_log_lib: bool;\n-  mutable sess_log_path: (string list) option;\n-  mutable sess_log_out: out_channel;\n-  mutable sess_log_err: out_channel;\n-  mutable sess_trace_block: bool;\n-  mutable sess_trace_drop: bool;\n-  mutable sess_trace_tag: bool;\n-  mutable sess_trace_gc: bool;\n-  mutable sess_failed: bool;\n-  mutable sess_report_timing: bool;\n-  mutable sess_report_quads: bool;\n-  mutable sess_report_gc: bool;\n-  mutable sess_report_deps: bool;\n-  mutable sess_next_crate_id: int;\n-  mutable sess_fuzz_item_count: int;\n-\n-  sess_timings: (string, float) Hashtbl.t;\n-  sess_quad_counts: (string, int ref) Hashtbl.t;\n-  sess_spans: (node_id,span) Hashtbl.t;\n-  sess_lib_dirs: filename Queue.t;\n-  sess_crate_meta: (meta, crate_id) Hashtbl.t;\n-\n-  sess_node_id_counter: node_id ref;\n-  sess_opaque_id_counter: opaque_id ref;\n-  sess_temp_id_counter: temp_id ref;\n-}\n-;;\n-\n-let add_time sess name amt =\n-  let existing =\n-    if Hashtbl.mem sess.sess_timings name\n-    then Hashtbl.find sess.sess_timings name\n-    else 0.0\n-  in\n-    (Hashtbl.replace sess.sess_timings name (existing +. amt))\n-;;\n-\n-let time_inner name sess thunk =\n-  let t0 = Unix.gettimeofday() in\n-  let x = thunk() in\n-  let t1 = Unix.gettimeofday() in\n-    add_time sess name (t1 -. t0);\n-    x\n-;;\n-\n-let get_span sess id =\n-  if Hashtbl.mem sess.sess_spans id\n-  then (Some (Hashtbl.find sess.sess_spans id))\n-  else None\n-;;\n-\n-let log name flag chan =\n-  let k1 s =\n-    Printf.fprintf chan \"%s: %s\\n%!\" name s\n-  in\n-  let k2 _ = () in\n-    Printf.ksprintf (if flag then k1 else k2)\n-;;\n-\n-let fail sess =\n-  sess.sess_failed <- true;\n-  Printf.fprintf sess.sess_log_err\n-;;\n-\n-\n-let string_of_pos (p:pos) =\n-  let (filename, line, col) = p in\n-  Printf.sprintf \"%s:%d:%d\" filename line col\n-;;\n-\n-\n-let string_of_span (s:span) =\n-    let (filename, line0, col0) = s.lo in\n-    let (_, line1, col1) = s.hi in\n-    Printf.sprintf \"%s:%d:%d:%d:%d\" filename line0 col0 line1 col1\n-;;\n-\n-let filename_of (fo:filename option) : filename =\n-  match fo with\n-      None -> \"<none>\"\n-    | Some f -> f\n-;;\n-\n-let report_err sess ido str =\n-  let spano = match ido with\n-      None -> None\n-    | Some id -> get_span sess id\n-  in\n-    match spano with\n-        None ->\n-          fail sess \"error: %s\\n%!\" str\n-      | Some span ->\n-          fail sess \"%s: error: %s\\n%!\"\n-            (string_of_span span) str\n-;;\n-\n-let make_crate_id (sess:sess) : crate_id =\n-  let crate_id = Crate sess.sess_next_crate_id in\n-  sess.sess_next_crate_id <- sess.sess_next_crate_id + 1;\n-  crate_id\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "26c3b7c12cf063a9b8db6969dd9fed77bf3db7b8", "filename": "src/boot/fe/ast.ml", "status": "removed", "additions": 0, "deletions": 1795, "changes": 1795, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,1795 +0,0 @@\n-(*\n- * There are two kinds of rust files:\n- *\n- * .rc files, containing crates.\n- * .rs files, containing source.\n- *\n- *)\n-\n-open Common;;\n-open Fmt;;\n-\n-type ident = string\n-;;\n-\n-type slot_key =\n-    KEY_ident of ident\n-  | KEY_temp of temp_id\n-;;\n-\n-(* \"names\" are statically computable references to particular items;\n-   they never involve dynamic indexing (nor even static tuple-indexing;\n-   you could add it but there are few contexts that need names that would\n-   benefit from it).\n-\n-   Each component of a name may also be type-parametric; you must\n-   supply type parameters to reference through a type-parametric name\n-   component. So for example if foo is parametric in 2 types, you can\n-   write foo[int,int].bar but not foo.bar.\n- *)\n-\n-type auth = AUTH_unsafe\n-;;\n-\n-type layer =\n-    LAYER_value\n-  | LAYER_state\n-  | LAYER_gc\n-;;\n-\n-type mutability =\n-    MUT_mutable\n-  | MUT_immutable\n-;;\n-\n-type name_base =\n-    BASE_ident of ident\n-  | BASE_temp of temp_id\n-  | BASE_app of (ident * (ty array))\n-\n-and name_component =\n-    COMP_ident of ident\n-  | COMP_app of (ident * (ty array))\n-  | COMP_idx of int\n-\n-and name =\n-    NAME_base of name_base\n-  | NAME_ext of (name * name_component)\n-\n-(*\n- * Type expressions are transparent to type names, their equality is\n- * structural.  (after normalization)\n- *)\n-and ty =\n-\n-    TY_any\n-  | TY_nil\n-  | TY_bool\n-  | TY_mach of ty_mach\n-  | TY_int\n-  | TY_uint\n-  | TY_char\n-  | TY_str\n-\n-  | TY_tup of ty_tup\n-  | TY_vec of ty\n-  | TY_rec of ty_rec\n-\n-  (* NB: non-denotable. *)\n-  | TY_tag of ty_tag\n-\n-  | TY_fn of ty_fn\n-  | TY_chan of ty\n-  | TY_port of ty\n-\n-  | TY_obj of ty_obj\n-  | TY_task\n-\n-  | TY_native of opaque_id\n-  | TY_param of (ty_param_idx * layer)\n-  | TY_named of name\n-  | TY_type\n-\n-  | TY_box of ty\n-  | TY_mutable of ty\n-\n-  | TY_constrained of (ty * constrs)\n-\n-(*\n- * FIXME: this should be cleaned up to be a different\n- * type definition. Only args can be by-ref, only locals\n- * can be auto. The structure here is historical.\n- *)\n-\n-and mode =\n-  | MODE_local\n-  | MODE_alias\n-\n-and slot = { slot_mode: mode;\n-             slot_ty: ty option; }\n-\n-and ty_tup = ty array\n-\n-and ty_tag = { tag_id: opaque_id;\n-               tag_args: ty array }\n-\n-(* In closed type terms a constraint may refer to components of the term by\n- * anchoring off the \"formal symbol\" '*', which represents \"the term this\n- * constraint is attached to\".\n- *\n- *\n- * For example, if I have a tuple type tup(int,int), I may wish to enforce the\n- * lt predicate on it; I can write this as a constrained type term like:\n- *\n- * tup(int,int) : lt( *._0, *._1 )\n- *\n- * In fact all tuple types are converted to this form for purpose of\n- * type-compatibility testing; the argument tuple in a function\n- *\n- * fn (int x, int y) : lt(x, y) -> int\n- *\n- * desugars to\n- *\n- * fn (tup(int, int) : lt( *._1, *._2 )) -> int\n- *\n- *)\n-\n-and carg_base =\n-    BASE_formal\n-  | BASE_named of name_base\n-\n-and carg_path =\n-    CARG_base of carg_base\n-  | CARG_ext of (carg_path * name_component)\n-\n-and carg =\n-    CARG_path of carg_path\n-  | CARG_lit of lit\n-\n-and constr =\n-    {\n-      constr_name: name;\n-      constr_args: carg array;\n-    }\n-\n-and constrs = constr array\n-\n-and ty_rec = (ident * ty) array\n-\n-and ty_sig =\n-    {\n-      sig_input_slots: slot array;\n-      sig_input_constrs: constrs;\n-      sig_output_slot: slot;\n-    }\n-\n-and ty_fn_aux =\n-    {\n-      fn_is_iter: bool;\n-    }\n-\n-and ty_fn = (ty_sig * ty_fn_aux)\n-\n-and ty_obj_header = (slot array * constrs)\n-\n-and ty_obj = (layer * ((ident,ty_fn) Hashtbl.t))\n-\n-and check_calls = (lval * (atom array)) array\n-\n-and rec_input = (ident * mutability * atom)\n-\n-and tup_input = (mutability * atom)\n-\n-and stmt' =\n-\n-  (* lval-assigning stmts. *)\n-    STMT_spawn of (lval * domain * string * lval * (atom array))\n-  | STMT_new_rec of (lval * (rec_input array) * lval option)\n-  | STMT_new_tup of (lval * (tup_input array))\n-  | STMT_new_vec of (lval * mutability * atom array)\n-  | STMT_new_str of (lval * string)\n-  | STMT_new_port of lval\n-  | STMT_new_chan of (lval * (lval option))\n-  | STMT_new_box of (lval * mutability * atom)\n-  | STMT_copy of (lval * expr)\n-  | STMT_copy_binop of (lval * binop * atom)\n-  | STMT_call of (lval * lval * (atom array))\n-  | STMT_bind of (lval * lval * ((atom option) array))\n-  | STMT_recv of (lval * lval)\n-  | STMT_slice of (lval * lval * slice)\n-\n-  (* control-flow stmts. *)\n-  | STMT_while of stmt_while\n-  | STMT_do_while of stmt_while\n-  | STMT_for of stmt_for\n-  | STMT_for_each of stmt_for_each\n-  | STMT_if of stmt_if\n-  | STMT_put of (atom option)\n-  | STMT_put_each of (lval * (atom array))\n-  | STMT_ret of (atom option)\n-  | STMT_be of (lval * (atom array))\n-  | STMT_break\n-  | STMT_cont\n-  | STMT_alt_tag of stmt_alt_tag\n-  | STMT_alt_type of stmt_alt_type\n-  | STMT_alt_port of stmt_alt_port\n-\n-  (* structural and misc stmts. *)\n-  | STMT_fail\n-  | STMT_yield\n-  | STMT_join of lval\n-  | STMT_send of (lval * lval)\n-  | STMT_log of atom\n-  | STMT_log_err of atom\n-  | STMT_note of atom\n-  | STMT_prove of (constrs)\n-  | STMT_check of (constrs * check_calls)\n-  | STMT_check_expr of expr\n-  | STMT_check_if of (constrs * check_calls * block)\n-  | STMT_block of block\n-  | STMT_decl of stmt_decl\n-\n-and stmt = stmt' identified\n-\n-and stmt_alt_tag =\n-    {\n-      alt_tag_lval: lval;\n-      alt_tag_arms: tag_arm array;\n-    }\n-\n-and stmt_alt_type =\n-    {\n-      alt_type_lval: lval;\n-      alt_type_arms: type_arm array;\n-      alt_type_else: block option;\n-    }\n-\n-and stmt_alt_port =\n-    {\n-      (* else atom is a timeout value. *)\n-      alt_port_arms: port_arm array;\n-      alt_port_else: (atom * block) option;\n-    }\n-\n-and block' = stmt array\n-and block = block' identified\n-\n-and stmt_decl =\n-    DECL_mod_item of (ident * mod_item)\n-  | DECL_slot of (slot_key * (slot identified))\n-\n-\n-and stmt_while =\n-    {\n-      while_lval: ((stmt array) * expr);\n-      while_body: block;\n-    }\n-\n-and stmt_for_each =\n-    {\n-      for_each_slot: (slot identified * ident);\n-      for_each_call: (lval * atom array);\n-      for_each_head: block;\n-      for_each_body: block;\n-    }\n-\n-and stmt_for =\n-    {\n-      for_slot: (slot identified * ident);\n-      for_seq: lval;\n-      for_body: block;\n-    }\n-\n-and stmt_if =\n-    {\n-      if_test: expr;\n-      if_then: block;\n-      if_else: block option;\n-    }\n-\n-and slice =\n-    { slice_start: atom option;\n-      slice_len: atom option; }\n-\n-and domain =\n-    DOMAIN_local\n-  | DOMAIN_thread\n-\n-(*\n- * PAT_tag uses lval for the tag constructor so that we can reuse our lval\n- * resolving machinery.  The lval is restricted during parsing to have only\n- * named components.\n- *)\n-and pat =\n-    PAT_lit of lit\n-  | PAT_tag of (lval * (pat array))\n-  | PAT_slot of ((slot identified) * ident)\n-  | PAT_wild\n-\n-and tag_arm' = pat * block\n-and tag_arm = tag_arm' identified\n-\n-and type_arm' = (ident * slot) * block\n-and type_arm = type_arm' identified\n-\n-and port_arm' = port_case * block\n-and port_arm = port_arm' identified\n-\n-and port_case =\n-    PORT_CASE_send of (lval * lval)\n-  | PORT_CASE_recv of (lval * lval)\n-\n-and atom =\n-    ATOM_literal of (lit identified)\n-  | ATOM_lval of lval\n-  | ATOM_pexp of pexp\n-\n-and expr =\n-    EXPR_binary of (binop * atom * atom)\n-  | EXPR_unary of (unop * atom)\n-  | EXPR_atom of atom\n-\n-(* FIXME: The redundancy between exprs and pexps is temporary.\n- * it'll just take a large-ish number of revisions to eliminate. *)\n-\n-and pexp' =\n-    PEXP_call of (pexp * pexp array)\n-  | PEXP_spawn of (domain * string * pexp)\n-  | PEXP_bind of (pexp * pexp option array)\n-  | PEXP_rec of ((ident * mutability * pexp) array * pexp option)\n-  | PEXP_tup of ((mutability * pexp) array)\n-  | PEXP_vec of mutability * (pexp array)\n-  | PEXP_port\n-  | PEXP_chan of (pexp option)\n-  | PEXP_binop of (binop * pexp * pexp)\n-  | PEXP_lazy_and of (pexp * pexp)\n-  | PEXP_lazy_or of (pexp * pexp)\n-  | PEXP_unop of (unop * pexp)\n-  | PEXP_lval of plval\n-  | PEXP_lit of lit\n-  | PEXP_str of string\n-  | PEXP_box of mutability * pexp\n-  | PEXP_custom of name * (pexp array) * (string option)\n-\n-and plval =\n-    PLVAL_base of name_base\n-  | PLVAL_ext_name of (pexp * name_component)\n-  | PLVAL_ext_pexp of (pexp * pexp)\n-  | PLVAL_ext_deref of pexp\n-\n-and pexp = pexp' identified\n-\n-and lit =\n-  | LIT_nil\n-  | LIT_bool of bool\n-  | LIT_mach_int of (ty_mach * int64)\n-  | LIT_int of int64\n-  | LIT_uint of int64\n-  | LIT_char of int\n-      (* FIXME: No support for LIT_mach_float or LIT_float yet. *)\n-\n-\n-and lval_component =\n-    COMP_named of name_component\n-  | COMP_atom of atom\n-  | COMP_deref\n-\n-\n-(* identifying the name_base here is sufficient to identify the full lval *)\n-and lval =\n-    LVAL_base of name_base identified\n-  | LVAL_ext of (lval * lval_component)\n-\n-and binop =\n-    BINOP_or\n-  | BINOP_and\n-  | BINOP_xor\n-\n-  | BINOP_eq\n-  | BINOP_ne\n-\n-  | BINOP_lt\n-  | BINOP_le\n-  | BINOP_ge\n-  | BINOP_gt\n-\n-  | BINOP_lsl\n-  | BINOP_lsr\n-  | BINOP_asr\n-\n-  | BINOP_add\n-  | BINOP_sub\n-  | BINOP_mul\n-  | BINOP_div\n-  | BINOP_mod\n-  | BINOP_send\n-\n-and unop =\n-    UNOP_not\n-  | UNOP_bitnot\n-  | UNOP_neg\n-  | UNOP_cast of ty identified\n-\n-and header_slots = ((slot identified) * ident) array\n-\n-and header_tup = (slot identified) array\n-\n-and fn =\n-    {\n-      fn_input_slots: header_slots;\n-      fn_input_constrs: constrs;\n-      fn_output_slot: slot identified;\n-      fn_aux: ty_fn_aux;\n-      fn_body: block;\n-    }\n-\n-and obj =\n-    {\n-      obj_state: header_slots;\n-      obj_layer: layer;\n-      obj_constrs: constrs;\n-      obj_fns: (ident,fn identified) Hashtbl.t;\n-      obj_drop: block option;\n-    }\n-\n-(*\n- * An 'a decl is a sort-of-thing that represents a parametric (generative)\n- * declaration. Every reference to one of these involves applying 0 or more\n- * type arguments, as part of *name resolution*.\n- *\n- * Slots are *not* parametric declarations. A slot has a specific type\n- * even if it's a type that's bound by a quantifier in its environment.\n- *)\n-\n-and ty_param = ident * (ty_param_idx * layer)\n-\n-and mod_item' =\n-    MOD_ITEM_type of (layer * ty)\n-  | MOD_ITEM_tag of (header_slots * opaque_id * int)\n-  | MOD_ITEM_mod of (mod_view * mod_items)\n-  | MOD_ITEM_fn of fn\n-  | MOD_ITEM_obj of obj\n-  | MOD_ITEM_const of (ty * expr option)\n-\n-and mod_item_decl =\n-    {\n-      decl_params: (ty_param identified) array;\n-      decl_item: mod_item';\n-    }\n-\n-and mod_item = mod_item_decl identified\n-and mod_items = (ident, mod_item) Hashtbl.t\n-\n-and export =\n-    EXPORT_all_decls\n-  | EXPORT_ident of ident\n-\n-and mod_view =\n-    {\n-      view_imports: (ident, name) Hashtbl.t;\n-      view_exports: (export, unit) Hashtbl.t;\n-    }\n-\n-and meta_pat = (string * string option) array\n-\n-and crate' =\n-    {\n-      crate_items: (mod_view * mod_items);\n-      crate_meta: Session.meta;\n-      crate_auth: (name, auth) Hashtbl.t;\n-      crate_required: (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n-      crate_required_syms: (node_id, string) Hashtbl.t;\n-      crate_files: (node_id,filename) Hashtbl.t;\n-      crate_main: name option;\n-    }\n-and crate = crate' identified\n-;;\n-\n-\n-(* Utility values and functions. *)\n-\n-let empty_crate' =\n-  { crate_items = ({ view_imports = Hashtbl.create 0;\n-                     view_exports = Hashtbl.create 0 },\n-                   Hashtbl.create 0);\n-    crate_meta = [||];\n-    crate_auth = Hashtbl.create 0;\n-    crate_required = Hashtbl.create 0;\n-    crate_required_syms = Hashtbl.create 0;\n-    crate_main = None;\n-    crate_files = Hashtbl.create 0 }\n-;;\n-\n-(*\n- * NB: names can only be type-parametric in their *last* path-entry.\n- * All path-entries before that must be ident or idx (non-parametric).\n- *)\n-let sane_name (n:name) : bool =\n-  let rec sane_prefix (n:name) : bool =\n-      match n with\n-          NAME_base (BASE_ident _)\n-        | NAME_base (BASE_temp _) -> true\n-        | NAME_ext (prefix, COMP_ident _)\n-        | NAME_ext (prefix, COMP_idx _) -> sane_prefix prefix\n-        | _ -> false\n-  in\n-    match n with\n-        NAME_base _ -> true\n-      | NAME_ext (prefix, _) -> sane_prefix prefix\n-;;\n-\n-(* Error messages always refer to simple types structurally, not by their\n- * user-defined names. *)\n-let rec ty_is_simple (ty:ty) : bool =\n-  match ty with\n-      TY_any | TY_nil | TY_bool | TY_mach _ | TY_int | TY_uint | TY_char\n-    | TY_str | TY_task | TY_type -> true\n-    | TY_vec ty | TY_chan ty | TY_port ty -> ty_is_simple ty\n-    | TY_tup tys -> List.for_all ty_is_simple (Array.to_list tys)\n-    | _ -> false\n-;;\n-\n-(*\n- * We have multiple subset-categories of expression:\n- *\n- *   - Atomic expressions are just atomic-lvals and literals.\n- *\n- *   - Primitive expressions are 1-level, machine-level operations on atomic\n- *     expressions (so: 1-level binops and unops on atomics)\n- *   - Constant expressions are those that can be evaluated at compile time,\n- *     without calling user code or accessing the communication subsystem. So\n- *     all expressions aside from call, port, chan or spawn, applied to all\n- *     lvals that are themselves constant.\n-\n- *\n- * We similarly have multiple subset-categories of lval:\n- *\n- *   - Name lvals are those that contain no dynamic indices.\n- *\n- *   - Atomic lvals are those indexed by atomic expressions.\n- *\n- *   - Constant lvals are those that are only indexed by constant expressions.\n- *\n- * Rationales:\n- *\n- *   - The primitives are those that can be evaluated without adjusting\n- *     reference counts or otherwise perturbing the lifecycle of anything\n- *     dynamically allocated.\n- *\n- *   - The atomics exist to define the sub-structure of the primitives.\n- *\n- *   - The constants are those we'll compile to read-only memory, either\n- *     immediates in the code-stream or frags in the .rodata section.\n- *\n- * Note:\n- *\n- *   - Constant-expression-ness is defined in semant, and can only be judged\n- *     after resolve has run and connected idents with bindings.\n- *)\n-\n-let rec plval_is_atomic (plval:plval) : bool =\n-  match plval with\n-      PLVAL_base _ -> true\n-\n-    | PLVAL_ext_name (p, _) ->\n-        pexp_is_atomic p\n-\n-    | PLVAL_ext_pexp (a, b) ->\n-        (pexp_is_atomic a) &&\n-          (pexp_is_atomic b)\n-\n-    | PLVAL_ext_deref p ->\n-        pexp_is_atomic p\n-\n-and pexp_is_atomic (pexp:pexp) : bool =\n-  match pexp.node with\n-      PEXP_lval pl -> plval_is_atomic pl\n-    | PEXP_lit _ -> true\n-    | _ -> false\n-;;\n-\n-\n-let pexp_is_primitive (pexp:pexp) : bool =\n-  match pexp.node with\n-      PEXP_binop (_, a, b) ->\n-        (pexp_is_atomic a) &&\n-          (pexp_is_atomic b)\n-    | PEXP_unop (_, p) ->\n-        pexp_is_atomic p\n-    | PEXP_lval pl ->\n-        plval_is_atomic pl\n-    | PEXP_lit _ -> true\n-    | _ -> false\n-;;\n-\n-\n-(* Pretty-printing. *)\n-\n-let fmt_ident (ff:Format.formatter) (i:ident) : unit =\n-  fmt ff  \"%s\" i\n-\n-let fmt_temp (ff:Format.formatter) (t:temp_id) : unit =\n-  fmt ff  \".t%d\" (int_of_temp t)\n-\n-let fmt_slot_key ff (s:slot_key) : unit =\n-  match s with\n-      KEY_ident i -> fmt_ident ff i\n-    | KEY_temp t -> fmt_temp ff t\n-\n-let rec fmt_app (ff:Format.formatter) (i:ident) (tys:ty array) : unit =\n-  fmt ff \"%s\" i;\n-  fmt_app_args ff tys\n-\n-and fmt_app_args (ff:Format.formatter) (tys:ty array) : unit =\n-  fmt ff \"[@[\";\n-  for i = 0 to (Array.length tys) - 1;\n-  do\n-    if i != 0\n-    then fmt ff \",@ \";\n-    fmt_ty ff tys.(i);\n-  done;\n-  fmt ff \"@]]\"\n-\n-and fmt_name_base (ff:Format.formatter) (nb:name_base) : unit =\n-  match nb with\n-      BASE_ident i -> fmt_ident ff i\n-    | BASE_temp t -> fmt_temp ff t\n-    | BASE_app (id, tys) -> fmt_app ff id tys\n-\n-and fmt_name_component (ff:Format.formatter) (nc:name_component) : unit =\n-  match nc with\n-      COMP_ident i -> fmt_ident ff i\n-    | COMP_app (id, tys) -> fmt_app ff id tys\n-    | COMP_idx i -> fmt ff \"_%d\" i\n-\n-and fmt_name (ff:Format.formatter) (n:name) : unit =\n-  match n with\n-      NAME_base nb -> fmt_name_base ff nb\n-    | NAME_ext (n, nc) ->\n-        fmt_name ff n;\n-        fmt ff \".\";\n-        fmt_name_component ff nc\n-\n-and fmt_mode (ff:Format.formatter) (m:mode) : unit =\n-  match m with\n-    | MODE_alias -> fmt ff \"&\"\n-    | MODE_local -> ()\n-\n-and fmt_slot (ff:Format.formatter) (s:slot) : unit =\n-  match s.slot_ty with\n-      None -> fmt ff \"auto\"\n-    | Some t ->\n-        fmt_mode ff s.slot_mode;\n-        fmt_ty ff t\n-\n-and fmt_tys\n-    (ff:Format.formatter)\n-    (tys:ty array)\n-    : unit =\n-  fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_ty ff tys\n-\n-and fmt_ident_tys\n-    (ff:Format.formatter)\n-    (entries:(ident * ty) array)\n-    : unit =\n-  fmt_bracketed_arr_sep \"(\" \")\" \",\"\n-    (fun ff (ident, ty) ->\n-       fmt_ty ff ty;\n-       fmt ff \" \";\n-       fmt_ident ff ident)\n-    ff\n-    entries\n-\n-and fmt_slots\n-    (ff:Format.formatter)\n-    (slots:slot array)\n-    (idents:(ident array) option)\n-    : unit =\n-  fmt ff \"(@[\";\n-  for i = 0 to (Array.length slots) - 1\n-  do\n-    if i != 0\n-    then fmt ff \",@ \";\n-    fmt_slot ff slots.(i);\n-    begin\n-      match idents with\n-          None -> ()\n-        | Some ids -> (fmt ff \" \"; fmt_ident ff ids.(i))\n-    end;\n-  done;\n-  fmt ff \"@])\"\n-\n-and fmt_layer\n-    (ff:Format.formatter)\n-    (la:layer)\n-    : unit =\n-  match la with\n-      LAYER_value -> ()\n-    | LAYER_state -> fmt ff \"state\"\n-    | LAYER_gc -> fmt ff \"gc\"\n-\n-and fmt_layer_qual\n-    (ff:Format.formatter)\n-    (s:layer)\n-    : unit =\n-  fmt_layer ff s;\n-  if s <> LAYER_value then fmt ff \" \";\n-\n-and fmt_ty_fn\n-    (ff:Format.formatter)\n-    (ident_and_params:(ident * ty_param array) option)\n-    (tf:ty_fn)\n-    : unit =\n-  let (tsig, ta) = tf in\n-    fmt ff \"%s\" (if ta.fn_is_iter then \"iter\" else \"fn\");\n-    begin\n-      match ident_and_params with\n-          Some (id, params) ->\n-            fmt ff \" \";\n-            fmt_ident_and_params ff id params\n-        | None -> ()\n-    end;\n-    fmt_slots ff tsig.sig_input_slots None;\n-    fmt_decl_constrs ff tsig.sig_input_constrs;\n-    if tsig.sig_output_slot.slot_ty <> (Some TY_nil)\n-    then\n-      begin\n-        fmt ff \" -> \";\n-        fmt_slot ff tsig.sig_output_slot;\n-      end\n-\n-and fmt_constrained ff (ty, constrs) : unit =\n-  fmt ff \"@[\";\n-  fmt_ty ff ty;\n-  fmt ff \" : \";\n-  fmt ff \"@[\";\n-  fmt_constrs ff constrs;\n-  fmt ff \"@]\";\n-  fmt ff \"@]\";\n-\n-\n-and fmt_ty (ff:Format.formatter) (t:ty) : unit =\n-  match t with\n-    TY_any -> fmt ff \"any\"\n-  | TY_nil -> fmt ff \"()\"\n-  | TY_bool -> fmt ff \"bool\"\n-  | TY_mach m -> fmt_mach ff m\n-  | TY_int -> fmt ff \"int\"\n-  | TY_uint -> fmt ff \"uint\"\n-  | TY_char -> fmt ff \"char\"\n-  | TY_str -> fmt ff \"str\"\n-\n-  | TY_tup tys -> (fmt ff \"tup\"; fmt_tys ff tys)\n-  | TY_vec t -> (fmt ff \"vec[\"; fmt_ty ff t; fmt ff \"]\")\n-  | TY_chan t -> (fmt ff \"chan[\"; fmt_ty ff t; fmt ff \"]\")\n-  | TY_port t -> (fmt ff \"port[\"; fmt_ty ff t; fmt ff \"]\")\n-\n-  | TY_rec entries ->\n-      fmt ff \"@[rec\";\n-      fmt_ident_tys ff entries;\n-      fmt ff \"@]\"\n-\n-  | TY_param (i, s) -> (fmt_layer_qual ff s;\n-                        fmt ff \"<p#%d>\" i)\n-  | TY_native oid -> fmt ff \"<native#%d>\" (int_of_opaque oid)\n-  | TY_named n -> fmt_name ff n\n-  | TY_type -> fmt ff \"type\"\n-\n-  | TY_box t ->\n-      fmt ff \"@@\";\n-      fmt_ty ff t\n-\n-  | TY_mutable t ->\n-      fmt ff \"mutable \";\n-      fmt_ty ff t\n-\n-  | TY_fn tfn -> fmt_ty_fn ff None tfn\n-  | TY_task -> fmt ff \"task\"\n-  | TY_tag ttag ->\n-        fmt ff \"<tag#%d\" (int_of_opaque ttag.tag_id);\n-        fmt_arr_sep \",\" fmt_ty ff ttag.tag_args;\n-        fmt ff \">\";\n-\n-  | TY_constrained ctrd -> fmt_constrained ff ctrd\n-\n-  | TY_obj (layer, fns) ->\n-      fmt_obox ff;\n-      fmt_layer_qual ff layer;\n-      fmt ff \"obj \";\n-      fmt_obr ff;\n-      Hashtbl.iter\n-        begin\n-          fun id fn ->\n-            fmt ff \"@\\n\";\n-            fmt_ty_fn ff (Some (id, [||])) fn;\n-            fmt ff \";\"\n-        end\n-        fns;\n-      fmt_cbb ff\n-\n-\n-and fmt_constrs (ff:Format.formatter) (cc:constr array) : unit =\n-  for i = 0 to (Array.length cc) - 1\n-  do\n-    if i != 0\n-    then fmt ff \",@ \";\n-    fmt_constr ff cc.(i)\n-  done;\n-  (* Array.iter (fmt_constr ff) cc *)\n-\n-and fmt_decl_constrs (ff:Format.formatter) (cc:constr array) : unit =\n-  if Array.length cc = 0\n-  then ()\n-  else\n-    begin\n-      fmt ff \" : \";\n-      fmt_constrs ff cc\n-    end\n-\n-and fmt_constr (ff:Format.formatter) (c:constr) : unit =\n-  fmt_name ff c.constr_name;\n-  fmt ff \"(@[\";\n-  for i = 0 to (Array.length c.constr_args) - 1\n-  do\n-    if i != 0\n-    then fmt ff \",@ \";\n-    fmt_carg ff c.constr_args.(i);\n-  done;\n-  fmt ff \"@])\"\n-\n-and fmt_carg_path (ff:Format.formatter) (cp:carg_path) : unit =\n-  match cp with\n-      CARG_base BASE_formal -> fmt ff \"*\"\n-    | CARG_base (BASE_named nb) -> fmt_name_base ff nb\n-    | CARG_ext (base, nc) ->\n-        fmt_carg_path ff base;\n-        fmt ff \".\";\n-        fmt_name_component ff nc\n-\n-and fmt_carg (ff:Format.formatter) (ca:carg) : unit =\n-  match ca with\n-      CARG_path cp -> fmt_carg_path ff cp\n-    | CARG_lit lit -> fmt_lit ff lit\n-\n-and fmt_stmts (ff:Format.formatter) (ss:stmt array) : unit =\n-  Array.iter (fmt_stmt ff) ss;\n-\n-and fmt_block (ff:Format.formatter) (b:stmt array) : unit =\n-  fmt_obox ff;\n-  fmt_obr ff;\n-  fmt_stmts ff b;\n-  fmt_cbb ff;\n-\n-and fmt_binop (ff:Format.formatter) (b:binop) : unit =\n-  fmt ff \"%s\"\n-    begin\n-      match b with\n-          BINOP_or -> \"|\"\n-        | BINOP_and -> \"&\"\n-        | BINOP_xor -> \"^\"\n-\n-        | BINOP_eq -> \"==\"\n-        | BINOP_ne -> \"!=\"\n-\n-        | BINOP_lt -> \"<\"\n-        | BINOP_le -> \"<=\"\n-        | BINOP_ge -> \">=\"\n-        | BINOP_gt -> \">\"\n-\n-        | BINOP_lsl -> \"<<\"\n-        | BINOP_lsr -> \">>\"\n-        | BINOP_asr -> \">>>\"\n-\n-        | BINOP_add -> \"+\"\n-        | BINOP_sub -> \"-\"\n-        | BINOP_mul -> \"*\"\n-        | BINOP_div -> \"/\"\n-        | BINOP_mod -> \"%\"\n-        | BINOP_send -> \"<|\"\n-    end\n-\n-\n-and fmt_unop (ff:Format.formatter) (u:unop) (a:atom) : unit =\n-  begin\n-    match u with\n-        UNOP_not ->\n-          fmt ff \"!\";\n-          fmt_atom ff a\n-\n-      | UNOP_bitnot ->\n-          fmt ff \"~\";\n-          fmt_atom ff a\n-\n-      | UNOP_neg ->\n-          fmt ff \"-\";\n-          fmt_atom ff a\n-\n-      | UNOP_cast t ->\n-          fmt_atom ff a;\n-          fmt ff \" as \";\n-          fmt_ty ff t.node;\n-  end\n-\n-and fmt_expr (ff:Format.formatter) (e:expr) : unit =\n-  match e with\n-    EXPR_binary (b,a1,a2) ->\n-      begin\n-        fmt_atom ff a1;\n-        fmt ff \" \";\n-        fmt_binop ff b;\n-        fmt ff \" \";\n-        fmt_atom ff a2\n-      end\n-  | EXPR_unary (u,a) ->\n-      begin\n-        fmt_unop ff u a;\n-      end\n-  | EXPR_atom a -> fmt_atom ff a\n-\n-and fmt_mutability (ff:Format.formatter) (mut:mutability) : unit =\n-  if mut = MUT_mutable then fmt ff \"mutable \"\n-\n-and fmt_pexp (ff:Format.formatter) (pexp:pexp) : unit =\n-  match pexp.node with\n-      PEXP_call (fn, args) ->\n-        fmt_pexp ff fn;\n-        fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_pexp ff args\n-\n-    | PEXP_spawn (dom, name, call) ->\n-        fmt_domain ff dom;\n-        fmt_str ff (\"\\\"\" ^ name ^ \"\\\"\");\n-        fmt_pexp ff call\n-\n-    | PEXP_bind (fn, arg_opts) ->\n-        fmt_pexp ff fn;\n-        let fmt_opt ff opt =\n-          match opt with\n-              None -> fmt ff \"_\"\n-            | Some p -> fmt_pexp ff p\n-        in\n-          fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_opt ff arg_opts\n-\n-    | PEXP_rec (elts, base) ->\n-        fmt_obox_n ff 0;\n-        fmt ff \"rec(\";\n-        let fmt_elt ff (ident, mut, pexp) =\n-          fmt_mutability ff mut;\n-          fmt_ident ff ident;\n-          fmt ff \" = \";\n-          fmt_pexp ff pexp;\n-        in\n-          fmt_arr_sep \",\" fmt_elt ff elts;\n-          begin\n-            match base with\n-                None -> ()\n-              | Some b ->\n-                  fmt ff \" with \";\n-                  fmt_pexp ff b\n-          end;\n-          fmt_cbox ff;\n-          fmt ff \")\"\n-\n-    | PEXP_tup elts ->\n-        fmt ff \"tup\";\n-        let fmt_elt ff (mut, pexp) =\n-          fmt_mutability ff mut;\n-          fmt_pexp ff pexp\n-        in\n-          fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_elt ff elts\n-\n-    | PEXP_vec (mut, elts) ->\n-        fmt ff \"vec\";\n-        if mut = MUT_mutable then fmt ff \"[mutable]\";\n-        fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_pexp ff elts\n-\n-    | PEXP_port ->\n-        fmt ff \"port()\"\n-\n-    | PEXP_chan None ->\n-        fmt ff \"chan()\"\n-\n-    | PEXP_chan (Some pexp) ->\n-        fmt ff \"chan\";\n-        fmt_bracketed \"(\" \")\" fmt_pexp ff pexp\n-\n-    | PEXP_binop (binop, a, b) ->\n-        fmt_pexp ff a;\n-        fmt ff \" \";\n-        fmt_binop ff binop;\n-        fmt ff \" \";\n-        fmt_pexp ff b;\n-\n-    | PEXP_lazy_and (a, b) ->\n-        fmt_pexp ff a;\n-        fmt ff \" && \";\n-        fmt_pexp ff b\n-\n-    | PEXP_lazy_or (a, b) ->\n-        fmt_pexp ff a;\n-        fmt ff \" || \";\n-        fmt_pexp ff b\n-\n-    | PEXP_unop (unop, pexp) ->\n-        begin\n-          match unop with\n-              UNOP_not ->\n-                fmt ff \"!\";\n-                fmt_pexp ff pexp\n-\n-            | UNOP_bitnot ->\n-                fmt ff \"~\";\n-                fmt_pexp ff pexp\n-\n-            | UNOP_neg ->\n-                fmt ff \"-\";\n-                fmt_pexp ff pexp\n-\n-            | UNOP_cast t ->\n-                fmt_pexp ff pexp;\n-                fmt ff \" as \";\n-                fmt_ty ff t.node\n-        end\n-\n-    | PEXP_lval plval ->\n-        fmt_plval ff plval\n-\n-    | PEXP_lit lit ->\n-        fmt_lit ff lit\n-\n-    | PEXP_str str -> fmt_str ff  (\"\\\"\" ^ str ^ \"\\\"\")\n-\n-    | PEXP_box (mut, pexp) ->\n-        fmt_mutability ff mut;\n-        fmt ff \"@@\";\n-        fmt_pexp ff pexp\n-\n-    | PEXP_custom (name, args, txt) ->\n-        fmt ff \"#\";\n-        fmt_name ff name;\n-        fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_pexp ff args;\n-        match txt with\n-            None -> ()\n-          | Some t -> fmt ff \"{%s}\" t\n-\n-\n-and fmt_plval (ff:Format.formatter) (plval:plval) : unit =\n-  match plval with\n-      PLVAL_base nb -> fmt_name_base ff nb\n-\n-    | PLVAL_ext_name (pexp, nc) ->\n-        fmt_pexp ff pexp;\n-        fmt ff \".\";\n-        fmt_name_component ff nc\n-\n-    | PLVAL_ext_pexp (pexp, ext) ->\n-        fmt_pexp ff pexp;\n-        fmt_bracketed \".(\" \")\" fmt_pexp ff ext\n-\n-    | PLVAL_ext_deref pexp ->\n-        fmt ff \"*\";\n-        fmt_pexp ff pexp\n-\n-\n-and fmt_mach (ff:Format.formatter) (m:ty_mach) : unit =\n-  match m with\n-    TY_u8 -> fmt ff \"u8\"\n-  | TY_u16 -> fmt ff \"u16\"\n-  | TY_u32 -> fmt ff \"u32\"\n-  | TY_u64 -> fmt ff \"u64\"\n-  | TY_i8 -> fmt ff \"i8\"\n-  | TY_i16 -> fmt ff \"i16\"\n-  | TY_i32 -> fmt ff \"i32\"\n-  | TY_i64 -> fmt ff \"i64\"\n-  | TY_f32 -> fmt ff \"f32\"\n-  | TY_f64 -> fmt ff \"f64\"\n-\n-and fmt_lit (ff:Format.formatter) (l:lit) : unit =\n-  match l with\n-  | LIT_nil -> fmt ff \"()\"\n-  | LIT_bool true -> fmt ff \"true\"\n-  | LIT_bool false -> fmt ff \"false\"\n-  | LIT_mach_int (m, i) ->\n-      begin\n-        fmt ff \"%Ld\" i;\n-        fmt_mach ff m;\n-      end\n-  | LIT_int i -> fmt ff \"%Ld\" i\n-  | LIT_uint i ->\n-      fmt ff \"%Ld\" i;\n-      fmt ff \"u\"\n-  | LIT_char c -> fmt ff \"'%s'\" (Common.escaped_char c)\n-\n-and fmt_domain (ff:Format.formatter) (d:domain) : unit =\n-  match d with\n-      DOMAIN_local -> ()\n-    | DOMAIN_thread -> fmt ff \"thread \"\n-\n-and fmt_atom (ff:Format.formatter) (a:atom) : unit =\n-  match a with\n-      ATOM_literal lit -> fmt_lit ff lit.node\n-    | ATOM_lval lval -> fmt_lval ff lval\n-    | ATOM_pexp pexp -> fmt_pexp ff pexp\n-\n-and fmt_atoms (ff:Format.formatter) (az:atom array) : unit =\n-  fmt ff \"(\";\n-  Array.iteri\n-    begin\n-      fun i a ->\n-        if i != 0\n-        then fmt ff \", \";\n-        fmt_atom ff a;\n-    end\n-    az;\n-  fmt ff \")\"\n-\n-and fmt_atom_opts (ff:Format.formatter) (az:(atom option) array) : unit =\n-  fmt ff \"(\";\n-  Array.iteri\n-    begin\n-      fun i a ->\n-        if i != 0\n-        then fmt ff \", \";\n-        match a with\n-            None -> fmt ff \"_\"\n-          | Some a -> fmt_atom ff a;\n-    end\n-    az;\n-  fmt ff \")\"\n-\n-and fmt_lval (ff:Format.formatter) (l:lval) : unit =\n-  match l with\n-      LVAL_base nbi -> fmt_name_base ff nbi.node\n-    | LVAL_ext (lv, lvc) ->\n-        begin\n-          match lvc with\n-              COMP_named nc ->\n-                fmt_lval ff lv;\n-                fmt ff \".\";\n-                fmt_name_component ff nc\n-            | COMP_atom a ->\n-                fmt_lval ff lv;\n-                fmt ff \".\";\n-                fmt_bracketed \"(\" \")\" fmt_atom ff a;\n-            | COMP_deref ->\n-                fmt ff \"*\";\n-                fmt_lval ff lv\n-        end\n-\n-and fmt_stmt (ff:Format.formatter) (s:stmt) : unit =\n-  fmt ff \"@\\n\";\n-  fmt_stmt_body ff s\n-\n-and fmt_stmt_body (ff:Format.formatter) (s:stmt) : unit =\n-  begin\n-    match s.node with\n-        STMT_log at ->\n-          begin\n-            fmt ff \"log \";\n-            fmt_atom ff at;\n-            fmt ff \";\"\n-          end\n-\n-      | STMT_log_err at ->\n-          begin\n-            fmt ff \"log_err \";\n-            fmt_atom ff at;\n-            fmt ff \";\"\n-          end\n-\n-      | STMT_spawn (dst, domain, name, fn, args) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = spawn \";\n-          fmt_domain ff domain;\n-          fmt_str ff (\"\\\"\" ^ name ^ \"\\\"\");\n-          fmt_lval ff fn;\n-          fmt_atoms ff args;\n-          fmt ff \";\";\n-\n-      | STMT_while sw ->\n-          let (stmts, e) = sw.while_lval in\n-            begin\n-              fmt_obox ff;\n-              fmt ff \"while (\";\n-              if Array.length stmts != 0\n-              then fmt_block ff stmts;\n-              fmt_expr ff e;\n-              fmt ff \") \";\n-              fmt_obr ff;\n-              fmt_stmts ff sw.while_body.node;\n-              fmt_cbb ff\n-            end\n-\n-      | STMT_do_while sw ->\n-          let (stmts, e) = sw.while_lval in\n-            begin\n-              fmt_obox ff;\n-              fmt ff \"do \";\n-              fmt_obr ff;\n-              fmt_stmts ff sw.while_body.node;\n-              fmt ff \"while (\";\n-              if Array.length stmts != 0\n-              then fmt_block ff stmts;\n-              fmt_expr ff e;\n-              fmt ff \");\";\n-              fmt_cbb ff\n-            end\n-\n-      | STMT_if sif ->\n-          fmt_obox ff;\n-          fmt ff \"if (\";\n-          fmt_expr ff sif.if_test;\n-          fmt ff \") \";\n-          fmt_obr ff;\n-          fmt_stmts ff sif.if_then.node;\n-          begin\n-            match sif.if_else with\n-                None -> ()\n-              | Some e ->\n-                  begin\n-                    fmt_cbb ff;\n-                    fmt_obox_n ff 3;\n-                    fmt ff \" else \";\n-                    fmt_obr ff;\n-                    fmt_stmts ff e.node\n-                  end\n-          end;\n-          fmt_cbb ff\n-\n-      | STMT_ret (ao) ->\n-          fmt ff \"ret\";\n-          begin\n-            match ao with\n-                None -> ()\n-              | Some at ->\n-                  fmt ff \" \";\n-                  fmt_atom ff at\n-          end;\n-          fmt ff \";\"\n-\n-      | STMT_be (fn, az) ->\n-          fmt ff \"be \";\n-          fmt_lval ff fn;\n-          fmt_atoms ff az;\n-          fmt ff \";\";\n-\n-      | STMT_break -> fmt ff \"break;\";\n-\n-      | STMT_cont -> fmt ff \"cont;\";\n-\n-      | STMT_block b -> fmt_block ff b.node\n-\n-      | STMT_copy (lv, ex) ->\n-          fmt_lval ff lv;\n-          fmt ff \" = \";\n-          fmt_expr ff ex;\n-          fmt ff \";\"\n-\n-      | STMT_copy_binop (lv, binop, at) ->\n-          fmt_lval ff lv;\n-          fmt ff \" \";\n-          fmt_binop ff binop;\n-          fmt ff \"= \";\n-          fmt_atom ff at;\n-          fmt ff \";\"\n-\n-      | STMT_call (dst, fn, args) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = \";\n-          fmt_lval ff fn;\n-          fmt_atoms ff args;\n-          fmt ff \";\";\n-\n-      | STMT_bind (dst, fn, arg_opts) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = bind \";\n-          fmt_lval ff fn;\n-          fmt_atom_opts ff arg_opts;\n-          fmt ff \";\";\n-\n-      | STMT_decl (DECL_slot (skey, sloti)) ->\n-          if sloti.node.slot_ty != None then fmt ff \"let \";\n-          fmt_slot ff sloti.node;\n-          fmt ff \" \";\n-          fmt_slot_key ff skey;\n-          fmt ff \";\"\n-\n-      | STMT_decl (DECL_mod_item (ident, item)) ->\n-          fmt_mod_item ff ident item\n-\n-      | STMT_new_rec (dst, entries, base) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = rec(\";\n-          for i = 0 to (Array.length entries) - 1\n-          do\n-            if i != 0\n-            then fmt ff \", \";\n-            let (ident, mutability, atom) = entries.(i) in\n-              if mutability = MUT_mutable then fmt ff \"mutable \";\n-              fmt_ident ff ident;\n-              fmt ff \" = \";\n-              fmt_atom ff atom;\n-          done;\n-          begin\n-            match base with\n-                None -> ()\n-              | Some b ->\n-                  fmt ff \" with \";\n-                  fmt_lval ff b\n-          end;\n-          fmt ff \");\"\n-\n-      | STMT_new_vec (dst, mutability, atoms) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = vec\";\n-          if mutability = MUT_mutable then fmt ff \"[mutable]\";\n-          fmt ff \"(\";\n-          for i = 0 to (Array.length atoms) - 1\n-          do\n-            if i != 0\n-            then fmt ff \", \";\n-            fmt_atom ff atoms.(i);\n-          done;\n-          fmt ff \");\"\n-\n-      | STMT_new_tup (dst, entries) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = tup(\";\n-          for i = 0 to (Array.length entries) - 1\n-          do\n-            if i != 0\n-            then fmt ff \", \";\n-            let (mutability, atom) = entries.(i) in\n-            if mutability = MUT_mutable then fmt ff \"mutable \";\n-            fmt_atom ff atom;\n-          done;\n-          fmt ff \");\";\n-\n-      | STMT_new_str (dst, s) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = \\\"%s\\\"\" (String.escaped s)\n-\n-      | STMT_new_port dst ->\n-          fmt_lval ff dst;\n-          fmt ff \" = port();\"\n-\n-      | STMT_new_chan (dst, port_opt) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = chan(\";\n-          begin\n-            match port_opt with\n-                None -> ()\n-              | Some lv -> fmt_lval ff lv\n-          end;\n-          fmt ff \");\"\n-\n-      | STMT_check_expr expr ->\n-          fmt ff \"check (\";\n-          fmt_expr ff expr;\n-          fmt ff \");\"\n-\n-      | STMT_check_if (constrs, _, block) ->\n-          fmt_obox ff;\n-          fmt ff \"check if (\";\n-          fmt_constrs ff constrs;\n-          fmt ff \")\";\n-          fmt_obr ff;\n-          fmt_stmts ff block.node;\n-          fmt_cbb ff\n-\n-      | STMT_check (constrs, _) ->\n-          fmt ff \"check \";\n-          fmt_constrs ff constrs;\n-          fmt ff \";\"\n-\n-      | STMT_prove constrs ->\n-          fmt ff \"prove \";\n-          fmt_constrs ff constrs;\n-          fmt ff \";\"\n-\n-      | STMT_for sfor ->\n-          let (slot, ident) = sfor.for_slot in\n-          let lval = sfor.for_seq in\n-            begin\n-              fmt_obox ff;\n-              fmt ff \"for (\";\n-              fmt_slot ff slot.node;\n-              fmt ff \" \";\n-              fmt_ident ff ident;\n-              fmt ff \" in \";\n-              fmt_lval ff lval;\n-              fmt ff \") \";\n-              fmt_obr ff;\n-              fmt_stmts ff sfor.for_body.node;\n-              fmt_cbb ff\n-            end\n-\n-      | STMT_for_each sf ->\n-          let (slot, ident) = sf.for_each_slot in\n-          let (f, az) = sf.for_each_call in\n-            begin\n-              fmt_obox ff;\n-              fmt ff \"for each (\";\n-              fmt_slot ff slot.node;\n-              fmt ff \" \";\n-              fmt_ident ff ident;\n-              fmt ff \" in \";\n-              fmt_lval ff f;\n-              fmt_atoms ff az;\n-              fmt ff \") \";\n-              fmt_obr ff;\n-              fmt_stmts ff sf.for_each_body.node;\n-              fmt_cbb ff\n-            end\n-\n-      | STMT_put (atom) ->\n-          fmt ff \"put\";\n-          begin\n-            match atom with\n-                Some a -> (fmt ff \" \"; fmt_atom ff a)\n-              | None -> ()\n-          end;\n-          fmt ff \";\"\n-\n-      | STMT_put_each (f, az) ->\n-          fmt ff \"put each \";\n-          fmt_lval ff f;\n-          fmt_atoms ff az;\n-          fmt ff \";\"\n-\n-      | STMT_fail -> fmt ff \"fail;\"\n-      | STMT_yield -> fmt ff \"yield;\"\n-\n-      | STMT_send (chan, v) ->\n-          fmt_lval ff chan;\n-          fmt ff \" <| \";\n-          fmt_lval ff v;\n-          fmt ff \";\";\n-\n-      | STMT_recv (d, port) ->\n-          fmt_lval ff d;\n-          fmt ff \" <- \";\n-          fmt_lval ff port;\n-          fmt ff \";\";\n-\n-      | STMT_join t ->\n-          fmt ff \"join \";\n-          fmt_lval ff t;\n-          fmt ff \";\"\n-\n-      | STMT_new_box (lv, mutability, at) ->\n-          fmt_lval ff lv;\n-          fmt ff \" = @@\";\n-          if mutability = MUT_mutable then fmt ff \" mutable \";\n-          fmt_atom ff at;\n-          fmt ff \";\"\n-\n-      | STMT_alt_tag at ->\n-          fmt_obox ff;\n-          fmt ff \"alt (\";\n-          fmt_lval ff at.alt_tag_lval;\n-          fmt ff \") \";\n-          fmt_obr ff;\n-          Array.iter (fmt_tag_arm ff) at.alt_tag_arms;\n-          fmt_cbb ff;\n-\n-      | STMT_alt_type at ->\n-          fmt_obox ff;\n-          fmt ff \"alt type (\";\n-          fmt_lval ff at.alt_type_lval;\n-          fmt ff \") \";\n-          fmt_obr ff;\n-          Array.iter (fmt_type_arm ff) at.alt_type_arms;\n-          begin\n-            match at.alt_type_else with\n-                None -> ()\n-              | Some block ->\n-                  fmt ff \"@\\n\";\n-                  fmt_obox ff;\n-                  fmt ff \"case (_) \";\n-                  fmt_obr ff;\n-                  fmt_stmts ff block.node;\n-                  fmt_cbb ff;\n-          end;\n-          fmt_cbb ff;\n-      | STMT_alt_port at ->\n-          fmt_obox ff;\n-          fmt ff \"alt \";\n-          fmt_obr ff;\n-          Array.iter (fmt_port_arm ff) at.alt_port_arms;\n-          begin\n-            match at.alt_port_else with\n-                None -> ()\n-              | Some (timeout, block) ->\n-                  fmt ff \"@\\n\";\n-                  fmt_obox ff;\n-                  fmt ff \"case (_) \";\n-                  fmt_atom ff timeout;\n-                  fmt ff \" \";\n-                  fmt_obr ff;\n-                  fmt_stmts ff block.node;\n-                  fmt_cbb ff;\n-          end;\n-          fmt_cbb ff;\n-      | STMT_note at ->\n-          begin\n-            fmt ff \"note \";\n-            fmt_atom ff at;\n-            fmt ff \";\"\n-          end\n-      | STMT_slice (dst, src, slice) ->\n-          fmt_lval ff dst;\n-          fmt ff \" = \";\n-          fmt_lval ff src;\n-          fmt ff \".\";\n-          fmt_slice ff slice;\n-          fmt ff \";\";\n-  end\n-\n-and fmt_arm\n-    (ff:Format.formatter)\n-    (fmt_arm_case_expr : Format.formatter -> unit)\n-    (block : block)\n-    : unit =\n-  fmt ff \"@\\n\";\n-  fmt_obox ff;\n-  fmt ff \"case (\";\n-  fmt_arm_case_expr ff;\n-  fmt ff \") \";\n-  fmt_obr ff;\n-  fmt_stmts ff block.node;\n-  fmt_cbb ff;\n-\n-and fmt_tag_arm (ff:Format.formatter) (tag_arm:tag_arm) : unit =\n-  let (pat, block) = tag_arm.node in\n-    fmt_arm ff (fun ff -> fmt_pat ff pat) block;\n-\n-and fmt_type_arm (ff:Format.formatter) (type_arm:type_arm) : unit =\n-  let ((ident, slot), block) = type_arm.node in\n-  let fmt_type_arm_case (ff:Format.formatter) =\n-    fmt_slot ff slot; fmt ff \" \"; fmt_ident ff ident\n-  in\n-    fmt_arm ff fmt_type_arm_case block;\n-and fmt_port_arm (ff:Format.formatter) (port_arm:port_arm) : unit =\n-  let (port_case, block) = port_arm.node in\n-    fmt_arm ff (fun ff -> fmt_port_case ff port_case) block;\n-\n-and fmt_port_case (ff:Format.formatter) (port_case:port_case) : unit =\n-  let stmt' = match port_case with\n-      PORT_CASE_send params -> STMT_send params\n-    | PORT_CASE_recv params -> STMT_recv params in\n-    fmt_stmt ff {node = stmt'; id = Node 0};\n-\n-and fmt_pat (ff:Format.formatter) (pat:pat) : unit =\n-  match pat with\n-      PAT_lit lit ->\n-        fmt_lit ff lit\n-    | PAT_tag (ctor, pats) ->\n-        fmt_lval ff ctor;\n-        fmt_bracketed_arr_sep \"(\" \")\" \",\" fmt_pat ff pats\n-    | PAT_slot (_, ident) ->\n-        fmt ff \"?\";\n-        fmt_ident ff ident\n-    | PAT_wild ->\n-        fmt ff \"_\"\n-\n-and fmt_slice (ff:Format.formatter) (slice:slice) : unit =\n-  let fmt_slice_start = (match slice.slice_start with\n-                             None -> (fun ff -> fmt ff \"0\")\n-                           | Some atom -> (fun ff -> fmt_atom ff atom)) in\n-    fmt ff \"(@[\";\n-    fmt_slice_start ff;\n-    begin\n-      match slice.slice_len with\n-          None -> fmt ff \",\"\n-        | Some slice_len ->\n-            fmt ff \",@ @[\";\n-            fmt_slice_start ff;\n-            fmt ff \" +@ \";\n-            fmt_atom ff slice_len;\n-            fmt ff \"@]\";\n-    end;\n-    fmt ff \"@])\";\n-\n-\n-\n-\n-and fmt_decl_param (ff:Format.formatter) (param:ty_param) : unit =\n-  let (ident, (i, s)) = param in\n-  fmt_layer_qual ff s;\n-  fmt_ident ff ident;\n-  fmt ff \"=<p#%d>\" i\n-\n-and fmt_decl_params (ff:Format.formatter) (params:ty_param array) : unit =\n-  if Array.length params = 0\n-  then ()\n-  else\n-    fmt_bracketed_arr_sep \"[\" \"]\" \",\" fmt_decl_param ff params\n-\n-and fmt_header_slots (ff:Format.formatter) (hslots:header_slots) : unit =\n-  fmt_slots ff\n-    (Array.map (fun (s,_) -> s.node) hslots)\n-    (Some (Array.map (fun (_, i) -> i) hslots))\n-\n-and fmt_ident_and_params\n-    (ff:Format.formatter)\n-    (id:ident)\n-    (params:ty_param array)\n-    : unit =\n-  fmt_ident ff id;\n-  fmt_decl_params ff params\n-\n-and fmt_fn\n-    (ff:Format.formatter)\n-    (id:ident)\n-    (params:ty_param array)\n-    (f:fn)\n-    : unit =\n-  fmt_obox ff;\n-  fmt ff \"%s \"(if f.fn_aux.fn_is_iter then \"iter\" else \"fn\");\n-  fmt_ident_and_params ff id params;\n-  fmt_header_slots ff f.fn_input_slots;\n-  fmt_decl_constrs ff f.fn_input_constrs;\n-  if f.fn_output_slot.node.slot_ty <> (Some TY_nil)\n-  then\n-    begin\n-      fmt ff \" -> \";\n-      fmt_slot ff f.fn_output_slot.node;\n-    end;\n-  fmt ff \" \";\n-  fmt_obr ff;\n-  fmt_stmts ff f.fn_body.node;\n-  fmt_cbb ff\n-\n-\n-and fmt_obj\n-    (ff:Format.formatter)\n-    (id:ident)\n-    (params:ty_param array)\n-    (obj:obj)\n-    : unit =\n-  fmt_obox ff;\n-  fmt_layer_qual ff obj.obj_layer;\n-  fmt ff \"obj \";\n-  fmt_ident_and_params ff id params;\n-  fmt_header_slots ff obj.obj_state;\n-  fmt_decl_constrs ff obj.obj_constrs;\n-  fmt ff \" \";\n-  fmt_obr ff;\n-  Hashtbl.iter\n-    begin\n-      fun id fn ->\n-        fmt ff \"@\\n\";\n-        fmt_fn ff id [||] fn.node\n-    end\n-    obj.obj_fns;\n-  begin\n-    match obj.obj_drop with\n-        None -> ()\n-      | Some d ->\n-          begin\n-            fmt ff \"@\\n\";\n-            fmt_obox ff;\n-            fmt ff \"drop \";\n-            fmt_obr ff;\n-            fmt_stmts ff d.node;\n-            fmt_cbb ff;\n-          end\n-  end;\n-  fmt_cbb ff\n-\n-\n-and fmt_mod_item (ff:Format.formatter) (id:ident) (item:mod_item) : unit =\n-  fmt ff \"@\\n\";\n-  let params = item.node.decl_params in\n-  let params = Array.map (fun i -> i.node) params in\n-    begin\n-      match item.node.decl_item with\n-          MOD_ITEM_type (s, ty) ->\n-            fmt_layer_qual ff s;\n-            fmt ff \"type \";\n-            fmt_ident_and_params ff id params;\n-            fmt ff \" = \";\n-            fmt_ty ff ty;\n-            fmt ff \";\";\n-\n-        | MOD_ITEM_tag (hdr, tid, _) ->\n-            fmt ff \"fn \";\n-            fmt_ident_and_params ff id params;\n-            fmt_header_slots ff hdr;\n-            fmt ff \" -> \";\n-            fmt_ty ff (TY_tag\n-                         { tag_id = tid;\n-                           tag_args =\n-                             Array.map\n-                               (fun (_,p) -> TY_param p)\n-                               params });\n-            fmt ff \";\";\n-\n-        | MOD_ITEM_mod (view,items) ->\n-            fmt_obox ff;\n-            fmt ff \"mod \";\n-            fmt_ident_and_params ff id params;\n-            fmt ff \" \";\n-            fmt_obr ff;\n-            fmt_mod_view ff view;\n-            fmt_mod_items ff items;\n-            fmt_cbb ff\n-\n-        | MOD_ITEM_fn f ->\n-            fmt_fn ff id params f\n-\n-        | MOD_ITEM_obj obj ->\n-            fmt_obj ff id params obj\n-\n-        | MOD_ITEM_const (ty,e) ->\n-            fmt ff \"const \";\n-            fmt_ty ff ty;\n-            begin\n-              match e with\n-                  None -> ()\n-                | Some e ->\n-                    fmt ff \" = \";\n-                    fmt_expr ff e\n-            end;\n-            fmt ff \";\"\n-    end\n-\n-and fmt_import (ff:Format.formatter) (ident:ident) (name:name) : unit =\n-  fmt ff \"@\\n\";\n-  fmt ff \"import \";\n-  fmt ff \"%s = \" ident;\n-  fmt_name ff name;\n-  fmt ff \";\";\n-\n-and fmt_export (ff:Format.formatter) (export:export) _ : unit =\n-  fmt ff \"@\\n\";\n-  match export with\n-      EXPORT_all_decls -> fmt ff \"export *;\"\n-    | EXPORT_ident i -> fmt ff \"export %s;\" i\n-\n-and fmt_mod_view (ff:Format.formatter) (mv:mod_view) : unit =\n-  Hashtbl.iter (fmt_import ff) mv.view_imports;\n-  if not ((Hashtbl.length mv.view_exports = 1) &&\n-            (Hashtbl.mem mv.view_exports EXPORT_all_decls))\n-  then Hashtbl.iter (fmt_export ff) mv.view_exports\n-\n-and fmt_mod_items (ff:Format.formatter) (mi:mod_items) : unit =\n-  Hashtbl.iter (fmt_mod_item ff) mi\n-\n-and fmt_crate (ff:Format.formatter) (c:crate) : unit =\n-  let (view,items) = c.node.crate_items in\n-    fmt_mod_view ff view;\n-    fmt_mod_items ff items\n-;;\n-\n-let sprintf_binop = sprintf_fmt fmt_binop;;\n-let sprintf_expr = sprintf_fmt fmt_expr;;\n-let sprintf_name = sprintf_fmt fmt_name;;\n-let sprintf_name_component = sprintf_fmt fmt_name_component;;\n-let sprintf_lval = sprintf_fmt fmt_lval;;\n-let sprintf_plval = sprintf_fmt fmt_plval;;\n-let sprintf_pexp = sprintf_fmt fmt_pexp;;\n-let sprintf_atom = sprintf_fmt fmt_atom;;\n-let sprintf_slot = sprintf_fmt fmt_slot;;\n-let sprintf_slot_key = sprintf_fmt fmt_slot_key;;\n-let sprintf_ty = sprintf_fmt fmt_ty;;\n-let sprintf_carg = sprintf_fmt fmt_carg;;\n-let sprintf_constr = sprintf_fmt fmt_constr;;\n-let sprintf_mod_item =\n-  sprintf_fmt (fun ff (id,item) -> fmt_mod_item ff id item);;\n-let sprintf_mod_items = sprintf_fmt fmt_mod_items;;\n-let sprintf_decl_param = sprintf_fmt fmt_decl_param;;\n-let sprintf_decl_params = sprintf_fmt fmt_decl_params;;\n-let sprintf_app_args = sprintf_fmt fmt_app_args;;\n-\n-(* You probably want this one; stmt has a leading \\n *)\n-let sprintf_stmt = sprintf_fmt fmt_stmt_body;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "fba2e7985cbb19dec7d97d5a4f0edd250c3b0c2f", "filename": "src/boot/fe/cexp.ml", "status": "removed", "additions": 0, "deletions": 771, "changes": 771, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fcexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fcexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fcexp.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,771 +0,0 @@\n-\n-open Common;;\n-open Token;;\n-open Parser;;\n-\n-(* NB: cexps (crate-expressions / constant-expressions) are only used\n- * transiently during compilation: they are the outermost expression-language\n- * describing crate configuration and constants. They are completely evaluated\n- * at compile-time, in a little micro-interpreter defined here, with the\n- * results of evaluation being the sequence of directives controlling the rest\n- * of the compiler.\n- * \n- * Cexps, like pexps, do not escape the language front-end.\n- * \n- * You can think of the AST as a statement-language called \"item\" sandwiched\n- * between two expression-languages, \"cexp\" on the outside and \"pexp\" on the\n- * inside. The front-end evaluates cexp on the outside in order to get one big\n- * directive-list, evaluating those parts of pexp that are directly used by\n- * cexp in passing, and desugaring those remaining parts of pexp that are\n- * embedded within the items of the directives.\n- * \n- * The rest of the compiler only deals with the directives, which are mostly\n- * just a set of containers for items. Items are what most of AST describes\n- * (\"most\" because the type-grammar spans both items and pexps).\n- * \n- *)\n-\n-type meta = (Ast.ident * Ast.pexp) array;;\n-\n-type meta_pat = (Ast.ident * (Ast.pexp option)) array;;\n-\n-type auth = (Ast.name * Ast.auth);;\n-\n-type cexp =\n-    CEXP_alt of cexp_alt identified\n-  | CEXP_let of cexp_let identified\n-  | CEXP_src_mod of cexp_src identified\n-  | CEXP_dir_mod of cexp_dir identified\n-  | CEXP_use_mod of cexp_use identified\n-  | CEXP_nat_mod of cexp_nat identified\n-  | CEXP_meta of meta identified\n-  | CEXP_auth of auth identified\n-\n-and cexp_alt =\n-    { alt_val: Ast.pexp;\n-      alt_arms: (Ast.pexp * cexp array) array;\n-      alt_else: cexp array }\n-\n-and cexp_let =\n-    { let_ident: Ast.ident;\n-      let_value: Ast.pexp;\n-      let_body: cexp array; }\n-\n-and cexp_src =\n-    { src_ident: Ast.ident;\n-      src_path: Ast.pexp option }\n-\n-and cexp_dir =\n-    { dir_ident: Ast.ident;\n-      dir_path: Ast.pexp option;\n-      dir_body: cexp array }\n-\n-and cexp_use =\n-    { use_ident: Ast.ident;\n-      use_meta: meta_pat; }\n-\n-and cexp_nat =\n-    { nat_abi: string;\n-      nat_ident: Ast.ident;\n-      nat_path: Ast.pexp option;\n-      (* \n-       * FIXME: possibly support embedding optional strings as\n-       * symbol-names, to handle mangling schemes that aren't\n-       * Token.IDENT values\n-       *)\n-      nat_items: Ast.mod_items;\n-    }\n-;;\n-\n-\n-(* Cexp grammar. *)\n-\n-let parse_meta_input (ps:pstate) : (Ast.ident * Ast.pexp option) =\n-  let lab = (ctxt \"meta input: label\" Pexp.parse_ident ps) in\n-    match peek ps with\n-        EQ ->\n-          bump ps;\n-          let v =\n-            match peek ps with\n-                UNDERSCORE -> bump ps; None\n-              | _ -> Some (Pexp.parse_pexp ps)\n-          in\n-            (lab, v)\n-      | _ -> raise (unexpected ps)\n-;;\n-\n-let parse_meta_pat (ps:pstate) : meta_pat =\n-  bracketed_zero_or_more LPAREN RPAREN\n-    (Some COMMA) parse_meta_input ps\n-;;\n-\n-let parse_meta (ps:pstate) : meta =\n-  Array.map\n-    begin\n-      fun (id,v) ->\n-        match v with\n-            None ->\n-              raise (err (\"wildcard found in meta pattern \"\n-                          ^ \"where value expected\") ps)\n-          | Some v -> (id,v)\n-    end\n-    (parse_meta_pat ps)\n-;;\n-\n-let parse_optional_meta_pat\n-    (ps:pstate)\n-    (ident:Ast.ident)\n-    : meta_pat =\n-  match peek ps with\n-      LPAREN -> parse_meta_pat ps\n-    | _ ->\n-        let apos = lexpos ps in\n-          [| (\"name\", Some (span ps apos apos (Ast.PEXP_str ident))) |]\n-;;\n-\n-let rec parse_cexps (ps:pstate) (term:Token.token) : cexp array =\n-  let cexps = Queue.create () in\n-    while ((peek ps) <> term)\n-    do\n-      Queue.push (parse_cexp ps) cexps\n-    done;\n-    expect ps term;\n-    queue_to_arr cexps\n-\n-and parse_cexp (ps:pstate) : cexp =\n-\n-  let apos = lexpos ps in\n-    match peek ps with\n-        MOD ->\n-          begin\n-            bump ps;\n-            let name = ctxt \"mod: name\" Pexp.parse_ident ps in\n-            let path = ctxt \"mod: path\" parse_eq_pexp_opt ps\n-            in\n-              match peek ps with\n-                  SEMI ->\n-                    bump ps;\n-                    let bpos = lexpos ps in\n-                      CEXP_src_mod\n-                        (span ps apos bpos { src_ident = name;\n-                                             src_path = path })\n-                | LBRACE ->\n-                    let body =\n-                      bracketed_zero_or_more LBRACE RBRACE\n-                        None parse_cexp ps\n-                    in\n-                    let bpos = lexpos ps in\n-                      CEXP_dir_mod\n-                        (span ps apos bpos { dir_ident = name;\n-                                             dir_path = path;\n-                                             dir_body = body })\n-                | _ -> raise (unexpected ps)\n-        end\n-\n-      | NATIVE ->\n-          begin\n-            bump ps;\n-            let abi =\n-                match peek ps with\n-                    MOD -> \"cdecl\"\n-                  | LIT_STR s -> bump ps; s\n-                  | _ -> raise (unexpected ps)\n-            in\n-            let _ = expect ps MOD in\n-            let name = ctxt \"native mod: name\" Pexp.parse_ident ps in\n-            let path = ctxt \"native mod: path\" parse_eq_pexp_opt ps in\n-            let items = Hashtbl.create 0 in\n-            let get_item ps =\n-              Array.map\n-                begin\n-                  fun (ident, item) ->\n-                    htab_put items ident item\n-                end\n-                (Item.parse_native_mod_item_from_signature ps)\n-            in\n-              ignore (bracketed_zero_or_more\n-                        LBRACE RBRACE None get_item ps);\n-              let bpos = lexpos ps in\n-                CEXP_nat_mod\n-                  (span ps apos bpos { nat_abi = abi;\n-                                       nat_ident = name;\n-                                       nat_path = path;\n-                                       nat_items = items })\n-          end\n-\n-      | USE ->\n-          begin\n-            bump ps;\n-            let ident = ctxt \"use mod: name\" Pexp.parse_ident ps in\n-            let meta =\n-              ctxt \"use mod: meta\" parse_optional_meta_pat ps ident\n-            in\n-            let bpos = lexpos ps in\n-              expect ps SEMI;\n-              CEXP_use_mod\n-                (span ps apos bpos { use_ident = ident;\n-                                     use_meta = meta })\n-          end\n-\n-      | LET ->\n-          begin\n-            bump ps;\n-            expect ps LPAREN;\n-            let id = Pexp.parse_ident ps in\n-              expect ps EQ;\n-              let v = Pexp.parse_pexp ps in\n-                expect ps RPAREN;\n-                expect ps LBRACE;\n-                let body = parse_cexps ps RBRACE in\n-                let bpos = lexpos ps in\n-                  CEXP_let\n-                    (span ps apos bpos\n-                       { let_ident = id;\n-                         let_value = v;\n-                         let_body = body })\n-          end\n-\n-      | ALT ->\n-          begin\n-            bump ps;\n-            expect ps LPAREN;\n-            let v = Pexp.parse_pexp ps in\n-              expect ps RPAREN;\n-              expect ps LBRACE;\n-              let rec consume_arms arms =\n-                match peek ps with\n-                    CASE ->\n-                      begin\n-                        bump ps;\n-                        expect ps LPAREN;\n-                        let cond = Pexp.parse_pexp ps in\n-                          expect ps RPAREN;\n-                          expect ps LBRACE;\n-                          let consequent = parse_cexps ps RBRACE in\n-                            let arm = (cond, consequent) in\n-                            consume_arms (arm::arms)\n-                      end\n-                  | ELSE ->\n-                      begin\n-                        bump ps;\n-                        expect ps LBRACE;\n-                        let consequent = parse_cexps ps RBRACE in\n-                          expect ps RBRACE;\n-                          let bpos = lexpos ps in\n-                            span ps apos bpos\n-                              { alt_val = v;\n-                                alt_arms = Array.of_list (List.rev arms);\n-                                alt_else = consequent }\n-                      end\n-\n-                  | _ -> raise (unexpected ps)\n-              in\n-                CEXP_alt (consume_arms [])\n-          end\n-\n-      | META ->\n-          bump ps;\n-          let meta = parse_meta ps in\n-            expect ps SEMI;\n-            let bpos = lexpos ps in\n-              CEXP_meta (span ps apos bpos meta)\n-\n-      | AUTH ->\n-          bump ps;\n-          let name = Pexp.parse_name ps in\n-            expect ps EQ;\n-            let au = Pexp.parse_auth ps in\n-              expect ps SEMI;\n-              let bpos = lexpos ps in\n-                CEXP_auth (span ps apos bpos (name, au))\n-\n-      | _ -> raise (unexpected ps)\n-\n-\n-and  parse_eq_pexp_opt (ps:pstate) : Ast.pexp option =\n-  match peek ps with\n-      EQ ->\n-        begin\n-          bump ps;\n-          Some (Pexp.parse_pexp ps)\n-        end\n-    | _ -> None\n-;;\n-\n-\n-(*\n- * Dynamic-typed micro-interpreter for the cexp language.\n- * \n- * The product of evaluating a pexp is a pval.\n- * \n- * The product of evlauating a cexp is a cdir array.\n- *)\n-\n-type pval =\n-    PVAL_str of string\n-  | PVAL_int of int64\n-  | PVAL_bool of bool\n-;;\n-\n-type cdir =\n-    CDIR_meta of ((Ast.ident * string) array)\n-  | CDIR_syntax of Ast.name\n-  | CDIR_mod of (Ast.ident * Ast.mod_item)\n-  | CDIR_auth of auth\n-\n-type env = { env_bindings: ((Ast.ident * pval) list) ref;\n-             env_prefix: filename list;\n-             env_items: (filename, Ast.mod_items) Hashtbl.t;\n-             env_files: (node_id,filename) Hashtbl.t;\n-             env_required: (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n-             env_required_syms: (node_id, string) Hashtbl.t;\n-             env_ps: pstate; }\n-\n-let unexpected_val (expected:string) (v:pval)  =\n-  let got =\n-    match v with\n-        PVAL_str s -> \"str \\\"\" ^ (String.escaped s) ^ \"\\\"\"\n-      | PVAL_int i -> \"int \" ^ (Int64.to_string i)\n-      | PVAL_bool b -> if b then \"bool true\" else \"bool false\"\n-  in\n-    (* FIXME (issue #70): proper error reporting, please. *)\n-    bug () \"expected %s, got %s\" expected got\n-;;\n-\n-let rewrap_items id items =\n-  let item = decl [||] (Ast.MOD_ITEM_mod items) in\n-    { id = id; node = item }\n-;;\n-\n-\n-let rec eval_cexps (env:env) (exps:cexp array) : cdir array =\n-  Parser.arj (Array.map (eval_cexp env) exps)\n-\n-and eval_cexp (env:env) (exp:cexp) : cdir array =\n-  match exp with\n-      CEXP_alt { node = ca; id = _ } ->\n-        let v = eval_pexp env ca.alt_val in\n-        let rec try_arm i =\n-          if i >= Array.length ca.alt_arms\n-          then ca.alt_else\n-          else\n-            let (arm_head, arm_body) = ca.alt_arms.(i) in\n-            let v' = eval_pexp env arm_head in\n-              if v' = v\n-              then arm_body\n-              else try_arm (i+1)\n-        in\n-          eval_cexps env (try_arm 0)\n-\n-    | CEXP_let { node = cl; id = _ } ->\n-        let ident = cl.let_ident in\n-        let v = eval_pexp env cl.let_value in\n-        let old_bindings = !(env.env_bindings) in\n-          env.env_bindings := (ident,v)::old_bindings;\n-          let res = eval_cexps env cl.let_body in\n-            env.env_bindings := old_bindings;\n-            res\n-\n-    | CEXP_src_mod {node=s; id=id} ->\n-        let name = s.src_ident in\n-        let path =\n-          match s.src_path with\n-              None -> name ^ \".rs\"\n-            | Some p -> eval_pexp_to_str env p\n-        in\n-        let full_path =\n-          List.fold_left Filename.concat \"\"\n-            (List.rev (path :: env.env_prefix))\n-        in\n-        let ps = env.env_ps in\n-        let p =\n-          make_parser\n-            ps.pstate_crate_cache\n-            ps.pstate_sess\n-            ps.pstate_get_mod\n-            ps.pstate_get_cenv_tok\n-            ps.pstate_infer_lib_name\n-            env.env_required\n-            env.env_required_syms\n-            full_path\n-        in\n-        let items = Item.parse_mod_items p EOF in\n-          htab_put env.env_files id full_path;\n-          [| CDIR_mod (name, rewrap_items id items) |]\n-\n-    | CEXP_dir_mod {node=d; id=id} ->\n-        let items = Hashtbl.create 0 in\n-        let name = d.dir_ident in\n-        let path =\n-          match d.dir_path with\n-              None -> name\n-            | Some p -> eval_pexp_to_str env p\n-        in\n-        let env = { env with\n-                      env_prefix = path :: env.env_prefix } in\n-        let sub_directives = eval_cexps env d.dir_body in\n-        let add d =\n-          match d with\n-              CDIR_mod (name, item) ->\n-                htab_put items name item\n-            | _ -> raise (err \"non-'mod' directive found in 'dir' directive\"\n-                            env.env_ps)\n-        in\n-          Array.iter add sub_directives;\n-          [| CDIR_mod (name, rewrap_items id (Item.empty_view, items)) |]\n-\n-    | CEXP_use_mod {node=u; id=id} ->\n-        let ps = env.env_ps in\n-        let name = u.use_ident in\n-        let (path, items) =\n-          let meta_pat =\n-            Array.map\n-              begin\n-                fun (k,vo) ->\n-                  match vo with\n-                      None -> (k, None)\n-                    | Some p -> (k, Some (eval_pexp_to_str env p))\n-              end\n-              u.use_meta\n-          in\n-            ps.pstate_get_mod meta_pat id ps.pstate_crate_cache\n-        in\n-          iflog ps\n-            begin\n-              fun _ ->\n-                log ps \"extracted mod signature from %s (binding to %s)\"\n-                  path name;\n-                log ps \"%a\" Ast.sprintf_mod_items items;\n-            end;\n-          let rlib = REQUIRED_LIB_rust { required_libname = path;\n-                                         required_prefix = 1 }\n-          in\n-          let item = decl [||] (Ast.MOD_ITEM_mod (Item.empty_view, items)) in\n-          let item = { id = id; node = item } in\n-          let span = Hashtbl.find ps.pstate_sess.Session.sess_spans id in\n-            Item.note_required_mod env.env_ps span CONV_rust rlib item;\n-            [| CDIR_mod (name, item) |]\n-\n-    | CEXP_nat_mod {node=cn;id=id} ->\n-        let conv =\n-          let v = cn.nat_abi in\n-          match string_to_conv v with\n-              None -> unexpected_val \"calling convention\" (PVAL_str v)\n-            | Some c -> c\n-        in\n-        let name = cn.nat_ident in\n-        let filename =\n-          match cn.nat_path with\n-              None -> env.env_ps.pstate_infer_lib_name name\n-            | Some p -> eval_pexp_to_str env p\n-        in\n-        let item =\n-          decl [||] (Ast.MOD_ITEM_mod (Item.empty_view, cn.nat_items))\n-        in\n-        let item = { id = id; node = item } in\n-        let rlib = REQUIRED_LIB_c { required_libname = filename;\n-                                    required_prefix = 1 }\n-        in\n-        let ps = env.env_ps in\n-        let span = Hashtbl.find ps.pstate_sess.Session.sess_spans id in\n-          Item.note_required_mod env.env_ps span conv rlib item;\n-          [| CDIR_mod (name, item) |]\n-\n-    | CEXP_meta m ->\n-        [| CDIR_meta\n-             begin\n-               Array.map\n-                 begin\n-                   fun (id, p) -> (id, eval_pexp_to_str env p)\n-                 end\n-                 m.node\n-             end |]\n-\n-    | CEXP_auth a -> [| CDIR_auth a.node |]\n-\n-\n-and eval_pexp (env:env) (exp:Ast.pexp) : pval =\n-  match exp.node with\n-    | Ast.PEXP_binop (bop, a, b) ->\n-        begin\n-          let av = eval_pexp env a in\n-          let bv = eval_pexp env b in\n-            match (bop, av, bv) with\n-                (Ast.BINOP_add, PVAL_str az, PVAL_str bz) ->\n-                  PVAL_str (az ^ bz)\n-              | _ ->\n-                  let av = (need_int av) in\n-                  let bv = (need_int bv) in\n-                    PVAL_int\n-                      begin\n-                        match bop with\n-                            Ast.BINOP_add -> Int64.add av bv\n-                          | Ast.BINOP_sub -> Int64.sub av bv\n-                          | Ast.BINOP_mul -> Int64.mul av bv\n-                          | Ast.BINOP_div -> Int64.div av bv\n-                          | _ ->\n-                              bug ()\n-                                \"unhandled arithmetic op in Cexp.eval_pexp\"\n-                      end\n-        end\n-\n-    | Ast.PEXP_unop (uop, a) ->\n-        begin\n-          match uop with\n-              Ast.UNOP_not ->\n-                PVAL_bool (not (eval_pexp_to_bool env a))\n-            | Ast.UNOP_neg ->\n-                PVAL_int (Int64.neg (eval_pexp_to_int env a))\n-            | _ -> bug () \"Unexpected unop in Cexp.eval_pexp\"\n-        end\n-\n-    | Ast.PEXP_lval (Ast.PLVAL_base (Ast.BASE_ident ident)) ->\n-        begin\n-          match ltab_search !(env.env_bindings) ident with\n-              None -> raise (err (Printf.sprintf \"no binding for '%s' found\"\n-                                    ident) env.env_ps)\n-            | Some v -> v\n-        end\n-\n-    | Ast.PEXP_lit (Ast.LIT_bool b) ->\n-        PVAL_bool b\n-\n-    | Ast.PEXP_lit (Ast.LIT_int i) ->\n-        PVAL_int i\n-\n-    | Ast.PEXP_str s ->\n-        PVAL_str s\n-\n-    | _ -> bug () \"unexpected Pexp in Cexp.eval_pexp\"\n-\n-\n-and eval_pexp_to_str (env:env) (exp:Ast.pexp) : string =\n-  match eval_pexp env exp with\n-      PVAL_str s -> s\n-    | v -> unexpected_val \"str\" v\n-\n-and need_int (cv:pval) : int64 =\n-  match cv with\n-      PVAL_int n -> n\n-    | v -> unexpected_val \"int\" v\n-\n-and eval_pexp_to_int (env:env) (exp:Ast.pexp) : int64 =\n-  need_int (eval_pexp env exp)\n-\n-and eval_pexp_to_bool (env:env) (exp:Ast.pexp) : bool =\n-  match eval_pexp env exp with\n-      PVAL_bool b -> b\n-    | v -> unexpected_val \"bool\" v\n-\n-;;\n-\n-\n-let find_main_fn\n-    (ps:pstate)\n-    (crate_items:Ast.mod_items)\n-    : Ast.name =\n-  let fns = ref [] in\n-  let extend prefix_name ident =\n-    match prefix_name with\n-        None -> Ast.NAME_base (Ast.BASE_ident ident)\n-      | Some n -> Ast.NAME_ext (n, Ast.COMP_ident ident)\n-  in\n-  let rec dig prefix_name items =\n-    Hashtbl.iter (extract_fn prefix_name) items\n-  and extract_fn prefix_name ident item =\n-    if not (Array.length item.node.Ast.decl_params = 0) ||\n-      Hashtbl.mem ps.pstate_required item.id\n-    then ()\n-    else\n-      match item.node.Ast.decl_item with\n-          Ast.MOD_ITEM_mod (_, items) ->\n-            dig (Some (extend prefix_name ident)) items\n-\n-       | Ast.MOD_ITEM_fn _ ->\n-            if ident = \"main\"\n-            then fns := (extend prefix_name ident) :: (!fns)\n-            else ()\n-\n-        | _ -> ()\n-  in\n-    dig None crate_items;\n-    match !fns with\n-        [] -> raise (err \"no 'main' function found\" ps)\n-      | [x] -> x\n-      | _ -> raise (err \"multiple 'main' functions found\" ps)\n-;;\n-\n-\n-let with_err_handling sess thunk =\n-  try\n-    thunk ()\n-  with\n-      Parse_err (ps, str) ->\n-        Session.fail sess \"%s: error: %s\\n%!\"\n-          (Session.string_of_pos (lexpos ps)) str;\n-        List.iter\n-          (fun (cx,pos) ->\n-             Session.fail sess \"%s: (parse context): %s\\n%!\"\n-               (Session.string_of_pos pos) cx)\n-          ps.pstate_ctxt;\n-        let apos = lexpos ps in\n-          span ps apos apos Ast.empty_crate'\n-;;\n-\n-\n-let parse_crate_file\n-    (sess:Session.sess)\n-    (get_mod:get_mod_fn)\n-    (infer_lib_name:(Ast.ident -> filename))\n-    (crate_cache:(crate_id, Ast.mod_items) Hashtbl.t)\n-    : Ast.crate =\n-  let fname = Session.filename_of sess.Session.sess_in in\n-  let required = Hashtbl.create 4 in\n-  let required_syms = Hashtbl.create 4 in\n-  let files = Hashtbl.create 0 in\n-  let items = Hashtbl.create 4 in\n-  let target_bindings =\n-    let (os, arch, libc) =\n-      match sess.Session.sess_targ with\n-          Linux_x86_elf -> (\"linux\", \"x86\", \"libc.so.6\")\n-        | FreeBSD_x86_elf -> (\"freebsd\", \"x86\", \"libc.so.7\")\n-        | Win32_x86_pe -> (\"win32\", \"x86\", \"msvcrt.dll\")\n-        | MacOS_x86_macho -> (\"macos\", \"x86\", \"libc.dylib\")\n-    in\n-      [\n-        (\"target_os\", PVAL_str os);\n-        (\"target_arch\", PVAL_str arch);\n-        (\"target_libc\", PVAL_str libc)\n-      ]\n-  in\n-  let build_bindings =\n-    [\n-      (\"build_compiler\", PVAL_str Sys.executable_name);\n-      (\"build_input\", PVAL_str fname);\n-    ]\n-  in\n-  let bindings =\n-    ref (target_bindings\n-         @ build_bindings)\n-  in\n-  let get_cenv_tok ps ident =\n-      match ltab_search (!bindings) ident with\n-          None -> raise (err (Printf.sprintf \"no binding for '%s' found\"\n-                                ident) ps)\n-        | Some (PVAL_bool b) -> LIT_BOOL b\n-        | Some (PVAL_str s) -> LIT_STR s\n-        | Some (PVAL_int n) -> LIT_INT n\n-  in\n-  let ps =\n-    make_parser crate_cache sess get_mod get_cenv_tok\n-      infer_lib_name required required_syms fname\n-  in\n-  let env = { env_bindings = bindings;\n-              env_prefix = [Filename.dirname fname];\n-              env_items = Hashtbl.create 0;\n-              env_files = files;\n-              env_required = required;\n-              env_required_syms = required_syms;\n-              env_ps = ps; }\n-  in\n-  let auth = Hashtbl.create 0 in\n-    with_err_handling sess\n-      begin\n-        fun _ ->\n-          let apos = lexpos ps in\n-          let cexps = parse_cexps ps EOF in\n-          let cdirs = eval_cexps env cexps in\n-          let meta = Queue.create () in\n-          let _ =\n-            Array.iter\n-              begin\n-                fun d ->\n-                  match d with\n-                      CDIR_mod (name, item) ->\n-                        if Hashtbl.mem items name\n-                        then raise\n-                          (err (\"duplicate mod declaration: \" ^ name) ps)\n-                        else Hashtbl.add items name item\n-                    | CDIR_meta metas ->\n-                        Array.iter (fun m -> Queue.add m meta) metas\n-                    | CDIR_auth (n,e) ->\n-                        if Hashtbl.mem auth n\n-                        then raise (err \"duplicate 'auth' clause\" ps)\n-                        else Hashtbl.add auth n e\n-                    | _ ->\n-                        raise\n-                          (err \"unhandled directive at top level\" ps)\n-              end\n-              cdirs\n-          in\n-          let bpos = lexpos ps in\n-          let main =\n-            if ps.pstate_sess.Session.sess_library_mode\n-            then None\n-            else Some (find_main_fn ps items) in\n-          let crate = { Ast.crate_items = (Item.empty_view, items);\n-                        Ast.crate_meta = queue_to_arr meta;\n-                        Ast.crate_auth = auth;\n-                        Ast.crate_required = required;\n-                        Ast.crate_required_syms = required_syms;\n-                        Ast.crate_main = main;\n-                        Ast.crate_files = files }\n-          in\n-          let cratei = span ps apos bpos crate in\n-            htab_put files cratei.id fname;\n-            cratei\n-      end\n-;;\n-\n-let parse_src_file\n-    (sess:Session.sess)\n-    (get_mod:get_mod_fn)\n-    (infer_lib_name:(Ast.ident -> filename))\n-    (crate_cache:(crate_id, Ast.mod_items) Hashtbl.t)\n-    : Ast.crate =\n-  let fname = Session.filename_of sess.Session.sess_in in\n-  let required = Hashtbl.create 0 in\n-  let required_syms = Hashtbl.create 0 in\n-  let get_cenv_tok ps ident =\n-    raise (err (Printf.sprintf \"no binding for '%s' found\"\n-                  ident) ps)\n-  in\n-  let ps =\n-    make_parser crate_cache sess get_mod get_cenv_tok\n-      infer_lib_name required required_syms fname\n-  in\n-    with_err_handling sess\n-      begin\n-        fun _ ->\n-          let apos = lexpos ps in\n-          let items = Item.parse_mod_items ps EOF in\n-          let bpos = lexpos ps in\n-          let files = Hashtbl.create 0 in\n-          let main =\n-            if ps.pstate_sess.Session.sess_library_mode\n-            then None\n-            else Some (find_main_fn ps (snd items))\n-          in\n-          let crate = { Ast.crate_items = items;\n-                        Ast.crate_required = required;\n-                        Ast.crate_required_syms = required_syms;\n-                        Ast.crate_auth = Hashtbl.create 0;\n-                        Ast.crate_meta = [||];\n-                        Ast.crate_main = main;\n-                        Ast.crate_files = files }\n-          in\n-          let cratei = span ps apos bpos crate in\n-            htab_put files cratei.id fname;\n-            cratei\n-      end\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "6b0bd7882ea59ed66a53b4d783af31b7d196ff13", "filename": "src/boot/fe/extfmt.ml", "status": "removed", "additions": 0, "deletions": 229, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fextfmt.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fextfmt.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fextfmt.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,229 +0,0 @@\n-(* The 'fmt' extension is modeled on the posix printf system.\n- * \n- * A posix conversion ostensibly looks like this:\n- * \n- * %[parameter][flags][width][.precision][length]type\n- * \n- * Given the different numeric type bestiary we have, we omit the 'length'\n- * parameter and support slightly different conversions for 'type':\n- * \n- * %[parameter][flags][width][.precision]type\n- * \n- * we also only support translating-to-rust a tiny subset of the possible\n- * combinations at the moment.\n- *)\n-\n-exception Malformed of string\n-;;\n-\n-type case =\n-    CASE_upper\n-  | CASE_lower\n-;;\n-\n-type signedness =\n-    SIGNED\n-  | UNSIGNED\n-;;\n-\n-type ty =\n-    TY_bool\n-  | TY_str\n-  | TY_char\n-  | TY_int of signedness\n-  | TY_bits\n-  | TY_hex of case\n-      (* FIXME: Support more later. *)\n-;;\n-\n-type flag =\n-    FLAG_left_justify\n-  | FLAG_left_zero_pad\n-  | FLAG_left_space_pad\n-  | FLAG_plus_if_positive\n-  | FLAG_alternate\n-;;\n-\n-type count =\n-    COUNT_is of int\n-  | COUNT_is_param of int\n-  | COUNT_is_next_param\n-  | COUNT_implied\n-\n-type conv =\n-    { conv_parameter: int option;\n-      conv_flags: flag list;\n-      conv_width: count;\n-      conv_precision: count;\n-      conv_ty: ty }\n-\n-type piece =\n-    PIECE_string of string\n-  | PIECE_conversion of conv\n-\n-\n-let rec peek_num (s:string) (i:int) (lim:int)\n-    : (int * int) option =\n-  if i >= lim\n-  then None\n-  else\n-    let c = s.[i] in\n-      if '0' <= c && c <= '9'\n-      then\n-        let n = (Char.code c) - (Char.code '0') in\n-          match peek_num s (i+1) lim with\n-              None -> Some (n, i+1)\n-            | Some (m, i) -> Some (n * 10 + m, i)\n-      else None\n-;;\n-\n-let parse_parameter (s:string) (i:int) (lim:int)\n-    : (int option * int) =\n-  if i >= lim\n-  then (None, i)\n-  else\n-    match peek_num s i lim with\n-        None -> (None, i)\n-      | Some (n, j) ->\n-          if j < (String.length s) && s.[j] = '$'\n-          then (Some n, j+1)\n-          else (None, i)\n-;;\n-\n-let rec parse_flags (s:string) (i:int) (lim:int)\n-    : (flag list * int) =\n-  if i >= lim\n-  then ([], i)\n-  else\n-    let cont flag =\n-      let (rest, j) = parse_flags s (i+1) lim in\n-        (flag :: rest, j)\n-    in\n-      match s.[i] with\n-          '-' -> cont FLAG_left_justify\n-        | '0' -> cont FLAG_left_zero_pad\n-        | ' ' -> cont FLAG_left_space_pad\n-        | '+' -> cont FLAG_plus_if_positive\n-        | '#' -> cont FLAG_alternate\n-        | _ -> ([], i)\n-;;\n-\n-let parse_count (s:string) (i:int) (lim:int)\n-    : (count * int) =\n-  if i >= lim\n-  then (COUNT_implied, i)\n-  else\n-    if s.[i] = '*'\n-    then\n-      begin\n-        match parse_parameter s (i+1) lim with\n-            (None, j) -> (COUNT_is_next_param, j)\n-          | (Some n, j) -> (COUNT_is_param n, j)\n-      end\n-    else\n-      begin\n-        match peek_num s i lim with\n-            None -> (COUNT_implied, i)\n-          | Some (n, j) -> (COUNT_is n, j)\n-      end\n-;;\n-\n-let parse_precision (s:string) (i:int) (lim:int)\n-    : (count * int) =\n-  if i >= lim\n-  then (COUNT_implied, i)\n-  else\n-    if s.[i] = '.'\n-    then parse_count s (i+1) lim\n-    else (COUNT_implied, i)\n-;;\n-\n-let parse_type (s:string) (i:int) (lim:int)\n-    : (ty * int) =\n-  if i >= lim\n-  then raise (Malformed \"missing type in conversion\")\n-  else\n-    let t =\n-      match s.[i] with\n-          'b' -> TY_bool\n-        | 's' -> TY_str\n-        | 'c' -> TY_char\n-        | 'd' | 'i' -> TY_int SIGNED\n-        | 'u' -> TY_int UNSIGNED\n-        | 'x' -> TY_hex CASE_lower\n-        | 'X' -> TY_hex CASE_upper\n-        | 't' -> TY_bits\n-        | _ -> raise (Malformed \"unknown type in conversion\")\n-    in\n-      (t, i+1)\n-;;\n-\n-let parse_conversion (s:string) (i:int) (lim:int)\n-    : (piece * int) =\n-  let (parameter, i) = parse_parameter s i lim in\n-  let (flags, i) = parse_flags s i lim in\n-  let (width, i) = parse_count s i lim in\n-  let (precision, i) = parse_precision s i lim in\n-  let (ty, i) = parse_type s i lim in\n-    (PIECE_conversion  { conv_parameter = parameter;\n-                         conv_flags = flags;\n-                         conv_width = width;\n-                         conv_precision = precision;\n-                         conv_ty = ty }, i)\n-;;\n-\n-let parse_fmt_string (s:string) : piece array =\n-  let pieces = Queue.create () in\n-  let i = ref 0 in\n-  let lim = String.length s in\n-  let buf = Buffer.create 10 in\n-  let flush_buf _ =\n-    if (Buffer.length buf) <> 0\n-    then\n-      let piece =\n-        PIECE_string (Buffer.contents buf)\n-      in\n-        Queue.add piece pieces;\n-        Buffer.clear buf;\n-  in\n-    while (!i) < lim\n-    do\n-      if s.[!i] = '%'\n-      then\n-        begin\n-          incr i;\n-          if (!i) >= lim\n-          then raise (Malformed \"unterminated conversion at end of string\");\n-          if s.[!i] = '%'\n-          then\n-            begin\n-              Buffer.add_char buf '%';\n-              incr i;\n-            end\n-          else\n-            begin\n-              flush_buf();\n-              let (piece, j) = parse_conversion s (!i) lim in\n-                Queue.add piece pieces;\n-                i := j\n-            end\n-        end\n-      else\n-        begin\n-          Buffer.add_char buf s.[!i];\n-          incr i;\n-        end\n-    done;\n-    flush_buf ();\n-    Common.queue_to_arr pieces\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "d93c36577b1d5259d636ca4d4d23fd6f234bbd69", "filename": "src/boot/fe/fuzz.ml", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Ffuzz.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Ffuzz.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ffuzz.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,166 +0,0 @@\n-open Common;;\n-open Ast;;\n-\n-let ident_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\";;\n-let digit_chars = \"1234567890\";;\n-\n-type scope =\n-    SCOPE_crate of crate\n-  | SCOPE_mod_item of (ident * mod_item)\n-  | SCOPE_block of block\n-  | SCOPE_anon\n-;;\n-\n-type ctxt =\n-    {\n-      ctxt_scopes: scope Stack.t;\n-      ctxt_node_counter: int ref;\n-      ctxt_sess: Session.sess;\n-    }\n-\n-let generate_ident _ : ident =\n-  let char n =\n-    if n = 0\n-    then '_'\n-    else ident_chars.[Random.int (String.length ident_chars)]\n-  in\n-  let i = 3 + (Random.int 10) in\n-  let s = String.create i in\n-    for j = 0 to (i-1)\n-    do\n-      s.[j] <- char j\n-    done;\n-    s\n-;;\n-\n-let wrap (n:'a) (cx:ctxt) : 'a identified =\n-  incr cx.ctxt_node_counter;\n-  { node = n; id = Node (!(cx.ctxt_node_counter)) }\n-;;\n-\n-let generate_in (scope:scope) (fn:(ctxt -> 'a)) (cx:ctxt) : 'a =\n-  Stack.push scope cx.ctxt_scopes;\n-  let x = fn cx in\n-    ignore (Stack.pop cx.ctxt_scopes);\n-    x\n-;;\n-\n-let generate_some (fn:(ctxt -> 'a)) (cx:ctxt) : 'a array =\n-  let root_count = cx.ctxt_sess.Session.sess_fuzz_item_count in\n-  let depth = Stack.length cx.ctxt_scopes in\n-  if depth >= root_count\n-  then [| |]\n-  else\n-    Array.init (1 + (Random.int (root_count - depth)))\n-      (fun _ -> fn cx)\n-;;\n-\n-let rec generate_ty (cx:ctxt) : ty =\n-  let subty _ =\n-    generate_in SCOPE_anon\n-      generate_ty cx\n-  in\n-    match Random.int (if Random.bool() then 10 else 17) with\n-      0 -> TY_nil\n-    | 1 -> TY_bool\n-\n-    | 2 -> TY_mach TY_u8\n-    | 3 -> TY_mach TY_u32\n-\n-    | 4 -> TY_mach TY_i8\n-    | 5 -> TY_mach TY_i32\n-\n-    | 6 -> TY_int\n-    | 7 -> TY_uint\n-    | 8 -> TY_char\n-    | 9 -> TY_str\n-\n-    | 10 -> TY_tup (generate_in SCOPE_anon\n-                      (generate_some\n-                         generate_ty) cx)\n-    | 11 -> TY_vec (subty())\n-    | 12 ->\n-        let generate_elt cx =\n-          (generate_ident cx, generate_ty cx)\n-        in\n-          TY_rec (generate_in SCOPE_anon\n-                    (generate_some generate_elt) cx)\n-\n-    | 13 -> TY_chan (subty())\n-    | 14 -> TY_port (subty())\n-\n-    | 15 -> TY_task\n-\n-    | _ -> TY_box (subty())\n-;;\n-\n-\n-let rec generate_mod_item (mis:mod_items) (cx:ctxt) : unit =\n-  let ident = generate_ident () in\n-  let decl i = wrap { decl_item = i;\n-                      decl_params = [| |] } cx\n-  in\n-  let item =\n-    match Random.int 2 with\n-        0 ->\n-          let ty = generate_ty cx in\n-          let st = Ast.LAYER_value in\n-            decl (MOD_ITEM_type (st, ty))\n-      | _ ->\n-          let mis' = Hashtbl.create 0 in\n-          let view = { view_imports = Hashtbl.create 0;\n-                       view_exports = Hashtbl.create 0; }\n-          in\n-          let item =\n-            decl (MOD_ITEM_mod (view, mis'))\n-          in\n-          let scope =\n-            SCOPE_mod_item (ident, item)\n-          in\n-            ignore\n-              (generate_in scope\n-                 (generate_some (generate_mod_item mis'))\n-                 cx);\n-            item\n-  in\n-    Hashtbl.add mis ident item\n-;;\n-\n-let fuzz (seed:int option) (sess:Session.sess) : unit =\n-  begin\n-    match seed with\n-        None -> Random.self_init ()\n-      | Some s -> Random.init s\n-  end;\n-  let filename =\n-    match sess.Session.sess_out with\n-        Some o -> o\n-      | None ->\n-          match seed with\n-              None -> \"fuzz.rs\"\n-            | Some seed -> \"fuzz-\" ^ (string_of_int seed) ^ \".rs\"\n-  in\n-  let out = open_out_bin filename in\n-  let ff = Format.formatter_of_out_channel out in\n-  let cx = { ctxt_scopes = Stack.create ();\n-             ctxt_node_counter = ref 0;\n-             ctxt_sess = sess }\n-  in\n-  let mis = Hashtbl.create 0 in\n-    ignore (generate_some\n-              (generate_mod_item mis) cx);\n-    fmt_mod_items ff mis;\n-    Format.pp_print_flush ff ();\n-    close_out out;\n-    exit 0\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "70e59be303912021ae58760a8eb71aee564a9ce1", "filename": "src/boot/fe/item.ml", "status": "removed", "additions": 0, "deletions": 1334, "changes": 1334, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,1334 +0,0 @@\n-\n-open Common;;\n-open Token;;\n-open Parser;;\n-\n-(* Item grammar. *)\n-\n-let default_exports =\n-  let e = Hashtbl.create 0 in\n-    Hashtbl.add e Ast.EXPORT_all_decls ();\n-    e\n-;;\n-\n-let empty_view = { Ast.view_imports = Hashtbl.create 0;\n-                   Ast.view_exports = default_exports }\n-;;\n-\n-let rec parse_expr (ps:pstate) : (Ast.stmt array * Ast.expr) =\n-  let pexp = ctxt \"expr\" Pexp.parse_pexp ps in\n-    if ps.pstate_sess.Session.sess_use_pexps\n-    then ([||], Ast.EXPR_atom (Ast.ATOM_pexp pexp))\n-    else Pexp.desugar_expr ps pexp\n-\n-and parse_prim_expr (ps:pstate) : Ast.expr =\n-  let pexp = ctxt \"expr\" Pexp.parse_pexp ps in\n-  let (stmts, expr) = Pexp.desugar_expr ps pexp in\n-    if Array.length stmts = 0\n-    then expr\n-    else raise (Parse_err (ps, \"expected primitive expression\"))\n-\n-and parse_expr_atom (ps:pstate) : (Ast.stmt array * Ast.atom) =\n-  let pexp = ctxt \"expr\" Pexp.parse_pexp ps in\n-    if ps.pstate_sess.Session.sess_use_pexps\n-    then ([||], Ast.ATOM_pexp pexp)\n-    else Pexp.desugar_expr_atom ps pexp\n-\n-and parse_expr_atom_list\n-    (bra:token)\n-    (ket:token)\n-    (ps:pstate)\n-    : (Ast.stmt array * Ast.atom array) =\n-  arj1st (bracketed_zero_or_more bra ket (Some COMMA)\n-            (ctxt \"expr-atom list\" parse_expr_atom) ps)\n-\n-and parse_expr_init (lv:Ast.lval) (ps:pstate) : (Ast.stmt array) =\n-  let apos = lexpos ps in\n-  let pexp = ctxt \"expr\" Pexp.parse_pexp ps in\n-  let bpos = lexpos ps in\n-    if ps.pstate_sess.Session.sess_use_pexps\n-    then [|\n-      span ps apos bpos\n-        (Ast.STMT_copy (lv, Ast.EXPR_atom (Ast.ATOM_pexp pexp)))\n-    |]\n-    else Pexp.desugar_expr_init ps lv pexp\n-\n-and parse_lval (ps:pstate) : (Ast.stmt array * Ast.lval) =\n-  let apos = lexpos ps in\n-  let pexp = ctxt \"lval\" Pexp.parse_pexp ps in\n-  let bpos = lexpos ps in\n-    if ps.pstate_sess.Session.sess_use_pexps\n-    then\n-      let (_, tmp, decl_stmt) = build_tmp ps slot_auto apos bpos in\n-      let copy_stmt =\n-        span ps apos bpos\n-          (Ast.STMT_copy (tmp, Ast.EXPR_atom (Ast.ATOM_pexp pexp)))\n-      in\n-        ([| decl_stmt; copy_stmt |], (clone_lval ps tmp))\n-    else Pexp.desugar_lval ps pexp\n-\n-and parse_identified_slot_and_ident\n-    (aliases_ok:bool)\n-    (ps:pstate)\n-    : (Ast.slot identified * Ast.ident) =\n-  let slot =\n-    ctxt \"identified slot and ident: slot\"\n-      (Pexp.parse_identified_slot aliases_ok) ps\n-  in\n-  let ident =\n-    ctxt \"identified slot and ident: ident\" Pexp.parse_ident ps\n-  in\n-    (slot, ident)\n-\n-and parse_zero_or_more_identified_slot_ident_pairs\n-    (aliases_ok:bool)\n-    (ps:pstate)\n-    : (((Ast.slot identified) * Ast.ident) array) =\n-  ctxt \"zero+ slots and idents\"\n-    (paren_comma_list\n-       (parse_identified_slot_and_ident aliases_ok)) ps\n-\n-and parse_block (ps:pstate) : Ast.block =\n-  let apos = lexpos ps in\n-  let stmts =\n-    arj (ctxt \"block: stmts\"\n-           (bracketed_zero_or_more LBRACE RBRACE\n-              None parse_stmts) ps)\n-  in\n-  let bpos = lexpos ps in\n-    span ps apos bpos stmts\n-\n-and parse_block_stmt (ps:pstate) : Ast.stmt =\n-  let apos = lexpos ps in\n-  let block = parse_block ps in\n-  let bpos = lexpos ps in\n-    span ps apos bpos (Ast.STMT_block block)\n-\n-and parse_init\n-    (lval:Ast.lval)\n-    (ps:pstate)\n-    : Ast.stmt array =\n-  let apos = lexpos ps in\n-  let stmts =\n-    match peek ps with\n-        EQ ->\n-          bump ps;\n-          parse_expr_init lval ps\n-      | LARROW ->\n-          bump ps;\n-          let (stmts, rhs) = ctxt \"init: port\" parse_lval ps in\n-          let bpos = lexpos ps in\n-          let stmt = Ast.STMT_recv (lval, rhs) in\n-            Array.append stmts [| (span ps apos bpos stmt) |]\n-      | _ -> arr []\n-  in\n-  let _ = expect ps SEMI in\n-    stmts\n-\n-and parse_slot_and_ident_and_init\n-    (ps:pstate)\n-    : (Ast.stmt array * Ast.slot * Ast.ident) =\n-  let apos = lexpos ps in\n-  let (slot, ident) =\n-    ctxt \"slot, ident and init: slot and ident\"\n-      (Pexp.parse_slot_and_ident false) ps\n-  in\n-  let bpos = lexpos ps in\n-  let lval = Ast.LVAL_base (span ps apos bpos (Ast.BASE_ident ident)) in\n-  let stmts = ctxt \"slot, ident and init: init\" (parse_init lval) ps in\n-    (stmts, slot, ident)\n-\n-and parse_auto_slot_and_init\n-    (ps:pstate)\n-    : (Ast.stmt array * Ast.slot * Ast.ident) =\n-  let apos = lexpos ps in\n-  let ident = Pexp.parse_ident ps in\n-  let bpos = lexpos ps in\n-  let lval = Ast.LVAL_base (span ps apos bpos (Ast.BASE_ident ident)) in\n-  let stmts = ctxt \"slot, ident and init: init\" (parse_init lval) ps in\n-    (stmts, slot_auto, ident)\n-\n-\n-and parse_stmts (ps:pstate) : Ast.stmt array =\n-  let arr = parse_stmts_including_none ps in\n-    if (Array.length arr) == 0 then\n-      raise (err \"statement does nothing\" ps);\n-    arr\n-\n-(*\n- * We have no way to parse a single Ast.stmt; any incoming syntactic statement\n- * may desugar to N>1 real Ast.stmts\n- *)\n-\n-and parse_stmts_including_none (ps:pstate) : Ast.stmt array =\n-  let apos = lexpos ps in\n-\n-  let ensure_mutable slot =\n-    match slot.Ast.slot_ty with\n-        None -> slot\n-      | Some (Ast.TY_mutable _) -> slot\n-      | Some t -> { slot with Ast.slot_ty = Some (Ast.TY_mutable t) }\n-  in\n-\n-  let rec name_to_lval (apos:pos) (bpos:pos) (name:Ast.name)\n-      : Ast.lval =\n-    match name with\n-        Ast.NAME_base nb ->\n-          Ast.LVAL_base (span ps apos bpos nb)\n-      | Ast.NAME_ext (n, nc) ->\n-          Ast.LVAL_ext (name_to_lval apos bpos n, Ast.COMP_named nc)\n-  in\n-\n-    match peek ps with\n-\n-        LOG ->\n-          bump ps;\n-          let (stmts, atom) = ctxt \"stmts: log value\" parse_expr_atom ps in\n-            expect ps SEMI;\n-            spans ps stmts apos (Ast.STMT_log atom)\n-      | LOG_ERR ->\n-          bump ps;\n-          let (stmts, atom) = ctxt \"stmts: log value\" parse_expr_atom ps in\n-            expect ps SEMI;\n-            spans ps stmts apos (Ast.STMT_log_err atom)\n-      | BREAK ->\n-          bump ps;\n-          expect ps SEMI;\n-          [| span ps apos (lexpos ps) Ast.STMT_break |]\n-      | CONT ->\n-          bump ps;\n-          expect ps SEMI;\n-          [| span ps apos (lexpos ps) Ast.STMT_cont |]\n-      | ASSERT ->\n-          bump ps;\n-          let (stmts, expr) =\n-             ctxt \"stmts: check value\" parse_expr ps\n-          in\n-              expect ps SEMI;\n-              spans ps stmts apos (Ast.STMT_check_expr expr)\n-(* leaving check as it is; adding assert as a synonym for the \"old\" check *)\n-      | CHECK ->\n-          bump ps;\n-          begin\n-\n-            let rec carg_path_to_lval (bpos:pos) (path:Ast.carg_path)\n-                : Ast.lval =\n-              match path with\n-                  Ast.CARG_base Ast.BASE_formal ->\n-                    raise (err \"converting formal constraint-arg to atom\" ps)\n-                | Ast.CARG_base (Ast.BASE_named nb) ->\n-                    Ast.LVAL_base (span ps apos bpos nb)\n-                | Ast.CARG_ext (pth, nc) ->\n-                    Ast.LVAL_ext (carg_path_to_lval bpos pth,\n-                                  Ast.COMP_named nc)\n-            in\n-\n-            let carg_to_atom (bpos:pos) (carg:Ast.carg)\n-                : Ast.atom =\n-              match carg with\n-                  Ast.CARG_lit lit ->\n-                    Ast.ATOM_literal (span ps apos bpos lit)\n-                | Ast.CARG_path pth ->\n-                    Ast.ATOM_lval (carg_path_to_lval bpos pth)\n-            in\n-\n-            let synthesise_check_call (bpos:pos) (constr:Ast.constr)\n-                : (Ast.lval * (Ast.atom array)) =\n-              let lval = name_to_lval apos bpos constr.Ast.constr_name in\n-              let args =\n-                Array.map (carg_to_atom bpos) constr.Ast.constr_args\n-              in\n-                (lval, args)\n-            in\n-\n-            let synthesise_check_calls (bpos:pos) (constrs:Ast.constrs)\n-                : Ast.check_calls =\n-              Array.map (synthesise_check_call bpos) constrs\n-            in\n-\n-              match peek ps with\n-                  LPAREN ->\n-                    bump ps;\n-                    let (stmts, expr) =\n-                      ctxt \"stmts: check value\" parse_expr ps\n-                    in\n-                      expect ps RPAREN;\n-                      expect ps SEMI;\n-                      spans ps stmts apos (Ast.STMT_check_expr expr)\n-\n-                | IF ->\n-                    bump ps;\n-                    expect ps LPAREN;\n-                    let constrs = Pexp.parse_constrs ps in\n-                      expect ps RPAREN;\n-                      let block = parse_block ps in\n-                      let bpos = lexpos ps in\n-                      let calls = synthesise_check_calls bpos constrs in\n-                        [| span ps apos bpos\n-                             (Ast.STMT_check_if (constrs, calls, block))\n-                        |]\n-\n-                | _ ->\n-                    let constrs = Pexp.parse_constrs ps in\n-                      expect ps SEMI;\n-                      let bpos = lexpos ps in\n-                      let calls = synthesise_check_calls bpos constrs in\n-                        [| span ps apos bpos\n-                             (Ast.STMT_check (constrs, calls))\n-                        |]\n-          end\n-\n-      | ALT ->\n-          bump ps;\n-          let rec parse_pat ps  =\n-            match peek ps with\n-                QUES ->\n-                  let apos = lexpos ps in\n-                    bump ps;\n-                    let name = Pexp.parse_name ps in\n-                    let bpos = lexpos ps in\n-                      begin\n-                        match name with\n-                            Ast.NAME_base (Ast.BASE_ident ident) ->\n-                              let slot =\n-                                { Ast.slot_mode = Ast.MODE_local;\n-                                  Ast.slot_ty = None }\n-                              in\n-                                Left\n-                                  (Ast.PAT_slot ((span ps apos bpos slot),\n-                                                 ident))\n-                          |_ -> raise (unexpected ps)\n-                      end\n-\n-              | IDENT _ ->\n-                  let apos = lexpos ps in\n-                  let name = Pexp.parse_name ps in\n-                  let bpos = lexpos ps in\n-                  let lv = name_to_lval apos bpos name in\n-                  let parse_pat ps = either_get_left (parse_pat ps) in\n-                  let args =\n-                    match peek ps with\n-                        LPAREN ->\n-                          let args = paren_comma_list parse_pat ps in\n-                            if Array.length args = 0\n-                            then raise (err \"empty pattern argument list\" ps)\n-                            else args\n-                      | _ -> [| |]\n-                  in\n-                    Left (Ast.PAT_tag (lv, args))\n-\n-              | LIT_INT _\n-              | LIT_UINT _\n-              | LIT_CHAR _\n-              | LIT_BOOL _ ->\n-                  Left (Ast.PAT_lit (Pexp.parse_lit ps))\n-\n-              | UNDERSCORE -> bump ps; Left (Ast.PAT_wild)\n-\n-              | tok -> raise (Parse_err (ps,\n-                                         \"Expected pattern but found '\" ^\n-                                           (string_of_tok tok) ^ \"'\"))\n-          in\n-          let rec parse_arms ps parse_case =\n-            match peek ps with\n-                CASE ->\n-                  bump ps;\n-                  let case = parse_case ps in\n-                  let blk = parse_block ps in\n-                  let combine_and_span case =\n-                    (span ps apos (lexpos ps) (case, blk)) in\n-                  let is_default = either_has_right case in\n-                    if is_default then\n-                      let arm = combine_and_span (either_get_right case) in\n-                        ([], Some arm)\n-                    else\n-                      let rec_result = parse_arms ps parse_case in\n-                      let arm = combine_and_span (either_get_left case) in\n-                        (arm::(fst rec_result), (snd rec_result))\n-              | _ -> ([], None)\n-          in\n-          let parse_alt_block ps str parse_case make_stmt =\n-            let br_parse_case = bracketed LPAREN RPAREN parse_case in\n-            let arms = (ctxt (String.concat \" \" [\"alt\"; str; \"arms\"])\n-                          (fun ps -> parse_arms ps br_parse_case) ps) in\n-              make_stmt (fst arms) (snd arms)\n-          in\n-          let which_alt = match peek ps with\n-              TYPE -> \"type\" | LPAREN -> \"tag\" | _ -> raise (unexpected ps)\n-          in\n-          let (stmts, lval) = if which_alt = \"type\" then bump ps;\n-            bracketed LPAREN RPAREN parse_lval ps\n-          in\n-          let make_alt_tag_stmt val_arms dflt_arm =\n-            assert (not (bool_of_option dflt_arm));\n-            spans ps stmts apos begin\n-              Ast.STMT_alt_tag {\n-                Ast.alt_tag_lval = lval;\n-                Ast.alt_tag_arms = Array.of_list val_arms;\n-              }\n-            end\n-          in\n-          let make_alt_type_stmt val_arms dflt_arm =\n-            spans ps stmts apos begin\n-              Ast.STMT_alt_type {\n-                Ast.alt_type_lval = lval;\n-                Ast.alt_type_arms = Array.of_list val_arms;\n-                Ast.alt_type_else = option_map (fun x -> snd x.node) dflt_arm;\n-              }\n-            end\n-          in\n-          let parse_slot_and_ident ps =\n-            match peek ps with\n-                UNDERSCORE -> Right ()\n-              | _ -> Left (pair_rev (Pexp.parse_slot_and_ident false ps))\n-\n-          in\n-          let parse_alt_tag_block ps =\n-            parse_alt_block ps\n-              \"tag\"\n-              parse_pat\n-              make_alt_tag_stmt\n-          in\n-          let parse_alt_type_block ps =\n-            parse_alt_block ps\n-              \"type\"\n-              parse_slot_and_ident\n-              make_alt_type_stmt\n-          in\n-          let parse_alt_block2 ps =\n-            match which_alt with\n-                \"type\" -> parse_alt_type_block ps\n-              | \"tag\" -> parse_alt_tag_block ps\n-              | _ -> assert false\n-          in\n-            bracketed LBRACE RBRACE parse_alt_block2 ps\n-      | IF ->\n-          let final_else = ref None in\n-          let rec parse_stmt_if _ =\n-            bump ps;\n-            let (stmts, expr) =\n-              ctxt \"stmts: if cond\"\n-                (bracketed LPAREN RPAREN parse_expr) ps\n-            in\n-            let then_block = ctxt \"stmts: if-then\" parse_block ps in\n-              begin\n-                match peek ps with\n-                    ELSE ->\n-                      begin\n-                        bump ps;\n-                        match peek ps with\n-                            IF ->\n-                              let nested_if = parse_stmt_if () in\n-                              let bpos = lexpos ps in\n-                                final_else :=\n-                                  Some (span ps apos bpos nested_if)\n-                          | _ ->\n-                              final_else :=\n-                                Some (ctxt \"stmts: if-else\" parse_block ps)\n-                      end\n-                  | _ -> ()\n-              end;\n-              let res =\n-                spans ps stmts apos\n-                  (Ast.STMT_if\n-                     { Ast.if_test = expr;\n-                       Ast.if_then = then_block;\n-                       Ast.if_else = !final_else; })\n-              in\n-                final_else := None;\n-                res\n-          in\n-            parse_stmt_if()\n-\n-      | FOR ->\n-          bump ps;\n-          begin\n-            match peek ps with\n-                EACH ->\n-                  bump ps;\n-                  let inner ps : ((Ast.slot identified * Ast.ident)\n-                                  * Ast.stmt array\n-                                  * (Ast.lval * Ast.atom array)) =\n-                    let slot = (parse_identified_slot_and_ident true ps) in\n-                    let _    = (expect ps IN) in\n-                    let (stmts1, iter) = (rstr true parse_lval) ps in\n-                    let (stmts2, args) =\n-                      parse_expr_atom_list LPAREN RPAREN ps\n-                    in\n-                      (slot, Array.append stmts1 stmts2, (iter, args))\n-                  in\n-                  let (slot, stmts, call) = ctxt \"stmts: foreach head\"\n-                    (bracketed LPAREN RPAREN inner) ps\n-                  in\n-                  let body_block =\n-                    ctxt \"stmts: foreach body\" parse_block ps\n-                  in\n-                  let bpos = lexpos ps in\n-                  let head_block =\n-                    (*\n-                     * Slightly weird, but we put an extra nesting level of\n-                     * block here to separate the part that lives in our frame\n-                     * (the iter slot) from the part that lives in the callee\n-                     * frame (the body block).\n-                     *)\n-                    span ps apos bpos [|\n-                      span ps apos bpos (Ast.STMT_block body_block);\n-                    |]\n-                  in\n-                    Array.append stmts\n-                      [| span ps apos bpos\n-                           (Ast.STMT_for_each\n-                              { Ast.for_each_slot = slot;\n-                                Ast.for_each_call = call;\n-                                Ast.for_each_head = head_block;\n-                                Ast.for_each_body = body_block; }) |]\n-              | _ ->\n-                  let inner ps =\n-                    let slot = (parse_identified_slot_and_ident false ps) in\n-                    let _    = (expect ps IN) in\n-                      (slot, (parse_lval ps))\n-                  in\n-                  let (slot, (stmts, lval)) =\n-                    ctxt \"stmts: for head\" (bracketed LPAREN RPAREN inner) ps\n-                  in\n-                  let body_block = ctxt \"stmts: for body\" parse_block ps in\n-                  let bpos = lexpos ps in\n-                    Array.append stmts\n-                      [| span ps apos bpos\n-                           (Ast.STMT_for\n-                            { Ast.for_slot = slot;\n-                              Ast.for_seq = lval;\n-                              Ast.for_body = body_block; }) |]\n-          end\n-\n-      | WHILE ->\n-          bump ps;\n-          let (stmts, test) =\n-            ctxt \"stmts: while cond\" (bracketed LPAREN RPAREN parse_expr) ps\n-          in\n-          let body_block = ctxt \"stmts: while body\" parse_block ps in\n-          let bpos = lexpos ps in\n-            [| span ps apos bpos\n-                 (Ast.STMT_while\n-                    { Ast.while_lval = (stmts, test);\n-                      Ast.while_body = body_block; }) |]\n-\n-      | PUT ->\n-          begin\n-            bump ps;\n-            match peek ps with\n-                EACH ->\n-                  bump ps;\n-                  let (lstmts, lval) =\n-                    ctxt \"put each: lval\" (rstr true parse_lval) ps\n-                  in\n-                  let (astmts, args) =\n-                    ctxt \"put each: args\"\n-                      (parse_expr_atom_list LPAREN RPAREN) ps\n-                  in\n-                  let bpos = lexpos ps in\n-                  let be =\n-                    span ps apos bpos (Ast.STMT_put_each (lval, args))\n-                  in\n-                    expect ps SEMI;\n-                    Array.concat [ lstmts; astmts; [| be |] ]\n-\n-              | _ ->\n-                  begin\n-                    let (stmts, e) =\n-                      match peek ps with\n-                          SEMI -> (arr [], None)\n-                        | _ ->\n-                            let (stmts, expr) =\n-                              ctxt \"stmts: put expr\" parse_expr_atom ps\n-                            in\n-                              expect ps SEMI;\n-                              (stmts, Some expr)\n-                    in\n-                      spans ps stmts apos (Ast.STMT_put e)\n-                  end\n-          end\n-\n-      | RET ->\n-          bump ps;\n-          let (stmts, e) =\n-            match peek ps with\n-                SEMI -> (bump ps; (arr [], None))\n-              | _ ->\n-                  let (stmts, expr) =\n-                    ctxt \"stmts: ret expr\" parse_expr_atom ps\n-                  in\n-                    expect ps SEMI;\n-                    (stmts, Some expr)\n-          in\n-            spans ps stmts apos (Ast.STMT_ret e)\n-\n-      | BE ->\n-          bump ps;\n-          let (lstmts, lval) = ctxt \"be: lval\" (rstr true parse_lval) ps in\n-          let (astmts, args) =\n-            ctxt \"be: args\" (parse_expr_atom_list LPAREN RPAREN) ps\n-          in\n-          let bpos = lexpos ps in\n-          let be = span ps apos bpos (Ast.STMT_be (lval, args)) in\n-            expect ps SEMI;\n-            Array.concat [ lstmts; astmts; [| be |] ]\n-\n-      | LBRACE -> [| ctxt \"stmts: block\" parse_block_stmt ps |]\n-\n-      | LET ->\n-          bump ps;\n-          let (stmts, slot, ident) =\n-            ctxt \"stmt slot\" parse_slot_and_ident_and_init ps in\n-          let slot = ensure_mutable slot in\n-          let bpos = lexpos ps in\n-          let decl = Ast.DECL_slot (Ast.KEY_ident ident,\n-                                    (span ps apos bpos slot))\n-          in\n-            Array.concat [[| span ps apos bpos (Ast.STMT_decl decl) |]; stmts]\n-\n-      | AUTO ->\n-          bump ps;\n-          let (stmts, slot, ident) =\n-            ctxt \"stmt slot\" parse_auto_slot_and_init ps in\n-          let slot = ensure_mutable slot in\n-          let bpos = lexpos ps in\n-          let decl = Ast.DECL_slot (Ast.KEY_ident ident,\n-                                    (span ps apos bpos slot))\n-          in\n-            Array.concat [[| span ps apos bpos (Ast.STMT_decl decl) |]; stmts]\n-\n-      | YIELD ->\n-          bump ps;\n-          expect ps SEMI;\n-          let bpos = lexpos ps in\n-            [| span ps apos bpos Ast.STMT_yield |]\n-\n-      | FAIL ->\n-          bump ps;\n-          expect ps SEMI;\n-          let bpos = lexpos ps in\n-            [| span ps apos bpos Ast.STMT_fail |]\n-\n-      | JOIN ->\n-          bump ps;\n-          let (stmts, lval) = ctxt \"stmts: task expr\" parse_lval ps in\n-            expect ps SEMI;\n-            spans ps stmts apos (Ast.STMT_join lval)\n-\n-\n-       | STATE | GC | NATIVE\n-       | MOD | OBJ | TAG | TYPE | FN | USE ->\n-          let items = ctxt \"stmt: decl\" parse_mod_item ps in\n-          let bpos = lexpos ps in\n-            Array.map\n-              begin\n-                fun (ident, item) ->\n-                  let decl = Ast.DECL_mod_item (ident, item) in\n-                    span ps apos bpos (Ast.STMT_decl decl)\n-              end\n-              items\n-\n-      | token ->\n-          if token = SPAWN then\n-            prerr_endline (\"warning: \\\"spawn\\\" with unused result spawns a \" ^\n-              \"task that immediately dies\");\n-\n-          let (lstmts, lval) = ctxt \"stmt: lval\" parse_lval ps in\n-          let stmts =\n-            match peek ps with\n-\n-                SEMI -> (bump ps; [| |])\n-\n-              | EQ -> parse_init lval ps\n-\n-              | OPEQ binop_token ->\n-                  bump ps;\n-                  let (stmts, rhs) =\n-                    ctxt \"stmt: opeq rhs\" parse_expr_atom ps\n-                  in\n-                  let binop =\n-                    match binop_token with\n-                        PLUS    -> Ast.BINOP_add\n-                      | MINUS   -> Ast.BINOP_sub\n-                      | STAR    -> Ast.BINOP_mul\n-                      | SLASH   -> Ast.BINOP_div\n-                      | PERCENT -> Ast.BINOP_mod\n-                      | AND     -> Ast.BINOP_and\n-                      | OR      -> Ast.BINOP_or\n-                      | CARET   -> Ast.BINOP_xor\n-                      | LSL     -> Ast.BINOP_lsl\n-                      | LSR     -> Ast.BINOP_lsr\n-                      | ASR     -> Ast.BINOP_asr\n-                      | _       -> raise (err \"unknown opeq token\" ps)\n-                  in\n-                    expect ps SEMI;\n-                    spans ps stmts apos\n-                      (Ast.STMT_copy_binop (lval, binop, rhs))\n-\n-              | LARROW ->\n-                  bump ps;\n-                  let (stmts, rhs) = ctxt \"stmt: recv rhs\" parse_lval ps in\n-                  let _ = expect ps SEMI in\n-                    spans ps stmts apos (Ast.STMT_recv (lval, rhs))\n-\n-              | SEND ->\n-                  bump ps;\n-                  let (stmts, rhs) =\n-                    ctxt \"stmt: send rhs\" parse_expr_atom ps\n-                  in\n-                  let _ = expect ps SEMI in\n-                  let bpos = lexpos ps in\n-                  let (src, copy) = match rhs with\n-                      Ast.ATOM_lval lv -> (lv, [| |])\n-                    | _ ->\n-                        let (_, tmp, tempdecl) =\n-                          build_tmp ps slot_auto apos bpos\n-                        in\n-                        let copy = span ps apos bpos\n-                          (Ast.STMT_copy (tmp, Ast.EXPR_atom rhs)) in\n-                            ((clone_lval ps tmp), [| tempdecl; copy |])\n-                  in\n-                  let send =\n-                    span ps apos bpos\n-                      (Ast.STMT_send (lval, src))\n-                  in\n-                    Array.concat [ stmts; copy; [| send |] ]\n-\n-              | _ -> raise (unexpected ps)\n-          in\n-          Array.append lstmts stmts\n-\n-\n-and parse_ty_param (iref:int ref) (ps:pstate) : Ast.ty_param identified =\n-  let apos = lexpos ps in\n-  let s = Pexp.parse_layer ps in\n-  let ident = Pexp.parse_ident ps in\n-  let i = !iref in\n-  let bpos = lexpos ps in\n-    incr iref;\n-    span ps apos bpos (ident, (i, s))\n-\n-and parse_ty_params (ps:pstate)\n-    : (Ast.ty_param identified) array =\n-  match peek ps with\n-      LBRACKET ->\n-        bracketed_zero_or_more LBRACKET RBRACKET (Some COMMA)\n-          (parse_ty_param (ref 0)) ps\n-    | _ -> arr []\n-\n-and parse_ident_and_params (ps:pstate) (cstr:string)\n-    : (Ast.ident * (Ast.ty_param identified) array) =\n-  let ident = ctxt (\"mod \" ^ cstr ^ \" item: ident\") Pexp.parse_ident ps in\n-  let params =\n-    ctxt (\"mod \" ^ cstr ^ \" item: type params\") parse_ty_params ps\n-  in\n-    (ident, params)\n-\n-and parse_inputs\n-    (ps:pstate)\n-    : ((Ast.slot identified * Ast.ident) array * Ast.constrs)  =\n-  let slots =\n-    match peek ps with\n-        LPAREN -> ctxt \"inputs: input idents and slots\"\n-          (parse_zero_or_more_identified_slot_ident_pairs true) ps\n-      | _ -> raise (unexpected ps)\n-  in\n-  let constrs =\n-    match peek ps with\n-        COLON -> (bump ps; ctxt \"inputs: constrs\" Pexp.parse_constrs ps)\n-      | _ -> [| |]\n-  in\n-  let rec rewrite_carg_path cp =\n-    match cp with\n-        Ast.CARG_base (Ast.BASE_named (Ast.BASE_ident ident)) ->\n-          begin\n-            let res = ref cp in\n-              for i = 0 to (Array.length slots) - 1\n-              do\n-                let (_, ident') = slots.(i) in\n-                  if ident' = ident\n-                  then res := Ast.CARG_ext (Ast.CARG_base Ast.BASE_formal,\n-                                            Ast.COMP_idx i)\n-                  else ()\n-              done;\n-              !res\n-          end\n-      | Ast.CARG_base _ -> cp\n-      | Ast.CARG_ext (cp, ext) ->\n-          Ast.CARG_ext (rewrite_carg_path cp, ext)\n-  in\n-    (* Rewrite constrs with input tuple as BASE_formal. *)\n-    Array.iter\n-      begin\n-        fun constr ->\n-          let args = constr.Ast.constr_args in\n-            Array.iteri\n-              begin\n-                fun i carg ->\n-                  match carg with\n-                      Ast.CARG_path cp ->\n-                        args.(i) <- Ast.CARG_path (rewrite_carg_path cp)\n-                    | _ -> ()\n-              end\n-              args\n-      end\n-      constrs;\n-    (slots, constrs)\n-\n-\n-and parse_in_and_out\n-    (ps:pstate)\n-    : ((Ast.slot identified * Ast.ident) array\n-       * Ast.constrs\n-       * Ast.slot identified) =\n-  let (inputs, constrs) = parse_inputs ps in\n-  let output =\n-    match peek ps with\n-        RARROW ->\n-          bump ps;\n-          ctxt \"fn in and out: output slot\"\n-            (Pexp.parse_identified_slot true) ps\n-      | _ ->\n-          let apos = lexpos ps in\n-            span ps apos apos slot_nil\n-  in\n-    (inputs, constrs, output)\n-\n-\n-(* parse_fn starts at the first lparen of the sig. *)\n-and parse_fn\n-    (is_iter:bool)\n-    (ps:pstate)\n-    : Ast.fn =\n-    let (inputs, constrs, output) =\n-      ctxt \"fn: in_and_out\" parse_in_and_out ps\n-    in\n-    let body = ctxt \"fn: body\" parse_block ps in\n-      { Ast.fn_input_slots = inputs;\n-        Ast.fn_input_constrs = constrs;\n-        Ast.fn_output_slot = output;\n-        Ast.fn_aux = { Ast.fn_is_iter = is_iter; };\n-        Ast.fn_body = body; }\n-\n-and parse_meta_input (ps:pstate) : (Ast.ident * string option) =\n-  let lab = (ctxt \"meta input: label\" Pexp.parse_ident ps) in\n-    match peek ps with\n-        EQ ->\n-          bump ps;\n-          let v =\n-            match peek ps with\n-                UNDERSCORE -> bump ps; None\n-              | LIT_STR s -> bump ps; Some s\n-              | _ -> raise (unexpected ps)\n-          in\n-            (lab, v)\n-      | _ -> raise (unexpected ps)\n-\n-and parse_meta_pat (ps:pstate) : Ast.meta_pat =\n-  bracketed_zero_or_more LPAREN RPAREN\n-    (Some COMMA) parse_meta_input ps\n-\n-and parse_meta (ps:pstate) : Session.meta =\n-  Array.map\n-    begin\n-      fun (id,v) ->\n-        match v with\n-            None ->\n-              raise (err (\"wildcard found in meta \"\n-                          ^ \"pattern where value expected\") ps)\n-          | Some v -> (id,v)\n-    end\n-    (parse_meta_pat ps)\n-\n-and parse_optional_meta_pat (ps:pstate) (ident:Ast.ident) : Ast.meta_pat =\n-  match peek ps with\n-      LPAREN -> parse_meta_pat ps\n-    | _ -> [| (\"name\", Some ident) |]\n-\n-\n-and parse_obj_item\n-    (ps:pstate)\n-    (apos:pos)\n-    (layer:Ast.layer)\n-    : (Ast.ident * Ast.mod_item) =\n-  expect ps OBJ;\n-  let (ident, params) = parse_ident_and_params ps \"obj\" in\n-  let (state, constrs) = (ctxt \"obj state\" parse_inputs ps) in\n-  let drop = ref None in\n-    expect ps LBRACE;\n-    let fns = Hashtbl.create 0 in\n-      while (not (peek ps = RBRACE))\n-      do\n-        let apos = lexpos ps in\n-          match peek ps with\n-              FN | ITER ->\n-                let is_iter = (peek ps) = ITER in\n-                  bump ps;\n-                  let ident = ctxt \"obj fn: ident\" Pexp.parse_ident ps in\n-                  let fn = ctxt \"obj fn: fn\" (parse_fn is_iter) ps in\n-                  let bpos = lexpos ps in\n-                    htab_put fns ident (span ps apos bpos fn)\n-            | DROP ->\n-                bump ps;\n-                drop := Some (parse_block ps)\n-            | RBRACE -> ()\n-            | _ -> raise (unexpected ps)\n-      done;\n-      expect ps RBRACE;\n-      let bpos = lexpos ps in\n-      let obj = { Ast.obj_state = state;\n-                  Ast.obj_layer = layer;\n-                  Ast.obj_constrs = constrs;\n-                  Ast.obj_fns = fns;\n-                  Ast.obj_drop = !drop }\n-      in\n-        (ident,\n-         span ps apos bpos\n-           (decl params (Ast.MOD_ITEM_obj obj)))\n-\n-and parse_tag_item\n-    (ps:pstate)\n-    (apos:pos)\n-    (layer:Ast.layer)\n-    : (Ast.ident * Ast.mod_item) array =\n-  expect ps TAG;\n-  let (ident, params) = parse_ident_and_params ps \"tag\" in\n-  let tag_id = next_opaque_id ps in\n-  let i = ref 0 in\n-  let parse_tag_ctor ps =\n-    let apos = lexpos ps in\n-    let ident = Pexp.parse_ident ps in\n-    let hdr =\n-      let j = ref 0 in\n-      let parse_ctor_slot ps =\n-        let apos = lexpos ps in\n-        let t = Pexp.parse_ty ps in\n-        let s = { Ast.slot_mode = Ast.MODE_local;\n-                  Ast.slot_ty = Some t }\n-        in\n-        let bpos = lexpos ps in\n-          incr j;\n-          ((span ps apos bpos s), \"_\" ^ string_of_int (!j))\n-      in\n-      let res =\n-        match peek ps with\n-            LPAREN ->\n-              let slots = paren_comma_list parse_ctor_slot ps in\n-                if Array.length slots = 0\n-                then\n-                  raise (err (\"empty argument list to tag constructor\") ps)\n-                else slots\n-\n-          | _ -> [| |]\n-      in\n-        expect ps SEMI;\n-        res\n-    in\n-    let n = !i in\n-    let bpos = lexpos ps in\n-    let params =\n-      Array.map (fun p -> Parser.clone_span ps p p.node) params\n-    in\n-      incr i;\n-      (ident,\n-       span ps apos bpos\n-         (decl params\n-            (Ast.MOD_ITEM_tag (hdr, tag_id, n))))\n-  in\n-  let constructors =\n-    bracketed_one_or_more LBRACE RBRACE\n-      None (ctxt \"tag: ctor\" parse_tag_ctor) ps\n-  in\n-  let bpos = lexpos ps in\n-  let ty =\n-    Ast.TY_tag\n-      { Ast.tag_id = tag_id;\n-        Ast.tag_args =\n-          Array.map\n-            (fun p -> Ast.TY_param (snd p.node))\n-            params }\n-  in\n-  let ty_item =\n-    (ident,\n-     span ps apos bpos\n-       (decl params (Ast.MOD_ITEM_type (layer, ty))))\n-  in\n-    Array.append [| ty_item |] constructors\n-\n-and parse_type_item\n-    (ps:pstate)\n-    (apos:pos)\n-    (layer:Ast.layer)\n-    : (Ast.ident * Ast.mod_item) =\n-  expect ps TYPE;\n-  let (ident, params) = parse_ident_and_params ps \"type\" in\n-  let _ = expect ps EQ in\n-  let ty = ctxt \"mod type item: ty\" Pexp.parse_ty ps in\n-  let _ = expect ps SEMI in\n-  let bpos = lexpos ps in\n-  let item = Ast.MOD_ITEM_type (layer, ty) in\n-    (ident, span ps apos bpos (decl params item))\n-\n-and parse_mod_item (ps:pstate)\n-    : (Ast.ident * Ast.mod_item) array =\n-  let apos = lexpos ps in\n-  let parse_lib_name ident =\n-    match peek ps with\n-        EQ ->\n-          begin\n-            bump ps;\n-            let do_tok t =\n-              bump ps;\n-              match t with\n-                  LIT_STR s -> s\n-                | _ -> raise (unexpected ps)\n-            in\n-              match peek ps with\n-                  IDENT i ->\n-                    do_tok (ps.pstate_get_cenv_tok ps i)\n-                | t ->\n-                    do_tok t\n-          end\n-      | _ -> ps.pstate_infer_lib_name ident\n-  in\n-\n-\n-    match peek ps with\n-\n-        STATE | GC\n-      | TYPE | OBJ | TAG | FN | ITER ->\n-          let layer = Pexp.parse_layer ps in\n-            begin\n-              match peek ps with\n-                  OBJ ->\n-                    [| parse_obj_item ps apos layer |]\n-                | TAG ->\n-                    parse_tag_item ps apos layer\n-                | TYPE ->\n-                    [| parse_type_item ps apos layer |]\n-                | _ ->\n-                    if layer <> Ast.LAYER_value\n-                    then raise (err \"layer specified for fn or iter\" ps);\n-                    let is_iter = (peek ps) = ITER in\n-                      bump ps;\n-                      let (ident, params) = parse_ident_and_params ps \"fn\" in\n-                      let fn =\n-                        ctxt \"mod fn item: fn\" (parse_fn is_iter) ps\n-                      in\n-                      let bpos = lexpos ps in\n-                        [| (ident,\n-                            span ps apos bpos\n-                              (decl params (Ast.MOD_ITEM_fn fn))) |]\n-            end\n-\n-      | CONST ->\n-          bump ps;\n-          let ty = Pexp.parse_ty ps in\n-          let ident = Pexp.parse_ident ps in\n-            expect ps EQ;\n-            let expr = parse_prim_expr ps in\n-              expect ps SEMI;\n-              let bpos = lexpos ps in\n-                [| (ident, span ps apos bpos\n-                      (decl [||] (Ast.MOD_ITEM_const (ty, Some expr)))) |]\n-\n-      | MOD ->\n-          bump ps;\n-          let (ident, params) = parse_ident_and_params ps \"mod\" in\n-            expect ps LBRACE;\n-            let items = parse_mod_items ps RBRACE in\n-            let bpos = lexpos ps in\n-              [| (ident,\n-                  span ps apos bpos\n-                    (decl params (Ast.MOD_ITEM_mod items))) |]\n-\n-      | NATIVE ->\n-          begin\n-            bump ps;\n-            let conv =\n-              match peek ps with\n-                  LIT_STR s ->\n-                    bump ps;\n-                    begin\n-                      match string_to_conv s with\n-                          None -> raise (unexpected ps)\n-                        | Some c -> c\n-                    end\n-                | _ -> CONV_cdecl\n-            in\n-              expect ps MOD;\n-              let ident = Pexp.parse_ident ps in\n-              let path = parse_lib_name ident in\n-              let items = parse_native_mod_items_from_signature ps in\n-              let bpos = lexpos ps in\n-              let rlib = REQUIRED_LIB_c { required_libname = path;\n-                                          required_prefix = ps.pstate_depth }\n-              in\n-              let item = decl [||] (Ast.MOD_ITEM_mod items) in\n-              let item = span ps apos bpos item in\n-                note_required_mod ps {lo=apos; hi=bpos} conv rlib item;\n-                [| (ident, item) |]\n-          end\n-      | _ -> raise (unexpected ps)\n-\n-and parse_native_mod_header_from_signature (ps:pstate) : Ast.mod_view =\n-  let exports = Hashtbl.create 0 in\n-    while (peek ps = EXPORT)\n-    do\n-      bump ps;\n-      parse_export ps exports;\n-      expect ps SEMI;\n-    done;\n-    if (Hashtbl.length exports) = 0\n-    then htab_put exports Ast.EXPORT_all_decls ();\n-    {empty_view with Ast.view_exports = exports}\n-\n-and parse_native_mod_items_from_signature\n-    (ps:pstate)\n-    : (Ast.mod_view * Ast.mod_items) =\n-  expect ps LBRACE;\n-  let view  = parse_native_mod_header_from_signature ps in\n-  let items = Hashtbl.create 0 in\n-    while not (peek ps = RBRACE)\n-    do\n-      Array.iter\n-        (fun (ident, item) ->\n-           htab_put items ident item)\n-        (ctxt \"mod items from sig: mod item\"\n-           parse_native_mod_item_from_signature ps)\n-    done;\n-    expect ps RBRACE;\n-    (view,items)\n-\n-and parse_native_mod_item_from_signature (ps:pstate)\n-    : (Ast.ident * Ast.mod_item) array =\n-  let apos = lexpos ps in\n-    match peek ps with\n-        MOD ->\n-          bump ps;\n-          let (ident, params) = parse_ident_and_params ps \"mod signature\" in\n-          let items = parse_native_mod_items_from_signature ps in\n-          let bpos = lexpos ps in\n-            [| (ident,\n-                span ps apos bpos (decl params (Ast.MOD_ITEM_mod items))) |]\n-\n-      | FN | ITER ->\n-          let is_iter = (peek ps) = ITER in\n-            bump ps;\n-            let (ident, params) = parse_ident_and_params ps \"fn signature\" in\n-            let (inputs, constrs, output) = parse_in_and_out ps in\n-            let bpos = lexpos ps in\n-            let body = span ps apos bpos [| |] in\n-            let fn =\n-              Ast.MOD_ITEM_fn\n-                { Ast.fn_input_slots = inputs;\n-                  Ast.fn_input_constrs = constrs;\n-                  Ast.fn_output_slot = output;\n-                  Ast.fn_aux = { Ast.fn_is_iter = is_iter; };\n-                  Ast.fn_body = body; }\n-            in\n-            let node = span ps apos bpos (decl params fn) in\n-              begin\n-                match peek ps with\n-                    EQ ->\n-                      bump ps;\n-                      begin\n-                        match peek ps with\n-                            LIT_STR s ->\n-                              bump ps;\n-                              htab_put ps.pstate_required_syms node.id s\n-                          | _ -> raise (unexpected ps)\n-                      end;\n-                  | _ -> ()\n-              end;\n-              expect ps SEMI;\n-              [| (ident, node) |]\n-\n-    | TYPE ->\n-        bump ps;\n-        let (ident, params) = parse_ident_and_params ps \"type type\" in\n-        let t =\n-          match peek ps with\n-              SEMI -> Ast.TY_native (next_opaque_id ps)\n-            | _ -> Pexp.parse_ty ps\n-        in\n-          expect ps SEMI;\n-          let bpos = lexpos ps in\n-            [| (ident, span ps apos bpos\n-                  (decl params (Ast.MOD_ITEM_type (Ast.LAYER_value, t)))) |]\n-\n-    | _ -> raise (unexpected ps)\n-\n-and note_required_mod\n-    (ps:pstate)\n-    (sp:span)\n-    (conv:nabi_conv)\n-    (rlib:required_lib)\n-    (item:Ast.mod_item)\n-    : unit =\n-  iflog ps\n-    begin\n-      fun _ -> log ps \"marking item #%d as required\" (int_of_node item.id)\n-    end;\n-  htab_put ps.pstate_required item.id (rlib, conv);\n-  if not (Hashtbl.mem ps.pstate_sess.Session.sess_spans item.id)\n-  then Hashtbl.add ps.pstate_sess.Session.sess_spans item.id sp;\n-  match item.node.Ast.decl_item with\n-      Ast.MOD_ITEM_mod (_, items) ->\n-        Hashtbl.iter\n-          begin\n-            fun _ sub ->\n-              note_required_mod ps sp conv rlib sub\n-          end\n-          items\n-    | _ -> ()\n-\n-\n-and parse_import\n-    (ps:pstate)\n-    (imports:(Ast.ident, Ast.name) Hashtbl.t)\n-    : unit =\n-  let import a n =\n-    let a = match a with\n-        None ->\n-          begin\n-            match n with\n-                Ast.NAME_ext (_, Ast.COMP_ident i)\n-              | Ast.NAME_ext (_, Ast.COMP_app (i, _))\n-              | Ast.NAME_base (Ast.BASE_ident i)\n-              | Ast.NAME_base (Ast.BASE_app (i, _)) -> i\n-              | _ -> raise (Parse_err (ps, \"bad import specification\"))\n-          end\n-      | Some i -> i\n-    in\n-      Hashtbl.add imports a n\n-  in\n-    match peek ps with\n-        IDENT i ->\n-          begin\n-            bump ps;\n-            match peek ps with\n-                EQ ->\n-                  (*\n-                   * import x = ...\n-                   *)\n-                  bump ps;\n-                  import (Some i) (Pexp.parse_name ps)\n-              | _ ->\n-                  (*\n-                   * import x...\n-                   *)\n-                  import None (Pexp.parse_name_ext ps\n-                                 (Ast.NAME_base\n-                                    (Ast.BASE_ident i)))\n-          end\n-      | _ ->\n-          import None (Pexp.parse_name ps)\n-\n-\n-and parse_export\n-    (ps:pstate)\n-    (exports:(Ast.export, unit) Hashtbl.t)\n-    : unit =\n-  let e =\n-    match peek ps with\n-        STAR -> bump ps; Ast.EXPORT_all_decls\n-      | IDENT i -> bump ps; Ast.EXPORT_ident i\n-      | _ -> raise (unexpected ps)\n-  in\n-    Hashtbl.add exports e ()\n-\n-and parse_use\n-    (ps:pstate)\n-    : (Ast.ident * Ast.mod_item) array =\n-  bump ps;\n-  let ident = ctxt \"use mod: ident\" Pexp.parse_ident ps in\n-  let meta =\n-    ctxt \"use mod: meta\" parse_optional_meta_pat ps ident\n-  in\n-  let apos = lexpos ps in\n-  let bpos = lexpos ps in\n-  let id = (span ps apos bpos ()).id in\n-  let (path, items) = ps.pstate_get_mod meta id ps.pstate_crate_cache in\n-  let bpos = lexpos ps in\n-    expect ps SEMI;\n-    let rlib =\n-      REQUIRED_LIB_rust { required_libname = path;\n-                          required_prefix = ps.pstate_depth }\n-    in\n-      iflog ps\n-        begin\n-          fun _ ->\n-            log ps \"extracted mod from %s (binding to %s)\"\n-              path ident;\n-            log ps \"%a\" Ast.sprintf_mod_items items;\n-        end;\n-      let item = decl [||] (Ast.MOD_ITEM_mod (empty_view, items)) in\n-      let item = span ps apos bpos item in\n-        note_required_mod ps {lo=apos; hi=bpos} CONV_rust rlib item;\n-        [| (ident, item) |]\n-\n-and parse_item_decl ps items fn =\n-  let add (id, item) =\n-    if Hashtbl.mem items id then\n-      raise (Parse_err\n-        (ps, (Printf.sprintf \"item name already in use: '%s'\" id)));\n-    Hashtbl.add items id item\n-  in\n-  Array.iter add (fn ps)\n-\n-and parse_mod_header (ps:pstate)\n-                     : (Ast.mod_view * Ast.mod_items) =\n-  let imports = Hashtbl.create 0 in\n-  let exports = Hashtbl.create 0 in\n-  let items   = Hashtbl.create 4 in\n-  let rec loop () =\n-    match peek ps with\n-        IMPORT ->\n-          bump ps;\n-          parse_import ps imports;\n-          expect ps SEMI;\n-          loop ()\n-      | EXPORT ->\n-          bump ps;\n-          parse_export ps exports;\n-          expect ps SEMI;\n-          loop ()\n-      | USE ->\n-          parse_item_decl ps items parse_use;\n-          loop ()\n-      | _ -> ()\n-  in\n-    loop ();\n-    if (Hashtbl.length exports) = 0\n-    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n-    let view = { Ast.view_imports = imports;\n-                 Ast.view_exports = exports }\n-    in\n-      (view, items)\n-\n-and parse_mod_items\n-    (ps:pstate)\n-    (terminal:token)\n-    : (Ast.mod_view * Ast.mod_items) =\n-  ps.pstate_depth <- ps.pstate_depth + 1;\n-  let (view, items) = parse_mod_header ps in\n-    while (not (peek ps = terminal))\n-    do\n-      parse_item_decl ps items parse_mod_item;\n-    done;\n-    expect ps terminal;\n-    ps.pstate_depth <- ps.pstate_depth - 1;\n-    (view, items)\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "a65acba1a6f7668d855e0852e4dd77980261f5cd", "filename": "src/boot/fe/lexer.mll", "status": "removed", "additions": 0, "deletions": 478, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Flexer.mll", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Flexer.mll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Flexer.mll?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,478 +0,0 @@\n-\n-\n-{\n-\n-  open Token;;\n-  open Common;;\n-\n-  exception Lex_err of (string * Common.pos);;\n-\n-  let fail lexbuf s =\n-    let p = lexbuf.Lexing.lex_start_p in\n-    let pos =\n-      (p.Lexing.pos_fname,\n-       p.Lexing.pos_lnum ,\n-       (p.Lexing.pos_cnum) - (p.Lexing.pos_bol))\n-    in\n-      raise (Lex_err (s, pos))\n-  ;;\n-\n-  let bump_line p = { p with\n-              Lexing.pos_lnum = p.Lexing.pos_lnum + 1;\n-              Lexing.pos_bol = p.Lexing.pos_cnum }\n-  ;;\n-\n-  let newline lexbuf =\n-    lexbuf.Lexing.lex_curr_p\n-    <- (bump_line lexbuf.Lexing.lex_curr_p)\n-  ;;\n-\n-  let mach_suf_table = Hashtbl.create 10\n-  ;;\n-\n-  let reserved_suf_table = Hashtbl.create 10\n-  ;;\n-\n-  let _ =\n-    List.iter (fun (suf, ty) -> Common.htab_put mach_suf_table suf ty)\n-      [ (\"u8\", Common.TY_u8);\n-        (\"i8\", Common.TY_i8);\n-        (\"u16\", Common.TY_u16);\n-        (\"i16\", Common.TY_i16);\n-        (\"u32\", Common.TY_u32);\n-        (\"i32\", Common.TY_i32);\n-        (\"u64\", Common.TY_u64);\n-        (\"i64\", Common.TY_i64);\n-        (\"f32\", Common.TY_f32);\n-        (\"f64\", Common.TY_f64); ]\n-  ;;\n-\n-  let _ =\n-    List.iter (fun suf -> Common.htab_put reserved_suf_table suf ())\n-      [ \"f16\";  (* IEEE 754-2008 'binary16' interchange format. *)\n-        \"f80\";  (* IEEE 754-1985 'extended'   *)\n-        \"f128\"; (* IEEE 754-2008 'binary128'  *)\n-        \"m32\";  (* IEEE 754-2008 'decimal32'  *)\n-        \"m64\";  (* IEEE 754-2008 'decimal64'  *)\n-        \"m128\"; (* IEEE 754-2008 'decimal128' *)\n-        \"m\";  (* One of m32, m64, m128.     *)\n-      ]\n-  ;;\n-\n-  let keyword_table = Hashtbl.create 100\n-  ;;\n-\n-  let reserved_table = Hashtbl.create 10\n-  ;;\n-\n-  let _ =\n-    List.iter (fun (kwd, tok) -> Common.htab_put keyword_table kwd tok)\n-              [ (\"mod\", MOD);\n-                (\"use\", USE);\n-                (\"meta\", META);\n-                (\"auth\", AUTH);\n-\n-                (\"syntax\", SYNTAX);\n-\n-                (\"if\", IF);\n-                (\"else\", ELSE);\n-                (\"while\", WHILE);\n-                (\"do\", DO);\n-                (\"alt\", ALT);\n-                (\"case\", CASE);\n-\n-                (\"for\", FOR);\n-                (\"each\", EACH);\n-                (\"put\", PUT);\n-                (\"ret\", RET);\n-                (\"be\", BE);\n-\n-                (\"fail\", FAIL);\n-                (\"drop\", DROP);\n-\n-                (\"type\", TYPE);\n-                (\"check\", CHECK);\n-                (\"assert\", ASSERT); \n-                (\"claim\", CLAIM);\n-                (\"prove\", PROVE);\n-\n-                (\"state\", STATE);\n-                (\"gc\", GC);\n-\n-                (\"unsafe\", UNSAFE);\n-\n-                (\"native\", NATIVE);\n-                (\"mutable\", MUTABLE);\n-                (\"auto\", AUTO);\n-\n-                (\"fn\", FN);\n-                (\"iter\", ITER);\n-\n-                (\"import\", IMPORT);\n-                (\"export\", EXPORT);\n-\n-                (\"let\", LET);\n-                (\"const\", CONST);\n-\n-                (\"log\", LOG);\n-                (\"log_err\", LOG_ERR);\n-                (\"break\", BREAK);\n-                (\"cont\", CONT);\n-                (\"spawn\", SPAWN);\n-                (\"thread\", THREAD);\n-                (\"yield\", YIELD);\n-                (\"join\", JOIN);\n-\n-                (\"bool\", BOOL);\n-\n-                (\"int\", INT);\n-                (\"uint\", UINT);\n-                (\"float\", FLOAT);\n-\n-                (\"char\", CHAR);\n-                (\"str\", STR);\n-\n-                (\"rec\", REC);\n-                (\"tup\", TUP);\n-                (\"tag\", TAG);\n-                (\"vec\", VEC);\n-                (\"any\", ANY);\n-\n-                (\"obj\", OBJ);\n-\n-                (\"port\", PORT);\n-                (\"chan\", CHAN);\n-\n-                (\"task\", TASK);\n-\n-                (\"true\", LIT_BOOL true);\n-                (\"false\", LIT_BOOL false);\n-\n-                (\"in\", IN);\n-\n-                (\"as\", AS);\n-                (\"with\", WITH);\n-\n-                (\"bind\", BIND);\n-\n-                (\"u8\", MACH TY_u8);\n-                (\"u16\", MACH TY_u16);\n-                (\"u32\", MACH TY_u32);\n-                (\"u64\", MACH TY_u64);\n-                (\"i8\", MACH TY_i8);\n-                (\"i16\", MACH TY_i16);\n-                (\"i32\", MACH TY_i32);\n-                (\"i64\", MACH TY_i64);\n-                (\"f32\", MACH TY_f32);\n-                (\"f64\", MACH TY_f64)\n-              ]\n-;;\n-\n-  let _ =\n-    List.iter (fun kwd -> Common.htab_put reserved_table kwd ())\n-              [ \"f16\";  (* IEEE 754-2008 'binary16' interchange format. *)\n-                \"f80\";  (* IEEE 754-1985 'extended'   *)\n-                \"f128\"; (* IEEE 754-2008 'binary128'  *)\n-                \"m32\";  (* IEEE 754-2008 'decimal32'  *)\n-                \"m64\";  (* IEEE 754-2008 'decimal64'  *)\n-                \"m128\"; (* IEEE 754-2008 'decimal128' *)\n-                \"dec\";  (* One of m32, m64, m128.     *)\n-              ];\n-  ;;\n-\n-}\n-\n-let hexdig = ['0'-'9' 'a'-'f' 'A'-'F']\n-let decdig = ['0'-'9']\n-let bin = '0' 'b' ['0' '1' '_']*\n-let hex = '0' 'x' ['0'-'9' 'a'-'f' 'A'-'F' '_']*\n-let dec = decdig ['0'-'9' '_']*\n-let exp = ['e''E']['-''+']? dec\n-let flo = (dec '.' dec (exp?)) | (dec exp)\n-\n-let mach_float_suf = \"f32\"|\"f64\"\n-let mach_int_suf = ['u''i']('8'|\"16\"|\"32\"|\"64\")\n-let flo_suf = ['m''f'](\"16\"|\"32\"|\"64\"|\"80\"|\"128\")\n-\n-let ws = [ ' ' '\\t' '\\r' ]\n-\n-let id = ['a'-'z' 'A'-'Z' '_']['a'-'z' 'A'-'Z' '0'-'9' '_']*\n-\n-rule token = parse\n-  ws+                          { token lexbuf }\n-| '\\n'                         { newline lexbuf;\n-                                 token lexbuf }\n-| \"//\" [^'\\n']*                { token lexbuf }\n-| \"/*\"                         { comment 1 lexbuf }\n-| '+'                          { PLUS       }\n-| '-'                          { MINUS      }\n-| '*'                          { STAR       }\n-| '/'                          { SLASH      }\n-| '%'                          { PERCENT    }\n-| '='                          { EQ         }\n-| '<'                          { LT         }\n-| \"<=\"                         { LE         }\n-| \"==\"                         { EQEQ       }\n-| \"!=\"                         { NE         }\n-| \">=\"                         { GE         }\n-| '>'                          { GT         }\n-| '!'                          { NOT        }\n-| '&'                          { AND        }\n-| \"&&\"                         { ANDAND     }\n-| '|'                          { OR         }\n-| \"||\"                         { OROR       }\n-| \"<<\"                         { LSL        }\n-| \">>\"                         { LSR        }\n-| \">>>\"                        { ASR        }\n-| '~'                          { TILDE      }\n-| '{'                          { LBRACE     }\n-| '_' (decdig+ as n)           { IDX (int_of_string n) }\n-| '_'                          { UNDERSCORE }\n-| '}'                          { RBRACE     }\n-\n-| \"+=\"                         { OPEQ (PLUS)    }\n-| \"-=\"                         { OPEQ (MINUS)   }\n-| \"*=\"                         { OPEQ (STAR)    }\n-| \"/=\"                         { OPEQ (SLASH)   }\n-| \"%=\"                         { OPEQ (PERCENT) }\n-| \"&=\"                         { OPEQ (AND) }\n-| \"|=\"                         { OPEQ (OR)  }\n-| \"<<=\"                        { OPEQ (LSL) }\n-| \">>=\"                        { OPEQ (LSR) }\n-| \">>>=\"                       { OPEQ (ASR) }\n-| \"^=\"                         { OPEQ (CARET) }\n-\n-| '#'                          { POUND      }\n-| '@'                          { AT         }\n-| '^'                          { CARET      }\n-| '.'                          { DOT        }\n-| ','                          { COMMA      }\n-| ';'                          { SEMI       }\n-| ':'                          { COLON      }\n-| '?'                          { QUES       }\n-| \"<-\"                         { LARROW     }\n-| \"<|\"                         { SEND       }\n-| \"->\"                         { RARROW     }\n-| '('                          { LPAREN     }\n-| ')'                          { RPAREN     }\n-| '['                          { LBRACKET   }\n-| ']'                          { RBRACKET   }\n-\n-| id as i\n-    {\n-      match Common.htab_search keyword_table i with\n-          Some tok -> tok\n-        | None ->\n-            if Hashtbl.mem reserved_table i\n-            then fail lexbuf \"reserved keyword\"\n-            else IDENT (i)\n-    }\n-\n-| (bin|hex|dec) as n           { LIT_INT (Int64.of_string n)       }\n-| ((bin|hex|dec) as n) 'u'     { LIT_UINT (Int64.of_string n)      }\n-| ((bin|hex|dec) as n)\n-  (mach_int_suf as s)\n-  {\n-    match Common.htab_search mach_suf_table s with\n-        Some tm -> LIT_MACH_INT (tm, Int64.of_string n)\n-      | None ->\n-          if Hashtbl.mem reserved_suf_table s\n-          then fail lexbuf \"reserved mach-int suffix\"\n-          else fail lexbuf \"bad mach-int suffix\"\n-  }\n-\n-| flo as n                     { LIT_FLOAT (float_of_string n)     }\n-| flo 'm'                      { fail lexbuf \"reseved mach-float suffix\" }\n-| (flo as n) (flo_suf as s)\n-  {\n-    match Common.htab_search mach_suf_table s with\n-        Some tm -> LIT_MACH_FLOAT (tm, float_of_string n)\n-      | None ->\n-          if Hashtbl.mem reserved_suf_table s\n-          then fail lexbuf \"reserved mach-float suffix\"\n-          else fail lexbuf \"bad mach-float suffix\"\n-  }\n-\n-| '\\''                         { char lexbuf                       }\n-| '\"'                          { let buf = Buffer.create 32 in\n-                                   str buf lexbuf                  }\n-| _ as c                       { let s = Char.escaped c in\n-                                   fail lexbuf (\"Bad character: \" ^ s) }\n-| eof                          { EOF        }\n-\n-and str buf = parse\n-    _ as ch\n-    {\n-      match ch with\n-          '\"' -> LIT_STR (Buffer.contents buf)\n-        | '\\\\' -> str_escape buf lexbuf\n-        | _ ->\n-            Buffer.add_char buf ch;\n-            let c = Char.code ch in\n-              if bounds 0 c 0x7f\n-              then str buf lexbuf\n-              else\n-                if ((c land 0b1110_0000) == 0b1100_0000)\n-                then ext_str 1 buf lexbuf\n-                else\n-                  if ((c land 0b1111_0000) == 0b1110_0000)\n-                  then ext_str 2 buf lexbuf\n-                  else\n-                    if ((c land 0b1111_1000) == 0b1111_0000)\n-                    then ext_str 3 buf lexbuf\n-                    else\n-                      if ((c land 0b1111_1100) == 0b1111_1000)\n-                      then ext_str 4 buf lexbuf\n-                      else\n-                        if ((c land 0b1111_1110) == 0b1111_1100)\n-                        then ext_str 5 buf lexbuf\n-                        else fail lexbuf \"bad initial utf-8 byte\"\n-    }\n-\n-and str_escape buf = parse\n-    'x' ((hexdig hexdig) as h)\n-  | 'u' ((hexdig hexdig hexdig hexdig) as h)\n-  | 'U'\n-      ((hexdig hexdig hexdig hexdig\n-        hexdig hexdig hexdig hexdig) as h)\n-      {\n-        Buffer.add_string buf (char_as_utf8 (int_of_string (\"0x\" ^ h)));\n-        str buf lexbuf\n-      }\n-  | 'n' { Buffer.add_char buf '\\n'; str buf lexbuf }\n-  | 'r' { Buffer.add_char buf '\\r'; str buf lexbuf }\n-  | 't' { Buffer.add_char buf '\\t'; str buf lexbuf }\n-  | '\\\\' { Buffer.add_char buf '\\\\'; str buf lexbuf }\n-  | '\"' { Buffer.add_char buf '\"'; str buf lexbuf }\n-  | _ as c { fail lexbuf (\"bad escape: \\\\\" ^ (Char.escaped c))  }\n-\n-\n-and ext_str n buf = parse\n-    _ as ch\n-      {\n-        let c = Char.code ch in\n-          if ((c land 0b1100_0000) == (0b1000_0000))\n-          then\n-            begin\n-              Buffer.add_char buf ch;\n-              if n = 1\n-              then str buf lexbuf\n-              else ext_str (n-1) buf lexbuf\n-            end\n-          else\n-            fail lexbuf \"bad trailing utf-8 byte\"\n-      }\n-\n-\n-and char = parse\n-    '\\\\' { char_escape lexbuf }\n-  | _ as c\n-    {\n-      let c = Char.code c in\n-        if bounds 0 c 0x7f\n-        then end_char c lexbuf\n-        else\n-          if ((c land 0b1110_0000) == 0b1100_0000)\n-          then ext_char 1 (c land 0b0001_1111) lexbuf\n-          else\n-            if ((c land 0b1111_0000) == 0b1110_0000)\n-            then ext_char 2 (c land 0b0000_1111) lexbuf\n-            else\n-              if ((c land 0b1111_1000) == 0b1111_0000)\n-              then ext_char 3 (c land 0b0000_0111) lexbuf\n-              else\n-                if ((c land 0b1111_1100) == 0b1111_1000)\n-                then ext_char 4 (c land 0b0000_0011) lexbuf\n-                else\n-                  if ((c land 0b1111_1110) == 0b1111_1100)\n-                  then ext_char 5 (c land 0b0000_0001) lexbuf\n-                  else fail lexbuf \"bad initial utf-8 byte\"\n-    }\n-\n-and char_escape = parse\n-    'x' ((hexdig hexdig) as h)\n-  | 'u' ((hexdig hexdig hexdig hexdig) as h)\n-  | 'U'\n-      ((hexdig hexdig hexdig hexdig\n-        hexdig hexdig hexdig hexdig) as h)\n-      {\n-        end_char (int_of_string (\"0x\" ^ h)) lexbuf\n-      }\n-  | 'n' { end_char (Char.code '\\n') lexbuf }\n-  | 'r' { end_char (Char.code '\\r') lexbuf }\n-  | 't' { end_char (Char.code '\\t') lexbuf }\n-  | '\\\\' { end_char (Char.code '\\\\') lexbuf }\n-  | '\\'' { end_char (Char.code '\\'') lexbuf }\n-  | _ as c { fail lexbuf (\"bad escape: \\\\\" ^ (Char.escaped c))  }\n-\n-\n-and ext_char n accum = parse\n-  _ as c\n-    {\n-      let c = Char.code c in\n-        if ((c land 0b1100_0000) == (0b1000_0000))\n-        then\n-          let accum = (accum lsl 6) lor (c land 0b0011_1111) in\n-            if n = 1\n-            then end_char accum lexbuf\n-            else ext_char (n-1) accum lexbuf\n-        else\n-          fail lexbuf \"bad trailing utf-8 byte\"\n-    }\n-\n-and end_char accum = parse\n-  '\\'' { LIT_CHAR accum }\n-\n-\n-and bracequote buf depth = parse\n-\n-  '\\\\' '{'                      { Buffer.add_char buf '{';\n-                                  bracequote buf depth lexbuf          }\n-\n-| '{'                           { Buffer.add_char buf '{';\n-                                  bracequote buf (depth+1) lexbuf      }\n-\n-| '\\\\' '}'                      { Buffer.add_char buf '}';\n-                                  bracequote buf depth lexbuf          }\n-\n-| '}'                           { if depth = 1\n-                                  then BRACEQUOTE (Buffer.contents buf)\n-                                  else\n-                                    begin\n-                                      Buffer.add_char buf '}';\n-                                      bracequote buf (depth-1) lexbuf\n-                                    end                                }\n-\n-| '\\\\' [^'{' '}']               { let s = Lexing.lexeme lexbuf in\n-                                    Buffer.add_string buf s;\n-                                    bracequote buf depth lexbuf        }\n-\n-\n-| [^'\\\\' '{' '}'] as c          {   Buffer.add_char buf c;\n-                                    if c = '\\n'\n-                                    then newline lexbuf;\n-                                    bracequote buf depth lexbuf        }\n-\n-\n-and comment depth = parse\n-\n-  '/' '*'                       { comment (depth+1) lexbuf      }\n-\n-| '*' '/'                       { if depth = 1\n-                                  then token lexbuf\n-                                  else comment (depth-1) lexbuf }\n-\n-| '\\n'                          { newline lexbuf;\n-                                  comment depth lexbuf           }\n-\n-| _                             { comment depth lexbuf           }\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "f961bd39dfbce1edd3f92bf149516273bc45cc54", "filename": "src/boot/fe/parser.ml", "status": "removed", "additions": 0, "deletions": 372, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fparser.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fparser.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fparser.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,372 +0,0 @@\n-\n-open Common;;\n-open Token;;\n-\n-(* Fundamental parser types and actions *)\n-\n-type get_mod_fn = (Ast.meta_pat\n-                   -> node_id\n-                     -> (crate_id, Ast.mod_items) Hashtbl.t\n-                       -> (filename * Ast.mod_items))\n-;;\n-\n-type pstate =\n-    { mutable pstate_peek : token;\n-      mutable pstate_ctxt : (string * pos) list;\n-      mutable pstate_rstr : bool;\n-      mutable pstate_depth: int;\n-      pstate_lexbuf       : Lexing.lexbuf;\n-      pstate_file         : filename;\n-      pstate_sess         : Session.sess;\n-      pstate_crate_cache  : (crate_id, Ast.mod_items) Hashtbl.t;\n-      pstate_get_mod      : get_mod_fn;\n-      pstate_get_cenv_tok : pstate -> Ast.ident -> token;\n-      pstate_infer_lib_name : (Ast.ident -> filename);\n-      pstate_required       : (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n-      pstate_required_syms  : (node_id, string) Hashtbl.t; }\n-;;\n-\n-let log (ps:pstate) = Session.log \"parse\"\n-  ps.pstate_sess.Session.sess_log_parse\n-  ps.pstate_sess.Session.sess_log_out\n-;;\n-\n-let iflog ps thunk =\n-  if ps.pstate_sess.Session.sess_log_parse\n-  then thunk ()\n-  else ()\n-;;\n-\n-let make_parser\n-    (crate_cache:(crate_id, Ast.mod_items) Hashtbl.t)\n-    (sess:Session.sess)\n-    (get_mod:get_mod_fn)\n-    (get_cenv_tok:pstate -> Ast.ident -> token)\n-    (infer_lib_name:Ast.ident -> filename)\n-    (required:(node_id, (required_lib * nabi_conv)) Hashtbl.t)\n-    (required_syms:(node_id, string) Hashtbl.t)\n-    (fname:string)\n-    : pstate =\n-  let lexbuf = Lexing.from_channel (open_in fname) in\n-  let spos = { lexbuf.Lexing.lex_start_p with Lexing.pos_fname = fname } in\n-  let cpos = { lexbuf.Lexing.lex_curr_p with Lexing.pos_fname = fname } in\n-    lexbuf.Lexing.lex_start_p <- spos;\n-    lexbuf.Lexing.lex_curr_p <- cpos;\n-    let first = Lexer.token lexbuf in\n-    let ps =\n-      { pstate_peek = first;\n-        pstate_ctxt = [];\n-        pstate_rstr = false;\n-        pstate_depth = 0;\n-        pstate_lexbuf = lexbuf;\n-        pstate_file = fname;\n-        pstate_sess = sess;\n-        pstate_crate_cache = crate_cache;\n-        pstate_get_mod = get_mod;\n-        pstate_get_cenv_tok = get_cenv_tok;\n-        pstate_infer_lib_name = infer_lib_name;\n-        pstate_required = required;\n-        pstate_required_syms = required_syms; }\n-    in\n-      iflog ps (fun _ -> log ps \"made parser for: %s\\n%!\" fname);\n-      ps\n-;;\n-\n-exception Parse_err of (pstate * string)\n-;;\n-\n-let lexpos (ps:pstate) : pos =\n-  let p = ps.pstate_lexbuf.Lexing.lex_start_p in\n-    (p.Lexing.pos_fname,\n-     p.Lexing.pos_lnum ,\n-     (p.Lexing.pos_cnum) - (p.Lexing.pos_bol))\n-;;\n-\n-let next_node_id (ps:pstate) : node_id =\n-  let r = ps.pstate_sess.Session.sess_node_id_counter in\n-  let id = !r in\n-    r := Node ((int_of_node id)+1);\n-    id\n-;;\n-\n-let next_opaque_id (ps:pstate) : opaque_id =\n-  let r = ps.pstate_sess.Session.sess_opaque_id_counter in\n-  let id = !r in\n-    r := Opaque ((int_of_opaque id)+1);\n-    id\n-;;\n-\n-let span\n-    (ps:pstate)\n-    (apos:pos)\n-    (bpos:pos)\n-    (x:'a)\n-    : 'a identified =\n-  let span = { lo = apos; hi = bpos } in\n-  let id = next_node_id ps in\n-    iflog ps (fun _ -> log ps \"span for node #%d: %s\"\n-                (int_of_node id) (Session.string_of_span span));\n-    htab_put ps.pstate_sess.Session.sess_spans id span;\n-    { node = x; id = id }\n-;;\n-\n-let decl p i =\n-  { Ast.decl_params = p;\n-    Ast.decl_item = i }\n-;;\n-\n-let spans\n-    (ps:pstate)\n-    (things:('a identified) array)\n-    (apos:pos)\n-    (thing:'a)\n-    : ('a identified) array =\n-  Array.append things [| (span ps apos (lexpos ps) thing) |]\n-;;\n-\n-(* \n- * The point of this is to make a new node_id entry for a node that is a\n- * \"copy\" of an lval returned from somewhere else. For example if you create\n- * a temp, the lval it returns can only be used in *one* place, for the\n- * node_id denotes the place that lval is first used; subsequent uses of\n- * 'the same' reference must clone_lval it into a new node_id. Otherwise\n- * there is trouble.\n- *)\n-\n-let clone_span\n-    (ps:pstate)\n-    (oldnode:'a identified)\n-    (newthing:'b)\n-    : 'b identified =\n-  let s = Hashtbl.find ps.pstate_sess.Session.sess_spans oldnode.id in\n-    span ps s.lo s.hi newthing\n-;;\n-\n-let rec clone_lval (ps:pstate) (lval:Ast.lval) : Ast.lval =\n-  match lval with\n-      Ast.LVAL_base nb ->\n-        let nnb = clone_span ps nb nb.node in\n-          Ast.LVAL_base nnb\n-    | Ast.LVAL_ext (base, ext) ->\n-        Ast.LVAL_ext ((clone_lval ps base), ext)\n-;;\n-\n-let clone_atom (ps:pstate) (atom:Ast.atom) : Ast.atom =\n-  match atom with\n-      Ast.ATOM_literal _ -> atom\n-    | Ast.ATOM_lval lv -> Ast.ATOM_lval (clone_lval ps lv)\n-    | Ast.ATOM_pexp _ -> bug () \"Parser.clone_atom on ATOM_pexp\"\n-;;\n-\n-let ctxt (n:string) (f:pstate -> 'a) (ps:pstate) : 'a =\n-  (ps.pstate_ctxt <- (n, lexpos ps) :: ps.pstate_ctxt;\n-   let res = f ps in\n-     ps.pstate_ctxt <- List.tl ps.pstate_ctxt;\n-     res)\n-;;\n-\n-let rstr (r:bool) (f:pstate -> 'a) (ps:pstate) : 'a =\n-  let prev = ps.pstate_rstr in\n-    (ps.pstate_rstr <- r;\n-     let res = f ps in\n-       ps.pstate_rstr <- prev;\n-       res)\n-;;\n-\n-let err (str:string) (ps:pstate) =\n-  (Parse_err (ps, (str)))\n-;;\n-\n-\n-let (slot_nil:Ast.slot) =\n-  { Ast.slot_mode = Ast.MODE_local;\n-    Ast.slot_ty = Some Ast.TY_nil }\n-;;\n-\n-let (slot_auto:Ast.slot) =\n-  { Ast.slot_mode = Ast.MODE_local;\n-    Ast.slot_ty = None }\n-;;\n-\n-let build_tmp\n-    (ps:pstate)\n-    (slot:Ast.slot)\n-    (apos:pos)\n-    (bpos:pos)\n-    : (temp_id * Ast.lval * Ast.stmt) =\n-  let r = ps.pstate_sess.Session.sess_temp_id_counter in\n-  let id = !r in\n-    r := Temp ((int_of_temp id)+1);\n-    iflog ps\n-      (fun _ -> log ps \"building temporary %d\" (int_of_temp id));\n-    let decl = Ast.DECL_slot (Ast.KEY_temp id, (span ps apos bpos slot)) in\n-    let declstmt = span ps apos bpos (Ast.STMT_decl decl) in\n-    let tmp = Ast.LVAL_base (span ps apos bpos (Ast.BASE_temp id)) in\n-      (id, tmp, declstmt)\n-;;\n-\n-(* Simple helpers *)\n-\n-(* FIXME (issue #71): please rename these, they make eyes bleed. *)\n-\n-let arr (ls:'a list) : 'a array = Array.of_list ls ;;\n-let arl (ls:'a list) : 'a array = Array.of_list (List.rev ls) ;;\n-let arj (ar:('a array array)) = Array.concat (Array.to_list ar) ;;\n-let arj1st (pairs:(('a array) * 'b) array) : (('a array) * 'b array) =\n-  let (az, bz) = List.split (Array.to_list pairs) in\n-    (Array.concat az, Array.of_list bz)\n-\n-\n-(* Bottom-most parser actions. *)\n-\n-let peek (ps:pstate) : token =\n-  iflog ps\n-    begin\n-      fun _ ->\n-        log ps \"peeking at: %s     // %s\"\n-          (string_of_tok ps.pstate_peek)\n-          (match ps.pstate_ctxt with\n-               (s, _) :: _ -> s\n-             | _ -> \"<empty>\")\n-    end;\n-  ps.pstate_peek\n-;;\n-\n-\n-let bump (ps:pstate) : unit =\n-  begin\n-    iflog ps (fun _ -> log ps \"bumping past: %s\"\n-                (string_of_tok ps.pstate_peek));\n-    ps.pstate_peek <- Lexer.token ps.pstate_lexbuf\n-  end\n-;;\n-\n-let bump_bracequote (ps:pstate) : unit =\n-  begin\n-    assert (ps.pstate_peek = LBRACE);\n-    iflog ps (fun _ -> log ps \"bumping past: %s\"\n-                (string_of_tok ps.pstate_peek));\n-    let buf = Buffer.create 32 in\n-      ps.pstate_peek <- Lexer.bracequote buf 1 ps.pstate_lexbuf\n-  end\n-;;\n-\n-\n-let expect (ps:pstate) (t:token) : unit =\n-  let p = peek ps in\n-    if p == t\n-    then bump ps\n-    else\n-      let msg = (\"Expected '\" ^ (string_of_tok t) ^\n-                   \"', found '\" ^ (string_of_tok p ) ^ \"'\") in\n-        raise (Parse_err (ps, msg))\n-;;\n-\n-let unexpected (ps:pstate) =\n-  err (\"Unexpected token '\" ^ (string_of_tok (peek ps)) ^ \"'\") ps\n-;;\n-\n-\n-\n-(* Parser combinators. *)\n-\n-let one_or_more\n-    (sep:token)\n-    (prule:pstate -> 'a)\n-    (ps:pstate)\n-    : 'a array =\n-  let accum = ref [prule ps] in\n-    while peek ps == sep\n-    do\n-      bump ps;\n-      accum := (prule ps) :: !accum\n-    done;\n-    arl !accum\n-;;\n-\n-let bracketed_seq\n-    (mandatory:int)\n-    (bra:token)\n-    (ket:token)\n-    (sepOpt:token option)\n-    (prule:pstate -> 'a)\n-    (ps:pstate)\n-    : 'a array =\n-  expect ps bra;\n-  let accum = ref [] in\n-  let dosep _ =\n-    (match sepOpt with\n-         None -> ()\n-       | Some tok ->\n-           if (!accum = [])\n-           then ()\n-           else expect ps tok)\n-  in\n-    while mandatory > List.length (!accum) do\n-      dosep ();\n-      accum := (prule ps) :: (!accum)\n-    done;\n-    while (not (peek ps = ket))\n-    do\n-      dosep ();\n-      accum := (prule ps) :: !accum\n-    done;\n-    expect ps ket;\n-    arl !accum\n-;;\n-\n-\n-let bracketed_zero_or_more\n-    (bra:token)\n-    (ket:token)\n-    (sepOpt:token option)\n-    (prule:pstate -> 'a)\n-    (ps:pstate)\n-    : 'a array =\n-  bracketed_seq 0 bra ket sepOpt (ctxt \"bracketed_seq\" prule) ps\n-;;\n-\n-\n-let paren_comma_list\n-    (prule:pstate -> 'a)\n-    (ps:pstate)\n-    : 'a array =\n-  bracketed_zero_or_more LPAREN RPAREN (Some COMMA) prule ps\n-;;\n-\n-let bracketed_one_or_more\n-    (bra:token)\n-    (ket:token)\n-    (sepOpt:token option)\n-    (prule:pstate -> 'a)\n-    (ps:pstate)\n-    : 'a array =\n-  bracketed_seq 1 bra ket sepOpt (ctxt \"bracketed_seq\" prule) ps\n-;;\n-\n-let bracketed_two_or_more\n-    (bra:token)\n-    (ket:token)\n-    (sepOpt:token option)\n-    (prule:pstate -> 'a)\n-    (ps:pstate)\n-    : 'a array =\n-  bracketed_seq 2 bra ket sepOpt (ctxt \"bracketed_seq\" prule) ps\n-;;\n-\n-\n-let bracketed (bra:token) (ket:token) (prule:pstate -> 'a) (ps:pstate) : 'a =\n-  expect ps bra;\n-  let res = ctxt \"bracketed\" prule ps in\n-    expect ps ket;\n-    res\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "ed36926dfb788683ba580f0d5e10933b254a2059", "filename": "src/boot/fe/pexp.ml", "status": "removed", "additions": 0, "deletions": 1441, "changes": 1441, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,1441 +0,0 @@\n-\n-open Common;;\n-open Token;;\n-open Parser;;\n-\n-(* NB: pexps (parser-expressions) are only used transiently during\n- * parsing, static-evaluation and syntax-expansion.  They're desugared\n- * into the general \"item\" AST and/or evaluated as part of the\n- * outermost \"cexp\" expressions. Expressions that can show up in source\n- * correspond to this loose grammar and have a wide-ish flexibility in\n- * *theoretical* composition; only subsets of those compositions are\n- * legal in various AST contexts.\n- * \n- * Desugaring on the fly is unfortunately complicated enough to require\n- * -- or at least \"make much more convenient\" -- this two-pass\n- * routine.\n- *)\n-\n-(* Pexp grammar. Includes names, idents, types, constrs, binops and unops,\n-   etc. *)\n-\n-let parse_ident (ps:pstate) : Ast.ident =\n-  match peek ps with\n-      IDENT id -> (bump ps; id)\n-    (* Decay IDX tokens to identifiers if they occur ousdide name paths. *)\n-    | IDX i -> (bump ps; string_of_tok (IDX i))\n-    | _ -> raise (unexpected ps)\n-;;\n-\n-(* Enforces the restricted pexp grammar when applicable (e.g. after \"bind\") *)\n-let check_rstr_start (ps:pstate) : 'a =\n-  if (ps.pstate_rstr) then\n-    match peek ps with\n-        IDENT _ | LPAREN -> ()\n-      | _ -> raise (unexpected ps)\n-;;\n-\n-let rec parse_name_component (ps:pstate) : Ast.name_component =\n-  match peek ps with\n-      IDENT id ->\n-        (bump ps;\n-         match peek ps with\n-             LBRACKET ->\n-               let tys =\n-                 ctxt \"name_component: apply\"\n-                   (bracketed_one_or_more LBRACKET RBRACKET\n-                      (Some COMMA) parse_ty) ps\n-               in\n-                 Ast.COMP_app (id, tys)\n-           | _ -> Ast.COMP_ident id)\n-\n-    | IDX i ->\n-        bump ps;\n-        Ast.COMP_idx i\n-    | _ -> raise (unexpected ps)\n-\n-and parse_name_base (ps:pstate) : Ast.name_base =\n-  match peek ps with\n-      IDENT i ->\n-        (bump ps;\n-         match peek ps with\n-             LBRACKET ->\n-               let tys =\n-                 ctxt \"name_base: apply\"\n-                   (bracketed_one_or_more LBRACKET RBRACKET\n-                      (Some COMMA) parse_ty) ps\n-               in\n-                 Ast.BASE_app (i, tys)\n-           | _ -> Ast.BASE_ident i)\n-    | _ -> raise (unexpected ps)\n-\n-and parse_name_ext (ps:pstate) (base:Ast.name) : Ast.name =\n-  match peek ps with\n-      DOT ->\n-        bump ps;\n-        let comps = one_or_more DOT parse_name_component ps in\n-          Array.fold_left (fun x y -> Ast.NAME_ext (x, y)) base comps\n-    | _ -> base\n-\n-\n-and parse_name (ps:pstate) : Ast.name =\n-  let base = Ast.NAME_base (parse_name_base ps) in\n-  let name = parse_name_ext ps base in\n-    if Ast.sane_name name\n-    then name\n-    else raise (err \"malformed name\" ps)\n-\n-and parse_carg_base (ps:pstate) : Ast.carg_base =\n-  match peek ps with\n-      STAR -> bump ps; Ast.BASE_formal\n-    | _ -> Ast.BASE_named (parse_name_base ps)\n-\n-and parse_carg (ps:pstate) : Ast.carg =\n-  match peek ps with\n-      IDENT _ | STAR ->\n-        begin\n-          let base = Ast.CARG_base (parse_carg_base ps) in\n-          let path =\n-            match peek ps with\n-                DOT ->\n-                  bump ps;\n-                  let comps = one_or_more DOT parse_name_component ps in\n-                    Array.fold_left\n-                      (fun x y -> Ast.CARG_ext (x, y)) base comps\n-              | _ -> base\n-          in\n-            Ast.CARG_path path\n-        end\n-    | _ ->\n-        Ast.CARG_lit (parse_lit ps)\n-\n-\n-and parse_constraint (ps:pstate) : Ast.constr =\n-  match peek ps with\n-\n-      (*\n-       * NB: A constraint *looks* a lot like an EXPR_call, but is restricted\n-       * syntactically: the constraint name needs to be a name (not an lval)\n-       * and the constraint args all need to be cargs, which are similar to\n-       * names but can begin with the 'formal' base anchor '*'.\n-       *)\n-\n-      IDENT _ ->\n-        let n = ctxt \"constraint: name\" parse_name ps in\n-        let args = ctxt \"constraint: args\"\n-          (bracketed_zero_or_more\n-             LPAREN RPAREN (Some COMMA)\n-             parse_carg) ps\n-        in\n-          { Ast.constr_name = n;\n-            Ast.constr_args = args }\n-    | _ -> raise (unexpected ps)\n-\n-\n-and parse_constrs (ps:pstate) : Ast.constrs =\n-  ctxt \"state: constraints\" (one_or_more COMMA parse_constraint) ps\n-\n-and parse_optional_trailing_constrs (ps:pstate) : Ast.constrs =\n-  match peek ps with\n-      COLON -> (bump ps; parse_constrs ps)\n-    | _ -> [| |]\n-\n-and parse_layer (ps:pstate) : Ast.layer =\n-  match peek ps with\n-      STATE -> bump ps; Ast.LAYER_state\n-    | GC -> bump ps; Ast.LAYER_gc\n-    |  _ -> Ast.LAYER_value\n-\n-and parse_auth (ps:pstate) : Ast.auth =\n-  match peek ps with\n-    | UNSAFE -> bump ps; Ast.AUTH_unsafe\n-    | _ -> raise (unexpected ps)\n-\n-and parse_mutability (ps:pstate) : Ast.mutability =\n-  match peek ps with\n-      MUTABLE ->\n-        begin\n-          (* HACK: ignore \"mutable?\" *)\n-          bump ps;\n-          match peek ps with\n-              QUES -> bump ps; Ast.MUT_immutable\n-            | _ -> Ast.MUT_mutable\n-        end\n-    | _ -> Ast.MUT_immutable\n-\n-and parse_ty_fn\n-    (ps:pstate)\n-    : (Ast.ty_fn * Ast.ident option) =\n-  match peek ps with\n-      FN | ITER ->\n-        let is_iter = (peek ps) = ITER in\n-          bump ps;\n-          let ident =\n-            match peek ps with\n-                IDENT i -> bump ps; Some i\n-              | _ -> None\n-          in\n-          let in_slots =\n-            match peek ps with\n-                _ ->\n-                  bracketed_zero_or_more LPAREN RPAREN (Some COMMA)\n-                    (parse_slot_and_optional_ignored_ident true) ps\n-          in\n-          let out_slot =\n-            match peek ps with\n-                RARROW -> (bump ps; parse_slot false ps)\n-              | _ -> slot_nil\n-          in\n-          let constrs = parse_optional_trailing_constrs ps in\n-          let tsig = { Ast.sig_input_slots = in_slots;\n-                       Ast.sig_input_constrs = constrs;\n-                       Ast.sig_output_slot = out_slot; }\n-          in\n-          let taux = { Ast.fn_is_iter = is_iter; }\n-          in\n-          let tfn = (tsig, taux) in\n-            (tfn, ident)\n-\n-    | _ -> raise (unexpected ps)\n-\n-and check_dup_rec_labels ps labels =\n-  arr_check_dups labels\n-    (fun l _ ->\n-       raise (err (Printf.sprintf\n-                     \"duplicate record label: %s\" l) ps));\n-\n-\n-and parse_atomic_ty (ps:pstate) : Ast.ty =\n-  match peek ps with\n-\n-      BOOL ->\n-        bump ps;\n-        Ast.TY_bool\n-\n-    | INT ->\n-        bump ps;\n-        Ast.TY_int\n-\n-    | UINT ->\n-        bump ps;\n-        Ast.TY_uint\n-\n-    | CHAR ->\n-        bump ps;\n-        Ast.TY_char\n-\n-    | STR ->\n-        bump ps;\n-        Ast.TY_str\n-\n-    | ANY ->\n-        bump ps;\n-        Ast.TY_any\n-\n-    | TASK ->\n-        bump ps;\n-        Ast.TY_task\n-\n-    | CHAN ->\n-        bump ps;\n-        Ast.TY_chan (bracketed LBRACKET RBRACKET parse_ty ps)\n-\n-    | PORT ->\n-        bump ps;\n-        Ast.TY_port (bracketed LBRACKET RBRACKET parse_ty ps)\n-\n-    | VEC ->\n-        bump ps;\n-        Ast.TY_vec (bracketed LBRACKET RBRACKET parse_ty ps)\n-\n-    | IDENT _ -> Ast.TY_named (parse_name ps)\n-\n-    | REC ->\n-        bump ps;\n-        let parse_rec_entry ps =\n-          let (ty, ident) = parse_ty_and_ident ps in\n-            (ident, ty)\n-        in\n-        let entries = paren_comma_list parse_rec_entry ps in\n-        let labels = Array.map (fun (l, _) -> l) entries in\n-          begin\n-            check_dup_rec_labels ps labels;\n-            Ast.TY_rec entries\n-          end\n-\n-    | TUP ->\n-        bump ps;\n-        let tys = paren_comma_list parse_ty ps in\n-          Ast.TY_tup tys\n-\n-    | MACH m ->\n-        bump ps;\n-        Ast.TY_mach m\n-\n-    | STATE | GC | UNSAFE | OBJ | FN | ITER ->\n-        let layer = parse_layer ps in\n-          begin\n-            match peek ps with\n-                OBJ ->\n-                  bump ps;\n-                  let methods = Hashtbl.create 0 in\n-                  let parse_method ps =\n-                    let (tfn, ident) = parse_ty_fn ps in\n-                      expect ps SEMI;\n-                      match ident with\n-                          None ->\n-                            raise (err (Printf.sprintf\n-                                          \"missing method identifier\") ps)\n-                        | Some i -> htab_put methods i tfn\n-                  in\n-                    ignore (bracketed_zero_or_more LBRACE RBRACE\n-                              None parse_method ps);\n-                    Ast.TY_obj (layer, methods)\n-\n-              | FN | ITER ->\n-                  if layer <> Ast.LAYER_value\n-                  then raise (err \"layer specified for fn or iter\" ps);\n-                  Ast.TY_fn (fst (parse_ty_fn ps))\n-              | _ -> raise (unexpected ps)\n-          end\n-\n-    | AT ->\n-        bump ps;\n-        Ast.TY_box (parse_ty ps)\n-\n-    | MUTABLE ->\n-        bump ps;\n-        begin\n-          (* HACK: ignore \"mutable?\" *)\n-          match peek ps with\n-              QUES -> bump ps; parse_ty ps\n-            | _ -> Ast.TY_mutable (parse_ty ps)\n-        end\n-\n-    | LPAREN ->\n-        begin\n-          bump ps;\n-          match peek ps with\n-              RPAREN ->\n-                bump ps;\n-                Ast.TY_nil\n-            | _ ->\n-                let t = parse_ty ps in\n-                  expect ps RPAREN;\n-                  t\n-        end\n-\n-    | _ -> raise (unexpected ps)\n-\n-and flag (ps:pstate) (tok:token) : bool =\n-  if peek ps = tok\n-  then (bump ps; true)\n-  else false\n-\n-and parse_slot (aliases_ok:bool) (ps:pstate) : Ast.slot =\n-  let mode =\n-  match (peek ps, aliases_ok) with\n-      (AND, true) -> bump ps; Ast.MODE_alias\n-    | (AND, false) -> raise (err \"alias slot in prohibited context\" ps)\n-    | _ -> Ast.MODE_local\n-  in\n-  let ty = parse_ty ps in\n-    { Ast.slot_mode = mode;\n-      Ast.slot_ty = Some ty }\n-\n-and parse_slot_and_ident\n-    (aliases_ok:bool)\n-    (ps:pstate)\n-    : (Ast.slot * Ast.ident) =\n-  let slot = ctxt \"slot and ident: slot\" (parse_slot aliases_ok) ps in\n-  let ident = ctxt \"slot and ident: ident\" parse_ident ps in\n-    (slot, ident)\n-\n-and parse_ty_and_ident\n-    (ps:pstate)\n-    : (Ast.ty * Ast.ident) =\n-  let ty = ctxt \"ty and ident: ty\" parse_ty ps in\n-  let ident = ctxt \"ty and ident: ident\" parse_ident ps in\n-    (ty, ident)\n-\n-and parse_slot_and_optional_ignored_ident\n-    (aliases_ok:bool)\n-    (ps:pstate)\n-    : Ast.slot =\n-  let slot = parse_slot aliases_ok ps in\n-    begin\n-      match peek ps with\n-          IDENT _ -> bump ps\n-        | _ -> ()\n-    end;\n-    slot\n-\n-and parse_identified_slot\n-    (aliases_ok:bool)\n-    (ps:pstate)\n-    : Ast.slot identified =\n-  let apos = lexpos ps in\n-  let slot = parse_slot aliases_ok ps in\n-  let bpos = lexpos ps in\n-    span ps apos bpos slot\n-\n-and parse_constrained_ty (ps:pstate) : Ast.ty =\n-  let base = ctxt \"ty: base\" parse_atomic_ty ps in\n-    match peek ps with\n-        COLON ->\n-          bump ps;\n-          let constrs = ctxt \"ty: constrs\" parse_constrs ps in\n-            Ast.TY_constrained (base, constrs)\n-\n-      | _ -> base\n-\n-and parse_ty (ps:pstate) : Ast.ty =\n-  parse_constrained_ty ps\n-\n-\n-and parse_rec_input (ps:pstate)\n-    : (Ast.ident * Ast.mutability * Ast.pexp) =\n-  let mutability = parse_mutability ps in\n-  let lab = (ctxt \"rec input: label\" parse_ident ps) in\n-    match peek ps with\n-        EQ ->\n-          bump ps;\n-          let pexp = ctxt \"rec input: expr\" parse_pexp ps in\n-            (lab, mutability, pexp)\n-      | _ -> raise (unexpected ps)\n-\n-\n-and parse_rec_body (ps:pstate) : Ast.pexp' =\n-  begin\n-    expect ps LPAREN;\n-    match peek ps with\n-        RPAREN -> Ast.PEXP_rec ([||], None)\n-      | WITH -> raise (err \"empty record extension\" ps)\n-      | _ ->\n-          let inputs = one_or_more COMMA parse_rec_input ps in\n-          let labels = Array.map (fun (l, _, _) -> l) inputs in\n-            begin\n-              check_dup_rec_labels ps labels;\n-              match peek ps with\n-                  RPAREN -> (bump ps; Ast.PEXP_rec (inputs, None))\n-                | WITH ->\n-                    begin\n-                      bump ps;\n-                      let base =\n-                        ctxt \"rec input: extension base\"\n-                          parse_pexp ps\n-                      in\n-                        expect ps RPAREN;\n-                        Ast.PEXP_rec (inputs, Some base)\n-                    end\n-                | _ -> raise (err \"expected 'with' or ')'\" ps)\n-            end\n-  end\n-\n-\n-and parse_lit (ps:pstate) : Ast.lit =\n-  match peek ps with\n-      LIT_INT i -> (bump ps; Ast.LIT_int i)\n-    | LIT_UINT i -> (bump ps; Ast.LIT_uint i)\n-    | LIT_MACH_INT (tm, i) -> (bump ps; Ast.LIT_mach_int (tm, i))\n-    | LIT_CHAR c -> (bump ps; Ast.LIT_char c)\n-    | LIT_BOOL b -> (bump ps; Ast.LIT_bool b)\n-    | _ -> raise (unexpected ps)\n-\n-\n-and parse_bottom_pexp (ps:pstate) : Ast.pexp =\n-  check_rstr_start ps;\n-  let apos = lexpos ps in\n-  match peek ps with\n-\n-      AT ->\n-        bump ps;\n-        let mutability = parse_mutability ps in\n-        let inner = parse_pexp ps in\n-        let bpos = lexpos ps in\n-          span ps apos bpos (Ast.PEXP_box (mutability, inner))\n-\n-    | TUP ->\n-        bump ps;\n-        let pexps =\n-          ctxt \"paren pexps(s)\" (rstr false parse_mutable_and_pexp_list) ps\n-        in\n-        let bpos = lexpos ps in\n-          span ps apos bpos (Ast.PEXP_tup pexps)\n-\n-    | REC ->\n-          bump ps;\n-          let body = ctxt \"rec pexp: rec body\" parse_rec_body ps in\n-          let bpos = lexpos ps in\n-            span ps apos bpos body\n-\n-    | VEC ->\n-        bump ps;\n-        let pexps =\n-          ctxt \"paren pexps(s)\" (rstr false parse_mutable_and_pexp_list) ps\n-        in\n-        let mutability = ref Ast.MUT_immutable in\n-        let pexps =\n-          Array.mapi\n-            begin\n-              fun i (mut, e) ->\n-                if i = 0\n-                then\n-                  mutability := mut\n-                else\n-                  if mut <> Ast.MUT_immutable\n-                  then\n-                    raise\n-                      (err \"'mutable' keyword after first vec element\" ps);\n-                e\n-            end\n-            pexps\n-        in\n-        let bpos = lexpos ps in\n-          span ps apos bpos (Ast.PEXP_vec (!mutability, pexps))\n-\n-\n-    | LIT_STR s ->\n-        bump ps;\n-        let bpos = lexpos ps in\n-          span ps apos bpos (Ast.PEXP_str s)\n-\n-    | PORT ->\n-        begin\n-            bump ps;\n-            expect ps LPAREN;\n-            expect ps RPAREN;\n-            let bpos = lexpos ps in\n-              span ps apos bpos (Ast.PEXP_port)\n-        end\n-\n-    | CHAN ->\n-        begin\n-            bump ps;\n-            let port =\n-              match peek ps with\n-                  LPAREN ->\n-                    begin\n-                      bump ps;\n-                      match peek ps with\n-                          RPAREN -> (bump ps; None)\n-                        | _ ->\n-                            let lv = parse_pexp ps in\n-                              expect ps RPAREN;\n-                              Some lv\n-                    end\n-                | _ -> raise (unexpected ps)\n-            in\n-            let bpos = lexpos ps in\n-              span ps apos bpos (Ast.PEXP_chan port)\n-        end\n-\n-    | SPAWN ->\n-        bump ps;\n-        let domain =\n-          match peek ps with\n-              THREAD -> bump ps; Ast.DOMAIN_thread\n-            | _ -> Ast.DOMAIN_local\n-        in\n-          (* Spawns either have an explicit literal string for the spawned\n-             task's name, or the task is named as the entry call\n-             expression. *)\n-        let explicit_name =\n-          match peek ps with\n-              LIT_STR s -> bump ps; Some s\n-            | _ -> None\n-        in\n-        let pexp =\n-          ctxt \"spawn [domain] [name] pexp: init call\" parse_pexp ps\n-        in\n-        let bpos = lexpos ps in\n-        let name =\n-          match explicit_name with\n-              Some s -> s\n-                (* FIXME: string_of_span returns a string like\n-                   \"./driver.rs:10:16 - 11:52\", not the actual text at those\n-                   characters *)\n-            | None -> Session.string_of_span { lo = apos; hi = bpos }\n-        in\n-          span ps apos bpos (Ast.PEXP_spawn (domain, name, pexp))\n-\n-    | BIND ->\n-        let apos = lexpos ps in\n-          begin\n-            bump ps;\n-            let pexp = ctxt \"bind pexp: function\" (rstr true parse_pexp) ps in\n-            let args =\n-              ctxt \"bind args\"\n-                (paren_comma_list parse_bind_arg) ps\n-            in\n-            let bpos = lexpos ps in\n-              span ps apos bpos (Ast.PEXP_bind (pexp, args))\n-          end\n-\n-    | IDENT i ->\n-        begin\n-          bump ps;\n-          match peek ps with\n-              LBRACKET ->\n-                begin\n-                  let tys =\n-                    ctxt \"apply-type expr\"\n-                      (bracketed_one_or_more LBRACKET RBRACKET\n-                         (Some COMMA) parse_ty) ps\n-                  in\n-                  let bpos = lexpos ps in\n-                    span ps apos bpos\n-                      (Ast.PEXP_lval (Ast.PLVAL_base (Ast.BASE_app (i, tys))))\n-                end\n-\n-            | _ ->\n-                begin\n-                  let bpos = lexpos ps in\n-                    span ps apos bpos\n-                      (Ast.PEXP_lval (Ast.PLVAL_base (Ast.BASE_ident i)))\n-                end\n-        end\n-\n-\n-    | STAR ->\n-        bump ps;\n-        let inner = parse_pexp ps in\n-        let bpos = lexpos ps in\n-          span ps apos bpos (Ast.PEXP_lval (Ast.PLVAL_ext_deref inner))\n-\n-    | POUND ->\n-        bump ps;\n-        let name = parse_name ps in\n-        let args =\n-          match peek ps with\n-              LPAREN ->\n-                parse_pexp_list ps\n-            | _ -> [| |]\n-        in\n-        let str =\n-          match peek ps with\n-              LBRACE ->\n-                begin\n-                  bump_bracequote ps;\n-                  match peek ps with\n-                      BRACEQUOTE s -> bump ps; Some s\n-                    | _ -> raise (unexpected ps)\n-                end\n-            | _ -> None\n-        in\n-        let bpos = lexpos ps in\n-          span ps apos bpos\n-            (Ast.PEXP_custom (name, args, str))\n-\n-    | LPAREN ->\n-        begin\n-          bump ps;\n-          match peek ps with\n-              RPAREN ->\n-                bump ps;\n-                let bpos = lexpos ps in\n-                  span ps apos bpos (Ast.PEXP_lit Ast.LIT_nil)\n-            | _ ->\n-                let pexp = parse_pexp ps in\n-                  expect ps RPAREN;\n-                  pexp\n-        end\n-\n-    | _ ->\n-        let lit = parse_lit ps in\n-        let bpos = lexpos ps in\n-          span ps apos bpos (Ast.PEXP_lit lit)\n-\n-\n-and parse_bind_arg (ps:pstate) : Ast.pexp option =\n-  match peek ps with\n-      UNDERSCORE -> (bump ps; None)\n-    | _ -> Some (parse_pexp ps)\n-\n-\n-and parse_ext_pexp (ps:pstate) (pexp:Ast.pexp) : Ast.pexp =\n-  let apos = lexpos ps in\n-    match peek ps with\n-        LPAREN ->\n-          if ps.pstate_rstr\n-          then pexp\n-          else\n-            let args = parse_pexp_list ps in\n-            let bpos = lexpos ps in\n-            let ext = span ps apos bpos (Ast.PEXP_call (pexp, args)) in\n-              parse_ext_pexp ps ext\n-\n-      | DOT ->\n-          begin\n-            bump ps;\n-            let ext =\n-              match peek ps with\n-                  LPAREN ->\n-                    bump ps;\n-                    let rhs = rstr false parse_pexp ps in\n-                      expect ps RPAREN;\n-                      let bpos = lexpos ps in\n-                        span ps apos bpos\n-                          (Ast.PEXP_lval (Ast.PLVAL_ext_pexp (pexp, rhs)))\n-                | _ ->\n-                    let rhs = parse_name_component ps in\n-                    let bpos = lexpos ps in\n-                      span ps apos bpos\n-                        (Ast.PEXP_lval (Ast.PLVAL_ext_name (pexp, rhs)))\n-            in\n-              parse_ext_pexp ps ext\n-          end\n-\n-      | _ -> pexp\n-\n-\n-and parse_negation_pexp (ps:pstate) : Ast.pexp =\n-    let apos = lexpos ps in\n-      match peek ps with\n-          NOT ->\n-            bump ps;\n-            let rhs = ctxt \"negation pexp\" parse_negation_pexp ps in\n-            let bpos = lexpos ps in\n-              span ps apos bpos (Ast.PEXP_unop (Ast.UNOP_not, rhs))\n-\n-        | TILDE ->\n-            bump ps;\n-            let rhs = ctxt \"negation pexp\" parse_negation_pexp ps in\n-            let bpos = lexpos ps in\n-              span ps apos bpos (Ast.PEXP_unop (Ast.UNOP_bitnot, rhs))\n-\n-        | MINUS ->\n-            bump ps;\n-            let rhs = ctxt \"negation pexp\" parse_negation_pexp ps in\n-            let bpos = lexpos ps in\n-              span ps apos bpos (Ast.PEXP_unop (Ast.UNOP_neg, rhs))\n-\n-        | _ ->\n-            let lhs = parse_bottom_pexp ps in\n-              parse_ext_pexp ps lhs\n-\n-\n-(* Binops are all left-associative,                *)\n-(* so we factor out some of the parsing code here. *)\n-and binop_build\n-    (ps:pstate)\n-    (name:string)\n-    (apos:pos)\n-    (rhs_parse_fn:pstate -> Ast.pexp)\n-    (lhs:Ast.pexp)\n-    (step_fn:Ast.pexp -> Ast.pexp)\n-    (op:Ast.binop)\n-    : Ast.pexp =\n-  bump ps;\n-  let rhs = (ctxt (name ^ \" rhs\") rhs_parse_fn ps) in\n-  let bpos = lexpos ps in\n-  let node = span ps apos bpos (Ast.PEXP_binop (op, lhs, rhs)) in\n-    step_fn node\n-\n-\n-and parse_factor_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"factor pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_negation_pexp ps in\n-  let build = binop_build ps name apos parse_negation_pexp in\n-  let rec step accum =\n-    match peek ps with\n-        STAR    -> build accum step Ast.BINOP_mul\n-      | SLASH   -> build accum step Ast.BINOP_div\n-      | PERCENT -> build accum step Ast.BINOP_mod\n-      | _       -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_term_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"term pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_factor_pexp ps in\n-  let build = binop_build ps name apos parse_factor_pexp in\n-  let rec step accum =\n-    match peek ps with\n-        PLUS  -> build accum step Ast.BINOP_add\n-      | MINUS -> build accum step Ast.BINOP_sub\n-      | _     -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_shift_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"shift pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_term_pexp ps in\n-  let build = binop_build ps name apos parse_term_pexp in\n-  let rec step accum =\n-    match peek ps with\n-        LSL -> build accum step Ast.BINOP_lsl\n-      | LSR -> build accum step Ast.BINOP_lsr\n-      | ASR -> build accum step Ast.BINOP_asr\n-      | _   -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_and_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"and pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_shift_pexp ps in\n-  let build = binop_build ps name apos parse_shift_pexp in\n-  let rec step accum =\n-    match peek ps with\n-        AND -> build accum step Ast.BINOP_and\n-      | _   -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_xor_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"xor pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_and_pexp ps in\n-  let build = binop_build ps name apos parse_and_pexp in\n-  let rec step accum =\n-    match peek ps with\n-        CARET -> build accum step Ast.BINOP_xor\n-      | _     -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_or_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"or pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_xor_pexp ps in\n-  let build = binop_build ps name apos parse_xor_pexp in\n-  let rec step accum =\n-    match peek ps with\n-        OR -> build accum step Ast.BINOP_or\n-      | _  -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_as_pexp (ps:pstate) : Ast.pexp =\n-  let apos = lexpos ps in\n-  let pexp = ctxt \"as pexp\" parse_or_pexp ps in\n-  let rec step accum =\n-    match peek ps with\n-        AS ->\n-          bump ps;\n-          let tapos = lexpos ps in\n-          let t = parse_ty ps in\n-          let bpos = lexpos ps in\n-          let t = span ps tapos bpos t in\n-          let node =\n-            span ps apos bpos\n-              (Ast.PEXP_unop ((Ast.UNOP_cast t), accum))\n-          in\n-            step node\n-\n-      | _ -> accum\n-  in\n-    step pexp\n-\n-\n-and parse_relational_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"relational pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_as_pexp ps in\n-  let build = binop_build ps name apos parse_as_pexp in\n-  let rec step accum =\n-    match peek ps with\n-        LT -> build accum step Ast.BINOP_lt\n-      | LE -> build accum step Ast.BINOP_le\n-      | GE -> build accum step Ast.BINOP_ge\n-      | GT -> build accum step Ast.BINOP_gt\n-      | _  -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_equality_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"equality pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_relational_pexp ps in\n-  let build = binop_build ps name apos parse_relational_pexp in\n-  let rec step accum =\n-    match peek ps with\n-        EQEQ -> build accum step Ast.BINOP_eq\n-      | NE   -> build accum step Ast.BINOP_ne\n-      | _    -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_andand_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"andand pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_equality_pexp ps in\n-  let rec step accum =\n-    match peek ps with\n-        ANDAND ->\n-          bump ps;\n-          let rhs = parse_equality_pexp ps in\n-          let bpos = lexpos ps in\n-          let node = span ps apos bpos (Ast.PEXP_lazy_and (accum, rhs)) in\n-            step node\n-\n-      | _   -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_oror_pexp (ps:pstate) : Ast.pexp =\n-  let name = \"oror pexp\" in\n-  let apos = lexpos ps in\n-  let lhs = ctxt (name ^ \" lhs\") parse_andand_pexp ps in\n-  let rec step accum =\n-    match peek ps with\n-        OROR ->\n-          bump ps;\n-          let rhs = parse_andand_pexp ps in\n-          let bpos = lexpos ps in\n-          let node = span ps apos bpos (Ast.PEXP_lazy_or (accum, rhs)) in\n-            step node\n-\n-      | _  -> accum\n-  in\n-    step lhs\n-\n-\n-and parse_pexp (ps:pstate) : Ast.pexp =\n-  parse_oror_pexp ps\n-\n-and parse_mutable_and_pexp (ps:pstate) : (Ast.mutability * Ast.pexp) =\n-  let mutability = parse_mutability ps in\n-  (mutability, parse_as_pexp ps)\n-\n-and parse_pexp_list (ps:pstate) : Ast.pexp array =\n-  match peek ps with\n-      LPAREN ->\n-        bracketed_zero_or_more LPAREN RPAREN (Some COMMA)\n-          (ctxt \"pexp list\" parse_pexp) ps\n-    | _ -> raise (unexpected ps)\n-\n-and parse_mutable_and_pexp_list (ps:pstate)\n-    : (Ast.mutability * Ast.pexp) array =\n-  match peek ps with\n-      LPAREN ->\n-        bracketed_zero_or_more LPAREN RPAREN (Some COMMA)\n-          (ctxt \"mutable-and-pexp list\" parse_mutable_and_pexp) ps\n-    | _ -> raise (unexpected ps)\n-\n-;;\n-\n-(* \n- * Desugarings depend on context:\n- * \n- *   - If a pexp is used on the RHS of an assignment, it's turned into\n- *     an initialization statement such as STMT_new_rec or such. This\n- *     removes the possibility of initializing into a temp only to\n- *     copy out. If the topmost pexp in such a desugaring is an atom,\n- *     unop or binop, of course, it will still just emit a STMT_copy\n- *     on a primitive expression.\n- * \n- *   - If a pexp is used in the context where an atom is required, a \n- *     statement declaring a temporary and initializing it with the \n- *     result of the pexp is prepended, and the temporary atom is used.\n- *)\n-\n-let rec desugar_lval (ps:pstate) (pexp:Ast.pexp)\n-    : (Ast.stmt array * Ast.lval) =\n-  let s = Hashtbl.find ps.pstate_sess.Session.sess_spans pexp.id in\n-  let (apos, bpos) = (s.lo, s.hi) in\n-    match pexp.node with\n-\n-        Ast.PEXP_lval (Ast.PLVAL_base nb) ->\n-            ([||], Ast.LVAL_base (span ps apos bpos nb))\n-\n-      | Ast.PEXP_lval (Ast.PLVAL_ext_name (base_pexp, comp)) ->\n-          let (base_stmts, base_atom) = desugar_expr_atom ps base_pexp in\n-          let base_lval = atom_lval ps base_atom in\n-            (base_stmts, Ast.LVAL_ext (base_lval, Ast.COMP_named comp))\n-\n-      | Ast.PEXP_lval (Ast.PLVAL_ext_pexp (base_pexp, ext_pexp)) ->\n-          let (base_stmts, base_atom) = desugar_expr_atom ps base_pexp in\n-          let (ext_stmts, ext_atom) = desugar_expr_atom ps ext_pexp in\n-          let base_lval = atom_lval ps base_atom in\n-            (Array.append base_stmts ext_stmts,\n-             Ast.LVAL_ext (base_lval, Ast.COMP_atom (clone_atom ps ext_atom)))\n-\n-      | Ast.PEXP_lval (Ast.PLVAL_ext_deref base_pexp) ->\n-          let (base_stmts, base_atom) = desugar_expr_atom ps base_pexp in\n-          let base_lval = atom_lval ps base_atom in\n-            (base_stmts, Ast.LVAL_ext (base_lval, Ast.COMP_deref))\n-\n-      | _ ->\n-          let (stmts, atom) = desugar_expr_atom ps pexp in\n-            (stmts, atom_lval ps atom)\n-\n-\n-and desugar_expr\n-    (ps:pstate)\n-    (pexp:Ast.pexp)\n-    : (Ast.stmt array * Ast.expr) =\n-  match pexp.node with\n-\n-      Ast.PEXP_unop (op, pe) ->\n-        let (stmts, at) = desugar_expr_atom ps pe in\n-          (stmts, Ast.EXPR_unary (op, at))\n-\n-    | Ast.PEXP_binop (op, lhs, rhs) ->\n-          let (lhs_stmts, lhs_atom) = desugar_expr_atom ps lhs in\n-          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n-            (Array.append lhs_stmts rhs_stmts,\n-             Ast.EXPR_binary (op, lhs_atom, rhs_atom))\n-\n-    | _ ->\n-        let (stmts, at) = desugar_expr_atom ps pexp in\n-          (stmts, Ast.EXPR_atom at)\n-\n-\n-and desugar_opt_expr_atom\n-    (ps:pstate)\n-    (po:Ast.pexp option)\n-    : (Ast.stmt array * Ast.atom option) =\n-  match po with\n-      None -> ([| |], None)\n-    | Some pexp ->\n-        let (stmts, atom) = desugar_expr_atom ps pexp in\n-          (stmts, Some atom)\n-\n-\n-and desugar_expr_atom\n-    (ps:pstate)\n-    (pexp:Ast.pexp)\n-    : (Ast.stmt array * Ast.atom) =\n-  let s = Hashtbl.find ps.pstate_sess.Session.sess_spans pexp.id in\n-  let (apos, bpos) = (s.lo, s.hi) in\n-    match pexp.node with\n-\n-        Ast.PEXP_unop _\n-      | Ast.PEXP_binop _\n-      | Ast.PEXP_lazy_or _\n-      | Ast.PEXP_lazy_and _\n-      | Ast.PEXP_rec _\n-      | Ast.PEXP_tup _\n-      | Ast.PEXP_str _\n-      | Ast.PEXP_vec _\n-      | Ast.PEXP_port\n-      | Ast.PEXP_chan _\n-      | Ast.PEXP_call _\n-      | Ast.PEXP_bind _\n-      | Ast.PEXP_spawn _\n-      | Ast.PEXP_custom _\n-      | Ast.PEXP_box _ ->\n-          let (_, tmp, decl_stmt) = build_tmp ps slot_auto apos bpos in\n-          let stmts = desugar_expr_init ps tmp pexp in\n-            (Array.append [| decl_stmt |] stmts,\n-             Ast.ATOM_lval (clone_lval ps tmp))\n-\n-      | Ast.PEXP_lit lit ->\n-          ([||], Ast.ATOM_literal (span ps apos bpos lit))\n-\n-      | Ast.PEXP_lval _ ->\n-          let (stmts, lval) = desugar_lval ps pexp in\n-            (stmts, Ast.ATOM_lval lval)\n-\n-and desugar_expr_atoms\n-    (ps:pstate)\n-    (pexps:Ast.pexp array)\n-    : (Ast.stmt array * Ast.atom array) =\n-  arj1st (Array.map (desugar_expr_atom ps) pexps)\n-\n-and desugar_opt_expr_atoms\n-    (ps:pstate)\n-    (pexps:Ast.pexp option array)\n-    : (Ast.stmt array * Ast.atom option array) =\n-  arj1st (Array.map (desugar_opt_expr_atom ps) pexps)\n-\n-and desugar_expr_init\n-    (ps:pstate)\n-    (dst_lval:Ast.lval)\n-    (pexp:Ast.pexp)\n-    : (Ast.stmt array) =\n-  let s = Hashtbl.find ps.pstate_sess.Session.sess_spans pexp.id in\n-  let (apos, bpos) = (s.lo, s.hi) in\n-\n-  (* Helpers. *)\n-  let ss x = span ps apos bpos x in\n-  let cp v = Ast.STMT_copy (clone_lval ps dst_lval, v) in\n-  let aa x y = Array.append x y in\n-  let ac xs = Array.concat xs in\n-\n-    match pexp.node with\n-\n-        Ast.PEXP_lit _\n-      | Ast.PEXP_lval _ ->\n-          let (stmts, atom) = desugar_expr_atom ps pexp in\n-            aa stmts [| ss (cp (Ast.EXPR_atom atom)) |]\n-\n-      | Ast.PEXP_binop (op, lhs, rhs) ->\n-          let (lhs_stmts, lhs_atom) = desugar_expr_atom ps lhs in\n-          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n-          let copy_stmt =\n-            ss (cp (Ast.EXPR_binary (op, lhs_atom, rhs_atom)))\n-          in\n-            ac [ lhs_stmts; rhs_stmts; [| copy_stmt |] ]\n-\n-      (* x = a && b ==> if (a) { x = b; } else { x = false; } *)\n-\n-      | Ast.PEXP_lazy_and (lhs, rhs) ->\n-          let (lhs_stmts, lhs_atom) = desugar_expr_atom ps lhs in\n-          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n-          let sthen =\n-            ss (aa rhs_stmts [| ss (cp (Ast.EXPR_atom rhs_atom)) |])\n-          in\n-          let selse =\n-            ss [| ss (cp (Ast.EXPR_atom\n-                            (Ast.ATOM_literal (ss (Ast.LIT_bool false))))) |]\n-          in\n-          let sif =\n-            ss (Ast.STMT_if { Ast.if_test = Ast.EXPR_atom lhs_atom;\n-                              Ast.if_then = sthen;\n-                              Ast.if_else = Some selse })\n-          in\n-            aa lhs_stmts [| sif |]\n-\n-      (* x = a || b ==> if (a) { x = true; } else { x = b; } *)\n-\n-      | Ast.PEXP_lazy_or (lhs, rhs) ->\n-          let (lhs_stmts, lhs_atom) = desugar_expr_atom ps lhs in\n-          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n-          let sthen =\n-            ss [| ss (cp (Ast.EXPR_atom\n-                            (Ast.ATOM_literal (ss (Ast.LIT_bool true))))) |]\n-          in\n-          let selse =\n-            ss (aa rhs_stmts [| ss (cp (Ast.EXPR_atom rhs_atom)) |])\n-          in\n-          let sif =\n-            ss (Ast.STMT_if { Ast.if_test = Ast.EXPR_atom lhs_atom;\n-                              Ast.if_then = sthen;\n-                              Ast.if_else = Some selse })\n-          in\n-            aa lhs_stmts [| sif |]\n-\n-\n-      | Ast.PEXP_unop (op, rhs) ->\n-          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n-          let expr = Ast.EXPR_unary (op, rhs_atom) in\n-          let copy_stmt = ss (cp expr) in\n-            aa rhs_stmts [| copy_stmt |]\n-\n-      | Ast.PEXP_call (fn, args) ->\n-          let (fn_stmts, fn_atom) = desugar_expr_atom ps fn in\n-          let (arg_stmts, arg_atoms) = desugar_expr_atoms ps args in\n-          let fn_lval = atom_lval ps fn_atom in\n-          let call_stmt = ss (Ast.STMT_call (dst_lval, fn_lval, arg_atoms)) in\n-            ac [ fn_stmts; arg_stmts; [| call_stmt |] ]\n-\n-      | Ast.PEXP_bind (fn, args) ->\n-          let (fn_stmts, fn_atom) = desugar_expr_atom ps fn in\n-          let (arg_stmts, arg_atoms) = desugar_opt_expr_atoms ps args in\n-          let fn_lval = atom_lval ps fn_atom in\n-          let bind_stmt = ss (Ast.STMT_bind (dst_lval, fn_lval, arg_atoms)) in\n-            ac [ fn_stmts; arg_stmts; [| bind_stmt |] ]\n-\n-      | Ast.PEXP_spawn (domain, name, sub) ->\n-          begin\n-            match sub.node with\n-                Ast.PEXP_call (fn, args) ->\n-                  let (fn_stmts, fn_atom) = desugar_expr_atom ps fn in\n-                  let (arg_stmts, arg_atoms) = desugar_expr_atoms ps args in\n-                  let fn_lval = atom_lval ps fn_atom in\n-                  let spawn_stmt =\n-                    ss (Ast.STMT_spawn\n-                          (dst_lval, domain, name, fn_lval, arg_atoms))\n-                  in\n-                    ac [ fn_stmts; arg_stmts; [| spawn_stmt |] ]\n-              | _ -> raise (err \"non-call spawn\" ps)\n-          end\n-\n-      | Ast.PEXP_rec (args, base) ->\n-          let (arg_stmts, entries) =\n-            arj1st\n-              begin\n-                Array.map\n-                  begin\n-                    fun (ident, mutability, pexp) ->\n-                      let (stmts, atom) =\n-                        desugar_expr_atom ps pexp\n-                      in\n-                        (stmts, (ident, mutability, atom))\n-                  end\n-                  args\n-              end\n-          in\n-            begin\n-              match base with\n-                  Some base ->\n-                    let (base_stmts, base_lval) = desugar_lval ps base in\n-                    let rec_stmt =\n-                      ss (Ast.STMT_new_rec\n-                            (dst_lval, entries, Some base_lval))\n-                    in\n-                      ac [ arg_stmts; base_stmts; [| rec_stmt |] ]\n-                | None ->\n-                    let rec_stmt =\n-                      ss (Ast.STMT_new_rec (dst_lval, entries, None))\n-                    in\n-                      aa arg_stmts [| rec_stmt |]\n-            end\n-\n-      | Ast.PEXP_tup args ->\n-          let muts = Array.to_list (Array.map fst args) in\n-          let (arg_stmts, arg_atoms) =\n-            desugar_expr_atoms ps (Array.map snd args)\n-          in\n-          let arg_atoms = Array.to_list arg_atoms in\n-          let tup_args = Array.of_list (List.combine muts arg_atoms) in\n-          let stmt = ss (Ast.STMT_new_tup (dst_lval, tup_args)) in\n-            aa arg_stmts [| stmt |]\n-\n-      | Ast.PEXP_str s ->\n-          let stmt = ss (Ast.STMT_new_str (dst_lval, s)) in\n-            [| stmt |]\n-\n-      | Ast.PEXP_vec (mutability, args) ->\n-          let (arg_stmts, arg_atoms) = desugar_expr_atoms ps args in\n-          let stmt =\n-            ss (Ast.STMT_new_vec (dst_lval, mutability, arg_atoms))\n-          in\n-            aa arg_stmts [| stmt |]\n-\n-      | Ast.PEXP_port ->\n-          [| ss (Ast.STMT_new_port dst_lval) |]\n-\n-      | Ast.PEXP_chan pexp_opt ->\n-          let (port_stmts, port_opt) =\n-            match pexp_opt with\n-                None -> ([||], None)\n-              | Some port_pexp ->\n-                  begin\n-                    let (port_stmts, port_atom) =\n-                      desugar_expr_atom ps port_pexp\n-                    in\n-                    let port_lval = atom_lval ps port_atom in\n-                      (port_stmts, Some port_lval)\n-                  end\n-          in\n-          let chan_stmt =\n-            ss\n-              (Ast.STMT_new_chan (dst_lval, port_opt))\n-          in\n-            aa port_stmts [| chan_stmt |]\n-\n-      | Ast.PEXP_box (mutability, arg) ->\n-          let (arg_stmts, arg_mode_atom) =\n-            desugar_expr_atom ps arg\n-          in\n-          let stmt =\n-            ss (Ast.STMT_new_box (dst_lval, mutability, arg_mode_atom))\n-          in\n-            aa arg_stmts [| stmt |]\n-\n-      | Ast.PEXP_custom (n, a, b) ->\n-          expand_pexp_custom ps apos bpos dst_lval n a b\n-\n-(* \n- * FIXME: This is a crude approximation of the syntax-extension system,\n- * for purposes of prototyping and/or hard-wiring any extensions we\n- * wish to use in the bootstrap compiler. The eventual aim is to permit\n- * loading rust crates to process extensions, but this will likely\n- * require a rust-based frontend, or an ocaml-FFI-based connection to\n- * rust crates. At the moment we have neither.\n- *)\n-\n-and expand_pexp_custom\n-    (ps:pstate)\n-    (apos:pos)\n-    (bpos:pos)\n-    (dst_lval:Ast.lval)\n-    (name:Ast.name)\n-    (pexp_args:Ast.pexp array)\n-    (body:string option)\n-    : (Ast.stmt array) =\n-  let nstr = Fmt.fmt_to_str Ast.fmt_name name in\n-    match (nstr, (Array.length pexp_args), body) with\n-\n-        (\"shell\", 0, Some cmd) ->\n-          let c = Unix.open_process_in cmd in\n-          let b = Buffer.create 32 in\n-          let rec r _ =\n-            try\n-              Buffer.add_char b (input_char c);\n-              r ()\n-            with\n-                End_of_file ->\n-                  ignore (Unix.close_process_in c);\n-                  Buffer.contents b\n-          in\n-            [| span ps apos bpos\n-                 (Ast.STMT_new_str (dst_lval, r())) |]\n-\n-      | (\"fmt\", nargs, None) ->\n-            if nargs = 0\n-            then raise (err \"malformed #fmt call\" ps)\n-            else\n-              begin\n-                match pexp_args.(0).node with\n-                    Ast.PEXP_str s ->\n-                      let (arg_stmts, args) =\n-                        desugar_expr_atoms ps\n-                          (Array.sub pexp_args 1 (nargs-1))\n-                      in\n-\n-                      let pieces = Extfmt.parse_fmt_string s in\n-                      let fmt_stmts =\n-                        fmt_pieces_to_stmts\n-                          ps apos bpos dst_lval pieces args\n-                      in\n-                        Array.append arg_stmts fmt_stmts\n-                  | _ ->\n-                      raise (err \"malformed #fmt call\" ps)\n-              end\n-\n-      | _ ->\n-          raise (err (\"unknown syntax extension: \" ^ nstr) ps)\n-\n-and fmt_pieces_to_stmts\n-    (ps:pstate)\n-    (apos:pos)\n-    (bpos:pos)\n-    (dst_lval:Ast.lval)\n-    (pieces:Extfmt.piece array)\n-    (args:Ast.atom array)\n-    : (Ast.stmt array) =\n-\n-  let stmts = Queue.create () in\n-\n-  let make_new_tmp _ =\n-    let (_, tmp, decl_stmt) = build_tmp ps slot_auto apos bpos in\n-      Queue.add decl_stmt stmts;\n-      tmp\n-  in\n-\n-  let make_new_str s =\n-    let tmp = make_new_tmp () in\n-    let init_stmt =\n-      span ps apos bpos (Ast.STMT_new_str (clone_lval ps tmp, s))\n-    in\n-      Queue.add init_stmt stmts;\n-      tmp\n-  in\n-\n-  let make_append dst_lval src_atom =\n-    let stmt =\n-      span ps apos bpos\n-        (Ast.STMT_copy_binop\n-           ((clone_lval ps dst_lval), Ast.BINOP_add, src_atom))\n-    in\n-      Queue.add stmt stmts\n-  in\n-\n-  let make_append_lval dst_lval src_lval =\n-      make_append dst_lval (Ast.ATOM_lval (clone_lval ps src_lval))\n-  in\n-\n-  let rec make_lval' path =\n-    match path with\n-        [n] ->\n-          Ast.LVAL_base (span ps apos bpos (Ast.BASE_ident n))\n-\n-      | x :: xs ->\n-          Ast.LVAL_ext (make_lval' xs,\n-                        Ast.COMP_named (Ast.COMP_ident x))\n-\n-      | [] -> (bug () \"make_lval on empty list in #fmt\")\n-  in\n-\n-  let make_lval path = make_lval' (List.rev path) in\n-\n-  let make_call dst path args =\n-    let callee = make_lval path in\n-    let stmt =\n-      span ps apos bpos (Ast.STMT_call (dst, callee, args ))\n-    in\n-      Queue.add stmt stmts\n-  in\n-\n-  let ulit i =\n-    Ast.ATOM_literal (span ps apos bpos (Ast.LIT_uint (Int64.of_int i)))\n-  in\n-\n-  let n = ref 0 in\n-  let tmp_lval = make_new_str \"\" in\n-  let final_stmt =\n-    span ps apos bpos\n-      (Ast.STMT_copy\n-         (clone_lval ps dst_lval,\n-          Ast.EXPR_atom (Ast.ATOM_lval tmp_lval)))\n-  in\n-    Array.iter\n-      begin\n-        fun piece ->\n-          match piece with\n-              Extfmt.PIECE_string s ->\n-                let s_lval = make_new_str s in\n-                  make_append_lval tmp_lval s_lval\n-\n-            | Extfmt.PIECE_conversion conv ->\n-                if not\n-                  ((conv.Extfmt.conv_parameter = None) &&\n-                     (conv.Extfmt.conv_flags = []) &&\n-                     (conv.Extfmt.conv_width = Extfmt.COUNT_implied) &&\n-                     (conv.Extfmt.conv_precision = Extfmt.COUNT_implied))\n-                then\n-                  raise (err \"conversion not supported in #fmt string\" ps);\n-                if !n >= Array.length args\n-                then raise (err \"too many conversions in #fmt string\" ps);\n-                let arg = args.(!n) in\n-                  incr n;\n-                  match conv.Extfmt.conv_ty with\n-                      Extfmt.TY_str ->\n-                        make_append tmp_lval arg\n-\n-                    | Extfmt.TY_int Extfmt.SIGNED ->\n-                        let t = make_new_tmp () in\n-                          make_call t\n-                            [\"std\"; \"_int\"; \"to_str\" ] [| arg; ulit 10 |];\n-\n-                          make_append_lval tmp_lval t\n-\n-                    | Extfmt.TY_int Extfmt.UNSIGNED ->\n-                        let t = make_new_tmp () in\n-                          make_call t\n-                            [\"std\"; \"_uint\"; \"to_str\" ] [| arg; ulit 10 |];\n-                          make_append_lval tmp_lval t\n-\n-                    | _ ->\n-                        raise (err \"conversion not supported in #fmt\" ps);\n-      end\n-      pieces;\n-    Queue.add final_stmt stmts;\n-    queue_to_arr stmts;\n-\n-\n-and atom_lval (_:pstate) (at:Ast.atom) : Ast.lval =\n-  match at with\n-      Ast.ATOM_lval lv -> lv\n-    | Ast.ATOM_literal _\n-    | Ast.ATOM_pexp _ -> bug () \"Pexp.atom_lval on non-ATOM_lval\"\n-;;\n-\n-\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "27cb399b5516d72cfebd99931a89c0aeb0e312b5", "filename": "src/boot/fe/token.ml", "status": "removed", "additions": 0, "deletions": 334, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Ftoken.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Ffe%2Ftoken.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ftoken.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,334 +0,0 @@\n-type token =\n-\n-    (* Expression operator symbols *)\n-    PLUS\n-  | MINUS\n-  | STAR\n-  | SLASH\n-  | PERCENT\n-  | EQ\n-  | LT\n-  | LE\n-  | EQEQ\n-  | NE\n-  | GE\n-  | GT\n-  | NOT\n-  | TILDE\n-  | CARET\n-  | AND\n-  | ANDAND\n-  | OR\n-  | OROR\n-  | LSL\n-  | LSR\n-  | ASR\n-  | OPEQ of token\n-  | AS\n-  | WITH\n-\n-  (* Structural symbols *)\n-  | AT\n-  | DOT\n-  | COMMA\n-  | SEMI\n-  | COLON\n-  | QUES\n-  | RARROW\n-  | SEND\n-  | LARROW\n-  | LPAREN\n-  | RPAREN\n-  | LBRACKET\n-  | RBRACKET\n-  | LBRACE\n-  | RBRACE\n-\n-  (* Module and crate keywords *)\n-  | MOD\n-  | USE\n-  | AUTH\n-  | META\n-\n-  (* Metaprogramming keywords *)\n-  | SYNTAX\n-  | POUND\n-\n-  (* Statement keywords *)\n-  | IF\n-  | ELSE\n-  | DO\n-  | WHILE\n-  | ALT\n-  | CASE\n-\n-  | FAIL\n-  | DROP\n-\n-  | IN\n-  | FOR\n-  | EACH\n-  | PUT\n-  | RET\n-  | BE\n-  | BREAK\n-  | CONT\n-\n-  (* Type and type-state keywords *)\n-  | TYPE\n-  | CHECK\n-  | ASSERT\n-  | CLAIM\n-  | PROVE\n-\n-  (* Layer keywords *)\n-  | STATE\n-  | GC\n-\n-  (* Unsafe-block keyword *)\n-  | UNSAFE\n-\n-  (* Type qualifiers *)\n-  | NATIVE\n-  | AUTO\n-  | MUTABLE\n-\n-  (* Name management *)\n-  | IMPORT\n-  | EXPORT\n-\n-  (* Value / stmt declarators *)\n-  | LET\n-  | CONST\n-\n-  (* Magic runtime services *)\n-  | LOG\n-  | LOG_ERR\n-  | SPAWN\n-  | BIND\n-  | THREAD\n-  | YIELD\n-  | JOIN\n-\n-  (* Literals *)\n-  | LIT_INT       of int64\n-  | LIT_UINT      of int64\n-  | LIT_FLOAT     of float\n-  | LIT_MACH_INT  of Common.ty_mach * int64\n-  | LIT_MACH_FLOAT of Common.ty_mach * float\n-  | LIT_STR       of string\n-  | LIT_CHAR      of int\n-  | LIT_BOOL      of bool\n-\n-  (* Name components *)\n-  | IDENT         of string\n-  | IDX           of int\n-  | UNDERSCORE\n-\n-  (* Reserved type names *)\n-  | BOOL\n-  | INT\n-  | UINT\n-  | FLOAT\n-  | CHAR\n-  | STR\n-  | MACH          of Common.ty_mach\n-\n-  (* Algebraic type constructors *)\n-  | REC\n-  | TUP\n-  | TAG\n-  | VEC\n-  | ANY\n-\n-  (* Callable type constructors *)\n-  | FN\n-  | ITER\n-\n-  (* Object type *)\n-  | OBJ\n-\n-  (* Comm and task types *)\n-  | CHAN\n-  | PORT\n-  | TASK\n-\n-  | EOF\n-\n-  | BRACEQUOTE of string\n-\n-;;\n-\n-let rec string_of_tok t =\n-  match t with\n-      (* Operator symbols (mostly) *)\n-      PLUS       -> \"+\"\n-    | MINUS      -> \"-\"\n-    | STAR       -> \"*\"\n-    | SLASH      -> \"/\"\n-    | PERCENT    -> \"%\"\n-    | EQ         -> \"=\"\n-    | LT         -> \"<\"\n-    | LE         -> \"<=\"\n-    | EQEQ       -> \"==\"\n-    | NE         -> \"!=\"\n-    | GE         -> \">=\"\n-    | GT         -> \">\"\n-    | TILDE      -> \"~\"\n-    | CARET      -> \"^\"\n-    | NOT        -> \"!\"\n-    | AND        -> \"&\"\n-    | ANDAND     -> \"&&\"\n-    | OR         -> \"|\"\n-    | OROR       -> \"||\"\n-    | LSL        -> \"<<\"\n-    | LSR        -> \">>\"\n-    | ASR        -> \">>>\"\n-    | OPEQ op    -> string_of_tok op ^ \"=\"\n-    | AS         -> \"as\"\n-    | WITH       -> \"with\"\n-\n-    (* Structural symbols *)\n-    | AT         -> \"@\"\n-    | DOT        -> \".\"\n-    | COMMA      -> \",\"\n-    | SEMI       -> \";\"\n-    | COLON      -> \":\"\n-    | QUES       -> \"?\"\n-    | RARROW     -> \"->\"\n-    | SEND       -> \"<|\"\n-    | LARROW     -> \"<-\"\n-    | LPAREN     -> \"(\"\n-    | RPAREN     -> \")\"\n-    | LBRACKET   -> \"[\"\n-    | RBRACKET   -> \"]\"\n-    | LBRACE     -> \"{\"\n-    | RBRACE     -> \"}\"\n-\n-    (* Module and crate keywords *)\n-    | MOD        -> \"mod\"\n-    | USE        -> \"use\"\n-    | AUTH       -> \"auth\"\n-\n-    (* Metaprogramming keywords *)\n-    | SYNTAX     -> \"syntax\"\n-    | META       -> \"meta\"\n-    | POUND      -> \"#\"\n-\n-    (* Control-flow keywords *)\n-    | IF         -> \"if\"\n-    | ELSE       -> \"else\"\n-    | DO         -> \"do\"\n-    | WHILE      -> \"while\"\n-    | ALT        -> \"alt\"\n-    | CASE       -> \"case\"\n-\n-    | FAIL       -> \"fail\"\n-    | DROP       -> \"drop\"\n-\n-    | IN         -> \"in\"\n-    | FOR        -> \"for\"\n-    | EACH       -> \"each\"\n-    | PUT        -> \"put\"\n-    | RET        -> \"ret\"\n-    | BE         -> \"be\"\n-    | BREAK      -> \"break\"\n-    | CONT       -> \"cont\"\n-\n-    (* Type and type-state keywords *)\n-    | TYPE       -> \"type\"\n-    | CHECK      -> \"check\"\n-    | ASSERT     -> \"assert\"\n-    | CLAIM      -> \"claim\"\n-    | PROVE      -> \"prove\"\n-\n-    (* Layer keywords *)\n-    | STATE      -> \"state\"\n-    | GC         -> \"gc\"\n-\n-    (* Unsafe-block keyword *)\n-    | UNSAFE     -> \"unsafe\"\n-\n-    (* Type qualifiers *)\n-    | NATIVE     -> \"native\"\n-    | AUTO       -> \"auto\"\n-    | MUTABLE    -> \"mutable\"\n-\n-    (* Name management *)\n-    | IMPORT     -> \"import\"\n-    | EXPORT     -> \"export\"\n-\n-    (* Value / stmt declarators. *)\n-    | LET        -> \"let\"\n-    | CONST      -> \"const\"\n-\n-    (* Magic runtime services *)\n-    | LOG        -> \"log\"\n-    | LOG_ERR    -> \"log_err\"\n-    | SPAWN      -> \"spawn\"\n-    | BIND       -> \"bind\"\n-    | THREAD     -> \"thread\"\n-    | YIELD      -> \"yield\"\n-    | JOIN       -> \"join\"\n-\n-    (* Literals *)\n-    | LIT_INT i  -> Int64.to_string i\n-    | LIT_UINT i -> (Int64.to_string i) ^ \"u\"\n-    | LIT_FLOAT s  -> string_of_float s\n-    | LIT_MACH_INT (tm, i)  ->\n-        (Int64.to_string i) ^ (Common.string_of_ty_mach tm)\n-    | LIT_MACH_FLOAT (tm, f)  ->\n-        (string_of_float f) ^ (Common.string_of_ty_mach tm)\n-    | LIT_STR s  -> (\"\\\"\" ^ (String.escaped s) ^ \"\\\"\")\n-    | LIT_CHAR c -> (\"'\" ^ (Common.escaped_char c) ^ \"'\")\n-    | LIT_BOOL b -> if b then \"true\" else \"false\"\n-\n-    (* Name components *)\n-    | IDENT s    -> s\n-    | IDX i      -> (\"_\" ^ (string_of_int i))\n-    | UNDERSCORE -> \"_\"\n-\n-    (* Reserved type names *)\n-    | BOOL       -> \"bool\"\n-    | INT        -> \"int\"\n-    | UINT       -> \"uint\"\n-    | FLOAT      -> \"float\"\n-    | CHAR       -> \"char\"\n-    | STR        -> \"str\"\n-    | MACH m     -> Common.string_of_ty_mach m\n-\n-    (* Algebraic type constructors *)\n-    | REC        -> \"rec\"\n-    | TUP        -> \"tup\"\n-    | TAG        -> \"tag\"\n-    | VEC        -> \"vec\"\n-    | ANY        -> \"any\"\n-\n-    (* Callable type constructors *)\n-    | FN         -> \"fn\"\n-    | ITER       -> \"iter\"\n-\n-    (* Object type *)\n-    | OBJ        -> \"obj\"\n-\n-    (* Ports and channels *)\n-    | CHAN          -> \"chan\"\n-    | PORT          -> \"port\"\n-\n-    (* Taskess types *)\n-    | TASK         -> \"task\"\n-\n-    | BRACEQUOTE _ -> \"{...bracequote...}\"\n-\n-    | EOF          -> \"<EOF>\"\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "1fc4834b855e135357a64e36851e74a8119c1cf5", "filename": "src/boot/me/alias.ml", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Falias.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Falias.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Falias.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,156 +0,0 @@\n-open Semant;;\n-open Common;;\n-\n-let log cx = Session.log \"alias\"\n-  (should_log cx cx.ctxt_sess.Session.sess_log_alias)\n-  cx.ctxt_sess.Session.sess_log_out\n-;;\n-\n-let alias_analysis_visitor\n-    (cx:ctxt)\n-    (inner:Walk.visitor)\n-    : Walk.visitor =\n-  let curr_stmt = Stack.create () in\n-\n-  let alias_slot (slot_id:node_id) : unit =\n-    begin\n-      log cx \"noting slot #%d as aliased\" (int_of_node slot_id);\n-      Hashtbl.replace cx.ctxt_slot_aliased slot_id ()\n-    end\n-  in\n-\n-  let alias lval =\n-    let defn_id = lval_base_defn_id cx lval in\n-      if (defn_id_is_slot cx defn_id)\n-      then alias_slot defn_id\n-  in\n-\n-  let alias_atom at =\n-    match at with\n-        Ast.ATOM_lval lv -> alias lv\n-      | _ -> () (* Aliasing a literal is harmless, if weird. *)\n-  in\n-\n-  let alias_call_args dst callee args =\n-    alias dst;\n-    let callee_ty = lval_ty cx callee in\n-      match callee_ty with\n-          Ast.TY_fn (tsig,_) ->\n-            Array.iteri\n-              begin\n-                fun i slot ->\n-                  match slot.Ast.slot_mode with\n-                      Ast.MODE_alias  ->\n-                        alias_atom args.(i)\n-                    | _ -> ()\n-              end\n-              tsig.Ast.sig_input_slots\n-        | _ -> ()\n-  in\n-\n-  let check_no_alias_bindings\n-      (fn:Ast.lval)\n-      (args:(Ast.atom option) array)\n-      : unit =\n-    let fty = match lval_ty cx fn with\n-        Ast.TY_fn tfn -> tfn\n-      | _ -> err (Some (lval_base_id fn)) \"binding non-fn\"\n-    in\n-    let arg_slots = (fst fty).Ast.sig_input_slots in\n-      Array.iteri\n-        begin\n-          fun i arg ->\n-            match arg with\n-                None -> ()\n-              | Some _ ->\n-                  match arg_slots.(i).Ast.slot_mode with\n-                      Ast.MODE_local -> ()\n-                    | Ast.MODE_alias ->\n-                        err (Some (lval_base_id fn)) \"binding alias slot\"\n-        end\n-        args\n-  in\n-\n-  let visit_stmt_pre s =\n-    Stack.push s.id curr_stmt;\n-    begin\n-      try\n-        match s.node with\n-            (* FIXME (issue #26): actually all these *existing* cases\n-             * can probably go now that we're using Trans.aliasing to\n-             * form short-term spill-based aliases. Only aliases that\n-             * survive 'into' a sub-block (those formed during iteration)\n-             * need to be handled in this module.  *)\n-            Ast.STMT_call (dst, callee, args)\n-          | Ast.STMT_spawn (dst, _, _, callee, args)\n-            -> alias_call_args dst callee args\n-\n-          | Ast.STMT_bind (_, fn, args) ->\n-              check_no_alias_bindings fn args\n-\n-          | Ast.STMT_send (_, src) -> alias src\n-          | Ast.STMT_recv (dst, _) -> alias dst\n-          | Ast.STMT_new_port (dst) -> alias dst\n-          | Ast.STMT_new_chan (dst, _) -> alias dst\n-          | Ast.STMT_new_vec (dst, _, _) -> alias dst\n-          | Ast.STMT_new_str (dst, _) -> alias dst\n-          | Ast.STMT_for_each sfe ->\n-              let (slot, _) = sfe.Ast.for_each_slot in\n-                alias_slot slot.id\n-          | _ -> () (* FIXME (issue #29): plenty more to handle here. *)\n-      with\n-          Semant_err (None, msg) ->\n-            raise (Semant_err ((Some s.id), msg))\n-    end;\n-    inner.Walk.visit_stmt_pre s\n-  in\n-  let visit_stmt_post s =\n-    inner.Walk.visit_stmt_post s;\n-    ignore (Stack.pop curr_stmt);\n-  in\n-\n-  let visit_lval_pre lv =\n-    let slot_id = lval_base_defn_id cx lv in\n-      if (not (Stack.is_empty curr_stmt)) && (defn_id_is_slot cx slot_id)\n-      then\n-        begin\n-          let slot_depth = get_slot_depth cx slot_id in\n-          let stmt_depth = get_stmt_depth cx (Stack.top curr_stmt) in\n-            if slot_depth <> stmt_depth\n-            then\n-              begin\n-                let _ = assert (slot_depth < stmt_depth) in\n-                  alias_slot slot_id\n-              end\n-        end\n-  in\n-\n-    { inner with\n-        Walk.visit_stmt_pre = visit_stmt_pre;\n-        Walk.visit_stmt_post = visit_stmt_post;\n-        Walk.visit_lval_pre = visit_lval_pre\n-    }\n-;;\n-\n-let process_crate\n-    (cx:ctxt)\n-    (crate:Ast.crate)\n-    : unit =\n-  let passes =\n-    [|\n-      (alias_analysis_visitor cx\n-         Walk.empty_visitor);\n-    |]\n-  in\n-    run_passes cx \"alias\" passes\n-      cx.ctxt_sess.Session.sess_log_alias log crate\n-;;\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "d508c664c24f6de6c2d795fbacfd0ff31db4c74f", "filename": "src/boot/me/dead.ml", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fdead.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fdead.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdead.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480", "patch": "@@ -1,134 +0,0 @@\n-(* \n- * A simple dead-code analysis that rejects code following unconditional\n- * 'ret' or 'be'. \n- *)\n-\n-open Semant;;\n-open Common;;\n-\n-let log cx = Session.log \"dead\"\n-  (should_log cx cx.ctxt_sess.Session.sess_log_dead)\n-  cx.ctxt_sess.Session.sess_log_out\n-;;\n-\n-let dead_code_visitor\n-    ((*cx*)_:ctxt)\n-    (inner:Walk.visitor)\n-    : Walk.visitor =\n-\n-  (* FIXME: create separate table for each fn body for less garbage *)\n-  let must_exit = Hashtbl.create 100 in\n-\n-  let all_must_exit ids =\n-    arr_for_all (fun _ id -> Hashtbl.mem must_exit id) ids\n-  in\n-\n-  let visit_block_post block =\n-    let stmts = block.node in\n-    let len = Array.length stmts in\n-      if len > 0 then\n-        Array.iteri\n-          begin\n-            fun i s ->\n-              if (i < (len - 1)) && (Hashtbl.mem must_exit s.id) then\n-                err (Some stmts.(i + 1).id) \"dead statement\"\n-          end\n-          stmts;\n-      inner.Walk.visit_block_post block\n-  in\n-\n-  let exit_stmt_if_exit_body s body =\n-      if (Hashtbl.mem must_exit body.id) then\n-        Hashtbl.add must_exit s.id ()\n-  in\n-\n-  let visit_stmt_post s =\n-    begin\n-        match s.node with\n-        | Ast.STMT_block block ->\n-            if Hashtbl.mem must_exit block.id then\n-              Hashtbl.add must_exit s.id ()\n-\n-        | Ast.STMT_while w\n-        | Ast.STMT_do_while w ->\n-            exit_stmt_if_exit_body s w.Ast.while_body\n-\n-        | Ast.STMT_for_each f ->\n-            exit_stmt_if_exit_body s f.Ast.for_each_body\n-\n-        | Ast.STMT_for f ->\n-            exit_stmt_if_exit_body s f.Ast.for_body\n-\n-        | Ast.STMT_if { Ast.if_then = b1;\n-                        Ast.if_else = Some b2;\n-                        Ast.if_test = _ } ->\n-            if (Hashtbl.mem must_exit b1.id) && (Hashtbl.mem must_exit b2.id)\n-            then Hashtbl.add must_exit s.id ()\n-\n-        | Ast.STMT_if _ -> ()\n-\n-        | Ast.STMT_ret _\n-        | Ast.STMT_be _ ->\n-            Hashtbl.add must_exit s.id ()\n-\n-        | Ast.STMT_alt_tag { Ast.alt_tag_arms = arms;\n-                             Ast.alt_tag_lval = _ } ->\n-            let arm_ids =\n-              Array.map (fun { node = (_, block); id = _ } -> block.id) arms\n-            in\n-              if all_must_exit arm_ids\n-              then Hashtbl.add must_exit s.id ()\n-\n-        | Ast.STMT_alt_type { Ast.alt_type_arms = arms;\n-                              Ast.alt_type_else = alt_type_else;\n-                              Ast.alt_type_lval = _ } ->\n-            let arm_ids = Array.map (fun { node = ((_, _), block); id = _ } ->\n-                                       block.id) arms in\n-            let else_ids =\n-              begin\n-                match alt_type_else with\n-                    Some stmt -> [| stmt.id |]\n-                  | None -> [| |]\n-              end\n-            in\n-              if all_must_exit (Array.append arm_ids else_ids) then\n-                Hashtbl.add must_exit s.id ()\n-\n-        (* FIXME: figure this one out *)\n-        | Ast.STMT_alt_port _ -> ()\n-\n-        | _ -> ()\n-    end;\n-    inner.Walk.visit_stmt_post s\n-\n-  in\n-    { inner with\n-        Walk.visit_block_post = visit_block_post;\n-        Walk.visit_stmt_post = visit_stmt_post }\n-;;\n-\n-let process_crate\n-    (cx:ctxt)\n-    (crate:Ast.crate)\n-    : unit =\n-  let passes =\n-    [|\n-      (dead_code_visitor cx\n-         Walk.empty_visitor)\n-    |]\n-  in\n-\n-    run_passes cx \"dead\" passes\n-      cx.ctxt_sess.Session.sess_log_dead log crate;\n-    ()\n-;;\n-\n-\n-(*\n- * Local Variables:\n- * fill-column: 78;\n- * indent-tabs-mode: nil\n- * buffer-file-coding-system: utf-8-unix\n- * compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n- * End:\n- *)"}, {"sha": "ff3786afaff8d6e74808f2794fe1f24c3a9af9fd", "filename": "src/boot/me/dwarf.ml", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fdwarf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fdwarf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdwarf.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "e99c9ac83c7f4c6badb5f65061b90b76a05f3eca", "filename": "src/boot/me/layer.ml", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Flayer.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Flayer.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Flayer.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "fd2a90b2b02d773b4ed0bfd44de91f9cd660e130", "filename": "src/boot/me/layout.ml", "status": "removed", "additions": 0, "deletions": 480, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Flayout.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Flayout.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Flayout.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "a0fc957025913c6f18acd87e3d77d748064b6d3f", "filename": "src/boot/me/loop.ml", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Floop.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Floop.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Floop.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "b7fd25ae088e8c4c2c8bc78ba50da6eeaceeabfd", "filename": "src/boot/me/resolve.ml", "status": "removed", "additions": 0, "deletions": 935, "changes": 935, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "a877f2d051c7c888600b617c5e88796e2c509026", "filename": "src/boot/me/semant.ml", "status": "removed", "additions": 0, "deletions": 2802, "changes": 2802, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "a4cd1418e38173d86590a9147af4f844cb837779", "filename": "src/boot/me/simplify.ml", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fsimplify.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fsimplify.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsimplify.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "d34d19d8dc63d65be0e1c51a9b6a959aaa43fbec", "filename": "src/boot/me/trans.ml", "status": "removed", "additions": 0, "deletions": 6367, "changes": 6367, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "ad012a756cd49a9866cba3fc546b0677f4555762", "filename": "src/boot/me/transutil.ml", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Ftransutil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Ftransutil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftransutil.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "b9aaf3601434a847c81d9b7f2ce47074346c31e3", "filename": "src/boot/me/type.ml", "status": "removed", "additions": 0, "deletions": 1453, "changes": 1453, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "fe6e8dcad6d171ec81973a038c0262beacbe5951", "filename": "src/boot/me/typestate.ml", "status": "removed", "additions": 0, "deletions": 1537, "changes": 1537, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "131005e54c6d96714b57c360e76764ae3ea1b80e", "filename": "src/boot/me/walk.ml", "status": "removed", "additions": 0, "deletions": 729, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fwalk.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Fme%2Fwalk.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fwalk.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "aed0f2b836141bbcb9685792890bcff90c5ef607", "filename": "src/boot/util/bits.ml", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Futil%2Fbits.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Futil%2Fbits.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Futil%2Fbits.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "63897217293442807908624c19bf2e3293c05379", "filename": "src/boot/util/common.ml", "status": "removed", "additions": 0, "deletions": 823, "changes": 823, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Futil%2Fcommon.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Futil%2Fcommon.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Futil%2Fcommon.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "e62ec1ec7482271f209475147f31c94c0afa5516", "filename": "src/boot/util/fmt.ml", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Futil%2Ffmt.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ef75860a0a72f79f97216f8aaa5b388d98da6480/src%2Fboot%2Futil%2Ffmt.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Futil%2Ffmt.ml?ref=ef75860a0a72f79f97216f8aaa5b388d98da6480"}, {"sha": "974511a8c0a6e636a879966f2b840acabb3db14f", "filename": "src/comp/README", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6997adf76342b7a6fe03c4bc370ce5fc5082a869/src%2Fcomp%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/6997adf76342b7a6fe03c4bc370ce5fc5082a869/src%2Fcomp%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2FREADME?ref=6997adf76342b7a6fe03c4bc370ce5fc5082a869"}, {"sha": "4c9d76cda505e164cd9f29cf81c0fa7d0ed35762", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6997adf76342b7a6fe03c4bc370ce5fc5082a869/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6997adf76342b7a6fe03c4bc370ce5fc5082a869/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=6997adf76342b7a6fe03c4bc370ce5fc5082a869"}]}