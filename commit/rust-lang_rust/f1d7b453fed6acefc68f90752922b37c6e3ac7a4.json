{"sha": "f1d7b453fed6acefc68f90752922b37c6e3ac7a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZDdiNDUzZmVkNmFjZWZjNjhmOTA3NTI5MjJiMzdjNmUzYWM3YTQ=", "commit": {"author": {"name": "Michael Lamparski", "email": "diagonaldevice@gmail.com", "date": "2018-04-30T11:37:36Z"}, "committer": {"name": "Michael Lamparski", "email": "diagonaldevice@gmail.com", "date": "2018-04-30T15:53:51Z"}, "message": "revise test gen macro for str", "tree": {"sha": "cde268ecf22ee801da020128dec28b3c659edd66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cde268ecf22ee801da020128dec28b3c659edd66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1d7b453fed6acefc68f90752922b37c6e3ac7a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d7b453fed6acefc68f90752922b37c6e3ac7a4", "html_url": "https://github.com/rust-lang/rust/commit/f1d7b453fed6acefc68f90752922b37c6e3ac7a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1d7b453fed6acefc68f90752922b37c6e3ac7a4/comments", "author": {"login": "ExpHP", "id": 1411280, "node_id": "MDQ6VXNlcjE0MTEyODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1411280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ExpHP", "html_url": "https://github.com/ExpHP", "followers_url": "https://api.github.com/users/ExpHP/followers", "following_url": "https://api.github.com/users/ExpHP/following{/other_user}", "gists_url": "https://api.github.com/users/ExpHP/gists{/gist_id}", "starred_url": "https://api.github.com/users/ExpHP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ExpHP/subscriptions", "organizations_url": "https://api.github.com/users/ExpHP/orgs", "repos_url": "https://api.github.com/users/ExpHP/repos", "events_url": "https://api.github.com/users/ExpHP/events{/privacy}", "received_events_url": "https://api.github.com/users/ExpHP/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ExpHP", "id": 1411280, "node_id": "MDQ6VXNlcjE0MTEyODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1411280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ExpHP", "html_url": "https://github.com/ExpHP", "followers_url": "https://api.github.com/users/ExpHP/followers", "following_url": "https://api.github.com/users/ExpHP/following{/other_user}", "gists_url": "https://api.github.com/users/ExpHP/gists{/gist_id}", "starred_url": "https://api.github.com/users/ExpHP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ExpHP/subscriptions", "organizations_url": "https://api.github.com/users/ExpHP/orgs", "repos_url": "https://api.github.com/users/ExpHP/repos", "events_url": "https://api.github.com/users/ExpHP/events{/privacy}", "received_events_url": "https://api.github.com/users/ExpHP/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030aa9b112b5b52207186b375d9fc09607bbed48", "url": "https://api.github.com/repos/rust-lang/rust/commits/030aa9b112b5b52207186b375d9fc09607bbed48", "html_url": "https://github.com/rust-lang/rust/commit/030aa9b112b5b52207186b375d9fc09607bbed48"}], "stats": {"total": 225, "additions": 81, "deletions": 144}, "files": [{"sha": "2edd41a70b945af71db27b33d5053ecc4c33900d", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 81, "deletions": 144, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/f1d7b453fed6acefc68f90752922b37c6e3ac7a4/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d7b453fed6acefc68f90752922b37c6e3ac7a4/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=f1d7b453fed6acefc68f90752922b37c6e3ac7a4", "patch": "@@ -291,11 +291,14 @@ fn test_replace_pattern() {\n     assert_eq!(data.replace(|c| c == '\u03b3', \"\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\"), \"abcd\u03b1\u03b2\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\u03b4abcd\u03b1\u03b2\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\u03b4\");\n }\n \n+// The current implementation of SliceIndex fails to handle methods\n+// orthogonally from range types; therefore, it is worth testing\n+// all of the indexing operations on each input.\n mod slice_index {\n     // Test a slicing operation **that should succeed,**\n     // testing it on all of the indexing methods.\n     //\n-    // DO NOT use this in `should_panic` tests, unless you are testing the macro itself.\n+    // This is not suitable for testing failure on invalid inputs.\n     macro_rules! assert_range_eq {\n         ($s:expr, $range:expr, $expected:expr)\n         => {\n@@ -340,7 +343,7 @@ mod slice_index {\n     // because if it can't, then what are we even doing here?\n     //\n     // (Be aware this only demonstrates the ability to detect bugs\n-    //  in the FIRST method it calls, as the macro is not designed\n+    //  in the FIRST method that panics, as the macro is not designed\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of bounds\")]\n@@ -363,8 +366,8 @@ mod slice_index {\n     // and `None` test cases for get/get_mut.\n     macro_rules! panic_cases {\n         ($(\n-            mod $case_name:ident {\n-                let DATA = $data:expr;\n+            in mod $case_name:ident {\n+                data: $data:expr;\n \n                 // optional:\n                 //\n@@ -373,14 +376,11 @@ mod slice_index {\n                 // straddles the boundary between valid and invalid.\n                 // (such as the input `len..len`, which is just barely valid)\n                 $(\n-                    let GOOD_INPUT = $good:expr;\n-                    let GOOD_OUTPUT = $output:expr;\n+                    good: data[$good:expr] == $output:expr;\n                 )*\n \n-                let BAD_INPUT = $bad:expr;\n-                const EXPECT_MSG = $expect_msg:expr; // must be a literal\n-\n-                !!generate_tests!!\n+                bad: data[$bad:expr];\n+                message: $expect_msg:expr; // must be a literal\n             }\n         )*) => {$(\n             mod $case_name {\n@@ -509,114 +509,72 @@ mod slice_index {\n     }\n \n     panic_cases! {\n-        mod rangefrom_len {\n-            let DATA = \"abcdef\";\n-\n-            let GOOD_INPUT = 6..;\n-            let GOOD_OUTPUT = \"\";\n-\n-            let BAD_INPUT = 7..;\n-            const EXPECT_MSG = \"out of bounds\";\n-\n-            !!generate_tests!!\n+        in mod rangefrom_len {\n+            data: \"abcdef\";\n+            good: data[6..] == \"\";\n+            bad: data[7..];\n+            message: \"out of bounds\";\n         }\n \n-        mod rangeto_len {\n-            let DATA = \"abcdef\";\n-\n-            let GOOD_INPUT = ..6;\n-            let GOOD_OUTPUT = \"abcdef\";\n-\n-            let BAD_INPUT = ..7;\n-            const EXPECT_MSG = \"out of bounds\";\n-\n-            !!generate_tests!!\n+        in mod rangeto_len {\n+            data: \"abcdef\";\n+            good: data[..6] == \"abcdef\";\n+            bad: data[..7];\n+            message: \"out of bounds\";\n         }\n \n-        mod rangetoinclusive_len {\n-            let DATA = \"abcdef\";\n-\n-            let GOOD_INPUT = ..=5;\n-            let GOOD_OUTPUT = \"abcdef\";\n-\n-            let BAD_INPUT = ..=6;\n-            const EXPECT_MSG = \"out of bounds\";\n-\n-            !!generate_tests!!\n+        in mod rangetoinclusive_len {\n+            data: \"abcdef\";\n+            good: data[..=5] == \"abcdef\";\n+            bad: data[..=6];\n+            message: \"out of bounds\";\n         }\n \n-        mod range_len_len {\n-            let DATA = \"abcdef\";\n-\n-            let GOOD_INPUT = 6..6;\n-            let GOOD_OUTPUT = \"\";\n-\n-            let BAD_INPUT = 7..7;\n-            const EXPECT_MSG = \"out of bounds\";\n-\n-            !!generate_tests!!\n+        in mod range_len_len {\n+            data: \"abcdef\";\n+            good: data[6..6] == \"\";\n+            bad: data[7..7];\n+            message: \"out of bounds\";\n         }\n \n-        mod rangeinclusive_len_len {\n-            let DATA = \"abcdef\";\n-\n-            let GOOD_INPUT = 6..=5;\n-            let GOOD_OUTPUT = \"\";\n-\n-            let BAD_INPUT = 7..=6;\n-            const EXPECT_MSG = \"out of bounds\";\n-\n-            !!generate_tests!!\n+        in mod rangeinclusive_len_len {\n+            data: \"abcdef\";\n+            good: data[6..=5] == \"\";\n+            bad: data[7..=6];\n+            message: \"out of bounds\";\n         }\n     }\n \n     panic_cases! {\n-        mod range_neg_width {\n-            let DATA = \"abcdef\";\n-\n-            let GOOD_INPUT = 4..4;\n-            let GOOD_OUTPUT = \"\";\n-\n-            let BAD_INPUT = 4..3;\n-            const EXPECT_MSG = \"begin <= end (4 <= 3)\";\n-\n-            !!generate_tests!!\n+        in mod range_neg_width {\n+            data: \"abcdef\";\n+            good: data[4..4] == \"\";\n+            bad: data[4..3];\n+            message: \"begin <= end (4 <= 3)\";\n         }\n \n-        mod rangeinclusive_neg_width {\n-            let DATA = \"abcdef\";\n-\n-            let GOOD_INPUT = 4..=3;\n-            let GOOD_OUTPUT = \"\";\n-\n-            let BAD_INPUT = 4..=2;\n-            const EXPECT_MSG = \"begin <= end (4 <= 3)\";\n-\n-            !!generate_tests!!\n+        in mod rangeinclusive_neg_width {\n+            data: \"abcdef\";\n+            good: data[4..=3] == \"\";\n+            bad: data[4..=2];\n+            message: \"begin <= end (4 <= 3)\";\n         }\n     }\n \n     mod overflow {\n         panic_cases! {\n-\n-            mod rangeinclusive {\n-                let DATA = \"hello\";\n-\n+            in mod rangeinclusive {\n+                data: \"hello\";\n                 // note: using 0 specifically ensures that the result of overflowing is 0..0,\n                 //       so that `get` doesn't simply return None for the wrong reason.\n-                let BAD_INPUT = 0..=usize::max_value();\n-                const EXPECT_MSG = \"maximum usize\";\n-\n-                !!generate_tests!!\n+                bad: data[0..=usize::max_value()];\n+                message: \"maximum usize\";\n             }\n \n-            mod rangetoinclusive {\n-                let DATA = \"hello\";\n-\n-                let BAD_INPUT = ..=usize::max_value();\n-                const EXPECT_MSG = \"maximum usize\";\n-\n-                !!generate_tests!!\n+            in mod rangetoinclusive {\n+                data: \"hello\";\n+                bad: data[..=usize::max_value()];\n+                message: \"maximum usize\";\n             }\n         }\n     }\n@@ -635,74 +593,53 @@ mod slice_index {\n         // because some of the logic may be duplicated as part of micro-optimizations\n         // to dodge unicode boundary checks on half-ranges.\n         panic_cases! {\n-            mod range_1 {\n-                let DATA = super::DATA;\n-\n-                let BAD_INPUT = super::BAD_START..super::GOOD_END;\n-                const EXPECT_MSG =\n+            in mod range_1 {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..super::GOOD_END];\n+                message:\n                     \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n-\n-                !!generate_tests!!\n             }\n \n-            mod range_2 {\n-                let DATA = super::DATA;\n-\n-                let BAD_INPUT = super::GOOD_START..super::BAD_END;\n-                const EXPECT_MSG =\n+            in mod range_2 {\n+                data: super::DATA;\n+                bad: data[super::GOOD_START..super::BAD_END];\n+                message:\n                     \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n-\n-                !!generate_tests!!\n             }\n \n-            mod rangefrom {\n-                let DATA = super::DATA;\n-\n-                let BAD_INPUT = super::BAD_START..;\n-                const EXPECT_MSG =\n+            in mod rangefrom {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..];\n+                message:\n                     \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n-\n-                !!generate_tests!!\n             }\n \n-            mod rangeto {\n-                let DATA = super::DATA;\n-\n-                let BAD_INPUT = ..super::BAD_END;\n-                const EXPECT_MSG =\n+            in mod rangeto {\n+                data: super::DATA;\n+                bad: data[..super::BAD_END];\n+                message:\n                     \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n-\n-                !!generate_tests!!\n             }\n \n-            mod rangeinclusive_1 {\n-                let DATA = super::DATA;\n-\n-                let BAD_INPUT = super::BAD_START..=super::GOOD_END_INCL;\n-                const EXPECT_MSG =\n+            in mod rangeinclusive_1 {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..=super::GOOD_END_INCL];\n+                message:\n                     \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n-\n-                !!generate_tests!!\n             }\n \n-            mod rangeinclusive_2 {\n-                let DATA = super::DATA;\n-\n-                let BAD_INPUT = super::GOOD_START..=super::BAD_END_INCL;\n-                const EXPECT_MSG =\n+            in mod rangeinclusive_2 {\n+                data: super::DATA;\n+                bad: data[super::GOOD_START..=super::BAD_END_INCL];\n+                message:\n                     \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n-\n-                !!generate_tests!!\n             }\n \n-            mod rangetoinclusive {\n-                let DATA = super::DATA;\n-\n-                let BAD_INPUT = ..=super::BAD_END_INCL;\n-                const EXPECT_MSG =\n+            in mod rangetoinclusive {\n+                data: super::DATA;\n+                bad: data[..=super::BAD_END_INCL];\n+                message:\n                     \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n-\n-                !!generate_tests!!\n             }\n         }\n     }"}]}