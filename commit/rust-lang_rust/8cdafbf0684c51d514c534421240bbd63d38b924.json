{"sha": "8cdafbf0684c51d514c534421240bbd63d38b924", "node_id": "C_kwDOAAsO6NoAKDhjZGFmYmYwNjg0YzUxZDUxNGM1MzQ0MjEyNDBiYmQ2M2QzOGI5MjQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-27T20:46:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-27T20:46:33Z"}, "message": "Rollup merge of #94396 - c410-f3r:yet-more-let-chains, r=Dylan-DPC\n\n1 - Make more use of `let_chains`\n\nContinuation of #94376.\n\ncc #53667", "tree": {"sha": "35d68fa7f55a42a631dc49bad42866f4b5cc289c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35d68fa7f55a42a631dc49bad42866f4b5cc289c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cdafbf0684c51d514c534421240bbd63d38b924", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiG+MpCRBK7hj4Ov3rIwAABu4IAJPcL9kLEKFTiNZoY+n54pV2\na4y1lochK8GtrAwYAMq3tHcvh5gUup3Ik4p8xyTyGYSHHVFOTxefhF/nIXjwMchX\neecFaP2GF52VQWvZPCt2jcW7AasAsdAenwmcpqtI+95W9C20iUWsK+Dlp1PvrZDC\n/sAdFS9+YS0+OOjsmdCYPgOdDEUF3XLa5rOj6vleWUkozVH3R5asRg5m6zPdz13W\n1m/3MQWJfmLwYulUOuv1kAb8Ry1h2nJA6fl+c+osnPJJbEukuKIKd9+cB6pjVAPh\neiAyDQ/al3ZXa2DXc7R0c83Ilq5FRYkbRh4oRLOL1MlcBhD/fO7X9TI3GQh0C5o=\n=NJSg\n-----END PGP SIGNATURE-----\n", "payload": "tree 35d68fa7f55a42a631dc49bad42866f4b5cc289c\nparent 6a705566166debf5eff88c57140df607fa409aaa\nparent ca2ad69143eff606f051aed98422d98a8d4e43d8\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645994793 +0100\ncommitter GitHub <noreply@github.com> 1645994793 +0100\n\nRollup merge of #94396 - c410-f3r:yet-more-let-chains, r=Dylan-DPC\n\n1 - Make more use of `let_chains`\n\nContinuation of #94376.\n\ncc #53667\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cdafbf0684c51d514c534421240bbd63d38b924", "html_url": "https://github.com/rust-lang/rust/commit/8cdafbf0684c51d514c534421240bbd63d38b924", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cdafbf0684c51d514c534421240bbd63d38b924/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a705566166debf5eff88c57140df607fa409aaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a705566166debf5eff88c57140df607fa409aaa", "html_url": "https://github.com/rust-lang/rust/commit/6a705566166debf5eff88c57140df607fa409aaa"}, {"sha": "ca2ad69143eff606f051aed98422d98a8d4e43d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2ad69143eff606f051aed98422d98a8d4e43d8", "html_url": "https://github.com/rust-lang/rust/commit/ca2ad69143eff606f051aed98422d98a8d4e43d8"}], "stats": {"total": 306, "additions": 142, "deletions": 164}, "files": [{"sha": "14a6e686a6424f4585dcec7c3c75d71c5e78e999", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -1054,12 +1054,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut result = Vec::new();\n \n         for ast_bound in ast_bounds {\n-            if let Some(trait_ref) = ast_bound.trait_ref() {\n-                if let Some(trait_did) = trait_ref.trait_def_id() {\n-                    if self.tcx().trait_may_define_assoc_type(trait_did, assoc_name) {\n-                        result.push(ast_bound.clone());\n-                    }\n-                }\n+            if let Some(trait_ref) = ast_bound.trait_ref()\n+                && let Some(trait_did) = trait_ref.trait_def_id()\n+                && self.tcx().trait_may_define_assoc_type(trait_did, assoc_name)\n+            {\n+                result.push(ast_bound.clone());\n             }\n         }\n "}, {"sha": "100d2d07a5c9f8029856572ce40e963364b2e249", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -282,13 +282,12 @@ pub(super) fn check_fn<'a, 'tcx>(\n                         sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n                     }\n \n-                    if let Node::Item(item) = hir.get(fn_id) {\n-                        if let ItemKind::Fn(_, ref generics, _) = item.kind {\n-                            if !generics.params.is_empty() {\n+                    if let Node::Item(item) = hir.get(fn_id)\n+                        && let ItemKind::Fn(_, ref generics, _) = item.kind\n+                        && !generics.params.is_empty()\n+                    {\n                                 sess.span_err(span, \"should have no type parameters\");\n                             }\n-                        }\n-                    }\n                 } else {\n                     let span = sess.source_map().guess_head_span(span);\n                     sess.span_err(span, \"function should have one argument\");\n@@ -319,17 +318,15 @@ pub(super) fn check_fn<'a, 'tcx>(\n                         sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n                     }\n \n-                    if let Node::Item(item) = hir.get(fn_id) {\n-                        if let ItemKind::Fn(_, ref generics, _) = item.kind {\n-                            if !generics.params.is_empty() {\n+                    if let Node::Item(item) = hir.get(fn_id)\n+                        && let ItemKind::Fn(_, ref generics, _) = item.kind\n+                        && !generics.params.is_empty()\n+                    {\n                                 sess.span_err(\n                                     span,\n-                                    \"`#[alloc_error_handler]` function should have no type \\\n-                                     parameters\",\n+                            \"`#[alloc_error_handler]` function should have no type parameters\",\n                                 );\n                             }\n-                        }\n-                    }\n                 } else {\n                     let span = sess.source_map().guess_head_span(span);\n                     sess.span_err(span, \"function should have one argument\");\n@@ -1146,18 +1143,17 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n     if repr.packed() {\n         for attr in tcx.get_attrs(def.did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess, attr) {\n-                if let attr::ReprPacked(pack) = r {\n-                    if let Some(repr_pack) = repr.pack {\n-                        if pack as u64 != repr_pack.bytes() {\n+                if let attr::ReprPacked(pack) = r\n+                    && let Some(repr_pack) = repr.pack\n+                    && pack as u64 != repr_pack.bytes()\n+                {\n                             struct_span_err!(\n                                 tcx.sess,\n                                 sp,\n                                 E0634,\n                                 \"type has conflicting packed representation hints\"\n                             )\n                             .emit();\n-                        }\n-                    }\n                 }\n             }\n         }\n@@ -1399,12 +1395,11 @@ fn display_discriminant_value<'tcx>(\n ) -> String {\n     if let Some(expr) = &variant.disr_expr {\n         let body = &tcx.hir().body(expr.body).value;\n-        if let hir::ExprKind::Lit(lit) = &body.kind {\n-            if let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node {\n-                if evaluated != *lit_value {\n+        if let hir::ExprKind::Lit(lit) = &body.kind\n+            && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n+            && evaluated != *lit_value\n+        {\n                     return format!(\"`{}` (overflowed from `{}`)\", evaluated, lit_value);\n-                }\n-            }\n         }\n     }\n     format!(\"`{}`\", evaluated)"}, {"sha": "c6b14d3e104588d1c928ed34c1b9f94d633d93f3", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -1696,13 +1696,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     }\n \n     fn is_return_ty_unsized<'a>(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n-        if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id) {\n-            if let hir::FnRetTy::Return(ty) = fn_decl.output {\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n-                if let ty::Dynamic(..) = ty.kind() {\n+        if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id)\n+            && let hir::FnRetTy::Return(ty) = fn_decl.output\n+            && let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty)\n+            && let ty::Dynamic(..) = ty.kind()\n+        {\n                     return true;\n-                }\n-            }\n         }\n         false\n     }"}, {"sha": "faead1bf5cd6d504f61135885f97a395f9a0236f", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -587,9 +587,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match (&expr.kind, expected.kind(), checked_ty.kind()) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (exp.kind(), check.kind()) {\n                 (&ty::Str, &ty::Array(arr, _) | &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprKind::Lit(_) = expr.kind {\n-                        if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if replace_prefix(&src, \"b\\\"\", \"\\\"\").is_some() {\n+                    if let hir::ExprKind::Lit(_) = expr.kind\n+                        && let Ok(src) = sm.span_to_snippet(sp)\n+                        && replace_prefix(&src, \"b\\\"\", \"\\\"\").is_some()\n+                    {\n                                 let pos = sp.lo() + BytePos(1);\n                                 return Some((\n                                     sp.with_hi(pos),\n@@ -600,21 +601,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ));\n                             }\n                         }\n-                    }\n-                }\n                 (&ty::Array(arr, _) | &ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprKind::Lit(_) = expr.kind {\n-                        if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if replace_prefix(&src, \"\\\"\", \"b\\\"\").is_some() {\n+                    if let hir::ExprKind::Lit(_) = expr.kind\n+                        && let Ok(src) = sm.span_to_snippet(sp)\n+                        && replace_prefix(&src, \"\\\"\", \"b\\\"\").is_some()\n+                    {\n                                 return Some((\n                                     sp.shrink_to_lo(),\n                                     \"consider adding a leading `b`\",\n                                     \"b\".to_string(),\n                                     Applicability::MachineApplicable,\n                                     true,\n                                 ));\n-                            }\n-                        }\n+\n                     }\n                 }\n                 _ => {}"}, {"sha": "14a1318517a197423edb2a2af0278cd883e94b03", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -810,10 +810,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Use the span of the trailing expression for our cause,\n         // not the span of the entire function\n         if !explicit_return {\n-            if let ExprKind::Block(body, _) = return_expr.kind {\n-                if let Some(last_expr) = body.expr {\n-                    span = last_expr.span;\n-                }\n+            if let ExprKind::Block(body, _) = return_expr.kind && let Some(last_expr) = body.expr {\n+                span = last_expr.span;\n             }\n         }\n         ret_coercion.borrow_mut().coerce("}, {"sha": "76339998a2fbba02b0244fc88cc304970dcbcf8a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -402,25 +402,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n                 );\n             }\n-            if let Some(def_id) = fn_def_id {\n-                if let Some(def_span) = tcx.def_ident_span(def_id) {\n-                    let mut spans: MultiSpan = def_span.into();\n-\n-                    let params = tcx\n-                        .hir()\n-                        .get_if_local(def_id)\n-                        .and_then(|node| node.body_id())\n-                        .into_iter()\n-                        .map(|id| tcx.hir().body(id).params)\n-                        .flatten();\n-\n-                    for param in params {\n-                        spans.push_span_label(param.span, String::new());\n-                    }\n-\n-                    let def_kind = tcx.def_kind(def_id);\n-                    err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+            if let Some(def_id) = fn_def_id && let Some(def_span) = tcx.def_ident_span(def_id) {\n+                let mut spans: MultiSpan = def_span.into();\n+\n+                let params = tcx\n+                    .hir()\n+                    .get_if_local(def_id)\n+                    .and_then(|node| node.body_id())\n+                    .into_iter()\n+                    .map(|id| tcx.hir().body(id).params)\n+                    .flatten();\n+\n+                for param in params {\n+                    spans.push_span_label(param.span, String::new());\n                 }\n+\n+                let def_kind = tcx.def_kind(def_id);\n+                err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n             }\n             if sugg_unit {\n                 let sugg_span = tcx.sess.source_map().end_point(call_expr.span);"}, {"sha": "32de5d23c1ea73149467efd269737ba4c91a50a9", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -430,12 +430,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             actual.prefix_string(self.tcx),\n                             ty_str_reported,\n                         );\n-                        if let Mode::MethodCall = mode {\n-                            if let SelfSource::MethodCall(call) = source {\n-                                self.suggest_await_before_method(\n-                                    &mut err, item_name, actual, call, span,\n-                                );\n-                            }\n+                        if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n+                            self.suggest_await_before_method(\n+                                &mut err, item_name, actual, cal, span,\n+                            );\n                         }\n                         if let Some(span) =\n                             tcx.resolutions(()).confused_type_with_std_module.get(&span)\n@@ -1525,43 +1523,41 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Arc), \"Arc::new\"),\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n-                    if let Some(new_rcvr_t) = *rcvr_ty {\n-                        if let Ok(pick) = self.lookup_probe(\n-                            span,\n-                            item_name,\n-                            new_rcvr_t,\n-                            rcvr,\n-                            crate::check::method::probe::ProbeScope::AllTraits,\n-                        ) {\n-                            debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n-                            let did = Some(pick.item.container.id());\n-                            // We don't want to suggest a container type when the missing\n-                            // method is `.clone()` or `.deref()` otherwise we'd suggest\n-                            // `Arc::new(foo).clone()`, which is far from what the user wants.\n-                            // Explicitly ignore the `Pin::as_ref()` method as `Pin` does not\n-                            // implement the `AsRef` trait.\n-                            let skip = skippable.contains(&did)\n-                                || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name));\n-                            // Make sure the method is defined for the *actual* receiver: we don't\n-                            // want to treat `Box<Self>` as a receiver if it only works because of\n-                            // an autoderef to `&self`\n-                            if pick.autoderefs == 0 && !skip {\n-                                err.span_label(\n-                                    pick.item.ident(self.tcx).span,\n-                                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n-                                );\n-                                err.multipart_suggestion(\n-                                    \"consider wrapping the receiver expression with the \\\n-                                        appropriate type\",\n-                                    vec![\n-                                        (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n-                                        (rcvr.span.shrink_to_hi(), \")\".to_string()),\n-                                    ],\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                // We don't care about the other suggestions.\n-                                alt_rcvr_sugg = true;\n-                            }\n+                    if let Some(new_rcvr_t) = *rcvr_ty && let Ok(pick) = self.lookup_probe(\n+                        span,\n+                        item_name,\n+                        new_rcvr_t,\n+                        rcvr,\n+                        crate::check::method::probe::ProbeScope::AllTraits,\n+                    ) {\n+                        debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n+                        let did = Some(pick.item.container.id());\n+                        // We don't want to suggest a container type when the missing\n+                        // method is `.clone()` or `.deref()` otherwise we'd suggest\n+                        // `Arc::new(foo).clone()`, which is far from what the user wants.\n+                        // Explicitly ignore the `Pin::as_ref()` method as `Pin` does not\n+                        // implement the `AsRef` trait.\n+                        let skip = skippable.contains(&did)\n+                            || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name));\n+                        // Make sure the method is defined for the *actual* receiver: we don't\n+                        // want to treat `Box<Self>` as a receiver if it only works because of\n+                        // an autoderef to `&self`\n+                        if pick.autoderefs == 0 && !skip {\n+                            err.span_label(\n+                                pick.item.ident(self.tcx).span,\n+                                &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                            );\n+                            err.multipart_suggestion(\n+                                \"consider wrapping the receiver expression with the \\\n+                                    appropriate type\",\n+                                vec![\n+                                    (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n+                                    (rcvr.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            // We don't care about the other suggestions.\n+                            alt_rcvr_sugg = true;\n                         }\n                     }\n                 }"}, {"sha": "9963a922268a42f40b20f321968bcda685e02d97", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -685,9 +685,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat<'_>) -> bool {\n-        if let PatKind::Binding(..) = inner.kind {\n-            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::Dynamic(..) = mt.ty.kind() {\n+        if let PatKind::Binding(..) = inner.kind\n+            && let Some(mt) = self.shallow_resolve(expected).builtin_deref(true)\n+            && let ty::Dynamic(..) = mt.ty.kind()\n+        {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);\n@@ -705,8 +706,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.emit();\n                     return false;\n                 }\n-            }\n-        }\n         true\n     }\n "}, {"sha": "88e3e67c99ee39dc8e24ef1932a10c2568a840de", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -190,25 +190,23 @@ crate fn placeholder_type_error<'tcx>(\n         let mut is_fn = false;\n         let mut is_const_or_static = false;\n \n-        if let Some(hir_ty) = hir_ty {\n-            if let hir::TyKind::BareFn(_) = hir_ty.kind {\n-                is_fn = true;\n-\n-                // Check if parent is const or static\n-                let parent_id = tcx.hir().get_parent_node(hir_ty.hir_id);\n-                let parent_node = tcx.hir().get(parent_id);\n-\n-                is_const_or_static = matches!(\n-                    parent_node,\n-                    Node::Item(&hir::Item {\n-                        kind: hir::ItemKind::Const(..) | hir::ItemKind::Static(..),\n-                        ..\n-                    }) | Node::TraitItem(&hir::TraitItem {\n-                        kind: hir::TraitItemKind::Const(..),\n-                        ..\n-                    }) | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n-                );\n-            }\n+        if let Some(hir_ty) = hir_ty && let hir::TyKind::BareFn(_) = hir_ty.kind {\n+            is_fn = true;\n+\n+            // Check if parent is const or static\n+            let parent_id = tcx.hir().get_parent_node(hir_ty.hir_id);\n+            let parent_node = tcx.hir().get(parent_id);\n+\n+            is_const_or_static = matches!(\n+                parent_node,\n+                Node::Item(&hir::Item {\n+                    kind: hir::ItemKind::Const(..) | hir::ItemKind::Static(..),\n+                    ..\n+                }) | Node::TraitItem(&hir::TraitItem {\n+                    kind: hir::TraitItemKind::Const(..),\n+                    ..\n+                }) | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n+            );\n         }\n \n         // if function is wrapped around a const or static,\n@@ -2417,16 +2415,14 @@ fn const_evaluatable_predicates_of<'tcx>(\n     let node = tcx.hir().get(hir_id);\n \n     let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n-    if let hir::Node::Item(item) = node {\n-        if let hir::ItemKind::Impl(ref impl_) = item.kind {\n-            if let Some(of_trait) = &impl_.of_trait {\n-                debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n-                collector.visit_trait_ref(of_trait);\n-            }\n-\n-            debug!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n-            collector.visit_ty(impl_.self_ty);\n+    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(ref impl_) = item.kind {\n+        if let Some(of_trait) = &impl_.of_trait {\n+            debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n+            collector.visit_trait_ref(of_trait);\n         }\n+\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n+        collector.visit_ty(impl_.self_ty);\n     }\n \n     if let Some(generics) = node.generics() {\n@@ -3280,15 +3276,14 @@ fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, id: DefId) -> &'tcx FxHashSet<Sy\n /// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n /// applied to the method prototype.\n fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if let Some(impl_item) = tcx.opt_associated_item(def_id) {\n-        if let ty::AssocItemContainer::ImplContainer(_) = impl_item.container {\n-            if let Some(trait_item) = impl_item.trait_item_def_id {\n-                return tcx\n-                    .codegen_fn_attrs(trait_item)\n-                    .flags\n-                    .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n-            }\n-        }\n+    if let Some(impl_item) = tcx.opt_associated_item(def_id)\n+        && let ty::AssocItemContainer::ImplContainer(_) = impl_item.container\n+        && let Some(trait_item) = impl_item.trait_item_def_id\n+    {\n+        return tcx\n+            .codegen_fn_attrs(trait_item)\n+            .flags\n+            .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n     }\n \n     false"}, {"sha": "de030c5b60bccd2f053733f9fbd97a7ecaab3967", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -55,22 +55,23 @@ This API is completely unstable and subject to change.\n \n */\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n+#![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n+#![feature(hash_drain_filter)]\n #![feature(if_let_guard)]\n #![feature(is_sorted)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(min_specialization)]\n-#![feature(nll)]\n-#![feature(try_blocks)]\n #![feature(never_type)]\n-#![feature(slice_partition_dedup)]\n-#![feature(control_flow_enum)]\n-#![feature(hash_drain_filter)]\n+#![feature(nll)]\n #![feature(once_cell)]\n+#![feature(slice_partition_dedup)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "61ca09f6b982c581d700fb8d1b24fb3bff362a3f", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cdafbf0684c51d514c534421240bbd63d38b924/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=8cdafbf0684c51d514c534421240bbd63d38b924", "patch": "@@ -304,13 +304,12 @@ pub fn check_explicit_predicates<'tcx>(\n         // = X` binding from the object type (there must be such a\n         // binding) and thus infer an outlives requirement that `X:\n         // 'b`.\n-        if let Some(self_ty) = ignored_self_ty {\n-            if let GenericArgKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.walk().any(|arg| arg == self_ty.into()) {\n-                    debug!(\"skipping self ty = {:?}\", &ty);\n-                    continue;\n-                }\n-            }\n+        if let Some(self_ty) = ignored_self_ty\n+            && let GenericArgKind::Type(ty) = outlives_predicate.0.unpack()\n+            && ty.walk().any(|arg| arg == self_ty.into())\n+        {\n+            debug!(\"skipping self ty = {:?}\", &ty);\n+            continue;\n         }\n \n         let predicate = outlives_predicate.subst(tcx, substs);"}]}