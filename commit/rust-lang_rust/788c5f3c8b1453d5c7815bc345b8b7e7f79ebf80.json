{"sha": "788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4OGM1ZjNjOGIxNDUzZDVjNzgxNWJjMzQ1YjhiN2U3Zjc5ZWJmODA=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-06-22T19:36:54Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2018-07-04T21:36:07Z"}, "message": "Revert \"Refactor EvalContext stack and heap into inner struct\"\n\nThis reverts commit 59d21c526c036d7097d05edd6dffdad9c5b1cb62, and uses\ntuple to store the mutable parts of an EvalContext (which now includes\n`Machine`). This requires that `Machine` be `Clone`.", "tree": {"sha": "c7ea8670ae3ffd8c7d99ca239c99ecb53edfd946", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7ea8670ae3ffd8c7d99ca239c99ecb53edfd946"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "html_url": "https://github.com/rust-lang/rust/commit/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6", "html_url": "https://github.com/rust-lang/rust/commit/7f9b01a0fc680943a5c37ee820ae3fbd6abc40f6"}], "stats": {"total": 304, "additions": 131, "deletions": 173}, "files": [{"sha": "e69e7a522ab73e62bfdc7d5014db72f3cb7392a5", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "patch": "@@ -76,8 +76,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n             TyRawPtr(_) => {\n                 Ok(Scalar::Bits {\n-                    bits: self.memory().truncate_to_ptr(v).0 as u128,\n-                    defined: self.memory().pointer_size().bits() as u8,\n+                    bits: self.memory.truncate_to_ptr(v).0 as u128,\n+                    defined: self.memory.pointer_size().bits() as u8,\n                 })\n             },\n \n@@ -92,7 +92,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_ty.sty {\n             // float -> uint\n             TyUint(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory().pointer_size().bits() as usize);\n+                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n                 match fty {\n                     FloatTy::F32 => Ok(Scalar::Bits {\n                         bits: Single::from_bits(bits).to_u128(width).value,\n@@ -106,7 +106,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             },\n             // float -> int\n             TyInt(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory().pointer_size().bits() as usize);\n+                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n                 match fty {\n                     FloatTy::F32 => Ok(Scalar::Bits {\n                         bits: Single::from_bits(bits).to_i128(width).value as u128,"}, {"sha": "e84132f27cc62d66090b1f535c63aa6ec8b80f7f", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "patch": "@@ -88,7 +88,7 @@ pub fn value_to_const_value<'tcx>(\n             Value::ScalarPair(a, b) => Ok(ConstValue::ScalarPair(a, b)),\n             Value::ByRef(ptr, align) => {\n                 let ptr = ptr.to_ptr().unwrap();\n-                let alloc = ecx.memory().get(ptr.alloc_id)?;\n+                let alloc = ecx.memory.get(ptr.alloc_id)?;\n                 assert!(alloc.align.abi() >= align.abi());\n                 assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n                 let mut alloc = alloc.clone();\n@@ -149,7 +149,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     }\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n-    let ptr = ecx.memory_mut().allocate(\n+    let ptr = ecx.memory.allocate(\n         layout.size,\n         layout.align,\n         MemoryKind::Stack,\n@@ -185,6 +185,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     Ok((value, ptr, layout.ty))\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n pub struct CompileTimeEvaluator;\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n@@ -486,7 +487,7 @@ pub fn const_variant_index<'a, 'tcx>(\n     let (ptr, align) = match value {\n         Value::ScalarPair(..) | Value::Scalar(_) => {\n             let layout = ecx.layout_of(val.ty)?;\n-            let ptr = ecx.memory_mut().allocate(layout.size, layout.align, MemoryKind::Stack)?.into();\n+            let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?.into();\n             ecx.write_value_to_ptr(value, ptr, layout.align, val.ty)?;\n             (ptr, layout.align)\n         },\n@@ -515,9 +516,9 @@ pub fn const_value_to_allocation_provider<'a, 'tcx>(\n             ());\n         let value = ecx.const_to_value(val.val)?;\n         let layout = ecx.layout_of(val.ty)?;\n-        let ptr = ecx.memory_mut().allocate(layout.size, layout.align, MemoryKind::Stack)?;\n+        let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?;\n         ecx.write_value_to_ptr(value, ptr.into(), layout.align, val.ty)?;\n-        let alloc = ecx.memory().get(ptr.alloc_id)?;\n+        let alloc = ecx.memory.get(ptr.alloc_id)?;\n         Ok(tcx.intern_const_alloc(alloc.clone()))\n     };\n     result().expect(\"unable to convert ConstValue to Allocation\")"}, {"sha": "85aeb3c7df51a0bb46f78871ad307b6338242921", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 88, "deletions": 121, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "patch": "@@ -34,8 +34,11 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Bounds in scope for polymorphic evaluations.\n     pub param_env: ty::ParamEnv<'tcx>,\n \n-    /// Virtual memory and call stack.\n-    pub(crate) state: EvalState<'a, 'mir, 'tcx, M>,\n+    /// The virtual memory system.\n+    pub memory: Memory<'a, 'mir, 'tcx, M>,\n+\n+    /// The virtual call stack.\n+    pub(crate) stack: Vec<Frame<'mir, 'tcx>>,\n \n     /// The maximum number of stack frames allowed\n     pub(crate) stack_limit: usize,\n@@ -47,50 +50,6 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub(crate) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n }\n \n-pub(crate) struct EvalState<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n-    /// The virtual memory system.\n-    memory: Memory<'a, 'mir, 'tcx, M>,\n-\n-    /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Clone for EvalState<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn clone(&self) -> Self {\n-        EvalState {\n-            memory: self.memory.clone(),\n-            stack: self.stack.clone(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Eq for EvalState<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{}\n-\n-impl<'a, 'mir, 'tcx, M> PartialEq for EvalState<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn eq(&self, other: &Self) -> bool {\n-        self.memory == other.memory\n-            && self.stack == other.stack\n-    }\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Hash for EvalState<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.memory.hash(state);\n-        self.stack.hash(state);\n-    }\n-}\n /// A stack frame.\n #[derive(Clone)]\n pub struct Frame<'mir, 'tcx: 'mir> {\n@@ -180,22 +139,26 @@ impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n     }\n }\n \n+/// The virtual machine state during const-evaluation at a given point in time.\n+type EvalSnapshot<'a, 'mir, 'tcx, M>\n+    = (M, Vec<Frame<'mir, 'tcx>>, Memory<'a, 'mir, 'tcx, M>);\n+\n pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n-    /// The set of all `EvalState` *hashes* observed by this detector.\n+    /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n     ///\n     /// Not a proper bloom filter.\n     bloom: FxHashSet<u64>,\n \n-    /// The set of all `EvalState`s observed by this detector.\n+    /// The set of all `EvalSnapshot`s observed by this detector.\n     ///\n-    /// An `EvalState` will only be fully cloned once it has caused a collision\n+    /// An `EvalSnapshot` will only be fully cloned once it has caused a collision\n     /// in `bloom`. As a result, the detector must observe *two* full cycles of\n     /// an infinite loop before it triggers.\n-    snapshots: FxHashSet<EvalState<'a, 'mir, 'tcx, M>>,\n+    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n }\n \n impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+    where M: Eq + Hash + Machine<'mir, 'tcx>,\n           'tcx: 'a + 'mir,\n {\n     fn default() -> Self {\n@@ -207,10 +170,17 @@ impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n }\n \n impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+    where M: Clone + Eq + Hash + Machine<'mir, 'tcx>,\n           'tcx: 'a + 'mir,\n {\n-    pub fn observe(&mut self, snapshot: &EvalState<'a, 'mir, 'tcx, M>) -> Result<(), (/*TODO*/)> {\n+    pub fn observe(\n+        &mut self,\n+        machine: &M,\n+        stack: &Vec<Frame<'mir, 'tcx>>,\n+        memory: &Memory<'a, 'mir, 'tcx, M>,\n+    ) -> Result<(), (/*TODO*/)> {\n+        let snapshot = (machine, stack, memory);\n+\n         let mut fx = FxHasher::default();\n         snapshot.hash(&mut fx);\n         let hash = fx.finish();\n@@ -220,7 +190,7 @@ impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n             return Ok(())\n         }\n \n-        if self.snapshots.insert(snapshot.clone()) {\n+        if self.snapshots.insert((machine.clone(), stack.clone(), memory.clone())) {\n             // Spurious collision or first cycle\n             return Ok(())\n         }\n@@ -322,26 +292,26 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n         memory_data: M::MemoryData,\n-    ) -> Self {\n+    ) -> Self\n+        where M: Eq + Hash\n+    {\n         EvalContext {\n             machine,\n             tcx,\n             param_env,\n-            state: EvalState {\n-                memory: Memory::new(tcx, memory_data),\n-                stack: Vec::new(),\n-            },\n+            memory: Memory::new(tcx, memory_data),\n+            stack: Vec::new(),\n             stack_limit: tcx.sess.const_eval_stack_frame_limit,\n             loop_detector: Default::default(),\n             steps_until_detector_enabled: MAX_TERMINATORS,\n         }\n     }\n \n     pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n-        let stack = mem::replace(self.stack_mut(), Vec::new());\n+        let stack = mem::replace(&mut self.stack, Vec::new());\n         let steps = mem::replace(&mut self.steps_until_detector_enabled, MAX_TERMINATORS);\n         let r = f(self);\n-        *self.stack_mut() = stack;\n+        self.stack = stack;\n         self.steps_until_detector_enabled = steps;\n         r\n     }\n@@ -350,34 +320,29 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n-        self.memory_mut().allocate(layout.size, layout.align, MemoryKind::Stack)\n+        self.memory.allocate(layout.size, layout.align, MemoryKind::Stack)\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n-        &self.state.memory\n+        &self.memory\n     }\n \n     pub fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n-        &mut self.state.memory\n+        &mut self.memory\n     }\n \n-    #[inline]\n     pub fn stack(&self) -> &[Frame<'mir, 'tcx>] {\n-        &self.state.stack\n-    }\n-\n-    pub fn stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx>> {\n-        &mut self.state.stack\n+        &self.stack\n     }\n \n     #[inline]\n     pub fn cur_frame(&self) -> usize {\n-        assert!(self.stack().len() > 0);\n-        self.stack().len() - 1\n+        assert!(self.stack.len() > 0);\n+        self.stack.len() - 1\n     }\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n-        let ptr = self.memory_mut().allocate_bytes(s.as_bytes());\n+        let ptr = self.memory.allocate_bytes(s.as_bytes());\n         Ok(Scalar::Ptr(ptr).to_value_with_len(s.len() as u64, self.tcx.tcx))\n     }\n \n@@ -395,7 +360,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n             ConstValue::ByRef(alloc, offset) => {\n                 // FIXME: Allocate new AllocId for all constants inside\n-                let id = self.memory_mut().allocate_value(alloc.clone(), MemoryKind::Stack)?;\n+                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n                 Ok(Value::ByRef(Pointer::new(id, offset).into(), alloc.align))\n             },\n             ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a, b)),\n@@ -566,7 +531,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             IndexVec::new()\n         };\n \n-        self.stack_mut().push(Frame {\n+        self.stack.push(Frame {\n             mir,\n             block: mir::START_BLOCK,\n             return_to_block,\n@@ -577,9 +542,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             stmt: 0,\n         });\n \n-        self.memory_mut().cur_frame = self.cur_frame();\n+        self.memory.cur_frame = self.cur_frame();\n \n-        if self.stack().len() > self.stack_limit {\n+        if self.stack.len() > self.stack_limit {\n             err!(StackFrameLimitReached)\n         } else {\n             Ok(())\n@@ -589,18 +554,18 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n         M::end_region(self, None)?;\n-        let frame = self.stack_mut().pop().expect(\n+        let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n-        if !self.stack().is_empty() {\n+        if !self.stack.is_empty() {\n             // TODO: Is this the correct time to start considering these accesses as originating from the returned-to stack frame?\n-            self.memory_mut().cur_frame = self.cur_frame();\n+            self.memory.cur_frame = self.cur_frame();\n         }\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => {\n                 if let Place::Ptr { ptr, .. } = frame.return_place {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    self.memory_mut().mark_static_initialized(\n+                    self.memory.mark_static_initialized(\n                         ptr.to_ptr()?.alloc_id,\n                         mutable,\n                     )?\n@@ -623,8 +588,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         if let Some(Value::ByRef(ptr, _align)) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n-            self.memory().dump_alloc(ptr.alloc_id);\n-            self.memory_mut().deallocate_local(ptr)?;\n+            self.memory.dump_alloc(ptr.alloc_id);\n+            self.memory.deallocate_local(ptr)?;\n         };\n         Ok(())\n     }\n@@ -637,7 +602,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         &mut self,\n         rvalue: &mir::Rvalue<'tcx>,\n         place: &mir::Place<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        where M: Clone + Eq + Hash,\n+    {\n         let dest = self.eval_place(place)?;\n         let dest_ty = self.place_ty(place);\n \n@@ -744,7 +711,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let src = self.eval_place(place)?;\n                 let ty = self.place_ty(place);\n                 let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n-                let defined = self.memory().pointer_size().bits() as u8;\n+                let defined = self.memory.pointer_size().bits() as u8;\n                 self.write_scalar(\n                     dest,\n                     Scalar::Bits {\n@@ -786,7 +753,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n-                let defined = self.memory().pointer_size().bits() as u8;\n+                let defined = self.memory.pointer_size().bits() as u8;\n                 self.write_scalar(\n                     dest,\n                     Scalar::Bits {\n@@ -881,7 +848,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                     def_id,\n                                     substs,\n                                 ).ok_or_else(|| EvalErrorKind::TooGeneric.into());\n-                                let fn_ptr = self.memory_mut().create_fn_alloc(instance?);\n+                                let fn_ptr = self.memory.create_fn_alloc(instance?);\n                                 let valty = ValTy {\n                                     value: Value::Scalar(fn_ptr.into()),\n                                     ty: dest_ty,\n@@ -917,7 +884,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                     substs,\n                                     ty::ClosureKind::FnOnce,\n                                 );\n-                                let fn_ptr = self.memory_mut().create_fn_alloc(instance);\n+                                let fn_ptr = self.memory.create_fn_alloc(instance);\n                                 let valty = ValTy {\n                                     value: Value::Scalar(fn_ptr.into()),\n                                     ty: dest_ty,\n@@ -1194,7 +1161,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n         let new_place = match place {\n             Place::Local { frame, local } => {\n-                match self.stack()[frame].locals[local] {\n+                match self.stack[frame].locals[local] {\n                     None => return err!(DeadLocal),\n                     Some(Value::ByRef(ptr, align)) => {\n                         Place::Ptr {\n@@ -1204,11 +1171,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         }\n                     }\n                     Some(val) => {\n-                        let ty = self.stack()[frame].mir.local_decls[local].ty;\n-                        let ty = self.monomorphize(ty, self.stack()[frame].instance.substs);\n+                        let ty = self.stack[frame].mir.local_decls[local].ty;\n+                        let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let layout = self.layout_of(ty)?;\n                         let ptr = self.alloc_ptr(ty)?;\n-                        self.stack_mut()[frame].locals[local] =\n+                        self.stack[frame].locals[local] =\n                             Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n                         let place = Place::from_ptr(ptr, layout.align);\n                         self.write_value(ValTy { value: val, ty }, place)?;\n@@ -1290,10 +1257,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n \n             Place::Local { frame, local } => {\n-                let dest = self.stack()[frame].get_local(local)?;\n+                let dest = self.stack[frame].get_local(local)?;\n                 self.write_value_possibly_by_val(\n                     src_val,\n-                    |this, val| this.stack_mut()[frame].set_local(local, val),\n+                    |this, val| this.stack[frame].set_local(local, val),\n                     dest,\n                     dest_ty,\n                 )\n@@ -1335,7 +1302,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             } else {\n                 let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n                 let layout = self.layout_of(dest_ty)?;\n-                self.memory_mut().copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size, false)?;\n+                self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size, false)?;\n                 write_dest(self, Value::ByRef(dest_ptr, layout.align))?;\n             }\n         } else {\n@@ -1357,7 +1324,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         trace!(\"write_value_to_ptr: {:#?}, {}, {:#?}\", value, dest_ty, layout);\n         match value {\n             Value::ByRef(ptr, align) => {\n-                self.memory_mut().copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n+                self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n             }\n             Value::Scalar(scalar) => {\n                 let signed = match layout.abi {\n@@ -1370,7 +1337,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout),\n                     }\n                 };\n-                self.memory_mut().write_scalar(dest, dest_align, scalar, layout.size, signed)\n+                self.memory.write_scalar(dest, dest_align, scalar, layout.size, signed)\n             }\n             Value::ScalarPair(a_val, b_val) => {\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n@@ -1383,8 +1350,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let b_offset = a_size.abi_align(b.align(&self));\n                 let b_ptr = dest.ptr_offset(b_offset, &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory_mut().write_scalar(a_ptr, dest_align, a_val, a_size, false)?;\n-                self.memory_mut().write_scalar(b_ptr, dest_align, b_val, b_size, false)\n+                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, false)?;\n+                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, false)\n             }\n         }\n     }\n@@ -1415,20 +1382,20 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         ptr_align: Align,\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n-        let ptr_size = self.memory().pointer_size();\n-        let p: Scalar = self.memory().read_ptr_sized(ptr, ptr_align)?.into();\n+        let ptr_size = self.memory.pointer_size();\n+        let p: Scalar = self.memory.read_ptr_sized(ptr, ptr_align)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(ptr_size, self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n-                    self.memory().read_ptr_sized(extra, ptr_align)?.to_ptr()?,\n+                    self.memory.read_ptr_sized(extra, ptr_align)?.to_ptr()?,\n                 )),\n                 ty::TySlice(..) | ty::TyStr => {\n                     let len = self\n-                        .memory()\n+                        .memory\n                         .read_ptr_sized(extra, ptr_align)?\n                         .to_bits(ptr_size)?;\n                     Ok(p.to_value_with_len(len as u64, self.tcx.tcx))\n@@ -1446,18 +1413,18 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         match ty.sty {\n             ty::TyBool => {\n-                self.memory().read_scalar(ptr, ptr_align, Size::from_bytes(1))?.to_bool()?;\n+                self.memory.read_scalar(ptr, ptr_align, Size::from_bytes(1))?.to_bool()?;\n             }\n             ty::TyChar => {\n-                let c = self.memory().read_scalar(ptr, ptr_align, Size::from_bytes(4))?.to_bits(Size::from_bytes(4))? as u32;\n+                let c = self.memory.read_scalar(ptr, ptr_align, Size::from_bytes(4))?.to_bits(Size::from_bytes(4))? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(..) => (),\n                     None => return err!(InvalidChar(c as u128)),\n                 }\n             }\n \n             ty::TyFnPtr(_) => {\n-                self.memory().read_ptr_sized(ptr, ptr_align)?;\n+                self.memory.read_ptr_sized(ptr, ptr_align)?;\n             },\n             ty::TyRef(_, rty, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: rty, .. }) => {\n@@ -1472,7 +1439,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n                     let size = scalar.value.size(self);\n-                    self.memory().read_scalar(ptr, ptr_align, size)?;\n+                    self.memory.read_scalar(ptr, ptr_align, size)?;\n                 }\n             }\n \n@@ -1493,7 +1460,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub fn try_read_value(&self, ptr: Scalar, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         let layout = self.layout_of(ty)?;\n-        self.memory().check_align(ptr, ptr_align)?;\n+        self.memory.check_align(ptr, ptr_align)?;\n \n         if layout.size.bytes() == 0 {\n             return Ok(Some(Value::Scalar(Scalar::undef())));\n@@ -1506,7 +1473,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n         match layout.abi {\n             layout::Abi::Scalar(..) => {\n-                let scalar = self.memory().read_scalar(ptr, ptr_align, layout.size)?;\n+                let scalar = self.memory.read_scalar(ptr, ptr_align, layout.size)?;\n                 Ok(Some(Value::Scalar(scalar)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n@@ -1515,28 +1482,28 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let a_ptr = ptr;\n                 let b_offset = a_size.abi_align(b.align(self));\n                 let b_ptr = ptr.offset(b_offset, self)?.into();\n-                let a_val = self.memory().read_scalar(a_ptr, ptr_align, a_size)?;\n-                let b_val = self.memory().read_scalar(b_ptr, ptr_align, b_size)?;\n+                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n+                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n                 Ok(Some(Value::ScalarPair(a_val, b_val)))\n             }\n             _ => Ok(None),\n         }\n     }\n \n     pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n-        self.stack().last().expect(\"no call frames exist\")\n+        self.stack.last().expect(\"no call frames exist\")\n     }\n \n     pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n-        self.stack_mut().last_mut().expect(\"no call frames exist\")\n+        self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n     pub(super) fn mir(&self) -> &'mir mir::Mir<'tcx> {\n         self.frame().mir\n     }\n \n     pub fn substs(&self) -> &'tcx Substs<'tcx> {\n-        if let Some(frame) = self.stack().last() {\n+        if let Some(frame) = self.stack.last() {\n             frame.instance.substs\n         } else {\n             Substs::empty()\n@@ -1682,7 +1649,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 }\n                 write!(msg, \":\").unwrap();\n \n-                match self.stack()[frame].get_local(local) {\n+                match self.stack[frame].get_local(local) {\n                     Err(err) => {\n                         if let EvalErrorKind::DeadLocal = err.kind {\n                             write!(msg, \" is dead\").unwrap();\n@@ -1717,13 +1684,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 }\n \n                 trace!(\"{}\", msg);\n-                self.memory().dump_allocs(allocs);\n+                self.memory.dump_allocs(allocs);\n             }\n             Place::Ptr { ptr, align, .. } => {\n                 match ptr {\n                     Scalar::Ptr(ptr) => {\n                         trace!(\"by align({}) ref:\", align.abi());\n-                        self.memory().dump_alloc(ptr.alloc_id);\n+                        self.memory.dump_alloc(ptr.alloc_id);\n                     }\n                     ptr => trace!(\" integral by ref: {:?}\", ptr),\n                 }\n@@ -1736,12 +1703,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     where\n         F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n-        let val = self.stack()[frame].get_local(local)?;\n+        let val = self.stack[frame].get_local(local)?;\n         let new_val = f(self, val)?;\n-        self.stack_mut()[frame].set_local(local, new_val)?;\n+        self.stack[frame].set_local(local, new_val)?;\n         // FIXME(solson): Run this when setting to Undef? (See previous version of this code.)\n-        // if let Value::ByRef(ptr) = self.stack()[frame].get_local(local) {\n-        //     self.memory().deallocate(ptr)?;\n+        // if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n+        //     self.memory.deallocate(ptr)?;\n         // }\n         Ok(())\n     }"}, {"sha": "e8994cdac4c2eabf6cdb536d4d45874f7eef1921", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "patch": "@@ -32,6 +32,7 @@ pub enum MemoryKind<T> {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[derive(Clone)]\n pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n@@ -48,21 +49,6 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'mir, 'tcx, M> Clone for Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn clone(&self) -> Self {\n-        Memory {\n-            data: self.data.clone(),\n-            alloc_kind: self.alloc_kind.clone(),\n-            alloc_map: self.alloc_map.clone(),\n-            cur_frame: self.cur_frame.clone(),\n-            tcx: self.tcx.clone(),\n-        }\n-    }\n-}\n-\n impl<'a, 'mir, 'tcx, M> Eq for Memory<'a, 'mir, 'tcx, M>\n     where M: Machine<'mir, 'tcx>,\n           'tcx: 'a + 'mir,\n@@ -1067,12 +1053,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Me\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n-        self.memory_mut()\n+        &mut self.memory\n     }\n \n     #[inline]\n     fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n-        self.memory()\n+        &self.memory\n     }\n }\n "}, {"sha": "bb8e5c99d499be8fc3e64017db1fff181a851d1a", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 assert_eq!(extra, PlaceExtra::None);\n                 Ok(Value::ByRef(ptr, align))\n             }\n-            Place::Local { frame, local } => self.stack()[frame].get_local(local),\n+            Place::Local { frame, local } => self.stack[frame].get_local(local),\n         }\n     }\n \n@@ -261,7 +261,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let (base_ptr, base_align, base_extra) = match base {\n             Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n             Place::Local { frame, local } => {\n-                match (&self.stack()[frame].get_local(local)?, &base_layout.abi) {\n+                match (&self.stack[frame].get_local(local)?, &base_layout.abi) {\n                     // in case the field covers the entire type, just return the value\n                     (&Value::Scalar(_), &layout::Abi::Scalar(_)) |\n                     (&Value::ScalarPair(..), &layout::Abi::ScalarPair(..))"}, {"sha": "dac7c0610c0ef2e503064086706f2b23f43bd030", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "patch": "@@ -2,18 +2,22 @@\n //!\n //! The main entry point is the `step` method.\n \n+use std::hash::Hash;\n+\n use rustc::mir;\n \n use rustc::mir::interpret::EvalResult;\n use super::{EvalContext, Machine};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n+    where M: Clone + Eq + Hash,\n+{\n     pub fn inc_step_counter_and_detect_loops(&mut self, n: usize) {\n         self.steps_until_detector_enabled\n             = self.steps_until_detector_enabled.saturating_sub(n);\n \n         if self.steps_until_detector_enabled == 0 {\n-            let _ = self.loop_detector.observe(&self.state); // TODO: Handle error\n+            let _ = self.loop_detector.observe(&self.machine, &self.stack, &self.memory); // TODO: Handle error\n \n             // FIXME(#49980): make this warning a lint\n             self.tcx.sess.span_warn(self.frame().span, \"Constant evaluating a complex constant, this might take some time\");\n@@ -23,7 +27,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n     /// Returns true as long as there are more things to do.\n     pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n-        if self.stack().is_empty() {\n+        if self.stack.is_empty() {\n             return Ok(false);\n         }\n \n@@ -57,7 +61,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // *before* executing the statement.\n         let frame_idx = self.cur_frame();\n         self.tcx.span = stmt.source_info.span;\n-        self.memory_mut().tcx.span = stmt.source_info.span;\n+        self.memory.tcx.span = stmt.source_info.span;\n \n         match stmt.kind {\n             Assign(ref place, ref rvalue) => self.eval_rvalue_into_place(rvalue, place)?,\n@@ -106,16 +110,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             InlineAsm { .. } => return err!(InlineAsm),\n         }\n \n-        self.stack_mut()[frame_idx].stmt += 1;\n+        self.stack[frame_idx].stmt += 1;\n         Ok(())\n     }\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<'tcx> {\n         trace!(\"{:?}\", terminator.kind);\n         self.tcx.span = terminator.source_info.span;\n-        self.memory_mut().tcx.span = terminator.source_info.span;\n+        self.memory.tcx.span = terminator.source_info.span;\n         self.eval_terminator(terminator)?;\n-        if !self.stack().is_empty() {\n+        if !self.stack.is_empty() {\n             trace!(\"// {:?}\", self.frame().block);\n         }\n         Ok(())"}, {"sha": "2994b1b387f3fa37c2e47a3621246da76bfbaef9", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let (fn_def, sig) = match func.ty.sty {\n                     ty::TyFnPtr(sig) => {\n                         let fn_ptr = self.value_to_scalar(func)?.to_ptr()?;\n-                        let instance = self.memory().get_fn(fn_ptr)?;\n+                        let instance = self.memory.get_fn(fn_ptr)?;\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n                             ty::TyFnDef(..) => {\n@@ -377,14 +377,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n-                let ptr_size = self.memory().pointer_size();\n+                let ptr_size = self.memory.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(args[0].value)?;\n-                let fn_ptr = self.memory().read_ptr_sized(\n+                let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n                 )?.to_ptr()?;\n-                let instance = self.memory().get_fn(fn_ptr)?;\n+                let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();\n                 let ty = self.layout_of(args[0].ty)?.field(&self, 0)?.ty;\n                 args[0].ty = ty;"}, {"sha": "b6c7feda19fa813377fff50213a3b046deb3b96c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=788c5f3c8b1453d5c7815bc345b8b7e7f79ebf80", "patch": "@@ -25,40 +25,40 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi();\n \n-        let ptr_size = self.memory().pointer_size();\n+        let ptr_size = self.memory.pointer_size();\n         let ptr_align = self.tcx.data_layout.pointer_align;\n         let methods = self.tcx.vtable_methods(trait_ref);\n-        let vtable = self.memory_mut().allocate(\n+        let vtable = self.memory.allocate(\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n             MemoryKind::Stack,\n         )?;\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n-        let drop = self.memory_mut().create_fn_alloc(drop);\n-        self.memory_mut().write_ptr_sized_unsigned(vtable, ptr_align, drop.into())?;\n+        let drop = self.memory.create_fn_alloc(drop);\n+        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, drop.into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory_mut().write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n+        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n             bits: size as u128,\n             defined: ptr_size.bits() as u8,\n         })?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory_mut().write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n+        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n             bits: align as u128,\n             defined: ptr_size.bits() as u8,\n         })?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n-                let fn_ptr = self.memory_mut().create_fn_alloc(instance);\n+                let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory_mut().write_ptr_sized_unsigned(method_ptr, ptr_align, fn_ptr.into())?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, fn_ptr.into())?;\n             }\n         }\n \n-        self.memory_mut().mark_static_initialized(\n+        self.memory.mark_static_initialized(\n             vtable.alloc_id,\n             Mutability::Immutable,\n         )?;\n@@ -76,7 +76,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n             Value::Scalar(Scalar::Bits { bits: 0, defined} ) if defined == pointer_size => Ok(None),\n-            Value::Scalar(Scalar::Ptr(drop_fn)) => self.memory().get_fn(drop_fn).map(Some),\n+            Value::Scalar(Scalar::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n             _ => err!(ReadBytesAsPointer),\n         }\n     }\n@@ -85,10 +85,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         vtable: Pointer,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        let pointer_size = self.memory().pointer_size();\n+        let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory().read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n-        let align = self.memory().read_ptr_sized(\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n+        let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n         )?.to_bits(pointer_size)? as u64;"}]}