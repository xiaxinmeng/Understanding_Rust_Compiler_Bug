{"sha": "65951c969ff843bc3a45c470d5f366498172ebe1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1OTUxYzk2OWZmODQzYmMzYTQ1YzQ3MGQ1ZjM2NjQ5ODE3MmViZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-08T00:04:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-08T00:04:14Z"}, "message": "Auto merge of #7165 - camsteffen:question-mark, r=Manishearth\n\nFix needless_quesiton_mark false positive\n\nchangelog: Fix [`needless_question_mark`] false positive where the inner value is implicity dereferenced by the question mark.\n\nFixes #7107", "tree": {"sha": "eaecb9733ad53906832f372a9cfffbc2381fe742", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaecb9733ad53906832f372a9cfffbc2381fe742"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65951c969ff843bc3a45c470d5f366498172ebe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65951c969ff843bc3a45c470d5f366498172ebe1", "html_url": "https://github.com/rust-lang/rust/commit/65951c969ff843bc3a45c470d5f366498172ebe1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65951c969ff843bc3a45c470d5f366498172ebe1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af8cf9444c5aab898799c75b1db01afa0b28e2bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/af8cf9444c5aab898799c75b1db01afa0b28e2bd", "html_url": "https://github.com/rust-lang/rust/commit/af8cf9444c5aab898799c75b1db01afa0b28e2bd"}, {"sha": "919ed2ba03f6bf7b02df6eda53d1cbfc28161448", "url": "https://api.github.com/repos/rust-lang/rust/commits/919ed2ba03f6bf7b02df6eda53d1cbfc28161448", "html_url": "https://github.com/rust-lang/rust/commit/919ed2ba03f6bf7b02df6eda53d1cbfc28161448"}], "stats": {"total": 124, "additions": 30, "deletions": 94}, "files": [{"sha": "5c9cce6aad42a0df5ef72f804d081c72685ec4d3", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 19, "deletions": 93, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/65951c969ff843bc3a45c470d5f366498172ebe1/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65951c969ff843bc3a45c470d5f366498172ebe1/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=65951c969ff843bc3a45c470d5f366498172ebe1", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, is_lang_ctor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TyS;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -63,12 +62,6 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NeedlessQuestionMark => [NEEDLESS_QUESTION_MARK]);\n \n-#[derive(Debug)]\n-enum SomeOkCall<'a> {\n-    SomeCall(&'a Expr<'a>, &'a Expr<'a>),\n-    OkCall(&'a Expr<'a>, &'a Expr<'a>),\n-}\n-\n impl LateLintPass<'_> for NeedlessQuestionMark {\n     /*\n      * The question mark operator is compatible with both Result<T, E> and Option<T>,\n@@ -90,104 +83,37 @@ impl LateLintPass<'_> for NeedlessQuestionMark {\n      */\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n-        let e = match &expr.kind {\n-            ExprKind::Ret(Some(e)) => e,\n-            _ => return,\n-        };\n-\n-        if let Some(ok_some_call) = is_some_or_ok_call(cx, e) {\n-            emit_lint(cx, &ok_some_call);\n+        if let ExprKind::Ret(Some(e)) = expr.kind {\n+            check(cx, e);\n         }\n     }\n \n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n-        // Function / Closure block\n-        let expr_opt = if let ExprKind::Block(block, _) = &body.value.kind {\n-            block.expr\n-        } else {\n-            // Single line closure\n-            Some(&body.value)\n-        };\n-\n-        if_chain! {\n-            if let Some(expr) = expr_opt;\n-            if let Some(ok_some_call) = is_some_or_ok_call(cx, expr);\n-            then {\n-                emit_lint(cx, &ok_some_call);\n-            }\n-        };\n+        check(cx, body.value.peel_blocks());\n     }\n }\n \n-fn emit_lint(cx: &LateContext<'_>, expr: &SomeOkCall<'_>) {\n-    let (entire_expr, inner_expr) = match expr {\n-        SomeOkCall::OkCall(outer, inner) | SomeOkCall::SomeCall(outer, inner) => (outer, inner),\n+fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    let inner_expr = if_chain! {\n+        if let ExprKind::Call(path, [arg]) = &expr.kind;\n+        if let ExprKind::Path(ref qpath) = &path.kind;\n+        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &arg.kind;\n+        if let ExprKind::Call(called, [inner_expr]) = &inner_expr_with_q.kind;\n+        if let ExprKind::Path(QPath::LangItem(LangItem::TryIntoResult, _)) = &called.kind;\n+        if expr.span.ctxt() == inner_expr.span.ctxt();\n+        let expr_ty = cx.typeck_results().expr_ty(expr);\n+        let inner_ty = cx.typeck_results().expr_ty(inner_expr);\n+        if TyS::same_type(expr_ty, inner_ty);\n+        then { inner_expr } else { return; }\n     };\n-\n     span_lint_and_sugg(\n         cx,\n         NEEDLESS_QUESTION_MARK,\n-        entire_expr.span,\n+        expr.span,\n         \"question mark operator is useless here\",\n         \"try\",\n         format!(\"{}\", snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n         Applicability::MachineApplicable,\n     );\n }\n-\n-fn is_some_or_ok_call<'a>(cx: &'a LateContext<'_>, expr: &'a Expr<'_>) -> Option<SomeOkCall<'a>> {\n-    if_chain! {\n-        // Check outer expression matches CALL_IDENT(ARGUMENT) format\n-        if let ExprKind::Call(path, args) = &expr.kind;\n-        if let ExprKind::Path(ref qpath) = &path.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n-\n-        // Extract inner expression from ARGUMENT\n-        if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;\n-        if let ExprKind::Call(called, args) = &inner_expr_with_q.kind;\n-        if args.len() == 1;\n-\n-        if let ExprKind::Path(QPath::LangItem(LangItem::TryIntoResult, _)) = &called.kind;\n-        then {\n-            // Extract inner expr type from match argument generated by\n-            // question mark operator\n-            let inner_expr = &args[0];\n-\n-            // if the inner expr is inside macro but the outer one is not, do not lint (#6921)\n-            if  differing_macro_contexts(expr.span, inner_expr.span) {\n-                return None;\n-            }\n-\n-            let inner_ty = cx.typeck_results().expr_ty(inner_expr);\n-            let outer_ty = cx.typeck_results().expr_ty(expr);\n-\n-            // Check if outer and inner type are Option\n-            let outer_is_some = is_type_diagnostic_item(cx, outer_ty, sym::option_type);\n-            let inner_is_some = is_type_diagnostic_item(cx, inner_ty, sym::option_type);\n-\n-            // Check for Option MSRV\n-            if outer_is_some && inner_is_some {\n-                return Some(SomeOkCall::SomeCall(expr, inner_expr));\n-            }\n-\n-            // Check if outer and inner type are Result\n-            let outer_is_result = is_type_diagnostic_item(cx, outer_ty, sym::result_type);\n-            let inner_is_result = is_type_diagnostic_item(cx, inner_ty, sym::result_type);\n-\n-            // Additional check: if the error type of the Result can be converted\n-            // via the From trait, then don't match\n-            let does_not_call_from = !has_implicit_error_from(cx, expr, inner_expr);\n-\n-            // Must meet Result MSRV\n-            if outer_is_result && inner_is_result && does_not_call_from {\n-                return Some(SomeOkCall::OkCall(expr, inner_expr));\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn has_implicit_error_from(cx: &LateContext<'_>, entire_expr: &Expr<'_>, inner_result_expr: &Expr<'_>) -> bool {\n-    return cx.typeck_results().expr_ty(entire_expr) != cx.typeck_results().expr_ty(inner_result_expr);\n-}"}, {"sha": "f1fc81aa12b9e7cb6b325f7142a9027602f18483", "filename": "tests/ui/needless_question_mark.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/65951c969ff843bc3a45c470d5f366498172ebe1/tests%2Fui%2Fneedless_question_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/65951c969ff843bc3a45c470d5f366498172ebe1/tests%2Fui%2Fneedless_question_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.fixed?ref=65951c969ff843bc3a45c470d5f366498172ebe1", "patch": "@@ -94,6 +94,11 @@ where\n     Ok(x?)\n }\n \n+// not quite needless\n+fn deref_ref(s: Option<&String>) -> Option<&str> {\n+    Some(s?)\n+}\n+\n fn main() {}\n \n // #6921 if a macro wraps an expr in Some(  ) and the ? is in the macro use,"}, {"sha": "44a0c5f61b5d5f71c9d6d7ebdc3eea35bb423572", "filename": "tests/ui/needless_question_mark.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/65951c969ff843bc3a45c470d5f366498172ebe1/tests%2Fui%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65951c969ff843bc3a45c470d5f366498172ebe1/tests%2Fui%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.rs?ref=65951c969ff843bc3a45c470d5f366498172ebe1", "patch": "@@ -94,6 +94,11 @@ where\n     Ok(x?)\n }\n \n+// not quite needless\n+fn deref_ref(s: Option<&String>) -> Option<&str> {\n+    Some(s?)\n+}\n+\n fn main() {}\n \n // #6921 if a macro wraps an expr in Some(  ) and the ? is in the macro use,"}, {"sha": "fa6982245307d6536269d52ebf5c26a14b4de428", "filename": "tests/ui/needless_question_mark.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65951c969ff843bc3a45c470d5f366498172ebe1/tests%2Fui%2Fneedless_question_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/65951c969ff843bc3a45c470d5f366498172ebe1/tests%2Fui%2Fneedless_question_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.stderr?ref=65951c969ff843bc3a45c470d5f366498172ebe1", "patch": "@@ -67,7 +67,7 @@ LL |         return Ok(t.magic?);\n    |                ^^^^^^^^^^^^ help: try: `t.magic`\n \n error: question mark operator is useless here\n-  --> $DIR/needless_question_mark.rs:115:27\n+  --> $DIR/needless_question_mark.rs:120:27\n    |\n LL |         || -> Option<_> { Some(Some($expr)?) }()\n    |                           ^^^^^^^^^^^^^^^^^^ help: try: `Some($expr)`"}]}