{"sha": "96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZDZmMjJhOGU3ZjA0ZjJhZTA3MTJmNzM1OTQ3MGE3OGM3N2E5ZTA=", "commit": {"author": {"name": "Soveu", "email": "marx.tomasz@gmail.com", "date": "2021-03-15T20:51:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-15T20:51:38Z"}, "message": "Merge branch 'master' into dedup", "tree": {"sha": "1660abccf0df54100751181250e049e830327b3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1660abccf0df54100751181250e049e830327b3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgT8jaCRBK7hj4Ov3rIwAAdHIIAJ9/uhLhmUzywH4hLyWZgx3a\nbOFgToCyn5w4ReUr9sIdD1ody4F7b9Dg3dNV8qxkgIbYW0wjpbtPmTOpp8tub0GS\nbDlVWvswD4dyA+RlLXKkyj0hYafpyjdplcDzDA+EQA2MhpZ47bYolLf2jL6ARYKk\n0el5U/WcJ6K8487/O6iLPRDy/5fvIIAfBYMlBwa/Y/Fk9oE6c/S92WK73un3qKPz\nQ2Kf4UkpQiG8k9MzF/6n7CSVbvktByd5LfxeluuPVzhSCKhGXTUZvB2Fgzh+S3q/\nddr9aaOWmLQFlp/JJSuYhLPMTy2yO0z8ZPCzwO8hW5SoOBWfiW2lSf4SJnh70MY=\n=Hh+5\n-----END PGP SIGNATURE-----\n", "payload": "tree 1660abccf0df54100751181250e049e830327b3c\nparent 2285f11724e2fa3251c94c9ab7672544099600e2\nparent 2ccf06302c08d7d4911aad40e66a9a3ee731c6f9\nauthor Soveu <marx.tomasz@gmail.com> 1615841498 +0100\ncommitter GitHub <noreply@github.com> 1615841498 +0100\n\nMerge branch 'master' into dedup"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "html_url": "https://github.com/rust-lang/rust/commit/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/comments", "author": {"login": "Soveu", "id": 34382234, "node_id": "MDQ6VXNlcjM0MzgyMjM0", "avatar_url": "https://avatars.githubusercontent.com/u/34382234?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Soveu", "html_url": "https://github.com/Soveu", "followers_url": "https://api.github.com/users/Soveu/followers", "following_url": "https://api.github.com/users/Soveu/following{/other_user}", "gists_url": "https://api.github.com/users/Soveu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Soveu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Soveu/subscriptions", "organizations_url": "https://api.github.com/users/Soveu/orgs", "repos_url": "https://api.github.com/users/Soveu/repos", "events_url": "https://api.github.com/users/Soveu/events{/privacy}", "received_events_url": "https://api.github.com/users/Soveu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2285f11724e2fa3251c94c9ab7672544099600e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2285f11724e2fa3251c94c9ab7672544099600e2", "html_url": "https://github.com/rust-lang/rust/commit/2285f11724e2fa3251c94c9ab7672544099600e2"}, {"sha": "2ccf06302c08d7d4911aad40e66a9a3ee731c6f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ccf06302c08d7d4911aad40e66a9a3ee731c6f9", "html_url": "https://github.com/rust-lang/rust/commit/2ccf06302c08d7d4911aad40e66a9a3ee731c6f9"}], "stats": {"total": 102165, "additions": 62577, "deletions": 39588}, "files": [{"sha": "044979f3baec3b3f9eb8fb6bb5043ad7868643b3", "filename": ".github/ISSUE_TEMPLATE/diagnostics.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fdiagnostics.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,46 @@\n+---\n+name: Diagnostic issue\n+about: Create a bug report or feature request for a change to `rustc`'s error output\n+labels: A-diagnostics, T-compiler\n+---\n+<!--\n+Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n+along with any information you feel relevant to replicating the bug.\n+\n+If you cannot produce a minimal reproduction case (something that would work in\n+isolation), please provide the steps or even link to a repository that causes\n+the problematic output to occur. \n+-->\n+\n+Given the following code: <!-- Please provide a link to play.rust-lang.org -->\n+\n+```rust\n+<code>\n+```\n+\n+The current output is:\n+\n+```\n+<rustc output>\n+```\n+\n+<!-- The following is not always necessary. -->\n+Ideally the output should look like:\n+\n+```\n+<proposed output>\n+```\n+\n+<!--\n+If the problem is not self-explanatory, please provide a rationale for the\n+change.\n+-->\n+\n+<!--\n+If dramatically different output is caused by small changes, consider also\n+adding them here.\n+\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions. The output might also be\n+different depending on the Edition.\n+-->"}, {"sha": "99a0c0b4b85de13523646072e0dc3bd8a733ad11", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -63,7 +63,7 @@ jobs:\n         run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n         env:\n           num: \"${{ github.event.number }}\"\n-        if: \"success() && !env.SKIP_JOBS && github.event_name == 'pull_request'\"\n+        if: \"success() && !env.SKIP_JOB && github.event_name == 'pull_request'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n         env:\n@@ -425,7 +425,7 @@ jobs:\n         run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n         env:\n           num: \"${{ github.event.number }}\"\n-        if: \"success() && !env.SKIP_JOBS && github.event_name == 'pull_request'\"\n+        if: \"success() && !env.SKIP_JOB && github.event_name == 'pull_request'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n         env:\n@@ -532,7 +532,7 @@ jobs:\n         run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n         env:\n           num: \"${{ github.event.number }}\"\n-        if: \"success() && !env.SKIP_JOBS && github.event_name == 'pull_request'\"\n+        if: \"success() && !env.SKIP_JOB && github.event_name == 'pull_request'\"\n       - name: add extra environment variables\n         run: src/ci/scripts/setup-environment.sh\n         env:"}, {"sha": "3f77e6884b90f0796b59c3ca3a438d3339bead1f", "filename": ".gitignore", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -7,6 +7,8 @@\n # configure your local ignore list.\n # FIXME: This needs cleanup.\n *~\n+*.swp\n+*.swo\n .#*\n .DS_Store\n .cproject\n@@ -50,4 +52,6 @@ Session.vim\n .cargo\n !/src/test/run-make/thumb-none-qemu/example/.cargo\n no_llvm_build\n+**node_modules\n+**package-lock.json\n # Before adding new lines, see the comment at the top."}, {"sha": "8618f61f04acdc8042dd8e06c8494eed56ee9389", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -37,7 +37,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/11.0-2021-01-05\n+\tbranch = rustc/12.0-2021-02-03\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "3f23aed31a833e2e53f05da145121b45b3673128", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -235,6 +235,7 @@ Philipp Matthias Sch\u00e4fer <philipp.matthias.schaefer@posteo.de>\n Przemys\u0142aw Weso\u0142ek <jest@go.art.pl> Przemek Weso\u0142ek <jest@go.art.pl>\n Rafael \u00c1vila de Esp\u00edndola <respindola@mozilla.com> Rafael Avila de Espindola <espindola@dream.(none)>\n Ralph Giles <giles@thaumas.net> Ralph Giles <giles@mozilla.com>\n+Ramkumar Ramachandra <r@artagnon.com> <artagnon@gmail.com>\n Renato Riccieri Santos Zannon <renato@rrsz.com.br>\n Richard Diamond <wichard@vitalitystudios.com> <wichard@hahbee.co>\n Rob Arnold <robarnold@cs.cmu.edu>"}, {"sha": "2827a46ae6f73e13c34d9159f8f953facd8d3270", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,8 +1,31 @@\n # Contributing to Rust\n \n-Thank you for your interest in contributing to Rust!\n+Thank you for your interest in contributing to Rust! There are many ways to contribute\n+and we appreciate all of them.\n \n-To get started, read the [Contributing to Rust] chapter of the [rustc-dev-guide].\n+Documentation for contributing to Rust is located in the [Guide to Rustc Development](https://rustc-dev-guide.rust-lang.org/),\n+commonly known as the [rustc-dev-guide]. Despite the name, this guide documents\n+not just how to develop rustc (the Rust compiler), but also how to contribute to any part\n+of the Rust project.\n+\n+To get started with contributing, please read the [Contributing to Rust] chapter of the guide.\n+That chapter explains how to get your development environment set up and how to get help.\n+\n+## About the [rustc-dev-guide]\n+\n+The [rustc-dev-guide] is meant to help document how rustc \u2013the Rust compiler\u2013 works,\n+as well as to help new contributors get involved in rustc development. It is recommend\n+to read and understand the [rustc-dev-guide] before making a contribution. This guide\n+talks about the different bots in the Rust ecosystem, the Rust development tools,\n+bootstrapping, the compiler architecture, source code representation, and more.\n+\n+## [Getting help](https://rustc-dev-guide.rust-lang.org/getting-started.html#asking-questions)\n+\n+There are many ways you can get help when you're stuck. Rust has many platforms for this:\n+[internals], [rust-zulip], and [rust-discord]. It is recommended to ask for help on\n+the [rust-zulip], but any of these platforms are a great way to seek help and even\n+find a mentor! You can learn more about asking questions and getting help in the\n+[Asking Questions](https://rustc-dev-guide.rust-lang.org/getting-started.html#asking-questions) chapter of the [rustc-dev-guide].\n \n ## Bug reports\n \n@@ -13,3 +36,6 @@ refer to [this section][contributing-bug-reports] and [open an issue][issue temp\n [rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n [contributing-bug-reports]: https://rustc-dev-guide.rust-lang.org/contributing.html#bug-reports\n [issue template]: https://github.com/rust-lang/rust/issues/new/choose\n+[internals]: https://internals.rust-lang.org\n+[rust-discord]: http://discord.gg/rust-lang\n+[rust-zulip]: https://rust-lang.zulipchat.com"}, {"sha": "203d8acb5b470514e141a80c7022278bfeaeba7a", "filename": "Cargo.lock", "status": "modified", "additions": 304, "deletions": 103, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -37,7 +37,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"compiler_builtins\",\n  \"core\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rand_xorshift\",\n ]\n \n@@ -95,12 +95,6 @@ version = \"1.0.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bf8dcb5b4bbaa28653b647d8c77bd4ed40183b48882e130c1f1ffb73de069fd7\"\n \n-[[package]]\n-name = \"arc-swap\"\n-version = \"0.4.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d25d88fd6b8041580a654f9d0c581a047baee2b3efee13275f2fc392fc75034\"\n-\n [[package]]\n name = \"array_tool\"\n version = \"1.0.3\"\n@@ -177,7 +171,7 @@ dependencies = [\n  \"block-padding\",\n  \"byte-tools\",\n  \"byteorder\",\n- \"generic-array 0.12.3\",\n+ \"generic-array 0.12.4\",\n ]\n \n [[package]]\n@@ -285,7 +279,7 @@ checksum = \"81a18687293a1546b67c246452202bbbf143d239cb43494cc163da14979082da\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.52.0\"\n+version = \"0.53.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -325,6 +319,7 @@ dependencies = [\n  \"openssl\",\n  \"percent-encoding 2.1.0\",\n  \"pretty_env_logger\",\n+ \"rand 0.8.3\",\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n  \"same-file\",\n@@ -533,13 +528,15 @@ dependencies = [\n \n [[package]]\n name = \"chrono\"\n-version = \"0.4.15\"\n+version = \"0.4.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"942f72db697d8767c22d46a598e01f2d3b475501ea43d0db4f16d90259182d0b\"\n+checksum = \"670ad68c9088c2a963aaa298cb369688cf3f9465ce5e2d4ca10e6e0098a1ce73\"\n dependencies = [\n+ \"libc\",\n  \"num-integer\",\n  \"num-traits\",\n  \"time\",\n+ \"winapi 0.3.9\",\n ]\n \n [[package]]\n@@ -565,14 +562,15 @@ dependencies = [\n  \"cargo_metadata 0.12.0\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n- \"compiletest_rs\",\n+ \"compiletest_rs 0.6.0\",\n  \"derive-new\",\n+ \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n  \"semver 0.11.0\",\n  \"serde\",\n  \"tempfile\",\n- \"tester\",\n+ \"tester 0.9.0\",\n ]\n \n [[package]]\n@@ -584,6 +582,7 @@ name = \"clippy_lints\"\n version = \"0.1.52\"\n dependencies = [\n  \"cargo_metadata 0.12.0\",\n+ \"clippy_utils\",\n  \"if_chain\",\n  \"itertools 0.9.0\",\n  \"pulldown-cmark 0.8.0\",\n@@ -600,6 +599,20 @@ dependencies = [\n  \"url 2.1.1\",\n ]\n \n+[[package]]\n+name = \"clippy_utils\"\n+version = \"0.1.52\"\n+dependencies = [\n+ \"if_chain\",\n+ \"itertools 0.9.0\",\n+ \"regex-syntax\",\n+ \"rustc-semver\",\n+ \"serde\",\n+ \"smallvec 1.6.1\",\n+ \"toml\",\n+ \"unicode-normalization\",\n+]\n+\n [[package]]\n name = \"cloudabi\"\n version = \"0.1.0\"\n@@ -661,6 +674,7 @@ dependencies = [\n name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n+ \"colored\",\n  \"diff\",\n  \"getopts\",\n  \"glob\",\n@@ -673,6 +687,7 @@ dependencies = [\n  \"serde_json\",\n  \"tracing\",\n  \"tracing-subscriber\",\n+ \"unified-diff\",\n  \"walkdir\",\n  \"winapi 0.3.9\",\n ]\n@@ -695,7 +710,30 @@ dependencies = [\n  \"serde_derive\",\n  \"serde_json\",\n  \"tempfile\",\n- \"tester\",\n+ \"tester 0.7.0\",\n+ \"winapi 0.3.9\",\n+]\n+\n+[[package]]\n+name = \"compiletest_rs\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0086d6ad78cf409c3061618cd98e2789d5c9ce598fc9651611cf62eae0a599cb\"\n+dependencies = [\n+ \"diff\",\n+ \"filetime\",\n+ \"getopts\",\n+ \"lazy_static\",\n+ \"libc\",\n+ \"log\",\n+ \"miow 0.3.6\",\n+ \"regex\",\n+ \"rustfix\",\n+ \"serde\",\n+ \"serde_derive\",\n+ \"serde_json\",\n+ \"tempfile\",\n+ \"tester 0.9.0\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -715,7 +753,7 @@ checksum = \"245097e9a4535ee1e3e3931fcfcd55a796a44c643e8596ff6566d68f09b87bbc\"\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand\",\n+ \"rand 0.7.3\",\n ]\n \n [[package]]\n@@ -801,15 +839,6 @@ dependencies = [\n  \"scopeguard\",\n ]\n \n-[[package]]\n-name = \"crossbeam-queue\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7c979cd6cfe72335896575c6b5688da489e420d36a27a0b9eb0c73db574b4a4b\"\n-dependencies = [\n- \"crossbeam-utils 0.6.6\",\n-]\n-\n [[package]]\n name = \"crossbeam-queue\"\n version = \"0.2.3\"\n@@ -821,16 +850,6 @@ dependencies = [\n  \"maybe-uninit\",\n ]\n \n-[[package]]\n-name = \"crossbeam-utils\"\n-version = \"0.6.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"04973fa96e96579258a5091af6003abde64af786b860f18622b82e026cca60e6\"\n-dependencies = [\n- \"cfg-if 0.1.10\",\n- \"lazy_static\",\n-]\n-\n [[package]]\n name = \"crossbeam-utils\"\n version = \"0.7.2\"\n@@ -866,6 +885,16 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"cstr\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c11a39d776a3b35896711da8a04dc1835169dcd36f710878187637314e47941b\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+]\n+\n [[package]]\n name = \"ctor\"\n version = \"0.1.15\"\n@@ -953,7 +982,7 @@ version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5\"\n dependencies = [\n- \"generic-array 0.12.3\",\n+ \"generic-array 0.12.4\",\n ]\n \n [[package]]\n@@ -984,14 +1013,35 @@ dependencies = [\n  \"dirs-sys\",\n ]\n \n+[[package]]\n+name = \"dirs-next\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"dirs-sys-next\",\n+]\n+\n [[package]]\n name = \"dirs-sys\"\n version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8e93d7f5705de3e49895a2b5e0b8855a1c27f080192ae9c32a6432d50741a57a\"\n dependencies = [\n  \"libc\",\n- \"redox_users\",\n+ \"redox_users 0.3.4\",\n+ \"winapi 0.3.9\",\n+]\n+\n+[[package]]\n+name = \"dirs-sys-next\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d\"\n+dependencies = [\n+ \"libc\",\n+ \"redox_users 0.4.0\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -1115,7 +1165,7 @@ checksum = \"3ed85775dcc68644b5c950ac06a2b23768d3bc9390464151aaf27136998dcf9e\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"libc\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -1325,9 +1375,9 @@ dependencies = [\n \n [[package]]\n name = \"generic-array\"\n-version = \"0.12.3\"\n+version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c68f0274ae0e023facc3c97b2e00f076be70e254bc851d972503b328db79b2ec\"\n+checksum = \"ffdf9f34f1447443d37393cc6c2b8313aebddcd96906caf34e54c68d8e57d7bd\"\n dependencies = [\n  \"typenum\",\n ]\n@@ -1589,7 +1639,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3ca8957e71f04a205cb162508f9326aea04676c8dfd0711220190d6b83664f3f\"\n dependencies = [\n  \"bitmaps\",\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n  \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n@@ -1698,7 +1748,7 @@ dependencies = [\n  \"regex\",\n  \"serde\",\n  \"serde_json\",\n- \"shlex\",\n+ \"shlex 0.1.1\",\n ]\n \n [[package]]\n@@ -1794,7 +1844,7 @@ dependencies = [\n  \"lazy_static\",\n  \"log\",\n  \"parking_lot\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"serde\",\n ]\n \n@@ -1839,9 +1889,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.85\"\n+version = \"0.2.88\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7ccac4b00700875e6a07c6cde370d44d32fa01c5a65cdd2fca6858c479d28bb3\"\n+checksum = \"03b07a082330a35e43f63177cc01689da34fbffa0105e1246cf0311472cac73a\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -2053,9 +2103,9 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.4.6\"\n+version = \"0.4.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b3d948b64449003363127ed6c6139f03273982c3fe97da4cb3dee933e38ce38f\"\n+checksum = \"28f6a882f3880ec68e96f60d6b543c34941e2f307ad10e2992e4db9acfe96529\"\n dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n@@ -2073,18 +2123,21 @@ dependencies = [\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n- \"shlex\",\n+ \"shlex 1.0.0\",\n  \"tempfile\",\n  \"toml\",\n ]\n \n [[package]]\n name = \"measureme\"\n-version = \"9.0.0\"\n+version = \"9.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22bf8d885d073610aee20e7fa205c4341ed32a761dbde96da5fd96301a8d3e82\"\n+checksum = \"4a98e07fe802486895addb2b5467f33f205e82c426bfaf350f5d8109b137767c\"\n dependencies = [\n+ \"log\",\n+ \"memmap\",\n  \"parking_lot\",\n+ \"perf-event-open-sys\",\n  \"rustc-hash\",\n  \"smallvec 1.6.1\",\n ]\n@@ -2138,9 +2191,9 @@ dependencies = [\n \n [[package]]\n name = \"minifier\"\n-version = \"0.0.33\"\n+version = \"0.0.39\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"70bf0db2475f5e627787da77ca52fe33c294063f49f4134b8bc662eedb5e7332\"\n+checksum = \"6cdf618de5c9c98d4a7b2e0d1f1e44f82a19196cfd94040bb203621c25d28d98\"\n dependencies = [\n  \"macro-utils\",\n ]\n@@ -2226,13 +2279,13 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"colored\",\n- \"compiletest_rs\",\n+ \"compiletest_rs 0.5.0\",\n  \"env_logger 0.7.1\",\n  \"getrandom 0.2.0\",\n  \"hex 0.4.2\",\n  \"libc\",\n  \"log\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n@@ -2432,7 +2485,7 @@ dependencies = [\n  \"log\",\n  \"mio-named-pipes\",\n  \"miow 0.3.6\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"tokio\",\n  \"winapi 0.3.9\",\n ]\n@@ -2458,7 +2511,7 @@ dependencies = [\n  \"cloudabi\",\n  \"instant\",\n  \"libc\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"smallvec 1.6.1\",\n  \"winapi 0.3.9\",\n ]\n@@ -2481,6 +2534,15 @@ version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n \n+[[package]]\n+name = \"perf-event-open-sys\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce9bedf5da2c234fdf2391ede2b90fabf585355f33100689bc364a3ea558561a\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"pest\"\n version = \"2.1.3\"\n@@ -2560,7 +2622,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"17367f0cc86f2d25802b2c26ee58a7b23faeccf78a396094c13dced0d0182526\"\n dependencies = [\n  \"phf_shared\",\n- \"rand\",\n+ \"rand 0.7.3\",\n ]\n \n [[package]]\n@@ -2807,20 +2869,42 @@ checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n  \"getrandom 0.1.14\",\n  \"libc\",\n- \"rand_chacha\",\n- \"rand_core\",\n- \"rand_hc\",\n+ \"rand_chacha 0.2.2\",\n+ \"rand_core 0.5.1\",\n+ \"rand_hc 0.2.0\",\n  \"rand_pcg\",\n ]\n \n+[[package]]\n+name = \"rand\"\n+version = \"0.8.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0ef9e7e66b4468674bfcb0c81af8b7fa0bb154fa9f28eb840da5c447baeb8d7e\"\n+dependencies = [\n+ \"libc\",\n+ \"rand_chacha 0.3.0\",\n+ \"rand_core 0.6.2\",\n+ \"rand_hc 0.3.0\",\n+]\n+\n [[package]]\n name = \"rand_chacha\"\n version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f4c8ed856279c9737206bf725bf36935d8666ead7aa69b52be55af369d193402\"\n dependencies = [\n  \"ppv-lite86\",\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n+]\n+\n+[[package]]\n+name = \"rand_chacha\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e12735cf05c9e10bf21534da50a147b924d555dc7a547c42e6bb2d5b6017ae0d\"\n+dependencies = [\n+ \"ppv-lite86\",\n+ \"rand_core 0.6.2\",\n ]\n \n [[package]]\n@@ -2832,13 +2916,31 @@ dependencies = [\n  \"getrandom 0.1.14\",\n ]\n \n+[[package]]\n+name = \"rand_core\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"34cf66eb183df1c5876e2dcf6b13d57340741e8dc255b48e40a26de954d06ae7\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+]\n+\n [[package]]\n name = \"rand_hc\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\"\n dependencies = [\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n+]\n+\n+[[package]]\n+name = \"rand_hc\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3190ef7066a446f2e7f42e239d161e905420ccab01eb967c9eb27d21b2322a73\"\n+dependencies = [\n+ \"rand_core 0.6.2\",\n ]\n \n [[package]]\n@@ -2847,7 +2949,7 @@ version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429\"\n dependencies = [\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2856,7 +2958,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"77d416b86801d23dde1aa643023b775c3a462efc0ed96443add11546cdf1dca8\"\n dependencies = [\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2865,7 +2967,7 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a9fcdd2e881d02f1d9390ae47ad8e5696a9e4be7b547a1da2afbc61973217004\"\n dependencies = [\n- \"rand_core\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2887,7 +2989,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e92e15d89083484e11353891f1af602cc661426deb9564c298b270c726973280\"\n dependencies = [\n  \"crossbeam-deque\",\n- \"crossbeam-queue 0.2.3\",\n+ \"crossbeam-queue\",\n  \"crossbeam-utils 0.7.2\",\n  \"lazy_static\",\n  \"num_cpus\",\n@@ -2899,17 +3001,36 @@ version = \"0.1.57\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"41cc0f7e4d5d4544e8861606a285bb08d3e70712ccc7d2b84d7c0ccfaf4b05ce\"\n \n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.2.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"94341e4e44e24f6b591b59e47a8a027df12e008d73fd5672dbea9cc22f4507d9\"\n+dependencies = [\n+ \"bitflags\",\n+]\n+\n [[package]]\n name = \"redox_users\"\n version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"09b23093265f8d200fa7b4c2c76297f47e681c655f6f1285a8780d6a022f7431\"\n dependencies = [\n  \"getrandom 0.1.14\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"rust-argon2\",\n ]\n \n+[[package]]\n+name = \"redox_users\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+ \"redox_syscall 0.2.5\",\n+]\n+\n [[package]]\n name = \"regex\"\n version = \"1.4.3\"\n@@ -2978,7 +3099,7 @@ dependencies = [\n  \"num_cpus\",\n  \"ordslice\",\n  \"racer\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rayon\",\n  \"regex\",\n  \"rls-analysis\",\n@@ -3049,7 +3170,7 @@ dependencies = [\n  \"env_logger 0.7.1\",\n  \"futures 0.3.12\",\n  \"log\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rls-data\",\n  \"rls-ipc\",\n  \"serde\",\n@@ -3436,9 +3557,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-rayon\"\n-version = \"0.3.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f32767f90d938f1b7199a174ef249ae1924f6e5bbdb9d112fea141e016f25b3a\"\n+checksum = \"ed7d6a39f8bfd4421ce720918234d1e672b83824c91345b47c93746839cf1629\"\n dependencies = [\n  \"crossbeam-deque\",\n  \"either\",\n@@ -3447,13 +3568,13 @@ dependencies = [\n \n [[package]]\n name = \"rustc-rayon-core\"\n-version = \"0.3.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea2427831f0053ea3ea73559c8eabd893133a51b251d142bacee53c62a288cb3\"\n+checksum = \"e94187d9ea3e8c38fafdbc38acb94eafa7ce155867f6ccb13830466a0d0db8c6\"\n dependencies = [\n  \"crossbeam-deque\",\n- \"crossbeam-queue 0.1.2\",\n- \"crossbeam-utils 0.6.6\",\n+ \"crossbeam-queue\",\n+ \"crossbeam-utils 0.7.2\",\n  \"lazy_static\",\n  \"num_cpus\",\n ]\n@@ -3516,6 +3637,7 @@ dependencies = [\n name = \"rustc_arena\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_data_structures\",\n  \"smallvec 1.6.1\",\n ]\n \n@@ -3620,6 +3742,7 @@ name = \"rustc_codegen_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n+ \"cstr\",\n  \"libc\",\n  \"measureme\",\n  \"rustc-demangle\",\n@@ -3654,7 +3777,6 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"memmap\",\n- \"num_cpus\",\n  \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n@@ -3725,13 +3847,15 @@ dependencies = [\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_mir\",\n+ \"rustc_mir_build\",\n  \"rustc_parse\",\n  \"rustc_plugin_impl\",\n  \"rustc_save_analysis\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_typeck\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n@@ -3829,7 +3953,7 @@ dependencies = [\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3878,6 +4002,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n  \"rustc-rayon\",\n+ \"rustc-rayon-core\",\n  \"rustc_ast\",\n  \"rustc_ast_lowering\",\n  \"rustc_ast_passes\",\n@@ -3890,6 +4015,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_hir\",\n  \"rustc_incremental\",\n+ \"rustc_index\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n@@ -3899,6 +4025,7 @@ dependencies = [\n  \"rustc_passes\",\n  \"rustc_plugin_impl\",\n  \"rustc_privacy\",\n+ \"rustc_query_impl\",\n  \"rustc_resolve\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -4120,6 +4247,7 @@ name = \"rustc_passes\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n+ \"rustc_ast_pretty\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -4165,6 +4293,29 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"rustc_query_impl\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"measureme\",\n+ \"rustc-rayon-core\",\n+ \"rustc_ast\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_middle\",\n+ \"rustc_query_system\",\n+ \"rustc_serialize\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"rustc_query_system\"\n version = \"0.0.0\"\n@@ -4177,6 +4328,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"smallvec 1.6.1\",\n  \"tracing\",\n@@ -4427,13 +4579,17 @@ dependencies = [\n  \"serde_json\",\n  \"smallvec 1.6.1\",\n  \"tempfile\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n+ \"tracing-tree\",\n ]\n \n [[package]]\n name = \"rustdoc-json-types\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n+ \"serde_json\",\n ]\n \n [[package]]\n@@ -4509,6 +4665,12 @@ dependencies = [\n  \"unicode_categories\",\n ]\n \n+[[package]]\n+name = \"rustversion\"\n+version = \"1.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cb5d2a036dc6d2d8fd16fde3498b04306e29bd193bf306a57427019b823d5acd\"\n+\n [[package]]\n name = \"ryu\"\n version = \"1.0.5\"\n@@ -4595,7 +4757,7 @@ version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f301af10236f6df4160f7c3f04eec6dbc70ace82d23326abad5edee88801c6b6\"\n dependencies = [\n- \"semver-parser 0.10.1\",\n+ \"semver-parser 0.10.2\",\n  \"serde\",\n ]\n \n@@ -4607,9 +4769,9 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"semver-parser\"\n-version = \"0.10.1\"\n+version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"42ef146c2ad5e5f4b037cd6ce2ebb775401729b19a82040c1beac9d36c7d1428\"\n+checksum = \"00b0bef5b7f9e0df16536d3961cfb6e84331c065b4066afb39768d0e319411f7\"\n dependencies = [\n  \"pest\",\n ]\n@@ -4706,9 +4868,9 @@ dependencies = [\n \n [[package]]\n name = \"sharded-slab\"\n-version = \"0.0.9\"\n+version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"06d5a3f5166fb5b42a5439f2eee8b9de149e235961e3eb21c5808fc3ea17ff3e\"\n+checksum = \"79c719719ee05df97490f80a45acfc99e5a30ce98a1e4fb67aee422745ae14e3\"\n dependencies = [\n  \"lazy_static\",\n ]\n@@ -4725,13 +4887,18 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fdf1b9db47230893d76faad238fd6097fd6d6a9245cd7a4d90dbd639536bbd2\"\n \n+[[package]]\n+name = \"shlex\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42a568c8f2cd051a4d283bd6eb0343ac214c1b0f1ac19f93e1175b2dee38c73d\"\n+\n [[package]]\n name = \"signal-hook-registry\"\n-version = \"1.2.1\"\n+version = \"1.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3e12110bc539e657a646068aaf5eb5b63af9d0c1f7b29c97113fad80e15f035\"\n+checksum = \"ce32ea0c6c56d5eacaeb814fbed9960547021d3edd010ded1425f180536b20ab\"\n dependencies = [\n- \"arc-swap\",\n  \"libc\",\n ]\n \n@@ -4743,9 +4910,9 @@ checksum = \"fa8f3741c7372e75519bd9346068370c9cdaabcc1f9599cbcf2a2719352286b7\"\n \n [[package]]\n name = \"sized-chunks\"\n-version = \"0.6.2\"\n+version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ec31ceca5644fa6d444cc77548b88b67f46db6f7c71683b0f9336e671830d2f\"\n+checksum = \"65e65d6a9f13cd78f361ea5a2cf53a45d67cdda421ba0316b9be101560f3d207\"\n dependencies = [\n  \"bitmaps\",\n  \"typenum\",\n@@ -4786,7 +4953,7 @@ checksum = \"7fd8b795c389288baa5f355489c65e71fd48a02104600d15c4cfbc561e9e429d\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"libc\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"winapi 0.3.9\",\n ]\n \n@@ -4828,7 +4995,7 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand\",\n+ \"rand 0.7.3\",\n  \"rustc-demangle\",\n  \"unwind\",\n  \"wasi\",\n@@ -4947,7 +5114,7 @@ checksum = \"c8a4c1d0bee3230179544336c15eefb563cf0302955d962e456542323e8c2e8a\"\n dependencies = [\n  \"filetime\",\n  \"libc\",\n- \"redox_syscall\",\n+ \"redox_syscall 0.1.57\",\n  \"xattr\",\n ]\n \n@@ -4959,8 +5126,8 @@ checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n  \"libc\",\n- \"rand\",\n- \"redox_syscall\",\n+ \"rand 0.7.3\",\n+ \"redox_syscall 0.1.57\",\n  \"remove_dir_all\",\n  \"winapi 0.3.9\",\n ]\n@@ -4994,6 +5161,17 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"term\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c59df8ac95d96ff9bede18eb7300b0fda5e5d8d90960e76f8e14ae765eedbf1f\"\n+dependencies = [\n+ \"dirs-next\",\n+ \"rustversion\",\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"1.1.0\"\n@@ -5039,6 +5217,19 @@ dependencies = [\n  \"term 0.6.1\",\n ]\n \n+[[package]]\n+name = \"tester\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0639d10d8f4615f223a57275cf40f9bdb7cfbb806bcb7f7cc56e3beb55a576eb\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"getopts\",\n+ \"libc\",\n+ \"num_cpus\",\n+ \"term 0.7.0\",\n+]\n+\n [[package]]\n name = \"textwrap\"\n version = \"0.11.0\"\n@@ -5172,20 +5363,21 @@ checksum = \"360dfd1d6d30e05fda32ace2c8c70e9c0a9da713275777f5a4dbb8a1893930c6\"\n \n [[package]]\n name = \"tracing\"\n-version = \"0.1.19\"\n+version = \"0.1.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6d79ca061b032d6ce30c660fded31189ca0b9922bf483cd70759f13a2d86786c\"\n+checksum = \"01ebdc2bb4498ab1ab5f5b73c5803825e60199229ccba0698170e3be0e7f959f\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n+ \"pin-project-lite 0.2.4\",\n  \"tracing-attributes\",\n  \"tracing-core\",\n ]\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.11\"\n+version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"80e0ccfc3378da0cce270c946b676a376943f5cd16aeba64568e7939806f4ada\"\n+checksum = \"a8a9bd1db7706f2373a190b0d067146caa39350c486f3d455b0e33b431f94c07\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5203,9 +5395,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-log\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5e0f8c7178e13481ff6765bd169b33e8d554c5d2bbede5e32c356194be02b9b9\"\n+checksum = \"a6923477a48e41c1951f1999ef8bb5a3023eb723ceadafe78ffb65dc366761e3\"\n dependencies = [\n  \"lazy_static\",\n  \"log\",\n@@ -5224,9 +5416,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-subscriber\"\n-version = \"0.2.13\"\n+version = \"0.2.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ef0a5e15477aa303afbfac3a44cba9b6430fdaad52423b1e6c0dbbe28c3eedd\"\n+checksum = \"8ab8966ac3ca27126141f7999361cc97dd6fb4b71da04c02044fa9045d98bb96\"\n dependencies = [\n  \"ansi_term 0.12.1\",\n  \"chrono\",\n@@ -5247,15 +5439,15 @@ dependencies = [\n \n [[package]]\n name = \"tracing-tree\"\n-version = \"0.1.6\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"43aac8afb493b08e1e1904956f7407c1e671b9c83b26a17e1bd83d6a3520e350\"\n+checksum = \"1712b40907f8d9bc2bc66763ab61dec914b7123d7149e59feb0d4e2a95fc4967\"\n dependencies = [\n  \"ansi_term 0.12.1\",\n  \"atty\",\n- \"chrono\",\n  \"termcolor\",\n  \"tracing\",\n+ \"tracing-log\",\n  \"tracing-subscriber\",\n ]\n \n@@ -5360,6 +5552,15 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"39ec24b3121d976906ece63c9daad25b85969647682eee313cb5779fdd69e14e\"\n \n+[[package]]\n+name = \"unified-diff\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"496a3d395ed0c30f411ceace4a91f7d93b148fb5a9b383d5d4cff7850f048d5f\"\n+dependencies = [\n+ \"diff\",\n+]\n+\n [[package]]\n name = \"unstable-book-gen\"\n version = \"0.1.0\""}, {"sha": "5ec94e189f8359c6659923317bb1e8e274dae7f7", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -31,7 +31,7 @@ by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n    * `g++` 5.1 or later or `clang++` 3.5 or later\n    * `python` 3 or 2.7\n    * GNU `make` 3.81 or later\n-   * `cmake` 3.4.3 or later\n+   * `cmake` 3.13.4 or later\n    * `ninja`\n    * `curl`\n    * `git`\n@@ -90,7 +90,7 @@ build.\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n \n-[msys2]: https://msys2.github.io/\n+[msys2]: https://www.msys2.org/\n \n 1. Grab the latest [MSYS2 installer][msys2] and go through the installer.\n "}, {"sha": "5dca7abcb26290408e96f09e7cce771b2ba83b9d", "filename": "RELEASES.md", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -43,6 +43,23 @@ The following previously stable methods are now `const`.\n \n - [`IpAddr::is_ipv4`]\n - [`IpAddr::is_ipv6`]\n+- [`IpAddr::is_unspecified`]\n+- [`IpAddr::is_loopback`]\n+- [`IpAddr::is_multicast`]\n+- [`Ipv4Addr::octets`]\n+- [`Ipv4Addr::is_loopback`]\n+- [`Ipv4Addr::is_private`]\n+- [`Ipv4Addr::is_link_local`]\n+- [`Ipv4Addr::is_multicast`]\n+- [`Ipv4Addr::is_broadcast`]\n+- [`Ipv4Addr::is_documentation`]\n+- [`Ipv4Addr::to_ipv6_compatible`]\n+- [`Ipv4Addr::to_ipv6_mapped`]\n+- [`Ipv6Addr::segments`]\n+- [`Ipv6Addr::is_unspecified`]\n+- [`Ipv6Addr::is_loopback`]\n+- [`Ipv6Addr::is_multicast`]\n+- [`Ipv6Addr::to_ipv4`]\n - [`Layout::size`]\n - [`Layout::align`]\n - [`Layout::from_size_align`]\n@@ -51,7 +68,7 @@ The following previously stable methods are now `const`.\n - `saturating_pow` for all integer types.\n - `wrapping_pow` for all integer types.\n - `next_power_of_two` for all unsigned integer types.\n-- `checked_power_of_two` for all unsigned integer types.\n+- `checked_next_power_of_two` for all unsigned integer types.\n \n Cargo\n -----------------------\n@@ -104,6 +121,23 @@ Compatibility Notes\n [cargo/8725]: https://github.com/rust-lang/cargo/pull/8725\n [`IpAddr::is_ipv4`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_ipv4\n [`IpAddr::is_ipv6`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_ipv6\n+[`IpAddr::is_unspecified`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_unspecified\n+[`IpAddr::is_loopback`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_loopback\n+[`IpAddr::is_multicast`]: https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_multicast\n+[`Ipv4Addr::octets`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.octets\n+[`Ipv4Addr::is_loopback`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_loopback\n+[`Ipv4Addr::is_private`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_private\n+[`Ipv4Addr::is_link_local`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_link_local\n+[`Ipv4Addr::is_multicast`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_multicast\n+[`Ipv4Addr::is_broadcast`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_broadcast\n+[`Ipv4Addr::is_documentation`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.is_documentation\n+[`Ipv4Addr::to_ipv6_compatible`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.to_ipv6_compatible\n+[`Ipv4Addr::to_ipv6_mapped`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv4Addr.html#method.to_ipv6_mapped\n+[`Ipv6Addr::segments`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.segments\n+[`Ipv6Addr::is_unspecified`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.is_unspecified\n+[`Ipv6Addr::is_loopback`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.is_loopback\n+[`Ipv6Addr::is_multicast`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.is_multicast\n+[`Ipv6Addr::to_ipv4`]: https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.to_ipv4\n [`Layout::align`]: https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.align\n [`Layout::from_size_align`]: https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.from_size_align\n [`Layout::size`]: https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.size"}, {"sha": "859028957db5607c42bdb250560ed570048d709e", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     // Note that we're pulling in a static copy of jemalloc which means that to\n     // pull it in we need to actually reference its symbols for it to get\n     // linked. The two crates we link to here, std and rustc_driver, are both\n-    // dynamic libraries. That means to pull in jemalloc we need to actually\n+    // dynamic libraries. That means to pull in jemalloc we actually need to\n     // reference allocation symbols one way or another (as this file is the only\n     // object code in the rustc executable).\n     #[cfg(feature = \"jemalloc-sys\")]\n@@ -24,6 +24,20 @@ fn main() {\n         static _F5: unsafe extern \"C\" fn(*mut c_void, usize) -> *mut c_void = jemalloc_sys::realloc;\n         #[used]\n         static _F6: unsafe extern \"C\" fn(*mut c_void) = jemalloc_sys::free;\n+\n+        // On OSX, jemalloc doesn't directly override malloc/free, but instead\n+        // registers itself with the allocator's zone APIs in a ctor. However,\n+        // the linker doesn't seem to consider ctors as \"used\" when statically\n+        // linking, so we need to explicitly depend on the function.\n+        #[cfg(target_os = \"macos\")]\n+        {\n+            extern \"C\" {\n+                fn _rjem_je_zone_register();\n+            }\n+\n+            #[used]\n+            static _F7: unsafe extern \"C\" fn() = _rjem_je_zone_register;\n+        }\n     }\n \n     rustc_driver::set_sigpipe_handler();"}, {"sha": "5d4d47527d3da7ce2e2acd59a727e4549f041ba5", "filename": "compiler/rustc_arena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -5,4 +5,5 @@ version = \"0.0.0\"\n edition = \"2018\"\n \n [dependencies]\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "a9917f50cc2021caa6b75c873f0cde837c68164f", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -14,10 +14,10 @@\n #![feature(dropck_eyepatch)]\n #![feature(new_uninit)]\n #![feature(maybe_uninit_slice)]\n-#![cfg_attr(bootstrap, feature(min_const_generics))]\n #![feature(min_specialization)]\n #![cfg_attr(test, feature(test))]\n \n+use rustc_data_structures::sync;\n use smallvec::SmallVec;\n \n use std::alloc::Layout;\n@@ -557,8 +557,19 @@ struct DropType {\n     obj: *mut u8,\n }\n \n-unsafe fn drop_for_type<T>(to_drop: *mut u8) {\n-    std::ptr::drop_in_place(to_drop as *mut T)\n+// SAFETY: we require `T: Send` before type-erasing into `DropType`.\n+#[cfg(parallel_compiler)]\n+unsafe impl sync::Send for DropType {}\n+\n+impl DropType {\n+    #[inline]\n+    unsafe fn new<T: sync::Send>(obj: *mut T) -> Self {\n+        unsafe fn drop_for_type<T>(to_drop: *mut u8) {\n+            std::ptr::drop_in_place(to_drop as *mut T)\n+        }\n+\n+        DropType { drop_fn: drop_for_type::<T>, obj: obj as *mut u8 }\n+    }\n }\n \n impl Drop for DropType {\n@@ -586,21 +597,26 @@ pub struct DropArena {\n \n impl DropArena {\n     #[inline]\n-    pub unsafe fn alloc<T>(&self, object: T) -> &mut T {\n+    pub unsafe fn alloc<T>(&self, object: T) -> &mut T\n+    where\n+        T: sync::Send,\n+    {\n         let mem = self.arena.alloc_raw(Layout::new::<T>()) as *mut T;\n         // Write into uninitialized memory.\n         ptr::write(mem, object);\n         let result = &mut *mem;\n         // Record the destructor after doing the allocation as that may panic\n         // and would cause `object`'s destructor to run twice if it was recorded before.\n-        self.destructors\n-            .borrow_mut()\n-            .push(DropType { drop_fn: drop_for_type::<T>, obj: result as *mut T as *mut u8 });\n+        self.destructors.borrow_mut().push(DropType::new(result));\n         result\n     }\n \n     #[inline]\n-    pub unsafe fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+    pub unsafe fn alloc_from_iter<T, I>(&self, iter: I) -> &mut [T]\n+    where\n+        T: sync::Send,\n+        I: IntoIterator<Item = T>,\n+    {\n         let mut vec: SmallVec<[_; 8]> = iter.into_iter().collect();\n         if vec.is_empty() {\n             return &mut [];\n@@ -621,8 +637,7 @@ impl DropArena {\n         // Record the destructors after doing the allocation as that may panic\n         // and would cause `object`'s destructor to run twice if it was recorded before.\n         for i in 0..len {\n-            destructors\n-                .push(DropType { drop_fn: drop_for_type::<T>, obj: start_ptr.add(i) as *mut u8 });\n+            destructors.push(DropType::new(start_ptr.add(i)));\n         }\n \n         slice::from_raw_parts_mut(start_ptr, len)"}, {"sha": "a934bdd79801b3c082bba8781f311f00d78934a4", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 35, "deletions": 115, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -486,8 +486,8 @@ pub struct WhereEqPredicate {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n-    pub module: Mod,\n     pub attrs: Vec<Attribute>,\n+    pub items: Vec<P<Item>>,\n     pub span: Span,\n     /// The order of items in the HIR is unrelated to the order of\n     /// items in the AST. However, we generate proc macro harnesses\n@@ -915,16 +915,6 @@ impl Stmt {\n         }\n     }\n \n-    pub fn tokens_mut(&mut self) -> Option<&mut LazyTokenStream> {\n-        match self.kind {\n-            StmtKind::Local(ref mut local) => local.tokens.as_mut(),\n-            StmtKind::Item(ref mut item) => item.tokens.as_mut(),\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => expr.tokens.as_mut(),\n-            StmtKind::Empty => None,\n-            StmtKind::MacCall(ref mut mac) => mac.tokens.as_mut(),\n-        }\n-    }\n-\n     pub fn has_trailing_semicolon(&self) -> bool {\n         match &self.kind {\n             StmtKind::Semi(_) => true,\n@@ -1083,7 +1073,7 @@ pub struct Expr {\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Expr, 120);\n \n impl Expr {\n@@ -1139,6 +1129,14 @@ impl Expr {\n         }\n     }\n \n+    pub fn peel_parens(&self) -> &Expr {\n+        let mut expr = self;\n+        while let ExprKind::Paren(inner) = &expr.kind {\n+            expr = &inner;\n+        }\n+        expr\n+    }\n+\n     /// Attempts to reparse as `Ty` (for diagnostic purposes).\n     pub fn to_ty(&self) -> Option<P<Ty>> {\n         let kind = match &self.kind {\n@@ -1979,7 +1977,7 @@ bitflags::bitflags! {\n     }\n }\n \n-#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, PartialOrd, Encodable, Decodable, Debug, Hash, HashStable_Generic)]\n pub enum InlineAsmTemplatePiece {\n     String(String),\n     Placeholder { operand_idx: usize, modifier: Option<char>, span: Span },\n@@ -2067,7 +2065,7 @@ pub struct InlineAsm {\n /// Inline assembly dialect.\n ///\n /// E.g., `\"intel\"` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, Hash, HashStable_Generic)]\n pub enum LlvmAsmDialect {\n     Att,\n     Intel,\n@@ -2299,21 +2297,22 @@ impl FnRetTy {\n     }\n }\n \n-/// Module declaration.\n-///\n-/// E.g., `mod foo;` or `mod foo { .. }`.\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n+pub enum Inline {\n+    Yes,\n+    No,\n+}\n+\n+/// Module item kind.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct Mod {\n-    /// A span from the first token past `{` to the last token until `}`.\n-    /// For `mod foo;`, the inner span ranges from the first token\n-    /// to the last token in the external file.\n-    pub inner: Span,\n-    /// `unsafe` keyword accepted syntactically for macro DSLs, but not\n-    /// semantically by Rust.\n-    pub unsafety: Unsafe,\n-    pub items: Vec<P<Item>>,\n-    /// `true` for `mod foo { .. }`; `false` for `mod foo;`.\n-    pub inline: bool,\n+pub enum ModKind {\n+    /// Module with inlined definition `mod foo { ... }`,\n+    /// or with definition outlined to a separate file `mod foo;` and already loaded from it.\n+    /// The inner span is from the first token past `{` to the last token until `}`,\n+    /// or from the first to the last token in the loaded file.\n+    Loaded(Vec<P<Item>>, Inline, Span),\n+    /// Module with definition outlined to a separate file `mod foo;` but not yet loaded from it.\n+    Unloaded,\n }\n \n /// Foreign module declaration.\n@@ -2694,7 +2693,7 @@ pub enum ItemKind {\n     /// A use declaration item (`use`).\n     ///\n     /// E.g., `use foo;`, `use foo::bar;` or `use foo::bar as FooBar;`.\n-    Use(P<UseTree>),\n+    Use(UseTree),\n     /// A static item (`static`).\n     ///\n     /// E.g., `static FOO: i32 = 42;` or `static FOO: &'static str = \"bar\";`.\n@@ -2710,13 +2709,15 @@ pub enum ItemKind {\n     /// A module declaration (`mod`).\n     ///\n     /// E.g., `mod foo;` or `mod foo { .. }`.\n-    Mod(Mod),\n+    /// `unsafe` keyword on modules is accepted syntactically for macro DSLs, but not\n+    /// semantically by Rust.\n+    Mod(Unsafe, ModKind),\n     /// An external module (`extern`).\n     ///\n     /// E.g., `extern {}` or `extern \"C\" {}`.\n     ForeignMod(ForeignMod),\n     /// Module-level inline assembly (from `global_asm!()`).\n-    GlobalAsm(P<GlobalAsm>),\n+    GlobalAsm(GlobalAsm),\n     /// A type alias (`type`).\n     ///\n     /// E.g., `type Foo = Bar<u8>;`.\n@@ -2754,7 +2755,7 @@ pub enum ItemKind {\n     MacroDef(MacroDef),\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ItemKind, 112);\n \n impl ItemKind {\n@@ -2828,7 +2829,7 @@ pub enum AssocItemKind {\n     MacCall(MacCall),\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(AssocItemKind, 72);\n \n impl AssocItemKind {\n@@ -2880,7 +2881,7 @@ pub enum ForeignItemKind {\n     MacCall(MacCall),\n }\n \n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ForeignItemKind, 72);\n \n impl From<ForeignItemKind> for ItemKind {\n@@ -2909,84 +2910,3 @@ impl TryFrom<ItemKind> for ForeignItemKind {\n }\n \n pub type ForeignItem = Item<ForeignItemKind>;\n-\n-pub trait HasTokens {\n-    /// Called by `Parser::collect_tokens` to store the collected\n-    /// tokens inside an AST node\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream);\n-}\n-\n-impl<T: HasTokens + 'static> HasTokens for P<T> {\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        (**self).finalize_tokens(tokens);\n-    }\n-}\n-\n-impl<T: HasTokens> HasTokens for Option<T> {\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        if let Some(inner) = self {\n-            inner.finalize_tokens(tokens);\n-        }\n-    }\n-}\n-\n-impl HasTokens for Attribute {\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        match &mut self.kind {\n-            AttrKind::Normal(_, attr_tokens) => {\n-                if attr_tokens.is_none() {\n-                    *attr_tokens = Some(tokens);\n-                }\n-            }\n-            AttrKind::DocComment(..) => {\n-                panic!(\"Called finalize_tokens on doc comment attr {:?}\", self)\n-            }\n-        }\n-    }\n-}\n-\n-impl HasTokens for Stmt {\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        let stmt_tokens = match self.kind {\n-            StmtKind::Local(ref mut local) => &mut local.tokens,\n-            StmtKind::Item(ref mut item) => &mut item.tokens,\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => &mut expr.tokens,\n-            StmtKind::Empty => return,\n-            StmtKind::MacCall(ref mut mac) => &mut mac.tokens,\n-        };\n-        if stmt_tokens.is_none() {\n-            *stmt_tokens = Some(tokens);\n-        }\n-    }\n-}\n-\n-macro_rules! derive_has_tokens {\n-    ($($ty:path),*) => { $(\n-        impl HasTokens for $ty {\n-            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-                if self.tokens.is_none() {\n-                    self.tokens = Some(tokens);\n-                }\n-            }\n-        }\n-    )* }\n-}\n-\n-derive_has_tokens! {\n-    Item, Expr, Ty, AttrItem, Visibility, Path, Block, Pat\n-}\n-\n-macro_rules! derive_has_attrs_no_tokens {\n-    ($($ty:path),*) => { $(\n-        impl HasTokens for $ty {\n-            fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {}\n-        }\n-    )* }\n-}\n-\n-// These ast nodes only support inert attributes, so they don't\n-// store tokens (since nothing can observe them)\n-derive_has_attrs_no_tokens! {\n-    StructField, Arm,\n-    Field, FieldPat, Variant, Param, GenericParam\n-}"}, {"sha": "a71f2ac9815012389303ed77e4284dd6db61ebc0", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,199 @@\n+use super::ptr::P;\n+use super::tokenstream::LazyTokenStream;\n+use super::{Arm, Field, FieldPat, GenericParam, Param, StructField, Variant};\n+use super::{AssocItem, Expr, ForeignItem, Item, Local};\n+use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n+use super::{AttrVec, Attribute, Stmt, StmtKind};\n+\n+/// An `AstLike` represents an AST node (or some wrapper around\n+/// and AST node) which stores some combination of attributes\n+/// and tokens.\n+pub trait AstLike: Sized {\n+    fn attrs(&self) -> &[Attribute];\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n+}\n+\n+impl<T: AstLike + 'static> AstLike for P<T> {\n+    fn attrs(&self) -> &[Attribute] {\n+        (**self).attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        (**self).visit_attrs(f);\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        (**self).tokens_mut()\n+    }\n+}\n+\n+fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    crate::mut_visit::visit_clobber(attrs, |attrs| {\n+        let mut vec = attrs.into();\n+        f(&mut vec);\n+        vec.into()\n+    });\n+}\n+\n+impl AstLike for StmtKind {\n+    fn attrs(&self) -> &[Attribute] {\n+        match self {\n+            StmtKind::Local(local) => local.attrs(),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.attrs(),\n+            StmtKind::Item(item) => item.attrs(),\n+            StmtKind::Empty => &[],\n+            StmtKind::MacCall(mac) => &mac.attrs,\n+        }\n+    }\n+\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        match self {\n+            StmtKind::Local(local) => local.visit_attrs(f),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n+            StmtKind::Item(item) => item.visit_attrs(f),\n+            StmtKind::Empty => {}\n+            StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n+        }\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match self {\n+            StmtKind::Local(local) => &mut local.tokens,\n+            StmtKind::Item(item) => &mut item.tokens,\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => &mut expr.tokens,\n+            StmtKind::Empty => return None,\n+            StmtKind::MacCall(mac) => &mut mac.tokens,\n+        })\n+    }\n+}\n+\n+impl AstLike for Stmt {\n+    fn attrs(&self) -> &[Attribute] {\n+        self.kind.attrs()\n+    }\n+\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.kind.visit_attrs(f);\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.kind.tokens_mut()\n+    }\n+}\n+\n+impl AstLike for Attribute {\n+    fn attrs(&self) -> &[Attribute] {\n+        &[]\n+    }\n+    fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match &mut self.kind {\n+            AttrKind::Normal(_, tokens) => tokens,\n+            kind @ AttrKind::DocComment(..) => {\n+                panic!(\"Called tokens_mut on doc comment attr {:?}\", kind)\n+            }\n+        })\n+    }\n+}\n+\n+impl<T: AstLike> AstLike for Option<T> {\n+    fn attrs(&self) -> &[Attribute] {\n+        self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        if let Some(inner) = self.as_mut() {\n+            inner.visit_attrs(f);\n+        }\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.as_mut().and_then(|inner| inner.tokens_mut())\n+    }\n+}\n+\n+/// Helper trait for the macros below. Abstracts over\n+/// the two types of attribute fields that AST nodes\n+/// may have (`Vec<Attribute>` or `AttrVec`)\n+trait VecOrAttrVec {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+}\n+\n+impl VecOrAttrVec for Vec<Attribute> {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        f(self)\n+    }\n+}\n+\n+impl VecOrAttrVec for AttrVec {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        visit_attrvec(self, f)\n+    }\n+}\n+\n+macro_rules! derive_has_tokens_and_attrs {\n+    ($($ty:path),*) => { $(\n+        impl AstLike for $ty {\n+            fn attrs(&self) -> &[Attribute] {\n+                &self.attrs\n+            }\n+\n+            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+                VecOrAttrVec::visit(&mut self.attrs, f)\n+            }\n+\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                Some(&mut self.tokens)\n+            }\n+        }\n+    )* }\n+}\n+\n+macro_rules! derive_has_attrs_no_tokens {\n+    ($($ty:path),*) => { $(\n+        impl AstLike for $ty {\n+            fn attrs(&self) -> &[Attribute] {\n+                &self.attrs\n+            }\n+\n+            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+                VecOrAttrVec::visit(&mut self.attrs, f)\n+            }\n+\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                None\n+            }\n+        }\n+    )* }\n+}\n+\n+macro_rules! derive_has_tokens_no_attrs {\n+    ($($ty:path),*) => { $(\n+        impl AstLike for $ty {\n+            fn attrs(&self) -> &[Attribute] {\n+                &[]\n+            }\n+\n+            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n+\n+            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                Some(&mut self.tokens)\n+            }\n+        }\n+    )* }\n+}\n+\n+// These AST nodes support both inert and active\n+// attributes, so they also have tokens.\n+derive_has_tokens_and_attrs! {\n+    Item, Expr, Local, AssocItem, ForeignItem\n+}\n+\n+// These ast nodes only support inert attributes, so they don't\n+// store tokens (since nothing can observe them)\n+derive_has_attrs_no_tokens! {\n+    StructField, Arm,\n+    Field, FieldPat, Variant, Param, GenericParam\n+}\n+\n+// These AST nodes don't support attributes, but can\n+// be captured by a `macro_rules!` matcher. Therefore,\n+// they need to store tokens.\n+derive_has_tokens_no_attrs! {\n+    Ty, Block, AttrItem, Pat, Path, Visibility\n+}"}, {"sha": "40b0cefd83aa6eed57093418bbf46d659cb49361", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 104, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,17 +1,15 @@\n //! Functions dealing with attributes and meta items.\n \n use crate::ast;\n-use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n-use crate::ast::{Expr, GenericParam, Item, Lit, LitKind, Local, Stmt, StmtKind};\n+use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n+use crate::ast::{Lit, LitKind};\n use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n-use crate::mut_visit::visit_clobber;\n-use crate::ptr::P;\n use crate::token::{self, CommentKind, Token};\n use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream, TokenTree, TreeAndSpacing};\n \n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_span::source_map::{BytePos, Spanned};\n+use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n@@ -36,7 +34,7 @@ impl MarkedAttrs {\n }\n \n pub fn is_known_lint_tool(m_item: Ident) -> bool {\n-    [sym::clippy, sym::rustc].contains(&m_item.name)\n+    [sym::clippy, sym::rustc, sym::rustdoc].contains(&m_item.name)\n }\n \n impl NestedMetaItem {\n@@ -122,6 +120,7 @@ impl NestedMetaItem {\n }\n \n impl Attribute {\n+    #[inline]\n     pub fn has_name(&self, name: Symbol) -> bool {\n         match self.kind {\n             AttrKind::Normal(ref item, _) => item.path == name,\n@@ -617,101 +616,3 @@ impl NestedMetaItem {\n         MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }\n-\n-pub trait HasAttrs: Sized {\n-    fn attrs(&self) -> &[Attribute];\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-}\n-\n-impl<T: HasAttrs> HasAttrs for Spanned<T> {\n-    fn attrs(&self) -> &[Attribute] {\n-        self.node.attrs()\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        self.node.visit_attrs(f);\n-    }\n-}\n-\n-impl HasAttrs for Vec<Attribute> {\n-    fn attrs(&self) -> &[Attribute] {\n-        self\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        f(self)\n-    }\n-}\n-\n-impl HasAttrs for AttrVec {\n-    fn attrs(&self) -> &[Attribute] {\n-        self\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        visit_clobber(self, |this| {\n-            let mut vec = this.into();\n-            f(&mut vec);\n-            vec.into()\n-        });\n-    }\n-}\n-\n-impl<T: HasAttrs + 'static> HasAttrs for P<T> {\n-    fn attrs(&self) -> &[Attribute] {\n-        (**self).attrs()\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        (**self).visit_attrs(f);\n-    }\n-}\n-\n-impl HasAttrs for StmtKind {\n-    fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            StmtKind::Local(ref local) => local.attrs(),\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n-            StmtKind::Item(ref item) => item.attrs(),\n-            StmtKind::Empty => &[],\n-            StmtKind::MacCall(ref mac) => mac.attrs.attrs(),\n-        }\n-    }\n-\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        match self {\n-            StmtKind::Local(local) => local.visit_attrs(f),\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n-            StmtKind::Item(item) => item.visit_attrs(f),\n-            StmtKind::Empty => {}\n-            StmtKind::MacCall(mac) => {\n-                mac.attrs.visit_attrs(f);\n-            }\n-        }\n-    }\n-}\n-\n-impl HasAttrs for Stmt {\n-    fn attrs(&self) -> &[ast::Attribute] {\n-        self.kind.attrs()\n-    }\n-\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        self.kind.visit_attrs(f);\n-    }\n-}\n-\n-macro_rules! derive_has_attrs {\n-    ($($ty:path),*) => { $(\n-        impl HasAttrs for $ty {\n-            fn attrs(&self) -> &[Attribute] {\n-                &self.attrs\n-            }\n-\n-            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-                self.attrs.visit_attrs(f);\n-            }\n-        }\n-    )* }\n-}\n-\n-derive_has_attrs! {\n-    Item, Expr, Local, ast::AssocItem, ast::ForeignItem, ast::StructField, ast::Arm,\n-    ast::Field, ast::FieldPat, ast::Variant, ast::Param, GenericParam\n-}"}, {"sha": "03ec4b8a44da66158774d9d7d4b2fa6906c3441d", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -40,8 +40,8 @@ pub mod util {\n }\n \n pub mod ast;\n+pub mod ast_like;\n pub mod attr;\n-pub mod crate_disambiguator;\n pub mod entry;\n pub mod expand;\n pub mod mut_visit;\n@@ -52,6 +52,7 @@ pub mod tokenstream;\n pub mod visit;\n \n pub use self::ast::*;\n+pub use self::ast_like::AstLike;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "c286738811ca13c27648c1da000c6ed5f72bb64b", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -170,10 +170,6 @@ pub trait MutVisitor: Sized {\n         noop_visit_ty_constraint(t, self);\n     }\n \n-    fn visit_mod(&mut self, m: &mut Mod) {\n-        noop_visit_mod(m, self);\n-    }\n-\n     fn visit_foreign_mod(&mut self, nm: &mut ForeignMod) {\n         noop_visit_foreign_mod(nm, self);\n     }\n@@ -917,7 +913,13 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_generics(generics);\n             visit_opt(body, |body| vis.visit_block(body));\n         }\n-        ItemKind::Mod(m) => vis.visit_mod(m),\n+        ItemKind::Mod(_unsafety, mod_kind) => match mod_kind {\n+            ModKind::Loaded(items, _inline, inner_span) => {\n+                vis.visit_span(inner_span);\n+                items.flat_map_in_place(|item| vis.flat_map_item(item));\n+            }\n+            ModKind::Unloaded => {}\n+        },\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n         ItemKind::GlobalAsm(_ga) => {}\n         ItemKind::TyAlias(box TyAliasKind(_, generics, bounds, ty)) => {\n@@ -998,14 +1000,10 @@ pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n     vis.visit_asyncness(asyncness);\n }\n \n-pub fn noop_visit_mod<T: MutVisitor>(module: &mut Mod, vis: &mut T) {\n-    let Mod { inner, unsafety: _, items, inline: _ } = module;\n-    vis.visit_span(inner);\n-    items.flat_map_in_place(|item| vis.flat_map_item(item));\n-}\n-\n+// FIXME: Avoid visiting the crate as a `Mod` item, flat map only the inner items if possible,\n+// or make crate visiting first class if necessary.\n pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n-    visit_clobber(krate, |Crate { module, attrs, span, proc_macros }| {\n+    visit_clobber(krate, |Crate { attrs, items, span, proc_macros }| {\n         let item_vis =\n             Visibility { kind: VisibilityKind::Public, span: span.shrink_to_lo(), tokens: None };\n         let item = P(Item {\n@@ -1014,19 +1012,20 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n             id: DUMMY_NODE_ID,\n             vis: item_vis,\n             span,\n-            kind: ItemKind::Mod(module),\n+            kind: ItemKind::Mod(Unsafe::No, ModKind::Loaded(items, Inline::Yes, span)),\n             tokens: None,\n         });\n         let items = vis.flat_map_item(item);\n \n         let len = items.len();\n         if len == 0 {\n-            let module = Mod { inner: span, unsafety: Unsafe::No, items: vec![], inline: true };\n-            Crate { module, attrs: vec![], span, proc_macros }\n+            Crate { attrs: vec![], items: vec![], span, proc_macros }\n         } else if len == 1 {\n             let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n             match kind {\n-                ItemKind::Mod(module) => Crate { module, attrs, span, proc_macros },\n+                ItemKind::Mod(_, ModKind::Loaded(items, ..)) => {\n+                    Crate { attrs, items, span, proc_macros }\n+                }\n                 _ => panic!(\"visitor converted a module to not a module\"),\n             }\n         } else {"}, {"sha": "093f7f2668c4644be1abf12a75df6f0d154ee712", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -11,11 +11,9 @@ use crate::tokenstream::TokenTree;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n-use rustc_span::hygiene::ExpnKind;\n-use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{self, edition::Edition, FileName, RealFileName, Span, DUMMY_SP};\n+use rustc_span::{self, edition::Edition, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n \n@@ -244,7 +242,7 @@ pub enum TokenKind {\n }\n \n // `TokenKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(TokenKind, 16);\n \n #[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n@@ -682,7 +680,7 @@ pub enum Nonterminal {\n }\n \n // `Nonterminal` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Nonterminal, 48);\n \n #[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable)]\n@@ -813,52 +811,6 @@ impl Nonterminal {\n         }\n         false\n     }\n-\n-    // See issue #74616 for details\n-    pub fn ident_name_compatibility_hack(\n-        &self,\n-        orig_span: Span,\n-        source_map: &SourceMap,\n-    ) -> Option<(Ident, bool)> {\n-        if let NtIdent(ident, is_raw) = self {\n-            if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n-                let filename = source_map.span_to_filename(orig_span);\n-                if let FileName::Real(RealFileName::Named(path)) = filename {\n-                    let matches_prefix = |prefix, filename| {\n-                        // Check for a path that ends with 'prefix*/src/<filename>'\n-                        let mut iter = path.components().rev();\n-                        iter.next().and_then(|p| p.as_os_str().to_str()) == Some(filename)\n-                            && iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"src\")\n-                            && iter\n-                                .next()\n-                                .and_then(|p| p.as_os_str().to_str())\n-                                .map_or(false, |p| p.starts_with(prefix))\n-                    };\n-\n-                    if (macro_name == sym::impl_macros\n-                        && matches_prefix(\"time-macros-impl\", \"lib.rs\"))\n-                        || (macro_name == sym::arrays && matches_prefix(\"js-sys\", \"lib.rs\"))\n-                    {\n-                        let snippet = source_map.span_to_snippet(orig_span);\n-                        if snippet.as_deref() == Ok(\"$name\") {\n-                            return Some((*ident, *is_raw));\n-                        }\n-                    }\n-\n-                    if macro_name == sym::tuple_from_req\n-                        && (matches_prefix(\"actix-web\", \"extract.rs\")\n-                            || matches_prefix(\"actori-web\", \"extract.rs\"))\n-                    {\n-                        let snippet = source_map.span_to_snippet(orig_span);\n-                        if snippet.as_deref() == Ok(\"$T\") {\n-                            return Some((*ident, *is_raw));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n }\n \n impl PartialEq for Nonterminal {"}, {"sha": "c5c3142602b9bb57083fcfa599f661987ed9faee", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -189,7 +189,7 @@ pub struct TokenStream(pub(crate) Lrc<Vec<TreeAndSpacing>>);\n pub type TreeAndSpacing = (TokenTree, Spacing);\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(TokenStream, 8);\n \n #[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable)]"}, {"sha": "32b9dd46baef446dc6b2f78d88e6393de49f4133", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -74,7 +74,7 @@ impl<'a> FnKind<'a> {\n /// Each method of the `Visitor` trait is a hook to be potentially\n /// overridden. Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n-/// e.g., the `visit_mod` method by default calls `visit::walk_mod`.\n+/// e.g., the `visit_item` method by default calls `visit::walk_item`.\n ///\n /// If you want to ensure that your code handles every variant\n /// explicitly, you need to override each method. (And you also need\n@@ -87,9 +87,6 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_ident(&mut self, ident: Ident) {\n         walk_ident(self, ident);\n     }\n-    fn visit_mod(&mut self, m: &'ast Mod, _s: Span, _attrs: &[Attribute], _n: NodeId) {\n-        walk_mod(self, m);\n-    }\n     fn visit_foreign_item(&mut self, i: &'ast ForeignItem) {\n         walk_foreign_item(self, i)\n     }\n@@ -238,14 +235,10 @@ pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, ident: Ident) {\n }\n \n pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n-    visitor.visit_mod(&krate.module, krate.span, &krate.attrs, CRATE_NODE_ID);\n+    walk_list!(visitor, visit_item, &krate.items);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n }\n \n-pub fn walk_mod<'a, V: Visitor<'a>>(visitor: &mut V, module: &'a Mod) {\n-    walk_list!(visitor, visit_item, &module.items);\n-}\n-\n pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n     for attr in local.attrs.iter() {\n         visitor.visit_attribute(attr);\n@@ -297,7 +290,12 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             let kind = FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n-        ItemKind::Mod(ref module) => visitor.visit_mod(module, item.span, &item.attrs, item.id),\n+        ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n+            ModKind::Loaded(items, _inline, _inner_span) => {\n+                walk_list!(visitor, visit_item, items)\n+            }\n+            ModKind::Unloaded => {}\n+        },\n         ItemKind::ForeignMod(ref foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }"}, {"sha": "43b93d03ff6fb958f2224cbcc3666e47f798b14c", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 128, "deletions": 48, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,7 +9,9 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n+use rustc_hir::definitions::DefPathData;\n use rustc_session::parse::feature_err;\n+use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{hygiene::ForLoopLoc, DUMMY_SP};\n@@ -42,8 +44,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n                 ExprKind::Call(ref f, ref args) => {\n-                    let f = self.lower_expr(f);\n-                    hir::ExprKind::Call(f, self.lower_exprs(args))\n+                    if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n+                        self.lower_legacy_const_generics((**f).clone(), args.clone(), &legacy_args)\n+                    } else {\n+                        let f = self.lower_expr(f);\n+                        hir::ExprKind::Call(f, self.lower_exprs(args))\n+                    }\n                 }\n                 ExprKind::MethodCall(ref seg, ref args, span) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n@@ -91,6 +97,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     ExprKind::Let(ref pat, ref scrutinee) => {\n                         self.lower_expr_if_let(e.span, pat, scrutinee, then, else_opt.as_deref())\n                     }\n+                    ExprKind::Paren(ref paren) => match paren.peel_parens().kind {\n+                        ExprKind::Let(ref pat, ref scrutinee) => {\n+                            // A user has written `if (let Some(x) = foo) {`, we want to avoid\n+                            // confusing them with mentions of nightly features.\n+                            // If this logic is changed, you will also likely need to touch\n+                            // `unused::UnusedParens::check_expr`.\n+                            self.if_let_expr_with_parens(cond, &paren.peel_parens());\n+                            self.lower_expr_if_let(\n+                                e.span,\n+                                pat,\n+                                scrutinee,\n+                                then,\n+                                else_opt.as_deref(),\n+                            )\n+                        }\n+                        _ => self.lower_expr_if(cond, then, else_opt.as_deref()),\n+                    },\n                     _ => self.lower_expr_if(cond, then, else_opt.as_deref()),\n                 },\n                 ExprKind::While(ref cond, ref body, opt_label) => self\n@@ -235,9 +258,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ex.span = e.span;\n                     }\n                     // Merge attributes into the inner expression.\n-                    let mut attrs: Vec<_> = e.attrs.iter().map(|a| self.lower_attr(a)).collect();\n-                    attrs.extend::<Vec<_>>(ex.attrs.into());\n-                    ex.attrs = attrs.into();\n+                    if !e.attrs.is_empty() {\n+                        let old_attrs = self.attrs.get(&ex.hir_id).map(|la| *la).unwrap_or(&[]);\n+                        self.attrs.insert(\n+                            ex.hir_id,\n+                            &*self.arena.alloc_from_iter(\n+                                e.attrs\n+                                    .iter()\n+                                    .map(|a| self.lower_attr(a))\n+                                    .chain(old_attrs.iter().cloned()),\n+                            ),\n+                        );\n+                    }\n                     return ex;\n                 }\n \n@@ -249,12 +281,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n \n-            hir::Expr {\n-                hir_id: self.lower_node_id(e.id),\n-                kind,\n-                span: e.span,\n-                attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n-            }\n+            let hir_id = self.lower_node_id(e.id);\n+            self.lower_attrs(hir_id, &e.attrs);\n+            hir::Expr { hir_id, kind, span: e.span }\n         })\n     }\n \n@@ -292,6 +321,73 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n+    fn lower_legacy_const_generics(\n+        &mut self,\n+        mut f: Expr,\n+        args: Vec<AstP<Expr>>,\n+        legacy_args_idx: &[usize],\n+    ) -> hir::ExprKind<'hir> {\n+        let path = match f.kind {\n+            ExprKind::Path(None, ref mut path) => path,\n+            _ => unreachable!(),\n+        };\n+\n+        // Split the arguments into const generics and normal arguments\n+        let mut real_args = vec![];\n+        let mut generic_args = vec![];\n+        for (idx, arg) in args.into_iter().enumerate() {\n+            if legacy_args_idx.contains(&idx) {\n+                let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n+                let node_id = self.resolver.next_node_id();\n+\n+                // Add a definition for the in-band const def.\n+                self.resolver.create_def(\n+                    parent_def_id,\n+                    node_id,\n+                    DefPathData::AnonConst,\n+                    ExpnId::root(),\n+                    arg.span,\n+                );\n+\n+                let anon_const = AnonConst { id: node_id, value: arg };\n+                generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));\n+            } else {\n+                real_args.push(arg);\n+            }\n+        }\n+\n+        // Add generic args to the last element of the path.\n+        let last_segment = path.segments.last_mut().unwrap();\n+        assert!(last_segment.args.is_none());\n+        last_segment.args = Some(AstP(GenericArgs::AngleBracketed(AngleBracketedArgs {\n+            span: DUMMY_SP,\n+            args: generic_args,\n+        })));\n+\n+        // Now lower everything as normal.\n+        let f = self.lower_expr(&f);\n+        hir::ExprKind::Call(f, self.lower_exprs(&real_args))\n+    }\n+\n+    fn if_let_expr_with_parens(&mut self, cond: &Expr, paren: &Expr) {\n+        let start = cond.span.until(paren.span);\n+        let end = paren.span.shrink_to_hi().until(cond.span.shrink_to_hi());\n+        self.sess\n+            .struct_span_err(\n+                vec![start, end],\n+                \"invalid parentheses around `let` expression in `if let`\",\n+            )\n+            .multipart_suggestion(\n+                \"`if let` needs to be written without parentheses\",\n+                vec![(start, String::new()), (end, String::new())],\n+                rustc_errors::Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        // Ideally, we'd remove the feature gating of a `let` expression since we are already\n+        // complaining about it here, but `feature_gate::check_crate` has already run by now:\n+        // self.sess.parse_sess.gated_spans.ungate_last(sym::let_chains, paren.span);\n+    }\n+\n     /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n@@ -302,8 +398,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         if self.sess.opts.unstable_features.is_nightly_build() {\n             self.sess\n                 .struct_span_err(span, \"`let` expressions are not supported here\")\n-                .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n-                .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                .note(\n+                    \"only supported directly without parentheses in conditions of `if`- and \\\n+                     `while`-expressions, as well as in `let` chains within parentheses\",\n+                )\n                 .emit();\n         } else {\n             self.sess\n@@ -347,8 +445,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         macro_rules! make_if {\n             ($opt:expr) => {{\n+                let cond = self.lower_expr(cond);\n                 let then_expr = self.lower_block_expr(then);\n-                hir::ExprKind::If(self.lower_expr(cond), self.arena.alloc(then_expr), $opt)\n+                hir::ExprKind::If(cond, self.arena.alloc(then_expr), $opt)\n             }};\n         }\n         if let Some(rslt) = else_opt {\n@@ -525,14 +624,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::Guard::If(self.lower_expr(cond))\n             }\n         });\n-        hir::Arm {\n-            hir_id: self.next_id(),\n-            attrs: self.lower_attrs(&arm.attrs),\n-            pat,\n-            guard,\n-            body: self.lower_expr(&arm.body),\n-            span: arm.span,\n-        }\n+        let hir_id = self.next_id();\n+        self.lower_attrs(hir_id, &arm.attrs);\n+        hir::Arm { hir_id, pat, guard, body: self.lower_expr(&arm.body), span: arm.span }\n     }\n \n     /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n@@ -576,7 +670,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Ident::with_dummy_span(sym::_task_context),\n             hir::BindingAnnotation::Mutable,\n         );\n-        let param = hir::Param { attrs: &[], hir_id: self.next_id(), pat, ty_span: span, span };\n+        let param = hir::Param { hir_id: self.next_id(), pat, ty_span: span, span };\n         let params = arena_vec![self; param];\n \n         let body_id = self.lower_body(move |this| {\n@@ -597,12 +691,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             span,\n             Some(hir::Movability::Static),\n         );\n-        let generator = hir::Expr {\n-            hir_id: self.lower_node_id(closure_node_id),\n-            kind: generator_kind,\n-            span,\n-            attrs: ThinVec::new(),\n-        };\n+        let generator =\n+            hir::Expr { hir_id: self.lower_node_id(closure_node_id), kind: generator_kind, span };\n \n         // `future::from_generator`:\n         let unstable_span =\n@@ -756,7 +846,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir_id: loop_hir_id,\n             kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop, span),\n             span,\n-            attrs: ThinVec::new(),\n         });\n \n         // mut pinned => loop { ... }\n@@ -933,7 +1022,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // Introduce a `let` for destructuring: `let (lhs1, lhs2) = t`.\n         let destructure_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             whole_span,\n             Some(rhs),\n             pat,\n@@ -1692,7 +1781,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             desugared_span,\n             None,\n             next_pat,\n@@ -1702,7 +1791,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `let <pat> = __next`\n         let pat = self.lower_pat(pat);\n         let pat_let = self.stmt_let_pat(\n-            ThinVec::new(),\n+            None,\n             desugared_span,\n             Some(next_expr),\n             pat,\n@@ -1726,12 +1815,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::LoopSource::ForLoop,\n             e.span.with_hi(orig_head_span.hi()),\n         );\n-        let loop_expr = self.arena.alloc(hir::Expr {\n-            hir_id: self.lower_node_id(e.id),\n-            kind,\n-            span: e.span,\n-            attrs: ThinVec::new(),\n-        });\n+        let loop_expr =\n+            self.arena.alloc(hir::Expr { hir_id: self.lower_node_id(e.id), kind, span: e.span });\n \n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n@@ -2066,21 +2151,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         kind: hir::ExprKind<'hir>,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n-        hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n+        let hir_id = self.next_id();\n+        self.lower_attrs(hir_id, &attrs);\n+        hir::Expr { hir_id, kind, span }\n     }\n \n     fn field(&mut self, ident: Ident, expr: &'hir hir::Expr<'hir>, span: Span) -> hir::Field<'hir> {\n         hir::Field { hir_id: self.next_id(), ident, span, expr, is_shorthand: false }\n     }\n \n     fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n-        hir::Arm {\n-            hir_id: self.next_id(),\n-            attrs: &[],\n-            pat,\n-            guard: None,\n-            span: expr.span,\n-            body: expr,\n-        }\n+        hir::Arm { hir_id: self.next_id(), pat, guard: None, span: expr.span, body: expr }\n     }\n }"}, {"sha": "f656325f68181cf8150c43c375969147e66068c8", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 113, "deletions": 102, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -15,11 +15,11 @@ use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n-\n use smallvec::{smallvec, SmallVec};\n-use std::collections::BTreeSet;\n use tracing::debug;\n \n+use std::mem;\n+\n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n }\n@@ -34,43 +34,32 @@ impl ItemLowerer<'_, '_, '_> {\n }\n \n impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n-    fn visit_mod(&mut self, m: &'a Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n-        let hir_id = self.lctx.lower_node_id(n);\n-\n-        self.lctx.modules.insert(\n-            hir_id,\n-            hir::ModuleItems {\n-                items: BTreeSet::new(),\n-                trait_items: BTreeSet::new(),\n-                impl_items: BTreeSet::new(),\n-                foreign_items: BTreeSet::new(),\n-            },\n-        );\n-\n-        let old = self.lctx.current_module;\n-        self.lctx.current_module = hir_id;\n-        visit::walk_mod(self, m);\n-        self.lctx.current_module = old;\n-    }\n-\n     fn visit_item(&mut self, item: &'a Item) {\n         let mut item_hir_id = None;\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             lctx.without_in_scope_lifetime_defs(|lctx| {\n                 if let Some(hir_item) = lctx.lower_item(item) {\n-                    item_hir_id = Some(hir_item.hir_id);\n-                    lctx.insert_item(hir_item);\n+                    let id = lctx.insert_item(hir_item);\n+                    item_hir_id = Some(id);\n                 }\n             })\n         });\n \n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl(box ImplKind { ref of_trait, .. }) = item.kind {\n-                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n-                } else {\n-                    visit::walk_item(this, item);\n+                match item.kind {\n+                    ItemKind::Mod(..) => {\n+                        let def_id = this.lctx.lower_node_id(item.id).expect_owner();\n+                        let old_current_module =\n+                            mem::replace(&mut this.lctx.current_module, def_id);\n+                        visit::walk_item(this, item);\n+                        this.lctx.current_module = old_current_module;\n+                    }\n+                    ItemKind::Impl(box ImplKind { ref of_trait, .. }) => {\n+                        this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n+                    }\n+                    _ => visit::walk_item(this, item),\n                 }\n             });\n         }\n@@ -92,15 +81,15 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n             AssocCtxt::Trait => {\n                 let hir_item = lctx.lower_trait_item(item);\n-                let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n+                let id = hir_item.trait_item_id();\n                 lctx.trait_items.insert(id, hir_item);\n-                lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n+                lctx.modules.entry(lctx.current_module).or_default().trait_items.insert(id);\n             }\n             AssocCtxt::Impl => {\n                 let hir_item = lctx.lower_impl_item(item);\n-                let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n+                let id = hir_item.impl_item_id();\n                 lctx.impl_items.insert(id, hir_item);\n-                lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n+                lctx.modules.entry(lctx.current_module).or_default().impl_items.insert(id);\n             }\n         });\n \n@@ -111,9 +100,9 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         self.lctx.allocate_hir_id_counter(item.id);\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             let hir_item = lctx.lower_foreign_item(item);\n-            let id = hir::ForeignItemId { hir_id: hir_item.hir_id };\n+            let id = hir_item.foreign_item_id();\n             lctx.foreign_items.insert(id, hir_item);\n-            lctx.modules.get_mut(&lctx.current_module).unwrap().foreign_items.insert(id);\n+            lctx.modules.entry(lctx.current_module).or_default().foreign_items.insert(id);\n         });\n \n         visit::walk_foreign_item(self, item);\n@@ -128,14 +117,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // only used when lowering a child item of a trait or impl.\n     fn with_parent_item_lifetime_defs<T>(\n         &mut self,\n-        parent_hir_id: hir::HirId,\n+        parent_hir_id: hir::ItemId,\n         f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n         let parent_generics = match self.items.get(&parent_hir_id).unwrap().kind {\n             hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n-            | hir::ItemKind::Trait(_, _, ref generics, ..) => &generics.params[..],\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n             _ => &[],\n         };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n@@ -157,7 +146,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n     ) -> T {\n-        let old_in_scope_lifetimes = std::mem::replace(&mut self.in_scope_lifetimes, vec![]);\n+        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, vec![]);\n \n         // this vector is only used when walking over impl headers,\n         // input types, and the like, and should not be non-empty in\n@@ -172,12 +161,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         res\n     }\n \n-    pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod<'hir> {\n+    pub(super) fn lower_mod(&mut self, items: &[P<Item>], inner: Span) -> hir::Mod<'hir> {\n         hir::Mod {\n-            inner: m.inner,\n-            item_ids: self\n-                .arena\n-                .alloc_from_iter(m.items.iter().flat_map(|x| self.lower_item_id(x))),\n+            inner,\n+            item_ids: self.arena.alloc_from_iter(items.iter().flat_map(|x| self.lower_item_id(x))),\n         }\n     }\n \n@@ -197,7 +184,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         node_ids\n             .into_iter()\n-            .map(|node_id| hir::ItemId { id: self.allocate_hir_id_counter(node_id) })\n+            .map(|node_id| hir::ItemId {\n+                def_id: self.allocate_hir_id_counter(node_id).expect_owner(),\n+            })\n             .collect()\n     }\n \n@@ -228,37 +217,41 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item<'hir>> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n-        let attrs = self.lower_attrs(&i.attrs);\n \n         if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n             if !macro_rules || self.sess.contains_name(&i.attrs, sym::macro_export) {\n                 let hir_id = self.lower_node_id(i.id);\n+                self.lower_attrs(hir_id, &i.attrs);\n                 let body = P(self.lower_mac_args(body));\n                 self.exported_macros.push(hir::MacroDef {\n                     ident,\n                     vis,\n-                    attrs,\n-                    hir_id,\n+                    def_id: hir_id.expect_owner(),\n                     span: i.span,\n                     ast: MacroDef { body, macro_rules },\n                 });\n             } else {\n-                self.non_exported_macro_attrs.extend(attrs.iter().cloned());\n+                for a in i.attrs.iter() {\n+                    let a = self.lower_attr(a);\n+                    self.non_exported_macro_attrs.push(a);\n+                }\n             }\n             return None;\n         }\n \n-        let kind = self.lower_item_kind(i.span, i.id, &mut ident, attrs, &mut vis, &i.kind);\n-\n-        Some(hir::Item { hir_id: self.lower_node_id(i.id), ident, attrs, kind, vis, span: i.span })\n+        let hir_id = self.lower_node_id(i.id);\n+        let attrs = self.lower_attrs(hir_id, &i.attrs);\n+        let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, &mut vis, &i.kind);\n+        Some(hir::Item { def_id: hir_id.expect_owner(), ident, kind, vis, span: i.span })\n     }\n \n     fn lower_item_kind(\n         &mut self,\n         span: Span,\n         id: NodeId,\n+        hir_id: hir::HirId,\n         ident: &mut Ident,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n         vis: &mut hir::Visibility<'hir>,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n@@ -318,13 +311,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n-            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n+            ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n+                ModKind::Loaded(items, _, inner_span) => {\n+                    hir::ItemKind::Mod(self.lower_mod(items, *inner_span))\n+                }\n+                ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n+            },\n             ItemKind::ForeignMod(ref fm) => {\n                 if fm.abi.is_none() {\n-                    self.maybe_lint_missing_abi(span, id, abi::Abi::C);\n+                    self.maybe_lint_missing_abi(span, id, abi::Abi::C { unwind: false });\n                 }\n                 hir::ItemKind::ForeignMod {\n-                    abi: fm.abi.map_or(abi::Abi::C, |abi| self.lower_abi(abi)),\n+                    abi: fm.abi.map_or(abi::Abi::C { unwind: false }, |abi| self.lower_abi(abi)),\n                     items: self\n                         .arena\n                         .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n@@ -364,14 +362,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n             ItemKind::Struct(ref struct_def, ref generics) => {\n-                let struct_def = self.lower_variant_data(struct_def);\n+                let struct_def = self.lower_variant_data(hir_id, struct_def);\n                 hir::ItemKind::Struct(\n                     struct_def,\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n-                let vdata = self.lower_variant_data(vdata);\n+                let vdata = self.lower_variant_data(hir_id, vdata);\n                 hir::ItemKind::Union(\n                     vdata,\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n@@ -387,8 +385,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self_ty: ref ty,\n                 items: ref impl_items,\n             }) => {\n-                let def_id = self.resolver.local_def_id(id);\n-\n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n                 //\n@@ -402,10 +398,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // method, it will not be considered an in-band\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n-                let lowered_trait_impl_id = self.lower_node_id(id);\n+                let lowered_trait_def_id = self.lower_node_id(id).expect_owner();\n                 let (generics, (trait_ref, lowered_ty)) = self.add_in_band_defs(\n                     ast_generics,\n-                    def_id,\n+                    lowered_trait_def_id,\n                     AnonymousLifetimeMode::CreateParameter,\n                     |this, _| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n@@ -417,7 +413,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                 this.trait_impls\n                                     .entry(def_id)\n                                     .or_default()\n-                                    .push(lowered_trait_impl_id);\n+                                    .push(lowered_trait_def_id);\n                             }\n                         }\n \n@@ -506,7 +502,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         vis: &mut hir::Visibility<'hir>,\n         ident: &mut Ident,\n-        attrs: &'hir [Attribute],\n+        attrs: Option<&'hir [Attribute]>,\n     ) -> hir::ItemKind<'hir> {\n         debug!(\"lower_use_tree(tree={:?})\", tree);\n         debug!(\"lower_use_tree: vis = {:?}\", vis);\n@@ -555,11 +551,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n                         let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n+                        if let Some(attrs) = attrs {\n+                            this.attrs.insert(new_id, attrs);\n+                        }\n \n                         this.insert_item(hir::Item {\n-                            hir_id: new_id,\n+                            def_id: new_id.expect_owner(),\n                             ident,\n-                            attrs,\n                             kind,\n                             vis,\n                             span,\n@@ -627,11 +625,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                         let kind =\n                             this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n+                        if let Some(attrs) = attrs {\n+                            this.attrs.insert(new_hir_id, attrs);\n+                        }\n \n                         this.insert_item(hir::Item {\n-                            hir_id: new_hir_id,\n+                            def_id: new_hir_id.expect_owner(),\n                             ident,\n-                            attrs,\n                             kind,\n                             vis,\n                             span: use_tree.span,\n@@ -700,11 +700,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n-        let def_id = self.resolver.local_def_id(i.id);\n+        let hir_id = self.lower_node_id(i.id);\n+        let def_id = hir_id.expect_owner();\n+        self.lower_attrs(hir_id, &i.attrs);\n         hir::ForeignItem {\n-            hir_id: self.lower_node_id(i.id),\n+            def_id,\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box FnKind(_, ref sig, ref generics, _)) => {\n                     let fdec = &sig.decl;\n@@ -737,7 +738,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef<'hir> {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { hir_id: self.lower_node_id(i.id) },\n+            id: hir::ForeignItemId { def_id: self.lower_node_id(i.id).expect_owner() },\n             ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n@@ -749,29 +750,43 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n+        let id = self.lower_node_id(v.id);\n+        self.lower_attrs(id, &v.attrs);\n         hir::Variant {\n-            attrs: self.lower_attrs(&v.attrs),\n-            data: self.lower_variant_data(&v.data),\n+            id,\n+            data: self.lower_variant_data(id, &v.data),\n             disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n-            id: self.lower_node_id(v.id),\n             ident: v.ident,\n             span: v.span,\n         }\n     }\n \n-    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData<'hir> {\n+    fn lower_variant_data(\n+        &mut self,\n+        parent_id: hir::HirId,\n+        vdata: &VariantData,\n+    ) -> hir::VariantData<'hir> {\n         match *vdata {\n             VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n                 self.arena\n                     .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_struct_field(f))),\n                 recovered,\n             ),\n-            VariantData::Tuple(ref fields, id) => hir::VariantData::Tuple(\n-                self.arena\n-                    .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_struct_field(f))),\n-                self.lower_node_id(id),\n-            ),\n-            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id)),\n+            VariantData::Tuple(ref fields, id) => {\n+                let ctor_id = self.lower_node_id(id);\n+                self.alias_attrs(ctor_id, parent_id);\n+                hir::VariantData::Tuple(\n+                    self.arena.alloc_from_iter(\n+                        fields.iter().enumerate().map(|f| self.lower_struct_field(f)),\n+                    ),\n+                    ctor_id,\n+                )\n+            }\n+            VariantData::Unit(id) => {\n+                let ctor_id = self.lower_node_id(id);\n+                self.alias_attrs(ctor_id, parent_id);\n+                hir::VariantData::Unit(ctor_id)\n+            }\n         }\n     }\n \n@@ -788,22 +803,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         } else {\n             self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n         };\n+        let hir_id = self.lower_node_id(f.id);\n+        self.lower_attrs(hir_id, &f.attrs);\n         hir::StructField {\n             span: f.span,\n-            hir_id: self.lower_node_id(f.id),\n+            hir_id,\n             ident: match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried): positional field hygiene.\n                 None => Ident::new(sym::integer(index), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n             ty,\n-            attrs: self.lower_attrs(&f.attrs),\n         }\n     }\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n-        let trait_item_def_id = self.resolver.local_def_id(i.id);\n+        let hir_id = self.lower_node_id(i.id);\n+        let trait_item_def_id = hir_id.expect_owner();\n \n         let (generics, kind) = match i.kind {\n             AssocItemKind::Const(_, ref ty, ref default) => {\n@@ -836,14 +853,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::MacCall(..) => panic!(\"macro item shouldn't exist at this point\"),\n         };\n \n-        hir::TraitItem {\n-            hir_id: self.lower_node_id(i.id),\n-            ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n-            generics,\n-            kind,\n-            span: i.span,\n-        }\n+        self.lower_attrs(hir_id, &i.attrs);\n+        hir::TraitItem { def_id: trait_item_def_id, ident: i.ident, generics, kind, span: i.span }\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n@@ -857,7 +868,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { hir_id: self.lower_node_id(i.id) };\n+        let id = hir::TraitItemId { def_id: self.lower_node_id(i.id).expect_owner() };\n         let defaultness = hir::Defaultness::Default { has_value: has_default };\n         hir::TraitItemRef { id, ident: i.ident, span: i.span, defaultness, kind }\n     }\n@@ -921,10 +932,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // Since `default impl` is not yet implemented, this is always true in impls.\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n+        let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n         hir::ImplItem {\n-            hir_id: self.lower_node_id(i.id),\n+            def_id: hir_id.expect_owner(),\n             ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n             defaultness,\n@@ -938,7 +950,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n+            id: hir::ImplItemId { def_id: self.lower_node_id(i.id).expect_owner() },\n             ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n@@ -1025,9 +1037,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_param(&mut self, param: &Param) -> hir::Param<'hir> {\n+        let hir_id = self.lower_node_id(param.id);\n+        self.lower_attrs(hir_id, &param.attrs);\n         hir::Param {\n-            attrs: self.lower_attrs(&param.attrs),\n-            hir_id: self.lower_node_id(param.id),\n+            hir_id,\n             pat: self.lower_pat(&param.pat),\n             ty_span: param.ty.span,\n             span: param.span,\n@@ -1159,11 +1172,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // If this is the simple case, this parameter will end up being the same as the\n                 // original parameter, but with a different pattern id.\n-                let mut stmt_attrs = AttrVec::new();\n-                stmt_attrs.extend(parameter.attrs.iter().cloned());\n+                let stmt_attrs = this.attrs.get(&parameter.hir_id).copied();\n                 let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n                 let new_parameter = hir::Param {\n-                    attrs: parameter.attrs,\n                     hir_id: parameter.hir_id,\n                     pat: new_parameter_pat,\n                     ty_span: parameter.ty_span,\n@@ -1206,7 +1217,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n-                        AttrVec::new(),\n+                        None,\n                         desugared_span,\n                         Some(move_expr),\n                         move_pat,\n@@ -1323,8 +1334,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match ext {\n             Extern::None => abi::Abi::Rust,\n             Extern::Implicit => {\n-                self.maybe_lint_missing_abi(span, id, abi::Abi::C);\n-                abi::Abi::C\n+                self.maybe_lint_missing_abi(span, id, abi::Abi::C { unwind: false });\n+                abi::Abi::C { unwind: false }\n             }\n             Extern::Explicit(abi) => self.lower_abi(abi),\n         }"}, {"sha": "003500eb68f0c41d3eaa3a83c861171cf5ca8a4a", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 133, "deletions": 96, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -12,7 +12,7 @@\n //! For the simpler lowering steps, IDs and spans should be preserved. Unlike\n //! expansion we do not preserve the process of lowering in the spans, so spans\n //! should not be modified here. When creating a new node (as opposed to\n-//! 'folding' an existing one), then you create a new ID using `next_id()`.\n+//! \"folding\" an existing one), create a new ID using `next_id()`.\n //!\n //! You must ensure that IDs are unique. That means that you should only use the\n //! ID from an AST node in a single HIR node (you can assume that AST node-IDs\n@@ -26,7 +26,7 @@\n //! span and spans don't need to be kept in order, etc. Where code is preserved\n //! by lowering, it should have the same span as in the AST. Where HIR nodes are\n //! new it is probably best to give a span for the whole AST node being lowered.\n-//! All nodes should have real spans, don't use dummy spans. Tools are likely to\n+//! All nodes should have real spans; don't use dummy spans. Tools are likely to\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n@@ -48,7 +48,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n@@ -95,11 +95,11 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// librustc_middle is independent of the parser, we use dynamic dispatch here.\n     nt_to_tokenstream: NtToTokenstream,\n \n-    /// Used to allocate HIR nodes\n+    /// Used to allocate HIR nodes.\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n-    items: BTreeMap<hir::HirId, hir::Item<'hir>>,\n+    items: BTreeMap<hir::ItemId, hir::Item<'hir>>,\n \n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem<'hir>>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem<'hir>>,\n@@ -108,12 +108,14 @@ struct LoweringContext<'a, 'hir: 'a> {\n     exported_macros: Vec<hir::MacroDef<'hir>>,\n     non_exported_macro_attrs: Vec<ast::Attribute>,\n \n-    trait_impls: BTreeMap<DefId, Vec<hir::HirId>>,\n+    trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n \n-    modules: BTreeMap<hir::HirId, hir::ModuleItems>,\n+    modules: BTreeMap<LocalDefId, hir::ModuleItems>,\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n+    attrs: BTreeMap<hir::HirId, &'hir [Attribute]>,\n+\n     /// When inside an `async` context, this is the `HirId` of the\n     /// `task_context` local bound to the resume argument of the generator.\n     task_context: Option<hir::HirId>,\n@@ -128,7 +130,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    /// What to do when we encounter either an \"anonymous lifetime\n+    /// What to do when we encounter an \"anonymous lifetime\n     /// reference\". The term \"anonymous\" is meant to encompass both\n     /// `'_` lifetimes as well as fully elided cases where nothing is\n     /// written at all (e.g., `&T` or `std::cell::Ref<T>`).\n@@ -158,7 +160,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// vector.\n     in_scope_lifetimes: Vec<ParamName>,\n \n-    current_module: hir::HirId,\n+    current_module: LocalDefId,\n \n     type_def_lifetime_params: DefIdMap<usize>,\n \n@@ -175,6 +177,8 @@ pub trait ResolverAstLowering {\n \n     fn item_generics_num_lifetimes(&self, def: DefId, sess: &Session) -> usize;\n \n+    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>>;\n+\n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n@@ -219,7 +223,7 @@ enum ImplTraitContext<'b, 'a> {\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n     /// Newly generated parameters should be inserted into the given `Vec`.\n-    Universal(&'b mut Vec<hir::GenericParam<'a>>),\n+    Universal(&'b mut Vec<hir::GenericParam<'a>>, LocalDefId),\n \n     /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n@@ -236,11 +240,13 @@ enum ImplTraitContext<'b, 'a> {\n     OtherOpaqueTy {\n         /// Set of lifetimes that this opaque type can capture, if it uses\n         /// them. This includes lifetimes bound since we entered this context.\n-        /// For example, in\n+        /// For example:\n         ///\n+        /// ```\n         /// type A<'b> = impl for<'a> Trait<'a, Out = impl Sized + 'a>;\n+        /// ```\n         ///\n-        /// the inner opaque type captures `'a` because it uses it. It doesn't\n+        /// Here the inner opaque type captures `'a` because it uses it. It doesn't\n         /// need to capture `'b` because it already inherits the lifetime\n         /// parameter from `A`.\n         // FIXME(impl_trait): but `required_region_bounds` will ICE later\n@@ -272,7 +278,7 @@ impl<'a> ImplTraitContext<'_, 'a> {\n     fn reborrow<'this>(&'this mut self) -> ImplTraitContext<'this, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n-            Universal(params) => Universal(params),\n+            Universal(params, parent) => Universal(params, *parent),\n             ReturnPositionOpaqueTy { fn_def_id, origin } => {\n                 ReturnPositionOpaqueTy { fn_def_id: *fn_def_id, origin: *origin }\n             }\n@@ -305,6 +311,7 @@ pub fn lower_crate<'a, 'hir>(\n         bodies: BTreeMap::new(),\n         trait_impls: BTreeMap::new(),\n         modules: BTreeMap::new(),\n+        attrs: BTreeMap::default(),\n         exported_macros: Vec::new(),\n         non_exported_macro_attrs: Vec::new(),\n         catch_scopes: Vec::new(),\n@@ -314,8 +321,8 @@ pub fn lower_crate<'a, 'hir>(\n         is_in_dyn_type: false,\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: Default::default(),\n-        current_module: hir::CRATE_HIR_ID,\n-        current_hir_id_owner: vec![(LocalDefId { local_def_index: CRATE_DEF_INDEX }, 0)],\n+        current_module: CRATE_DEF_ID,\n+        current_hir_id_owner: vec![(CRATE_DEF_ID, 0)],\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n@@ -468,25 +475,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         impl MiscCollector<'_, '_, '_> {\n-            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree, owner: LocalDefId) {\n+            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree) {\n                 match tree.kind {\n                     UseTreeKind::Simple(_, id1, id2) => {\n                         for &id in &[id1, id2] {\n-                            self.lctx.resolver.create_def(\n-                                owner,\n-                                id,\n-                                DefPathData::Misc,\n-                                ExpnId::root(),\n-                                tree.prefix.span,\n-                            );\n                             self.lctx.allocate_hir_id_counter(id);\n                         }\n                     }\n                     UseTreeKind::Glob => (),\n                     UseTreeKind::Nested(ref trees) => {\n                         for &(ref use_tree, id) in trees {\n-                            let hir_id = self.lctx.allocate_hir_id_counter(id);\n-                            self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n+                            self.lctx.allocate_hir_id_counter(id);\n+                            self.allocate_use_tree_hir_id_counters(use_tree);\n                         }\n                     }\n                 }\n@@ -495,7 +495,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         impl<'tcx> Visitor<'tcx> for MiscCollector<'tcx, '_, '_> {\n             fn visit_item(&mut self, item: &'tcx Item) {\n-                let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n+                self.lctx.allocate_hir_id_counter(item.id);\n \n                 match item.kind {\n                     ItemKind::Struct(_, ref generics)\n@@ -514,7 +514,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         self.lctx.type_def_lifetime_params.insert(def_id.to_def_id(), count);\n                     }\n                     ItemKind::Use(ref use_tree) => {\n-                        self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n+                        self.allocate_use_tree_hir_id_counters(use_tree);\n                     }\n                     _ => {}\n                 }\n@@ -560,8 +560,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n-        let module = self.lower_mod(&c.module);\n-        let attrs = self.lower_attrs(&c.attrs);\n+        let module = self.lower_mod(&c.items, c.span);\n+        self.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n         let body_ids = body_ids(&self.bodies);\n         let proc_macros =\n             c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id].unwrap()).collect();\n@@ -588,8 +588,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n \n+        #[cfg(debug_assertions)]\n+        for (&id, attrs) in self.attrs.iter() {\n+            // Verify that we do not store empty slices in the map.\n+            if attrs.is_empty() {\n+                panic!(\"Stored empty attributes for {:?}\", id);\n+            }\n+        }\n+\n         hir::Crate {\n-            item: hir::CrateItem { module, attrs, span: c.span },\n+            item: hir::CrateItem { module, span: c.span },\n             exported_macros: self.arena.alloc_from_iter(self.exported_macros),\n             non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n             items: self.items,\n@@ -602,15 +610,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             modules: self.modules,\n             proc_macros,\n             trait_map,\n+            attrs: self.attrs,\n         }\n     }\n \n-    fn insert_item(&mut self, item: hir::Item<'hir>) {\n-        let id = item.hir_id;\n-        // FIXME: Use `debug_asset-rt`.\n-        assert_eq!(id.local_id, hir::ItemLocalId::from_u32(0));\n+    fn insert_item(&mut self, item: hir::Item<'hir>) -> hir::ItemId {\n+        let id = hir::ItemId { def_id: item.def_id };\n         self.items.insert(id, item);\n-        self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n+        self.modules.entry(self.current_module).or_default().items.insert(id);\n+        id\n     }\n \n     fn allocate_hir_id_counter(&mut self, owner: NodeId) -> hir::HirId {\n@@ -831,7 +839,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             name: hir_name,\n-            attrs: &[],\n             bounds: &[],\n             span,\n             pure_wrt_drop: false,\n@@ -925,8 +932,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // `lifetimes_to_define`. If we swapped the order of these two,\n                     // in-band-lifetimes introduced by generics or where-clauses\n                     // wouldn't have been added yet.\n-                    let generics =\n-                        this.lower_generics_mut(generics, ImplTraitContext::Universal(&mut params));\n+                    let generics = this.lower_generics_mut(\n+                        generics,\n+                        ImplTraitContext::Universal(\n+                            &mut params,\n+                            this.current_hir_id_owner.last().unwrap().0,\n+                        ),\n+                    );\n                     let res = f(this, &mut params);\n                     (params, (generics, res))\n                 })\n@@ -964,11 +976,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ret\n     }\n \n-    fn lower_attrs(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n-        self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)))\n+    fn lower_attrs(&mut self, id: hir::HirId, attrs: &[Attribute]) -> Option<&'hir [Attribute]> {\n+        if attrs.is_empty() {\n+            None\n+        } else {\n+            let ret = self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)));\n+            debug_assert!(!ret.is_empty());\n+            self.attrs.insert(id, ret);\n+            Some(ret)\n+        }\n     }\n \n-    fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n+    fn lower_attr(&self, attr: &Attribute) -> Attribute {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n         // the `HirId`s. We don't actually need HIR version of attributes anyway.\n@@ -988,7 +1007,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         Attribute { kind, id: attr.id, style: attr.style, span: attr.span }\n     }\n \n-    fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {\n+    fn alias_attrs(&mut self, id: hir::HirId, target_id: hir::HirId) {\n+        if let Some(&a) = self.attrs.get(&target_id) {\n+            debug_assert!(!a.is_empty());\n+            self.attrs.insert(id, a);\n+        }\n+    }\n+\n+    fn lower_mac_args(&self, args: &MacArgs) -> MacArgs {\n         match *args {\n             MacArgs::Empty => MacArgs::Empty,\n             MacArgs::Delimited(dspan, delim, ref tokens) => {\n@@ -1117,6 +1143,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             AssocTyConstraintKind::Bound { ref bounds } => {\n                 let mut capturable_lifetimes;\n+                let mut parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1136,7 +1163,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo(x: dyn Iterator<Item = impl Debug>)\n-                    ImplTraitContext::Universal(..) if self.is_in_dyn_type => (true, itctx),\n+                    ImplTraitContext::Universal(_, parent) if self.is_in_dyn_type => {\n+                        parent_def_id = parent;\n+                        (true, itctx)\n+                    }\n \n                     // In `type Foo = dyn Iterator<Item: Debug>` we desugar to\n                     // `type Foo = dyn Iterator<Item = impl Debug>` but we have to override the\n@@ -1170,7 +1200,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // constructing the HIR for `impl bounds...` and then lowering that.\n \n                     let impl_trait_node_id = self.resolver.next_node_id();\n-                    let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n                     self.resolver.create_def(\n                         parent_def_id,\n                         impl_trait_node_id,\n@@ -1423,7 +1452,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             |this| this.lower_param_bounds(bounds, nested_itctx),\n                         )\n                     }\n-                    ImplTraitContext::Universal(in_band_ty_params) => {\n+                    ImplTraitContext::Universal(in_band_ty_params, parent_def_id) => {\n                         // Add a definition for the in-band `Param`.\n                         let def_id = self.resolver.local_def_id(def_node_id);\n \n@@ -1432,7 +1461,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         let hir_bounds = self.with_hir_id_owner(def_node_id, |this| {\n                             this.lower_param_bounds(\n                                 bounds,\n-                                ImplTraitContext::Universal(in_band_ty_params),\n+                                ImplTraitContext::Universal(in_band_ty_params, parent_def_id),\n                             )\n                         });\n                         // Set the name to `impl Bound1 + Bound2`.\n@@ -1441,7 +1470,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n-                            attrs: &[],\n                             bounds: hir_bounds,\n                             span,\n                             kind: hir::GenericParamKind::Type {\n@@ -1547,31 +1575,28 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n-            let opaque_ty_id =\n-                lctx.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n+            lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, lifetimes)\n+            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes)\n         })\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n     /// returns the lowered node-ID for the opaque type.\n     fn generate_opaque_type(\n         &mut self,\n-        opaque_ty_node_id: NodeId,\n+        opaque_ty_id: LocalDefId,\n         opaque_ty_item: hir::OpaqueTy<'hir>,\n         span: Span,\n         opaque_ty_span: Span,\n-    ) -> hir::HirId {\n+    ) {\n         let opaque_ty_item_kind = hir::ItemKind::OpaqueTy(opaque_ty_item);\n-        let opaque_ty_id = self.lower_node_id(opaque_ty_node_id);\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            hir_id: opaque_ty_id,\n+            def_id: opaque_ty_id,\n             ident: Ident::invalid(),\n-            attrs: Default::default(),\n             kind: opaque_ty_item_kind,\n             vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n             span: opaque_ty_span,\n@@ -1581,7 +1606,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // automatically for all AST items. But this opaque type item\n         // does not actually exist in the AST.\n         self.insert_item(opaque_ty_item);\n-        opaque_ty_id\n     }\n \n     fn lifetimes_from_impl_trait_bounds(\n@@ -1733,7 +1757,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name,\n                         span: lifetime.span,\n                         pure_wrt_drop: false,\n-                        attrs: &[],\n                         bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n                     });\n@@ -1790,14 +1813,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n         });\n         let init = l.init.as_ref().map(|e| self.lower_expr(e));\n+        let hir_id = self.lower_node_id(l.id);\n+        self.lower_attrs(hir_id, &l.attrs);\n         (\n             hir::Local {\n-                hir_id: self.lower_node_id(l.id),\n+                hir_id,\n                 ty,\n                 pat: self.lower_pat(&l.pat),\n                 init,\n                 span: l.span,\n-                attrs: l.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n                 source: hir::LocalSource::Normal,\n             },\n             ids,\n@@ -1868,7 +1892,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             this.arena.alloc_from_iter(inputs.iter().map(|param| {\n                 if let Some((_, ibty)) = &mut in_band_ty_params {\n-                    this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n+                    this.lower_ty_direct(\n+                        &param.ty,\n+                        ImplTraitContext::Universal(\n+                            ibty,\n+                            this.current_hir_id_owner.last().unwrap().0,\n+                        ),\n+                    )\n                 } else {\n                     this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n                 }\n@@ -2010,7 +2040,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // grow.\n         let input_lifetimes_count = self.in_scope_lifetimes.len() + self.lifetimes_to_define.len();\n \n-        let (opaque_ty_id, lifetime_params) = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+        let lifetime_params = self.with_hir_id_owner(opaque_ty_node_id, |this| {\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n             // lifetime in the return type.  So, given a return type\n@@ -2061,10 +2091,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             };\n \n             trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n-            let opaque_ty_id =\n-                this.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n+            this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span);\n \n-            (opaque_ty_id, lifetime_params)\n+            lifetime_params\n         });\n \n         // As documented above on the variable\n@@ -2107,12 +2136,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n-        let opaque_ty_ref = hir::TyKind::OpaqueDef(hir::ItemId { id: opaque_ty_id }, generic_args);\n+        let opaque_ty_ref =\n+            hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, generic_args);\n         let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n         hir::FnRetTy::Return(self.arena.alloc(opaque_ty))\n     }\n \n-    /// Transforms `-> T` into `Future<Output = T>`\n+    /// Transforms `-> T` into `Future<Output = T>`.\n     fn lower_async_fn_output_type_to_future_bound(\n         &mut self,\n         output: &FnRetTy,\n@@ -2300,12 +2330,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         };\n \n+        let hir_id = self.lower_node_id(param.id);\n+        self.lower_attrs(hir_id, &param.attrs);\n         hir::GenericParam {\n-            hir_id: self.lower_node_id(param.id),\n+            hir_id,\n             name,\n             span: param.ident.span,\n             pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n-            attrs: self.lower_attrs(&param.attrs),\n             bounds: self.arena.alloc_from_iter(bounds),\n             kind,\n         }\n@@ -2385,26 +2416,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_block_noalloc(&mut self, b: &Block, targeted_by_break: bool) -> hir::Block<'hir> {\n-        let mut expr: Option<&'hir _> = None;\n-\n-        let stmts = self.arena.alloc_from_iter(\n-            b.stmts\n-                .iter()\n-                .enumerate()\n-                .filter_map(|(index, stmt)| {\n-                    if index == b.stmts.len() - 1 {\n-                        if let StmtKind::Expr(ref e) = stmt.kind {\n-                            expr = Some(self.lower_expr(e));\n-                            None\n-                        } else {\n-                            Some(self.lower_stmt(stmt))\n-                        }\n-                    } else {\n-                        Some(self.lower_stmt(stmt))\n-                    }\n-                })\n-                .flatten(),\n-        );\n+        let (stmts, expr) = match &*b.stmts {\n+            [stmts @ .., Stmt { kind: StmtKind::Expr(e), .. }] => (stmts, Some(&*e)),\n+            stmts => (stmts, None),\n+        };\n+        let stmts = self.arena.alloc_from_iter(stmts.iter().flat_map(|stmt| self.lower_stmt(stmt)));\n+        let expr = expr.map(|e| self.lower_expr(e));\n         let rules = self.lower_block_check_mode(&b.rules);\n         let hir_id = self.lower_node_id(b.id);\n \n@@ -2426,19 +2443,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt<'hir>; 1]> {\n-        let kind = match s.kind {\n+        let (hir_id, kind) = match s.kind {\n             StmtKind::Local(ref l) => {\n                 let (l, item_ids) = self.lower_local(l);\n                 let mut ids: SmallVec<[hir::Stmt<'hir>; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n-                        let item_id = hir::ItemId { id: self.lower_node_id(item_id) };\n+                        let item_id = hir::ItemId {\n+                            // All the items that `lower_local` finds are `impl Trait` types.\n+                            def_id: self.lower_node_id(item_id).expect_owner(),\n+                        };\n                         self.stmt(s.span, hir::StmtKind::Item(item_id))\n                     })\n                     .collect();\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, l.hir_id);\n                 ids.push({\n                     hir::Stmt {\n-                        hir_id: self.lower_node_id(s.id),\n+                        hir_id,\n                         kind: hir::StmtKind::Local(self.arena.alloc(l)),\n                         span: s.span,\n                     }\n@@ -2461,12 +2483,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     })\n                     .collect();\n             }\n-            StmtKind::Expr(ref e) => hir::StmtKind::Expr(self.lower_expr(e)),\n-            StmtKind::Semi(ref e) => hir::StmtKind::Semi(self.lower_expr(e)),\n+            StmtKind::Expr(ref e) => {\n+                let e = self.lower_expr(e);\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, e.hir_id);\n+                (hir_id, hir::StmtKind::Expr(e))\n+            }\n+            StmtKind::Semi(ref e) => {\n+                let e = self.lower_expr(e);\n+                let hir_id = self.lower_node_id(s.id);\n+                self.alias_attrs(hir_id, e.hir_id);\n+                (hir_id, hir::StmtKind::Semi(e))\n+            }\n             StmtKind::Empty => return smallvec![],\n             StmtKind::MacCall(..) => panic!(\"shouldn't exist here\"),\n         };\n-        smallvec![hir::Stmt { hir_id: self.lower_node_id(s.id), kind, span: s.span }]\n+        smallvec![hir::Stmt { hir_id, kind, span: s.span }]\n     }\n \n     fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n@@ -2510,13 +2542,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn stmt_let_pat(\n         &mut self,\n-        attrs: AttrVec,\n+        attrs: Option<&'hir [Attribute]>,\n         span: Span,\n         init: Option<&'hir hir::Expr<'hir>>,\n         pat: &'hir hir::Pat<'hir>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt<'hir> {\n-        let local = hir::Local { attrs, hir_id: self.next_id(), init, pat, source, span, ty: None };\n+        let hir_id = self.next_id();\n+        if let Some(a) = attrs {\n+            debug_assert!(!a.is_empty());\n+            self.attrs.insert(hir_id, a);\n+        }\n+        let local = hir::Local { hir_id, init, pat, source, span, ty: None };\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }\n "}, {"sha": "563bcda51906575cefaf6602b1553caa42bba11e", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1054,12 +1054,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return;\n             }\n-            ItemKind::Mod(Mod { inline, unsafety, .. }) => {\n+            ItemKind::Mod(unsafety, ref mod_kind) => {\n                 if let Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n+                if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n+                    && !self.session.contains_name(&item.attrs, sym::path)\n+                {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }"}, {"sha": "8a17ac90a023d1f962fbc2bbd9857ff563358c77", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -164,6 +164,38 @@ impl<'a> PostExpansionVisitor<'a> {\n                     \"C-cmse-nonsecure-call ABI is experimental and subject to change\"\n                 );\n             }\n+            \"C-unwind\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    c_unwind,\n+                    span,\n+                    \"C-unwind ABI is experimental and subject to change\"\n+                );\n+            }\n+            \"stdcall-unwind\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    c_unwind,\n+                    span,\n+                    \"stdcall-unwind ABI is experimental and subject to change\"\n+                );\n+            }\n+            \"system-unwind\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    c_unwind,\n+                    span,\n+                    \"system-unwind ABI is experimental and subject to change\"\n+                );\n+            }\n+            \"thiscall-unwind\" => {\n+                gate_feature_post!(\n+                    &self,\n+                    c_unwind,\n+                    span,\n+                    \"thiscall-unwind ABI is experimental and subject to change\"\n+                );\n+            }\n             abi => self\n                 .sess\n                 .parse_sess\n@@ -638,8 +670,16 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n             }\n         };\n     }\n-    gate_all!(if_let_guard, \"`if let` guards are experimental\");\n-    gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n+    gate_all!(\n+        if_let_guard,\n+        \"`if let` guards are experimental\",\n+        \"you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\"\n+    );\n+    gate_all!(\n+        let_chains,\n+        \"`let` expressions in this position are experimental\",\n+        \"you can write `matches!(<expr>, <pattern>)` instead of `let <pattern> = <expr>`\"\n+    );\n     gate_all!(\n         async_closure,\n         \"async closures are unstable\",\n@@ -665,6 +705,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n         // involved, so we only emit errors where there are no other parsing errors.\n         gate_all!(destructuring_assignment, \"destructuring assignments are unstable\");\n     }\n+    gate_all!(pub_macro_rules, \"`pub` on `macro_rules` items is unstable\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "fb7e0d3450fde5a0f1b1cf422838fa73a4d37574", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -20,10 +20,6 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_ident(self, ident);\n     }\n-    fn visit_mod(&mut self, m: &Mod, _s: Span, _a: &[Attribute], _n: NodeId) {\n-        self.count += 1;\n-        walk_mod(self, m)\n-    }\n     fn visit_foreign_item(&mut self, i: &ForeignItem) {\n         self.count += 1;\n         walk_foreign_item(self, i)"}, {"sha": "82f6e936b766eb041a8bc4458abab9fd25d56772", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{GenericArg, MacArgs};\n+use rustc_ast::{GenericArg, MacArgs, ModKind};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -87,7 +87,6 @@ pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n     ann: &'a (dyn PpAnn + 'a),\n-    is_expanded: bool,\n }\n \n crate const INDENT_UNIT: usize = 4;\n@@ -103,12 +102,8 @@ pub fn print_crate<'a>(\n     is_expanded: bool,\n     edition: Edition,\n ) -> String {\n-    let mut s = State {\n-        s: pp::mk_printer(),\n-        comments: Some(Comments::new(sm, filename, input)),\n-        ann,\n-        is_expanded,\n-    };\n+    let mut s =\n+        State { s: pp::mk_printer(), comments: Some(Comments::new(sm, filename, input)), ann };\n \n     if is_expanded && !krate.attrs.iter().any(|attr| attr.has_name(sym::no_core)) {\n         // We need to print `#![no_std]` (and its feature gate) so that\n@@ -132,7 +127,10 @@ pub fn print_crate<'a>(\n         }\n     }\n \n-    s.print_mod(&krate.module, &krate.attrs);\n+    s.print_inner_attributes(&krate.attrs);\n+    for item in &krate.items {\n+        s.print_item(item);\n+    }\n     s.print_remaining_comments();\n     s.ann.post(&mut s, AnnNode::Crate(krate));\n     s.s.eof()\n@@ -853,7 +851,7 @@ impl<'a> PrintState<'a> for State<'a> {\n \n impl<'a> State<'a> {\n     pub fn new() -> State<'a> {\n-        State { s: pp::mk_printer(), comments: None, ann: &NoAnn, is_expanded: false }\n+        State { s: pp::mk_printer(), comments: None, ann: &NoAnn }\n     }\n \n     // Synthesizes a comment that was not textually present in the original source\n@@ -891,13 +889,6 @@ impl<'a> State<'a> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n-    pub fn print_mod(&mut self, _mod: &ast::Mod, attrs: &[ast::Attribute]) {\n-        self.print_inner_attributes(attrs);\n-        for item in &_mod.items {\n-            self.print_item(item);\n-        }\n-    }\n-\n     crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n         self.print_inner_attributes(attrs);\n         for item in &nmod.items {\n@@ -914,6 +905,7 @@ impl<'a> State<'a> {\n \n     pub fn print_assoc_constraint(&mut self, constraint: &ast::AssocTyConstraint) {\n         self.print_ident(constraint.ident);\n+        constraint.gen_args.as_ref().map(|args| self.print_generic_args(args, false));\n         self.s.space();\n         match &constraint.kind {\n             ast::AssocTyConstraintKind::Equality { ty } => {\n@@ -1138,23 +1130,29 @@ impl<'a> State<'a> {\n                 let body = body.as_deref();\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n-            ast::ItemKind::Mod(ref _mod) => {\n+            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n                 self.head(self.to_string(|s| {\n                     s.print_visibility(&item.vis);\n-                    s.print_unsafety(_mod.unsafety);\n+                    s.print_unsafety(unsafety);\n                     s.word(\"mod\");\n                 }));\n                 self.print_ident(item.ident);\n \n-                if _mod.inline || self.is_expanded {\n-                    self.nbsp();\n-                    self.bopen();\n-                    self.print_mod(_mod, &item.attrs);\n-                    self.bclose(item.span);\n-                } else {\n-                    self.s.word(\";\");\n-                    self.end(); // end inner head-block\n-                    self.end(); // end outer head-block\n+                match mod_kind {\n+                    ModKind::Loaded(items, ..) => {\n+                        self.nbsp();\n+                        self.bopen();\n+                        self.print_inner_attributes(&item.attrs);\n+                        for item in items {\n+                            self.print_item(item);\n+                        }\n+                        self.bclose(item.span);\n+                    }\n+                    ModKind::Unloaded => {\n+                        self.s.word(\";\");\n+                        self.end(); // end inner head-block\n+                        self.end(); // end outer head-block\n+                    }\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n@@ -1681,7 +1679,7 @@ impl<'a> State<'a> {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.print_inner_attributes_inline(attrs);\n-        self.commasep_exprs(Inconsistent, &exprs[..]);\n+        self.commasep_exprs(Inconsistent, exprs);\n         self.s.word(\"]\");\n         self.end();\n     }\n@@ -1722,7 +1720,7 @@ impl<'a> State<'a> {\n         self.print_inner_attributes_inline(attrs);\n         self.commasep_cmnt(\n             Consistent,\n-            &fields[..],\n+            fields,\n             |s, field| {\n                 s.print_outer_attributes(&field.attrs);\n                 s.ibox(INDENT_UNIT);\n@@ -1757,7 +1755,7 @@ impl<'a> State<'a> {\n     fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>], attrs: &[ast::Attribute]) {\n         self.popen();\n         self.print_inner_attributes_inline(attrs);\n-        self.commasep_exprs(Inconsistent, &exprs[..]);\n+        self.commasep_exprs(Inconsistent, exprs);\n         if exprs.len() == 1 {\n             self.s.word(\",\");\n         }"}, {"sha": "e58b266fdb9e19d970bd694b998ce8ae96526892", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -176,23 +176,24 @@ pub fn find_stability(\n     sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n-) -> (Option<Stability>, Option<ConstStability>) {\n+) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>) {\n     find_stability_generic(sess, attrs.iter(), item_sp)\n }\n \n fn find_stability_generic<'a, I>(\n     sess: &Session,\n     attrs_iter: I,\n     item_sp: Span,\n-) -> (Option<Stability>, Option<ConstStability>)\n+) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>)\n where\n     I: Iterator<Item = &'a Attribute>,\n {\n     use StabilityLevel::*;\n \n-    let mut stab: Option<Stability> = None;\n-    let mut const_stab: Option<ConstStability> = None;\n+    let mut stab: Option<(Stability, Span)> = None;\n+    let mut const_stab: Option<(ConstStability, Span)> = None;\n     let mut promotable = false;\n+\n     let diagnostic = &sess.parse_sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n@@ -356,10 +357,12 @@ where\n                             }\n                             let level = Unstable { reason, issue: issue_num, is_soft };\n                             if sym::unstable == meta_name {\n-                                stab = Some(Stability { level, feature });\n+                                stab = Some((Stability { level, feature }, attr.span));\n                             } else {\n-                                const_stab =\n-                                    Some(ConstStability { level, feature, promotable: false });\n+                                const_stab = Some((\n+                                    ConstStability { level, feature, promotable: false },\n+                                    attr.span,\n+                                ));\n                             }\n                         }\n                         (None, _, _) => {\n@@ -432,10 +435,12 @@ where\n                         (Some(feature), Some(since)) => {\n                             let level = Stable { since };\n                             if sym::stable == meta_name {\n-                                stab = Some(Stability { level, feature });\n+                                stab = Some((Stability { level, feature }, attr.span));\n                             } else {\n-                                const_stab =\n-                                    Some(ConstStability { level, feature, promotable: false });\n+                                const_stab = Some((\n+                                    ConstStability { level, feature, promotable: false },\n+                                    attr.span,\n+                                ));\n                             }\n                         }\n                         (None, _) => {\n@@ -455,7 +460,7 @@ where\n \n     // Merge the const-unstable info into the stability info\n     if promotable {\n-        if let Some(ref mut stab) = const_stab {\n+        if let Some((ref mut stab, _)) = const_stab {\n             stab.promotable = promotable;\n         } else {\n             struct_span_err!(\n@@ -1035,22 +1040,22 @@ pub fn find_transparency(\n pub fn allow_internal_unstable<'a>(\n     sess: &'a Session,\n     attrs: &'a [Attribute],\n-) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+) -> impl Iterator<Item = Symbol> + 'a {\n     allow_unstable(sess, attrs, sym::allow_internal_unstable)\n }\n \n pub fn rustc_allow_const_fn_unstable<'a>(\n     sess: &'a Session,\n     attrs: &'a [Attribute],\n-) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+) -> impl Iterator<Item = Symbol> + 'a {\n     allow_unstable(sess, attrs, sym::rustc_allow_const_fn_unstable)\n }\n \n fn allow_unstable<'a>(\n     sess: &'a Session,\n     attrs: &'a [Attribute],\n     symbol: Symbol,\n-) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+) -> impl Iterator<Item = Symbol> + 'a {\n     let attrs = sess.filter_by_name(attrs, symbol);\n     let list = attrs\n         .filter_map(move |attr| {\n@@ -1064,7 +1069,7 @@ fn allow_unstable<'a>(\n         })\n         .flatten();\n \n-    Some(list.into_iter().filter_map(move |it| {\n+    list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {\n             sess.diagnostic().span_err(\n@@ -1073,5 +1078,5 @@ fn allow_unstable<'a>(\n             );\n         }\n         name\n-    }))\n+    })\n }"}, {"sha": "eea4d785dee069943941709d79c5b34f468b073d", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,157 @@\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast::mut_visit::{self, MutVisitor};\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, AstLike};\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_expand::config::StripUnconfigured;\n+use rustc_expand::configure;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use smallvec::SmallVec;\n+\n+crate fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    annotatable: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::cfg_eval);\n+    cfg_eval(ecx, annotatable)\n+}\n+\n+crate fn cfg_eval(ecx: &ExtCtxt<'_>, annotatable: Annotatable) -> Vec<Annotatable> {\n+    let mut visitor = CfgEval {\n+        cfg: StripUnconfigured { sess: ecx.sess, features: ecx.ecfg.features, modified: false },\n+    };\n+    let mut annotatable = visitor.configure_annotatable(annotatable);\n+    if visitor.cfg.modified {\n+        // Erase the tokens if cfg-stripping modified the item\n+        // This will cause us to synthesize fake tokens\n+        // when `nt_to_tokenstream` is called on this item.\n+        if let Some(tokens) = annotatable.tokens_mut() {\n+            *tokens = None;\n+        }\n+    }\n+    vec![annotatable]\n+}\n+\n+struct CfgEval<'a> {\n+    cfg: StripUnconfigured<'a>,\n+}\n+\n+impl CfgEval<'_> {\n+    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n+        self.cfg.configure(node)\n+    }\n+\n+    fn configure_annotatable(&mut self, annotatable: Annotatable) -> Annotatable {\n+        // Since the item itself has already been configured by the InvocationCollector,\n+        // we know that fold result vector will contain exactly one element\n+        match annotatable {\n+            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n+            Annotatable::TraitItem(item) => {\n+                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n+            }\n+            Annotatable::ImplItem(item) => {\n+                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n+            }\n+            Annotatable::ForeignItem(item) => {\n+                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n+            }\n+            Annotatable::Stmt(stmt) => {\n+                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n+            }\n+            Annotatable::Expr(mut expr) => Annotatable::Expr({\n+                self.visit_expr(&mut expr);\n+                expr\n+            }),\n+            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n+            Annotatable::Field(field) => {\n+                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n+            }\n+            Annotatable::FieldPat(fp) => {\n+                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n+            }\n+            Annotatable::GenericParam(param) => {\n+                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n+            }\n+            Annotatable::Param(param) => {\n+                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n+            }\n+            Annotatable::StructField(sf) => {\n+                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n+            }\n+            Annotatable::Variant(v) => {\n+                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n+            }\n+        }\n+    }\n+}\n+\n+impl MutVisitor for CfgEval<'_> {\n+    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr);\n+        mut_visit::noop_visit_expr(expr, self);\n+    }\n+\n+    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        let mut expr = configure!(self, expr);\n+        mut_visit::noop_visit_expr(&mut expr, self);\n+        Some(expr)\n+    }\n+\n+    fn flat_map_generic_param(\n+        &mut self,\n+        param: ast::GenericParam,\n+    ) -> SmallVec<[ast::GenericParam; 1]> {\n+        mut_visit::noop_flat_map_generic_param(configure!(self, param), self)\n+    }\n+\n+    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+        mut_visit::noop_flat_map_stmt(configure!(self, stmt), self)\n+    }\n+\n+    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        mut_visit::noop_flat_map_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        mut_visit::noop_flat_map_assoc_item(configure!(self, item), self)\n+    }\n+\n+    fn flat_map_foreign_item(\n+        &mut self,\n+        foreign_item: P<ast::ForeignItem>,\n+    ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n+        mut_visit::noop_flat_map_foreign_item(configure!(self, foreign_item), self)\n+    }\n+\n+    fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n+        mut_visit::noop_flat_map_arm(configure!(self, arm), self)\n+    }\n+\n+    fn flat_map_field(&mut self, field: ast::Field) -> SmallVec<[ast::Field; 1]> {\n+        mut_visit::noop_flat_map_field(configure!(self, field), self)\n+    }\n+\n+    fn flat_map_field_pattern(&mut self, fp: ast::FieldPat) -> SmallVec<[ast::FieldPat; 1]> {\n+        mut_visit::noop_flat_map_field_pattern(configure!(self, fp), self)\n+    }\n+\n+    fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n+        mut_visit::noop_flat_map_param(configure!(self, p), self)\n+    }\n+\n+    fn flat_map_struct_field(&mut self, sf: ast::StructField) -> SmallVec<[ast::StructField; 1]> {\n+        mut_visit::noop_flat_map_struct_field(configure!(self, sf), self)\n+    }\n+\n+    fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n+        mut_visit::noop_flat_map_variant(configure!(self, variant), self)\n+    }\n+}"}, {"sha": "0da2c1c1021f33224b1f79a2987a7e849830d531", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,7 +1,8 @@\n+use crate::cfg_eval::cfg_eval;\n+\n use rustc_ast::{self as ast, token, ItemKind, MetaItemKind, NestedMetaItem, StmtKind};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n-use rustc_expand::config::StripUnconfigured;\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n use rustc_session::Session;\n@@ -51,26 +52,7 @@ impl MultiItemModifier for Expander {\n \n         // FIXME: Try to cache intermediate results to avoid collecting same paths multiple times.\n         match ecx.resolver.resolve_derives(ecx.current_expansion.id, derives, ecx.force_mode) {\n-            Ok(()) => {\n-                let mut visitor =\n-                    StripUnconfigured { sess, features: ecx.ecfg.features, modified: false };\n-                let mut item = visitor.fully_configure(item);\n-                if visitor.modified {\n-                    // Erase the tokens if cfg-stripping modified the item\n-                    // This will cause us to synthesize fake tokens\n-                    // when `nt_to_tokenstream` is called on this item.\n-                    match &mut item {\n-                        Annotatable::Item(item) => item,\n-                        Annotatable::Stmt(stmt) => match &mut stmt.kind {\n-                            StmtKind::Item(item) => item,\n-                            _ => unreachable!(),\n-                        },\n-                        _ => unreachable!(),\n-                    }\n-                    .tokens = None;\n-                }\n-                ExpandResult::Ready(vec![item])\n-            }\n+            Ok(()) => ExpandResult::Ready(cfg_eval(ecx, item)),\n             Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }"}, {"sha": "7e88b58c0e29d99cecfdf21100332b4469be5112", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     parse::ArgumentNamed(s) => Named(s),\n                 };\n \n-                let ty = Placeholder(match &arg.format.ty[..] {\n+                let ty = Placeholder(match arg.format.ty {\n                     \"\" => \"Display\",\n                     \"?\" => \"Debug\",\n                     \"e\" => \"LowerExp\","}, {"sha": "0cc520e5bd1f0165d61b8a4ae8cf399b539edfea", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -312,7 +312,7 @@ pub mod printf {\n                 return Some((Substitution::Escape, &s[start + 2..]));\n             }\n \n-            Cur::new_at(&s[..], start)\n+            Cur::new_at(s, start)\n         };\n \n         // This is meant to be a translation of the following regex:\n@@ -673,7 +673,7 @@ pub mod shell {\n                 _ => { /* fall-through */ }\n             }\n \n-            Cur::new_at(&s[..], start)\n+            Cur::new_at(s, start)\n         };\n \n         let at = at.at_next_cp()?;"}, {"sha": "76d874529270e179167c66ce5a78fc0d9765e568", "filename": "compiler/rustc_builtin_macros/src/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -28,7 +28,7 @@ pub fn expand_global_asm<'cx>(\n             ident: Ident::invalid(),\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n-            kind: ast::ItemKind::GlobalAsm(P(global_asm)),\n+            kind: ast::ItemKind::GlobalAsm(global_asm),\n             vis: ast::Visibility {\n                 span: sp.shrink_to_lo(),\n                 kind: ast::VisibilityKind::Inherited,"}, {"sha": "a46a5502b24ad4acb88a81071f3fb7a6d4363eea", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -11,6 +11,7 @@\n #![feature(or_patterns)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n+#![recursion_limit = \"256\"]\n \n extern crate proc_macro;\n \n@@ -24,6 +25,7 @@ mod asm;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n+mod cfg_eval;\n mod compile_error;\n mod concat;\n mod concat_idents;\n@@ -89,6 +91,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     register_attr! {\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n+        cfg_eval: cfg_eval::expand,\n         derive: derive::Expander,\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,"}, {"sha": "71bbae1161b4bebcef863c749dde5e5f53697b2b", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -91,7 +91,7 @@ pub fn inject(\n     }\n \n     let decls = mk_decls(&mut krate, &mut cx, &macros);\n-    krate.module.items.push(decls);\n+    krate.items.push(decls);\n \n     krate\n }"}, {"sha": "4aafcb2fb6dfea067783c635dacaad92d0d9f67e", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n-use rustc_expand::module::DirectoryOwnership;\n+use rustc_expand::module::DirOwnership;\n use rustc_parse::parser::{ForceCollect, Parser};\n use rustc_parse::{self, new_parser_from_file};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n@@ -101,7 +101,7 @@ pub fn expand_include<'cx>(\n         None => return DummyResult::any(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let mut file = match cx.resolve_path(file, sp) {\n+    let file = match cx.resolve_path(file, sp) {\n         Ok(f) => f,\n         Err(mut err) => {\n             err.emit();\n@@ -114,10 +114,9 @@ pub fn expand_include<'cx>(\n     // then the path of `bar.rs` should be relative to the directory of `file`.\n     // See https://github.com/rust-lang/rust/pull/69838/files#r395217057 for a discussion.\n     // `MacroExpander::fully_expand_fragment` later restores, so \"stack discipline\" is maintained.\n-    file.pop();\n-    cx.current_expansion.directory_ownership = DirectoryOwnership::Owned { relative: None };\n-    let mod_path = cx.current_expansion.module.mod_path.clone();\n-    cx.current_expansion.module = Rc::new(ModuleData { mod_path, directory: file });\n+    let dir_path = file.parent().unwrap_or(&file).to_owned();\n+    cx.current_expansion.module = Rc::new(cx.current_expansion.module.with_dir_path(dir_path));\n+    cx.current_expansion.dir_ownership = DirOwnership::Owned { relative: None };\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,"}, {"sha": "fbd8be22a9de2391ee0138cbfab8c97054ba8c3a", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,9 +1,8 @@\n use rustc_ast as ast;\n-use rustc_ast::ptr::P;\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n use rustc_session::Session;\n-use rustc_span::edition::Edition;\n+use rustc_span::edition::Edition::*;\n use rustc_span::hygiene::AstPass;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n@@ -14,7 +13,7 @@ pub fn inject(\n     sess: &Session,\n     alt_std_name: Option<Symbol>,\n ) -> ast::Crate {\n-    let rust_2018 = sess.parse_sess.edition >= Edition::Edition2018;\n+    let edition = sess.parse_sess.edition;\n \n     // the first name in this list is the crate name of the crate with the prelude\n     let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n@@ -43,8 +42,12 @@ pub fn inject(\n \n     // .rev() to preserve ordering above in combination with insert(0, ...)\n     for &name in names.iter().rev() {\n-        let ident = if rust_2018 { Ident::new(name, span) } else { Ident::new(name, call_site) };\n-        krate.module.items.insert(\n+        let ident = if edition >= Edition2018 {\n+            Ident::new(name, span)\n+        } else {\n+            Ident::new(name, call_site)\n+        };\n+        krate.items.insert(\n             0,\n             cx.item(\n                 span,\n@@ -59,27 +62,31 @@ pub fn inject(\n     // the one with the prelude.\n     let name = names[0];\n \n-    let import_path = if rust_2018 {\n-        [name, sym::prelude, sym::v1].iter().map(|symbol| Ident::new(*symbol, span)).collect()\n-    } else {\n-        [kw::PathRoot, name, sym::prelude, sym::v1]\n-            .iter()\n-            .map(|symbol| Ident::new(*symbol, span))\n-            .collect()\n-    };\n+    let root = (edition == Edition2015).then(|| kw::PathRoot);\n+\n+    let import_path = root\n+        .iter()\n+        .chain(&[name, sym::prelude])\n+        .chain(&[match edition {\n+            Edition2015 => sym::rust_2015,\n+            Edition2018 => sym::rust_2018,\n+            Edition2021 => sym::rust_2021,\n+        }])\n+        .map(|&symbol| Ident::new(symbol, span))\n+        .collect();\n \n     let use_item = cx.item(\n         span,\n         Ident::invalid(),\n         vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n-        ast::ItemKind::Use(P(ast::UseTree {\n+        ast::ItemKind::Use(ast::UseTree {\n             prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,\n             span,\n-        })),\n+        }),\n     );\n \n-    krate.module.items.insert(0, use_item);\n+    krate.items.insert(0, use_item);\n \n     krate\n }"}, {"sha": "28e8259784387078e064de865d09c7c62e8cb286", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,10 +1,10 @@\n // Code that generates a test runner to run all the tests in a crate\n \n use rustc_ast as ast;\n-use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_ast::mut_visit::{ExpectOne, *};\n use rustc_ast::ptr::P;\n+use rustc_ast::{attr, ModKind};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_feature::Features;\n@@ -89,7 +89,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n         noop_visit_crate(c, self);\n \n         // Create a main function to run our tests\n-        c.module.items.push(mk_main(&mut self.cx));\n+        c.items.push(mk_main(&mut self.cx));\n     }\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -103,18 +103,22 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(mut module) = item.kind {\n+        if let ast::ItemKind::Mod(..) = item.kind {\n             let tests = mem::take(&mut self.tests);\n-            noop_visit_mod(&mut module, self);\n+            noop_visit_item_kind(&mut item.kind, self);\n             let mut tests = mem::replace(&mut self.tests, tests);\n \n             if !tests.is_empty() {\n                 let parent =\n                     if item.id == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { item.id };\n                 // Create an identifier that will hygienically resolve the test\n                 // case name, even in another module.\n+                let inner_span = match item.kind {\n+                    ast::ItemKind::Mod(_, ModKind::Loaded(.., span)) => span,\n+                    _ => unreachable!(),\n+                };\n                 let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n-                    module.inner,\n+                    inner_span,\n                     AstPass::TestHarness,\n                     &[],\n                     Some(parent),\n@@ -126,7 +130,6 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n                 }\n                 self.cx.test_cases.extend(tests);\n             }\n-            item.kind = ast::ItemKind::Mod(module);\n         }\n         smallvec![P(item)]\n     }"}, {"sha": "e173df423a76523f092160e138d648ea64c29651", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,25 @@\n+task:\n+  name: freebsd\n+  freebsd_instance:\n+    image: freebsd-12-1-release-amd64\n+  setup_rust_script:\n+    - pkg install -y curl git bash\n+    - curl https://sh.rustup.rs -sSf --output rustup.sh\n+    - sh rustup.sh --default-toolchain none -y --profile=minimal\n+  cargo_bin_cache:\n+    folder: ~/.cargo/bin\n+  target_cache:\n+    folder: target\n+  prepare_script:\n+    - . $HOME/.cargo/env\n+    - git config --global user.email \"user@example.com\"\n+    - git config --global user.name \"User\"\n+    - ./prepare.sh\n+  test_script:\n+    - . $HOME/.cargo/env\n+    - # Enable backtraces for easier debugging\n+    - export RUST_BACKTRACE=1\n+    - # Reduce amount of benchmark runs as they are slow\n+    - export COMPILE_RUNS=2\n+    - export RUN_RUNS=2\n+    - ./test.sh"}, {"sha": "e6d3375fb1bab6240d6d309259aa84657547a559", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -12,9 +12,6 @@ jobs:\n       fail-fast: false\n       matrix:\n         os: [ubuntu-latest, macos-latest]\n-        env:\n-          - BACKEND: \"\"\n-          - BACKEND: --oldbe\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -54,7 +51,7 @@ jobs:\n         export COMPILE_RUNS=2\n         export RUN_RUNS=2\n \n-        ./test.sh $BACKEND\n+        ./test.sh\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build"}, {"sha": "a13d5931ffa894099e1faee735dbc902244e86fe", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,6 +1,6 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n-    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n+    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"macro-error\"],\n     \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n     \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n     \"rust-analyzer.linkedProjects\": ["}, {"sha": "76d9f0d27ce461a143b28f36e83b161093f1485f", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 41, "deletions": 87, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,5 +1,7 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.38\"\n@@ -29,18 +31,6 @@ version = \"1.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ae44d1a3d5a19df61dd0c8beb138458ac2a53a7ac09eba97d55592540004306b\"\n \n-[[package]]\n-name = \"cc\"\n-version = \"1.0.66\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n-\n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n@@ -49,16 +39,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -75,27 +65,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -105,8 +95,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -123,8 +113,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -135,18 +125,17 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"cranelift-codegen\",\n- \"raw-cpuid\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#cdb60ec5a9df087262ae8960a31067e88cd80058\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -162,7 +151,7 @@ version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"81156fece84ab6a9f2afdb109ce3ae577e42b1228441eded99bd77f627953b1a\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -219,27 +208,27 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.82\"\n+version = \"0.2.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"89203f3fba0a3795506acaad8ebce3c80c0af93f994d5a1d7a0b1eeb23271929\"\n+checksum = \"b7282d924be3275cec7f6756ff4121987bc6481325397dde6ba3e7802b1a8b1c\"\n \n [[package]]\n name = \"libloading\"\n version = \"0.6.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"351a32417a12d5f7e82c368a66781e307834dae04c6ce0cd4456d52989229883\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"log\"\n-version = \"0.4.13\"\n+version = \"0.4.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fcf3805d4480bb5b86070dcfeb9e2cb2ebc148adb753c5cca5f884d1d65a42b2\"\n+checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -253,9 +242,9 @@ dependencies = [\n \n [[package]]\n name = \"object\"\n-version = \"0.22.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d3b63360ec3cb337817c2dbd47ab4a0f170d285d8e5a2064600f3def1402397\"\n+checksum = \"a9a7ab5d64814df0fe4a4b5ead45ed6c5f181ee3ff04ba344313a6c80446c5d4\"\n dependencies = [\n  \"crc32fast\",\n  \"indexmap\",\n@@ -272,24 +261,13 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.8\"\n+version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"991431c3519a3f36861882da93630ce66b52918dcf1b8e2fd66b397fc96f28df\"\n+checksum = \"c3d0b9745dc2debf507c8422de05d7226cc1f0644216dfdfead988f9b1ab32a7\"\n dependencies = [\n  \"proc-macro2\",\n ]\n \n-[[package]]\n-name = \"raw-cpuid\"\n-version = \"8.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fdf7d9dbd43f3d81d94a49c1c3df73cc2b3827995147e6cf7f89d4ec5483e73\"\n-dependencies = [\n- \"bitflags\",\n- \"cc\",\n- \"rustc_version\",\n-]\n-\n [[package]]\n name = \"regalloc\"\n version = \"0.0.31\"\n@@ -337,30 +315,6 @@ dependencies = [\n  \"target-lexicon\",\n ]\n \n-[[package]]\n-name = \"rustc_version\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n-dependencies = [\n- \"semver\",\n-]\n-\n-[[package]]\n-name = \"semver\"\n-version = \"0.9.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n-dependencies = [\n- \"semver-parser\",\n-]\n-\n-[[package]]\n-name = \"semver-parser\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\n [[package]]\n name = \"smallvec\"\n version = \"1.6.1\"\n@@ -369,9 +323,9 @@ checksum = \"fe0f37c9e8f3c5a4a66ad655a93c74daac4ad00c441533bf5c6e7990bb42604e\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.58\"\n+version = \"1.0.60\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc60a3d73ea6594cd712d830cc1f0390fd71542d8c8cd24e70cc54cdfd5e05d5\"\n+checksum = \"c700597eca8a5a762beb35753ef6b94df201c81cca676604f547495a0d7f0081\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -380,24 +334,24 @@ dependencies = [\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.11.1\"\n+version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ee5a98e506fb7231a304c3a1bd7c132a55016cf65001e0282480665870dfcb9\"\n+checksum = \"422045212ea98508ae3d28025bc5aaa2bd4a9cdaecd442a08da2ee620ee9ea95\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.23\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"76cc616c6abf8c8928e2fdcc0dbfab37175edd8fb49a4641066ad1364fdab146\"\n+checksum = \"e0f4a65597094d4483ddaed134f409b2cb7c1beccf25201a9f73c719254fa98e\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.23\"\n+version = \"1.0.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9be73a2caec27583d0046ef3796c3794f868a5bc813db689eed00c7631275cd1\"\n+checksum = \"7765189610d8241a44529806d6fd1f2e0a08734313a35d5b3a556f92b381f3c0\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "9861af1f8eae2cfb384cbaee7ad709937835465a", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,14 +9,14 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x86\", \"x64\"] }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x64\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n target-lexicon = \"0.11.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.22.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.23.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n@@ -38,7 +38,6 @@ smallvec = \"1.6.1\"\n default = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n-oldbe = []\n \n [profile.dev]\n # By compiling dependencies with optimizations, performing tests gets much faster."}, {"sha": "090349e54b1484a33856b7e18e39179318ef973c", "filename": "compiler/rustc_codegen_cranelift/build.sh", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,11 +1,10 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n # Settings\n export CHANNEL=\"release\"\n build_sysroot=\"clif\"\n target_dir='build'\n-oldbe=''\n while [[ $# != 0 ]]; do\n     case $1 in\n         \"--debug\")\n@@ -19,12 +18,9 @@ while [[ $# != 0 ]]; do\n             target_dir=$2\n             shift\n             ;;\n-        \"--oldbe\")\n-            oldbe='--features oldbe'\n-            ;;\n         *)\n             echo \"Unknown flag '$1'\"\n-            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--oldbe]\"\n+            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR]\"\n             exit 1\n             ;;\n     esac\n@@ -34,19 +30,19 @@ done\n # Build cg_clif\n unset CARGO_TARGET_DIR\n unamestr=$(uname)\n-if [[ \"$unamestr\" == 'Linux' ]]; then\n+if [[ \"$unamestr\" == 'Linux' || \"$unamestr\" == \"FreeBSD\" ]]; then\n    export RUSTFLAGS='-Clink-arg=-Wl,-rpath=$ORIGIN/../lib '$RUSTFLAGS\n elif [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS='-Csplit-debuginfo=unpacked -Clink-arg=-Wl,-rpath,@loader_path/../lib -Zosx-rpath-install-name '$RUSTFLAGS\n    dylib_ext='dylib'\n else\n-   echo \"Unsupported os\"\n+   echo \"Unsupported os $unamestr\"\n    exit 1\n fi\n if [[ \"$CHANNEL\" == \"release\" ]]; then\n-    cargo build $oldbe --release\n+    cargo build --release\n else\n-    cargo build $oldbe\n+    cargo build\n fi\n \n source scripts/ext_config.sh"}, {"sha": "a7650ab995b0fa4466619d9d28d27345b940f9f8", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,5 +1,7 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"addr2line\"\n version = \"0.14.1\"\n@@ -30,15 +32,6 @@ dependencies = [\n  \"core\",\n ]\n \n-[[package]]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"core\",\n- \"libc\",\n-]\n-\n [[package]]\n name = \"autocfg\"\n version = \"1.0.1\"\n@@ -47,9 +40,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.66\"\n+version = \"1.0.67\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n+checksum = \"e3c69b077ad434294d3ce9f1f6143a2a4b89a8a2d54ef813d85003a4fd1137fd\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -139,9 +132,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.84\"\n+version = \"0.2.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cca32fa0182e8c0989459524dc356b8f2b5c10f1b9eb521b7d182c03cf8c5ff\"\n+checksum = \"b7282d924be3275cec7f6756ff4121987bc6481325397dde6ba3e7802b1a8b1c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -258,7 +251,6 @@ name = \"sysroot\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"alloc_system\",\n  \"compiler_builtins\",\n  \"core\",\n  \"std\","}, {"sha": "04748d5dbab5951df6ef16995fccdc0f13f2f809", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,8 +9,6 @@ alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n-alloc_system = { path = \"./alloc_system\" }\n-\n compiler_builtins = { version = \"0.1.39\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]"}, {"sha": "9fffca843006fa1d936640f1f4280452ef6e8f7e", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Falloc_system%2FCargo.toml?ref=2285f11724e2fa3251c94c9ab7672544099600e2", "patch": "@@ -1,13 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\", \"bjorn3 (edited to be usable outside the rust source)\"]\n-name = \"alloc_system\"\n-version = \"0.0.0\"\n-[lib]\n-name = \"alloc_system\"\n-path = \"lib.rs\"\n-test = false\n-doc = false\n-[dependencies]\n-core = { path = \"../sysroot_src/library/core\" }\n-libc = { version = \"0.2.43\", features = ['rustc-dep-of-std'], default-features = false }\n-compiler_builtins = \"0.1\""}, {"sha": "636aa5f3f3dc2d1793f27270e3f270353e7b8f54", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n # Requires the CHANNEL env var to be set to `debug` or `release.`\n "}, {"sha": "c90205db0fbd067af3c33691164486277ddc1b56", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n cd \"$(dirname \"$0\")\"\n \n@@ -33,7 +33,7 @@ git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/\n pushd compiler-builtins\n git checkout -- .\n git checkout 0.1.39\n-git apply ../../crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch\n+git apply ../../crate_patches/000*-compiler-builtins-*.patch\n popd\n \n echo \"Successfully prepared sysroot source for building\""}, {"sha": "a7bbeb05cac5a094bc0103d5f676452cef77f8a5", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n \n rm -rf target/ build/ build_sysroot/{sysroot_src/,target/,compiler-builtins/} perf.data{,.old}"}, {"sha": "7daea99f5794d2103588c152a0ac02ca1b5b14b1", "filename": "compiler/rustc_codegen_cranelift/crate_patches/0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,48 @@\n+From 1d574bf5e32d51641dcacaf8ef777e95b44f6f2a Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:30:55 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ src/mem/mod.rs | 12 ------------\n+ 1 file changed, 12 deletions(-)\n+\n+diff --git a/src/mem/mod.rs b/src/mem/mod.rs\n+index 107762c..2d1ae10 100644\n+--- a/src/mem/mod.rs\n++++ b/src/mem/mod.rs\n+@@ -137,10 +137,6 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+         memcpy_element_unordered_atomic(dest, src, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-        memcpy_element_unordered_atomic(dest, src, bytes);\n+-    }\n+ \n+     #[cfg(target_has_atomic_load_store = \"8\")]\n+     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_1(dest: *mut u8, src: *const u8, bytes: usize) -> () {\n+@@ -158,10 +154,6 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+         memmove_element_unordered_atomic(dest, src, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-        memmove_element_unordered_atomic(dest, src, bytes);\n+-    }\n+ \n+     #[cfg(target_has_atomic_load_store = \"8\")]\n+     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_1(s: *mut u8, c: u8, bytes: usize) -> () {\n+@@ -179,8 +171,4 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_8(s: *mut u64, c: u8, bytes: usize) -> () {\n+         memset_element_unordered_atomic(s, c, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memset_element_unordered_atomic_16(s: *mut u128, c: u8, bytes: usize) -> () {\n+-        memset_element_unordered_atomic(s, c, bytes);\n+-    }\n+ }\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "71e93e87b6c4135c4d180cedeac7be72f64fabe7", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, alloc_system, core_intrinsics, alloc_prelude, alloc_error_handler)]\n+#![feature(start, box_syntax, core_intrinsics, alloc_prelude, alloc_error_handler)]\n #![no_std]\n \n extern crate alloc;"}, {"sha": "5f66ca67f2d409e9699c49a9fcda047c1e8c6ca9", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "renamed", "additions": 3, "deletions": 133, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -8,66 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![no_std]\n-#![allow(unused_attributes)]\n-#![unstable(feature = \"alloc_system\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"32838\")]\n-#![feature(allocator_api)]\n-#![feature(core_intrinsics)]\n-#![feature(nll)]\n-#![feature(staged_api)]\n-#![feature(rustc_attrs)]\n-#![feature(alloc_layout_extra)]\n-#![cfg_attr(\n-    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-    feature(integer_atomics, stdsimd)\n-)]\n+#![feature(allocator_api, rustc_private)]\n #![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n+\n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values.\n #[cfg(all(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n               target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"asmjs\",\n-              target_arch = \"wasm32\")))]\n-#[allow(dead_code)]\n+              target_arch = \"powerpc64\")))]\n const MIN_ALIGN: usize = 8;\n #[cfg(all(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n               target_arch = \"mips64\",\n               target_arch = \"s390x\",\n               target_arch = \"sparc64\")))]\n-#[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-/// The default memory allocator provided by the operating system.\n-///\n-/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n-/// plus related functions.\n-///\n-/// This type can be used in a `static` item\n-/// with the `#[global_allocator]` attribute\n-/// to force the global allocator to be the system\u2019s one.\n-/// (The default is jemalloc for executables, on some platforms.)\n-///\n-/// ```rust\n-/// use std::alloc::System;\n-///\n-/// #[global_allocator]\n-/// static A: System = System;\n-///\n-/// fn main() {\n-///     let a = Box::new(4); // Allocates from the system allocator.\n-///     println!(\"{}\", a);\n-/// }\n-/// ```\n-///\n-/// It can also be used directly to allocate memory\n-/// independently of the standard library\u2019s global allocator.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n pub struct System;\n #[cfg(any(windows, unix, target_os = \"redox\"))]\n mod realloc_fallback {\n@@ -96,7 +54,6 @@ mod platform {\n     use MIN_ALIGN;\n     use System;\n     use core::alloc::{GlobalAlloc, Layout};\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n         unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n@@ -221,7 +178,6 @@ mod platform {\n         };\n         ptr as *mut u8\n     }\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n         unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n@@ -254,89 +210,3 @@ mod platform {\n         }\n     }\n }\n-// This is an implementation of a global allocator on the wasm32 platform when\n-// emscripten is not in use. In that situation there's no actual runtime for us\n-// to lean on for allocation, so instead we provide our own!\n-//\n-// The wasm32 instruction set has two instructions for getting the current\n-// amount of memory and growing the amount of memory. These instructions are the\n-// foundation on which we're able to build an allocator, so we do so! Note that\n-// the instructions are also pretty \"global\" and this is the \"global\" allocator\n-// after all!\n-//\n-// The current allocator here is the `dlmalloc` crate which we've got included\n-// in the rust-lang/rust repository as a submodule. The crate is a port of\n-// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n-// for now which is currently technically required (can't link with C yet).\n-//\n-// The crate itself provides a global allocator which on wasm has no\n-// synchronization as there are no threads!\n-#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n-mod platform {\n-    extern crate dlmalloc;\n-    use core::alloc::{GlobalAlloc, Layout};\n-    use System;\n-    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n-    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-    unsafe impl GlobalAlloc for System {\n-        #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.malloc(layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.calloc(layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-            let _lock = lock::lock();\n-            DLMALLOC.free(ptr, layout.size(), layout.align())\n-        }\n-        #[inline]\n-        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-            let _lock = lock::lock();\n-            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n-        }\n-    }\n-    #[cfg(target_feature = \"atomics\")]\n-    mod lock {\n-        use core::arch::wasm32;\n-        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n-        static LOCKED: AtomicI32 = AtomicI32::new(0);\n-        pub struct DropLock;\n-        pub fn lock() -> DropLock {\n-            loop {\n-                if LOCKED.swap(1, SeqCst) == 0 {\n-                    return DropLock\n-                }\n-                unsafe {\n-                    let r = wasm32::atomic::wait_i32(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1,  // expected value\n-                        -1, // timeout\n-                    );\n-                    debug_assert!(r == 0 || r == 1);\n-                }\n-            }\n-        }\n-        impl Drop for DropLock {\n-            fn drop(&mut self) {\n-                let r = LOCKED.swap(0, SeqCst);\n-                debug_assert_eq!(r, 1);\n-                unsafe {\n-                    wasm32::atomic::wake(\n-                        &LOCKED as *const AtomicI32 as *mut i32,\n-                        1, // only one thread\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    #[cfg(not(target_feature = \"atomics\"))]\n-    mod lock {\n-        #[inline]\n-        pub fn lock() {} // no atomics, no threads, that's easy!\n-    }\n-}", "previous_filename": "compiler/rustc_codegen_cranelift/build_sysroot/alloc_system/lib.rs"}, {"sha": "ddeb752f93ed71257d6dd2e39d33b372416eca1a", "filename": "compiler/rustc_codegen_cranelift/example/arbitrary_self_types_pointers_and_wrappers.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,22 +1,12 @@\n // Adapted from rustc run-pass test suite\n \n-#![feature(no_core, arbitrary_self_types, box_syntax)]\n+#![feature(arbitrary_self_types, unsize, coerce_unsized, dispatch_from_dyn)]\n #![feature(rustc_attrs)]\n \n-#![feature(start, lang_items)]\n-#![no_core]\n-\n-extern crate mini_core;\n-\n-use mini_core::*;\n-\n-macro_rules! assert_eq {\n-    ($l:expr, $r: expr) => {\n-        if $l != $r {\n-            panic(stringify!($l != $r));\n-        }\n-    }\n-}\n+use std::{\n+    ops::{Deref, CoerceUnsized, DispatchFromDyn},\n+    marker::Unsize,\n+};\n \n struct Ptr<T: ?Sized>(Box<T>);\n \n@@ -67,16 +57,13 @@ impl Trait for i32 {\n     }\n }\n \n-#[start]\n-fn main(_: isize, _: *const *const u8) -> isize {\n-    let pw = Ptr(box Wrapper(5)) as Ptr<Wrapper<dyn Trait>>;\n+fn main() {\n+    let pw = Ptr(Box::new(Wrapper(5))) as Ptr<Wrapper<dyn Trait>>;\n     assert_eq!(pw.ptr_wrapper(), 5);\n \n-    let wp = Wrapper(Ptr(box 6)) as Wrapper<Ptr<dyn Trait>>;\n+    let wp = Wrapper(Ptr(Box::new(6))) as Wrapper<Ptr<dyn Trait>>;\n     assert_eq!(wp.wrapper_ptr(), 6);\n \n-    let wpw = Wrapper(Ptr(box Wrapper(7))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n+    let wpw = Wrapper(Ptr(Box::new(Wrapper(7)))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n     assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n-\n-    0\n }"}, {"sha": "7c6d7fc106ded4c3ef44ed9f334a36ac1bb1598a", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -365,6 +365,22 @@ impl <T: PartialEq> PartialEq for Option<T> {\n     }\n }\n \n+#[lang = \"shl\"]\n+pub trait Shl<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn shl(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Shl for u128 {\n+    type Output = u128;\n+\n+    fn shl(self, rhs: u128) -> u128 {\n+        self << rhs\n+    }\n+}\n+\n #[lang = \"neg\"]\n pub trait Neg {\n     type Output;"}, {"sha": "237f4d11d57f1c628454ebbb843eda33f9afb5a0", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -264,6 +264,9 @@ fn main() {\n     assert_eq!(f2 as i8, -128);\n     assert_eq!(f2 as u8, 0);\n \n+    let amount = 0;\n+    assert_eq!(1u128 << amount, 1);\n+\n     static ANOTHER_STATIC: &u8 = &A_STATIC;\n     assert_eq!(*ANOTHER_STATIC, 42);\n "}, {"sha": "8cfffe580a1f0ef9be7dc3f207d4d399465de3de", "filename": "compiler/rustc_codegen_cranelift/patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -119,21 +119,5 @@ index 6609bc3..241b497 100644\n  \n  #[test]\n  #[should_panic(expected = \"index 0 greater than length of slice\")]\n-diff --git a/library/core/tests/num/ops.rs b/library/core/tests/num/ops.rs\n-index 9979cc8..d5d1d83 100644\n---- a/library/core/tests/num/ops.rs\n-+++ b/library/core/tests/num/ops.rs\n-@@ -238,7 +238,7 @@ macro_rules! test_shift_assign {\n-         }\n-     };\n- }\n--test_shift!(test_shl_defined, Shl::shl);\n--test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n--test_shift!(test_shr_defined, Shr::shr);\n--test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n-+//test_shift!(test_shl_defined, Shl::shl);\n-+//test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n-+//test_shift!(test_shr_defined, Shr::shr);\n-+//test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "32e5930969061f0231ecc6e89c72eb77be7002cb", "filename": "compiler/rustc_codegen_cranelift/patches/0027-Disable-128bit-atomic-operations.patch", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-Disable-128bit-atomic-operations.patch?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,103 @@\n+From 894e07dfec2624ba539129b1c1d63e1d7d812bda Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:45:28 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ library/core/src/sync/atomic.rs | 38 ---------------------------------\n+ library/core/tests/atomic.rs    |  4 ----\n+ library/std/src/panic.rs        |  6 ------\n+ 3 files changed, 48 deletions(-)\n+\n+diff --git a/library/core/src/sync/atomic.rs b/library/core/src/sync/atomic.rs\n+index 81c9e1d..65c9503 100644\n+--- a/library/core/src/sync/atomic.rs\n++++ b/library/core/src/sync/atomic.rs\n+@@ -2228,44 +2228,6 @@ atomic_int! {\n+     \"AtomicU64::new(0)\",\n+     u64 AtomicU64 ATOMIC_U64_INIT\n+ }\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-atomic_int! {\n+-    cfg(target_has_atomic = \"128\"),\n+-    cfg(target_has_atomic_equal_alignment = \"128\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    \"i128\",\n+-    \"#![feature(integer_atomics)]\\n\\n\",\n+-    atomic_min, atomic_max,\n+-    16,\n+-    \"AtomicI128::new(0)\",\n+-    i128 AtomicI128 ATOMIC_I128_INIT\n+-}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-atomic_int! {\n+-    cfg(target_has_atomic = \"128\"),\n+-    cfg(target_has_atomic_equal_alignment = \"128\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    \"u128\",\n+-    \"#![feature(integer_atomics)]\\n\\n\",\n+-    atomic_umin, atomic_umax,\n+-    16,\n+-    \"AtomicU128::new(0)\",\n+-    u128 AtomicU128 ATOMIC_U128_INIT\n+-}\n+ \n+ macro_rules! atomic_int_ptr_sized {\n+     ( $($target_pointer_width:literal $align:literal)* ) => { $(\n+diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+index 2d1e449..cb6da5d 100644\n+--- a/library/core/tests/atomic.rs\n++++ b/library/core/tests/atomic.rs\n+@@ -145,10 +145,6 @@ fn atomic_alignment() {\n+     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n+     #[cfg(target_has_atomic = \"64\")]\n+     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+diff --git a/library/std/src/panic.rs b/library/std/src/panic.rs\n+index 89a822a..779fd88 100644\n+--- a/library/std/src/panic.rs\n++++ b/library/std/src/panic.rs\n+@@ -279,9 +279,6 @@ impl RefUnwindSafe for atomic::AtomicI32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for atomic::AtomicI64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for atomic::AtomicI128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"ptr\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+@@ -298,9 +295,6 @@ impl RefUnwindSafe for atomic::AtomicU32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for atomic::AtomicU64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for atomic::AtomicU128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"8\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "ee995ffcfa9f7df9692746f6ca56506de949ef2b", "filename": "compiler/rustc_codegen_cranelift/prepare.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fprepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fprepare.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n \n rustup component add rust-src rustc-dev llvm-tools-preview"}, {"sha": "908ca52135b668b137e29523282b5e467ccecc43", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1 +1 @@\n-nightly-2021-01-30\n+nightly-2021-03-05"}, {"sha": "2bd8f7d1bc15d7a6690a34aad18f968f7af9bd3c", "filename": "compiler/rustc_codegen_cranelift/rustfmt.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frustfmt.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,4 @@\n+# Matches rustfmt.toml of rustc\n+version = \"Two\"\n+use_small_heuristics = \"Max\"\n+merge_derives = false"}, {"sha": "669d2d45b71b5471e874e475e63bcff7108884fc", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n dir=$(dirname \"$0\")\n source \"$dir/config.sh\""}, {"sha": "c2ed2bf256d5980a188421ba69b229777e2c8d16", "filename": "compiler/rustc_codegen_cranelift/scripts/config.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -3,7 +3,7 @@\n set -e\n \n unamestr=$(uname)\n-if [[ \"$unamestr\" == 'Linux' ]]; then\n+if [[ \"$unamestr\" == 'Linux' || \"$unamestr\" == 'FreeBSD' ]]; then\n    dylib_ext='so'\n elif [[ \"$unamestr\" == 'Darwin' ]]; then\n    dylib_ext='dylib'\n@@ -26,7 +26,7 @@ export RUSTC=$dir\"/bin/cg_clif\"\n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n '-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n \n-# FIXME remove once the atomic shim is gone\n+# FIXME fix `#[linkage = \"extern_weak\"]` without this\n if [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi"}, {"sha": "694945a87c268deaa890288ab55ff7b5bbe1f601", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n set -e\n "}, {"sha": "6473c6ad67d2e6e45b31274a172132719943ec24", "filename": "compiler/rustc_codegen_cranelift/scripts/test_bootstrap.sh", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_bootstrap.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n cd \"$(dirname \"$0\")/../\"\n@@ -14,21 +14,18 @@ git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n git apply - <<EOF\n-diff --git a/.gitmodules b/.gitmodules\n-index 984113151de..c1e9d960d56 100644\n---- a/.gitmodules\n-+++ b/.gitmodules\n-@@ -34,10 +34,6 @@\n- [submodule \"src/doc/edition-guide\"]\n- \tpath = src/doc/edition-guide\n- \turl = https://github.com/rust-lang/edition-guide.git\n--[submodule \"src/llvm-project\"]\n--\tpath = src/llvm-project\n--\turl = https://github.com/rust-lang/llvm-project.git\n--\tbranch = rustc/11.0-2020-10-12\n- [submodule \"src/doc/embedded-book\"]\n- \tpath = src/doc/embedded-book\n- \turl = https://github.com/rust-embedded/book.git\n+diff --git a/Cargo.toml b/Cargo.toml\n+index 5bd1147cad5..10d68a2ff14 100644\n+--- a/Cargo.toml\n++++ b/Cargo.toml\n+@@ -111,5 +111,7 @@ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+ rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n+ rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n+ \n++compiler_builtins = { path = \"../build_sysroot/compiler-builtins\" }\n++\n+ [patch.\"https://github.com/rust-lang/rust-clippy\"]\n+ clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\n index 23e689fcae7..5f077b765b6 100644\n --- a/compiler/rustc_data_structures/Cargo.toml\n@@ -41,6 +38,19 @@ index 23e689fcae7..5f077b765b6 100644\n \n  [target.'cfg(windows)'.dependencies]\n  winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }\n+diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n+index d95b5b7f17f..00b6f0e3635 100644\n+--- a/library/alloc/Cargo.toml\n++++ b/library/alloc/Cargo.toml\n+@@ -8,7 +8,7 @@ edition = \"2018\"\n+ \n+ [dependencies]\n+ core = { path = \"../core\" }\n+-compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n++compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std', 'no-asm'] }\n+ \n+ [dev-dependencies]\n+ rand = \"0.7\"\n EOF\n \n cat > config.toml <<EOF"}, {"sha": "f9a9fb091fb4ac0117eec2e9315882e54082d6d6", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n set -e\n \n@@ -27,13 +27,16 @@ function no_sysroot_tests() {\n     $MY_RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n     # (echo \"break set -n main\"; echo \"run\"; sleep 1; echo \"si -c 10\"; sleep 1; echo \"frame variable\") | lldb -- ./target/out/mini_core_hello_world abc bcd\n+}\n \n+function base_sysroot_tests() {\n     echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n     $MY_RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n-}\n \n-function base_sysroot_tests() {\n+    echo \"[AOT] alloc_system\"\n+    $MY_RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n+\n     echo \"[AOT] alloc_example\"\n     $MY_RUSTC example/alloc_example.rs --crate-type bin --target \"$TARGET_TRIPLE\"\n     $RUN_WRAPPER ./target/out/alloc_example"}, {"sha": "c3cf90e1e70be209295c81096cdfa3dfe5291ab2", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 18, "deletions": 38, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -10,14 +10,14 @@ use cranelift_codegen::entity::EntityRef;\n \n use crate::prelude::*;\n \n-pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n     fx.add_global_comment(\n         \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n     );\n }\n \n pub(super) fn add_arg_comment<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     kind: &str,\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n@@ -42,11 +42,7 @@ pub(super) fn add_arg_comment<'tcx>(\n         [param_a, param_b] => Cow::Owned(format!(\"= {:?},{:?}\", param_a, param_b)),\n         params => Cow::Owned(format!(\n             \"= {}\",\n-            params\n-                .iter()\n-                .map(ToString::to_string)\n-                .collect::<Vec<_>>()\n-                .join(\",\")\n+            params.iter().map(ToString::to_string).collect::<Vec<_>>().join(\",\")\n         )),\n     };\n \n@@ -62,27 +58,21 @@ pub(super) fn add_arg_comment<'tcx>(\n     ));\n }\n \n-pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n     fx.add_global_comment(String::new());\n     fx.add_global_comment(\n         \"kind  local ty                              size align (abi,pref)\".to_string(),\n     );\n }\n \n pub(super) fn add_local_place_comments<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     local: Local,\n ) {\n     let TyAndLayout { ty, layout } = place.layout();\n-    let rustc_target::abi::Layout {\n-        size,\n-        align,\n-        abi: _,\n-        variants: _,\n-        fields: _,\n-        largest_niche: _,\n-    } = layout;\n+    let rustc_target::abi::Layout { size, align, abi: _, variants: _, fields: _, largest_niche: _ } =\n+        layout;\n \n     let (kind, extra) = match *place.inner() {\n         CPlaceInner::Var(place_local, var) => {\n@@ -91,10 +81,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         }\n         CPlaceInner::VarPair(place_local, var1, var2) => {\n             assert_eq!(local, place_local);\n-            (\n-                \"ssa\",\n-                Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())),\n-            )\n+            (\"ssa\", Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())))\n         }\n         CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n         CPlaceInner::Addr(ptr, meta) => {\n@@ -104,18 +91,15 @@ pub(super) fn add_local_place_comments<'tcx>(\n                 Cow::Borrowed(\"\")\n             };\n             match ptr.base_and_offset() {\n-                (crate::pointer::PointerBase::Addr(addr), offset) => (\n-                    \"reuse\",\n-                    format!(\"storage={}{}{}\", addr, offset, meta).into(),\n-                ),\n-                (crate::pointer::PointerBase::Stack(stack_slot), offset) => (\n-                    \"stack\",\n-                    format!(\"storage={}{}{}\", stack_slot, offset, meta).into(),\n-                ),\n-                (crate::pointer::PointerBase::Dangling(align), offset) => (\n-                    \"zst\",\n-                    format!(\"align={},offset={}\", align.bytes(), offset).into(),\n-                ),\n+                (crate::pointer::PointerBase::Addr(addr), offset) => {\n+                    (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n+                    (\"stack\", format!(\"storage={}{}{}\", stack_slot, offset, meta).into())\n+                }\n+                (crate::pointer::PointerBase::Dangling(align), offset) => {\n+                    (\"zst\", format!(\"align={},offset={}\", align.bytes(), offset).into())\n+                }\n             }\n         }\n     };\n@@ -128,11 +112,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         size.bytes(),\n         align.abi.bytes(),\n         align.pref.bytes(),\n-        if extra.is_empty() {\n-            \"\"\n-        } else {\n-            \"              \"\n-        },\n+        if extra.is_empty() { \"\" } else { \"              \" },\n         extra,\n     ));\n }"}, {"sha": "b158d73f3a1a89cbcc566dbfd2f2d75f7569792b", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 35, "deletions": 106, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -38,25 +38,15 @@ fn clif_sig_from_fn_abi<'tcx>(\n         | Conv::X86VectorCall\n         | Conv::AmdGpuKernel\n         | Conv::AvrInterrupt\n-        | Conv::AvrNonBlockingInterrupt => {\n-            todo!(\"{:?}\", fn_abi.conv)\n-        }\n+        | Conv::AvrNonBlockingInterrupt => todo!(\"{:?}\", fn_abi.conv),\n     };\n-    let inputs = fn_abi\n-        .args\n-        .iter()\n-        .map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter())\n-        .flatten();\n+    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n \n     let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n     // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n     let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n-    Signature {\n-        params,\n-        returns,\n-        call_conv,\n-    }\n+    Signature { params, returns, call_conv }\n }\n \n pub(crate) fn get_function_sig<'tcx>(\n@@ -65,34 +55,25 @@ pub(crate) fn get_function_sig<'tcx>(\n     inst: Instance<'tcx>,\n ) -> Signature {\n     assert!(!inst.substs.needs_infer());\n-    clif_sig_from_fn_abi(\n-        tcx,\n-        triple,\n-        &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]),\n-    )\n+    clif_sig_from_fn_abi(tcx, triple, &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]))\n }\n \n /// Instance must be monomorphized\n pub(crate) fn import_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name.to_string();\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module\n-        .declare_function(&name, Linkage::Import, &sig)\n-        .unwrap()\n+    module.declare_function(&name, Linkage::Import, &sig).unwrap()\n }\n \n-impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, &mut self.cx.module, inst);\n-        let func_ref = self\n-            .cx\n-            .module\n-            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = import_function(self.tcx, self.cx.module, inst);\n+        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n         #[cfg(debug_assertions)]\n         self.add_comment(func_ref, format!(\"{:?}\", inst));\n@@ -107,20 +88,9 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n-        let sig = Signature {\n-            params,\n-            returns,\n-            call_conv: CallConv::triple_default(self.triple()),\n-        };\n-        let func_id = self\n-            .cx\n-            .module\n-            .declare_function(&name, Linkage::Import, &sig)\n-            .unwrap();\n-        let func_ref = self\n-            .cx\n-            .module\n-            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n+        let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         #[cfg(debug_assertions)]\n         {\n@@ -140,17 +110,12 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         let (input_tys, args): (Vec<_>, Vec<_>) = args\n             .iter()\n             .map(|arg| {\n-                (\n-                    AbiParam::new(self.clif_type(arg.layout().ty).unwrap()),\n-                    arg.load_scalar(self),\n-                )\n+                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types()\n-                .map(|ty| AbiParam::new(self.clif_type(ty).unwrap()))\n-                .collect()\n+            tup.types().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n         } else {\n             vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n@@ -169,7 +134,7 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n \n /// Make a [`CPlace`] capable of holding value of the specified type.\n fn make_local_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     local: Local,\n     layout: TyAndLayout<'tcx>,\n     is_ssa: bool,\n@@ -190,10 +155,7 @@ fn make_local_place<'tcx>(\n     place\n }\n \n-pub(crate) fn codegen_fn_prelude<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    start_block: Block,\n-) {\n+pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_block: Block) {\n     fx.bcx.append_block_params_for_function_params(start_block);\n \n     fx.bcx.switch_to_block(start_block);\n@@ -204,13 +166,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n-    let mut block_params_iter = fx\n-        .bcx\n-        .func\n-        .dfg\n-        .block_params(start_block)\n-        .to_vec()\n-        .into_iter();\n+    let mut block_params_iter = fx.bcx.func.dfg.block_params(start_block).to_vec().into_iter();\n     let ret_place =\n         self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n@@ -286,10 +242,10 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n             if let Some((addr, meta)) = val.try_to_ptr() {\n                 let local_decl = &fx.mir.local_decls[local];\n                 //                       v this ! is important\n-                let internally_mutable = !val.layout().ty.is_freeze(\n-                    fx.tcx.at(local_decl.source_info.span),\n-                    ParamEnv::reveal_all(),\n-                );\n+                let internally_mutable = !val\n+                    .layout()\n+                    .ty\n+                    .is_freeze(fx.tcx.at(local_decl.source_info.span), ParamEnv::reveal_all());\n                 if local_decl.mutability == mir::Mutability::Not && !internally_mutable {\n                     // We wont mutate this argument, so it is fine to borrow the backing storage\n                     // of this argument, to prevent a copy.\n@@ -321,9 +277,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n             ArgKind::Spread(params) => {\n                 for (i, param) in params.into_iter().enumerate() {\n                     if let Some(param) = param {\n-                        place\n-                            .place_field(fx, mir::Field::new(i))\n-                            .write_cvalue(fx, param);\n+                        place.place_field(fx, mir::Field::new(i)).write_cvalue(fx, param);\n                     }\n                 }\n             }\n@@ -340,23 +294,20 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         assert_eq!(fx.local_map.push(place), local);\n     }\n \n-    fx.bcx\n-        .ins()\n-        .jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n+    fx.bcx.ins().jump(*fx.block_map.get(START_BLOCK).unwrap(), &[]);\n }\n \n pub(crate) fn codegen_terminator_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n     current_block: Block,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n     destination: Option<(Place<'tcx>, BasicBlock)>,\n ) {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig = fx\n-        .tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let fn_sig =\n+        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n     let destination = destination.map(|(place, bb)| (codegen_place(fx, place), bb));\n \n@@ -404,20 +355,11 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let fn_abi = if let Some(instance) = instance {\n         FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(\n-            &RevealAllLayoutCx(fx.tcx),\n-            fn_ty.fn_sig(fx.tcx),\n-            &extra_args,\n-        )\n+        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n     };\n \n     let is_cold = instance\n-        .map(|inst| {\n-            fx.tcx\n-                .codegen_fn_attrs(inst.def_id())\n-                .flags\n-                .contains(CodegenFnAttrFlags::COLD)\n-        })\n+        .map(|inst| fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD))\n         .unwrap_or(false);\n     if is_cold {\n         fx.cold_blocks.insert(current_block);\n@@ -441,20 +383,15 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         }\n         args\n     } else {\n-        args.iter()\n-            .map(|arg| codegen_operand(fx, arg))\n-            .collect::<Vec<_>>()\n+        args.iter().map(|arg| codegen_operand(fx, arg)).collect::<Vec<_>>()\n     };\n \n     //   | indirect call target\n     //   |         | the first argument to be passed\n     //   v         v\n     let (func_ref, first_arg) = match instance {\n         // Trait object call\n-        Some(Instance {\n-            def: InstanceDef::Virtual(_, idx),\n-            ..\n-        }) => {\n+        Some(Instance { def: InstanceDef::Virtual(_, idx), .. }) => {\n             #[cfg(debug_assertions)]\n             {\n                 let nop_inst = fx.bcx.ins().nop();\n@@ -511,10 +448,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 )\n                 .collect::<Vec<_>>();\n \n-            if instance\n-                .map(|inst| inst.def.requires_caller_location(fx.tcx))\n-                .unwrap_or(false)\n-            {\n+            if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n                 call_args.extend(\n@@ -542,7 +476,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n-        if fn_sig.abi != Abi::C {\n+        if !matches!(fn_sig.abi, Abi::C { .. }) {\n             fx.tcx.sess.span_fatal(\n                 span,\n                 &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n@@ -555,9 +489,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let ty = fx.bcx.func.dfg.value_type(arg);\n                 if !ty.is_int() {\n                     // FIXME set %al to upperbound on float args once floats are supported\n-                    fx.tcx\n-                        .sess\n-                        .span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n+                    fx.tcx.sess.span_fatal(span, &format!(\"Non int ty {:?} for variadic call\", ty));\n                 }\n                 AbiParam::new(ty)\n             })\n@@ -574,7 +506,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n }\n \n pub(crate) fn codegen_drop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n     drop_place: CPlace<'tcx>,\n ) {\n@@ -611,10 +543,7 @@ pub(crate) fn codegen_drop<'tcx>(\n                     fx,\n                     fx.layout_of(fx.tcx.mk_ref(\n                         &ty::RegionKind::ReErased,\n-                        TypeAndMut {\n-                            ty,\n-                            mutbl: crate::rustc_hir::Mutability::Mut,\n-                        },\n+                        TypeAndMut { ty, mutbl: crate::rustc_hir::Mutability::Mut },\n                     )),\n                 );\n                 let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);"}, {"sha": "d58f952f53c1a6d4087dd81d7d18e5881e217513", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 27, "deletions": 81, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -71,12 +71,7 @@ fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n         .prefix\n         .iter()\n         .flatten()\n-        .map(|&kind| {\n-            reg_to_abi_param(Reg {\n-                kind,\n-                size: cast.prefix_chunk_size,\n-            })\n-        })\n+        .map(|&kind| reg_to_abi_param(Reg { kind, size: cast.prefix_chunk_size }))\n         .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n         .collect::<SmallVec<_>>();\n \n@@ -98,12 +93,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         match self.mode {\n             PassMode::Ignore => smallvec![],\n             PassMode::Direct(attrs) => match &self.layout.abi {\n-                Abi::Scalar(scalar) => {\n-                    smallvec![apply_arg_attrs_to_abi_param(\n-                        AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n-                        attrs\n-                    )]\n-                }\n+                Abi::Scalar(scalar) => smallvec![apply_arg_attrs_to_abi_param(\n+                    AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n+                    attrs\n+                )],\n                 Abi::Vector { .. } => {\n                     let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n                     smallvec![AbiParam::new(vector_ty)]\n@@ -122,29 +115,18 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n             PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n-            PassMode::Indirect {\n-                attrs,\n-                extra_attrs: None,\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     let size = u32::try_from(self.layout.size.bytes()).unwrap();\n                     smallvec![apply_arg_attrs_to_abi_param(\n                         AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructArgument(size),),\n                         attrs\n                     )]\n                 } else {\n-                    smallvec![apply_arg_attrs_to_abi_param(\n-                        AbiParam::new(pointer_ty(tcx)),\n-                        attrs\n-                    )]\n+                    smallvec![apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs)]\n                 }\n             }\n-            PassMode::Indirect {\n-                attrs,\n-                extra_attrs: Some(extra_attrs),\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack } => {\n                 assert!(!on_stack);\n                 smallvec![\n                     apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs),\n@@ -158,10 +140,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         match self.mode {\n             PassMode::Ignore => (None, vec![]),\n             PassMode::Direct(_) => match &self.layout.abi {\n-                Abi::Scalar(scalar) => (\n-                    None,\n-                    vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))],\n-                ),\n+                Abi::Scalar(scalar) => {\n+                    (None, vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))])\n+                }\n                 Abi::Vector { .. } => {\n                     let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n                     (None, vec![AbiParam::new(vector_ty)])\n@@ -177,31 +158,19 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n             PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n-            PassMode::Indirect {\n-                attrs: _,\n-                extra_attrs: None,\n-                on_stack,\n-            } => {\n+            PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n-                (\n-                    Some(AbiParam::special(\n-                        pointer_ty(tcx),\n-                        ArgumentPurpose::StructReturn,\n-                    )),\n-                    vec![],\n-                )\n+                (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n+            }\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+                unreachable!(\"unsized return value\")\n             }\n-            PassMode::Indirect {\n-                attrs: _,\n-                extra_attrs: Some(_),\n-                on_stack: _,\n-            } => unreachable!(\"unsized return value\"),\n         }\n     }\n }\n \n pub(super) fn to_casted_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     cast: CastTarget,\n ) -> SmallVec<[Value; 2]> {\n@@ -211,26 +180,21 @@ pub(super) fn to_casted_value<'tcx>(\n     cast_target_to_abi_params(cast)\n         .into_iter()\n         .map(|param| {\n-            let val = ptr\n-                .offset_i64(fx, offset)\n-                .load(fx, param.value_type, MemFlags::new());\n+            let val = ptr.offset_i64(fx, offset).load(fx, param.value_type, MemFlags::new());\n             offset += i64::from(param.value_type.bytes());\n             val\n         })\n         .collect()\n }\n \n pub(super) fn from_casted_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n     cast: CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n-    let abi_param_size: u32 = abi_params\n-        .iter()\n-        .map(|param| param.value_type.bytes())\n-        .sum();\n+    let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n     let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n     let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n         kind: StackSlotKind::ExplicitSlot,\n@@ -260,7 +224,7 @@ pub(super) fn from_casted_value<'tcx>(\n \n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n ) -> SmallVec<[Value; 2]> {\n@@ -283,7 +247,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// Create a [`CValue`] containing the value of a function parameter adding clif function parameters\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n@@ -294,10 +258,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n         .into_iter()\n         .map(|abi_param| {\n             let block_param = block_params_iter.next().unwrap();\n-            assert_eq!(\n-                fx.bcx.func.dfg.value_type(block_param),\n-                abi_param.value_type\n-            );\n+            assert_eq!(fx.bcx.func.dfg.value_type(block_param), abi_param.value_type);\n             block_param\n         })\n         .collect::<SmallVec<[_; 2]>>();\n@@ -321,29 +282,14 @@ pub(super) fn cvalue_for_param<'tcx>(\n         }\n         PassMode::Pair(_, _) => {\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n-            Some(CValue::by_val_pair(\n-                block_params[0],\n-                block_params[1],\n-                arg_abi.layout,\n-            ))\n+            Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n         PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n-            Some(CValue::by_ref(\n-                Pointer::new(block_params[0]),\n-                arg_abi.layout,\n-            ))\n+            Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_ref_unsized(\n                 Pointer::new(block_params[0]),"}, {"sha": "9fa066df69b3cd936b346b28a6bc1213ad633cb9", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 27, "deletions": 63, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -8,14 +8,13 @@ use smallvec::{smallvec, SmallVec};\n \n /// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     func: &mir::Operand<'tcx>,\n     args: &[mir::Operand<'tcx>],\n ) -> bool {\n     let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig = fx\n-        .tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let fn_sig =\n+        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n \n     // Handle special calls like instrinsics and empty drop glue.\n     let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n@@ -42,11 +41,7 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n     let fn_abi = if let Some(instance) = instance {\n         FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(\n-            &RevealAllLayoutCx(fx.tcx),\n-            fn_ty.fn_sig(fx.tcx),\n-            &extra_args,\n-        )\n+        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n     };\n     match fn_abi.ret.mode {\n         PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n@@ -58,15 +53,12 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n /// Return a place where the return value of the current function can be written to. If necessary\n /// this adds an extra parameter pointing to where the return value needs to be stored.\n pub(super) fn codegen_return_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore => (\n-            CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n-            smallvec![],\n-        ),\n+        PassMode::Ignore => (CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout), smallvec![]),\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n@@ -79,26 +71,17 @@ pub(super) fn codegen_return_param<'tcx>(\n                 smallvec![],\n             )\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             let ret_param = block_params_iter.next().unwrap();\n             assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n             (\n-                CPlace::for_ptr(\n-                    Pointer::new(ret_param),\n-                    fx.fn_abi.as_ref().unwrap().ret.layout,\n-                ),\n+                CPlace::for_ptr(Pointer::new(ret_param), fx.fn_abi.as_ref().unwrap().ret.layout),\n                 smallvec![ret_param],\n             )\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n     };\n \n     #[cfg(not(debug_assertions))]\n@@ -120,27 +103,21 @@ pub(super) fn codegen_return_param<'tcx>(\n \n /// Invokes the closure with if necessary a value representing the return pointer. When the closure\n /// returns the call return value(s) if any are written to the correct place.\n-pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n-    f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n+    f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> (Inst, T),\n ) -> (Inst, T) {\n     let return_ptr = match ret_arg_abi.mode {\n         PassMode::Ignore => None,\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => match ret_place {\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n         PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n@@ -177,37 +154,24 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n                 ret_place.write_cvalue(fx, result);\n             }\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {}\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {}\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n     }\n \n     (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any.\n-pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n     match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore\n-        | PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: None,\n-            on_stack: _,\n-        } => {\n+        PassMode::Ignore | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        PassMode::Indirect {\n-            attrs: _,\n-            extra_attrs: Some(_),\n-            on_stack: _,\n-        } => unreachable!(\"unsized return value\"),\n+        PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n+            unreachable!(\"unsized return value\")\n+        }\n         PassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);"}, {"sha": "efb64233ef2c3109104b0dce231dec1d7aca699f", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -66,13 +66,9 @@ fn codegen_inner(\n         let callee_name = kind.fn_name(method.name);\n         //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n-        let func_id = module\n-            .declare_function(&caller_name, Linkage::Export, &sig)\n-            .unwrap();\n+        let func_id = module.declare_function(&caller_name, Linkage::Export, &sig).unwrap();\n \n-        let callee_func_id = module\n-            .declare_function(&callee_name, Linkage::Import, &sig)\n-            .unwrap();\n+        let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig.clone());\n@@ -96,11 +92,7 @@ fn codegen_inner(\n             bcx.finalize();\n         }\n         module\n-            .define_function(\n-                func_id,\n-                &mut ctx,\n-                &mut cranelift_codegen::binemit::NullTrapSink {},\n-            )\n+            .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n             .unwrap();\n         unwind_context.add_function(func_id, &ctx, module.isa());\n     }\n@@ -114,13 +106,10 @@ fn codegen_inner(\n     let callee_name = kind.fn_name(sym::oom);\n     //eprintln!(\"Codegen allocator shim {} -> {} ({:?} -> {:?})\", caller_name, callee_name, sig.params, sig.returns);\n \n-    let func_id = module\n-        .declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig)\n-        .unwrap();\n+    let func_id =\n+        module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n \n-    let callee_func_id = module\n-        .declare_function(&callee_name, Linkage::Import, &sig)\n-        .unwrap();\n+    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n     ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n@@ -143,11 +132,7 @@ fn codegen_inner(\n         bcx.finalize();\n     }\n     module\n-        .define_function(\n-            func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n+        .define_function(func_id, &mut ctx, &mut cranelift_codegen::binemit::NullTrapSink {})\n         .unwrap();\n     unwind_context.add_function(func_id, &ctx, module.isa());\n }"}, {"sha": "efead25552f4d1ca203e35b49a2c4912ab253c4b", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -11,7 +11,7 @@ pub(crate) enum SsaKind {\n     Ssa,\n }\n \n-pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, SsaKind> {\n+pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n     let mut flag_map = fx\n         .mir\n         .local_decls\n@@ -40,12 +40,7 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, S\n         }\n \n         match &bb.terminator().kind {\n-            TerminatorKind::Call {\n-                destination,\n-                func,\n-                args,\n-                ..\n-            } => {\n+            TerminatorKind::Call { destination, func, args, .. } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n                     if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n                         not_ssa(&mut flag_map, dest_place.local)"}, {"sha": "7583fc424071e251cb158c390265c294bbe30836", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -12,10 +12,7 @@ use object::{Object, ObjectSymbol, SymbolKind};\n \n #[derive(Debug)]\n enum ArchiveEntry {\n-    FromArchive {\n-        archive_index: usize,\n-        entry_index: usize,\n-    },\n+    FromArchive { archive_index: usize, entry_index: usize },\n     File(PathBuf),\n }\n \n@@ -30,7 +27,6 @@ pub(crate) struct ArArchiveBuilder<'a> {\n     // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n     // the end of an archive for linkers to not get confused.\n     entries: Vec<(String, ArchiveEntry)>,\n-    update_symbols: bool,\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n@@ -46,10 +42,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 let entry = entry.unwrap();\n                 entries.push((\n                     String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    ArchiveEntry::FromArchive {\n-                        archive_index: 0,\n-                        entry_index: i,\n-                    },\n+                    ArchiveEntry::FromArchive { archive_index: 0, entry_index: i },\n                 ));\n                 i += 1;\n             }\n@@ -69,7 +62,6 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n             src_archives,\n             entries,\n-            update_symbols: false,\n         }\n     }\n \n@@ -95,14 +87,9 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n     fn add_native_library(&mut self, name: rustc_span::symbol::Symbol) {\n         let location = find_library(name, &self.lib_search_paths, self.sess);\n-        self.add_archive(location.clone(), |_| false)\n-            .unwrap_or_else(|e| {\n-                panic!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                );\n-            });\n+        self.add_archive(location.clone(), |_| false).unwrap_or_else(|e| {\n+            panic!(\"failed to add native library {}: {}\", location.to_string_lossy(), e);\n+        });\n     }\n \n     fn add_rlib(\n@@ -136,9 +123,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         })\n     }\n \n-    fn update_symbols(&mut self) {\n-        self.update_symbols = true;\n-    }\n+    fn update_symbols(&mut self) {}\n \n     fn build(mut self) {\n         enum BuilderKind {\n@@ -156,10 +141,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             // FIXME only read the symbol table of the object files to avoid having to keep all\n             // object files in memory at once, or read them twice.\n             let data = match entry {\n-                ArchiveEntry::FromArchive {\n-                    archive_index,\n-                    entry_index,\n-                } => {\n+                ArchiveEntry::FromArchive { archive_index, entry_index } => {\n                     // FIXME read symbols from symtab\n                     use std::io::Read;\n                     let (ref _src_archive_path, ref mut src_archive) =\n@@ -225,10 +207,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                             err\n                         ));\n                     }),\n-                    entries\n-                        .iter()\n-                        .map(|(name, _)| name.as_bytes().to_vec())\n-                        .collect(),\n+                    entries.iter().map(|(name, _)| name.as_bytes().to_vec()).collect(),\n                     ar::GnuSymbolTableFormat::Size32,\n                     symbol_table,\n                 )\n@@ -271,8 +250,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 .expect(\"Couldn't run ranlib\");\n \n             if !status.success() {\n-                self.sess\n-                    .fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+                self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n             }\n         }\n     }\n@@ -292,13 +270,8 @@ impl<'a> ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.header().identifier().to_vec())\n                 .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                self.entries.push((\n-                    file_name,\n-                    ArchiveEntry::FromArchive {\n-                        archive_index,\n-                        entry_index: i,\n-                    },\n-                ));\n+                self.entries\n+                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n             }\n             i += 1;\n         }"}, {"sha": "674e6d907510a8510607cea2c747a66d17238c74", "filename": "compiler/rustc_codegen_cranelift/src/atomic_shim.rs", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fatomic_shim.rs?ref=2285f11724e2fa3251c94c9ab7672544099600e2", "patch": "@@ -1,185 +0,0 @@\n-//! Atomic intrinsics are implemented using a global lock for now, as Cranelift doesn't support\n-//! atomic operations yet.\n-\n-// FIXME implement atomic instructions in Cranelift.\n-\n-use crate::prelude::*;\n-\n-#[cfg(all(feature = \"jit\", unix))]\n-#[no_mangle]\n-static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n-\n-pub(crate) fn init_global_lock(\n-    module: &mut impl Module,\n-    bcx: &mut FunctionBuilder<'_>,\n-    use_jit: bool,\n-) {\n-    if use_jit {\n-        // When using JIT, dylibs won't find the __cg_clif_global_atomic_mutex data object defined here,\n-        // so instead we define it in the cg_clif dylib.\n-\n-        return;\n-    }\n-\n-    let mut data_ctx = DataContext::new();\n-    data_ctx.define_zeroinit(1024); // 1024 bytes should be big enough on all platforms.\n-    data_ctx.set_align(16);\n-    let atomic_mutex = module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Export,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-    module.define_data(atomic_mutex, &data_ctx).unwrap();\n-\n-    let pthread_mutex_init = module\n-        .declare_function(\n-            \"pthread_mutex_init\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: module.target_config().default_call_conv,\n-                params: vec![\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                    ),\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *const pthread_mutex_attr_t */\n-                    ),\n-                ],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_init = module.declare_func_in_func(pthread_mutex_init, bcx.func);\n-\n-    let atomic_mutex = module.declare_data_in_func(atomic_mutex, bcx.func);\n-    let atomic_mutex = bcx\n-        .ins()\n-        .global_value(module.target_config().pointer_type(), atomic_mutex);\n-\n-    let nullptr = bcx.ins().iconst(module.target_config().pointer_type(), 0);\n-\n-    bcx.ins().call(pthread_mutex_init, &[atomic_mutex, nullptr]);\n-}\n-\n-pub(crate) fn init_global_lock_constructor(\n-    module: &mut impl Module,\n-    constructor_name: &str,\n-) -> FuncId {\n-    let sig = Signature::new(CallConv::SystemV);\n-    let init_func_id = module\n-        .declare_function(constructor_name, Linkage::Export, &sig)\n-        .unwrap();\n-\n-    let mut ctx = Context::new();\n-    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n-    {\n-        let mut func_ctx = FunctionBuilderContext::new();\n-        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-        let block = bcx.create_block();\n-        bcx.switch_to_block(block);\n-\n-        crate::atomic_shim::init_global_lock(module, &mut bcx, false);\n-\n-        bcx.ins().return_(&[]);\n-        bcx.seal_all_blocks();\n-        bcx.finalize();\n-    }\n-    module\n-        .define_function(\n-            init_func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n-        .unwrap();\n-\n-    init_func_id\n-}\n-\n-pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_lock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n-}\n-\n-pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_unlock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n-}"}, {"sha": "eb7927fc4adebdbd16cf8742b6b8709d3076361e", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -8,7 +8,7 @@ use rustc_session::Session;\n use cranelift_module::FuncId;\n \n use object::write::*;\n-use object::{RelocationEncoding, RelocationKind, SectionKind, SymbolFlags};\n+use object::{RelocationEncoding, SectionKind, SymbolFlags};\n \n use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n \n@@ -22,9 +22,7 @@ pub(crate) trait WriteMetadata {\n \n impl WriteMetadata for object::write::Object {\n     fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, _is_like_osx: bool) {\n-        let segment = self\n-            .segment_name(object::write::StandardSegment::Data)\n-            .to_vec();\n+        let segment = self.segment_name(object::write::StandardSegment::Data).to_vec();\n         let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n         let offset = self.append_section_data(section_id, &data, 1);\n         // For MachO and probably PE this is necessary to prevent the linker from throwing away the\n@@ -74,11 +72,7 @@ impl WriteDebugInfo for ObjectProduct {\n         let section_id = self.object.add_section(\n             segment,\n             name,\n-            if id == SectionId::EhFrame {\n-                SectionKind::ReadOnlyData\n-            } else {\n-                SectionKind::Debug\n-            },\n+            if id == SectionId::EhFrame { SectionKind::ReadOnlyData } else { SectionKind::Debug },\n         );\n         self.object\n             .section_mut(section_id)\n@@ -118,49 +112,6 @@ impl WriteDebugInfo for ObjectProduct {\n     }\n }\n \n-// FIXME remove once atomic instructions are implemented in Cranelift.\n-pub(crate) trait AddConstructor {\n-    fn add_constructor(&mut self, func_id: FuncId);\n-}\n-\n-impl AddConstructor for ObjectProduct {\n-    fn add_constructor(&mut self, func_id: FuncId) {\n-        let symbol = self.function_symbol(func_id);\n-        let segment = self\n-            .object\n-            .segment_name(object::write::StandardSegment::Data);\n-        let init_array_section =\n-            self.object\n-                .add_section(segment.to_vec(), b\".init_array\".to_vec(), SectionKind::Data);\n-        let address_size = self\n-            .object\n-            .architecture()\n-            .address_size()\n-            .expect(\"address_size must be known\")\n-            .bytes();\n-        self.object.append_section_data(\n-            init_array_section,\n-            &std::iter::repeat(0)\n-                .take(address_size.into())\n-                .collect::<Vec<u8>>(),\n-            8,\n-        );\n-        self.object\n-            .add_relocation(\n-                init_array_section,\n-                object::write::Relocation {\n-                    offset: 0,\n-                    size: address_size * 8,\n-                    kind: RelocationKind::Absolute,\n-                    encoding: RelocationEncoding::Generic,\n-                    symbol,\n-                    addend: 0,\n-                },\n-            )\n-            .unwrap();\n-    }\n-}\n-\n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n     let triple = crate::build_isa(sess).triple().clone();\n \n@@ -175,10 +126,9 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n         target_lexicon::Architecture::X86_64 => object::Architecture::X86_64,\n         target_lexicon::Architecture::Arm(_) => object::Architecture::Arm,\n         target_lexicon::Architecture::Aarch64(_) => object::Architecture::Aarch64,\n-        architecture => sess.fatal(&format!(\n-            \"target architecture {:?} is unsupported\",\n-            architecture,\n-        )),\n+        architecture => {\n+            sess.fatal(&format!(\"target architecture {:?} is unsupported\", architecture,))\n+        }\n     };\n     let endian = match triple.endianness().unwrap() {\n         target_lexicon::Endianness::Little => object::Endianness::Little,"}, {"sha": "8b5ae9e0541ade6210bfd3436f2c9b9228085328", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 105, "deletions": 191, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -8,7 +8,7 @@ use rustc_target::abi::call::FnAbi;\n use crate::prelude::*;\n \n pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    cx: &mut crate::CodegenCx<'_, 'tcx>,\n     instance: Instance<'tcx>,\n     linkage: Linkage,\n ) {\n@@ -38,9 +38,8 @@ pub(crate) fn codegen_fn<'tcx>(\n \n     // Predefine blocks\n     let start_block = bcx.create_block();\n-    let block_map: IndexVec<BasicBlock, Block> = (0..mir.basic_blocks().len())\n-        .map(|_| bcx.create_block())\n-        .collect();\n+    let block_map: IndexVec<BasicBlock, Block> =\n+        (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n     let pointer_type = cx.module.target_config().pointer_type();\n@@ -68,22 +67,23 @@ pub(crate) fn codegen_fn<'tcx>(\n         inline_asm_index: 0,\n     };\n \n-    let arg_uninhabited = fx.mir.args_iter().any(|arg| {\n-        fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty))\n-            .abi\n-            .is_uninhabited()\n-    });\n+    let arg_uninhabited = fx\n+        .mir\n+        .args_iter()\n+        .any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n \n-    if arg_uninhabited {\n-        fx.bcx\n-            .append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+    if !crate::constant::check_constants(&mut fx) {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n+        fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n+        crate::trap::trap_unreachable(&mut fx, \"compilation should have been aborted\");\n+    } else if arg_uninhabited {\n+        fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n         fx.bcx.switch_to_block(fx.block_map[START_BLOCK]);\n         crate::trap::trap_unreachable(&mut fx, \"function has uninhabited argument\");\n     } else {\n         tcx.sess.time(\"codegen clif ir\", || {\n-            tcx.sess.time(\"codegen prelude\", || {\n-                crate::abi::codegen_fn_prelude(&mut fx, start_block)\n-            });\n+            tcx.sess\n+                .time(\"codegen prelude\", || crate::abi::codegen_fn_prelude(&mut fx, start_block));\n             codegen_fn_content(&mut fx);\n         });\n     }\n@@ -131,11 +131,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n-            .define_function(\n-                func_id,\n-                context,\n-                &mut cranelift_codegen::binemit::NullTrapSink {},\n-            )\n+            .define_function(func_id, context, &mut cranelift_codegen::binemit::NullTrapSink {})\n             .unwrap()\n     });\n \n@@ -149,14 +145,12 @@ pub(crate) fn codegen_fn<'tcx>(\n         &clif_comments,\n     );\n \n-    if let Some(mach_compile_result) = &context.mach_compile_result {\n-        if let Some(disasm) = &mach_compile_result.disasm {\n-            crate::pretty_clif::write_ir_file(\n-                tcx,\n-                &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n-                |file| file.write_all(disasm.as_bytes()),\n-            )\n-        }\n+    if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n+        crate::pretty_clif::write_ir_file(\n+            tcx,\n+            &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+            |file| file.write_all(disasm.as_bytes()),\n+        )\n     }\n \n     // Define debuginfo for function\n@@ -199,16 +193,13 @@ pub(crate) fn verify_func(\n                     Some(Box::new(writer)),\n                     err,\n                 );\n-                tcx.sess\n-                    .fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n+                tcx.sess.fatal(&format!(\"cranelift verify error:\\n{}\", pretty_error));\n             }\n         }\n     });\n }\n \n-fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    crate::constant::check_constants(fx);\n-\n+fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n     for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n@@ -231,11 +222,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n         #[cfg(debug_assertions)]\n         {\n             let mut terminator_head = \"\\n\".to_string();\n-            bb_data\n-                .terminator()\n-                .kind\n-                .fmt_head(&mut terminator_head)\n-                .unwrap();\n+            bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n             let inst = fx.bcx.func.layout.last_inst(block).unwrap();\n             fx.add_comment(inst, terminator_head);\n         }\n@@ -267,13 +254,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             TerminatorKind::Return => {\n                 crate::abi::codegen_return(fx);\n             }\n-            TerminatorKind::Assert {\n-                cond,\n-                expected,\n-                msg,\n-                target,\n-                cleanup: _,\n-            } => {\n+            TerminatorKind::Assert { cond, expected, msg, target, cleanup: _ } => {\n                 if !fx.tcx.sess.overflow_checks() {\n                     if let mir::AssertKind::OverflowNeg(_) = *msg {\n                         let target = fx.get_block(*target);\n@@ -319,11 +300,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                 }\n             }\n \n-            TerminatorKind::SwitchInt {\n-                discr,\n-                switch_ty,\n-                targets,\n-            } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty, targets } => {\n                 let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n                 let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n@@ -433,11 +410,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             | TerminatorKind::GeneratorDrop => {\n                 bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n-            TerminatorKind::Drop {\n-                place,\n-                target,\n-                unwind: _,\n-            } => {\n+            TerminatorKind::Drop { place, target, unwind: _ } => {\n                 let drop_place = codegen_place(fx, *place);\n                 crate::abi::codegen_drop(fx, bb_data.terminator().source_info.span, drop_place);\n \n@@ -452,7 +425,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n }\n \n fn codegen_stmt<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     #[allow(unused_variables)] cur_block: Block,\n     stmt: &Statement<'tcx>,\n ) {\n@@ -470,10 +443,7 @@ fn codegen_stmt<'tcx>(\n     }\n \n     match &stmt.kind {\n-        StatementKind::SetDiscriminant {\n-            place,\n-            variant_index,\n-        } => {\n+        StatementKind::SetDiscriminant { place, variant_index } => {\n             let place = codegen_place(fx, **place);\n             crate::discriminant::codegen_set_discriminant(fx, place, *variant_index);\n         }\n@@ -494,14 +464,14 @@ fn codegen_stmt<'tcx>(\n                     let val = crate::constant::codegen_tls_ref(fx, def_id, lval.layout());\n                     lval.write_cvalue(fx, val);\n                 }\n-                Rvalue::BinaryOp(bin_op, ref lhs, ref rhs) => {\n+                Rvalue::BinaryOp(bin_op, box (ref lhs, ref rhs)) => {\n                     let lhs = codegen_operand(fx, lhs);\n                     let rhs = codegen_operand(fx, rhs);\n \n                     let res = crate::num::codegen_binop(fx, bin_op, lhs, rhs);\n                     lval.write_cvalue(fx, res);\n                 }\n-                Rvalue::CheckedBinaryOp(bin_op, ref lhs, ref rhs) => {\n+                Rvalue::CheckedBinaryOp(bin_op, box (ref lhs, ref rhs)) => {\n                     let lhs = codegen_operand(fx, lhs);\n                     let rhs = codegen_operand(fx, rhs);\n \n@@ -594,19 +564,11 @@ fn codegen_stmt<'tcx>(\n                     let from_ty = operand.layout().ty;\n                     let to_ty = fx.monomorphize(to_ty);\n \n-                    fn is_fat_ptr<'tcx>(\n-                        fx: &FunctionCx<'_, 'tcx, impl Module>,\n-                        ty: Ty<'tcx>,\n-                    ) -> bool {\n+                    fn is_fat_ptr<'tcx>(fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n                         ty.builtin_deref(true)\n-                            .map(\n-                                |ty::TypeAndMut {\n-                                     ty: pointee_ty,\n-                                     mutbl: _,\n-                                 }| {\n-                                    has_ptr_meta(fx.tcx, pointee_ty)\n-                                },\n-                            )\n+                            .map(|ty::TypeAndMut { ty: pointee_ty, mutbl: _ }| {\n+                                has_ptr_meta(fx.tcx, pointee_ty)\n+                            })\n                             .unwrap_or(false)\n                     }\n \n@@ -626,50 +588,22 @@ fn codegen_stmt<'tcx>(\n                             ty::Uint(_) | ty::Int(_) => {}\n                             _ => unreachable!(\"cast adt {} -> {}\", from_ty, to_ty),\n                         }\n+                        let to_clif_ty = fx.clif_type(to_ty).unwrap();\n \n-                        use rustc_target::abi::{Int, TagEncoding, Variants};\n-\n-                        match operand.layout().variants {\n-                            Variants::Single { index } => {\n-                                let discr = operand\n-                                    .layout()\n-                                    .ty\n-                                    .discriminant_for_variant(fx.tcx, index)\n-                                    .unwrap();\n-                                let discr = if discr.ty.is_signed() {\n-                                    fx.layout_of(discr.ty).size.sign_extend(discr.val)\n-                                } else {\n-                                    discr.val\n-                                };\n-                                let discr = discr.into();\n-\n-                                let discr = CValue::const_val(fx, fx.layout_of(to_ty), discr);\n-                                lval.write_cvalue(fx, discr);\n-                            }\n-                            Variants::Multiple {\n-                                ref tag,\n-                                tag_field,\n-                                tag_encoding: TagEncoding::Direct,\n-                                variants: _,\n-                            } => {\n-                                let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n-\n-                                // Read the tag/niche-encoded discriminant from memory.\n-                                let encoded_discr =\n-                                    operand.value_field(fx, mir::Field::new(tag_field));\n-                                let encoded_discr = encoded_discr.load_scalar(fx);\n-\n-                                // Decode the discriminant (specifically if it's niche-encoded).\n-                                let signed = match tag.value {\n-                                    Int(_, signed) => signed,\n-                                    _ => false,\n-                                };\n-                                let val = clif_intcast(fx, encoded_discr, cast_to, signed);\n-                                let val = CValue::by_val(val, dest_layout);\n-                                lval.write_cvalue(fx, val);\n-                            }\n-                            Variants::Multiple { .. } => unreachable!(),\n-                        }\n+                        let discriminant = crate::discriminant::codegen_get_discriminant(\n+                            fx,\n+                            operand,\n+                            fx.layout_of(operand.layout().ty.discriminant_ty(fx.tcx)),\n+                        )\n+                        .load_scalar(fx);\n+\n+                        let res = crate::cast::clif_intcast(\n+                            fx,\n+                            discriminant,\n+                            to_clif_ty,\n+                            to_ty.is_signed(),\n+                        );\n+                        lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n                     } else {\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n                         let from = operand.load_scalar(fx);\n@@ -730,8 +664,7 @@ fn codegen_stmt<'tcx>(\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx\n-                            .call_memset(fx.cx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.cx.module.target_config(), addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -766,36 +699,31 @@ fn codegen_stmt<'tcx>(\n                     let content_ty = fx.monomorphize(content_ty);\n                     let layout = fx.layout_of(content_ty);\n                     let llsize = fx.bcx.ins().iconst(usize_type, layout.size.bytes() as i64);\n-                    let llalign = fx\n-                        .bcx\n-                        .ins()\n-                        .iconst(usize_type, layout.align.abi.bytes() as i64);\n+                    let llalign = fx.bcx.ins().iconst(usize_type, layout.align.abi.bytes() as i64);\n                     let box_layout = fx.layout_of(fx.tcx.mk_box(content_ty));\n \n                     // Allocate space:\n-                    let def_id = match fx\n-                        .tcx\n-                        .lang_items()\n-                        .require(rustc_hir::LangItem::ExchangeMalloc)\n-                    {\n-                        Ok(id) => id,\n-                        Err(s) => {\n-                            fx.tcx\n-                                .sess\n-                                .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n-                        }\n-                    };\n+                    let def_id =\n+                        match fx.tcx.lang_items().require(rustc_hir::LangItem::ExchangeMalloc) {\n+                            Ok(id) => id,\n+                            Err(s) => {\n+                                fx.tcx\n+                                    .sess\n+                                    .fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n+                            }\n+                        };\n                     let instance = ty::Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n                     let func_ref = fx.get_function_ref(instance);\n                     let call = fx.bcx.ins().call(func_ref, &[llsize, llalign]);\n                     let ptr = fx.bcx.inst_results(call)[0];\n                     lval.write_cvalue(fx, CValue::by_val(ptr, box_layout));\n                 }\n                 Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                    assert!(lval\n-                        .layout()\n-                        .ty\n-                        .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all()));\n+                    assert!(\n+                        lval.layout()\n+                            .ty\n+                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n+                    );\n                     let ty_size = fx.layout_of(fx.monomorphize(ty)).size.bytes();\n                     let val =\n                         CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), ty_size.into());\n@@ -823,11 +751,7 @@ fn codegen_stmt<'tcx>(\n \n         StatementKind::LlvmInlineAsm(asm) => {\n             use rustc_span::symbol::Symbol;\n-            let LlvmInlineAsm {\n-                asm,\n-                outputs,\n-                inputs,\n-            } = &**asm;\n+            let LlvmInlineAsm { asm, outputs, inputs } = &**asm;\n             let rustc_hir::LlvmInlineAsmInner {\n                 asm: asm_code,         // Name\n                 outputs: output_names, // Vec<LlvmInlineAsmOutput>\n@@ -843,15 +767,9 @@ fn codegen_stmt<'tcx>(\n                     // Black box\n                 }\n                 \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n-                    assert_eq!(\n-                        input_names,\n-                        &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]\n-                    );\n+                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n                     assert_eq!(output_names.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"])\n-                        .iter()\n-                        .enumerate()\n-                    {\n+                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n                         assert_eq!(&output_names[i].constraint.as_str(), c);\n                         assert!(!output_names[i].is_rw);\n                         assert!(!output_names[i].is_indirect);\n@@ -897,12 +815,7 @@ fn codegen_stmt<'tcx>(\n                     crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n                 }\n                 // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fx\n-                    .tcx\n-                    .symbol_name(fx.instance)\n-                    .name\n-                    .starts_with(\"___chkstk\") =>\n-                {\n+                _ if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n                     crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n                 }\n                 _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n@@ -919,30 +832,45 @@ fn codegen_stmt<'tcx>(\n             }\n         }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n+        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n+          src,\n+          dst,\n+          count,\n+        }) => {\n+            let dst = codegen_operand(fx, dst);\n+            let pointee = dst\n+              .layout()\n+              .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n+              .expect(\"Expected pointer\");\n+            let dst = dst.load_scalar(fx);\n+            let src = codegen_operand(fx, src).load_scalar(fx);\n+            let count = codegen_operand(fx, count).load_scalar(fx);\n+            let elem_size: u64 = pointee.size.bytes();\n+            let bytes = if elem_size != 1 {\n+               fx.bcx.ins().imul_imm(count, elem_size as i64)\n+            } else {\n+               count\n+            };\n+            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n+        }\n     }\n }\n \n-fn codegen_array_len<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    place: CPlace<'tcx>,\n-) -> Value {\n+fn codegen_array_len<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, place: CPlace<'tcx>) -> Value {\n     match *place.layout().ty.kind() {\n         ty::Array(_elem_ty, len) => {\n-            let len = fx\n-                .monomorphize(len)\n-                .eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n+            let len = fx.monomorphize(len).eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n-        ty::Slice(_elem_ty) => place\n-            .to_ptr_maybe_unsized()\n-            .1\n-            .expect(\"Length metadata for slice place\"),\n+        ty::Slice(_elem_ty) => {\n+            place.to_ptr_maybe_unsized().1.expect(\"Length metadata for slice place\")\n+        }\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n     }\n }\n \n pub(crate) fn codegen_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: Place<'tcx>,\n ) -> CPlace<'tcx> {\n     let mut cplace = fx.get_local_place(place.local);\n@@ -959,11 +887,7 @@ pub(crate) fn codegen_place<'tcx>(\n                 let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n                 cplace = cplace.place_index(fx, index);\n             }\n-            PlaceElem::ConstantIndex {\n-                offset,\n-                min_length: _,\n-                from_end,\n-            } => {\n+            PlaceElem::ConstantIndex { offset, min_length: _, from_end } => {\n                 let offset: u64 = offset;\n                 let index = if !from_end {\n                     fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n@@ -1014,7 +938,7 @@ pub(crate) fn codegen_place<'tcx>(\n }\n \n pub(crate) fn codegen_operand<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> CValue<'tcx> {\n     match operand {\n@@ -1026,34 +950,24 @@ pub(crate) fn codegen_operand<'tcx>(\n     }\n }\n \n-pub(crate) fn codegen_panic<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    msg_str: &str,\n-    span: Span,\n-) {\n+pub(crate) fn codegen_panic<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, msg_str: &str, span: Span) {\n     let location = fx.get_caller_location(span).load_scalar(fx);\n \n     let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n-    let msg_len = fx\n-        .bcx\n-        .ins()\n-        .iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+    let msg_len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n     let args = [msg_ptr, msg_len, location];\n \n     codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, span);\n }\n \n pub(crate) fn codegen_panic_inner<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     lang_item: rustc_hir::LangItem,\n     args: &[Value],\n     span: Span,\n ) {\n-    let def_id = fx\n-        .tcx\n-        .lang_items()\n-        .require(lang_item)\n-        .unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n+    let def_id =\n+        fx.tcx.lang_items().require(lang_item).unwrap_or_else(|s| fx.tcx.sess.span_fatal(span, &s));\n \n     let instance = Instance::mono(fx.tcx, def_id).polymorphize(fx.tcx);\n     let symbol_name = fx.tcx.symbol_name(instance).name;"}, {"sha": "983839d48d2d756ab0bbf5760668eac6854d4329", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -27,13 +27,7 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n         config.opts.cg.panic = Some(PanicStrategy::Abort);\n         config.opts.debugging_opts.panic_abort_tests = true;\n         config.opts.maybe_sysroot = Some(config.opts.maybe_sysroot.clone().unwrap_or_else(|| {\n-            std::env::current_exe()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .to_owned()\n+            std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_owned()\n         }));\n     }\n }"}, {"sha": "e7cd5edbbf654a2888e6b0ba4965da554f37f4a1", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -46,15 +46,8 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n \n         config.opts.cg.panic = Some(PanicStrategy::Abort);\n         config.opts.debugging_opts.panic_abort_tests = true;\n-        config.opts.maybe_sysroot = Some(\n-            std::env::current_exe()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .parent()\n-                .unwrap()\n-                .to_owned(),\n-        );\n+        config.opts.maybe_sysroot =\n+            Some(std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().to_owned());\n     }\n }\n "}, {"sha": "74c5e09f08da008decbad6a70710b106adb4b0bf", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -3,7 +3,7 @@\n use crate::prelude::*;\n \n pub(crate) fn clif_intcast(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     val: Value,\n     to: Type,\n     signed: bool,\n@@ -40,18 +40,14 @@ pub(crate) fn clif_intcast(\n         // reduce\n         (types::I128, _) => {\n             let (lsb, _msb) = fx.bcx.ins().isplit(val);\n-            if to == types::I64 {\n-                lsb\n-            } else {\n-                fx.bcx.ins().ireduce(to, lsb)\n-            }\n+            if to == types::I64 { lsb } else { fx.bcx.ins().ireduce(to, lsb) }\n         }\n         (_, _) => fx.bcx.ins().ireduce(to, val),\n     }\n }\n \n pub(crate) fn clif_int_or_float_cast(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     from: Value,\n     from_signed: bool,\n     to_ty: Type,\n@@ -87,11 +83,7 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n \n             let to_rust_ty = match to_ty {\n                 types::F32 => fx.tcx.types.f32,\n@@ -100,11 +92,7 @@ pub(crate) fn clif_int_or_float_cast(\n             };\n \n             return fx\n-                .easy_call(\n-                    &name,\n-                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                    to_rust_ty,\n-                )\n+                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n                 .load_scalar(fx);\n         }\n \n@@ -138,18 +126,10 @@ pub(crate) fn clif_int_or_float_cast(\n                 _ => unreachable!(),\n             };\n \n-            let to_rust_ty = if to_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n \n             return fx\n-                .easy_call(\n-                    &name,\n-                    &[CValue::by_val(from, fx.layout_of(from_rust_ty))],\n-                    to_rust_ty,\n-                )\n+                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n                 .load_scalar(fx);\n         }\n "}, {"sha": "ae75e6508cb0bac04150342c238c9453221e85a4", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 17, "deletions": 68, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -5,13 +5,17 @@ use cranelift_codegen::ir::ArgumentPurpose;\n use crate::prelude::*;\n \n pub(crate) fn maybe_codegen<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     checked: bool,\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n ) -> Option<CValue<'tcx>> {\n-    if lhs.layout().ty != fx.tcx.types.u128 && lhs.layout().ty != fx.tcx.types.i128 {\n+    if lhs.layout().ty != fx.tcx.types.u128\n+        && lhs.layout().ty != fx.tcx.types.i128\n+        && rhs.layout().ty != fx.tcx.types.u128\n+        && rhs.layout().ty != fx.tcx.types.i128\n+    {\n         return None;\n     }\n \n@@ -27,11 +31,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked => {\n-            let val_ty = if is_signed {\n-                fx.tcx.types.i128\n-            } else {\n-                fx.tcx.types.u128\n-            };\n+            let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n             Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n@@ -43,11 +43,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 AbiParam::new(types::I128),\n                 AbiParam::new(types::I128),\n             ];\n-            let args = [\n-                out_place.to_ptr().get_addr(fx),\n-                lhs.load_scalar(fx),\n-                rhs.load_scalar(fx),\n-            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -97,70 +93,23 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 None\n             };\n \n-            // Optimize `val >> 64`, because compiler_builtins uses it to deconstruct an 128bit\n-            // integer into its lsb and msb.\n-            // https://github.com/rust-lang-nursery/compiler-builtins/blob/79a6a1603d5672cbb9187ff41ff4d9b5048ac1cb/src/int/mod.rs#L217\n-            if resolve_value_imm(fx.bcx.func, rhs_val) == Some(64) {\n-                let (lhs_lsb, lhs_msb) = fx.bcx.ins().isplit(lhs_val);\n-                let all_zeros = fx.bcx.ins().iconst(types::I64, 0);\n-                let val = match (bin_op, is_signed) {\n-                    (BinOp::Shr, false) => {\n-                        let val = fx.bcx.ins().iconcat(lhs_msb, all_zeros);\n-                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.u128)))\n-                    }\n-                    (BinOp::Shr, true) => {\n-                        let sign = fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, lhs_msb, 0);\n-                        let all_ones = fx.bcx.ins().iconst(types::I64, u64::MAX as i64);\n-                        let all_sign_bits = fx.bcx.ins().select(sign, all_zeros, all_ones);\n-\n-                        let val = fx.bcx.ins().iconcat(lhs_msb, all_sign_bits);\n-                        Some(CValue::by_val(val, fx.layout_of(fx.tcx.types.i128)))\n-                    }\n-                    (BinOp::Shl, _) => {\n-                        let val_ty = if is_signed {\n-                            fx.tcx.types.i128\n-                        } else {\n-                            fx.tcx.types.u128\n-                        };\n-                        let val = fx.bcx.ins().iconcat(all_zeros, lhs_lsb);\n-                        Some(CValue::by_val(val, fx.layout_of(val_ty)))\n-                    }\n-                    _ => None,\n-                };\n-                if let Some(val) = val {\n-                    if let Some(is_overflow) = is_overflow {\n-                        let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                        let val = val.load_scalar(fx);\n-                        return Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)));\n+            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n+            let val = match bin_op {\n+                BinOp::Shl => fx.bcx.ins().ishl(lhs_val, truncated_rhs),\n+                BinOp::Shr => {\n+                    if is_signed {\n+                        fx.bcx.ins().sshr(lhs_val, truncated_rhs)\n                     } else {\n-                        return Some(val);\n+                        fx.bcx.ins().ushr(lhs_val, truncated_rhs)\n                     }\n                 }\n-            }\n-\n-            let truncated_rhs = clif_intcast(fx, rhs_val, types::I32, false);\n-            let truncated_rhs = CValue::by_val(truncated_rhs, fx.layout_of(fx.tcx.types.u32));\n-            let val = match (bin_op, is_signed) {\n-                (BinOp::Shl, false) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n-                }\n-                (BinOp::Shl, true) => {\n-                    fx.easy_call(\"__ashlti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n-                }\n-                (BinOp::Shr, false) => {\n-                    fx.easy_call(\"__lshrti3\", &[lhs, truncated_rhs], fx.tcx.types.u128)\n-                }\n-                (BinOp::Shr, true) => {\n-                    fx.easy_call(\"__ashrti3\", &[lhs, truncated_rhs], fx.tcx.types.i128)\n-                }\n-                (_, _) => unreachable!(),\n+                _ => unreachable!(),\n             };\n             if let Some(is_overflow) = is_overflow {\n                 let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                let val = val.load_scalar(fx);\n                 Some(CValue::by_val_pair(val, is_overflow, fx.layout_of(out_ty)))\n             } else {\n-                Some(val)\n+                Some(CValue::by_val(val, lhs.layout()))\n             }\n         }\n     }"}, {"sha": "6a4a6744a5cf7bc469c1f01f00437f9b38cdad37", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 21, "deletions": 90, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -3,8 +3,6 @@ use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n-use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n-\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -56,11 +54,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n             FloatTy::F64 => types::F64,\n         },\n         ty::FnPtr(_) => pointer_ty(tcx),\n-        ty::RawPtr(TypeAndMut {\n-            ty: pointee_ty,\n-            mutbl: _,\n-        })\n-        | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 return None;\n             } else {\n@@ -99,11 +93,7 @@ fn clif_pair_type_from_ty<'tcx>(\n             }\n             (a, b)\n         }\n-        ty::RawPtr(TypeAndMut {\n-            ty: pointee_ty,\n-            mutbl: _,\n-        })\n-        | ty::Ref(_, pointee_ty, _) => {\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, pointee_ty) {\n                 (pointer_ty(tcx), pointer_ty(tcx))\n             } else {\n@@ -116,23 +106,16 @@ fn clif_pair_type_from_ty<'tcx>(\n \n /// Is a pointer to this type a fat ptr?\n pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    let ptr_ty = tcx.mk_ptr(TypeAndMut {\n-        ty,\n-        mutbl: rustc_hir::Mutability::Not,\n-    });\n-    match &tcx\n-        .layout_of(ParamEnv::reveal_all().and(ptr_ty))\n-        .unwrap()\n-        .abi\n-    {\n+    let ptr_ty = tcx.mk_ptr(TypeAndMut { ty, mutbl: rustc_hir::Mutability::Not });\n+    match &tcx.layout_of(ParamEnv::reveal_all().and(ptr_ty)).unwrap().abi {\n         Abi::Scalar(_) => false,\n         Abi::ScalarPair(_, _) => true,\n         abi => unreachable!(\"Abi of ptr to {:?} is {:?}???\", ty, abi),\n     }\n }\n \n pub(crate) fn codegen_icmp_imm(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     intcc: IntCC,\n     lhs: Value,\n     rhs: i128,\n@@ -175,51 +158,6 @@ pub(crate) fn codegen_icmp_imm(\n     }\n }\n \n-fn resolve_normal_value_imm(func: &Function, val: Value) -> Option<i64> {\n-    if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n-        if let InstructionData::UnaryImm {\n-            opcode: Opcode::Iconst,\n-            imm,\n-        } = func.dfg[inst]\n-        {\n-            Some(imm.into())\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn resolve_128bit_value_imm(func: &Function, val: Value) -> Option<u128> {\n-    let (lsb, msb) = if let ValueDef::Result(inst, 0 /*param*/) = func.dfg.value_def(val) {\n-        if let InstructionData::Binary {\n-            opcode: Opcode::Iconcat,\n-            args: [lsb, msb],\n-        } = func.dfg[inst]\n-        {\n-            (lsb, msb)\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        return None;\n-    };\n-\n-    let lsb = u128::from(resolve_normal_value_imm(func, lsb)? as u64);\n-    let msb = u128::from(resolve_normal_value_imm(func, msb)? as u64);\n-\n-    Some(msb << 64 | lsb)\n-}\n-\n-pub(crate) fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n-    if func.dfg.value_type(val) == types::I128 {\n-        resolve_128bit_value_imm(func, val)\n-    } else {\n-        resolve_normal_value_imm(func, val).map(|imm| u128::from(imm as u64))\n-    }\n-}\n-\n pub(crate) fn type_min_max_value(\n     bcx: &mut FunctionBuilder<'_>,\n     ty: Type,\n@@ -288,8 +226,8 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n-pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx, M>,\n+pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'m, 'tcx>,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n \n@@ -316,7 +254,7 @@ pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n     pub(crate) inline_asm_index: u32,\n }\n \n-impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> LayoutOf for FunctionCx<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n@@ -325,31 +263,31 @@ impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n     }\n }\n \n-impl<'tcx, M: Module> layout::HasTyCtxt<'tcx> for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> layout::HasTyCtxt<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'tcx, M: Module> rustc_target::abi::HasDataLayout for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> rustc_target::abi::HasDataLayout for FunctionCx<'_, '_, 'tcx> {\n     fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'tcx, M: Module> layout::HasParamEnv<'tcx> for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> layout::HasParamEnv<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn param_env(&self) -> ParamEnv<'tcx> {\n         ParamEnv::reveal_all()\n     }\n }\n \n-impl<'tcx, M: Module> HasTargetSpec for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> HasTargetSpec for FunctionCx<'_, '_, 'tcx> {\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target\n     }\n }\n \n-impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     pub(crate) fn monomorphize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n@@ -416,12 +354,7 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         let msg_id = self\n             .cx\n             .module\n-            .declare_data(\n-                &format!(\"__{}_{:08x}\", prefix, msg_hash),\n-                Linkage::Local,\n-                false,\n-                false,\n-            )\n+            .declare_data(&format!(\"__{}_{:08x}\", prefix, msg_hash), Linkage::Local, false, false)\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n@@ -444,15 +377,13 @@ impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n         assert!(!ty.still_further_specializable());\n-        self.0\n-            .layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| {\n-                if let layout::LayoutError::SizeOverflow(_) = e {\n-                    self.0.sess.fatal(&e.to_string())\n-                } else {\n-                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n+        self.0.layout_of(ParamEnv::reveal_all().and(&ty)).unwrap_or_else(|e| {\n+            if let layout::LayoutError::SizeOverflow(_) = e {\n+                self.0.sess.fatal(&e.to_string())\n+            } else {\n+                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+            }\n+        })\n     }\n }\n "}, {"sha": "b0639cf9e15fe70839956ee2e18dbcdea2120d6f", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 40, "deletions": 78, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -28,29 +28,28 @@ enum TodoItem {\n }\n \n impl ConstantCx {\n-    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut impl Module) {\n+    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut dyn Module) {\n         //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n         //println!(\"done {:?}\", self.done);\n         self.done.clear();\n     }\n }\n \n-pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n+    let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n         let const_ = fx.monomorphize(constant.literal);\n         match const_.val {\n             ConstKind::Value(_) => {}\n             ConstKind::Unevaluated(def, ref substs, promoted) => {\n                 if let Err(err) =\n-                    fx.tcx\n-                        .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n+                    fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n                 {\n+                    all_constants_ok = false;\n                     match err {\n                         ErrorHandled::Reported(ErrorReported) | ErrorHandled::Linted => {\n-                            fx.tcx\n-                                .sess\n-                                .span_err(constant.span, \"erroneous constant encountered\");\n+                            fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n                         }\n                         ErrorHandled::TooGeneric => {\n                             span_bug!(\n@@ -69,18 +68,19 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n         }\n     }\n+    all_constants_ok\n }\n \n pub(crate) fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n     constants_cx.todo.push(TodoItem::Static(def_id));\n }\n \n pub(crate) fn codegen_tls_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n@@ -89,11 +89,11 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n }\n \n fn codegen_static_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n@@ -110,7 +110,7 @@ fn codegen_static_ref<'tcx>(\n }\n \n pub(crate) fn codegen_constant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n     let const_ = fx.monomorphize(constant.literal);\n@@ -128,20 +128,10 @@ pub(crate) fn codegen_constant<'tcx>(\n             .to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(def, ref substs, promoted) => {\n-            match fx\n-                .tcx\n-                .const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None)\n-            {\n+            match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n                 Ok(const_val) => const_val,\n                 Err(_) => {\n-                    fx.tcx\n-                        .sess\n-                        .span_err(constant.span, \"erroneous constant encountered\");\n-                    return crate::trap::trap_unreachable_ret_value(\n-                        fx,\n-                        fx.layout_of(const_.ty),\n-                        \"erroneous constant encountered\",\n-                    );\n+                    span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n                 }\n             }\n         }\n@@ -156,7 +146,7 @@ pub(crate) fn codegen_constant<'tcx>(\n }\n \n pub(crate) fn codegen_const_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     const_val: ConstValue<'tcx>,\n     ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n@@ -172,9 +162,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n             if fx.clif_type(layout.ty).is_none() {\n                 let (size, align) = (layout.size, layout.align.pref);\n                 let mut alloc = Allocation::from_bytes(\n-                    std::iter::repeat(0)\n-                        .take(size.bytes_usize())\n-                        .collect::<Vec<u8>>(),\n+                    std::iter::repeat(0).take(size.bytes_usize()).collect::<Vec<u8>>(),\n                     align,\n                 );\n                 let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n@@ -190,11 +178,8 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id = data_id_for_alloc_id(\n-                                &mut fx.cx.module,\n-                                ptr.alloc_id,\n-                                alloc.mutability,\n-                            );\n+                            let data_id =\n+                                data_id_for_alloc_id(fx.cx.module, ptr.alloc_id, alloc.mutability);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n@@ -203,15 +188,14 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n                             let func_id =\n-                                crate::abi::import_function(fx.tcx, &mut fx.cx.module, instance);\n+                                crate::abi::import_function(fx.tcx, fx.cx.module, instance);\n                             let local_func_id =\n                                 fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id =\n-                                data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+                            let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n@@ -221,9 +205,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n                     };\n                     let val = if ptr.offset.bytes() != 0 {\n-                        fx.bcx\n-                            .ins()\n-                            .iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n+                        fx.bcx.ins().iadd_imm(base_addr, i64::try_from(ptr.offset.bytes()).unwrap())\n                     } else {\n                         base_addr\n                     };\n@@ -240,22 +222,22 @@ pub(crate) fn codegen_const_value<'tcx>(\n             let ptr = pointer_for_allocation(fx, data)\n                 .offset_i64(fx, i64::try_from(start).unwrap())\n                 .get_addr(fx);\n-            let len = fx.bcx.ins().iconst(\n-                fx.pointer_type,\n-                i64::try_from(end.checked_sub(start).unwrap()).unwrap(),\n-            );\n+            let len = fx\n+                .bcx\n+                .ins()\n+                .iconst(fx.pointer_type, i64::try_from(end.checked_sub(start).unwrap()).unwrap());\n             CValue::by_val_pair(ptr, len, layout)\n         }\n     }\n }\n \n fn pointer_for_allocation<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n     fx.cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-    let data_id = data_id_for_alloc_id(&mut fx.cx.module, alloc_id, alloc.mutability);\n+    let data_id = data_id_for_alloc_id(fx.cx.module, alloc_id, alloc.mutability);\n \n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n@@ -265,7 +247,7 @@ fn pointer_for_allocation<'tcx>(\n }\n \n fn data_id_for_alloc_id(\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     alloc_id: AllocId,\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n@@ -281,7 +263,7 @@ fn data_id_for_alloc_id(\n \n fn data_id_for_static(\n     tcx: TyCtxt<'_>,\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     def_id: DefId,\n     definition: bool,\n ) -> DataId {\n@@ -304,12 +286,7 @@ fn data_id_for_static(\n     } else {\n         !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n     };\n-    let align = tcx\n-        .layout_of(ParamEnv::reveal_all().and(ty))\n-        .unwrap()\n-        .align\n-        .pref\n-        .bytes();\n+    let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n \n     let attrs = tcx.codegen_fn_attrs(def_id);\n \n@@ -332,17 +309,11 @@ fn data_id_for_static(\n         // zero.\n \n         let ref_name = format!(\"_rust_extern_with_linkage_{}\", symbol_name);\n-        let ref_data_id = module\n-            .declare_data(&ref_name, Linkage::Local, false, false)\n-            .unwrap();\n+        let ref_data_id = module.declare_data(&ref_name, Linkage::Local, false, false).unwrap();\n         let mut data_ctx = DataContext::new();\n         data_ctx.set_align(align);\n         let data = module.declare_data_in_data(data_id, &mut data_ctx);\n-        data_ctx.define(\n-            std::iter::repeat(0)\n-                .take(pointer_ty(tcx).bytes() as usize)\n-                .collect(),\n-        );\n+        data_ctx.define(std::iter::repeat(0).take(pointer_ty(tcx).bytes() as usize).collect());\n         data_ctx.write_data_addr(0, data, 0);\n         match module.define_data(ref_data_id, &data_ctx) {\n             // Every time the static is referenced there will be another definition of this global,\n@@ -356,7 +327,7 @@ fn data_id_for_static(\n     }\n }\n \n-fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut ConstantCx) {\n+fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut ConstantCx) {\n     while let Some(todo_item) = cx.todo.pop() {\n         let (data_id, alloc, section_name) = match todo_item {\n             TodoItem::Alloc(alloc_id) => {\n@@ -371,10 +342,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             TodoItem::Static(def_id) => {\n                 //println!(\"static {:?}\", def_id);\n \n-                let section_name = tcx\n-                    .codegen_fn_attrs(def_id)\n-                    .link_section\n-                    .map(|s| s.as_str());\n+                let section_name = tcx.codegen_fn_attrs(def_id).link_section.map(|s| s.as_str());\n \n                 let alloc = tcx.eval_static_initializer(def_id).unwrap();\n \n@@ -396,9 +364,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             data_ctx.set_segment_section(\"\", &*section_name);\n         }\n \n-        let bytes = alloc\n-            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n-            .to_vec();\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()).to_vec();\n         data_ctx.define(bytes.into_boxed_slice());\n \n         for &(offset, (_tag, reloc)) in alloc.relocations().iter() {\n@@ -426,10 +392,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n                     data_id_for_alloc_id(module, reloc, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n-                    if tcx\n-                        .codegen_fn_attrs(def_id)\n-                        .flags\n-                        .contains(CodegenFnAttrFlags::THREAD_LOCAL)\n+                    if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n                     {\n                         tcx.sess.fatal(&format!(\n                             \"Allocation {:?} contains reference to TLS value {:?}\",\n@@ -457,14 +420,13 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n }\n \n pub(crate) fn mir_operand_get_const_val<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> Option<&'tcx Const<'tcx>> {\n     match operand {\n         Operand::Copy(_) | Operand::Move(_) => None,\n-        Operand::Constant(const_) => Some(\n-            fx.monomorphize(const_.literal)\n-                .eval(fx.tcx, ParamEnv::reveal_all()),\n-        ),\n+        Operand::Constant(const_) => {\n+            Some(fx.monomorphize(const_.literal).eval(fx.tcx, ParamEnv::reveal_all()))\n+        }\n     }\n }"}, {"sha": "6018eefcd42fb4ae4b196729bed6ecbe19d33dc8", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -14,10 +14,7 @@ impl DebugContext<'_> {\n         let unit_range_list_id = self.dwarf.unit.ranges.add(self.unit_range_list.clone());\n         let root = self.dwarf.unit.root();\n         let root = self.dwarf.unit.get_mut(root);\n-        root.set(\n-            gimli::DW_AT_ranges,\n-            AttributeValue::RangeListRef(unit_range_list_id),\n-        );\n+        root.set(gimli::DW_AT_ranges, AttributeValue::RangeListRef(unit_range_list_id));\n \n         let mut sections = Sections::new(WriterRelocate::new(self.endian));\n         self.dwarf.write(&mut sections).unwrap();\n@@ -66,10 +63,7 @@ pub(super) struct WriterRelocate {\n \n impl WriterRelocate {\n     pub(super) fn new(endian: RunTimeEndian) -> Self {\n-        WriterRelocate {\n-            relocs: Vec::new(),\n-            writer: EndianVec::new(endian),\n-        }\n+        WriterRelocate { relocs: Vec::new(), writer: EndianVec::new(endian) }\n     }\n \n     /// Perform the collected relocations to be usable for JIT usage.\n@@ -85,9 +79,7 @@ impl WriterRelocate {\n                         cranelift_module::FuncId::from_u32(sym.try_into().unwrap()),\n                     );\n                     let val = (addr as u64 as i64 + reloc.addend) as u64;\n-                    self.writer\n-                        .write_udata_at(reloc.offset as usize, val, reloc.size)\n-                        .unwrap();\n+                    self.writer.write_udata_at(reloc.offset as usize, val, reloc.size).unwrap();\n                 }\n             }\n         }"}, {"sha": "30ed356c7627f65b9ec6da55b3ca4a8a6094997b", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/line_info.rs", "status": "modified", "additions": 18, "deletions": 57, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fline_info.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -53,11 +53,7 @@ pub(crate) fn make_file_info(hash: SourceFileHash) -> Option<FileInfo> {\n     if hash.kind == SourceFileHashAlgorithm::Md5 {\n         let mut buf = [0u8; MD5_LEN];\n         buf.copy_from_slice(hash.hash_bytes());\n-        Some(FileInfo {\n-            timestamp: 0,\n-            size: 0,\n-            md5: buf,\n-        })\n+        Some(FileInfo { timestamp: 0, size: 0, md5: buf })\n     } else {\n         None\n     }\n@@ -112,24 +108,14 @@ impl<'tcx> DebugContext<'tcx> {\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n \n-        entry.set(\n-            gimli::DW_AT_decl_file,\n-            AttributeValue::FileIndex(Some(file_id)),\n-        );\n-        entry.set(\n-            gimli::DW_AT_decl_line,\n-            AttributeValue::Udata(loc.line as u64),\n-        );\n+        entry.set(gimli::DW_AT_decl_file, AttributeValue::FileIndex(Some(file_id)));\n+        entry.set(gimli::DW_AT_decl_line, AttributeValue::Udata(loc.line as u64));\n         // FIXME: probably omit this\n-        entry.set(\n-            gimli::DW_AT_decl_column,\n-            AttributeValue::Udata(loc.col.to_usize() as u64),\n-        );\n+        entry.set(gimli::DW_AT_decl_column, AttributeValue::Udata(loc.col.to_usize() as u64));\n     }\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n-        isa: &dyn cranelift_codegen::isa::TargetIsa,\n         symbol: usize,\n         entry_id: UnitEntryId,\n         context: &Context,\n@@ -138,7 +124,6 @@ impl<'tcx> DebugContext<'tcx> {\n     ) -> CodeOffset {\n         let tcx = self.tcx;\n         let line_program = &mut self.dwarf.unit.line_program;\n-        let func = &context.func;\n \n         let line_strings = &mut self.dwarf.line_strings;\n         let mut last_span = None;\n@@ -202,54 +187,30 @@ impl<'tcx> DebugContext<'tcx> {\n \n         let mut func_end = 0;\n \n-        if let Some(ref mcr) = &context.mach_compile_result {\n-            for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-                line_program.row().address_offset = u64::from(start);\n-                if !loc.is_default() {\n-                    let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                    create_row_for_span(line_program, source_info.span);\n-                } else {\n-                    create_row_for_span(line_program, function_span);\n-                }\n-                func_end = end;\n-            }\n-\n-            line_program.end_sequence(u64::from(func_end));\n-\n-            func_end = mcr.buffer.total_size();\n-        } else {\n-            let encinfo = isa.encoding_info();\n-            let mut blocks = func.layout.blocks().collect::<Vec<_>>();\n-            blocks.sort_by_key(|block| func.offsets[*block]); // Ensure inst offsets always increase\n-\n-            for block in blocks {\n-                for (offset, inst, size) in func.inst_offsets(block, &encinfo) {\n-                    let srcloc = func.srclocs[inst];\n-                    line_program.row().address_offset = u64::from(offset);\n-                    if !srcloc.is_default() {\n-                        let source_info =\n-                            *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n-                        create_row_for_span(line_program, source_info.span);\n-                    } else {\n-                        create_row_for_span(line_program, function_span);\n-                    }\n-                    func_end = offset + size;\n-                }\n+        let mcr = context.mach_compile_result.as_ref().unwrap();\n+        for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n+            line_program.row().address_offset = u64::from(start);\n+            if !loc.is_default() {\n+                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(line_program, source_info.span);\n+            } else {\n+                create_row_for_span(line_program, function_span);\n             }\n-            line_program.end_sequence(u64::from(func_end));\n+            func_end = end;\n         }\n \n+        line_program.end_sequence(u64::from(func_end));\n+\n+        let func_end = mcr.buffer.total_size();\n+\n         assert_ne!(func_end, 0);\n \n         let entry = self.dwarf.unit.get_mut(entry_id);\n         entry.set(\n             gimli::DW_AT_low_pc,\n             AttributeValue::Address(Address::Symbol { symbol, addend: 0 }),\n         );\n-        entry.set(\n-            gimli::DW_AT_high_pc,\n-            AttributeValue::Udata(u64::from(func_end)),\n-        );\n+        entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(func_end)));\n \n         self.emit_location(entry_id, function_span);\n "}, {"sha": "dc8bc8d9cb74147814e27809f1e7e20457df6885", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 26, "deletions": 131, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,7 +9,7 @@ use crate::prelude::*;\n use rustc_index::vec::IndexVec;\n \n use cranelift_codegen::entity::EntityRef;\n-use cranelift_codegen::ir::{StackSlots, ValueLabel, ValueLoc};\n+use cranelift_codegen::ir::{LabelValueLoc, StackSlots, ValueLabel, ValueLoc};\n use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::ValueLocRange;\n \n@@ -39,7 +39,6 @@ pub(crate) struct DebugContext<'tcx> {\n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n \n-    clif_types: FxHashMap<Type, UnitEntryId>,\n     types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n }\n \n@@ -91,20 +90,11 @@ impl<'tcx> DebugContext<'tcx> {\n \n             let root = dwarf.unit.root();\n             let root = dwarf.unit.get_mut(root);\n-            root.set(\n-                gimli::DW_AT_producer,\n-                AttributeValue::StringRef(dwarf.strings.add(producer)),\n-            );\n-            root.set(\n-                gimli::DW_AT_language,\n-                AttributeValue::Language(gimli::DW_LANG_Rust),\n-            );\n+            root.set(gimli::DW_AT_producer, AttributeValue::StringRef(dwarf.strings.add(producer)));\n+            root.set(gimli::DW_AT_language, AttributeValue::Language(gimli::DW_LANG_Rust));\n             root.set(gimli::DW_AT_name, AttributeValue::StringRef(name));\n             root.set(gimli::DW_AT_comp_dir, AttributeValue::StringRef(comp_dir));\n-            root.set(\n-                gimli::DW_AT_low_pc,\n-                AttributeValue::Address(Address::Constant(0)),\n-            );\n+            root.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Constant(0)));\n         }\n \n         DebugContext {\n@@ -115,48 +105,10 @@ impl<'tcx> DebugContext<'tcx> {\n             dwarf,\n             unit_range_list: RangeList(Vec::new()),\n \n-            clif_types: FxHashMap::default(),\n             types: FxHashMap::default(),\n         }\n     }\n \n-    fn dwarf_ty_for_clif_ty(&mut self, ty: Type) -> UnitEntryId {\n-        if let Some(type_id) = self.clif_types.get(&ty) {\n-            return *type_id;\n-        }\n-\n-        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n-\n-        let primitive = |dwarf: &mut DwarfUnit, ate| {\n-            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n-            let type_entry = dwarf.unit.get_mut(type_id);\n-            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n-            type_id\n-        };\n-\n-        let type_id = if ty.is_bool() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_boolean)\n-        } else if ty.is_int() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_address)\n-        } else if ty.is_float() {\n-            primitive(&mut self.dwarf, gimli::DW_ATE_float)\n-        } else {\n-            new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type)\n-        };\n-\n-        let type_entry = self.dwarf.unit.get_mut(type_id);\n-        type_entry.set(\n-            gimli::DW_AT_name,\n-            AttributeValue::String(format!(\"{}\", ty).replace('i', \"u\").into_bytes()),\n-        );\n-        type_entry.set(\n-            gimli::DW_AT_byte_size,\n-            AttributeValue::Udata(u64::from(ty.bytes())),\n-        );\n-\n-        type_id\n-    }\n-\n     fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n         if let Some(type_id) = self.types.get(ty) {\n             return *type_id;\n@@ -181,10 +133,7 @@ impl<'tcx> DebugContext<'tcx> {\n             ty::Int(_) => primitive(&mut self.dwarf, gimli::DW_ATE_signed),\n             ty::Float(_) => primitive(&mut self.dwarf, gimli::DW_ATE_float),\n             ty::Ref(_, pointee_ty, _mutbl)\n-            | ty::RawPtr(ty::TypeAndMut {\n-                ty: pointee_ty,\n-                mutbl: _mutbl,\n-            }) => {\n+            | ty::RawPtr(ty::TypeAndMut { ty: pointee_ty, mutbl: _mutbl }) => {\n                 let type_id = new_entry(&mut self.dwarf, gimli::DW_TAG_pointer_type);\n \n                 // Ensure that type is inserted before recursing to avoid duplicates\n@@ -211,10 +160,7 @@ impl<'tcx> DebugContext<'tcx> {\n                     let field_offset = layout.fields.offset(field_idx);\n                     let field_layout = layout\n                         .field(\n-                            &layout::LayoutCx {\n-                                tcx: self.tcx,\n-                                param_env: ParamEnv::reveal_all(),\n-                            },\n+                            &layout::LayoutCx { tcx: self.tcx, param_env: ParamEnv::reveal_all() },\n                             field_idx,\n                         )\n                         .unwrap();\n@@ -243,10 +189,7 @@ impl<'tcx> DebugContext<'tcx> {\n         let type_entry = self.dwarf.unit.get_mut(type_id);\n \n         type_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-        type_entry.set(\n-            gimli::DW_AT_byte_size,\n-            AttributeValue::Udata(layout.size.bytes()),\n-        );\n+        type_entry.set(gimli::DW_AT_byte_size, AttributeValue::Udata(layout.size.bytes()));\n \n         self.types.insert(ty, type_id);\n \n@@ -286,23 +229,15 @@ impl<'tcx> DebugContext<'tcx> {\n         let name_id = self.dwarf.strings.add(name);\n         // Gdb requires DW_AT_name. Otherwise the DW_TAG_subprogram is skipped.\n         entry.set(gimli::DW_AT_name, AttributeValue::StringRef(name_id));\n-        entry.set(\n-            gimli::DW_AT_linkage_name,\n-            AttributeValue::StringRef(name_id),\n-        );\n+        entry.set(gimli::DW_AT_linkage_name, AttributeValue::StringRef(name_id));\n \n-        let end =\n-            self.create_debug_lines(isa, symbol, entry_id, context, mir.span, source_info_set);\n+        let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n \n         self.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },\n             length: u64::from(end),\n         });\n \n-        if isa.get_mach_backend().is_some() {\n-            return; // Not yet implemented for the AArch64 backend.\n-        }\n-\n         let func_entry = self.dwarf.unit.get_mut(entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n         func_entry.set(\n@@ -312,51 +247,6 @@ impl<'tcx> DebugContext<'tcx> {\n         // Using Udata for DW_AT_high_pc requires at least DWARF4\n         func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n \n-        // FIXME Remove once actual debuginfo for locals works.\n-        for (i, (param, &val)) in context\n-            .func\n-            .signature\n-            .params\n-            .iter()\n-            .zip(\n-                context\n-                    .func\n-                    .dfg\n-                    .block_params(context.func.layout.entry_block().unwrap()),\n-            )\n-            .enumerate()\n-        {\n-            use cranelift_codegen::ir::ArgumentPurpose;\n-            let base_name = match param.purpose {\n-                ArgumentPurpose::Normal => \"arg\",\n-                ArgumentPurpose::StructArgument(_) => \"struct_arg\",\n-                ArgumentPurpose::StructReturn => \"sret\",\n-                ArgumentPurpose::Link\n-                | ArgumentPurpose::FramePointer\n-                | ArgumentPurpose::CalleeSaved => continue,\n-                ArgumentPurpose::VMContext\n-                | ArgumentPurpose::SignatureId\n-                | ArgumentPurpose::CallerTLS\n-                | ArgumentPurpose::CalleeTLS\n-                | ArgumentPurpose::StackLimit => unreachable!(),\n-            };\n-            let name = format!(\"{}{}\", base_name, i);\n-\n-            let dw_ty = self.dwarf_ty_for_clif_ty(param.value_type);\n-            let loc =\n-                translate_loc(isa, context.func.locations[val], &context.func.stack_slots).unwrap();\n-\n-            let arg_id = self\n-                .dwarf\n-                .unit\n-                .add(entry_id, gimli::DW_TAG_formal_parameter);\n-            let var_entry = self.dwarf.unit.get_mut(arg_id);\n-\n-            var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n-            var_entry.set(gimli::DW_AT_type, AttributeValue::UnitRef(dw_ty));\n-            var_entry.set(gimli::DW_AT_location, AttributeValue::Exprloc(loc));\n-        }\n-\n         // FIXME make it more reliable and implement scopes before re-enabling this.\n         if false {\n             let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n@@ -376,10 +266,7 @@ impl<'tcx> DebugContext<'tcx> {\n                     context,\n                     &local_map,\n                     &value_labels_ranges,\n-                    Place {\n-                        local,\n-                        projection: ty::List::empty(),\n-                    },\n+                    Place { local, projection: ty::List::empty() },\n                 );\n \n                 let var_entry = self.dwarf.unit.get_mut(var_id);\n@@ -417,10 +304,7 @@ fn place_location<'tcx>(\n                                 symbol,\n                                 addend: i64::from(value_loc_range.start),\n                             },\n-                            end: Address::Symbol {\n-                                symbol,\n-                                addend: i64::from(value_loc_range.end),\n-                            },\n+                            end: Address::Symbol { symbol, addend: i64::from(value_loc_range.end) },\n                             data: translate_loc(\n                                 isa,\n                                 value_loc_range.loc,\n@@ -463,17 +347,17 @@ fn place_location<'tcx>(\n // Adapted from https://github.com/CraneStation/wasmtime/blob/5a1845b4caf7a5dba8eda1fef05213a532ed4259/crates/debug/src/transform/expression.rs#L59-L137\n fn translate_loc(\n     isa: &dyn TargetIsa,\n-    loc: ValueLoc,\n+    loc: LabelValueLoc,\n     stack_slots: &StackSlots,\n ) -> Option<Expression> {\n     match loc {\n-        ValueLoc::Reg(reg) => {\n+        LabelValueLoc::ValueLoc(ValueLoc::Reg(reg)) => {\n             let machine_reg = isa.map_dwarf_register(reg).unwrap();\n             let mut expr = Expression::new();\n             expr.op_reg(gimli::Register(machine_reg));\n             Some(expr)\n         }\n-        ValueLoc::Stack(ss) => {\n+        LabelValueLoc::ValueLoc(ValueLoc::Stack(ss)) => {\n             if let Some(ss_offset) = stack_slots[ss].offset {\n                 let mut expr = Expression::new();\n                 expr.op_breg(X86_64::RBP, i64::from(ss_offset) + 16);\n@@ -482,6 +366,17 @@ fn translate_loc(\n                 None\n             }\n         }\n-        _ => None,\n+        LabelValueLoc::ValueLoc(ValueLoc::Unassigned) => unreachable!(),\n+        LabelValueLoc::Reg(reg) => {\n+            let machine_reg = isa.map_regalloc_reg_to_dwarf(reg).unwrap();\n+            let mut expr = Expression::new();\n+            expr.op_reg(gimli::Register(machine_reg));\n+            Some(expr)\n+        }\n+        LabelValueLoc::SPOffset(offset) => {\n+            let mut expr = Expression::new();\n+            expr.op_breg(X86_64::RSP, offset);\n+            Some(expr)\n+        }\n     }\n }"}, {"sha": "357c9fe6ed83a08e19e022c259a84b1b1a23ed36", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -28,11 +28,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             None\n         };\n \n-        UnwindContext {\n-            tcx,\n-            frame_table,\n-            cie_id,\n-        }\n+        UnwindContext { tcx, frame_table, cie_id }\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n@@ -46,10 +42,8 @@ impl<'tcx> UnwindContext<'tcx> {\n             UnwindInfo::SystemV(unwind_info) => {\n                 self.frame_table.add_fde(\n                     self.cie_id.unwrap(),\n-                    unwind_info.to_fde(Address::Symbol {\n-                        symbol: func_id.as_u32() as usize,\n-                        addend: 0,\n-                    }),\n+                    unwind_info\n+                        .to_fde(Address::Symbol { symbol: func_id.as_u32() as usize, addend: 0 }),\n                 );\n             }\n             UnwindInfo::WindowsX64(_) => {\n@@ -60,9 +54,8 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n-            self.tcx,\n-        )));\n+        let mut eh_frame =\n+            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -82,9 +75,8 @@ impl<'tcx> UnwindContext<'tcx> {\n         self,\n         jit_module: &cranelift_jit::JITModule,\n     ) -> Option<UnwindRegistry> {\n-        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(\n-            self.tcx,\n-        )));\n+        let mut eh_frame =\n+            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {\n@@ -130,10 +122,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             registrations.push(ptr as usize);\n         }\n \n-        Some(UnwindRegistry {\n-            _frame_table: eh_frame,\n-            registrations,\n-        })\n+        Some(UnwindRegistry { _frame_table: eh_frame, registrations })\n     }\n }\n "}, {"sha": "3326f87f000757099e3a9940de6677609889b533", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -7,7 +7,7 @@ use rustc_target::abi::{Int, TagEncoding, Variants};\n use crate::prelude::*;\n \n pub(crate) fn codegen_set_discriminant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     variant_index: VariantIdx,\n ) {\n@@ -26,11 +26,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             variants: _,\n         } => {\n             let ptr = place.place_field(fx, mir::Field::new(tag_field));\n-            let to = layout\n-                .ty\n-                .discriminant_for_variant(fx.tcx, variant_index)\n-                .unwrap()\n-                .val;\n+            let to = layout.ty.discriminant_for_variant(fx.tcx, variant_index).unwrap().val;\n             let to = if ptr.layout().abi.is_signed() {\n                 ty::ScalarInt::try_from_int(\n                     ptr.layout().size.sign_extend(to) as i128,\n@@ -46,12 +42,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         Variants::Multiple {\n             tag: _,\n             tag_field,\n-            tag_encoding:\n-                TagEncoding::Niche {\n-                    dataful_variant,\n-                    ref niche_variants,\n-                    niche_start,\n-                },\n+            tag_encoding: TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n             variants: _,\n         } => {\n             if variant_index != dataful_variant {\n@@ -70,7 +61,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n }\n \n pub(crate) fn codegen_get_discriminant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     value: CValue<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n@@ -101,12 +92,9 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             };\n             return CValue::const_val(fx, dest_layout, discr_val);\n         }\n-        Variants::Multiple {\n-            tag,\n-            tag_field,\n-            tag_encoding,\n-            variants: _,\n-        } => (tag, *tag_field, tag_encoding),\n+        Variants::Multiple { tag, tag_field, tag_encoding, variants: _ } => {\n+            (tag, *tag_field, tag_encoding)\n+        }\n     };\n \n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n@@ -125,11 +113,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             let val = clif_intcast(fx, tag, cast_to, signed);\n             CValue::by_val(val, dest_layout)\n         }\n-        TagEncoding::Niche {\n-            dataful_variant,\n-            ref niche_variants,\n-            niche_start,\n-        } => {\n+        TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n             // Rebase from niche values to discriminants, and check\n             // whether the result is in range for the niche variants.\n \n@@ -146,9 +130,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 tag\n             } else {\n                 // FIXME handle niche_start > i64::MAX\n-                fx.bcx\n-                    .ins()\n-                    .iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n+                fx.bcx.ins().iadd_imm(tag, -i64::try_from(niche_start).unwrap())\n             };\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n             let is_niche = {\n@@ -176,15 +158,10 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 } else {\n                     clif_intcast(fx, relative_discr, cast_to, false)\n                 };\n-                fx.bcx\n-                    .ins()\n-                    .iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n+                fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n             };\n \n-            let dataful_variant = fx\n-                .bcx\n-                .ins()\n-                .iconst(cast_to, i64::from(dataful_variant.as_u32()));\n+            let dataful_variant = fx.bcx.ins().iconst(cast_to, i64::from(dataful_variant.as_u32()));\n             let discr = fx.bcx.ins().select(is_niche, niche_discr, dataful_variant);\n             CValue::by_val(discr, dest_layout)\n         }"}, {"sha": "b87dcc41928b699b27f7e905a69f83f23299e894", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 28, "deletions": 96, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -12,11 +12,9 @@ use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n \n-use cranelift_object::{ObjectModule, ObjectProduct};\n+use cranelift_object::ObjectModule;\n \n-use crate::prelude::*;\n-\n-use crate::backend::AddConstructor;\n+use crate::{prelude::*, BackendConfig};\n \n fn new_module(tcx: TyCtxt<'_>, name: String) -> ObjectModule {\n     let module = crate::backend::make_module(tcx.sess, name);\n@@ -39,7 +37,6 @@ fn emit_module(\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n     unwind_context: UnwindContext<'_>,\n-    map_product: impl FnOnce(ObjectProduct) -> ObjectProduct,\n ) -> ModuleCodegenResult {\n     let mut product = module.finish();\n \n@@ -49,15 +46,10 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let product = map_product(product);\n-\n-    let tmp_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .temp_path(OutputType::Object, Some(&name));\n+    let tmp_file = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&name));\n     let obj = product.object.write().unwrap();\n     if let Err(err) = std::fs::write(&tmp_file, obj) {\n-        tcx.sess\n-            .fatal(&format!(\"error writing object file: {}\", err));\n+        tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n     }\n \n     let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n@@ -71,13 +63,7 @@ fn emit_module(\n     };\n \n     ModuleCodegenResult(\n-        CompiledModule {\n-            name,\n-            kind,\n-            object: Some(tmp_file),\n-            dwarf_object: None,\n-            bytecode: None,\n-        },\n+        CompiledModule { name, kind, object: Some(tmp_file), dwarf_object: None, bytecode: None },\n         work_product,\n     )\n }\n@@ -117,55 +103,33 @@ fn reuse_workproduct_for_cgu(\n     }\n }\n \n-fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n+fn module_codegen(\n+    tcx: TyCtxt<'_>,\n+    (backend_config, cgu_name): (BackendConfig, rustc_span::Symbol),\n+) -> ModuleCodegenResult {\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n     let mut module = new_module(tcx, cgu_name.as_str().to_string());\n \n-    // Initialize the global atomic mutex using a constructor for proc-macros.\n-    // FIXME implement atomic instructions in Cranelift.\n-    let mut init_atomics_mutex_from_constructor = None;\n-    if tcx\n-        .sess\n-        .crate_types()\n-        .contains(&rustc_session::config::CrateType::ProcMacro)\n-    {\n-        if mono_items.iter().any(|(mono_item, _)| match mono_item {\n-            rustc_middle::mir::mono::MonoItem::Static(def_id) => tcx\n-                .symbol_name(Instance::mono(tcx, *def_id))\n-                .name\n-                .contains(\"__rustc_proc_macro_decls_\"),\n-            _ => false,\n-        }) {\n-            init_atomics_mutex_from_constructor =\n-                Some(crate::atomic_shim::init_global_lock_constructor(\n-                    &mut module,\n-                    &format!(\"{}_init_atomics_mutex\", cgu_name.as_str()),\n-                ));\n-        }\n-    }\n-\n     let mut cx = crate::CodegenCx::new(\n         tcx,\n-        module,\n+        backend_config,\n+        &mut module,\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n-        true,\n     );\n     super::predefine_mono_items(&mut cx, &mono_items);\n     for (mono_item, (linkage, visibility)) in mono_items {\n         let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || {\n-                    crate::base::codegen_fn(&mut cx, inst, linkage)\n-                });\n+                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n             }\n             MonoItem::Static(def_id) => {\n                 crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n             }\n-            MonoItem::GlobalAsm(hir_id) => {\n-                let item = cx.tcx.hir().expect_item(hir_id);\n+            MonoItem::GlobalAsm(item_id) => {\n+                let item = cx.tcx.hir().item(item_id);\n                 if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n                     cx.global_asm.push_str(&*asm.as_str());\n                     cx.global_asm.push_str(\"\\n\\n\");\n@@ -175,9 +139,9 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n             }\n         }\n     }\n-    let (mut module, global_asm, debug, mut unwind_context) =\n+    let (global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context, false);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n \n     let codegen_result = emit_module(\n         tcx,\n@@ -186,13 +150,6 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n         module,\n         debug,\n         unwind_context,\n-        |mut product| {\n-            if let Some(func_id) = init_atomics_mutex_from_constructor {\n-                product.add_constructor(func_id);\n-            }\n-\n-            product\n-        },\n     );\n \n     codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n@@ -202,6 +159,7 @@ fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodege\n \n pub(super) fn run_aot(\n     tcx: TyCtxt<'_>,\n+    backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n ) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n@@ -225,9 +183,7 @@ pub(super) fn run_aot(\n         cgus.iter()\n             .map(|cgu| {\n                 let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n-                tcx.sess\n-                    .cgu_reuse_tracker\n-                    .set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+                tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n                     _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n@@ -242,7 +198,7 @@ pub(super) fn run_aot(\n                 let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n                     dep_node,\n                     tcx,\n-                    cgu.name(),\n+                    (backend_config, cgu.name()),\n                     module_codegen,\n                     rustc_middle::dep_graph::hash_result,\n                 );\n@@ -271,7 +227,6 @@ pub(super) fn run_aot(\n             allocator_module,\n             None,\n             allocator_unwind_context,\n-            |product| product,\n         );\n         if let Some((id, product)) = work_product {\n             work_products.insert(id, product);\n@@ -301,8 +256,7 @@ pub(super) fn run_aot(\n             });\n \n             if let Err(err) = std::fs::write(&tmp_file, obj) {\n-                tcx.sess\n-                    .fatal(&format!(\"error writing metadata object file: {}\", err));\n+                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n             }\n \n             (metadata_cgu_name, tmp_file)\n@@ -356,8 +310,7 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n                 \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\",\n             );\n         } else {\n-            tcx.sess\n-                .fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n+            tcx.sess.fatal(\"asm! and global_asm! are not yet supported on macOS and Windows\");\n         }\n     }\n \n@@ -367,19 +320,12 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n     // Remove all LLVM style comments\n     let global_asm = global_asm\n         .lines()\n-        .map(|line| {\n-            if let Some(index) = line.find(\"//\") {\n-                &line[0..index]\n-            } else {\n-                line\n-            }\n-        })\n+        .map(|line| if let Some(index) = line.find(\"//\") { &line[0..index] } else { line })\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n \n-    let output_object_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .temp_path(OutputType::Object, Some(cgu_name));\n+    let output_object_file =\n+        tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(cgu_name));\n \n     // Assemble `global_asm`\n     let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n@@ -389,16 +335,10 @@ fn codegen_global_asm(tcx: TyCtxt<'_>, cgu_name: &str, global_asm: &str) {\n         .stdin(Stdio::piped())\n         .spawn()\n         .expect(\"Failed to spawn `as`.\");\n-    child\n-        .stdin\n-        .take()\n-        .unwrap()\n-        .write_all(global_asm.as_bytes())\n-        .unwrap();\n+    child.stdin.take().unwrap().write_all(global_asm.as_bytes()).unwrap();\n     let status = child.wait().expect(\"Failed to wait for `as`.\");\n     if !status.success() {\n-        tcx.sess\n-            .fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n+        tcx.sess.fatal(&format!(\"Failed to assemble `{}`\", global_asm));\n     }\n \n     // Link the global asm and main object file together\n@@ -442,11 +382,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n     }\n \n     let work_product_id = &cgu.work_product_id();\n-    if tcx\n-        .dep_graph\n-        .previous_work_product(work_product_id)\n-        .is_none()\n-    {\n+    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n         // We don't have anything cached for this CGU. This can happen\n         // if the CGU did not exist in the previous session.\n         return CguReuse::No;\n@@ -465,9 +401,5 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n-        CguReuse::PreLto\n-    } else {\n-        CguReuse::No\n-    }\n+    if tcx.try_mark_green(&dep_node) { CguReuse::PreLto } else { CguReuse::No }\n }"}, {"sha": "245df03ffb84de600b7d127369f0e8b602ca9824", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 48, "deletions": 78, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -10,43 +10,24 @@ use rustc_middle::mir::mono::MonoItem;\n \n use cranelift_jit::{JITBuilder, JITModule};\n \n-use crate::prelude::*;\n+use crate::{prelude::*, BackendConfig};\n use crate::{CodegenCx, CodegenMode};\n \n thread_local! {\n+    pub static BACKEND_CONFIG: RefCell<Option<BackendConfig>> = RefCell::new(None);\n     pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n }\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n+pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n \n-    #[cfg(unix)]\n-    unsafe {\n-        // When not using our custom driver rustc will open us without the RTLD_GLOBAL flag, so\n-        // __cg_clif_global_atomic_mutex will not be exported. We fix this by opening ourself again\n-        // as global.\n-        // FIXME remove once atomic_shim is gone\n-\n-        let mut dl_info: libc::Dl_info = std::mem::zeroed();\n-        assert_ne!(\n-            libc::dladdr(run_jit as *const libc::c_void, &mut dl_info),\n-            0\n-        );\n-        assert_ne!(\n-            libc::dlopen(dl_info.dli_fname, libc::RTLD_NOW | libc::RTLD_GLOBAL),\n-            std::ptr::null_mut(),\n-        );\n-    }\n-\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder = JITBuilder::with_isa(\n-        crate::build_isa(tcx.sess),\n-        cranelift_module::default_libcall_names(),\n-    );\n-    jit_builder.hotswap(matches!(codegen_mode, CodegenMode::JitLazy));\n+    let mut jit_builder =\n+        JITBuilder::with_isa(crate::build_isa(tcx.sess), cranelift_module::default_libcall_names());\n+    jit_builder.hotswap(matches!(backend_config.codegen_mode, CodegenMode::JitLazy));\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n     assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n@@ -56,14 +37,10 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n             AbiParam::new(jit_module.target_config().pointer_type()),\n             AbiParam::new(jit_module.target_config().pointer_type()),\n         ],\n-        returns: vec![AbiParam::new(\n-            jit_module.target_config().pointer_type(), /*isize*/\n-        )],\n+        returns: vec![AbiParam::new(jit_module.target_config().pointer_type() /*isize*/)],\n         call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n     };\n-    let main_func_id = jit_module\n-        .declare_function(\"main\", Linkage::Import, &sig)\n-        .unwrap();\n+    let main_func_id = jit_module.declare_function(\"main\", Linkage::Import, &sig).unwrap();\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     let mono_items = cgus\n@@ -74,43 +51,42 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+    let mut cx = crate::CodegenCx::new(tcx, backend_config, &mut jit_module, false);\n \n     super::time(tcx, \"codegen mono items\", || {\n         super::predefine_mono_items(&mut cx, &mono_items);\n         for (mono_item, (linkage, visibility)) in mono_items {\n             let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n             match mono_item {\n-                MonoItem::Fn(inst) => match codegen_mode {\n+                MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || {\n-                            crate::base::codegen_fn(&mut cx, inst, linkage)\n-                        });\n+                        cx.tcx\n+                            .sess\n+                            .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst, linkage));\n                     }\n                     CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n                 },\n                 MonoItem::Static(def_id) => {\n                     crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n                 }\n-                MonoItem::GlobalAsm(hir_id) => {\n-                    let item = cx.tcx.hir().expect_item(hir_id);\n-                    tcx.sess\n-                        .span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n+                MonoItem::GlobalAsm(item_id) => {\n+                    let item = cx.tcx.hir().item(item_id);\n+                    tcx.sess.span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n                 }\n             }\n         }\n     });\n \n-    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+    let (global_asm, _debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n     jit_module.finalize_definitions();\n \n     if !global_asm.is_empty() {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n     tcx.sess.abort_if_errors();\n@@ -121,7 +97,9 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n \n     let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n \n-    println!(\"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\");\n+    println!(\n+        \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n+    );\n \n     let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n         unsafe { ::std::mem::transmute(finalized_main) };\n@@ -137,6 +115,9 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n+    BACKEND_CONFIG.with(|tls_backend_config| {\n+        assert!(tls_backend_config.borrow_mut().replace(backend_config).is_none())\n+    });\n     CURRENT_MODULE\n         .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n \n@@ -154,21 +135,19 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n         CURRENT_MODULE.with(|jit_module| {\n             let mut jit_module = jit_module.borrow_mut();\n             let jit_module = jit_module.as_mut().unwrap();\n-            let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+            let backend_config =\n+                BACKEND_CONFIG.with(|backend_config| backend_config.borrow().clone().unwrap());\n \n             let name = tcx.symbol_name(instance).name.to_string();\n-            let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), instance);\n-            let func_id = cx\n-                .module\n-                .declare_function(&name, Linkage::Export, &sig)\n-                .unwrap();\n-            cx.module.prepare_for_function_redefine(func_id).unwrap();\n-\n-            tcx.sess.time(\"codegen fn\", || {\n-                crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n-            });\n-\n-            let (jit_module, global_asm, _debug_context, unwind_context) = cx.finalize();\n+            let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n+            let func_id = jit_module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+            jit_module.prepare_for_function_redefine(func_id).unwrap();\n+\n+            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n+            tcx.sess\n+                .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance, Linkage::Export));\n+\n+            let (global_asm, _debug_context, unwind_context) = cx.finalize();\n             assert!(global_asm.is_empty());\n             jit_module.finalize_definitions();\n             std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n@@ -195,9 +174,8 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n                 let name = tcx.crate_name(cnum);\n-                let mut err = tcx\n-                    .sess\n-                    .struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n+                let mut err =\n+                    tcx.sess.struct_err(&format!(\"Can't load static lib {}\", name.as_str()));\n                 err.note(\"rustc_codegen_cranelift can only load dylibs in JIT mode.\");\n                 err.emit();\n             }\n@@ -218,6 +196,11 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n             if name.is_empty() || !symbol.is_global() || symbol.is_undefined() {\n                 return None;\n             }\n+            if name.starts_with(\"rust_metadata_\") {\n+                // The metadata is part of a section that is not loaded by the dynamic linker in\n+                // case of cg_llvm.\n+                return None;\n+            }\n             let dlsym_name = if cfg!(target_os = \"macos\") {\n                 // On macOS `dlsym` expects the name without leading `_`.\n                 assert!(name.starts_with('_'), \"{:?}\", name);\n@@ -237,17 +220,14 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: Instance<'tcx>) {\n+pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n     let pointer_type = cx.module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name.to_string();\n     let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n-    let func_id = cx\n-        .module\n-        .declare_function(&name, Linkage::Export, &sig)\n-        .unwrap();\n+    let func_id = cx.module.declare_function(&name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));\n \n@@ -268,28 +248,18 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: In\n     let mut builder_ctx = FunctionBuilderContext::new();\n     let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n \n-    let jit_fn = cx\n-        .module\n-        .declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let jit_fn = cx.module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n     let entry_block = trampoline_builder.create_block();\n     trampoline_builder.append_block_params_for_function_params(entry_block);\n-    let fn_args = trampoline_builder\n-        .func\n-        .dfg\n-        .block_params(entry_block)\n-        .to_vec();\n+    let fn_args = trampoline_builder.func.dfg.block_params(entry_block).to_vec();\n \n     trampoline_builder.switch_to_block(entry_block);\n-    let instance_ptr = trampoline_builder\n-        .ins()\n-        .iconst(pointer_type, instance_ptr as u64 as i64);\n+    let instance_ptr = trampoline_builder.ins().iconst(pointer_type, instance_ptr as u64 as i64);\n     let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n     let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n-    let call_inst = trampoline_builder\n-        .ins()\n-        .call_indirect(sig_ref, jitted_fn, &fn_args);\n+    let call_inst = trampoline_builder.ins().call_indirect(sig_ref, jitted_fn, &fn_args);\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n "}, {"sha": "b994f28ffef5b39fe832355a3d4ac570d96b9601", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -17,33 +17,30 @@ pub(crate) fn codegen_crate(\n     tcx: TyCtxt<'_>,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-    config: crate::BackendConfig,\n+    backend_config: crate::BackendConfig,\n ) -> Box<dyn Any> {\n     tcx.sess.abort_if_errors();\n \n-    match config.codegen_mode {\n-        CodegenMode::Aot => aot::run_aot(tcx, metadata, need_metadata_module),\n+    match backend_config.codegen_mode {\n+        CodegenMode::Aot => aot::run_aot(tcx, backend_config, metadata, need_metadata_module),\n         CodegenMode::Jit | CodegenMode::JitLazy => {\n-            let is_executable = tcx\n-                .sess\n-                .crate_types()\n-                .contains(&rustc_session::config::CrateType::Executable);\n+            let is_executable =\n+                tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable);\n             if !is_executable {\n                 tcx.sess.fatal(\"can't jit non-executable crate\");\n             }\n \n             #[cfg(feature = \"jit\")]\n-            let _: ! = jit::run_jit(tcx, config.codegen_mode);\n+            let _: ! = jit::run_jit(tcx, backend_config);\n \n             #[cfg(not(feature = \"jit\"))]\n-            tcx.sess\n-                .fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n         }\n     }\n }\n \n fn predefine_mono_items<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    cx: &mut crate::CodegenCx<'_, 'tcx>,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n     cx.tcx.sess.time(\"predefine functions\", || {\n@@ -63,21 +60,12 @@ fn predefine_mono_items<'tcx>(\n }\n \n fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\")\n-        .as_ref()\n-        .map(|val| &**val)\n-        == Ok(\"1\")\n-    {\n+    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").as_ref().map(|val| &**val) == Ok(\"1\") {\n         println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n         let before = std::time::Instant::now();\n         let res = tcx.sess.time(name, f);\n         let after = std::time::Instant::now();\n-        println!(\n-            \"[{:<30}: {}] end time: {:?}\",\n-            tcx.crate_name(LOCAL_CRATE),\n-            name,\n-            after - before\n-        );\n+        println!(\"[{:<30}: {}] end time: {:?}\", tcx.crate_name(LOCAL_CRATE), name, after - before);\n         res\n     } else {\n         tcx.sess.time(name, f)"}, {"sha": "5b3df2bd382808c908a94907c90dbbc8d3737139", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 13, "deletions": 44, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::InlineAsmOperand;\n use rustc_target::asm::*;\n \n pub(crate) fn codegen_inline_asm<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     _span: Span,\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n@@ -53,11 +53,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     crate::base::codegen_operand(fx, value).load_scalar(fx),\n                 ));\n             }\n-            InlineAsmOperand::Out {\n-                reg,\n-                late: _,\n-                place,\n-            } => {\n+            InlineAsmOperand::Out { reg, late: _, place } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 if let Some(place) = place {\n@@ -68,12 +64,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     ));\n                 }\n             }\n-            InlineAsmOperand::InOut {\n-                reg,\n-                late: _,\n-                ref in_value,\n-                out_place,\n-            } => {\n+            InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n                 let reg = expect_reg(reg);\n                 clobbered_regs.push((reg, new_slot(reg.reg_class())));\n                 inputs.push((\n@@ -97,11 +88,8 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n \n     let inline_asm_index = fx.inline_asm_index;\n     fx.inline_asm_index += 1;\n-    let asm_name = format!(\n-        \"{}__inline_asm_{}\",\n-        fx.tcx.symbol_name(fx.instance).name,\n-        inline_asm_index\n-    );\n+    let asm_name =\n+        format!(\"{}__inline_asm_{}\", fx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n \n     let generated_asm = generate_asm_wrapper(\n         &asm_name,\n@@ -129,12 +117,7 @@ fn generate_asm_wrapper(\n     let mut generated_asm = String::new();\n     writeln!(generated_asm, \".globl {}\", asm_name).unwrap();\n     writeln!(generated_asm, \".type {},@function\", asm_name).unwrap();\n-    writeln!(\n-        generated_asm,\n-        \".section .text.{},\\\"ax\\\",@progbits\",\n-        asm_name\n-    )\n-    .unwrap();\n+    writeln!(generated_asm, \".section .text.{},\\\"ax\\\",@progbits\", asm_name).unwrap();\n     writeln!(generated_asm, \"{}:\", asm_name).unwrap();\n \n     generated_asm.push_str(\".intel_syntax noprefix\\n\");\n@@ -164,11 +147,7 @@ fn generate_asm_wrapper(\n             InlineAsmTemplatePiece::String(s) => {\n                 generated_asm.push_str(s);\n             }\n-            InlineAsmTemplatePiece::Placeholder {\n-                operand_idx: _,\n-                modifier: _,\n-                span: _,\n-            } => todo!(),\n+            InlineAsmTemplatePiece::Placeholder { operand_idx: _, modifier: _, span: _ } => todo!(),\n         }\n     }\n     generated_asm.push('\\n');\n@@ -203,7 +182,7 @@ fn generate_asm_wrapper(\n }\n \n fn call_inline_asm<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     asm_name: &str,\n     slot_size: Size,\n     inputs: Vec<(InlineAsmReg, Size, Value)>,\n@@ -230,28 +209,20 @@ fn call_inline_asm<'tcx>(\n             },\n         )\n         .unwrap();\n-    let inline_asm_func = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(inline_asm_func, asm_name);\n \n     for (_reg, offset, value) in inputs {\n-        fx.bcx\n-            .ins()\n-            .stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());\n     }\n \n     let stack_slot_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n     fx.bcx.ins().call(inline_asm_func, &[stack_slot_addr]);\n \n     for (_reg, offset, place) in outputs {\n         let ty = fx.clif_type(place.layout().ty).unwrap();\n-        let value = fx\n-            .bcx\n-            .ins()\n-            .stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n+        let value = fx.bcx.ins().stack_load(ty, stack_slot, i32::try_from(offset.bytes()).unwrap());\n         place.write_cvalue(fx, CValue::by_val(value, place.layout()));\n     }\n }\n@@ -267,8 +238,7 @@ fn save_register(generated_asm: &mut String, arch: InlineAsmArch, reg: InlineAsm\n     match arch {\n         InlineAsmArch::X86_64 => {\n             write!(generated_asm, \"    mov [rbp+0x{:x}], \", offset.bytes()).unwrap();\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n-                .unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n             generated_asm.push('\\n');\n         }\n         _ => unimplemented!(\"save_register for {:?}\", arch),\n@@ -284,8 +254,7 @@ fn restore_register(\n     match arch {\n         InlineAsmArch::X86_64 => {\n             generated_asm.push_str(\"    mov \");\n-            reg.emit(generated_asm, InlineAsmArch::X86_64, None)\n-                .unwrap();\n+            reg.emit(generated_asm, InlineAsmArch::X86_64, None).unwrap();\n             writeln!(generated_asm, \", [rbp+0x{:x}]\", offset.bytes()).unwrap();\n         }\n         _ => unimplemented!(\"restore_register for {:?}\", arch),"}, {"sha": "b27b0eddfbad6f6d4ad4e763fc37249dced899bc", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -6,7 +6,7 @@ use crate::prelude::*;\n ///\n /// This emulates an intel cpu with sse and sse2 support, but which doesn't support anything else.\n pub(crate) fn codegen_cpuid_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     leaf: Value,\n     _subleaf: Value,\n ) -> (Value, Value, Value, Value) {\n@@ -31,54 +31,28 @@ pub(crate) fn codegen_cpuid_call<'tcx>(\n \n     fx.bcx.switch_to_block(leaf_0);\n     let max_basic_leaf = fx.bcx.ins().iconst(types::I32, 1);\n-    let vend0 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n-    let vend2 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n-    let vend1 = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n+    let vend0 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"Genu\")));\n+    let vend2 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ineI\")));\n+    let vend1 = fx.bcx.ins().iconst(types::I32, i64::from(u32::from_le_bytes(*b\"ntel\")));\n+    fx.bcx.ins().jump(dest, &[max_basic_leaf, vend0, vend1, vend2]);\n \n     fx.bcx.switch_to_block(leaf_1);\n     let cpu_signature = fx.bcx.ins().iconst(types::I32, 0);\n     let additional_information = fx.bcx.ins().iconst(types::I32, 0);\n     let ecx_features = fx.bcx.ins().iconst(types::I32, 0);\n-    let edx_features = fx\n-        .bcx\n-        .ins()\n-        .iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n-    fx.bcx.ins().jump(\n-        dest,\n-        &[\n-            cpu_signature,\n-            additional_information,\n-            ecx_features,\n-            edx_features,\n-        ],\n-    );\n+    let edx_features = fx.bcx.ins().iconst(types::I32, 1 << 25 /* sse */ | 1 << 26 /* sse2 */);\n+    fx.bcx.ins().jump(dest, &[cpu_signature, additional_information, ecx_features, edx_features]);\n \n     fx.bcx.switch_to_block(leaf_8000_0000);\n     let extended_max_basic_leaf = fx.bcx.ins().iconst(types::I32, 0);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n+    fx.bcx.ins().jump(dest, &[extended_max_basic_leaf, zero, zero, zero]);\n \n     fx.bcx.switch_to_block(leaf_8000_0001);\n     let zero = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_ecx = fx.bcx.ins().iconst(types::I32, 0);\n     let proc_info_edx = fx.bcx.ins().iconst(types::I32, 0);\n-    fx.bcx\n-        .ins()\n-        .jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n+    fx.bcx.ins().jump(dest, &[zero, zero, proc_info_ecx, proc_info_edx]);\n \n     fx.bcx.switch_to_block(unsupported_leaf);\n     crate::trap::trap_unreachable("}, {"sha": "0692da397eb9465c2e44c1f70173bfe7c28e82bf", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -6,7 +6,7 @@ use crate::prelude::*;\n use rustc_middle::ty::subst::SubstsRef;\n \n pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     intrinsic: &str,\n     substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],"}, {"sha": "39e047a98f9eb660d25054e898ac824d959ba6ad", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 141, "deletions": 135, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,6 +9,7 @@ pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use crate::prelude::*;\n+use cranelift_codegen::ir::AtomicRmwOp;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n macro intrinsic_pat {\n@@ -112,38 +113,6 @@ macro call_intrinsic_match {\n     }\n }\n \n-macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-    let new = $fx.bcx.ins().$op(old, $src);\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-    $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n-macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    // Read old\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-\n-    // Compare\n-    let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n-    let new = $fx.bcx.ins().select(is_eq, old, $src);\n-\n-    // Write new\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-\n-    let ret_val = CValue::by_val(old, $ret.layout());\n-    $ret.write_cvalue($fx, ret_val);\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     match $ty.kind() {\n         ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n@@ -184,12 +153,12 @@ pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx\n     }\n }\n \n-fn simd_for_each_lane<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_for_each_lane<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(\n-        &mut FunctionCx<'_, 'tcx, M>,\n+        &mut FunctionCx<'_, '_, 'tcx>,\n         TyAndLayout<'tcx>,\n         TyAndLayout<'tcx>,\n         Value,\n@@ -213,13 +182,13 @@ fn simd_for_each_lane<'tcx, M: Module>(\n     }\n }\n \n-fn simd_pair_for_each_lane<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_pair_for_each_lane<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     x: CValue<'tcx>,\n     y: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(\n-        &mut FunctionCx<'_, 'tcx, M>,\n+        &mut FunctionCx<'_, '_, 'tcx>,\n         TyAndLayout<'tcx>,\n         TyAndLayout<'tcx>,\n         Value,\n@@ -246,42 +215,40 @@ fn simd_pair_for_each_lane<'tcx, M: Module>(\n     }\n }\n \n-fn simd_reduce<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_reduce<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, TyAndLayout<'tcx>, Value, Value) -> Value,\n+    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     let lane_layout = fx.layout_of(lane_ty);\n     assert_eq!(lane_layout, ret.layout());\n \n     let mut res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     for lane_idx in 1..lane_count {\n-        let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n-            .load_scalar(fx);\n+        let lane =\n+            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n         res_val = f(fx, lane_layout, res_val, lane);\n     }\n     let res = CValue::by_val(res_val, lane_layout);\n     ret.write_cvalue(fx, res);\n }\n \n-fn simd_reduce_bool<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_reduce_bool<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, Value, Value) -> Value,\n+    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n \n     let res_val = val.value_field(fx, mir::Field::new(0)).load_scalar(fx);\n     let mut res_val = fx.bcx.ins().band_imm(res_val, 1); // mask to boolean\n     for lane_idx in 1..lane_count {\n-        let lane = val\n-            .value_field(fx, mir::Field::new(lane_idx.try_into().unwrap()))\n-            .load_scalar(fx);\n+        let lane =\n+            val.value_field(fx, mir::Field::new(lane_idx.try_into().unwrap())).load_scalar(fx);\n         let lane = fx.bcx.ins().band_imm(lane, 1); // mask to boolean\n         res_val = f(fx, res_val, lane);\n     }\n@@ -290,7 +257,7 @@ fn simd_reduce_bool<'tcx, M: Module>(\n }\n \n fn bool_to_zero_or_max_uint<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     val: Value,\n ) -> CValue<'tcx> {\n@@ -424,7 +391,7 @@ macro simd_flt_binop($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n }\n \n pub(crate) fn codegen_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n@@ -912,136 +879,175 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         _ if intrinsic.starts_with(\"atomic_fence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().fence();\n         };\n         _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            // FIXME use a compiler fence once Cranelift supports it\n+            fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_load\"), <T> (v ptr) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+            let ty = fx.clif_type(T).unwrap();\n \n-            let inner_layout =\n-                fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            validate_atomic_type!(fx, intrinsic, span, inner_layout.ty);\n-            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n-            ret.write_cvalue(fx, val);\n+            let val = fx.bcx.ins().atomic_load(ty, MemFlags::trusted(), ptr);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let val = CValue::by_val(val, fx.layout_of(T));\n+            ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n             validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n-            dest.write_cvalue(fx, val);\n+            let val = val.load_scalar(fx);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n-\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_xchg\"), (v ptr, c new) {\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let new = new.load_scalar(fx);\n \n-            // Write new\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), src.layout());\n-            dest.write_cvalue(fx, src);\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xchg, ptr, new);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n \n             let test_old = test_old.load_scalar(fx);\n             let new = new.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-\n-            // Compare\n+            let old = fx.bcx.ins().atomic_cas(MemFlags::trusted(), ptr, test_old, new);\n             let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n-            let new = fx.bcx.ins().select(is_eq, new, old); // Keep old if not equal to test_old\n-\n-            // Write new\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n \n             let ret_val = CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n-            ret.write_cvalue(fx, ret_val);\n-\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            ret.write_cvalue(fx, ret_val)\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Add, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Sub, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_and\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::And, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_or\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            let and = fx.bcx.ins().band(old, src);\n-            let new = fx.bcx.ins().bnot(and);\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Or, ptr, src);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xor\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xor, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+\n+        // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n+        _ if intrinsic.starts_with(\"atomic_nand\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Nand, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n+        _ if intrinsic.starts_with(\"atomic_max\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umax\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_min\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umin\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n \n         minnumf32, (v a, v b) {"}, {"sha": "1f8eeb1e714913c072e2c303594501d33011bc4a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -4,7 +4,7 @@ use super::*;\n use crate::prelude::*;\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,"}, {"sha": "8edb883ccb5f9c7469241695cb2c870fb8db686f", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -5,15 +5,13 @@\n     associated_type_bounds,\n     never_type,\n     try_blocks,\n-    hash_drain_filter,\n-    str_split_once\n+    box_patterns,\n+    hash_drain_filter\n )]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n-#[cfg(feature = \"jit\")]\n-extern crate libc;\n extern crate snap;\n #[macro_use]\n extern crate rustc_middle;\n@@ -54,7 +52,6 @@ mod abi;\n mod allocator;\n mod analyze;\n mod archive;\n-mod atomic_shim;\n mod backend;\n mod base;\n mod cast;\n@@ -130,9 +127,9 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n     }\n }\n \n-struct CodegenCx<'tcx, M: Module> {\n+struct CodegenCx<'m, 'tcx: 'm> {\n     tcx: TyCtxt<'tcx>,\n-    module: M,\n+    module: &'m mut dyn Module,\n     global_asm: String,\n     constants_cx: ConstantCx,\n     cached_context: Context,\n@@ -141,14 +138,20 @@ struct CodegenCx<'tcx, M: Module> {\n     unwind_context: UnwindContext<'tcx>,\n }\n \n-impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n-    fn new(tcx: TyCtxt<'tcx>, module: M, debug_info: bool, pic_eh_frame: bool) -> Self {\n-        let unwind_context = UnwindContext::new(tcx, module.isa(), pic_eh_frame);\n-        let debug_context = if debug_info {\n-            Some(DebugContext::new(tcx, module.isa()))\n-        } else {\n-            None\n-        };\n+impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        backend_config: BackendConfig,\n+        module: &'m mut dyn Module,\n+        debug_info: bool,\n+    ) -> Self {\n+        let unwind_context = UnwindContext::new(\n+            tcx,\n+            module.isa(),\n+            matches!(backend_config.codegen_mode, CodegenMode::Aot),\n+        );\n+        let debug_context =\n+            if debug_info { Some(DebugContext::new(tcx, module.isa())) } else { None };\n         CodegenCx {\n             tcx,\n             module,\n@@ -161,14 +164,9 @@ impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n         }\n     }\n \n-    fn finalize(mut self) -> (M, String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n-        self.constants_cx.finalize(self.tcx, &mut self.module);\n-        (\n-            self.module,\n-            self.global_asm,\n-            self.debug_context,\n-            self.unwind_context,\n-        )\n+    fn finalize(self) -> (String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n+        self.constants_cx.finalize(self.tcx, self.module);\n+        (self.global_asm, self.debug_context, self.unwind_context)\n     }\n }\n \n@@ -303,14 +301,7 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     flags_builder\n-        .set(\n-            \"enable_verifier\",\n-            if cfg!(debug_assertions) {\n-                \"true\"\n-            } else {\n-                \"false\"\n-            },\n-        )\n+        .set(\"enable_verifier\", if cfg!(debug_assertions) { \"true\" } else { \"false\" })\n         .unwrap();\n \n     let tls_model = match target_triple.binary_format {\n@@ -339,11 +330,7 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n \n     let flags = settings::Flags::new(flags_builder);\n \n-    let variant = if cfg!(feature = \"oldbe\") {\n-        cranelift_codegen::isa::BackendVariant::Legacy\n-    } else {\n-        cranelift_codegen::isa::BackendVariant::MachInst\n-    };\n+    let variant = cranelift_codegen::isa::BackendVariant::MachInst;\n     let mut isa_builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n     // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n     // is interpreted as `bsr`."}, {"sha": "62e551b186ff7c8cb96350eb8e4977496dce9193", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,7 +9,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext<'_>,\n-    use_jit: bool,\n ) {\n     let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, entry_ty)) => (\n@@ -27,22 +26,14 @@ pub(crate) fn maybe_create_entry_wrapper(\n         return;\n     }\n \n-    create_entry_fn(\n-        tcx,\n-        module,\n-        unwind_context,\n-        main_def_id,\n-        use_start_lang_item,\n-        use_jit,\n-    );\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, use_start_lang_item);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n         m: &mut impl Module,\n         unwind_context: &mut UnwindContext<'_>,\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n-        use_jit: bool,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -57,23 +48,17 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 AbiParam::new(m.target_config().pointer_type()),\n                 AbiParam::new(m.target_config().pointer_type()),\n             ],\n-            returns: vec![AbiParam::new(\n-                m.target_config().pointer_type(), /*isize*/\n-            )],\n+            returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n             call_conv: CallConv::triple_default(m.isa().triple()),\n         };\n \n-        let cmain_func_id = m\n-            .declare_function(\"main\", Linkage::Export, &cmain_sig)\n-            .unwrap();\n+        let cmain_func_id = m.declare_function(\"main\", Linkage::Export, &cmain_sig).unwrap();\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n         let main_name = tcx.symbol_name(instance).name.to_string();\n         let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n-        let main_func_id = m\n-            .declare_function(&main_name, Linkage::Import, &main_sig)\n-            .unwrap();\n+        let main_func_id = m.declare_function(&main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig);\n@@ -86,8 +71,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n             let arg_argc = bcx.append_block_param(block, m.target_config().pointer_type());\n             let arg_argv = bcx.append_block_param(block, m.target_config().pointer_type());\n \n-            crate::atomic_shim::init_global_lock(m, &mut bcx, use_jit);\n-\n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n             let call_inst = if use_start_lang_item {\n@@ -103,9 +86,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 .polymorphize(tcx);\n                 let start_func_id = import_function(tcx, m, start_instance);\n \n-                let main_val = bcx\n-                    .ins()\n-                    .func_addr(m.target_config().pointer_type(), main_func_ref);\n+                let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n                 bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])"}, {"sha": "190c4f45ccafdefe6ca1f55662e57c4fddc39a3b", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -94,9 +94,7 @@ pub(crate) fn write_metadata<P: WriteMetadata>(\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n-    FrameEncoder::new(&mut compressed)\n-        .write_all(&metadata.raw_data)\n-        .unwrap();\n+    FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n     product.add_rustc_section(\n         rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx),"}, {"sha": "da49e1c6c91dbacaa5df5900ed8abe5fa8f59a8a", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -41,7 +41,7 @@ pub(crate) fn bin_op_to_intcc(bin_op: BinOp, signed: bool) -> Option<IntCC> {\n }\n \n fn codegen_compare_bin_op<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     signed: bool,\n     lhs: Value,\n@@ -54,7 +54,7 @@ fn codegen_compare_bin_op<'tcx>(\n }\n \n pub(crate) fn codegen_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -93,17 +93,12 @@ pub(crate) fn codegen_binop<'tcx>(\n         ty::Uint(_) | ty::Int(_) => crate::num::codegen_int_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::Float(_) => crate::num::codegen_float_binop(fx, bin_op, in_lhs, in_rhs),\n         ty::RawPtr(..) | ty::FnPtr(..) => crate::num::codegen_ptr_binop(fx, bin_op, in_lhs, in_rhs),\n-        _ => unreachable!(\n-            \"{:?}({:?}, {:?})\",\n-            bin_op,\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty\n-        ),\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     }\n }\n \n pub(crate) fn codegen_bool_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -124,7 +119,7 @@ pub(crate) fn codegen_bool_binop<'tcx>(\n }\n \n pub(crate) fn codegen_int_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -185,19 +180,14 @@ pub(crate) fn codegen_int_binop<'tcx>(\n             }\n         }\n         // Compare binops handles by `codegen_binop`.\n-        _ => unreachable!(\n-            \"{:?}({:?}, {:?})\",\n-            bin_op,\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty\n-        ),\n+        _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs.layout().ty, in_rhs.layout().ty),\n     };\n \n     CValue::by_val(val, in_lhs.layout())\n }\n \n pub(crate) fn codegen_checked_int_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -268,9 +258,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                     let rhs = fx.bcx.ins().sextend(ty.double_width().unwrap(), rhs);\n                     let val = fx.bcx.ins().imul(lhs, rhs);\n                     let has_underflow =\n-                        fx.bcx\n-                            .ins()\n-                            .icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n+                        fx.bcx.ins().icmp_imm(IntCC::SignedLessThan, val, -(1 << (ty.bits() - 1)));\n                     let has_overflow = fx.bcx.ins().icmp_imm(\n                         IntCC::SignedGreaterThan,\n                         val,\n@@ -309,10 +297,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             let val = fx.bcx.ins().ishl(lhs, actual_shift);\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx\n-                .bcx\n-                .ins()\n-                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         BinOp::Shr => {\n@@ -326,38 +311,20 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             };\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx\n-                .bcx\n-                .ins()\n-                .icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n+            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n-        _ => bug!(\n-            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n-            bin_op,\n-            in_lhs,\n-            in_rhs\n-        ),\n+        _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n     let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n \n-    // FIXME directly write to result place instead\n-    let out_place = CPlace::new_stack_slot(\n-        fx,\n-        fx.layout_of(\n-            fx.tcx\n-                .mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()),\n-        ),\n-    );\n-    let out_layout = out_place.layout();\n-    out_place.write_cvalue(fx, CValue::by_val_pair(res, has_overflow, out_layout));\n-\n-    out_place.to_cvalue(fx)\n+    let out_layout = fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n+    CValue::by_val_pair(res, has_overflow, out_layout)\n }\n \n pub(crate) fn codegen_float_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -402,7 +369,7 @@ pub(crate) fn codegen_float_binop<'tcx>(\n }\n \n pub(crate) fn codegen_ptr_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -452,9 +419,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n                 let ptr_eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_ptr, rhs_ptr);\n \n                 let ptr_cmp =\n-                    fx.bcx\n-                        .ins()\n-                        .icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n+                    fx.bcx.ins().icmp(bin_op_to_intcc(bin_op, false).unwrap(), lhs_ptr, rhs_ptr);\n                 let extra_cmp = fx.bcx.ins().icmp(\n                     bin_op_to_intcc(bin_op, false).unwrap(),\n                     lhs_extra,\n@@ -466,9 +431,6 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        CValue::by_val(\n-            fx.bcx.ins().bint(types::I8, res),\n-            fx.layout_of(fx.tcx.types.bool),\n-        )\n+        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n     }\n }"}, {"sha": "ca9ff15ec10ffee9967d95ccf086ab0e345ba1fe", "filename": "compiler/rustc_codegen_cranelift/src/optimize/code_layout.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -15,10 +15,7 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     // bytecodealliance/cranelift#1339 is implemented.\n \n     let mut block_insts = FxHashMap::default();\n-    for block in cold_blocks\n-        .keys()\n-        .filter(|&block| cold_blocks.contains(block))\n-    {\n+    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n         let insts = ctx.func.layout.block_insts(block).collect::<Vec<_>>();\n         for &inst in &insts {\n             ctx.func.layout.remove_inst(inst);\n@@ -28,10 +25,7 @@ pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block\n     }\n \n     // And then append them at the back again.\n-    for block in cold_blocks\n-        .keys()\n-        .filter(|&block| cold_blocks.contains(block))\n-    {\n+    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n         ctx.func.layout.append_block(block);\n         for inst in block_insts.remove(&block).unwrap() {\n             ctx.func.layout.append_inst(inst, block);"}, {"sha": "389f50e797e890795c5512321eddef538e303511", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -19,7 +19,12 @@ pub(crate) fn optimize_function<'tcx>(\n     if tcx.sess.opts.optimize == rustc_session::config::OptLevel::No {\n         return; // FIXME classify optimizations over opt levels\n     }\n-    self::stack2reg::optimize_function(ctx, clif_comments);\n+\n+    // FIXME(#1142) stack2reg miscompiles lewton\n+    if false {\n+        self::stack2reg::optimize_function(ctx, clif_comments);\n+    }\n+\n     crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", None, instance, &ctx, &*clif_comments);\n     crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n }"}, {"sha": "b95e2d72877d992f35622873a25270f624d635e0", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -10,10 +10,7 @@ use cranelift_frontend::FunctionBuilder;\n pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n     if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n         match bcx.func.dfg[arg_inst] {\n-            InstructionData::Unary {\n-                opcode: Opcode::Bint,\n-                arg,\n-            } => arg,\n+            InstructionData::Unary { opcode: Opcode::Bint, arg } => arg,\n             _ => arg,\n         }\n     } else {\n@@ -54,12 +51,7 @@ pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n \n         match bcx.func.dfg[arg_inst] {\n             // This is the lowering of Rvalue::Not\n-            InstructionData::Load {\n-                opcode: Opcode::Load,\n-                arg: ptr,\n-                flags,\n-                offset,\n-            } => {\n+            InstructionData::Load { opcode: Opcode::Load, arg: ptr, flags, offset } => {\n                 // Using `load.i8 + uextend.i32` would legalize to `uload8 + ireduce.i8 +\n                 // uextend.i32`. Just `uload8` is much faster.\n                 match bcx.func.dfg.ctrl_typevar(arg_inst) {\n@@ -95,20 +87,14 @@ pub(crate) fn maybe_known_branch_taken(\n     };\n \n     match bcx.func.dfg[arg_inst] {\n-        InstructionData::UnaryBool {\n-            opcode: Opcode::Bconst,\n-            imm,\n-        } => {\n+        InstructionData::UnaryBool { opcode: Opcode::Bconst, imm } => {\n             if test_zero {\n                 Some(!imm)\n             } else {\n                 Some(imm)\n             }\n         }\n-        InstructionData::UnaryImm {\n-            opcode: Opcode::Iconst,\n-            imm,\n-        } => {\n+        InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)\n             } else {"}, {"sha": "d111f37f5e4552a3d582636e73026b07f31364ac", "filename": "compiler/rustc_codegen_cranelift/src/optimize/stack2reg.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -175,16 +175,14 @@ impl<'a> OptimizeContext<'a> {\n             }\n         }\n \n-        OptimizeContext {\n-            ctx,\n-            stack_slot_usage_map,\n-        }\n+        OptimizeContext { ctx, stack_slot_usage_map }\n     }\n }\n \n pub(super) fn optimize_function(\n     ctx: &mut Context,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] clif_comments: &mut crate::pretty_clif::CommentWriter,\n+    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n+    clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n     combine_stack_addr_with_load_store(&mut ctx.func);\n \n@@ -296,12 +294,7 @@ fn combine_stack_addr_with_load_store(func: &mut Function) {\n     while let Some(_block) = cursor.next_block() {\n         while let Some(inst) = cursor.next_inst() {\n             match cursor.func.dfg[inst] {\n-                InstructionData::Load {\n-                    opcode: Opcode::Load,\n-                    arg: addr,\n-                    flags: _,\n-                    offset,\n-                } => {\n+                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n                     if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n                         || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n                     {\n@@ -391,20 +384,14 @@ fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n         stack_slot_users\n             .stack_addr\n             .drain_filter(|inst| {\n-                stack_addr_load_insts_users\n-                    .get(inst)\n-                    .map(|users| users.is_empty())\n-                    .unwrap_or(true)\n+                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n             })\n             .for_each(|inst| StackSlotUsage::remove_unused_stack_addr(&mut func, inst));\n \n         stack_slot_users\n             .stack_load\n             .drain_filter(|inst| {\n-                stack_addr_load_insts_users\n-                    .get(inst)\n-                    .map(|users| users.is_empty())\n-                    .unwrap_or(true)\n+                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n             })\n             .for_each(|inst| StackSlotUsage::remove_unused_load(&mut func, inst));\n     }\n@@ -415,11 +402,8 @@ fn try_get_stack_slot_and_offset_for_addr(\n     addr: Value,\n ) -> Option<(StackSlot, Offset32)> {\n     if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n-        if let InstructionData::StackLoad {\n-            opcode: Opcode::StackAddr,\n-            stack_slot,\n-            offset,\n-        } = func.dfg[addr_inst]\n+        if let InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset } =\n+            func.dfg[addr_inst]\n         {\n             return Some((stack_slot, offset));\n         }\n@@ -437,16 +421,8 @@ enum SpatialOverlap {\n fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     fn inst_info(func: &Function, inst: Inst) -> (StackSlot, Offset32, u32) {\n         match func.dfg[inst] {\n-            InstructionData::StackLoad {\n-                opcode: Opcode::StackAddr,\n-                stack_slot,\n-                offset,\n-            }\n-            | InstructionData::StackLoad {\n-                opcode: Opcode::StackLoad,\n-                stack_slot,\n-                offset,\n-            }\n+            InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset }\n+            | InstructionData::StackLoad { opcode: Opcode::StackLoad, stack_slot, offset }\n             | InstructionData::StackStore {\n                 opcode: Opcode::StackStore,\n                 stack_slot,\n@@ -471,10 +447,7 @@ fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n     }\n \n     let src_end: i64 = src_offset.try_add_i64(i64::from(src_size)).unwrap().into();\n-    let dest_end: i64 = dest_offset\n-        .try_add_i64(i64::from(dest_size))\n-        .unwrap()\n-        .into();\n+    let dest_end: i64 = dest_offset.try_add_i64(i64::from(dest_size)).unwrap().into();\n     if src_end <= dest_offset.into() || dest_end <= src_offset.into() {\n         return SpatialOverlap::No;\n     }"}, {"sha": "88a78f3214d87b054efdb0281dde5d557009d6ee", "filename": "compiler/rustc_codegen_cranelift/src/pointer.rs", "status": "modified", "additions": 26, "deletions": 97, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -23,82 +23,49 @@ pub(crate) enum PointerBase {\n \n impl Pointer {\n     pub(crate) fn new(addr: Value) -> Self {\n-        Pointer {\n-            base: PointerBase::Addr(addr),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn stack_slot(stack_slot: StackSlot) -> Self {\n-        Pointer {\n-            base: PointerBase::Stack(stack_slot),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n-    pub(crate) fn const_addr<'a, 'tcx>(\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        addr: i64,\n-    ) -> Self {\n+    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n         let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer {\n-            base: PointerBase::Addr(addr),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n     }\n \n     pub(crate) fn dangling(align: Align) -> Self {\n-        Pointer {\n-            base: PointerBase::Dangling(align),\n-            offset: Offset32::new(0),\n-        }\n+        Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }\n \n     #[cfg(debug_assertions)]\n     pub(crate) fn base_and_offset(self) -> (PointerBase, Offset32) {\n         (self.base, self.offset)\n     }\n \n-    pub(crate) fn get_addr<'a, 'tcx>(self, fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> Value {\n+    pub(crate) fn get_addr(self, fx: &mut FunctionCx<'_, '_, '_>) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 let offset: i64 = self.offset.into();\n-                if offset == 0 {\n-                    base_addr\n-                } else {\n-                    fx.bcx.ins().iadd_imm(base_addr, offset)\n-                }\n+                if offset == 0 { base_addr } else { fx.bcx.ins().iadd_imm(base_addr, offset) }\n             }\n             PointerBase::Stack(stack_slot) => {\n-                fx.bcx\n-                    .ins()\n-                    .stack_addr(fx.pointer_type, stack_slot, self.offset)\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset)\n+            }\n+            PointerBase::Dangling(align) => {\n+                fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n             }\n-            PointerBase::Dangling(align) => fx\n-                .bcx\n-                .ins()\n-                .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n         }\n     }\n \n-    pub(crate) fn offset<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: Offset32,\n-    ) -> Self {\n+    pub(crate) fn offset(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: Offset32) -> Self {\n         self.offset_i64(fx, extra_offset.into())\n     }\n \n-    pub(crate) fn offset_i64<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: i64,\n-    ) -> Self {\n+    pub(crate) fn offset_i64(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: i64) -> Self {\n         if let Some(new_offset) = self.offset.try_add_i64(extra_offset) {\n-            Pointer {\n-                base: self.base,\n-                offset: new_offset,\n-            }\n+            Pointer { base: self.base, offset: new_offset }\n         } else {\n             let base_offset: i64 = self.offset.into();\n             if let Some(new_offset) = base_offset.checked_add(extra_offset) {\n@@ -107,16 +74,12 @@ impl Pointer {\n                     PointerBase::Stack(stack_slot) => {\n                         fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)\n                     }\n-                    PointerBase::Dangling(align) => fx\n-                        .bcx\n-                        .ins()\n-                        .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap()),\n+                    PointerBase::Dangling(align) => {\n+                        fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap())\n+                    }\n                 };\n                 let addr = fx.bcx.ins().iadd_imm(base_addr, new_offset);\n-                Pointer {\n-                    base: PointerBase::Addr(addr),\n-                    offset: Offset32::new(0),\n-                }\n+                Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n             } else {\n                 panic!(\n                     \"self.offset ({}) + extra_offset ({}) not representable in i64\",\n@@ -126,31 +89,22 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn offset_value<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: Value,\n-    ) -> Self {\n+    pub(crate) fn offset_value(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: Value) -> Self {\n         match self.base {\n             PointerBase::Addr(addr) => Pointer {\n                 base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n                 offset: self.offset,\n             },\n             PointerBase::Stack(stack_slot) => {\n-                let base_addr = fx\n-                    .bcx\n-                    .ins()\n-                    .stack_addr(fx.pointer_type, stack_slot, self.offset);\n+                let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, self.offset);\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(base_addr, extra_offset)),\n                     offset: Offset32::new(0),\n                 }\n             }\n             PointerBase::Dangling(align) => {\n-                let addr = fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n+                let addr =\n+                    fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(align.bytes()).unwrap());\n                 Pointer {\n                     base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n                     offset: self.offset,\n@@ -159,46 +113,21 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn load<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        ty: Type,\n-        flags: MemFlags,\n-    ) -> Value {\n+    pub(crate) fn load(self, fx: &mut FunctionCx<'_, '_, '_>, ty: Type, flags: MemFlags) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n-            PointerBase::Stack(stack_slot) => {\n-                if ty == types::I128 || ty.is_vector() {\n-                    // WORKAROUND for stack_load.i128 and stack_load.iXxY not being implemented\n-                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                    fx.bcx.ins().load(ty, flags, base_addr, self.offset)\n-                } else {\n-                    fx.bcx.ins().stack_load(ty, stack_slot, self.offset)\n-                }\n-            }\n+            PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_load(ty, stack_slot, self.offset),\n             PointerBase::Dangling(_align) => unreachable!(),\n         }\n     }\n \n-    pub(crate) fn store<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        value: Value,\n-        flags: MemFlags,\n-    ) {\n+    pub(crate) fn store(self, fx: &mut FunctionCx<'_, '_, '_>, value: Value, flags: MemFlags) {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 fx.bcx.ins().store(flags, value, base_addr, self.offset);\n             }\n             PointerBase::Stack(stack_slot) => {\n-                let val_ty = fx.bcx.func.dfg.value_type(value);\n-                if val_ty == types::I128 || val_ty.is_vector() {\n-                    // WORKAROUND for stack_store.i128 and stack_store.iXxY not being implemented\n-                    let base_addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                    fx.bcx.ins().store(flags, value, base_addr, self.offset);\n-                } else {\n-                    fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n-                }\n+                fx.bcx.ins().stack_store(value, stack_slot, self.offset);\n             }\n             PointerBase::Dangling(_align) => unreachable!(),\n         }"}, {"sha": "9c91b92e515b1b0ffc22a06fc81a4452a488db1d", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -79,20 +79,14 @@ impl CommentWriter {\n             vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n-                format!(\n-                    \"abi {:?}\",\n-                    FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])\n-                ),\n+                format!(\"abi {:?}\", FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n                 String::new(),\n             ]\n         } else {\n             vec![]\n         };\n \n-        CommentWriter {\n-            global_comments,\n-            entity_comments: FxHashMap::default(),\n-        }\n+        CommentWriter { global_comments, entity_comments: FxHashMap::default() }\n     }\n }\n \n@@ -186,7 +180,7 @@ impl FuncWriter for &'_ CommentWriter {\n }\n \n #[cfg(debug_assertions)]\n-impl<M: Module> FunctionCx<'_, '_, M> {\n+impl FunctionCx<'_, '_, '_> {\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n         self.clif_comments.add_global_comment(comment);\n     }\n@@ -201,12 +195,7 @@ impl<M: Module> FunctionCx<'_, '_, M> {\n }\n \n pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n-    cfg!(debug_assertions)\n-        || tcx\n-            .sess\n-            .opts\n-            .output_types\n-            .contains_key(&OutputType::LlvmAssembly)\n+    tcx.sess.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n }\n \n pub(crate) fn write_ir_file<'tcx>(\n@@ -245,40 +234,33 @@ pub(crate) fn write_clif_file<'tcx>(\n     context: &cranelift_codegen::Context,\n     mut clif_comments: &CommentWriter,\n ) {\n-    write_ir_file(\n-        tcx,\n-        &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n-        |file| {\n-            let value_ranges = isa.map(|isa| {\n-                context\n-                    .build_value_labels_ranges(isa)\n-                    .expect(\"value location ranges\")\n-            });\n+    write_ir_file(tcx, &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix), |file| {\n+        let value_ranges =\n+            isa.map(|isa| context.build_value_labels_ranges(isa).expect(\"value location ranges\"));\n \n-            let mut clif = String::new();\n-            cranelift_codegen::write::decorate_function(\n-                &mut clif_comments,\n-                &mut clif,\n-                &context.func,\n-                &DisplayFunctionAnnotations {\n-                    isa: Some(&*crate::build_isa(tcx.sess)),\n-                    value_ranges: value_ranges.as_ref(),\n-                },\n-            )\n-            .unwrap();\n+        let mut clif = String::new();\n+        cranelift_codegen::write::decorate_function(\n+            &mut clif_comments,\n+            &mut clif,\n+            &context.func,\n+            &DisplayFunctionAnnotations {\n+                isa: Some(&*crate::build_isa(tcx.sess)),\n+                value_ranges: value_ranges.as_ref(),\n+            },\n+        )\n+        .unwrap();\n \n-            writeln!(file, \"test compile\")?;\n-            writeln!(file, \"set is_pic\")?;\n-            writeln!(file, \"set enable_simd\")?;\n-            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n-            writeln!(file)?;\n-            file.write_all(clif.as_bytes())?;\n-            Ok(())\n-        },\n-    );\n+        writeln!(file, \"test compile\")?;\n+        writeln!(file, \"set is_pic\")?;\n+        writeln!(file, \"set enable_simd\")?;\n+        writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+        writeln!(file)?;\n+        file.write_all(clif.as_bytes())?;\n+        Ok(())\n+    });\n }\n \n-impl<M: Module> fmt::Debug for FunctionCx<'_, '_, M> {\n+impl fmt::Debug for FunctionCx<'_, '_, '_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(f, \"{:?}\", self.instance.substs)?;\n         writeln!(f, \"{:?}\", self.local_map)?;"}, {"sha": "484a9b699a0aa41aa73c412610bae16e2155d456", "filename": "compiler/rustc_codegen_cranelift/src/toolchain.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftoolchain.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -71,12 +71,9 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 flavor,\n             )),\n             (Some(linker), None) => {\n-                let stem = linker\n-                    .file_stem()\n-                    .and_then(|stem| stem.to_str())\n-                    .unwrap_or_else(|| {\n-                        sess.fatal(\"couldn't extract file stem from specified linker\")\n-                    });\n+                let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n+                    sess.fatal(\"couldn't extract file stem from specified linker\")\n+                });\n \n                 let flavor = if stem == \"emcc\" {\n                     LinkerFlavor::Em\n@@ -105,11 +102,7 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     // linker and linker flavor specified via command line have precedence over what the target\n     // specification specifies\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.opts.cg.linker.clone(),\n-        sess.opts.cg.linker_flavor,\n-    ) {\n+    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), sess.opts.cg.linker_flavor) {\n         return ret;\n     }\n "}, {"sha": "bb63d72addf9842f32c3cf1af965fb80824c7bc3", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -2,7 +2,7 @@\n \n use crate::prelude::*;\n \n-fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n+fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     let puts = fx\n         .cx\n         .module\n@@ -29,7 +29,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n }\n \n /// Trap code: user1\n-pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::User(1));\n }\n@@ -38,7 +38,7 @@ pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsR\n /// so you can **not** add instructions to it afterwards.\n ///\n /// Trap code: user65535\n-pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n@@ -47,7 +47,7 @@ pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: im\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unreachable_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {\n@@ -62,7 +62,7 @@ pub(crate) fn trap_unreachable_ret_value<'tcx>(\n /// to it afterwards.\n ///\n /// Trap code: user65535\n-pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     let true_ = fx.bcx.ins().iconst(types::I32, 1);\n     fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n@@ -72,7 +72,7 @@ pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg:\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unimplemented_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {"}, {"sha": "042583cd5720fa07b7cac71d3928a302f7d3be0b", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 25, "deletions": 50, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -13,19 +13,18 @@ use crate::prelude::*;\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n pub(crate) fn unsized_info<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n     old_info: Option<Value>,\n ) -> Value {\n     let (source, target) =\n-        fx.tcx\n-            .struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n+        fx.tcx.struct_lockstep_tails_erasing_lifetimes(source, target, ParamEnv::reveal_all());\n     match (&source.kind(), &target.kind()) {\n-        (&ty::Array(_, len), &ty::Slice(_)) => fx.bcx.ins().iconst(\n-            fx.pointer_type,\n-            len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64,\n-        ),\n+        (&ty::Array(_, len), &ty::Slice(_)) => fx\n+            .bcx\n+            .ins()\n+            .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n@@ -35,17 +34,13 @@ pub(crate) fn unsized_info<'tcx>(\n         (_, &ty::Dynamic(ref data, ..)) => {\n             crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n         }\n-        _ => bug!(\n-            \"unsized_info: invalid unsizing {:?} -> {:?}\",\n-            source,\n-            target\n-        ),\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n fn unsize_thin_ptr<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: Value,\n     src_layout: TyAndLayout<'tcx>,\n     dst_layout: TyAndLayout<'tcx>,\n@@ -89,24 +84,22 @@ fn unsize_thin_ptr<'tcx>(\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub(crate) fn coerce_unsized_into<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: CValue<'tcx>,\n     dst: CPlace<'tcx>,\n ) {\n     let src_ty = src.layout().ty;\n     let dst_ty = dst.layout().ty;\n     let mut coerce_ptr = || {\n-        let (base, info) = if fx\n-            .layout_of(src.layout().ty.builtin_deref(true).unwrap().ty)\n-            .is_unsized()\n-        {\n-            // fat-ptr to fat-ptr unsize preserves the vtable\n-            // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-            src.load_scalar_pair(fx)\n-        } else {\n-            let base = src.load_scalar(fx);\n-            unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n-        };\n+        let (base, info) =\n+            if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+                src.load_scalar_pair(fx)\n+            } else {\n+                let base = src.load_scalar(fx);\n+                unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n+            };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };\n     match (&src_ty.kind(), &dst_ty.kind()) {\n@@ -131,49 +124,34 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n                 }\n             }\n         }\n-        _ => bug!(\n-            \"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n-            src_ty,\n-            dst_ty\n-        ),\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\", src_ty, dst_ty),\n     }\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n \n pub(crate) fn size_and_align_of_dst<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     info: Value,\n ) -> (Value, Value) {\n     if !layout.is_unsized() {\n-        let size = fx\n-            .bcx\n-            .ins()\n-            .iconst(fx.pointer_type, layout.size.bytes() as i64);\n-        let align = fx\n-            .bcx\n-            .ins()\n-            .iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n+        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n+        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n         return (size, align);\n     }\n     match layout.ty.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n-            (\n-                crate::vtable::size_of_obj(fx, info),\n-                crate::vtable::min_align_of_obj(fx, info),\n-            )\n+            (crate::vtable::size_of_obj(fx, info), crate::vtable::min_align_of_obj(fx, info))\n         }\n         ty::Slice(_) | ty::Str => {\n             let unit = layout.field(fx, 0);\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             (\n                 fx.bcx.ins().imul_imm(info, unit.size.bytes() as i64),\n-                fx.bcx\n-                    .ins()\n-                    .iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n+                fx.bcx.ins().iconst(fx.pointer_type, unit.align.abi.bytes() as i64),\n             )\n         }\n         _ => {\n@@ -211,10 +189,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let cmp = fx\n-                .bcx\n-                .ins()\n-                .icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n+            let cmp = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n             let align = fx.bcx.ins().select(cmp, sized_align, unsized_align);\n \n             // Issue #27023: must add any necessary padding to `size`"}, {"sha": "cffaf79ded10b8ebfaae7e4ea0a2db31b85579ab", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 52, "deletions": 135, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -6,7 +6,7 @@ use cranelift_codegen::entity::EntityRef;\n use cranelift_codegen::ir::immediates::Offset32;\n \n fn codegen_field<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     base: Pointer,\n     extra: Option<Value>,\n     layout: TyAndLayout<'tcx>,\n@@ -15,11 +15,8 @@ fn codegen_field<'tcx>(\n     let field_offset = layout.fields.offset(field.index());\n     let field_layout = layout.field(&*fx, field.index());\n \n-    let simple = |fx: &mut FunctionCx<'_, '_, _>| {\n-        (\n-            base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()),\n-            field_layout,\n-        )\n+    let simple = |fx: &mut FunctionCx<'_, '_, '_>| {\n+        (base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()), field_layout)\n     };\n \n     if let Some(extra) = extra {\n@@ -58,10 +55,7 @@ fn scalar_pair_calculate_b_offset(\n     a_scalar: &Scalar,\n     b_scalar: &Scalar,\n ) -> Offset32 {\n-    let b_offset = a_scalar\n-        .value\n-        .size(&tcx)\n-        .align_to(b_scalar.value.align(&tcx).abi);\n+    let b_offset = a_scalar.value.size(&tcx).align_to(b_scalar.value.align(&tcx).abi);\n     Offset32::new(b_offset.bytes().try_into().unwrap())\n }\n \n@@ -106,10 +100,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    pub(crate) fn force_stack(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    ) -> (Pointer, Option<Value>) {\n+    pub(crate) fn force_stack(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> (Pointer, Option<Value>) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, meta) => (ptr, meta),\n@@ -129,7 +120,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value with layout.abi of scalar\n-    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> Value {\n+    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> Value {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n@@ -153,10 +144,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value pair with layout.abi of scalar pair\n-    pub(crate) fn load_scalar_pair(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    ) -> (Value, Value) {\n+    pub(crate) fn load_scalar_pair(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> (Value, Value) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n@@ -183,7 +171,7 @@ impl<'tcx> CValue<'tcx> {\n \n     pub(crate) fn value_field(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         field: mir::Field,\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n@@ -219,21 +207,17 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub(crate) fn unsize_value(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-        dest: CPlace<'tcx>,\n-    ) {\n+    pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub(crate) fn const_val(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n         const_val: ty::ScalarInt,\n     ) -> CValue<'tcx> {\n-        assert_eq!(const_val.size(), layout.size);\n+        assert_eq!(const_val.size(), layout.size, \"{:#?}: {:?}\", const_val, layout);\n         use cranelift_codegen::ir::immediates::{Ieee32, Ieee64};\n \n         let clif_ty = fx.clif_type(layout.ty).unwrap();\n@@ -250,18 +234,11 @@ impl<'tcx> CValue<'tcx> {\n             ty::Uint(UintTy::U128) | ty::Int(IntTy::I128) => {\n                 let const_val = const_val.to_bits(layout.size).unwrap();\n                 let lsb = fx.bcx.ins().iconst(types::I64, const_val as u64 as i64);\n-                let msb = fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(types::I64, (const_val >> 64) as u64 as i64);\n+                let msb = fx.bcx.ins().iconst(types::I64, (const_val >> 64) as u64 as i64);\n                 fx.bcx.ins().iconcat(lsb, msb)\n             }\n-            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..)\n-            | ty::RawPtr(..) => {\n-                fx\n-                    .bcx\n-                    .ins()\n-                    .iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n+            ty::Bool | ty::Char | ty::Uint(_) | ty::Int(_) | ty::Ref(..) | ty::RawPtr(..) => {\n+                fx.bcx.ins().iconst(clif_ty, const_val.to_bits(layout.size).unwrap() as i64)\n             }\n             ty::Float(FloatTy::F32) => {\n                 fx.bcx.ins().f32const(Ieee32::with_bits(u32::try_from(const_val).unwrap()))\n@@ -279,14 +256,8 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     pub(crate) fn cast_pointer_to(self, layout: TyAndLayout<'tcx>) -> Self {\n-        assert!(matches!(\n-            self.layout().ty.kind(),\n-            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n-        ));\n-        assert!(matches!(\n-            layout.ty.kind(),\n-            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)\n-        ));\n+        assert!(matches!(self.layout().ty.kind(), ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n+        assert!(matches!(layout.ty.kind(), ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..)));\n         assert_eq!(self.layout().abi, layout.abi);\n         CValue(self.0, layout)\n     }\n@@ -317,14 +288,11 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn no_place(layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None), layout }\n     }\n \n     pub(crate) fn new_stack_slot(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n         assert!(!layout.is_unsized());\n@@ -339,28 +307,22 @@ impl<'tcx> CPlace<'tcx> {\n             size: (u32::try_from(layout.size.bytes()).unwrap() + 15) / 16 * 16,\n             offset: None,\n         });\n-        CPlace {\n-            inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(Pointer::stack_slot(stack_slot), None), layout }\n     }\n \n     pub(crate) fn new_var(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n         let var = Variable::with_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n         fx.bcx.declare_var(var, fx.clif_type(layout.ty).unwrap());\n-        CPlace {\n-            inner: CPlaceInner::Var(local, var),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Var(local, var), layout }\n     }\n \n     pub(crate) fn new_var_pair(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n@@ -372,52 +334,39 @@ impl<'tcx> CPlace<'tcx> {\n         let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n         fx.bcx.declare_var(var1, ty1);\n         fx.bcx.declare_var(var2, ty2);\n-        CPlace {\n-            inner: CPlaceInner::VarPair(local, var1, var2),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::VarPair(local, var1, var2), layout }\n     }\n \n     pub(crate) fn for_ptr(ptr: Pointer, layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(ptr, None),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(ptr, None), layout }\n     }\n \n     pub(crate) fn for_ptr_with_extra(\n         ptr: Pointer,\n         extra: Value,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        CPlace {\n-            inner: CPlaceInner::Addr(ptr, Some(extra)),\n-            layout,\n-        }\n+        CPlace { inner: CPlaceInner::Addr(ptr, Some(extra)), layout }\n     }\n \n-    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CValue<'tcx> {\n+    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CValue<'tcx> {\n         let layout = self.layout();\n         match self.inner {\n             CPlaceInner::Var(_local, var) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 CValue::by_val(val, layout)\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n                 let val1 = fx.bcx.use_var(var1);\n-                fx.bcx\n-                    .set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                //fx.bcx.set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n                 let val2 = fx.bcx.use_var(var2);\n-                fx.bcx\n-                    .set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                //fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n                 CValue::by_val_pair(val1, val2, layout)\n             }\n             CPlaceInner::VarLane(_local, var, lane) => {\n                 let val = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 let val = fx.bcx.ins().extractlane(val, lane);\n                 CValue::by_val(val, layout)\n             }\n@@ -447,32 +396,28 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub(crate) fn write_cvalue(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-        from: CValue<'tcx>,\n-    ) {\n+    pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>, from: CValue<'tcx>) {\n         assert_assignable(fx, from.layout().ty, self.layout().ty);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n     }\n \n     pub(crate) fn write_cvalue_transmute(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n     ) {\n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue_transmute\");\n     }\n \n     fn write_cvalue_maybe_transmute(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n         #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n     ) {\n         fn transmute_value<'tcx>(\n-            fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+            fx: &mut FunctionCx<'_, '_, 'tcx>,\n             var: Variable,\n             data: Value,\n             dst_ty: Type,\n@@ -511,8 +456,7 @@ impl<'tcx> CPlace<'tcx> {\n                 }\n                 _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n             };\n-            fx.bcx\n-                .set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+            //fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n             fx.bcx.def_var(var, data);\n         }\n \n@@ -558,15 +502,13 @@ impl<'tcx> CPlace<'tcx> {\n \n                 // First get the old vector\n                 let vector = fx.bcx.use_var(var);\n-                fx.bcx\n-                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n \n                 // Next insert the written lane into the vector\n                 let vector = fx.bcx.ins().insertlane(vector, data, lane);\n \n                 // Finally write the new vector\n-                fx.bcx\n-                    .set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 fx.bcx.def_var(var, vector);\n \n                 return;\n@@ -604,10 +546,7 @@ impl<'tcx> CPlace<'tcx> {\n                 to_ptr.store(fx, val, flags);\n             }\n             CValueInner::ByValPair(_, _) => {\n-                bug!(\n-                    \"Non ScalarPair abi {:?} for ByValPair CValue\",\n-                    dst_layout.abi\n-                );\n+                bug!(\"Non ScalarPair abi {:?} for ByValPair CValue\", dst_layout.abi);\n             }\n             CValueInner::ByRef(from_ptr, None) => {\n                 let from_addr = from_ptr.get_addr(fx);\n@@ -632,7 +571,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_field(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n@@ -650,18 +589,8 @@ impl<'tcx> CPlace<'tcx> {\n                 let layout = layout.field(&*fx, field.index());\n \n                 match field.as_u32() {\n-                    0 => {\n-                        return CPlace {\n-                            inner: CPlaceInner::Var(local, var1),\n-                            layout,\n-                        }\n-                    }\n-                    1 => {\n-                        return CPlace {\n-                            inner: CPlaceInner::Var(local, var2),\n-                            layout,\n-                        }\n-                    }\n+                    0 => return CPlace { inner: CPlaceInner::Var(local, var1), layout },\n+                    1 => return CPlace { inner: CPlaceInner::Var(local, var2), layout },\n                     _ => unreachable!(\"field should be 0 or 1\"),\n                 }\n             }\n@@ -680,7 +609,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_index(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n@@ -689,30 +618,24 @@ impl<'tcx> CPlace<'tcx> {\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n-        let offset = fx\n-            .bcx\n-            .ins()\n-            .imul_imm(index, elem_layout.size.bytes() as i64);\n+        let offset = fx.bcx.ins().imul_imm(index, elem_layout.size.bytes() as i64);\n \n         CPlace::for_ptr(ptr.offset_value(fx, offset), elem_layout)\n     }\n \n-    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CPlace<'tcx> {\n+    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CPlace<'tcx> {\n         let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n         if has_ptr_meta(fx.tcx, inner_layout.ty) {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n             CPlace::for_ptr_with_extra(Pointer::new(addr), extra, inner_layout)\n         } else {\n-            CPlace::for_ptr(\n-                Pointer::new(self.to_cvalue(fx).load_scalar(fx)),\n-                inner_layout,\n-            )\n+            CPlace::for_ptr(Pointer::new(self.to_cvalue(fx).load_scalar(fx)), inner_layout)\n         }\n     }\n \n     pub(crate) fn place_ref(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CValue<'tcx> {\n         if has_ptr_meta(fx.tcx, self.layout().ty) {\n@@ -729,21 +652,18 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn downcast_variant(\n         self,\n-        fx: &FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &FunctionCx<'_, '_, 'tcx>,\n         variant: VariantIdx,\n     ) -> Self {\n         assert!(!self.layout().is_unsized());\n         let layout = self.layout().for_variant(fx, variant);\n-        CPlace {\n-            inner: self.inner,\n-            layout,\n-        }\n+        CPlace { inner: self.inner, layout }\n     }\n }\n \n #[track_caller]\n pub(crate) fn assert_assignable<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) {\n@@ -776,12 +696,9 @@ pub(crate) fn assert_assignable<'tcx>(\n         }\n         (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n             for (from, to) in from_traits.iter().zip(to_traits) {\n-                let from = fx\n-                    .tcx\n-                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n-                let to = fx\n-                    .tcx\n-                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                let from =\n+                    fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                let to = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n                 assert_eq!(\n                     from, to,\n                     \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\","}, {"sha": "4d2551a061b99b5e1b74e55d0f53d15b76ce2f04", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -15,7 +15,7 @@ fn vtable_memflags() -> MemFlags {\n     flags\n }\n \n-pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -25,7 +25,7 @@ pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: V\n     )\n }\n \n-pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -35,7 +35,7 @@ pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Valu\n     )\n }\n \n-pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -46,7 +46,7 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable:\n }\n \n pub(crate) fn get_ptr_and_method_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     idx: usize,\n ) -> (Value, Value) {\n@@ -68,7 +68,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n }\n \n pub(crate) fn get_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n@@ -85,7 +85,7 @@ pub(crate) fn get_vtable<'tcx>(\n }\n \n fn build_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> DataId {\n@@ -94,7 +94,7 @@ fn build_vtable<'tcx>(\n \n     let drop_in_place_fn = import_function(\n         tcx,\n-        &mut fx.cx.module,\n+        fx.cx.module,\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n@@ -111,7 +111,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map(|(def_id, substs)| {\n             import_function(\n                 tcx,\n-                &mut fx.cx.module,\n+                fx.cx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n                     .unwrap()\n                     .polymorphize(fx.tcx),\n@@ -165,11 +165,8 @@ fn build_vtable<'tcx>(\n }\n \n fn write_usize(tcx: TyCtxt<'_>, buf: &mut [u8], idx: usize, num: u64) {\n-    let pointer_size = tcx\n-        .layout_of(ParamEnv::reveal_all().and(tcx.types.usize))\n-        .unwrap()\n-        .size\n-        .bytes() as usize;\n+    let pointer_size =\n+        tcx.layout_of(ParamEnv::reveal_all().and(tcx.types.usize)).unwrap().size.bytes() as usize;\n     let target = &mut buf[idx * pointer_size..(idx + 1) * pointer_size];\n \n     match tcx.data_layout.endian {"}, {"sha": "e222adc7b80582ec7169a0c65f2fd9d34af00341", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n \n ./build.sh --sysroot none \"$@\""}, {"sha": "4999cb3c7ab42e3303e74139aede92b0d88cb0bc", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -10,8 +10,9 @@ doctest = false\n \n [dependencies]\n bitflags = \"1.0\"\n+cstr = \"0.2\"\n libc = \"0.2\"\n-measureme = \"9.0.0\"\n+measureme = \"9.1.0\"\n snap = \"1\"\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "d9393ffe534accb4d6b7763f129db6e7d76b2583", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -430,7 +430,13 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(attrs);\n-                llvm::Attribute::StructRet.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n+                unsafe {\n+                    llvm::LLVMRustAddStructRetAttr(\n+                        llfn,\n+                        llvm::AttributePlace::Argument(i).as_uint(),\n+                        self.ret.layout.llvm_type(cx),\n+                    );\n+                }\n             }\n             _ => {}\n         }\n@@ -486,8 +492,13 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(attrs);\n-                llvm::Attribute::StructRet\n-                    .apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n+                unsafe {\n+                    llvm::LLVMRustAddStructRetCallSiteAttr(\n+                        callsite,\n+                        llvm::AttributePlace::Argument(i).as_uint(),\n+                        self.ret.layout.llvm_type(bx),\n+                    );\n+                }\n             }\n             _ => {}\n         }\n@@ -554,7 +565,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 llvm::AddCallSiteAttrString(\n                     callsite,\n                     llvm::AttributePlace::Function,\n-                    rustc_data_structures::const_cstr!(\"cmse_nonsecure_call\"),\n+                    cstr::cstr!(\"cmse_nonsecure_call\"),\n                 );\n             }\n         }"}, {"sha": "068e5e99efead3487e0b88137e4a024c88b7e520", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -93,7 +93,7 @@ pub(crate) unsafe fn codegen(\n     let args = [usize, usize]; // size, align\n \n     let ty = llvm::LLVMFunctionType(void, args.as_ptr(), args.len() as c_uint, False);\n-    let name = \"__rust_alloc_error_handler\".to_string();\n+    let name = \"__rust_alloc_error_handler\";\n     let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n     // -> ! DIFlagNoReturn\n     llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);"}, {"sha": "38c8ae711a4cba3915f42baf1402b9d357edd157", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -61,9 +61,9 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         // Default per-arch clobbers\n         // Basically what clang does\n         let arch_clobbers = match &self.sess().target.arch[..] {\n-            \"x86\" | \"x86_64\" => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n-            \"mips\" | \"mips64\" => vec![\"~{$1}\"],\n-            _ => Vec::new(),\n+            \"x86\" | \"x86_64\" => &[\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"][..],\n+            \"mips\" | \"mips64\" => &[\"~{$1}\"],\n+            _ => &[],\n         };\n \n         let all_constraints = ia\n@@ -304,6 +304,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             } else if options.contains(InlineAsmOptions::READONLY) {\n                 llvm::Attribute::ReadOnly.apply_callsite(llvm::AttributePlace::Function, result);\n             }\n+            llvm::Attribute::WillReturn.apply_callsite(llvm::AttributePlace::Function, result);\n         } else if options.contains(InlineAsmOptions::NOMEM) {\n             llvm::Attribute::InaccessibleMemOnly\n                 .apply_callsite(llvm::AttributePlace::Function, result);"}, {"sha": "09ece6164ebd1a1b2421179685debb983def9190", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -2,8 +2,8 @@\n \n use std::ffi::CString;\n \n+use cstr::cstr;\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::const_cstr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n@@ -75,8 +75,8 @@ pub fn set_frame_pointer_elimination(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value)\n         llvm::AddFunctionAttrStringValue(\n             llfn,\n             llvm::AttributePlace::Function,\n-            const_cstr!(\"frame-pointer\"),\n-            const_cstr!(\"all\"),\n+            cstr!(\"frame-pointer\"),\n+            cstr!(\"all\"),\n         );\n     }\n }\n@@ -95,7 +95,7 @@ fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         llvm::AddFunctionAttrStringValue(\n             llfn,\n             llvm::AttributePlace::Function,\n-            const_cstr!(\"instrument-function-entry-inlined\"),\n+            cstr!(\"instrument-function-entry-inlined\"),\n             &mcount_name,\n         );\n     }\n@@ -129,24 +129,24 @@ fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         StackProbeType::None => None,\n         // Request LLVM to generate the probes inline. If the given LLVM version does not support\n         // this, no probe is generated at all (even if the attribute is specified).\n-        StackProbeType::Inline => Some(const_cstr!(\"inline-asm\")),\n+        StackProbeType::Inline => Some(cstr!(\"inline-asm\")),\n         // Flag our internal `__rust_probestack` function as the stack probe symbol.\n         // This is defined in the `compiler-builtins` crate for each architecture.\n-        StackProbeType::Call => Some(const_cstr!(\"__rust_probestack\")),\n+        StackProbeType::Call => Some(cstr!(\"__rust_probestack\")),\n         // Pick from the two above based on the LLVM version.\n         StackProbeType::InlineOrCall { min_llvm_version_for_inline } => {\n             if llvm_util::get_version() < min_llvm_version_for_inline {\n-                Some(const_cstr!(\"__rust_probestack\"))\n+                Some(cstr!(\"__rust_probestack\"))\n             } else {\n-                Some(const_cstr!(\"inline-asm\"))\n+                Some(cstr!(\"inline-asm\"))\n             }\n         }\n     };\n     if let Some(attr_value) = attr_value {\n         llvm::AddFunctionAttrStringValue(\n             llfn,\n             llvm::AttributePlace::Function,\n-            const_cstr!(\"probe-stack\"),\n+            cstr!(\"probe-stack\"),\n             attr_value,\n         );\n     }\n@@ -169,7 +169,7 @@ pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     llvm::AddFunctionAttrStringValue(\n         llfn,\n         llvm::AttributePlace::Function,\n-        const_cstr!(\"target-cpu\"),\n+        cstr!(\"target-cpu\"),\n         target_cpu.as_c_str(),\n     );\n }\n@@ -180,7 +180,7 @@ pub fn apply_tune_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         llvm::AddFunctionAttrStringValue(\n             llfn,\n             llvm::AttributePlace::Function,\n-            const_cstr!(\"tune-cpu\"),\n+            cstr!(\"tune-cpu\"),\n             tune_cpu.as_c_str(),\n         );\n     }\n@@ -289,7 +289,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n         Attribute::NoAlias.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY) {\n-        llvm::AddFunctionAttrString(llfn, Function, const_cstr!(\"cmse_nonsecure_entry\"));\n+        llvm::AddFunctionAttrString(llfn, Function, cstr!(\"cmse_nonsecure_entry\"));\n     }\n     sanitize(cx, codegen_fn_attrs.no_sanitize, llfn);\n \n@@ -319,7 +319,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n         llvm::AddFunctionAttrStringValue(\n             llfn,\n             llvm::AttributePlace::Function,\n-            const_cstr!(\"target-features\"),\n+            cstr!(\"target-features\"),\n             &val,\n         );\n     }\n@@ -332,7 +332,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n             llvm::AddFunctionAttrStringValue(\n                 llfn,\n                 llvm::AttributePlace::Function,\n-                const_cstr!(\"wasm-import-module\"),\n+                cstr!(\"wasm-import-module\"),\n                 &module,\n             );\n \n@@ -342,7 +342,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n             llvm::AddFunctionAttrStringValue(\n                 llfn,\n                 llvm::AttributePlace::Function,\n-                const_cstr!(\"wasm-import-name\"),\n+                cstr!(\"wasm-import-name\"),\n                 &name,\n             );\n         }"}, {"sha": "4b7bcf05501311da5abd45d997e3e755c378de86", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -11,6 +11,7 @@ use crate::llvm_util;\n use crate::type_::Type;\n use crate::LlvmCodegenBackend;\n use crate::ModuleLlvm;\n+use rustc_codegen_ssa::back::link::ensure_removed;\n use rustc_codegen_ssa::back::write::{\n     BitcodeSection, CodegenContext, EmitObj, ModuleConfig, TargetMachineFactoryConfig,\n     TargetMachineFactoryFn,\n@@ -93,7 +94,7 @@ pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm:\n pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n     let split_dwarf_file = if tcx.sess.target_can_use_split_dwarf() {\n         tcx.output_filenames(LOCAL_CRATE)\n-            .split_dwarf_filename(tcx.sess.split_debuginfo(), Some(mod_name))\n+            .split_dwarf_path(tcx.sess.split_debuginfo(), Some(mod_name))\n     } else {\n         None\n     };\n@@ -139,7 +140,7 @@ fn to_llvm_relocation_model(relocation_model: RelocModel) -> llvm::RelocModel {\n     }\n }\n \n-fn to_llvm_code_model(code_model: Option<CodeModel>) -> llvm::CodeModel {\n+pub(crate) fn to_llvm_code_model(code_model: Option<CodeModel>) -> llvm::CodeModel {\n     match code_model {\n         Some(CodeModel::Tiny) => llvm::CodeModel::Tiny,\n         Some(CodeModel::Small) => llvm::CodeModel::Small,\n@@ -879,9 +880,7 @@ pub(crate) unsafe fn codegen(\n \n                 if !config.emit_bc {\n                     debug!(\"removing_bitcode {:?}\", bc_out);\n-                    if let Err(e) = fs::remove_file(&bc_out) {\n-                        diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n-                    }\n+                    ensure_removed(diag_handler, &bc_out);\n                 }\n             }\n "}, {"sha": "f4852c91e53d5a67fd1b06ba85814f7fb4808cec", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -5,13 +5,13 @@ use crate::llvm::{AtomicOrdering, AtomicRmwBinOp, SynchronizationScope};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n+use cstr::cstr;\n use libc::{c_char, c_uint};\n use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, TypeKind};\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n-use rustc_data_structures::const_cstr;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::TyAndLayout;\n@@ -979,7 +979,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn cleanup_pad(&mut self, parent: Option<&'ll Value>, args: &[&'ll Value]) -> Funclet<'ll> {\n-        let name = const_cstr!(\"cleanuppad\");\n+        let name = cstr!(\"cleanuppad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupPad(\n                 self.llbuilder,\n@@ -1003,7 +1003,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn catch_pad(&mut self, parent: &'ll Value, args: &[&'ll Value]) -> Funclet<'ll> {\n-        let name = const_cstr!(\"catchpad\");\n+        let name = cstr!(\"catchpad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchPad(\n                 self.llbuilder,\n@@ -1022,7 +1022,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unwind: Option<&'ll BasicBlock>,\n         num_handlers: usize,\n     ) -> &'ll Value {\n-        let name = const_cstr!(\"catchswitch\");\n+        let name = cstr!(\"catchswitch\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(\n                 self.llbuilder,"}, {"sha": "99046839973d5c64ba968a1ecc06792944d01669", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -5,9 +5,9 @@ use crate::llvm::{self, True};\n use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n+use cstr::cstr;\n use libc::c_uint;\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::const_cstr;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n@@ -419,9 +419,9 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                             .all(|&byte| byte == 0);\n \n                     let sect_name = if all_bytes_are_zero {\n-                        const_cstr!(\"__DATA,__thread_bss\")\n+                        cstr!(\"__DATA,__thread_bss\")\n                     } else {\n-                        const_cstr!(\"__DATA,__thread_data\")\n+                        cstr!(\"__DATA,__thread_data\")\n                     };\n                     llvm::LLVMSetSection(g, sect_name.as_ptr());\n                 }"}, {"sha": "21473f3b1143cfc71b5c60b5cfb40f2380fedbd0", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,5 @@\n use crate::attributes;\n+use crate::back::write::to_llvm_code_model;\n use crate::callee::get_fn;\n use crate::coverageinfo;\n use crate::debuginfo;\n@@ -7,10 +8,10 @@ use crate::llvm_util;\n use crate::type_::Type;\n use crate::value::Value;\n \n+use cstr::cstr;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::base_n;\n-use rustc_data_structures::const_cstr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_middle::bug;\n@@ -104,6 +105,10 @@ fn strip_x86_address_spaces(data_layout: String) -> String {\n     data_layout.replace(\"-p270:32:32-p271:32:32-p272:64:64-\", \"-\")\n }\n \n+fn strip_powerpc64_vectors(data_layout: String) -> String {\n+    data_layout.replace(\"-v256:256:256-v512:512:512\", \"\")\n+}\n+\n pub unsafe fn create_module(\n     tcx: TyCtxt<'_>,\n     llcx: &'ll llvm::Context,\n@@ -119,6 +124,9 @@ pub unsafe fn create_module(\n     {\n         target_data_layout = strip_x86_address_spaces(target_data_layout);\n     }\n+    if llvm_util::get_version() < (12, 0, 0) && sess.target.arch == \"powerpc64\" {\n+        target_data_layout = strip_powerpc64_vectors(target_data_layout);\n+    }\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n     if sess.target.is_builtin {\n@@ -174,6 +182,13 @@ pub unsafe fn create_module(\n         }\n     }\n \n+    // Linking object files with different code models is undefined behavior\n+    // because the compiler would have to generate additional code (to span\n+    // longer jumps) if a larger code model is used with a smaller one.\n+    //\n+    // See https://reviews.llvm.org/D52322 and https://reviews.llvm.org/D52323.\n+    llvm::LLVMRustSetModuleCodeModel(llmod, to_llvm_code_model(sess.code_model()));\n+\n     // If skipping the PLT is enabled, we need to add some module metadata\n     // to ensure intrinsic calls don't use it.\n     if !sess.needs_plt() {\n@@ -414,8 +429,8 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn create_used_variable(&self) {\n-        let name = const_cstr!(\"llvm.used\");\n-        let section = const_cstr!(\"llvm.metadata\");\n+        let name = cstr!(\"llvm.used\");\n+        let section = cstr!(\"llvm.metadata\");\n         let array =\n             self.const_array(&self.type_ptr_to(self.type_i8()), &*self.used_statics.borrow());\n "}, {"sha": "e47b8fde40fee327a4a1972448c11383877c268d", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -162,7 +162,7 @@ pub(crate) fn write_filenames_section_to_buffer<'a>(\n pub(crate) fn write_mapping_to_buffer(\n     virtual_file_mapping: Vec<u32>,\n     expressions: Vec<CounterExpression>,\n-    mut mapping_regions: Vec<CounterMappingRegion>,\n+    mapping_regions: Vec<CounterMappingRegion>,\n     buffer: &RustString,\n ) {\n     unsafe {\n@@ -171,7 +171,7 @@ pub(crate) fn write_mapping_to_buffer(\n             virtual_file_mapping.len() as c_uint,\n             expressions.as_ptr(),\n             expressions.len() as c_uint,\n-            mapping_regions.as_mut_ptr(),\n+            mapping_regions.as_ptr(),\n             mapping_regions.len() as c_uint,\n             buffer,\n         );"}, {"sha": "c2725b83f50d62f32a6d9f1180da76e25fc010cc", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-use super::metadata::{file_metadata, UNKNOWN_COLUMN_NUMBER, UNKNOWN_LINE_NUMBER};\n+use super::metadata::file_metadata;\n use super::utils::DIB;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext};\n use rustc_codegen_ssa::traits::*;\n@@ -102,8 +102,8 @@ fn make_mir_scope(\n                 DIB(cx),\n                 parent_scope.dbg_scope.unwrap(),\n                 file_metadata,\n-                loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-                loc.col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n+                loc.line,\n+                loc.col,\n             )\n         },\n     };"}, {"sha": "d5b32e58cc397d0508f5fd88cd803cc5eff3eed0", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -18,8 +18,8 @@ use crate::llvm::debuginfo::{\n };\n use crate::value::Value;\n \n+use cstr::cstr;\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::const_cstr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -979,7 +979,7 @@ pub fn compile_unit_metadata(\n     // The OSX linker has an idiosyncrasy where it will ignore some debuginfo\n     // if multiple object files with the same `DW_AT_name` are linked together.\n     // As a workaround we generate unique names for each object file. Those do\n-    // not correspond to an actual source file but that should be harmless.\n+    // not correspond to an actual source file but that is harmless.\n     if tcx.sess.target.is_like_osx {\n         name_in_debuginfo.push(\"@\");\n         name_in_debuginfo.push(codegen_unit_name);\n@@ -992,17 +992,17 @@ pub fn compile_unit_metadata(\n     let producer = format!(\"clang LLVM ({})\", rustc_producer);\n \n     let name_in_debuginfo = name_in_debuginfo.to_string_lossy();\n+    let work_dir = tcx.sess.working_dir.0.to_string_lossy();\n     let flags = \"\\0\";\n-\n     let out_dir = &tcx.output_filenames(LOCAL_CRATE).out_directory;\n     let split_name = if tcx.sess.target_can_use_split_dwarf() {\n         tcx.output_filenames(LOCAL_CRATE)\n-            .split_dwarf_filename(tcx.sess.split_debuginfo(), Some(codegen_unit_name))\n+            .split_dwarf_path(tcx.sess.split_debuginfo(), Some(codegen_unit_name))\n+            .map(|f| out_dir.join(f))\n     } else {\n         None\n     }\n     .unwrap_or_default();\n-    let out_dir = out_dir.to_str().unwrap();\n     let split_name = split_name.to_str().unwrap();\n \n     // FIXME(#60020):\n@@ -1024,12 +1024,12 @@ pub fn compile_unit_metadata(\n     assert!(tcx.sess.opts.debuginfo != DebugInfo::None);\n \n     unsafe {\n-        let file_metadata = llvm::LLVMRustDIBuilderCreateFile(\n+        let compile_unit_file = llvm::LLVMRustDIBuilderCreateFile(\n             debug_context.builder,\n             name_in_debuginfo.as_ptr().cast(),\n             name_in_debuginfo.len(),\n-            out_dir.as_ptr().cast(),\n-            out_dir.len(),\n+            work_dir.as_ptr().cast(),\n+            work_dir.len(),\n             llvm::ChecksumKind::None,\n             ptr::null(),\n             0,\n@@ -1038,12 +1038,15 @@ pub fn compile_unit_metadata(\n         let unit_metadata = llvm::LLVMRustDIBuilderCreateCompileUnit(\n             debug_context.builder,\n             DW_LANG_RUST,\n-            file_metadata,\n+            compile_unit_file,\n             producer.as_ptr().cast(),\n             producer.len(),\n             tcx.sess.opts.optimize != config::OptLevel::No,\n             flags.as_ptr().cast(),\n             0,\n+            // NB: this doesn't actually have any perceptible effect, it seems. LLVM will instead\n+            // put the path supplied to `MCSplitDwarfFile` into the debug info of the final\n+            // output(s).\n             split_name.as_ptr().cast(),\n             split_name.len(),\n             kind,\n@@ -1072,7 +1075,7 @@ pub fn compile_unit_metadata(\n                 gcov_cu_info.len() as c_uint,\n             );\n \n-            let llvm_gcov_ident = const_cstr!(\"llvm.gcov\");\n+            let llvm_gcov_ident = cstr!(\"llvm.gcov\");\n             llvm::LLVMAddNamedMetadataOperand(\n                 debug_context.llmod,\n                 llvm_gcov_ident.as_ptr(),\n@@ -1090,7 +1093,7 @@ pub fn compile_unit_metadata(\n             );\n             llvm::LLVMAddNamedMetadataOperand(\n                 debug_context.llmod,\n-                const_cstr!(\"llvm.ident\").as_ptr(),\n+                cstr!(\"llvm.ident\").as_ptr(),\n                 llvm::LLVMMDNodeInContext(debug_context.llcontext, &name_metadata, 1),\n             );\n         }\n@@ -1414,7 +1417,7 @@ fn generator_layout_and_saved_local_names(\n     def_id: DefId,\n ) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>) {\n     let body = tcx.optimized_mir(def_id);\n-    let generator_layout = body.generator_layout.as_ref().unwrap();\n+    let generator_layout = body.generator_layout().unwrap();\n     let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n \n     let state_arg = mir::Local::new(1);\n@@ -1839,10 +1842,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n                     .span;\n                 if !span.is_dummy() {\n                     let loc = cx.lookup_debug_loc(span.lo());\n-                    return Some(SourceInfo {\n-                        file: file_metadata(cx, &loc.file),\n-                        line: loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-                    });\n+                    return Some(SourceInfo { file: file_metadata(cx, &loc.file), line: loc.line });\n                 }\n             }\n             _ => {}\n@@ -2369,7 +2369,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIAr\n     fn get_parameter_names(cx: &CodegenCx<'_, '_>, generics: &ty::Generics) -> Vec<Symbol> {\n         let mut names = generics\n             .parent\n-            .map_or(vec![], |def_id| get_parameter_names(cx, cx.tcx.generics_of(def_id)));\n+            .map_or_else(Vec::new, |def_id| get_parameter_names(cx, cx.tcx.generics_of(def_id)));\n         names.extend(generics.params.iter().map(|param| param.name));\n         names\n     }\n@@ -2481,7 +2481,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n         let loc = cx.lookup_debug_loc(span.lo());\n         (file_metadata(cx, &loc.file), loc.line)\n     } else {\n-        (unknown_file_metadata(cx), None)\n+        (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER)\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n@@ -2504,7 +2504,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n             linkage_name.as_ptr().cast(),\n             linkage_name.len(),\n             file_metadata,\n-            line_number.unwrap_or(UNKNOWN_LINE_NUMBER),\n+            line_number,\n             type_metadata,\n             is_local_to_unit,\n             global,"}, {"sha": "440e4d505fc920d4becd8b63a9bbb37c2b7993f5", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -224,9 +224,9 @@ pub struct DebugLoc {\n     /// Information about the original source file.\n     pub file: Lrc<SourceFile>,\n     /// The (1-based) line number.\n-    pub line: Option<u32>,\n+    pub line: u32,\n     /// The (1-based) column number.\n-    pub col: Option<u32>,\n+    pub col: u32,\n }\n \n impl CodegenCx<'ll, '_> {\n@@ -243,16 +243,16 @@ impl CodegenCx<'ll, '_> {\n                 let line = (line + 1) as u32;\n                 let col = (pos - line_pos).to_u32() + 1;\n \n-                (file, Some(line), Some(col))\n+                (file, line, col)\n             }\n-            Err(file) => (file, None, None),\n+            Err(file) => (file, UNKNOWN_LINE_NUMBER, UNKNOWN_COLUMN_NUMBER),\n         };\n \n         // For MSVC, omit the column number.\n         // Otherwise, emit it. This mimics clang behaviour.\n         // See discussion in https://github.com/rust-lang/rust/issues/42921\n         if self.sess().target.is_like_msvc {\n-            DebugLoc { file, line, col: None }\n+            DebugLoc { file, line, col: UNKNOWN_COLUMN_NUMBER }\n         } else {\n             DebugLoc { file, line, col }\n         }\n@@ -358,9 +358,9 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 linkage_name.as_ptr().cast(),\n                 linkage_name.len(),\n                 file_metadata,\n-                loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                loc.line,\n                 function_type_metadata,\n-                scope_line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                scope_line,\n                 flags,\n                 spflags,\n                 maybe_definition_llfn,\n@@ -481,9 +481,9 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n \n         fn get_parameter_names(cx: &CodegenCx<'_, '_>, generics: &ty::Generics) -> Vec<Symbol> {\n-            let mut names = generics\n-                .parent\n-                .map_or(vec![], |def_id| get_parameter_names(cx, cx.tcx.generics_of(def_id)));\n+            let mut names = generics.parent.map_or_else(Vec::new, |def_id| {\n+                get_parameter_names(cx, cx.tcx.generics_of(def_id))\n+            });\n             names.extend(generics.params.iter().map(|param| param.name));\n             names\n         }\n@@ -550,14 +550,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     ) -> &'ll DILocation {\n         let DebugLoc { line, col, .. } = self.lookup_debug_loc(span.lo());\n \n-        unsafe {\n-            llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-                col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n-                scope,\n-                inlined_at,\n-            )\n-        }\n+        unsafe { llvm::LLVMRustDIBuilderCreateDebugLocation(line, col, scope, inlined_at) }\n     }\n \n     fn create_vtable_metadata(&self, ty: Ty<'tcx>, vtable: Self::Value) {\n@@ -606,7 +599,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 name.as_ptr().cast(),\n                 name.len(),\n                 file_metadata,\n-                loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                loc.line,\n                 type_metadata,\n                 true,\n                 DIFlags::FlagZero,"}, {"sha": "f445d708c94f60d1b72cba2d75f97e704d7c7687", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -334,8 +334,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n \n-    fn sideeffect(&mut self, unconditional: bool) {\n-        if unconditional || self.tcx.sess.opts.debugging_opts.insert_sideeffect {\n+    fn sideeffect(&mut self) {\n+        // This kind of check would make a ton of sense in the caller, but currently the only\n+        // caller of this function is in `rustc_codegen_ssa`, which is agnostic to whether LLVM\n+        // codegen backend being used, and so is unable to check the LLVM version.\n+        if unsafe { llvm::LLVMRustVersionMajor() } < 12 {\n             let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n             self.call(fnname, &[], None);\n         }\n@@ -390,7 +393,6 @@ fn codegen_msvc_try(\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n-        bx.sideeffect(false);\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n         let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n@@ -552,9 +554,6 @@ fn codegen_gnu_try(\n         //      (%ptr, _) = landingpad\n         //      call %catch_func(%data, %ptr)\n         //      ret 1\n-\n-        bx.sideeffect(false);\n-\n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n \n@@ -614,9 +613,6 @@ fn codegen_emcc_try(\n         //      %catch_data[1] = %is_rust_panic\n         //      call %catch_func(%data, %catch_data)\n         //      ret 1\n-\n-        bx.sideeffect(false);\n-\n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n "}, {"sha": "82cd1be3b3b45ab70beded53ff66d66cc0c69c11", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -132,6 +132,7 @@ pub enum Attribute {\n     ReadNone = 26,\n     InaccessibleMemOnly = 27,\n     SanitizeHWAddress = 28,\n+    WillReturn = 29,\n }\n \n /// LLVMIntPredicate\n@@ -239,6 +240,7 @@ pub enum TypeKind {\n     Token = 16,\n     ScalableVector = 17,\n     BFloat = 18,\n+    X86_AMX = 19,\n }\n \n impl TypeKind {\n@@ -263,6 +265,7 @@ impl TypeKind {\n             TypeKind::Token => rustc_codegen_ssa::common::TypeKind::Token,\n             TypeKind::ScalableVector => rustc_codegen_ssa::common::TypeKind::ScalableVector,\n             TypeKind::BFloat => rustc_codegen_ssa::common::TypeKind::BFloat,\n+            TypeKind::X86_AMX => rustc_codegen_ssa::common::TypeKind::X86_AMX,\n         }\n     }\n }\n@@ -674,9 +677,7 @@ pub mod coverageinfo {\n     /// array\", encoded separately), and source location (start and end positions of the represented\n     /// code region).\n     ///\n-    /// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L224-L227)\n-    /// Important: The Rust struct layout (order and types of fields) must match its C++\n-    /// counterpart.\n+    /// Matches LLVMRustCounterMappingRegion.\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub struct CounterMappingRegion {\n@@ -1073,6 +1074,7 @@ extern \"C\" {\n     pub fn LLVMRustAddDereferenceableAttr(Fn: &Value, index: c_uint, bytes: u64);\n     pub fn LLVMRustAddDereferenceableOrNullAttr(Fn: &Value, index: c_uint, bytes: u64);\n     pub fn LLVMRustAddByValAttr(Fn: &Value, index: c_uint, ty: &Type);\n+    pub fn LLVMRustAddStructRetAttr(Fn: &Value, index: c_uint, ty: &Type);\n     pub fn LLVMRustAddFunctionAttribute(Fn: &Value, index: c_uint, attr: Attribute);\n     pub fn LLVMRustAddFunctionAttrStringValue(\n         Fn: &Value,\n@@ -1108,6 +1110,7 @@ extern \"C\" {\n     pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: &Value, index: c_uint, bytes: u64);\n     pub fn LLVMRustAddDereferenceableOrNullCallSiteAttr(Instr: &Value, index: c_uint, bytes: u64);\n     pub fn LLVMRustAddByValCallSiteAttr(Instr: &Value, index: c_uint, ty: &Type);\n+    pub fn LLVMRustAddStructRetCallSiteAttr(Instr: &Value, index: c_uint, ty: &Type);\n \n     // Operations on load/store instructions (only)\n     pub fn LLVMSetVolatile(MemoryAccessInst: &Value, volatile: Bool);\n@@ -1792,7 +1795,7 @@ extern \"C\" {\n         NumVirtualFileMappingIDs: c_uint,\n         Expressions: *const coverage_map::CounterExpression,\n         NumExpressions: c_uint,\n-        MappingRegions: *mut coverageinfo::CounterMappingRegion,\n+        MappingRegions: *const coverageinfo::CounterMappingRegion,\n         NumMappingRegions: c_uint,\n         BufferOut: &RustString,\n     );\n@@ -2323,6 +2326,7 @@ extern \"C\" {\n     pub fn LLVMRustUnsetComdat(V: &Value);\n     pub fn LLVMRustSetModulePICLevel(M: &Module);\n     pub fn LLVMRustSetModulePIELevel(M: &Module);\n+    pub fn LLVMRustSetModuleCodeModel(M: &Module, Model: CodeModel);\n     pub fn LLVMRustModuleBufferCreate(M: &Module) -> &'static mut ModuleBuffer;\n     pub fn LLVMRustModuleBufferPtr(p: &ModuleBuffer) -> *const u8;\n     pub fn LLVMRustModuleBufferLen(p: &ModuleBuffer) -> usize;"}, {"sha": "b007df5730621e7e368067afcd68a5055f721f15", "filename": "compiler/rustc_codegen_llvm/src/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -65,8 +65,8 @@ fn search_meta_section<'a>(\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = None;\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = name_buf.map_or(\n-                String::new(), // We got a NULL ptr, ignore `name_len`.\n+            let name = name_buf.map_or_else(\n+                String::new, // We got a NULL ptr, ignore `name_len`.\n                 |buf| {\n                     String::from_utf8(\n                         slice::from_raw_parts(buf.as_ptr() as *const u8, name_len as usize)"}, {"sha": "5e2f01b2c9da86b19a2500ca5daf0d27786ec8d7", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -11,7 +11,6 @@ test = false\n bitflags = \"1.2.1\"\n cc = \"1.0.1\"\n itertools = \"0.9\"\n-num_cpus = \"1.0\"\n memmap = \"0.7\"\n tracing = \"0.1\"\n libc = \"0.2.50\""}, {"sha": "b11821b7db0a2b8eb6ac62e5eae4f0b4eb48d9c1", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,5 +1,6 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n+use rustc_errors::Handler;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::{EncodedMetadata, LibSource};\n@@ -34,9 +35,11 @@ use std::path::{Path, PathBuf};\n use std::process::{ExitStatus, Output, Stdio};\n use std::{ascii, char, env, fmt, fs, io, mem, str};\n \n-pub fn remove(sess: &Session, path: &Path) {\n+pub fn ensure_removed(diag_handler: &Handler, path: &Path) {\n     if let Err(e) = fs::remove_file(path) {\n-        sess.err(&format!(\"failed to remove {}: {}\", path.display(), e));\n+        if e.kind() != io::ErrorKind::NotFound {\n+            diag_handler.err(&format!(\"failed to remove {}: {}\", path.display(), e));\n+        }\n     }\n }\n \n@@ -112,11 +115,11 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         if !sess.opts.cg.save_temps {\n             let remove_temps_from_module = |module: &CompiledModule| {\n                 if let Some(ref obj) = module.object {\n-                    remove(sess, obj);\n+                    ensure_removed(sess.diagnostic(), obj);\n                 }\n \n                 if let Some(ref obj) = module.dwarf_object {\n-                    remove(sess, obj);\n+                    ensure_removed(sess.diagnostic(), obj);\n                 }\n             };\n \n@@ -178,16 +181,16 @@ fn get_linker(\n             let original_path = tool.path();\n             if let Some(ref root_lib_path) = original_path.ancestors().nth(4) {\n                 let arch = match t.arch.as_str() {\n-                    \"x86_64\" => Some(\"x64\".to_string()),\n-                    \"x86\" => Some(\"x86\".to_string()),\n-                    \"aarch64\" => Some(\"arm64\".to_string()),\n-                    \"arm\" => Some(\"arm\".to_string()),\n+                    \"x86_64\" => Some(\"x64\"),\n+                    \"x86\" => Some(\"x86\"),\n+                    \"aarch64\" => Some(\"arm64\"),\n+                    \"arm\" => Some(\"arm\"),\n                     _ => None,\n                 };\n                 if let Some(ref a) = arch {\n                     // FIXME: Move this to `fn linker_with_args`.\n                     let mut arg = OsString::from(\"/LIBPATH:\");\n-                    arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a.to_string()));\n+                    arg.push(format!(\"{}\\\\lib\\\\{}\\\\store\", root_lib_path.display(), a));\n                     cmd.arg(&arg);\n                 } else {\n                     warn!(\"arch is not supported\");\n@@ -708,7 +711,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n             status.signal() == Some(libc::SIGILL)\n         }\n \n-        #[cfg(windows)]\n+        #[cfg(not(unix))]\n         fn is_illegal_instruction(_status: &ExitStatus) -> bool {\n             false\n         }\n@@ -1195,7 +1198,7 @@ fn exec_linker(\n     flush_linked_file(&output, out_filename)?;\n     return output;\n \n-    #[cfg(unix)]\n+    #[cfg(not(windows))]\n     fn flush_linked_file(_: &io::Result<Output>, _: &Path) -> io::Result<()> {\n         Ok(())\n     }\n@@ -1235,6 +1238,11 @@ fn exec_linker(\n         err.raw_os_error() == Some(ERROR_FILENAME_EXCED_RANGE)\n     }\n \n+    #[cfg(not(any(unix, windows)))]\n+    fn command_line_too_big(_: &io::Error) -> bool {\n+        false\n+    }\n+\n     struct Escape<'a> {\n         arg: &'a str,\n         is_like_msvc: bool,\n@@ -2079,7 +2087,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n         cmd.link_rust_dylib(\n             Symbol::intern(&unlib(&sess.target, filestem)),\n-            parent.unwrap_or(Path::new(\"\")),\n+            parent.unwrap_or_else(|| Path::new(\"\")),\n         );\n     }\n }\n@@ -2190,6 +2198,7 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n         (\"x86_64\", \"tvos\") => \"appletvsimulator\",\n         (\"arm\", \"ios\") => \"iphoneos\",\n         (\"aarch64\", \"ios\") if llvm_target.contains(\"macabi\") => \"macosx\",\n+        (\"aarch64\", \"ios\") if llvm_target.contains(\"sim\") => \"iphonesimulator\",\n         (\"aarch64\", \"ios\") => \"iphoneos\",\n         (\"x86\", \"ios\") => \"iphonesimulator\",\n         (\"x86_64\", \"ios\") if llvm_target.contains(\"macabi\") => \"macosx\","}, {"sha": "5f21046b05e475e9e3934faa2a671d927ee99383", "filename": "compiler/rustc_codegen_ssa/src/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -24,7 +24,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig<'_>) -> Vec<String> {\n \n     debug!(\"preparing the RPATH!\");\n \n-    let libs = config.used_crates.clone();\n+    let libs = config.used_crates;\n     let libs = libs.iter().filter_map(|&(_, ref l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs);\n     let mut flags = rpaths_to_flags(&rpaths);"}, {"sha": "854aaac757fb013a32b17c1cbe73ffd8314bdc31", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 157, "deletions": 74, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,4 @@\n-use super::link::{self, remove};\n+use super::link::{self, ensure_removed};\n use super::linker::LinkerInfo;\n use super::lto::{self, SerializedModule};\n use super::symbol_export::symbol_name_for_instance_in_crate;\n@@ -288,7 +288,7 @@ impl TargetMachineFactoryConfig {\n         module_name: &str,\n     ) -> TargetMachineFactoryConfig {\n         let split_dwarf_file = if cgcx.target_can_use_split_dwarf {\n-            cgcx.output_filenames.split_dwarf_filename(cgcx.split_debuginfo, Some(module_name))\n+            cgcx.output_filenames.split_dwarf_path(cgcx.split_debuginfo, Some(module_name))\n         } else {\n             None\n         };\n@@ -433,12 +433,10 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    let no_builtins = tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n-    let is_compiler_builtins =\n-        tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n-    let subsystem = tcx\n-        .sess\n-        .first_attr_value_str_by_name(&tcx.hir().krate().item.attrs, sym::windows_subsystem);\n+    let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n+    let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n+    let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n+    let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n         if subsystem != sym::windows && subsystem != sym::console {\n             tcx.sess.fatal(&format!(\n@@ -543,7 +541,7 @@ fn produce_final_output_artifacts(\n             copy_gracefully(&path, &crate_output.path(output_type));\n             if !sess.opts.cg.save_temps && !keep_numbered {\n                 // The user just wants `foo.x`, not `foo.#module-name#.x`.\n-                remove(sess, &path);\n+                ensure_removed(sess.diagnostic(), &path);\n             }\n         } else {\n             let ext = crate_output\n@@ -642,33 +640,33 @@ fn produce_final_output_artifacts(\n         for module in compiled_modules.modules.iter() {\n             if let Some(ref path) = module.object {\n                 if !keep_numbered_objects {\n-                    remove(sess, path);\n+                    ensure_removed(sess.diagnostic(), path);\n                 }\n             }\n \n             if let Some(ref path) = module.dwarf_object {\n                 if !keep_numbered_objects {\n-                    remove(sess, path);\n+                    ensure_removed(sess.diagnostic(), path);\n                 }\n             }\n \n             if let Some(ref path) = module.bytecode {\n                 if !keep_numbered_bitcode {\n-                    remove(sess, path);\n+                    ensure_removed(sess.diagnostic(), path);\n                 }\n             }\n         }\n \n         if !user_wants_bitcode {\n             if let Some(ref metadata_module) = compiled_modules.metadata_module {\n                 if let Some(ref path) = metadata_module.bytecode {\n-                    remove(sess, &path);\n+                    ensure_removed(sess.diagnostic(), &path);\n                 }\n             }\n \n             if let Some(ref allocator_module) = compiled_modules.allocator_module {\n                 if let Some(ref path) = allocator_module.bytecode {\n-                    remove(sess, path);\n+                    ensure_removed(sess.diagnostic(), path);\n                 }\n             }\n         }\n@@ -712,6 +710,33 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n             }\n         }\n     }\n+\n+    /// Generate a short description of this work item suitable for use as a thread name.\n+    fn short_description(&self) -> String {\n+        // `pthread_setname()` on *nix is limited to 15 characters and longer names are ignored.\n+        // Use very short descriptions in this case to maximize the space available for the module name.\n+        // Windows does not have that limitation so use slightly more descriptive names there.\n+        match self {\n+            WorkItem::Optimize(m) => {\n+                #[cfg(windows)]\n+                return format!(\"optimize module {}\", m.name);\n+                #[cfg(not(windows))]\n+                return format!(\"opt {}\", m.name);\n+            }\n+            WorkItem::CopyPostLtoArtifacts(m) => {\n+                #[cfg(windows)]\n+                return format!(\"copy LTO artifacts for {}\", m.name);\n+                #[cfg(not(windows))]\n+                return format!(\"copy {}\", m.name);\n+            }\n+            WorkItem::LTO(m) => {\n+                #[cfg(windows)]\n+                return format!(\"LTO module {}\", m.name());\n+                #[cfg(not(windows))]\n+                return format!(\"LTO {}\", m.name());\n+            }\n+        }\n+    }\n }\n \n enum WorkItemResult<B: WriteBackendMethods> {\n@@ -735,7 +760,7 @@ fn execute_work_item<B: ExtraBackendMethods>(\n     match work_item {\n         WorkItem::Optimize(module) => execute_optimize_work_item(cgcx, module, module_config),\n         WorkItem::CopyPostLtoArtifacts(module) => {\n-            execute_copy_from_cache_work_item(cgcx, module, module_config)\n+            Ok(execute_copy_from_cache_work_item(cgcx, module, module_config))\n         }\n         WorkItem::LTO(module) => execute_lto_work_item(cgcx, module, module_config),\n     }\n@@ -844,7 +869,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     module: CachedModuleCodegen,\n     module_config: &ModuleConfig,\n-) -> Result<WorkItemResult<B>, FatalError> {\n+) -> WorkItemResult<B> {\n     let incr_comp_session_dir = cgcx.incr_comp_session_dir.as_ref().unwrap();\n     let mut object = None;\n     if let Some(saved_file) = module.source.saved_file {\n@@ -870,13 +895,13 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n \n     assert_eq!(object.is_some(), module_config.emit_obj != EmitObj::None);\n \n-    Ok(WorkItemResult::Compiled(CompiledModule {\n+    WorkItemResult::Compiled(CompiledModule {\n         name: module.name,\n         kind: ModuleKind::Regular,\n         object,\n         dwarf_object: None,\n         bytecode: None,\n-    }))\n+    })\n }\n \n fn execute_lto_work_item<B: ExtraBackendMethods>(\n@@ -1193,7 +1218,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // necessary. There's already optimizations in place to avoid sending work\n     // back to the coordinator if LTO isn't requested.\n     return thread::spawn(move || {\n-        let max_workers = num_cpus::get();\n         let mut worker_id_counter = 0;\n         let mut free_worker_ids = Vec::new();\n         let mut get_worker_id = |free_worker_ids: &mut Vec<usize>| {\n@@ -1253,7 +1277,17 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             // For codegenning more CGU or for running them through LLVM.\n             if !codegen_done {\n                 if main_thread_worker_state == MainThreadWorkerState::Idle {\n-                    if !queue_full_enough(work_items.len(), running, max_workers) {\n+                    // Compute the number of workers that will be running once we've taken as many\n+                    // items from the work queue as we can, plus one for the main thread. It's not\n+                    // critically important that we use this instead of just `running`, but it\n+                    // prevents the `queue_full_enough` heuristic from fluctuating just because a\n+                    // worker finished up and we decreased the `running` count, even though we're\n+                    // just going to increase it right after this when we put a new worker to work.\n+                    let extra_tokens = tokens.len().checked_sub(running).unwrap();\n+                    let additional_running = std::cmp::min(extra_tokens, work_items.len());\n+                    let anticipated_running = running + additional_running + 1;\n+\n+                    if !queue_full_enough(work_items.len(), anticipated_running) {\n                         // The queue is not full enough, codegen more items:\n                         if codegen_worker_send.send(Message::CodegenItem).is_err() {\n                             panic!(\"Could not send Message::CodegenItem to main thread\")\n@@ -1529,13 +1563,59 @@ fn start_executing_work<B: ExtraBackendMethods>(\n \n     // A heuristic that determines if we have enough LLVM WorkItems in the\n     // queue so that the main thread can do LLVM work instead of codegen\n-    fn queue_full_enough(\n-        items_in_queue: usize,\n-        workers_running: usize,\n-        max_workers: usize,\n-    ) -> bool {\n-        // Tune me, plz.\n-        items_in_queue > 0 && items_in_queue >= max_workers.saturating_sub(workers_running / 2)\n+    fn queue_full_enough(items_in_queue: usize, workers_running: usize) -> bool {\n+        // This heuristic scales ahead-of-time codegen according to available\n+        // concurrency, as measured by `workers_running`. The idea is that the\n+        // more concurrency we have available, the more demand there will be for\n+        // work items, and the fuller the queue should be kept to meet demand.\n+        // An important property of this approach is that we codegen ahead of\n+        // time only as much as necessary, so as to keep fewer LLVM modules in\n+        // memory at once, thereby reducing memory consumption.\n+        //\n+        // When the number of workers running is less than the max concurrency\n+        // available to us, this heuristic can cause us to instruct the main\n+        // thread to work on an LLVM item (that is, tell it to \"LLVM\") instead\n+        // of codegen, even though it seems like it *should* be codegenning so\n+        // that we can create more work items and spawn more LLVM workers.\n+        //\n+        // But this is not a problem. When the main thread is told to LLVM,\n+        // according to this heuristic and how work is scheduled, there is\n+        // always at least one item in the queue, and therefore at least one\n+        // pending jobserver token request. If there *is* more concurrency\n+        // available, we will immediately receive a token, which will upgrade\n+        // the main thread's LLVM worker to a real one (conceptually), and free\n+        // up the main thread to codegen if necessary. On the other hand, if\n+        // there isn't more concurrency, then the main thread working on an LLVM\n+        // item is appropriate, as long as the queue is full enough for demand.\n+        //\n+        // Speaking of which, how full should we keep the queue? Probably less\n+        // full than you'd think. A lot has to go wrong for the queue not to be\n+        // full enough and for that to have a negative effect on compile times.\n+        //\n+        // Workers are unlikely to finish at exactly the same time, so when one\n+        // finishes and takes another work item off the queue, we often have\n+        // ample time to codegen at that point before the next worker finishes.\n+        // But suppose that codegen takes so long that the workers exhaust the\n+        // queue, and we have one or more workers that have nothing to work on.\n+        // Well, it might not be so bad. Of all the LLVM modules we create and\n+        // optimize, one has to finish last. It's not necessarily the case that\n+        // by losing some concurrency for a moment, we delay the point at which\n+        // that last LLVM module is finished and the rest of compilation can\n+        // proceed. Also, when we can't take advantage of some concurrency, we\n+        // give tokens back to the job server. That enables some other rustc to\n+        // potentially make use of the available concurrency. That could even\n+        // *decrease* overall compile time if we're lucky. But yes, if no other\n+        // rustc can make use of the concurrency, then we've squandered it.\n+        //\n+        // However, keeping the queue full is also beneficial when we have a\n+        // surge in available concurrency. Then items can be taken from the\n+        // queue immediately, without having to wait for codegen.\n+        //\n+        // So, the heuristic below tries to keep one item in the queue for every\n+        // four running workers. Based on limited benchmarking, this appears to\n+        // be more than sufficient to avoid increasing compilation times.\n+        let quarter_of_workers = workers_running - 3 * workers_running / 4;\n+        items_in_queue > 0 && items_in_queue >= quarter_of_workers\n     }\n \n     fn maybe_start_llvm_timer<'a>(\n@@ -1554,56 +1634,59 @@ fn start_executing_work<B: ExtraBackendMethods>(\n pub struct WorkerFatalError;\n \n fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>) {\n-    thread::spawn(move || {\n-        // Set up a destructor which will fire off a message that we're done as\n-        // we exit.\n-        struct Bomb<B: ExtraBackendMethods> {\n-            coordinator_send: Sender<Box<dyn Any + Send>>,\n-            result: Option<Result<WorkItemResult<B>, FatalError>>,\n-            worker_id: usize,\n-        }\n-        impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n-            fn drop(&mut self) {\n-                let worker_id = self.worker_id;\n-                let msg = match self.result.take() {\n-                    Some(Ok(WorkItemResult::Compiled(m))) => {\n-                        Message::Done::<B> { result: Ok(m), worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsLink(m))) => {\n-                        Message::NeedsLink::<B> { module: m, worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n-                        Message::NeedsFatLTO::<B> { result: m, worker_id }\n-                    }\n-                    Some(Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))) => {\n-                        Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n-                    }\n-                    Some(Err(FatalError)) => {\n-                        Message::Done::<B> { result: Err(Some(WorkerFatalError)), worker_id }\n-                    }\n-                    None => Message::Done::<B> { result: Err(None), worker_id },\n-                };\n-                drop(self.coordinator_send.send(Box::new(msg)));\n+    let builder = thread::Builder::new().name(work.short_description());\n+    builder\n+        .spawn(move || {\n+            // Set up a destructor which will fire off a message that we're done as\n+            // we exit.\n+            struct Bomb<B: ExtraBackendMethods> {\n+                coordinator_send: Sender<Box<dyn Any + Send>>,\n+                result: Option<Result<WorkItemResult<B>, FatalError>>,\n+                worker_id: usize,\n+            }\n+            impl<B: ExtraBackendMethods> Drop for Bomb<B> {\n+                fn drop(&mut self) {\n+                    let worker_id = self.worker_id;\n+                    let msg = match self.result.take() {\n+                        Some(Ok(WorkItemResult::Compiled(m))) => {\n+                            Message::Done::<B> { result: Ok(m), worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsLink(m))) => {\n+                            Message::NeedsLink::<B> { module: m, worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsFatLTO(m))) => {\n+                            Message::NeedsFatLTO::<B> { result: m, worker_id }\n+                        }\n+                        Some(Ok(WorkItemResult::NeedsThinLTO(name, thin_buffer))) => {\n+                            Message::NeedsThinLTO::<B> { name, thin_buffer, worker_id }\n+                        }\n+                        Some(Err(FatalError)) => {\n+                            Message::Done::<B> { result: Err(Some(WorkerFatalError)), worker_id }\n+                        }\n+                        None => Message::Done::<B> { result: Err(None), worker_id },\n+                    };\n+                    drop(self.coordinator_send.send(Box::new(msg)));\n+                }\n             }\n-        }\n \n-        let mut bomb = Bomb::<B> {\n-            coordinator_send: cgcx.coordinator_send.clone(),\n-            result: None,\n-            worker_id: cgcx.worker,\n-        };\n+            let mut bomb = Bomb::<B> {\n+                coordinator_send: cgcx.coordinator_send.clone(),\n+                result: None,\n+                worker_id: cgcx.worker,\n+            };\n \n-        // Execute the work itself, and if it finishes successfully then flag\n-        // ourselves as a success as well.\n-        //\n-        // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n-        // as a diagnostic was already sent off to the main thread - just\n-        // surface that there was an error in this worker.\n-        bomb.result = {\n-            let _prof_timer = work.start_profiling(&cgcx);\n-            Some(execute_work_item(&cgcx, work))\n-        };\n-    });\n+            // Execute the work itself, and if it finishes successfully then flag\n+            // ourselves as a success as well.\n+            //\n+            // Note that we ignore any `FatalError` coming out of `execute_work_item`,\n+            // as a diagnostic was already sent off to the main thread - just\n+            // surface that there was an error in this worker.\n+            bomb.result = {\n+                let _prof_timer = work.start_profiling(&cgcx);\n+                Some(execute_work_item(&cgcx, work))\n+            };\n+        })\n+        .expect(\"failed to spawn thread\");\n }\n \n enum SharedEmitterMessage {"}, {"sha": "08e31c3b37f345eaed02667f0e933387e4a8841e", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -867,7 +867,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         cgu.name()\n     );\n \n-    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n+    if tcx.try_mark_green(&dep_node) {\n         // We can re-use either the pre- or the post-thinlto state. If no LTO is\n         // being performed then we can use post-LTO artifacts, otherwise we must\n         // reuse pre-LTO artifacts"}, {"sha": "afd83bfcb56922a4d8d791ac4530956c7c5d5a1f", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -95,6 +95,7 @@ pub enum TypeKind {\n     Token,\n     ScalableVector,\n     BFloat,\n+    X86_AMX,\n }\n \n // FIXME(mw): Anything that is produced via DepGraph::with_task() must implement"}, {"sha": "2c2330409fd709b51bd3c0195e2353713cb76fc5", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,6 +9,7 @@\n #![feature(or_patterns)]\n #![feature(associated_type_bounds)]\n #![recursion_limit = \"256\"]\n+#![feature(box_syntax)]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n //! The backend-agnostic functions of this crate use functions defined in various traits that"}, {"sha": "31d5c87182d3da0746d47f4d02e8b2409482aac9", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -199,7 +199,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             }\n \n             self.visit_local(&place_ref.local, context, location);\n-            self.visit_projection(place_ref.local, place_ref.projection, context, location);\n+            self.visit_projection(*place_ref, context, location);\n         }\n     }\n }\n@@ -281,7 +281,18 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                     Some(assignment_location) => {\n                         assignment_location.dominates(location, &self.dominators)\n                     }\n-                    None => false,\n+                    None => {\n+                        debug!(\"No first assignment found for {:?}\", local);\n+                        // We have not seen any assignment to the local yet,\n+                        // but before marking not_ssa, check if it is a ZST,\n+                        // in which case we don't need to initialize the local.\n+                        let ty = self.fx.mir.local_decls[local].ty;\n+                        let ty = self.fx.monomorphize(ty);\n+\n+                        let is_zst = self.fx.cx.layout_of(ty).is_zst();\n+                        debug!(\"is_zst: {}\", is_zst);\n+                        is_zst\n+                    }\n                 };\n                 if !ssa_read {\n                     self.not_ssa(local);"}, {"sha": "a8dda100763aae7c2aa076f0c609cf306c385455", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 68, "deletions": 104, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -146,24 +146,6 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n         }\n     }\n-\n-    // Generate sideeffect intrinsic if jumping to any of the targets can form\n-    // a loop.\n-    fn maybe_sideeffect<Bx: BuilderMethods<'a, 'tcx>>(\n-        &self,\n-        mir: &'tcx mir::Body<'tcx>,\n-        bx: &mut Bx,\n-        targets: &[mir::BasicBlock],\n-    ) {\n-        if bx.tcx().sess.opts.debugging_opts.insert_sideeffect {\n-            if targets.iter().any(|&target| {\n-                target <= self.bb\n-                    && target.start_location().is_predecessor_of(self.bb.start_location(), mir)\n-            }) {\n-                bx.sideeffect(false);\n-            }\n-        }\n-    }\n }\n \n /// Codegen implementations for some terminator variants.\n@@ -198,8 +180,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let discr = self.codegen_operand(&mut bx, &discr);\n         // `switch_ty` is redundant, sanity-check that.\n         assert_eq!(discr.layout.ty, switch_ty);\n-        helper.maybe_sideeffect(self.mir, &mut bx, targets.all_targets());\n-\n         let mut target_iter = targets.iter();\n         if target_iter.len() == 1 {\n             // If there are two targets (one conditional, one fallback), emit br instead of switch\n@@ -308,7 +288,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -337,7 +316,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             _ => (bx.get_fn_addr(drop_fn), FnAbi::of_instance(&bx, drop_fn, &[])),\n         };\n-        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         helper.do_call(\n             self,\n             &mut bx,\n@@ -379,7 +357,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -390,7 +367,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n-        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -491,9 +467,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fn_abi = FnAbi::of_instance(bx, instance, &[]);\n                 let llfn = bx.get_fn_addr(instance);\n \n-                if let Some((_, target)) = destination.as_ref() {\n-                    helper.maybe_sideeffect(self.mir, bx, &[*target]);\n-                }\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n                     self,\n@@ -507,7 +480,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             } else {\n                 // a NOP\n                 let target = destination.as_ref().unwrap().1;\n-                helper.maybe_sideeffect(self.mir, bx, &[target]);\n                 helper.funclet_br(self, bx, target)\n             }\n             true\n@@ -551,7 +523,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if let Some(ty::InstanceDef::DropGlue(_, None)) = def {\n             // Empty drop glue; a no-op.\n             let &(_, target) = destination.as_ref().unwrap();\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -586,7 +557,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n@@ -634,82 +604,85 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     location.val.store(&mut bx, tmp);\n                 }\n                 self.store_return(&mut bx, ret_dest, &fn_abi.ret, location.immediate());\n-\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n                 helper.funclet_br(self, &mut bx, *target);\n             }\n             return;\n         }\n \n-        if intrinsic.is_some() && intrinsic != Some(sym::drop_in_place) {\n-            let intrinsic = intrinsic.unwrap();\n-            let dest = match ret_dest {\n-                _ if fn_abi.ret.is_indirect() => llargs[0],\n-                ReturnDest::Nothing => {\n-                    bx.const_undef(bx.type_ptr_to(bx.arg_memory_ty(&fn_abi.ret)))\n-                }\n-                ReturnDest::IndirectOperand(dst, _) | ReturnDest::Store(dst) => dst.llval,\n-                ReturnDest::DirectOperand(_) => {\n-                    bug!(\"Cannot use direct operand with an intrinsic call\")\n-                }\n-            };\n+        match intrinsic {\n+            None | Some(sym::drop_in_place) => {}\n+            Some(sym::copy_nonoverlapping) => unreachable!(),\n+            Some(intrinsic) => {\n+                let dest = match ret_dest {\n+                    _ if fn_abi.ret.is_indirect() => llargs[0],\n+                    ReturnDest::Nothing => {\n+                        bx.const_undef(bx.type_ptr_to(bx.arg_memory_ty(&fn_abi.ret)))\n+                    }\n+                    ReturnDest::IndirectOperand(dst, _) | ReturnDest::Store(dst) => dst.llval,\n+                    ReturnDest::DirectOperand(_) => {\n+                        bug!(\"Cannot use direct operand with an intrinsic call\")\n+                    }\n+                };\n \n-            let args: Vec<_> = args\n-                .iter()\n-                .enumerate()\n-                .map(|(i, arg)| {\n-                    // The indices passed to simd_shuffle* in the\n-                    // third argument must be constant. This is\n-                    // checked by const-qualification, which also\n-                    // promotes any complex rvalues to constants.\n-                    if i == 2 && intrinsic.as_str().starts_with(\"simd_shuffle\") {\n-                        if let mir::Operand::Constant(constant) = arg {\n-                            let c = self.eval_mir_constant(constant);\n-                            let (llval, ty) = self.simd_shuffle_indices(\n-                                &bx,\n-                                constant.span,\n-                                constant.literal.ty,\n-                                c,\n-                            );\n-                            return OperandRef { val: Immediate(llval), layout: bx.layout_of(ty) };\n-                        } else {\n-                            span_bug!(span, \"shuffle indices must be constant\");\n+                let args: Vec<_> = args\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, arg)| {\n+                        // The indices passed to simd_shuffle* in the\n+                        // third argument must be constant. This is\n+                        // checked by const-qualification, which also\n+                        // promotes any complex rvalues to constants.\n+                        if i == 2 && intrinsic.as_str().starts_with(\"simd_shuffle\") {\n+                            if let mir::Operand::Constant(constant) = arg {\n+                                let c = self.eval_mir_constant(constant);\n+                                let (llval, ty) = self.simd_shuffle_indices(\n+                                    &bx,\n+                                    constant.span,\n+                                    constant.literal.ty,\n+                                    c,\n+                                );\n+                                return OperandRef {\n+                                    val: Immediate(llval),\n+                                    layout: bx.layout_of(ty),\n+                                };\n+                            } else {\n+                                span_bug!(span, \"shuffle indices must be constant\");\n+                            }\n                         }\n-                    }\n \n-                    self.codegen_operand(&mut bx, arg)\n-                })\n-                .collect();\n+                        self.codegen_operand(&mut bx, arg)\n+                    })\n+                    .collect();\n+\n+                Self::codegen_intrinsic_call(\n+                    &mut bx,\n+                    *instance.as_ref().unwrap(),\n+                    &fn_abi,\n+                    &args,\n+                    dest,\n+                    span,\n+                );\n \n-            Self::codegen_intrinsic_call(\n-                &mut bx,\n-                *instance.as_ref().unwrap(),\n-                &fn_abi,\n-                &args,\n-                dest,\n-                span,\n-            );\n+                if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n+                    self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n+                }\n \n-            if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n-                self.store_return(&mut bx, ret_dest, &fn_abi.ret, dst.llval);\n-            }\n+                if let Some((_, target)) = *destination {\n+                    helper.funclet_br(self, &mut bx, target);\n+                } else {\n+                    bx.unreachable();\n+                }\n \n-            if let Some((_, target)) = *destination {\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n-                helper.funclet_br(self, &mut bx, target);\n-            } else {\n-                bx.unreachable();\n+                return;\n             }\n-\n-            return;\n         }\n \n         // Split the rust-call tupled arguments off.\n         let (first_args, untuple) = if abi == Abi::RustCall && !args.is_empty() {\n             let (tup, args) = args.split_last().unwrap();\n             (args, Some(tup))\n         } else {\n-            (&args[..], None)\n+            (args, None)\n         };\n \n         'make_args: for (i, arg) in first_args.iter().enumerate() {\n@@ -811,9 +784,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => span_bug!(span, \"no llfn for call\"),\n         };\n \n-        if let Some((_, target)) = destination.as_ref() {\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n-        }\n         helper.do_call(\n             self,\n             &mut bx,\n@@ -963,22 +933,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::TerminatorKind::Goto { target } => {\n                 if bb == target {\n-                    // This is an unconditional branch back to this same basic\n-                    // block. That means we have something like a `loop {}`\n-                    // statement. Currently LLVM miscompiles this because it\n-                    // assumes forward progress. We want to prevent this in all\n-                    // cases, but that has a fairly high cost to compile times\n-                    // currently. Instead, try to handle this specific case\n-                    // which comes up commonly in practice (e.g., in embedded\n-                    // code).\n+                    // This is an unconditional branch back to this same basic block. That means we\n+                    // have something like a `loop {}` statement. LLVM versions before 12.0\n+                    // miscompile this because they assume forward progress. For older versions\n+                    // try to handle just this specific case which comes up commonly in practice\n+                    // (e.g., in embedded code).\n                     //\n-                    // The `true` here means we insert side effects regardless\n-                    // of -Zinsert-sideeffect being passed on unconditional\n-                    // branching to the same basic block.\n-                    bx.sideeffect(true);\n-                } else {\n-                    helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                    // NB: the `sideeffect` currently checks for the LLVM version used internally.\n+                    bx.sideeffect();\n                 }\n+\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "ea59e1831188b82bca2bb0db58037f9d3c1bcba9", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -320,6 +320,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<IndexVec<mir::Local, Vec<PerLocalVarDebugInfo<'tcx, Bx::DIVariable>>>> {\n         let full_debug_info = self.cx.sess().opts.debuginfo == DebugInfo::Full;\n \n+        let target_is_msvc = self.cx.sess().target.is_like_msvc;\n+\n         if !full_debug_info && self.cx.sess().fewer_names() {\n             return None;\n         }\n@@ -341,11 +343,29 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             && var.source_info.scope == mir::OUTERMOST_SOURCE_SCOPE\n                         {\n                             let arg_index = place.local.index() - 1;\n-\n-                            // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n-                            // offset in closures to account for the hidden environment?\n-                            // Also, is this `+ 1` needed at all?\n-                            VariableKind::ArgumentVariable(arg_index + 1)\n+                            if target_is_msvc {\n+                                // Rust compiler decomposes every &str or slice argument into two components:\n+                                // a pointer to the memory address where the data is stored and a usize representing\n+                                // the length of the str (or slice). These components will later be used to reconstruct\n+                                // the original argument inside the body of the function that owns it (see the\n+                                // definition of debug_introduce_local for more details).\n+                                //\n+                                // Since the original argument is declared inside a function rather than being passed\n+                                // in as an argument, it must be marked as a LocalVariable for MSVC debuggers to visualize\n+                                // its data correctly. (See issue #81894 for an in-depth description of the problem).\n+                                match *var_ty.kind() {\n+                                    ty::Ref(_, inner_type, _) => match *inner_type.kind() {\n+                                        ty::Slice(_) | ty::Str => VariableKind::LocalVariable,\n+                                        _ => VariableKind::ArgumentVariable(arg_index + 1),\n+                                    },\n+                                    _ => VariableKind::ArgumentVariable(arg_index + 1),\n+                                }\n+                            } else {\n+                                // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n+                                // offset in closures to account for the hidden environment?\n+                                // Also, is this `+ 1` needed at all?\n+                                VariableKind::ArgumentVariable(arg_index + 1)\n+                            }\n                         } else {\n                             VariableKind::LocalVariable\n                         };"}, {"sha": "8502309b90e5a1e7bfab7d1bd54cdc16b7d229e4", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -125,19 +125,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let offset = args[1].immediate();\n                 bx.gep(ptr, &[offset])\n             }\n-\n-            sym::copy_nonoverlapping => {\n-                copy_intrinsic(\n-                    bx,\n-                    false,\n-                    false,\n-                    substs.type_at(0),\n-                    args[1].immediate(),\n-                    args[0].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n             sym::copy => {\n                 copy_intrinsic(\n                     bx,"}, {"sha": "3f945478213494d7d071f6e5af4bb5f111b8a5d5", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -149,8 +149,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.set_personality_fn(cx.eh_personality());\n     }\n \n-    bx.sideeffect(false);\n-\n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it."}, {"sha": "629cb64d43ee1c55f01a5a9bce4421df09464120", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -325,7 +325,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                                 let er = scalar.valid_range_exclusive(bx.cx());\n                                 if er.end != er.start\n-                                    && scalar.valid_range.end() > scalar.valid_range.start()\n+                                    && scalar.valid_range.end() >= scalar.valid_range.start()\n                                 {\n                                     // We want `table[e as usize \u00b1 k]` to not\n                                     // have bound checks, and this is the most\n@@ -424,7 +424,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (bx, operand)\n             }\n \n-            mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+            mir::Rvalue::BinaryOp(op, box (ref lhs, ref rhs)) => {\n                 let lhs = self.codegen_operand(&mut bx, lhs);\n                 let rhs = self.codegen_operand(&mut bx, rhs);\n                 let llresult = match (lhs.val, rhs.val) {\n@@ -453,7 +453,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 (bx, operand)\n             }\n-            mir::Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+            mir::Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs)) => {\n                 let lhs = self.codegen_operand(&mut bx, lhs);\n                 let rhs = self.codegen_operand(&mut bx, rhs);\n                 let result = self.codegen_scalar_checked_binop("}, {"sha": "5523e5f2e8604d737f86987380b657182de113c0", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -115,6 +115,26 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 self.codegen_coverage(&mut bx, coverage.clone());\n                 bx\n             }\n+            mir::StatementKind::CopyNonOverlapping(box mir::CopyNonOverlapping {\n+                ref src,\n+                ref dst,\n+                ref count,\n+            }) => {\n+                let dst_val = self.codegen_operand(&mut bx, dst);\n+                let src_val = self.codegen_operand(&mut bx, src);\n+                let count = self.codegen_operand(&mut bx, count).immediate();\n+                let pointee_layout = dst_val\n+                    .layout\n+                    .pointee_info_at(&mut bx, rustc_target::abi::Size::ZERO)\n+                    .expect(\"Expected pointer\");\n+                let bytes = bx.mul(count, bx.const_usize(pointee_layout.size.bytes()));\n+\n+                let align = pointee_layout.align;\n+                let dst = dst_val.immediate();\n+                let src = src_val.immediate();\n+                bx.memcpy(dst, align, src, align, bytes, crate::MemFlags::empty());\n+                bx\n+            }\n             mir::StatementKind::FakeRead(..)\n             | mir::StatementKind::Retag { .. }\n             | mir::StatementKind::AscribeUserType(..)"}, {"sha": "8e79193759eb45bda1d576b43303d046d4b4eb8e", "filename": "compiler/rustc_codegen_ssa/src/mono_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -30,8 +30,8 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n             MonoItem::Static(def_id) => {\n                 cx.codegen_static(def_id, cx.tcx().is_mutable_static(def_id));\n             }\n-            MonoItem::GlobalAsm(hir_id) => {\n-                let item = cx.tcx().hir().expect_item(hir_id);\n+            MonoItem::GlobalAsm(item_id) => {\n+                let item = cx.tcx().hir().item(item_id);\n                 if let hir::ItemKind::GlobalAsm(ref ga) = item.kind {\n                     cx.codegen_global_asm(ga);\n                 } else {"}, {"sha": "777436ad2ae8fd9290405e131d2c15361958a25d", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -20,9 +20,10 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n-    /// Normally, sideeffect is only emitted if -Zinsert-sideeffect is passed;\n-    /// in some cases though we want to emit it regardless.\n-    fn sideeffect(&mut self, unconditional: bool);\n+    /// Emits a forced side effect.\n+    ///\n+    /// Currently has any effect only when LLVM versions prior to 12.0 are used as the backend.\n+    fn sideeffect(&mut self);\n     /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;"}, {"sha": "2e5a86b14c932640a1ebf61c849193144b951f46", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -19,13 +19,13 @@ rustc_graphviz = { path = \"../rustc_graphviz\" }\n cfg-if = \"0.1.2\"\n crossbeam-utils = { version = \"0.7\", features = [\"nightly\"] }\n stable_deref_trait = \"1.0.0\"\n-rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n-rayon-core = { version = \"0.3.0\", package = \"rustc-rayon-core\" }\n+rayon = { version = \"0.3.1\", package = \"rustc-rayon\" }\n+rayon-core = { version = \"0.3.1\", package = \"rustc-rayon-core\" }\n rustc-hash = \"1.1.0\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\"\n-measureme = \"9.0.0\"\n+measureme = \"9.1.0\"\n libc = \"0.2\"\n stacker = \"0.1.12\"\n tempfile = \"3.0.5\""}, {"sha": "1ebcb87818ecf3b53b0e4911caaccda2cac30575", "filename": "compiler/rustc_data_structures/src/const_cstr.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_data_structures%2Fsrc%2Fconst_cstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_data_structures%2Fsrc%2Fconst_cstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fconst_cstr.rs?ref=2285f11724e2fa3251c94c9ab7672544099600e2", "patch": "@@ -1,30 +0,0 @@\n-/// This macro creates a zero-overhead &CStr by adding a NUL terminator to\n-/// the string literal passed into it at compile-time. Use it like:\n-///\n-/// ```\n-///     let some_const_cstr = const_cstr!(\"abc\");\n-/// ```\n-///\n-/// The above is roughly equivalent to:\n-///\n-/// ```\n-///     let some_const_cstr = CStr::from_bytes_with_nul(b\"abc\\0\").unwrap()\n-/// ```\n-///\n-/// Note that macro only checks the string literal for internal NULs if\n-/// debug-assertions are enabled in order to avoid runtime overhead in release\n-/// builds.\n-#[macro_export]\n-macro_rules! const_cstr {\n-    ($s:expr) => {{\n-        use std::ffi::CStr;\n-\n-        let str_plus_nul = concat!($s, \"\\0\");\n-\n-        if cfg!(debug_assertions) {\n-            CStr::from_bytes_with_nul(str_plus_nul.as_bytes()).unwrap()\n-        } else {\n-            unsafe { CStr::from_bytes_with_nul_unchecked(str_plus_nul.as_bytes()) }\n-        }\n-    }};\n-}"}, {"sha": "681b49e2ea97bfaca49751da7d8ab1d79335ad1b", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -7,19 +7,30 @@ use std::hash::{Hash, Hasher};\n use std::mem::{self, MaybeUninit};\n \n #[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Clone, Copy)]\n+#[repr(C)]\n pub struct Fingerprint(u64, u64);\n \n impl Fingerprint {\n     pub const ZERO: Fingerprint = Fingerprint(0, 0);\n \n+    #[inline]\n+    pub fn new(_0: u64, _1: u64) -> Fingerprint {\n+        Fingerprint(_0, _1)\n+    }\n+\n     #[inline]\n     pub fn from_smaller_hash(hash: u64) -> Fingerprint {\n         Fingerprint(hash, hash)\n     }\n \n     #[inline]\n     pub fn to_smaller_hash(&self) -> u64 {\n-        self.0\n+        // Even though both halves of the fingerprint are expected to be good\n+        // quality hash values, let's still combine the two values because the\n+        // Fingerprints in DefPathHash have the StableCrateId portion which is\n+        // the same for all DefPathHashes from the same crate. Combining the\n+        // two halfs makes sure we get a good quality hash in such cases too.\n+        self.0.wrapping_mul(3).wrapping_add(self.1)\n     }\n \n     #[inline]\n@@ -92,8 +103,19 @@ impl<H: Hasher> FingerprintHasher for H {\n impl FingerprintHasher for crate::unhash::Unhasher {\n     #[inline]\n     fn write_fingerprint(&mut self, fingerprint: &Fingerprint) {\n-        // `Unhasher` only wants a single `u64`\n-        self.write_u64(fingerprint.0);\n+        // Even though both halves of the fingerprint are expected to be good\n+        // quality hash values, let's still combine the two values because the\n+        // Fingerprints in DefPathHash have the StableCrateId portion which is\n+        // the same for all DefPathHashes from the same crate. Combining the\n+        // two halfs makes sure we get a good quality hash in such cases too.\n+        //\n+        // Since `Unhasher` is used only in the context of HashMaps, it is OK\n+        // to combine the two components in an order-independent way (which is\n+        // cheaper than the more robust Fingerprint::to_smaller_hash()). For\n+        // HashMaps we don't really care if Fingerprint(x,y) and\n+        // Fingerprint(y, x) result in the same hash value. Collision\n+        // probability will still be much better than with FxHash.\n+        self.write_u64(fingerprint.0.wrapping_add(fingerprint.1));\n     }\n }\n "}, {"sha": "fcb2bca7b4cc195005315711ae01356760475abf", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -26,7 +26,6 @@\n #![feature(thread_id_value)]\n #![feature(extend_one)]\n #![feature(const_panic)]\n-#![cfg_attr(bootstrap, feature(min_const_generics))]\n #![feature(new_uninit)]\n #![feature(once_cell)]\n #![feature(maybe_uninit_uninit_array)]\n@@ -70,7 +69,6 @@ pub mod base_n;\n pub mod binary_search_util;\n pub mod box_region;\n pub mod captures;\n-pub mod const_cstr;\n pub mod flock;\n pub mod functor;\n pub mod fx;"}, {"sha": "48dfbba7504ef741578cb019f0a7a415aefdb22d", "filename": "compiler/rustc_data_structures/src/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,11 +9,11 @@ macro_rules! static_assert_size {\n #[macro_export]\n macro_rules! enum_from_u32 {\n     ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident = $e:expr,)*\n+        $($(#[$var_attr:meta])* $variant:ident = $e:expr,)*\n     }) => {\n         $(#[$attr])*\n         pub enum $name {\n-            $($variant = $e),*\n+            $($(#[$var_attr])* $variant = $e),*\n         }\n \n         impl $name {\n@@ -26,11 +26,11 @@ macro_rules! enum_from_u32 {\n         }\n     };\n     ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident,)*\n+        $($(#[$var_attr:meta])* $variant:ident,)*\n     }) => {\n         $(#[$attr])*\n         pub enum $name {\n-            $($variant,)*\n+            $($(#[$var_attr])* $variant,)*\n         }\n \n         impl $name {"}, {"sha": "51f851dc9469fe10dc0a07fea8d21e20c8a71b4a", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -608,7 +608,7 @@ pub fn print_time_passes_entry(\n         (None, None) => String::new(),\n     };\n \n-    println!(\"time: {:>7}{}\\t{}\", duration_to_secs_str(dur), mem_string, what);\n+    eprintln!(\"time: {:>7}{}\\t{}\", duration_to_secs_str(dur), mem_string, what);\n }\n \n // Hack up our own formatting for the duration to make it easier for scripts"}, {"sha": "ff28784a1dc4264b3c9f37fa95419028e16550bd", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -35,6 +35,7 @@ impl StableHasher {\n         StableHasher { state: SipHasher128::new_with_keys(0, 0) }\n     }\n \n+    #[inline]\n     pub fn finish<W: StableHasherResult>(self) -> W {\n         W::finish(self)\n     }"}, {"sha": "c521f2041d8919ceadb8c84242e951c5fbc8ead0", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -10,9 +10,9 @@ crate-type = [\"dylib\"]\n [dependencies]\n libc = \"0.2\"\n atty = \"0.2\"\n-tracing = { version = \"0.1.18\" }\n-tracing-subscriber = { version = \"0.2.13\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n-tracing-tree = \"0.1.6\"\n+tracing = { version = \"0.1.25\" }\n+tracing-subscriber = { version = \"0.2.16\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n+tracing-tree = \"0.1.9\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_target = { path = \"../rustc_target\" }\n@@ -34,6 +34,8 @@ rustc_interface = { path = \"../rustc_interface\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n+rustc_mir_build = { path = \"../rustc_mir_build\" }\n+rustc_typeck = { path = \"../rustc_typeck\" }\n \n [target.'cfg(windows)'.dependencies]\n winapi = { version = \"0.3\", features = [\"consoleapi\", \"debugapi\", \"processenv\"] }"}, {"sha": "01338359f1af1d063ddc3d16130fc221a31657f4", "filename": "compiler/rustc_driver/src/args.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fargs.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -3,7 +3,7 @@ use std::fmt;\n use std::fs;\n use std::io;\n \n-pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n+fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n     if let Some(path) = arg.strip_prefix('@') {\n         let file = match fs::read_to_string(path) {\n             Ok(file) => file,\n@@ -18,6 +18,20 @@ pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n     }\n }\n \n+pub fn arg_expand_all(at_args: &[String]) -> Vec<String> {\n+    let mut args = Vec::new();\n+    for arg in at_args {\n+        match arg_expand(arg.clone()) {\n+            Ok(arg) => args.extend(arg),\n+            Err(err) => rustc_session::early_error(\n+                rustc_session::config::ErrorOutputType::default(),\n+                &format!(\"Failed to load argument file: {}\", err),\n+            ),\n+        }\n+    }\n+    args\n+}\n+\n #[derive(Debug)]\n pub enum Error {\n     Utf8Error(Option<String>),"}, {"sha": "25a78041c0007bf4269efdb4dc62267e4b698e50", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -27,7 +27,6 @@ use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n use rustc_metadata::locator;\n use rustc_middle::middle::cstore::MetadataLoader;\n-use rustc_middle::ty::TyCtxt;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc_serialize::json::{self, ToJson};\n@@ -55,7 +54,7 @@ use std::process::{self, Command, Stdio};\n use std::str;\n use std::time::Instant;\n \n-mod args;\n+pub mod args;\n pub mod pretty;\n \n /// Exit status code used for successful compilation and help output.\n@@ -188,16 +187,8 @@ fn run_compiler(\n         Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n     >,\n ) -> interface::Result<()> {\n-    let mut args = Vec::new();\n-    for arg in at_args {\n-        match args::arg_expand(arg.clone()) {\n-            Ok(arg) => args.extend(arg),\n-            Err(err) => early_error(\n-                ErrorOutputType::default(),\n-                &format!(\"Failed to load argument file: {}\", err),\n-            ),\n-        }\n-    }\n+    let args = args::arg_expand_all(at_args);\n+\n     let diagnostic_output = emitter.map_or(DiagnosticOutput::Default, DiagnosticOutput::Raw);\n     let matches = match handle_options(&args) {\n         Some(matches) => matches,\n@@ -224,6 +215,7 @@ fn run_compiler(\n             diagnostic_output,\n             stderr: None,\n             lint_caps: Default::default(),\n+            parse_sess_created: None,\n             register_lints: None,\n             override_queries: None,\n             make_codegen_backend: make_codegen_backend.take().unwrap(),\n@@ -307,6 +299,7 @@ fn run_compiler(\n         diagnostic_output,\n         stderr: None,\n         lint_caps: Default::default(),\n+        parse_sess_created: None,\n         register_lints: None,\n         override_queries: None,\n         make_codegen_backend: make_codegen_backend.unwrap(),\n@@ -821,7 +814,7 @@ fn usage(verbose: bool, include_unstable_options: bool, nightly_build: bool) {\n     } else {\n         \"\\n    --help -v           Print the full set of options rustc accepts\"\n     };\n-    let at_path = if verbose && nightly_build {\n+    let at_path = if verbose {\n         \"    @path               Read newline separated options from `path`\\n\"\n     } else {\n         \"\"\n@@ -1240,7 +1233,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n \n     let num_frames = if backtrace { None } else { Some(2) };\n \n-    TyCtxt::try_print_query_stack(&handler, num_frames);\n+    interface::try_print_query_stack(&handler, num_frames);\n \n     #[cfg(windows)]\n     unsafe {"}, {"sha": "5512bd74453e54eace3b0bd17fc11847eb464f38", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 79, "deletions": 70, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -9,14 +9,14 @@ use rustc_hir_pretty as pprust_hir;\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_mir::util::{write_mir_graphviz, write_mir_pretty};\n-use rustc_session::config::{Input, PpMode, PpSourceMode};\n+use rustc_mir_build::thir;\n+use rustc_session::config::{Input, PpAstTreeMode, PpHirMode, PpMode, PpSourceMode};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::FileName;\n \n use std::cell::Cell;\n-use std::fs::File;\n-use std::io::Write;\n+use std::fmt::Write;\n use std::path::Path;\n \n pub use self::PpMode::*;\n@@ -44,43 +44,41 @@ where\n     F: FnOnce(&dyn PrinterSupport) -> A,\n {\n     match *ppmode {\n-        PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n+        Normal | EveryBodyLoops | Expanded => {\n             let annotation = NoAnn { sess, tcx };\n             f(&annotation)\n         }\n \n-        PpmIdentified | PpmExpandedIdentified => {\n+        Identified | ExpandedIdentified => {\n             let annotation = IdentifiedAnnotation { sess, tcx };\n             f(&annotation)\n         }\n-        PpmExpandedHygiene => {\n+        ExpandedHygiene => {\n             let annotation = HygieneAnnotation { sess };\n             f(&annotation)\n         }\n-        _ => panic!(\"Should use call_with_pp_support_hir\"),\n     }\n }\n-fn call_with_pp_support_hir<A, F>(ppmode: &PpSourceMode, tcx: TyCtxt<'_>, f: F) -> A\n+fn call_with_pp_support_hir<A, F>(ppmode: &PpHirMode, tcx: TyCtxt<'_>, f: F) -> A\n where\n     F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate<'_>) -> A,\n {\n     match *ppmode {\n-        PpmNormal => {\n+        PpHirMode::Normal => {\n             let annotation = NoAnn { sess: tcx.sess, tcx: Some(tcx) };\n             f(&annotation, tcx.hir().krate())\n         }\n \n-        PpmIdentified => {\n+        PpHirMode::Identified => {\n             let annotation = IdentifiedAnnotation { sess: tcx.sess, tcx: Some(tcx) };\n             f(&annotation, tcx.hir().krate())\n         }\n-        PpmTyped => {\n+        PpHirMode::Typed => {\n             abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n \n             let annotation = TypedAnnotation { tcx, maybe_typeck_results: Cell::new(None) };\n             tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().krate()))\n         }\n-        _ => panic!(\"Should use call_with_pp_support\"),\n     }\n }\n \n@@ -237,7 +235,7 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust_hir::AnnNode::Name(_) => {}\n             pprust_hir::AnnNode::Item(item) => {\n                 s.s.space();\n-                s.synth_comment(format!(\"hir_id: {}\", item.hir_id));\n+                s.synth_comment(format!(\"hir_id: {}\", item.hir_id()));\n             }\n             pprust_hir::AnnNode::SubItem(id) => {\n                 s.s.space();\n@@ -375,13 +373,14 @@ fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n     (src, src_name)\n }\n \n-fn write_output(out: Vec<u8>, ofile: Option<&Path>) {\n+fn write_or_print(out: &str, ofile: Option<&Path>) {\n     match ofile {\n-        None => print!(\"{}\", String::from_utf8(out).unwrap()),\n-        Some(p) => match File::create(p) {\n-            Ok(mut w) => w.write_all(&out).unwrap(),\n-            Err(e) => panic!(\"print-print failed to open {} due to {}\", p.display(), e),\n-        },\n+        None => print!(\"{}\", out),\n+        Some(p) => {\n+            if let Err(e) = std::fs::write(p, out) {\n+                panic!(\"print-print failed to write {} due to {}\", p.display(), e);\n+            }\n+        }\n     }\n }\n \n@@ -394,30 +393,32 @@ pub fn print_after_parsing(\n ) {\n     let (src, src_name) = get_source(input, sess);\n \n-    let mut out = String::new();\n-\n-    if let PpmSource(s) = ppm {\n-        // Silently ignores an identified node.\n-        let out = &mut out;\n-        call_with_pp_support(&s, sess, None, move |annotation| {\n-            debug!(\"pretty printing source code {:?}\", s);\n-            let sess = annotation.sess();\n-            let parse = &sess.parse_sess;\n-            *out = pprust::print_crate(\n-                sess.source_map(),\n-                krate,\n-                src_name,\n-                src,\n-                annotation.pp_ann(),\n-                false,\n-                parse.edition,\n-            )\n-        })\n-    } else {\n-        unreachable!();\n+    let out = match ppm {\n+        Source(s) => {\n+            // Silently ignores an identified node.\n+            call_with_pp_support(&s, sess, None, move |annotation| {\n+                debug!(\"pretty printing source code {:?}\", s);\n+                let sess = annotation.sess();\n+                let parse = &sess.parse_sess;\n+                pprust::print_crate(\n+                    sess.source_map(),\n+                    krate,\n+                    src_name,\n+                    src,\n+                    annotation.pp_ann(),\n+                    false,\n+                    parse.edition,\n+                )\n+            })\n+        }\n+        AstTree(PpAstTreeMode::Normal) => {\n+            debug!(\"pretty printing AST tree\");\n+            format!(\"{:#?}\", krate)\n+        }\n+        _ => unreachable!(),\n     };\n \n-    write_output(out.into_bytes(), ofile);\n+    write_or_print(&out, ofile);\n }\n \n pub fn print_after_hir_lowering<'tcx>(\n@@ -434,17 +435,14 @@ pub fn print_after_hir_lowering<'tcx>(\n \n     let (src, src_name) = get_source(input, tcx.sess);\n \n-    let mut out = String::new();\n-\n-    match ppm {\n-        PpmSource(s) => {\n+    let out = match ppm {\n+        Source(s) => {\n             // Silently ignores an identified node.\n-            let out = &mut out;\n             call_with_pp_support(&s, tcx.sess, Some(tcx), move |annotation| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n                 let parse = &sess.parse_sess;\n-                *out = pprust::print_crate(\n+                pprust::print_crate(\n                     sess.source_map(),\n                     krate,\n                     src_name,\n@@ -456,28 +454,42 @@ pub fn print_after_hir_lowering<'tcx>(\n             })\n         }\n \n-        PpmHir(s) => {\n-            let out = &mut out;\n-            call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                let sm = sess.source_map();\n-                *out = pprust_hir::print_crate(sm, krate, src_name, src, annotation.pp_ann())\n-            })\n+        AstTree(PpAstTreeMode::Expanded) => {\n+            debug!(\"pretty-printing expanded AST\");\n+            format!(\"{:#?}\", krate)\n         }\n \n-        PpmHirTree(s) => {\n-            let out = &mut out;\n-            call_with_pp_support_hir(&s, tcx, move |_annotation, krate| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                *out = format!(\"{:#?}\", krate);\n-            });\n+        Hir(s) => call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n+            debug!(\"pretty printing HIR {:?}\", s);\n+            let sess = annotation.sess();\n+            let sm = sess.source_map();\n+            pprust_hir::print_crate(sm, krate, src_name, src, annotation.pp_ann())\n+        }),\n+\n+        HirTree => call_with_pp_support_hir(&PpHirMode::Normal, tcx, move |_annotation, krate| {\n+            debug!(\"pretty printing HIR tree\");\n+            format!(\"{:#?}\", krate)\n+        }),\n+\n+        ThirTree => {\n+            let mut out = String::new();\n+            abort_on_err(rustc_typeck::check_crate(tcx), tcx.sess);\n+            debug!(\"pretty printing THIR tree\");\n+            for did in tcx.body_owners() {\n+                let hir = tcx.hir();\n+                let body = hir.body(hir.body_owned_by(hir.local_def_id_to_hir_id(did)));\n+                let arena = thir::Arena::default();\n+                let thir =\n+                    thir::build_thir(tcx, ty::WithOptConstParam::unknown(did), &arena, &body.value);\n+                let _ = writeln!(out, \"{:?}:\\n{:#?}\\n\", did, thir);\n+            }\n+            out\n         }\n \n         _ => unreachable!(),\n-    }\n+    };\n \n-    write_output(out.into_bytes(), ofile);\n+    write_or_print(&out, ofile);\n }\n \n // In an ideal world, this would be a public function called by the driver after\n@@ -494,16 +506,13 @@ fn print_with_analysis(\n     tcx.analysis(LOCAL_CRATE)?;\n \n     match ppm {\n-        PpmMir | PpmMirCFG => match ppm {\n-            PpmMir => write_mir_pretty(tcx, None, &mut out),\n-            PpmMirCFG => write_mir_graphviz(tcx, None, &mut out),\n-            _ => unreachable!(),\n-        },\n+        Mir => write_mir_pretty(tcx, None, &mut out).unwrap(),\n+        MirCFG => write_mir_graphviz(tcx, None, &mut out).unwrap(),\n         _ => unreachable!(),\n     }\n-    .unwrap();\n \n-    write_output(out, ofile);\n+    let out = std::str::from_utf8(&out).unwrap();\n+    write_or_print(out, ofile);\n \n     Ok(())\n }"}, {"sha": "4b529734328c7153387a4f2df61b5ce9cab8e7f2", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -103,7 +103,6 @@ E0198: include_str!(\"./error_codes/E0198.md\"),\n E0199: include_str!(\"./error_codes/E0199.md\"),\n E0200: include_str!(\"./error_codes/E0200.md\"),\n E0201: include_str!(\"./error_codes/E0201.md\"),\n-E0202: include_str!(\"./error_codes/E0202.md\"),\n E0203: include_str!(\"./error_codes/E0203.md\"),\n E0204: include_str!(\"./error_codes/E0204.md\"),\n E0205: include_str!(\"./error_codes/E0205.md\"),\n@@ -286,8 +285,11 @@ E0538: include_str!(\"./error_codes/E0538.md\"),\n E0539: include_str!(\"./error_codes/E0539.md\"),\n E0541: include_str!(\"./error_codes/E0541.md\"),\n E0542: include_str!(\"./error_codes/E0542.md\"),\n+E0543: include_str!(\"./error_codes/E0543.md\"),\n+E0545: include_str!(\"./error_codes/E0545.md\"),\n E0546: include_str!(\"./error_codes/E0546.md\"),\n E0547: include_str!(\"./error_codes/E0547.md\"),\n+E0549: include_str!(\"./error_codes/E0549.md\"),\n E0550: include_str!(\"./error_codes/E0550.md\"),\n E0551: include_str!(\"./error_codes/E0551.md\"),\n E0552: include_str!(\"./error_codes/E0552.md\"),\n@@ -604,13 +606,8 @@ E0781: include_str!(\"./error_codes/E0781.md\"),\n     E0523,\n //  E0526, // shuffle indices are not constant\n //  E0540, // multiple rustc_deprecated attributes\n-    E0543, // missing 'reason'\n     E0544, // multiple stability levels\n-    E0545, // incorrect 'issue'\n //  E0548, // replaced with a generic attribute input check\n-    // rustc_deprecated attribute must be paired with either stable or unstable\n-    // attribute\n-    E0549,\n     E0553, // multiple rustc_const_unstable attributes\n //  E0555, // replaced with a generic attribute input check\n //  E0558, // replaced with a generic attribute input check"}, {"sha": "0161c9325c2111e573d91a609bfa8a102fe608b2", "filename": "compiler/rustc_error_codes/src/error_codes/E0162.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0162.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0162.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0162.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,6 +1,6 @@\n #### Note: this error code is no longer emitted by the compiler.\n \n-An if-let pattern attempts to match the pattern, and enters the body if the\n+An `if let` pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding instead. For instance:\n "}, {"sha": "7bcd6c0cbf379fe8a0b09bd6b7d0930001ffb389", "filename": "compiler/rustc_error_codes/src/error_codes/E0165.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0165.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0165.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0165.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,6 +1,6 @@\n #### Note: this error code is no longer emitted by the compiler.\n \n-A while-let pattern attempts to match the pattern, and enters the body if the\n+A `while let` pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding inside a `loop` instead. For instance:\n "}, {"sha": "afc61ec2e48ff87fc80b0c9733a3c8360f624ccc", "filename": "compiler/rustc_error_codes/src/error_codes/E0202.md", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0202.md", "raw_url": "https://github.com/rust-lang/rust/raw/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0202.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0202.md?ref=2285f11724e2fa3251c94c9ab7672544099600e2", "patch": "@@ -1,15 +0,0 @@\n-Inherent associated types were part of [RFC 195] but are not yet implemented.\n-See [the tracking issue][iss8995] for the status of this implementation.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0202\n-struct Foo;\n-\n-impl Foo {\n-    type Bar = isize; // error!\n-}\n-```\n-\n-[RFC 195]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md\n-[iss8995]: https://github.com/rust-lang/rust/issues/8995"}, {"sha": "ba26f92e89f5e3f0b3204524c416a355a6f57251", "filename": "compiler/rustc_error_codes/src/error_codes/E0543.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0543.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0543.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0543.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,35 @@\n+The `reason` value is missing in a stability attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0543\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[stable(since = \"0.1.0\", feature = \"_deprecated_fn\")]\n+#[rustc_deprecated(\n+    since = \"1.0.0\"\n+)] // invalid\n+fn _deprecated_fn() {}\n+```\n+\n+To fix this issue, you need to provide the `reason` field. Example:\n+\n+```\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[stable(since = \"0.1.0\", feature = \"_deprecated_fn\")]\n+#[rustc_deprecated(\n+    since = \"1.0.0\",\n+    reason = \"explanation for deprecation\"\n+)] // ok!\n+fn _deprecated_fn() {}\n+```\n+\n+See the [How Rust is Made and \u201cNightly Rust\u201d][how-rust-made-nightly] appendix\n+of the Book and the [Stability attributes][stability-attributes] section of the\n+Rustc Dev Guide for more details.\n+\n+[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html"}, {"sha": "9fb935a3ab1abbb254c7b05631ec7c75cec17a52", "filename": "compiler/rustc_error_codes/src/error_codes/E0545.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0545.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0545.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0545.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,35 @@\n+The `issue` value is incorrect in a stability attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0545\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[unstable(feature = \"_unstable_fn\", issue = \"0\")] // invalid\n+fn _unstable_fn() {}\n+\n+#[rustc_const_unstable(feature = \"_unstable_const_fn\", issue = \"0\")] // invalid\n+fn _unstable_const_fn() {}\n+```\n+\n+To fix this issue, you need to provide a correct value in the `issue` field.\n+Example:\n+\n+```\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[unstable(feature = \"_unstable_fn\", issue = \"none\")] // ok!\n+fn _unstable_fn() {}\n+\n+#[rustc_const_unstable(feature = \"_unstable_const_fn\", issue = \"1\")] // ok!\n+fn _unstable_const_fn() {}\n+```\n+\n+See the [How Rust is Made and \u201cNightly Rust\u201d][how-rust-made-nightly] appendix\n+of the Book and the [Stability attributes][stability-attributes] section of the\n+Rustc Dev Guide for more details.\n+\n+[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html"}, {"sha": "d4b78e7e0d668d706a6aa45c8a0ef4415a1fdc9f", "filename": "compiler/rustc_error_codes/src/error_codes/E0549.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0549.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0549.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0549.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,37 @@\n+A `rustc_deprecated` attribute wasn't paired with a `stable`/`unstable`\n+attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0549\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[rustc_deprecated(\n+    since = \"1.0.1\",\n+    reason = \"explanation for deprecation\"\n+)] // invalid\n+fn _deprecated_fn() {}\n+```\n+\n+To fix this issue, you need to add also an attribute `stable` or `unstable`.\n+Example:\n+\n+```\n+#![feature(staged_api)]\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#[stable(since = \"1.0.0\", feature = \"test\")]\n+#[rustc_deprecated(\n+    since = \"1.0.1\",\n+    reason = \"explanation for deprecation\"\n+)] // ok!\n+fn _deprecated_fn() {}\n+```\n+\n+See the [How Rust is Made and \u201cNightly Rust\u201d][how-rust-made-nightly] appendix\n+of the Book and the [Stability attributes][stability-attributes] section of the\n+Rustc Dev Guide for more details.\n+\n+[how-rust-made-nightly]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+[stability-attributes]: https://rustc-dev-guide.rust-lang.org/stability.html"}, {"sha": "760c5897698aa6137cf5767a1d19ea16f2f6c81c", "filename": "compiler/rustc_error_codes/src/error_codes/E0761.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0761.md", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0761.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0761.md?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -2,7 +2,7 @@ Multiple candidate files were found for an out-of-line module.\n \n Erroneous code example:\n \n-```ignore (multiple source files required for compile_fail)\n+```ignore (Multiple source files are required for compile_fail.)\n // file: ambiguous_module/mod.rs\n \n fn foo() {}"}, {"sha": "14ddb3e20793a24a2db9eaf8829e23bab5aa563c", "filename": "compiler/rustc_error_codes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,5 @@\n-#![deny(invalid_codeblock_attributes)]\n+#![cfg_attr(bootstrap, deny(invalid_codeblock_attributes))]\n+#![cfg_attr(not(bootstrap), deny(rustdoc::invalid_codeblock_attributes))]\n //! This library is used to gather all error codes into one place,\n //! the goal being to make their maintenance easier.\n "}, {"sha": "ce5b130dd97fee2e8ce820bc97f069b56d9bd2fb", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -295,6 +295,7 @@ impl Diagnostic {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n+        assert!(!suggestion.is_empty());\n         self.suggestions.push(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: suggestion\n@@ -318,6 +319,10 @@ impl Diagnostic {\n         suggestions: Vec<Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n+        assert!(!suggestions.is_empty());\n+        for s in &suggestions {\n+            assert!(!s.is_empty());\n+        }\n         self.suggestions.push(CodeSuggestion {\n             substitutions: suggestions\n                 .into_iter()\n@@ -348,6 +353,7 @@ impl Diagnostic {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n+        assert!(!suggestion.is_empty());\n         self.suggestions.push(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: suggestion"}, {"sha": "9b6f67166bdaa7a4e2ce1640d108fa2e9a85e0c2", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1713,7 +1713,8 @@ impl EmitterWriter {\n         let max_line_num_len = if self.ui_testing {\n             ANONYMIZED_LINE_NUM.len()\n         } else {\n-            self.get_max_line_num(span, children).to_string().len()\n+            let n = self.get_max_line_num(span, children);\n+            num_decimal_digits(n)\n         };\n \n         match self.emit_message_default(span, message, code, level, max_line_num_len, false) {\n@@ -1941,6 +1942,30 @@ impl FileWithAnnotatedLines {\n     }\n }\n \n+// instead of taking the String length or dividing by 10 while > 0, we multiply a limit by 10 until\n+// we're higher. If the loop isn't exited by the `return`, the last multiplication will wrap, which\n+// is OK, because while we cannot fit a higher power of 10 in a usize, the loop will end anyway.\n+// This is also why we need the max number of decimal digits within a `usize`.\n+fn num_decimal_digits(num: usize) -> usize {\n+    #[cfg(target_pointer_width = \"64\")]\n+    const MAX_DIGITS: usize = 20;\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    const MAX_DIGITS: usize = 10;\n+\n+    #[cfg(target_pointer_width = \"16\")]\n+    const MAX_DIGITS: usize = 5;\n+\n+    let mut lim = 10;\n+    for num_digits in 1..MAX_DIGITS {\n+        if num < lim {\n+            return num_digits;\n+        }\n+        lim = lim.wrapping_mul(10);\n+    }\n+    MAX_DIGITS\n+}\n+\n fn replace_tabs(str: &str) -> String {\n     str.replace('\\t', \"    \")\n }"}, {"sha": "1db39fbfba5025ee5b7ec528ae4124fcd7523116", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -30,6 +30,7 @@ use rustc_span::{Loc, MultiSpan, Span};\n \n use std::borrow::Cow;\n use std::hash::{Hash, Hasher};\n+use std::num::NonZeroUsize;\n use std::panic;\n use std::path::Path;\n use std::{error, fmt};\n@@ -51,7 +52,7 @@ pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n // `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n // (See also the comment on `DiagnosticBuilderInner`.)\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n@@ -359,7 +360,7 @@ pub struct HandlerFlags {\n     pub can_emit_warnings: bool,\n     /// If true, error-level diagnostics are upgraded to bug-level.\n     /// (rustc: see `-Z treat-err-as-bug`)\n-    pub treat_err_as_bug: Option<usize>,\n+    pub treat_err_as_bug: Option<NonZeroUsize>,\n     /// If true, immediately emit diagnostics that would otherwise be buffered.\n     /// (rustc: see `-Z dont-buffer-diagnostics` and `-Z treat-err-as-bug`)\n     pub dont_buffer_diagnostics: bool,\n@@ -396,7 +397,7 @@ impl Handler {\n     pub fn with_tty_emitter(\n         color_config: ColorConfig,\n         can_emit_warnings: bool,\n-        treat_err_as_bug: Option<usize>,\n+        treat_err_as_bug: Option<NonZeroUsize>,\n         sm: Option<Lrc<SourceMap>>,\n     ) -> Self {\n         Self::with_tty_emitter_and_flags(\n@@ -424,7 +425,7 @@ impl Handler {\n \n     pub fn with_emitter(\n         can_emit_warnings: bool,\n-        treat_err_as_bug: Option<usize>,\n+        treat_err_as_bug: Option<NonZeroUsize>,\n         emitter: Box<dyn Emitter + sync::Send>,\n     ) -> Self {\n         Handler::with_emitter_and_flags(\n@@ -841,7 +842,7 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() >= c)\n+        self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() >= c.get())\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n@@ -950,7 +951,7 @@ impl HandlerInner {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n-        if self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() + 1 >= c) {\n+        if self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() + 1 >= c.get()) {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n         }\n@@ -1023,7 +1024,7 @@ impl HandlerInner {\n \n     fn panic_if_treat_err_as_bug(&self) {\n         if self.treat_err_as_bug() {\n-            match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n+            match (self.err_count(), self.flags.treat_err_as_bug.map(|c| c.get()).unwrap_or(0)) {\n                 (1, 1) => panic!(\"aborting due to `-Z treat-err-as-bug=1`\"),\n                 (0, _) | (1, _) => {}\n                 (count, as_bug) => panic!("}, {"sha": "dd93fe8350e4202a252f49edea62dac26ade56b7", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,12 +1,12 @@\n use crate::expand::{self, AstFragment, Invocation};\n-use crate::module::DirectoryOwnership;\n+use crate::module::DirOwnership;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n-use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream};\n+use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, LazyTokenStream, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, Attribute, NodeId, PatKind};\n-use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n+use rustc_ast::{self as ast, AstLike, Attribute, Item, NodeId, PatKind};\n+use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n@@ -44,7 +44,7 @@ pub enum Annotatable {\n     Variant(ast::Variant),\n }\n \n-impl HasAttrs for Annotatable {\n+impl AstLike for Annotatable {\n     fn attrs(&self) -> &[Attribute] {\n         match *self {\n             Annotatable::Item(ref item) => &item.attrs,\n@@ -80,6 +80,24 @@ impl HasAttrs for Annotatable {\n             Annotatable::Variant(v) => v.visit_attrs(f),\n         }\n     }\n+\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        match self {\n+            Annotatable::Item(item) => item.tokens_mut(),\n+            Annotatable::TraitItem(trait_item) => trait_item.tokens_mut(),\n+            Annotatable::ImplItem(impl_item) => impl_item.tokens_mut(),\n+            Annotatable::ForeignItem(foreign_item) => foreign_item.tokens_mut(),\n+            Annotatable::Stmt(stmt) => stmt.tokens_mut(),\n+            Annotatable::Expr(expr) => expr.tokens_mut(),\n+            Annotatable::Arm(arm) => arm.tokens_mut(),\n+            Annotatable::Field(field) => field.tokens_mut(),\n+            Annotatable::FieldPat(fp) => fp.tokens_mut(),\n+            Annotatable::GenericParam(gp) => gp.tokens_mut(),\n+            Annotatable::Param(p) => p.tokens_mut(),\n+            Annotatable::StructField(sf) => sf.tokens_mut(),\n+            Annotatable::Variant(v) => v.tokens_mut(),\n+        }\n+    }\n }\n \n impl Annotatable {\n@@ -756,8 +774,8 @@ impl SyntaxExtension {\n         name: Symbol,\n         attrs: &[ast::Attribute],\n     ) -> SyntaxExtension {\n-        let allow_internal_unstable = attr::allow_internal_unstable(sess, &attrs)\n-            .map(|features| features.collect::<Vec<Symbol>>().into());\n+        let allow_internal_unstable =\n+            attr::allow_internal_unstable(sess, &attrs).collect::<Vec<Symbol>>();\n \n         let mut local_inner_macros = false;\n         if let Some(macro_export) = sess.find_by_name(attrs, sym::macro_export) {\n@@ -770,19 +788,26 @@ impl SyntaxExtension {\n             .find_by_name(attrs, sym::rustc_builtin_macro)\n             .map(|a| a.value_str().unwrap_or(name));\n         let (stability, const_stability) = attr::find_stability(&sess, attrs, span);\n-        if const_stability.is_some() {\n+        if let Some((_, sp)) = const_stability {\n             sess.parse_sess\n                 .span_diagnostic\n-                .span_err(span, \"macros cannot have const stability attributes\");\n+                .struct_span_err(sp, \"macros cannot have const stability attributes\")\n+                .span_label(sp, \"invalid const stability attribute\")\n+                .span_label(\n+                    sess.source_map().guess_head_span(span),\n+                    \"const stability attribute affects this macro\",\n+                )\n+                .emit();\n         }\n \n         SyntaxExtension {\n             kind,\n             span,\n-            allow_internal_unstable,\n+            allow_internal_unstable: (!allow_internal_unstable.is_empty())\n+                .then(|| allow_internal_unstable.into()),\n             allow_internal_unsafe: sess.contains_name(attrs, sym::allow_internal_unsafe),\n             local_inner_macros,\n-            stability,\n+            stability: stability.map(|(s, _)| s),\n             deprecation: attr::find_deprecation(&sess, attrs).map(|(d, _)| d),\n             helper_attrs,\n             edition,\n@@ -890,21 +915,40 @@ pub trait ResolverExpand {\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Default)]\n pub struct ModuleData {\n+    /// Path to the module starting from the crate name, like `my_crate::foo::bar`.\n     pub mod_path: Vec<Ident>,\n-    pub directory: PathBuf,\n+    /// Stack of paths to files loaded by out-of-line module items,\n+    /// used to detect and report recursive module inclusions.\n+    pub file_path_stack: Vec<PathBuf>,\n+    /// Directory to search child module files in,\n+    /// often (but not necessarily) the parent of the top file path on the `file_path_stack`.\n+    pub dir_path: PathBuf,\n+}\n+\n+impl ModuleData {\n+    pub fn with_dir_path(&self, dir_path: PathBuf) -> ModuleData {\n+        ModuleData {\n+            mod_path: self.mod_path.clone(),\n+            file_path_stack: self.file_path_stack.clone(),\n+            dir_path,\n+        }\n+    }\n }\n \n #[derive(Clone)]\n pub struct ExpansionData {\n     pub id: ExpnId,\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n-    pub directory_ownership: DirectoryOwnership,\n+    pub dir_ownership: DirOwnership,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n+type OnExternModLoaded<'a> =\n+    Option<&'a dyn Fn(Ident, Vec<Attribute>, Vec<P<Item>>, Span) -> (Vec<Attribute>, Vec<P<Item>>)>;\n+\n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n /// -> expn_data` of their expansion context stored into their span.\n@@ -922,15 +966,15 @@ pub struct ExtCtxt<'a> {\n     /// Called directly after having parsed an external `mod foo;` in expansion.\n     ///\n     /// `Ident` is the module name.\n-    pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate, Ident)>,\n+    pub(super) extern_mod_loaded: OnExternModLoaded<'a>,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(\n         sess: &'a Session,\n         ecfg: expand::ExpansionConfig<'a>,\n         resolver: &'a mut dyn ResolverExpand,\n-        extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate, Ident)>,\n+        extern_mod_loaded: OnExternModLoaded<'a>,\n     ) -> ExtCtxt<'a> {\n         ExtCtxt {\n             sess,\n@@ -942,8 +986,8 @@ impl<'a> ExtCtxt<'a> {\n             current_expansion: ExpansionData {\n                 id: ExpnId::root(),\n                 depth: 0,\n-                module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n-                directory_ownership: DirectoryOwnership::Owned { relative: None },\n+                module: Default::default(),\n+                dir_ownership: DirOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n             },\n             force_mode: false,"}, {"sha": "a23731cf309a41a7749ad778779e5c31a6013d56", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 26, "deletions": 175, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,13 +1,9 @@\n //! Conditional compilation stripping.\n \n-use crate::base::Annotatable;\n-\n-use rustc_ast::attr::HasAttrs;\n-use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, LazyTokenStream, Spacing, TokenStream, TokenTree};\n-use rustc_ast::{self as ast, AttrItem, Attribute, MetaItem};\n+use rustc_ast::{self as ast, AstLike, AttrItem, Attribute, MetaItem};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -23,8 +19,6 @@ use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n-use smallvec::SmallVec;\n-\n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n     pub sess: &'a Session,\n@@ -205,11 +199,11 @@ pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features)\n     let unconfigured_attrs = krate.attrs.clone();\n     let diag = &sess.parse_sess.span_diagnostic;\n     let err_count = diag.err_count();\n-    let features = match strip_unconfigured.configure(krate.attrs) {\n+    let features = match strip_unconfigured.configure_krate_attrs(krate.attrs) {\n         None => {\n             // The entire crate is unconfigured.\n             krate.attrs = Vec::new();\n-            krate.module.items = Vec::new();\n+            krate.items = Vec::new();\n             Features::default()\n         }\n         Some(attrs) => {\n@@ -218,7 +212,9 @@ pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features)\n             if err_count == diag.err_count() {\n                 // Avoid reconfiguring malformed `cfg_attr`s.\n                 strip_unconfigured.features = Some(&features);\n-                strip_unconfigured.configure(unconfigured_attrs);\n+                // Run configuration again, this time with features available\n+                // so that we can perform feature-gating.\n+                strip_unconfigured.configure_krate_attrs(unconfigured_attrs);\n             }\n             features\n         }\n@@ -242,7 +238,7 @@ const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n     #the-cfg_attr-attribute>\";\n \n impl<'a> StripUnconfigured<'a> {\n-    pub fn configure<T: HasAttrs>(&mut self, mut node: T) -> Option<T> {\n+    pub fn configure<T: AstLike>(&mut self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n         if self.in_cfg(node.attrs()) {\n             Some(node)\n@@ -252,13 +248,26 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n+    fn configure_krate_attrs(\n+        &mut self,\n+        mut attrs: Vec<ast::Attribute>,\n+    ) -> Option<Vec<ast::Attribute>> {\n+        attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n+        if self.in_cfg(&attrs) {\n+            Some(attrs)\n+        } else {\n+            self.modified = true;\n+            None\n+        }\n+    }\n+\n     /// Parse and expand all `cfg_attr` attributes into a list of attributes\n     /// that are within each `cfg_attr` that has a true configuration predicate.\n     ///\n     /// Gives compiler warnings if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    pub fn process_cfg_attrs<T: HasAttrs>(&mut self, node: &mut T) {\n+    fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n             attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         });\n@@ -373,7 +382,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// Determines if a node with the given attributes should be included in this configuration.\n-    pub fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n+    fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n             if !is_cfg(self.sess, attr) {\n                 return true;\n@@ -413,16 +422,8 @@ impl<'a> StripUnconfigured<'a> {\n         })\n     }\n \n-    /// Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_expr_attrs(&mut self, attrs: &[Attribute]) {\n-        // flag the offending attributes\n-        for attr in attrs.iter() {\n-            self.maybe_emit_expr_attr_err(attr);\n-        }\n-    }\n-\n     /// If attributes are not allowed on expressions, emit an error for `attr`\n-    pub fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n+    crate fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n                 &self.sess.parse_sess,\n@@ -439,49 +440,10 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        let ast::ForeignMod { unsafety: _, abi: _, items } = foreign_mod;\n-        items.flat_map_in_place(|item| self.configure(item));\n-    }\n-\n-    fn configure_variant_data(&mut self, vdata: &mut ast::VariantData) {\n-        match vdata {\n-            ast::VariantData::Struct(fields, ..) | ast::VariantData::Tuple(fields, _) => {\n-                fields.flat_map_in_place(|field| self.configure(field))\n-            }\n-            ast::VariantData::Unit(_) => {}\n-        }\n-    }\n-\n-    pub fn configure_item_kind(&mut self, item: &mut ast::ItemKind) {\n-        match item {\n-            ast::ItemKind::Struct(def, _generics) | ast::ItemKind::Union(def, _generics) => {\n-                self.configure_variant_data(def)\n-            }\n-            ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n-                variants.flat_map_in_place(|variant| self.configure(variant));\n-                for variant in variants {\n-                    self.configure_variant_data(&mut variant.data);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    pub fn configure_expr_kind(&mut self, expr_kind: &mut ast::ExprKind) {\n-        match expr_kind {\n-            ast::ExprKind::Match(_m, arms) => {\n-                arms.flat_map_in_place(|arm| self.configure(arm));\n-            }\n-            ast::ExprKind::Struct(_path, fields, _base) => {\n-                fields.flat_map_in_place(|field| self.configure(field));\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     pub fn configure_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.visit_expr_attrs(expr.attrs());\n+        for attr in expr.attrs.iter() {\n+            self.maybe_emit_expr_attr_err(attr);\n+        }\n \n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n@@ -497,117 +459,6 @@ impl<'a> StripUnconfigured<'a> {\n \n         self.process_cfg_attrs(expr)\n     }\n-\n-    pub fn configure_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.kind {\n-            fields.flat_map_in_place(|field| self.configure(field));\n-        }\n-    }\n-\n-    pub fn configure_fn_decl(&mut self, fn_decl: &mut ast::FnDecl) {\n-        fn_decl.inputs.flat_map_in_place(|arg| self.configure(arg));\n-    }\n-\n-    pub fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n-        // Since the item itself has already been configured by the InvocationCollector,\n-        // we know that fold result vector will contain exactly one element\n-        match item {\n-            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n-            Annotatable::TraitItem(item) => {\n-                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n-            }\n-            Annotatable::ImplItem(item) => {\n-                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n-            }\n-            Annotatable::ForeignItem(item) => {\n-                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n-            }\n-            Annotatable::Stmt(stmt) => {\n-                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n-            }\n-            Annotatable::Expr(mut expr) => Annotatable::Expr({\n-                self.visit_expr(&mut expr);\n-                expr\n-            }),\n-            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n-            Annotatable::Field(field) => {\n-                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n-            }\n-            Annotatable::FieldPat(fp) => {\n-                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n-            }\n-            Annotatable::GenericParam(param) => {\n-                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n-            }\n-            Annotatable::Param(param) => {\n-                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n-            }\n-            Annotatable::StructField(sf) => {\n-                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n-            }\n-            Annotatable::Variant(v) => {\n-                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> MutVisitor for StripUnconfigured<'a> {\n-    fn visit_foreign_mod(&mut self, foreign_mod: &mut ast::ForeignMod) {\n-        self.configure_foreign_mod(foreign_mod);\n-        noop_visit_foreign_mod(foreign_mod, self);\n-    }\n-\n-    fn visit_item_kind(&mut self, item: &mut ast::ItemKind) {\n-        self.configure_item_kind(item);\n-        noop_visit_item_kind(item, self);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.configure_expr(expr);\n-        self.configure_expr_kind(&mut expr.kind);\n-        noop_visit_expr(expr, self);\n-    }\n-\n-    fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let mut expr = configure!(self, expr);\n-        self.configure_expr_kind(&mut expr.kind);\n-        noop_visit_expr(&mut expr, self);\n-        Some(expr)\n-    }\n-\n-    fn flat_map_generic_param(\n-        &mut self,\n-        param: ast::GenericParam,\n-    ) -> SmallVec<[ast::GenericParam; 1]> {\n-        noop_flat_map_generic_param(configure!(self, param), self)\n-    }\n-\n-    fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n-        noop_flat_map_stmt(configure!(self, stmt), self)\n-    }\n-\n-    fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        noop_flat_map_item(configure!(self, item), self)\n-    }\n-\n-    fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        noop_flat_map_assoc_item(configure!(self, item), self)\n-    }\n-\n-    fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        noop_flat_map_assoc_item(configure!(self, item), self)\n-    }\n-\n-    fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        self.configure_pat(pat);\n-        noop_visit_pat(pat, self)\n-    }\n-\n-    fn visit_fn_decl(&mut self, mut fn_decl: &mut P<ast::FnDecl>) {\n-        self.configure_fn_decl(&mut fn_decl);\n-        noop_visit_fn_decl(fn_decl, self);\n-    }\n }\n \n fn is_cfg(sess: &Session, attr: &Attribute) -> bool {"}, {"sha": "a1e5979f62dcdd3734dbba257d9d287f16152388", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 117, "deletions": 94, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -3,7 +3,7 @@ use crate::config::StripUnconfigured;\n use crate::configure;\n use crate::hygiene::SyntaxContext;\n use crate::mbe::macro_rules::annotate_err_with_kind;\n-use crate::module::{parse_external_mod, push_directory, Directory, DirectoryOwnership};\n+use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n \n use rustc_ast as ast;\n@@ -12,17 +12,17 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AttrItem, AttrStyle, Block, ItemKind, LitKind, MacArgs};\n-use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AstLike, AttrItem, AttrStyle, Block, Inline, ItemKind, LitKind, MacArgs};\n+use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n-use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n+use rustc_attr::{self as attr, is_builtin_attr};\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n-use rustc_parse::parser::{AttemptLocalParseRecovery, ForceCollect, Parser};\n+use rustc_parse::parser::{AttemptLocalParseRecovery, ForceCollect, GateOr, Parser, RecoverComma};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -301,6 +301,8 @@ pub enum InvocationKind {\n     },\n     Attr {\n         attr: ast::Attribute,\n+        // Re-insertion position for inert attributes.\n+        pos: usize,\n         item: Annotatable,\n         // Required for resolving derive helper attributes.\n         derives: Vec<Path>,\n@@ -350,24 +352,28 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         MacroExpander { cx, monotonic }\n     }\n \n+    // FIXME: Avoid visiting the crate as a `Mod` item,\n+    // make crate a first class expansion target instead.\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let mut module = ModuleData {\n-            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n-            directory: match self.cx.source_map().span_to_unmapped_path(krate.span) {\n-                FileName::Real(name) => name.into_local_path(),\n-                other => PathBuf::from(other.to_string()),\n-            },\n+        let file_path = match self.cx.source_map().span_to_unmapped_path(krate.span) {\n+            FileName::Real(name) => name.into_local_path(),\n+            other => PathBuf::from(other.to_string()),\n         };\n-        module.directory.pop();\n-        self.cx.root_path = module.directory.clone();\n-        self.cx.current_expansion.module = Rc::new(module);\n-\n-        let orig_mod_span = krate.module.inner;\n+        let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n+        self.cx.root_path = dir_path.clone();\n+        self.cx.current_expansion.module = Rc::new(ModuleData {\n+            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n+            file_path_stack: vec![file_path],\n+            dir_path,\n+        });\n \n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n-            kind: ast::ItemKind::Mod(krate.module),\n+            kind: ast::ItemKind::Mod(\n+                Unsafe::No,\n+                ModKind::Loaded(krate.items, Inline::Yes, krate.span)\n+            ),\n             ident: Ident::invalid(),\n             id: ast::DUMMY_NODE_ID,\n             vis: ast::Visibility {\n@@ -379,28 +385,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         })]);\n \n         match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n-            Some(ast::Item { attrs, kind: ast::ItemKind::Mod(module), .. }) => {\n+            Some(ast::Item {\n+                attrs,\n+                kind: ast::ItemKind::Mod(_, ModKind::Loaded(items, ..)),\n+                ..\n+            }) => {\n                 krate.attrs = attrs;\n-                krate.module = module;\n+                krate.items = items;\n             }\n             None => {\n                 // Resolution failed so we return an empty expansion\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod {\n-                    inner: orig_mod_span,\n-                    unsafety: Unsafe::No,\n-                    items: vec![],\n-                    inline: true,\n-                };\n+                krate.items = vec![];\n             }\n             Some(ast::Item { span, kind, .. }) => {\n                 krate.attrs = vec![];\n-                krate.module = ast::Mod {\n-                    inner: orig_mod_span,\n-                    unsafety: Unsafe::No,\n-                    items: vec![],\n-                    inline: true,\n-                };\n+                krate.items = vec![];\n                 self.cx.span_err(\n                     span,\n                     &format!(\n@@ -693,7 +693,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::Attr { attr, mut item, derives } => match ext {\n+            InvocationKind::Attr { attr, pos, mut item, derives } => match ext {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n@@ -724,7 +724,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                 ExpandResult::Retry(item) => {\n                                     // Reassemble the original invocation for retrying.\n                                     return ExpandResult::Retry(Invocation {\n-                                        kind: InvocationKind::Attr { attr, item, derives },\n+                                        kind: InvocationKind::Attr { attr, pos, item, derives },\n                                         ..invoc\n                                     });\n                                 }\n@@ -742,7 +742,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     if *mark_used {\n                         self.cx.sess.mark_attr_used(&attr);\n                     }\n-                    item.visit_attrs(|attrs| attrs.push(attr));\n+                    item.visit_attrs(|attrs| attrs.insert(pos, attr));\n                     fragment_kind.expect_from_annotatables(iter::once(item))\n                 }\n                 _ => unreachable!(),\n@@ -814,7 +814,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         impl<'ast, 'a> Visitor<'ast> for GateProcMacroInput<'a> {\n             fn visit_item(&mut self, item: &'ast ast::Item) {\n                 match &item.kind {\n-                    ast::ItemKind::Mod(module) if !module.inline => {\n+                    ast::ItemKind::Mod(_, mod_kind)\n+                        if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _)) =>\n+                    {\n                         feature_err(\n                             self.parse_sess,\n                             sym::proc_macro_hygiene,\n@@ -914,7 +916,9 @@ pub fn parse_ast_fragment<'a>(\n             }\n         }\n         AstFragmentKind::Ty => AstFragment::Ty(this.parse_ty()?),\n-        AstFragmentKind::Pat => AstFragment::Pat(this.parse_pat(None)?),\n+        AstFragmentKind::Pat => {\n+            AstFragment::Pat(this.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::No)?)\n+        }\n         AstFragmentKind::Arms\n         | AstFragmentKind::Fields\n         | AstFragmentKind::FieldPats\n@@ -999,17 +1003,20 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(\n         &mut self,\n-        (attr, derives): (ast::Attribute, Vec<Path>),\n+        (attr, pos, derives): (ast::Attribute, usize, Vec<Path>),\n         item: Annotatable,\n         kind: AstFragmentKind,\n     ) -> AstFragment {\n-        self.collect(kind, InvocationKind::Attr { attr, item, derives })\n+        self.collect(kind, InvocationKind::Attr { attr, pos, item, derives })\n     }\n \n     /// If `item` is an attribute invocation, remove the attribute and return it together with\n-    /// derives following it. We have to collect the derives in order to resolve legacy derive\n-    /// helpers (helpers written before derives that introduce them).\n-    fn take_first_attr(&mut self, item: &mut impl HasAttrs) -> Option<(ast::Attribute, Vec<Path>)> {\n+    /// its position and derives following it. We have to collect the derives in order to resolve\n+    /// legacy derive helpers (helpers written before derives that introduce them).\n+    fn take_first_attr(\n+        &mut self,\n+        item: &mut impl AstLike,\n+    ) -> Option<(ast::Attribute, usize, Vec<Path>)> {\n         let mut attr = None;\n \n         item.visit_attrs(|attrs| {\n@@ -1032,14 +1039,14 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                         })\n                         .collect();\n \n-                    (attr, following_derives)\n+                    (attr, attr_pos, following_derives)\n                 })\n         });\n \n         attr\n     }\n \n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n \n@@ -1239,10 +1246,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn visit_block(&mut self, block: &mut P<Block>) {\n-        let old_directory_ownership = self.cx.current_expansion.directory_ownership;\n-        self.cx.current_expansion.directory_ownership = DirectoryOwnership::UnownedViaBlock;\n+        let orig_dir_ownership = mem::replace(\n+            &mut self.cx.current_expansion.dir_ownership,\n+            DirOwnership::UnownedViaBlock,\n+        );\n         noop_visit_block(block, self);\n-        self.cx.current_expansion.directory_ownership = old_directory_ownership;\n+        self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n     }\n \n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -1269,69 +1278,83 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            ast::ItemKind::Mod(ref mut old_mod @ ast::Mod { .. }) if ident != Ident::invalid() => {\n-                let sess = &self.cx.sess.parse_sess;\n-                let orig_ownership = self.cx.current_expansion.directory_ownership;\n-                let mut module = (*self.cx.current_expansion.module).clone();\n-\n-                let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n-                let dir = Directory { ownership: orig_ownership, path: module.directory };\n-                let Directory { ownership, path } = if old_mod.inline {\n-                    // Inline `mod foo { ... }`, but we still need to push directories.\n-                    item.attrs = attrs;\n-                    push_directory(&self.cx.sess, ident, &item.attrs, dir)\n-                } else {\n-                    // We have an outline `mod foo;` so we need to parse the file.\n-                    let (new_mod, dir) = parse_external_mod(\n-                        &self.cx.sess,\n-                        ident,\n-                        span,\n-                        old_mod.unsafety,\n-                        dir,\n-                        &mut attrs,\n-                        pushed,\n-                    );\n-\n-                    let krate = ast::Crate {\n-                        span: new_mod.inner,\n-                        module: new_mod,\n-                        attrs,\n-                        proc_macros: vec![],\n-                    };\n-                    if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                        extern_mod_loaded(&krate, ident);\n+            ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::invalid() => {\n+                let (file_path, dir_path, dir_ownership) = match mod_kind {\n+                    ModKind::Loaded(_, inline, _) => {\n+                        // Inline `mod foo { ... }`, but we still need to push directories.\n+                        let (dir_path, dir_ownership) = mod_dir_path(\n+                            &self.cx.sess,\n+                            ident,\n+                            &attrs,\n+                            &self.cx.current_expansion.module,\n+                            self.cx.current_expansion.dir_ownership,\n+                            *inline,\n+                        );\n+                        item.attrs = attrs;\n+                        (None, dir_path, dir_ownership)\n                     }\n+                    ModKind::Unloaded => {\n+                        // We have an outline `mod foo;` so we need to parse the file.\n+                        let old_attrs_len = attrs.len();\n+                        let ParsedExternalMod {\n+                            mut items,\n+                            inner_span,\n+                            file_path,\n+                            dir_path,\n+                            dir_ownership,\n+                        } = parse_external_mod(\n+                            &self.cx.sess,\n+                            ident,\n+                            span,\n+                            &self.cx.current_expansion.module,\n+                            self.cx.current_expansion.dir_ownership,\n+                            &mut attrs,\n+                        );\n \n-                    *old_mod = krate.module;\n-                    item.attrs = krate.attrs;\n-                    // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n-                    item = match self.configure(item) {\n-                        Some(node) => node,\n-                        None => {\n-                            if *pushed {\n-                                sess.included_mod_stack.borrow_mut().pop();\n+                        if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n+                            (attrs, items) = extern_mod_loaded(ident, attrs, items, inner_span);\n+                        }\n+\n+                        *mod_kind = ModKind::Loaded(items, Inline::No, inner_span);\n+                        item.attrs = attrs;\n+                        if item.attrs.len() > old_attrs_len {\n+                            // If we loaded an out-of-line module and added some inner attributes,\n+                            // then we need to re-configure it and re-collect attributes for\n+                            // resolution and expansion.\n+                            item = configure!(self, item);\n+\n+                            if let Some(attr) = self.take_first_attr(&mut item) {\n+                                return self\n+                                    .collect_attr(\n+                                        attr,\n+                                        Annotatable::Item(item),\n+                                        AstFragmentKind::Items,\n+                                    )\n+                                    .make_items();\n                             }\n-                            return Default::default();\n                         }\n-                    };\n-                    dir\n+                        (Some(file_path), dir_path, dir_ownership)\n+                    }\n                 };\n \n                 // Set the module info before we flat map.\n-                self.cx.current_expansion.directory_ownership = ownership;\n-                module.directory = path;\n+                let mut module = self.cx.current_expansion.module.with_dir_path(dir_path);\n                 module.mod_path.push(ident);\n+                if let Some(file_path) = file_path {\n+                    module.file_path_stack.push(file_path);\n+                }\n+\n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n+                let orig_dir_ownership =\n+                    mem::replace(&mut self.cx.current_expansion.dir_ownership, dir_ownership);\n \n                 let result = noop_flat_map_item(item, self);\n \n                 // Restore the module info.\n+                self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.directory_ownership = orig_ownership;\n-                if *pushed {\n-                    sess.included_mod_stack.borrow_mut().pop();\n-                }\n+\n                 result\n             }\n             _ => {"}, {"sha": "1a93975533de03bbafc3c72e1c2fef3c3e55808b", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,5 +1,7 @@\n+#![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(destructuring_assignment)]\n #![feature(or_patterns)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]"}, {"sha": "c5ce0baaa8f6a13d33eeca78cc2cb02252ccf5af", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 181, "deletions": 213, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,236 +1,175 @@\n-use rustc_ast::{token, Attribute, Mod, Unsafe};\n-use rustc_errors::{struct_span_err, PResult};\n+use crate::base::ModuleData;\n+use rustc_ast::ptr::P;\n+use rustc_ast::{token, Attribute, Inline, Item};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n-use rustc_span::source_map::{FileName, Span};\n use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n \n use std::path::{self, Path, PathBuf};\n \n-#[derive(Clone)]\n-pub struct Directory {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n-}\n-\n #[derive(Copy, Clone)]\n-pub enum DirectoryOwnership {\n+pub enum DirOwnership {\n     Owned {\n         // None if `mod.rs`, `Some(\"foo\")` if we're in `foo.rs`.\n         relative: Option<Ident>,\n     },\n     UnownedViaBlock,\n-    UnownedViaMod,\n }\n \n-/// Information about the path to a module.\n // Public for rustfmt usage.\n-pub struct ModulePath<'a> {\n-    name: String,\n-    path_exists: bool,\n-    pub result: PResult<'a, ModulePathSuccess>,\n+pub struct ModulePathSuccess {\n+    pub file_path: PathBuf,\n+    pub dir_ownership: DirOwnership,\n }\n \n-// Public for rustfmt usage.\n-pub struct ModulePathSuccess {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n+crate struct ParsedExternalMod {\n+    pub items: Vec<P<Item>>,\n+    pub inner_span: Span,\n+    pub file_path: PathBuf,\n+    pub dir_path: PathBuf,\n+    pub dir_ownership: DirOwnership,\n+}\n+\n+pub enum ModError<'a> {\n+    CircularInclusion(Vec<PathBuf>),\n+    ModInBlock(Option<Ident>),\n+    FileNotFound(Ident, PathBuf),\n+    MultipleCandidates(Ident, String, String),\n+    ParserError(DiagnosticBuilder<'a>),\n }\n \n crate fn parse_external_mod(\n     sess: &Session,\n-    id: Ident,\n+    ident: Ident,\n     span: Span, // The span to blame on errors.\n-    unsafety: Unsafe,\n-    Directory { mut ownership, path }: Directory,\n+    module: &ModuleData,\n+    mut dir_ownership: DirOwnership,\n     attrs: &mut Vec<Attribute>,\n-    pop_mod_stack: &mut bool,\n-) -> (Mod, Directory) {\n+) -> ParsedExternalMod {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n-    let result: PResult<'_, _> = try {\n+    let result: Result<_, ModError<'_>> = try {\n         // Extract the file path and the new ownership.\n-        let mp = submod_path(sess, id, span, &attrs, ownership, &path)?;\n-        ownership = mp.ownership;\n+        let mp = mod_file_path(sess, ident, &attrs, &module.dir_path, dir_ownership)?;\n+        dir_ownership = mp.dir_ownership;\n \n         // Ensure file paths are acyclic.\n-        let mut included_mod_stack = sess.parse_sess.included_mod_stack.borrow_mut();\n-        error_on_circular_module(&sess.parse_sess, span, &mp.path, &included_mod_stack)?;\n-        included_mod_stack.push(mp.path.clone());\n-        *pop_mod_stack = true; // We have pushed, so notify caller.\n-        drop(included_mod_stack);\n+        if let Some(pos) = module.file_path_stack.iter().position(|p| p == &mp.file_path) {\n+            Err(ModError::CircularInclusion(module.file_path_stack[pos..].to_vec()))?;\n+        }\n \n         // Actually parse the external file as a module.\n-        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n-        let mut module = parser.parse_mod(&token::Eof, unsafety)?;\n-        module.0.inline = false;\n-        module\n+        let mut parser = new_parser_from_file(&sess.parse_sess, &mp.file_path, Some(span));\n+        let (mut inner_attrs, items, inner_span) =\n+            parser.parse_mod(&token::Eof).map_err(|err| ModError::ParserError(err))?;\n+        attrs.append(&mut inner_attrs);\n+        (items, inner_span, mp.file_path)\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_else(|_| {\n-        let module = Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false };\n-        (module, Vec::new())\n-    });\n-    attrs.append(&mut new_attrs);\n-\n-    // Extract the directory path for submodules of `module`.\n-    let path = sess.source_map().span_to_unmapped_path(module.inner);\n-    let mut path = match path {\n-        FileName::Real(name) => name.into_local_path(),\n-        other => PathBuf::from(other.to_string()),\n-    };\n-    path.pop();\n+    let (items, inner_span, file_path) =\n+        result.map_err(|err| err.report(sess, span)).unwrap_or_default();\n \n-    (module, Directory { ownership, path })\n-}\n+    // Extract the directory path for submodules of the module.\n+    let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n \n-fn error_on_circular_module<'a>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path: &Path,\n-    included_mod_stack: &[PathBuf],\n-) -> PResult<'a, ()> {\n-    if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n-        let mut err = String::from(\"circular modules: \");\n-        for p in &included_mod_stack[i..] {\n-            err.push_str(&p.to_string_lossy());\n-            err.push_str(\" -> \");\n-        }\n-        err.push_str(&path.to_string_lossy());\n-        return Err(sess.span_diagnostic.struct_span_err(span, &err[..]));\n-    }\n-    Ok(())\n+    ParsedExternalMod { items, inner_span, file_path, dir_path, dir_ownership }\n }\n \n-crate fn push_directory(\n+crate fn mod_dir_path(\n     sess: &Session,\n-    id: Ident,\n+    ident: Ident,\n     attrs: &[Attribute],\n-    Directory { mut ownership, mut path }: Directory,\n-) -> Directory {\n-    if let Some(filename) = sess.first_attr_value_str_by_name(attrs, sym::path) {\n-        path.push(&*filename.as_str());\n-        ownership = DirectoryOwnership::Owned { relative: None };\n-    } else {\n-        // We have to push on the current module name in the case of relative\n-        // paths in order to ensure that any additional module paths from inline\n-        // `mod x { ... }` come after the relative extension.\n-        //\n-        // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n-        // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n-        if let DirectoryOwnership::Owned { relative } = &mut ownership {\n-            if let Some(ident) = relative.take() {\n-                // Remove the relative offset.\n-                path.push(&*ident.as_str());\n+    module: &ModuleData,\n+    mut dir_ownership: DirOwnership,\n+    inline: Inline,\n+) -> (PathBuf, DirOwnership) {\n+    match inline {\n+        Inline::Yes => {\n+            if let Some(file_path) = mod_file_path_from_attr(sess, attrs, &module.dir_path) {\n+                // For inline modules file path from `#[path]` is actually the directory path\n+                // for historical reasons, so we don't pop the last segment here.\n+                return (file_path, DirOwnership::Owned { relative: None });\n             }\n-        }\n-        path.push(&*id.as_str());\n-    }\n-    Directory { ownership, path }\n-}\n \n-fn submod_path<'a>(\n-    sess: &'a Session,\n-    id: Ident,\n-    span: Span,\n-    attrs: &[Attribute],\n-    ownership: DirectoryOwnership,\n-    dir_path: &Path,\n-) -> PResult<'a, ModulePathSuccess> {\n-    if let Some(path) = submod_path_from_attr(sess, attrs, dir_path) {\n-        let ownership = match path.file_name().and_then(|s| s.to_str()) {\n-            // All `#[path]` files are treated as though they are a `mod.rs` file.\n-            // This means that `mod foo;` declarations inside `#[path]`-included\n-            // files are siblings,\n+            // We have to push on the current module name in the case of relative\n+            // paths in order to ensure that any additional module paths from inline\n+            // `mod x { ... }` come after the relative extension.\n             //\n-            // Note that this will produce weirdness when a file named `foo.rs` is\n-            // `#[path]` included and contains a `mod foo;` declaration.\n-            // If you encounter this, it's your own darn fault :P\n-            Some(_) => DirectoryOwnership::Owned { relative: None },\n-            _ => DirectoryOwnership::UnownedViaMod,\n-        };\n-        return Ok(ModulePathSuccess { ownership, path });\n-    }\n+            // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n+            // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n+            let mut dir_path = module.dir_path.clone();\n+            if let DirOwnership::Owned { relative } = &mut dir_ownership {\n+                if let Some(ident) = relative.take() {\n+                    // Remove the relative offset.\n+                    dir_path.push(&*ident.as_str());\n+                }\n+            }\n+            dir_path.push(&*ident.as_str());\n \n-    let relative = match ownership {\n-        DirectoryOwnership::Owned { relative } => relative,\n-        DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n-    };\n-    let ModulePath { path_exists, name, result } =\n-        default_submod_path(&sess.parse_sess, id, span, relative, dir_path);\n-    match ownership {\n-        DirectoryOwnership::Owned { .. } => Ok(result?),\n-        DirectoryOwnership::UnownedViaBlock => {\n-            let _ = result.map_err(|mut err| err.cancel());\n-            error_decl_mod_in_block(&sess.parse_sess, span, path_exists, &name)\n+            (dir_path, dir_ownership)\n         }\n-        DirectoryOwnership::UnownedViaMod => {\n-            let _ = result.map_err(|mut err| err.cancel());\n-            error_cannot_declare_mod_here(&sess.parse_sess, span, path_exists, &name)\n+        Inline::No => {\n+            // FIXME: This is a subset of `parse_external_mod` without actual parsing,\n+            // check whether the logic for unloaded, loaded and inline modules can be unified.\n+            let file_path = mod_file_path(sess, ident, &attrs, &module.dir_path, dir_ownership)\n+                .map(|mp| {\n+                    dir_ownership = mp.dir_ownership;\n+                    mp.file_path\n+                })\n+                .unwrap_or_default();\n+\n+            // Extract the directory path for submodules of the module.\n+            let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n+\n+            (dir_path, dir_ownership)\n         }\n     }\n }\n \n-fn error_decl_mod_in_block<'a, T>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path_exists: bool,\n-    name: &str,\n-) -> PResult<'a, T> {\n-    let msg = \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n-    let mut err = sess.span_diagnostic.struct_span_err(span, msg);\n-    if path_exists {\n-        let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\", name);\n-        err.span_note(span, &msg);\n+fn mod_file_path<'a>(\n+    sess: &'a Session,\n+    ident: Ident,\n+    attrs: &[Attribute],\n+    dir_path: &Path,\n+    dir_ownership: DirOwnership,\n+) -> Result<ModulePathSuccess, ModError<'a>> {\n+    if let Some(file_path) = mod_file_path_from_attr(sess, attrs, dir_path) {\n+        // All `#[path]` files are treated as though they are a `mod.rs` file.\n+        // This means that `mod foo;` declarations inside `#[path]`-included\n+        // files are siblings,\n+        //\n+        // Note that this will produce weirdness when a file named `foo.rs` is\n+        // `#[path]` included and contains a `mod foo;` declaration.\n+        // If you encounter this, it's your own darn fault :P\n+        let dir_ownership = DirOwnership::Owned { relative: None };\n+        return Ok(ModulePathSuccess { file_path, dir_ownership });\n     }\n-    Err(err)\n-}\n \n-fn error_cannot_declare_mod_here<'a, T>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path_exists: bool,\n-    name: &str,\n-) -> PResult<'a, T> {\n-    let mut err =\n-        sess.span_diagnostic.struct_span_err(span, \"cannot declare a new module at this location\");\n-    if !span.is_dummy() {\n-        if let FileName::Real(src_name) = sess.source_map().span_to_filename(span) {\n-            let src_path = src_name.into_local_path();\n-            if let Some(stem) = src_path.file_stem() {\n-                let mut dest_path = src_path.clone();\n-                dest_path.set_file_name(stem);\n-                dest_path.push(\"mod.rs\");\n-                err.span_note(\n-                    span,\n-                    &format!(\n-                        \"maybe move this module `{}` to its own directory via `{}`\",\n-                        src_path.display(),\n-                        dest_path.display()\n-                    ),\n-                );\n-            }\n-        }\n-    }\n-    if path_exists {\n-        err.span_note(\n-            span,\n-            &format!(\"... or maybe `use` the module `{}` instead of possibly redeclaring it\", name),\n-        );\n+    let relative = match dir_ownership {\n+        DirOwnership::Owned { relative } => relative,\n+        DirOwnership::UnownedViaBlock => None,\n+    };\n+    let result = default_submod_path(&sess.parse_sess, ident, relative, dir_path);\n+    match dir_ownership {\n+        DirOwnership::Owned { .. } => result,\n+        DirOwnership::UnownedViaBlock => Err(ModError::ModInBlock(match result {\n+            Ok(_) | Err(ModError::MultipleCandidates(..)) => Some(ident),\n+            _ => None,\n+        })),\n     }\n-    Err(err)\n }\n \n /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n /// The provided `dir_path` is joined with the `path_string`.\n-pub(super) fn submod_path_from_attr(\n+fn mod_file_path_from_attr(\n     sess: &Session,\n     attrs: &[Attribute],\n     dir_path: &Path,\n ) -> Option<PathBuf> {\n     // Extract path string from first `#[path = \"path_string\"]` attribute.\n-    let path_string = sess.first_attr_value_str_by_name(attrs, sym::path)?;\n-    let path_string = path_string.as_str();\n+    let path_string = sess.first_attr_value_str_by_name(attrs, sym::path)?.as_str();\n \n     // On windows, the base path might have the form\n     // `\\\\?\\foo\\bar` in which case it does not tolerate\n@@ -246,15 +185,14 @@ pub(super) fn submod_path_from_attr(\n // Public for rustfmt usage.\n pub fn default_submod_path<'a>(\n     sess: &'a ParseSess,\n-    id: Ident,\n-    span: Span,\n+    ident: Ident,\n     relative: Option<Ident>,\n     dir_path: &Path,\n-) -> ModulePath<'a> {\n+) -> Result<ModulePathSuccess, ModError<'a>> {\n     // If we're in a foo.rs file instead of a mod.rs file,\n     // we need to look for submodules in\n-    // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n-    // `./<id>.rs` and `./<id>/mod.rs`.\n+    // `./foo/<ident>.rs` and `./foo/<ident>/mod.rs` rather than\n+    // `./<ident>.rs` and `./<ident>/mod.rs`.\n     let relative_prefix_string;\n     let relative_prefix = if let Some(ident) = relative {\n         relative_prefix_string = format!(\"{}{}\", ident.name, path::MAIN_SEPARATOR);\n@@ -263,7 +201,7 @@ pub fn default_submod_path<'a>(\n         \"\"\n     };\n \n-    let mod_name = id.name.to_string();\n+    let mod_name = ident.name.to_string();\n     let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n     let secondary_path_str =\n         format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n@@ -272,44 +210,74 @@ pub fn default_submod_path<'a>(\n     let default_exists = sess.source_map().file_exists(&default_path);\n     let secondary_exists = sess.source_map().file_exists(&secondary_path);\n \n-    let result = match (default_exists, secondary_exists) {\n+    match (default_exists, secondary_exists) {\n         (true, false) => Ok(ModulePathSuccess {\n-            path: default_path,\n-            ownership: DirectoryOwnership::Owned { relative: Some(id) },\n+            file_path: default_path,\n+            dir_ownership: DirOwnership::Owned { relative: Some(ident) },\n         }),\n         (false, true) => Ok(ModulePathSuccess {\n-            path: secondary_path,\n-            ownership: DirectoryOwnership::Owned { relative: None },\n+            file_path: secondary_path,\n+            dir_ownership: DirOwnership::Owned { relative: None },\n         }),\n-        (false, false) => {\n-            let mut err = struct_span_err!(\n-                sess.span_diagnostic,\n-                span,\n-                E0583,\n-                \"file not found for module `{}`\",\n-                mod_name,\n-            );\n-            err.help(&format!(\n-                \"to create the module `{}`, create file \\\"{}\\\"\",\n-                mod_name,\n-                default_path.display(),\n-            ));\n-            Err(err)\n-        }\n+        (false, false) => Err(ModError::FileNotFound(ident, default_path)),\n         (true, true) => {\n-            let mut err = struct_span_err!(\n-                sess.span_diagnostic,\n-                span,\n-                E0761,\n-                \"file for module `{}` found at both {} and {}\",\n-                mod_name,\n-                default_path_str,\n-                secondary_path_str,\n-            );\n-            err.help(\"delete or rename one of them to remove the ambiguity\");\n-            Err(err)\n+            Err(ModError::MultipleCandidates(ident, default_path_str, secondary_path_str))\n         }\n-    };\n+    }\n+}\n \n-    ModulePath { name: mod_name, path_exists: default_exists || secondary_exists, result }\n+impl ModError<'_> {\n+    fn report(self, sess: &Session, span: Span) {\n+        let diag = &sess.parse_sess.span_diagnostic;\n+        match self {\n+            ModError::CircularInclusion(file_paths) => {\n+                let mut msg = String::from(\"circular modules: \");\n+                for file_path in &file_paths {\n+                    msg.push_str(&file_path.display().to_string());\n+                    msg.push_str(\" -> \");\n+                }\n+                msg.push_str(&file_paths[0].display().to_string());\n+                diag.struct_span_err(span, &msg)\n+            }\n+            ModError::ModInBlock(ident) => {\n+                let msg = \"cannot declare a non-inline module inside a block unless it has a path attribute\";\n+                let mut err = diag.struct_span_err(span, msg);\n+                if let Some(ident) = ident {\n+                    let note =\n+                        format!(\"maybe `use` the module `{}` instead of redeclaring it\", ident);\n+                    err.span_note(span, &note);\n+                }\n+                err\n+            }\n+            ModError::FileNotFound(ident, default_path) => {\n+                let mut err = struct_span_err!(\n+                    diag,\n+                    span,\n+                    E0583,\n+                    \"file not found for module `{}`\",\n+                    ident,\n+                );\n+                err.help(&format!(\n+                    \"to create the module `{}`, create file \\\"{}\\\"\",\n+                    ident,\n+                    default_path.display(),\n+                ));\n+                err\n+            }\n+            ModError::MultipleCandidates(ident, default_path_short, secondary_path_short) => {\n+                let mut err = struct_span_err!(\n+                    diag,\n+                    span,\n+                    E0761,\n+                    \"file for module `{}` found at both {} and {}\",\n+                    ident,\n+                    default_path_short,\n+                    secondary_path_short,\n+                );\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            ModError::ParserError(err) => err,\n+        }.emit()\n+    }\n }"}, {"sha": "7e7155ad27876bff0571d97c42305eb518be8ade", "filename": "compiler/rustc_expand/src/mut_visit/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmut_visit%2Ftests.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -7,8 +7,8 @@ use rustc_span::symbol::Ident;\n use rustc_span::with_default_session_globals;\n \n // This version doesn't care about getting comments or doc-strings in.\n-fn fake_print_crate(s: &mut pprust::State<'_>, krate: &ast::Crate) {\n-    s.print_mod(&krate.module, &krate.attrs)\n+fn print_crate_items(krate: &ast::Crate) -> String {\n+    krate.items.iter().map(|i| pprust::item_to_string(i)).collect::<Vec<_>>().join(\" \")\n }\n \n // Change every identifier to \"zz\".\n@@ -46,7 +46,7 @@ fn ident_transformation() {\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n-            pprust::to_string(|s| fake_print_crate(s, &krate)),\n+            print_crate_items(&krate),\n             \"#[zz]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string()\n         );\n     })\n@@ -66,7 +66,7 @@ fn ident_transformation_in_defs() {\n         assert_pred!(\n             matches_codepattern,\n             \"matches_codepattern\",\n-            pprust::to_string(|s| fake_print_crate(s, &krate)),\n+            print_crate_items(&krate),\n             \"macro_rules! zz{(zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+))}\".to_string()\n         );\n     })"}, {"sha": "56f25ffdb0187cf7bc4ea2a8f8c3ea7c17d25898", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -309,8 +309,8 @@ fn out_of_line_mod() {\n         .unwrap()\n         .unwrap();\n \n-        if let ast::ItemKind::Mod(ref m) = item.kind {\n-            assert!(m.items.len() == 2);\n+        if let ast::ItemKind::Mod(_, ref mod_kind) = item.kind {\n+            assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n         } else {\n             panic!();\n         }"}, {"sha": "837fad905800a89298296d23e23de818b5ff07c9", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -2,16 +2,21 @@ use crate::base::ExtCtxt;\n \n use rustc_ast as ast;\n use rustc_ast::token;\n+use rustc_ast::token::Nonterminal;\n+use rustc_ast::token::NtIdent;\n use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens};\n use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Diagnostic;\n+use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n+use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::{nt_to_tokenstream, parse_stream_from_source_str};\n use rustc_session::parse::ParseSess;\n+use rustc_span::hygiene::ExpnKind;\n use rustc_span::symbol::{self, kw, sym, Symbol};\n-use rustc_span::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n+use rustc_span::{BytePos, FileName, MultiSpan, Pos, RealFileName, SourceFile, Span};\n \n use pm::bridge::{server, TokenTree};\n use pm::{Delimiter, Level, LineColumn, Spacing};\n@@ -174,9 +179,7 @@ impl FromInternal<(TreeAndSpacing, &'_ ParseSess, &'_ mut Vec<Self>)>\n             }\n \n             Interpolated(nt) => {\n-                if let Some((name, is_raw)) =\n-                    nt.ident_name_compatibility_hack(span, sess.source_map())\n-                {\n+                if let Some((name, is_raw)) = ident_name_compatibility_hack(&nt, span, sess) {\n                     TokenTree::Ident(Ident::new(sess, name.name, is_raw, name.span))\n                 } else {\n                     let stream = nt_to_tokenstream(&nt, sess, CanSynthesizeMissingTokens::No);\n@@ -711,3 +714,62 @@ impl server::Span for Rustc<'_> {\n         self.sess.source_map().span_to_snippet(span).ok()\n     }\n }\n+\n+// See issue #74616 for details\n+fn ident_name_compatibility_hack(\n+    nt: &Nonterminal,\n+    orig_span: Span,\n+    sess: &ParseSess,\n+) -> Option<(rustc_span::symbol::Ident, bool)> {\n+    if let NtIdent(ident, is_raw) = nt {\n+        if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n+            let source_map = sess.source_map();\n+            let filename = source_map.span_to_filename(orig_span);\n+            if let FileName::Real(RealFileName::Named(path)) = filename {\n+                let matches_prefix = |prefix, filename| {\n+                    // Check for a path that ends with 'prefix*/src/<filename>'\n+                    let mut iter = path.components().rev();\n+                    iter.next().and_then(|p| p.as_os_str().to_str()) == Some(filename)\n+                        && iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"src\")\n+                        && iter\n+                            .next()\n+                            .and_then(|p| p.as_os_str().to_str())\n+                            .map_or(false, |p| p.starts_with(prefix))\n+                };\n+\n+                let time_macros_impl =\n+                    macro_name == sym::impl_macros && matches_prefix(\"time-macros-impl\", \"lib.rs\");\n+                if time_macros_impl\n+                    || (macro_name == sym::arrays && matches_prefix(\"js-sys\", \"lib.rs\"))\n+                {\n+                    let snippet = source_map.span_to_snippet(orig_span);\n+                    if snippet.as_deref() == Ok(\"$name\") {\n+                        if time_macros_impl {\n+                            sess.buffer_lint_with_diagnostic(\n+                                &PROC_MACRO_BACK_COMPAT,\n+                                orig_span,\n+                                ast::CRATE_NODE_ID,\n+                                \"using an old version of `time-macros-impl`\",\n+                                BuiltinLintDiagnostics::ProcMacroBackCompat(\n+                                \"the `time-macros-impl` crate will stop compiling in futures version of Rust. \\\n+                                Please update to the latest version of the `time` crate to avoid breakage\".to_string())\n+                            );\n+                        }\n+                        return Some((*ident, *is_raw));\n+                    }\n+                }\n+\n+                if macro_name == sym::tuple_from_req\n+                    && (matches_prefix(\"actix-web\", \"extract.rs\")\n+                        || matches_prefix(\"actori-web\", \"extract.rs\"))\n+                {\n+                    let snippet = source_map.span_to_snippet(orig_span);\n+                    if snippet.as_deref() == Ok(\"$T\") {\n+                        return Some((*ident, *is_raw));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    None\n+}"}, {"sha": "9902b6cc9e84209d436d8c77fa650380dd348c13", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -272,9 +272,11 @@ declare_features! (\n     (accepted, doc_alias, \"1.48.0\", Some(50146), None),\n     /// Allows patterns with concurrent by-move and by-ref bindings.\n     /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n-    (accepted, move_ref_pattern, \"1.48.0\", Some(68354), None),\n+    (accepted, move_ref_pattern, \"1.49.0\", Some(68354), None),\n     /// The smallest useful subset of `const_generics`.\n     (accepted, min_const_generics, \"1.51.0\", Some(74878), None),\n+    /// The `unsafe_op_in_unsafe_fn` lint (allowed by default): no longer treat an unsafe function as an unsafe block.\n+    (accepted, unsafe_block_in_unsafe_fn, \"1.51.0\", Some(71668), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "ee2fce34b0b0df24bfd53c05530d41cf2aa0251b", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -557,9 +557,6 @@ declare_features! (\n     /// Allows the use of `#[ffi_const]` on foreign functions.\n     (active, ffi_const, \"1.45.0\", Some(58328), None),\n \n-    /// No longer treat an unsafe function as an unsafe block.\n-    (active, unsafe_block_in_unsafe_fn, \"1.45.0\", Some(71668), None),\n-\n     /// Allows `extern \"avr-interrupt\" fn()` and `extern \"avr-non-blocking-interrupt\" fn()`.\n     (active, abi_avr_interrupt, \"1.45.0\", Some(69664), None),\n \n@@ -633,11 +630,20 @@ declare_features! (\n     (active, abi_c_cmse_nonsecure_call, \"1.51.0\", Some(81391), None),\n \n     /// Lessens the requirements for structs to implement `Unsize`.\n-    (active, relaxed_struct_unsize, \"1.51.0\", Some(1), None),\n+    (active, relaxed_struct_unsize, \"1.51.0\", Some(81793), None),\n \n     /// Allows macro attributes to observe output of `#[derive]`.\n     (active, macro_attributes_in_derive_output, \"1.51.0\", Some(81119), None),\n \n+    /// Allows `pub` on `macro_rules` items.\n+    (active, pub_macro_rules, \"1.52.0\", Some(78855), None),\n+\n+    /// Allows associated types in inherent impls.\n+    (active, inherent_associated_types, \"1.52.0\", Some(8995), None),\n+\n+    /// Allows `extern \"C-unwind\" fn` to enable unwinding across ABI boundaries.\n+    (active, c_unwind, \"1.52.0\", Some(74990), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -663,6 +669,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::unsized_locals,\n     sym::capture_disjoint_fields,\n     sym::const_generics_defaults,\n+    sym::inherent_associated_types,\n ];\n \n /// Some features are not allowed to be used together at the same time, if"}, {"sha": "072062dd615d874942f0102884b342199bd17fd5", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -470,6 +470,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     rustc_attr!(rustc_promotable, AssumedUsed, template!(Word), IMPL_DETAIL),\n     rustc_attr!(rustc_args_required_const, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_legacy_const_generics, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Layout related:"}, {"sha": "3266dfac702babbc70e40418777d786ac6039c8a", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -5,13 +5,16 @@\n //! expressions) that are mostly just leftovers.\n \n pub use crate::def_id::DefPathHash;\n-use crate::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::def_id::{\n+    CrateNum, DefId, DefIndex, LocalDefId, StableCrateId, CRATE_DEF_INDEX, LOCAL_CRATE,\n+};\n use crate::hir;\n \n-use rustc_ast::crate_disambiguator::CrateDisambiguator;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::unhash::UnhashMap;\n use rustc_index::vec::IndexVec;\n+use rustc_span::crate_disambiguator::CrateDisambiguator;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n@@ -27,6 +30,7 @@ use tracing::debug;\n pub struct DefPathTable {\n     index_to_key: IndexVec<DefIndex, DefKey>,\n     def_path_hashes: IndexVec<DefIndex, DefPathHash>,\n+    def_path_hash_to_index: UnhashMap<DefPathHash, DefIndex>,\n }\n \n impl DefPathTable {\n@@ -39,6 +43,35 @@ impl DefPathTable {\n         };\n         self.def_path_hashes.push(def_path_hash);\n         debug_assert!(self.def_path_hashes.len() == self.index_to_key.len());\n+\n+        // Check for hash collisions of DefPathHashes. These should be\n+        // exceedingly rare.\n+        if let Some(existing) = self.def_path_hash_to_index.insert(def_path_hash, index) {\n+            let def_path1 = DefPath::make(LOCAL_CRATE, existing, |idx| self.def_key(idx));\n+            let def_path2 = DefPath::make(LOCAL_CRATE, index, |idx| self.def_key(idx));\n+\n+            // Continuing with colliding DefPathHashes can lead to correctness\n+            // issues. We must abort compilation.\n+            //\n+            // The likelyhood of such a collision is very small, so actually\n+            // running into one could be indicative of a poor hash function\n+            // being used.\n+            //\n+            // See the documentation for DefPathHash for more information.\n+            panic!(\n+                \"found DefPathHash collsion between {:?} and {:?}. \\\n+                    Compilation cannot continue.\",\n+                def_path1, def_path2\n+            );\n+        }\n+\n+        // Assert that all DefPathHashes correctly contain the local crate's\n+        // StableCrateId\n+        #[cfg(debug_assertions)]\n+        if let Some(root) = self.def_path_hashes.get(CRATE_DEF_INDEX) {\n+            assert!(def_path_hash.stable_crate_id() == root.stable_crate_id());\n+        }\n+\n         index\n     }\n \n@@ -108,13 +141,10 @@ pub struct DefKey {\n }\n \n impl DefKey {\n-    fn compute_stable_hash(&self, parent_hash: DefPathHash) -> DefPathHash {\n+    pub(crate) fn compute_stable_hash(&self, parent: DefPathHash) -> DefPathHash {\n         let mut hasher = StableHasher::new();\n \n-        // We hash a `0u8` here to disambiguate between regular `DefPath` hashes,\n-        // and the special \"root_parent\" below.\n-        0u8.hash(&mut hasher);\n-        parent_hash.hash(&mut hasher);\n+        parent.hash(&mut hasher);\n \n         let DisambiguatedDefPathData { ref data, disambiguator } = self.disambiguated_data;\n \n@@ -127,19 +157,13 @@ impl DefKey {\n \n         disambiguator.hash(&mut hasher);\n \n-        DefPathHash(hasher.finish())\n-    }\n+        let local_hash: u64 = hasher.finish();\n \n-    fn root_parent_stable_hash(\n-        crate_name: &str,\n-        crate_disambiguator: CrateDisambiguator,\n-    ) -> DefPathHash {\n-        let mut hasher = StableHasher::new();\n-        // Disambiguate this from a regular `DefPath` hash; see `compute_stable_hash()` above.\n-        1u8.hash(&mut hasher);\n-        crate_name.hash(&mut hasher);\n-        crate_disambiguator.hash(&mut hasher);\n-        DefPathHash(hasher.finish())\n+        // Construct the new DefPathHash, making sure that the `crate_id`\n+        // portion of the hash is properly copied from the parent. This way the\n+        // `crate_id` part will be recursively propagated from the root to all\n+        // DefPathHashes in this DefPathTable.\n+        DefPathHash::new(parent.stable_crate_id(), local_hash)\n     }\n }\n \n@@ -295,6 +319,12 @@ impl Definitions {\n         self.table.def_path_hash(id.local_def_index)\n     }\n \n+    #[inline]\n+    pub fn def_path_hash_to_def_id(&self, def_path_hash: DefPathHash) -> LocalDefId {\n+        let local_def_index = self.table.def_path_hash_to_index[&def_path_hash];\n+        LocalDefId { local_def_index }\n+    }\n+\n     /// Returns the path from the crate root to `index`. The root\n     /// nodes are not included in the path (i.e., this will be an\n     /// empty vector for the crate root). For an inlined item, this\n@@ -312,11 +342,6 @@ impl Definitions {\n         self.def_id_to_hir_id[id].unwrap()\n     }\n \n-    #[inline]\n-    pub fn opt_local_def_id_to_hir_id(&self, id: LocalDefId) -> Option<hir::HirId> {\n-        self.def_id_to_hir_id[id]\n-    }\n-\n     #[inline]\n     pub fn opt_hir_id_to_local_def_id(&self, hir_id: hir::HirId) -> Option<LocalDefId> {\n         self.hir_id_to_def_id.get(&hir_id).copied()\n@@ -332,7 +357,8 @@ impl Definitions {\n             },\n         };\n \n-        let parent_hash = DefKey::root_parent_stable_hash(crate_name, crate_disambiguator);\n+        let stable_crate_id = StableCrateId::new(crate_name, crate_disambiguator);\n+        let parent_hash = DefPathHash::new(stable_crate_id, 0);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n         // Create the root definition."}, {"sha": "8f61adcd8e28870f0c62f1cabd5eeec08cc62976", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 242, "deletions": 59, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,11 +1,12 @@\n-use crate::def::{DefKind, Namespace, Res};\n+// ignore-tidy-filelength\n+use crate::def::{CtorKind, DefKind, Namespace, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::{itemlikevisit, LangItem};\n \n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_ast::{self as ast, CrateSugar, LlvmAsmDialect};\n-use rustc_ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n+use rustc_ast::{Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n pub use rustc_ast::{BorrowKind, ImplPolarity, IsAuto};\n pub use rustc_ast::{CaptureBy, Movability, Mutability};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -468,7 +469,6 @@ pub enum GenericParamKind<'hir> {\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n-    pub attrs: &'hir [Attribute],\n     pub bounds: GenericBounds<'hir>,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n@@ -615,11 +615,11 @@ pub struct WhereEqPredicate<'hir> {\n     pub rhs_ty: &'hir Ty<'hir>,\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Default, Encodable, Debug, HashStable_Generic)]\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n-    pub items: BTreeSet<HirId>,\n+    pub items: BTreeSet<ItemId>,\n     pub trait_items: BTreeSet<TraitItemId>,\n     pub impl_items: BTreeSet<ImplItemId>,\n     pub foreign_items: BTreeSet<ForeignItemId>,\n@@ -629,7 +629,6 @@ pub struct ModuleItems {\n #[derive(Encodable, Debug, HashStable_Generic)]\n pub struct CrateItem<'hir> {\n     pub module: Mod<'hir>,\n-    pub attrs: &'hir [Attribute],\n     pub span: Span,\n }\n \n@@ -652,13 +651,13 @@ pub struct Crate<'hir> {\n     // does, because it can affect the order in which errors are\n     // detected, which in turn can make UI tests yield\n     // slightly different results.\n-    pub items: BTreeMap<HirId, Item<'hir>>,\n+    pub items: BTreeMap<ItemId, Item<'hir>>,\n \n     pub trait_items: BTreeMap<TraitItemId, TraitItem<'hir>>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem<'hir>>,\n     pub foreign_items: BTreeMap<ForeignItemId, ForeignItem<'hir>>,\n     pub bodies: BTreeMap<BodyId, Body<'hir>>,\n-    pub trait_impls: BTreeMap<DefId, Vec<HirId>>,\n+    pub trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n \n     /// A list of the body ids written out in the order in which they\n     /// appear in the crate. If you're going to process all the bodies\n@@ -668,16 +667,19 @@ pub struct Crate<'hir> {\n \n     /// A list of modules written out in the order in which they\n     /// appear in the crate. This includes the main crate module.\n-    pub modules: BTreeMap<HirId, ModuleItems>,\n+    pub modules: BTreeMap<LocalDefId, ModuleItems>,\n     /// A list of proc macro HirIds, written out in the order in which\n     /// they are declared in the static array generated by proc_macro_harness.\n     pub proc_macros: Vec<HirId>,\n \n     pub trait_map: BTreeMap<HirId, Vec<TraitCandidate>>,\n+\n+    /// Collected attributes from HIR nodes.\n+    pub attrs: BTreeMap<HirId, &'hir [Attribute]>,\n }\n \n impl Crate<'hir> {\n-    pub fn item(&self, id: HirId) -> &Item<'hir> {\n+    pub fn item(&self, id: ItemId) -> &Item<'hir> {\n         &self.items[&id]\n     }\n \n@@ -761,16 +763,22 @@ impl Crate<'_> {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug)]\n pub struct MacroDef<'hir> {\n     pub ident: Ident,\n     pub vis: Visibility<'hir>,\n-    pub attrs: &'hir [Attribute],\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub span: Span,\n     pub ast: ast::MacroDef,\n }\n \n+impl MacroDef<'_> {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        HirId::make_owner(self.def_id)\n+    }\n+}\n+\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n@@ -1158,16 +1166,6 @@ pub enum StmtKind<'hir> {\n     Semi(&'hir Expr<'hir>),\n }\n \n-impl<'hir> StmtKind<'hir> {\n-    pub fn attrs(&self, get_item: impl FnOnce(ItemId) -> &'hir Item<'hir>) -> &'hir [Attribute] {\n-        match *self {\n-            StmtKind::Local(ref l) => &l.attrs,\n-            StmtKind::Item(ref item_id) => &get_item(*item_id).attrs,\n-            StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => &e.attrs,\n-        }\n-    }\n-}\n-\n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n #[derive(Debug, HashStable_Generic)]\n pub struct Local<'hir> {\n@@ -1178,7 +1176,6 @@ pub struct Local<'hir> {\n     pub init: Option<&'hir Expr<'hir>>,\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub attrs: AttrVec,\n     /// Can be `ForLoopDesugar` if the `let` statement is part of a `for` loop\n     /// desugaring. Otherwise will be `Normal`.\n     pub source: LocalSource,\n@@ -1191,7 +1188,6 @@ pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub attrs: &'hir [Attribute],\n     /// If this pattern and the optional guard matches, then `body` is evaluated.\n     pub pat: &'hir Pat<'hir>,\n     /// Optional guard clause.\n@@ -1274,7 +1270,18 @@ impl Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, Eq, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n+#[derive(\n+    Clone,\n+    PartialEq,\n+    PartialOrd,\n+    Eq,\n+    Hash,\n+    HashStable_Generic,\n+    Encodable,\n+    Decodable,\n+    Debug,\n+    Copy\n+)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n     Async(AsyncGeneratorKind),\n@@ -1292,12 +1299,32 @@ impl fmt::Display for GeneratorKind {\n     }\n }\n \n+impl GeneratorKind {\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            GeneratorKind::Async(ask) => ask.descr(),\n+            GeneratorKind::Gen => \"generator\",\n+        }\n+    }\n+}\n+\n /// In the case of a generator created as part of an async construct,\n /// which kind of async construct caused it to be created?\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, Eq, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n+#[derive(\n+    Clone,\n+    PartialEq,\n+    PartialOrd,\n+    Eq,\n+    Hash,\n+    HashStable_Generic,\n+    Encodable,\n+    Decodable,\n+    Debug,\n+    Copy\n+)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,\n@@ -1319,6 +1346,16 @@ impl fmt::Display for AsyncGeneratorKind {\n     }\n }\n \n+impl AsyncGeneratorKind {\n+    pub fn descr(&self) -> &'static str {\n+        match self {\n+            AsyncGeneratorKind::Block => \"`async` block\",\n+            AsyncGeneratorKind::Closure => \"`async` closure body\",\n+            AsyncGeneratorKind::Fn => \"`async fn` body\",\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum BodyOwnerKind {\n     /// Functions and methods.\n@@ -1409,14 +1446,9 @@ pub struct AnonConst {\n pub struct Expr<'hir> {\n     pub hir_id: HirId,\n     pub kind: ExprKind<'hir>,\n-    pub attrs: AttrVec,\n     pub span: Span,\n }\n \n-// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Expr<'static>, 72);\n-\n impl Expr<'_> {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.kind {\n@@ -1532,6 +1564,71 @@ impl Expr<'_> {\n         }\n         expr\n     }\n+\n+    pub fn peel_blocks(&self) -> &Self {\n+        let mut expr = self;\n+        while let ExprKind::Block(Block { expr: Some(inner), .. }, _) = &expr.kind {\n+            expr = inner;\n+        }\n+        expr\n+    }\n+\n+    pub fn can_have_side_effects(&self) -> bool {\n+        match self.peel_drop_temps().kind {\n+            ExprKind::Path(_) | ExprKind::Lit(_) => false,\n+            ExprKind::Type(base, _)\n+            | ExprKind::Unary(_, base)\n+            | ExprKind::Field(base, _)\n+            | ExprKind::Index(base, _)\n+            | ExprKind::AddrOf(.., base)\n+            | ExprKind::Cast(base, _) => {\n+                // This isn't exactly true for `Index` and all `Unnary`, but we are using this\n+                // method exclusively for diagnostics and there's a *cultural* pressure against\n+                // them being used only for its side-effects.\n+                base.can_have_side_effects()\n+            }\n+            ExprKind::Struct(_, fields, init) => fields\n+                .iter()\n+                .map(|field| field.expr)\n+                .chain(init.into_iter())\n+                .all(|e| e.can_have_side_effects()),\n+\n+            ExprKind::Array(args)\n+            | ExprKind::Tup(args)\n+            | ExprKind::Call(\n+                Expr {\n+                    kind:\n+                        ExprKind::Path(QPath::Resolved(\n+                            None,\n+                            Path { res: Res::Def(DefKind::Ctor(_, CtorKind::Fn), _), .. },\n+                        )),\n+                    ..\n+                },\n+                args,\n+            ) => args.iter().all(|arg| arg.can_have_side_effects()),\n+            ExprKind::If(..)\n+            | ExprKind::Match(..)\n+            | ExprKind::MethodCall(..)\n+            | ExprKind::Call(..)\n+            | ExprKind::Closure(..)\n+            | ExprKind::Block(..)\n+            | ExprKind::Repeat(..)\n+            | ExprKind::Break(..)\n+            | ExprKind::Continue(..)\n+            | ExprKind::Ret(..)\n+            | ExprKind::Loop(..)\n+            | ExprKind::Assign(..)\n+            | ExprKind::InlineAsm(..)\n+            | ExprKind::LlvmInlineAsm(..)\n+            | ExprKind::AssignOp(..)\n+            | ExprKind::ConstBlock(..)\n+            | ExprKind::Box(..)\n+            | ExprKind::Binary(..)\n+            | ExprKind::Yield(..)\n+            | ExprKind::DropTemps(..)\n+            | ExprKind::Err => true,\n+        }\n+    }\n }\n \n /// Checks if the specified expression is a built-in range literal.\n@@ -1911,7 +2008,15 @@ pub struct FnSig<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct TraitItemId {\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n+}\n+\n+impl TraitItemId {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1921,13 +2026,24 @@ pub struct TraitItemId {\n #[derive(Debug)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n-    pub hir_id: HirId,\n-    pub attrs: &'hir [Attribute],\n+    pub def_id: LocalDefId,\n     pub generics: Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n }\n \n+impl TraitItem<'_> {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n+    pub fn trait_item_id(&self) -> TraitItemId {\n+        TraitItemId { def_id: self.def_id }\n+    }\n+}\n+\n /// Represents a trait method's body (or just argument names).\n #[derive(Encodable, Debug, HashStable_Generic)]\n pub enum TraitFn<'hir> {\n@@ -1955,22 +2071,41 @@ pub enum TraitItemKind<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct ImplItemId {\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n+}\n+\n+impl ImplItemId {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n }\n \n /// Represents anything within an `impl` block.\n #[derive(Debug)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub vis: Visibility<'hir>,\n     pub defaultness: Defaultness,\n-    pub attrs: &'hir [Attribute],\n     pub generics: Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub span: Span,\n }\n \n+impl ImplItem<'_> {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n+    pub fn impl_item_id(&self) -> ImplItemId {\n+        ImplItemId { def_id: self.def_id }\n+    }\n+}\n+\n /// Represents various kinds of content within an `impl`.\n #[derive(Debug, HashStable_Generic)]\n pub enum ImplItemKind<'hir> {\n@@ -2250,7 +2385,7 @@ pub struct InlineAsm<'hir> {\n     pub line_spans: &'hir [Span],\n }\n \n-#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic, PartialEq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Hash, HashStable_Generic, PartialEq)]\n pub struct LlvmInlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n@@ -2261,7 +2396,7 @@ pub struct LlvmInlineAsmOutput {\n // NOTE(eddyb) This is used within MIR as well, so unlike the rest of the HIR,\n // it needs to be `Clone` and `Decodable` and use plain `Vec<T>` instead of\n // arena-allocated slice.\n-#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic, PartialEq)]\n+#[derive(Clone, Encodable, Decodable, Debug, Hash, HashStable_Generic, PartialEq)]\n pub struct LlvmInlineAsmInner {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -2283,7 +2418,6 @@ pub struct LlvmInlineAsm<'hir> {\n /// Represents a parameter in a function header.\n #[derive(Debug, HashStable_Generic)]\n pub struct Param<'hir> {\n-    pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n     pub pat: &'hir Pat<'hir>,\n     pub ty_span: Span,\n@@ -2401,8 +2535,6 @@ pub struct Variant<'hir> {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    /// Attributes of the variant.\n-    pub attrs: &'hir [Attribute],\n     /// Id of the variant (not the constructor, see `VariantData::ctor_hir_id()`).\n     pub id: HirId,\n     /// Fields and constructor id of the variant.\n@@ -2496,7 +2628,6 @@ pub struct StructField<'hir> {\n     pub vis: Visibility<'hir>,\n     pub hir_id: HirId,\n     pub ty: &'hir Ty<'hir>,\n-    pub attrs: &'hir [Attribute],\n }\n \n impl StructField<'_> {\n@@ -2545,9 +2676,17 @@ impl VariantData<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the hir-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, Encodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug, Hash)]\n pub struct ItemId {\n-    pub id: HirId,\n+    pub def_id: LocalDefId,\n+}\n+\n+impl ItemId {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n }\n \n /// An item\n@@ -2556,13 +2695,24 @@ pub struct ItemId {\n #[derive(Debug)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub hir_id: HirId,\n-    pub attrs: &'hir [Attribute],\n+    pub def_id: LocalDefId,\n     pub kind: ItemKind<'hir>,\n     pub vis: Visibility<'hir>,\n     pub span: Span,\n }\n \n+impl Item<'_> {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n+    pub fn item_id(&self) -> ItemId {\n+        ItemId { def_id: self.def_id }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Unsafety {\n@@ -2733,7 +2883,15 @@ pub enum AssocItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct ForeignItemId {\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n+}\n+\n+impl ForeignItemId {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n }\n \n /// A reference from a foreign block to one of its items. This\n@@ -2751,17 +2909,27 @@ pub struct ForeignItemRef<'hir> {\n     pub vis: Visibility<'hir>,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug)]\n pub struct ForeignItem<'hir> {\n-    #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    pub attrs: &'hir [Attribute],\n     pub kind: ForeignItemKind<'hir>,\n-    pub hir_id: HirId,\n+    pub def_id: LocalDefId,\n     pub span: Span,\n     pub vis: Visibility<'hir>,\n }\n \n+impl ForeignItem<'_> {\n+    #[inline]\n+    pub fn hir_id(&self) -> HirId {\n+        // Items are always HIR owners.\n+        HirId::make_owner(self.def_id)\n+    }\n+\n+    pub fn foreign_item_id(&self) -> ForeignItemId {\n+        ForeignItemId { def_id: self.def_id }\n+    }\n+}\n+\n /// An item within an `extern` block.\n #[derive(Debug, HashStable_Generic)]\n pub enum ForeignItemKind<'hir> {\n@@ -2871,11 +3039,12 @@ impl<'hir> Node<'hir> {\n \n     pub fn hir_id(&self) -> Option<HirId> {\n         match self {\n-            Node::Item(Item { hir_id, .. })\n-            | Node::ForeignItem(ForeignItem { hir_id, .. })\n-            | Node::TraitItem(TraitItem { hir_id, .. })\n-            | Node::ImplItem(ImplItem { hir_id, .. })\n-            | Node::Field(StructField { hir_id, .. })\n+            Node::Item(Item { def_id, .. })\n+            | Node::TraitItem(TraitItem { def_id, .. })\n+            | Node::ImplItem(ImplItem { def_id, .. })\n+            | Node::ForeignItem(ForeignItem { def_id, .. })\n+            | Node::MacroDef(MacroDef { def_id, .. }) => Some(HirId::make_owner(*def_id)),\n+            Node::Field(StructField { hir_id, .. })\n             | Node::AnonConst(AnonConst { hir_id, .. })\n             | Node::Expr(Expr { hir_id, .. })\n             | Node::Stmt(Stmt { hir_id, .. })\n@@ -2885,7 +3054,6 @@ impl<'hir> Node<'hir> {\n             | Node::Arm(Arm { hir_id, .. })\n             | Node::Block(Block { hir_id, .. })\n             | Node::Local(Local { hir_id, .. })\n-            | Node::MacroDef(MacroDef { hir_id, .. })\n             | Node::Lifetime(Lifetime { hir_id, .. })\n             | Node::Param(Param { hir_id, .. })\n             | Node::GenericParam(GenericParam { hir_id, .. }) => Some(*hir_id),\n@@ -2897,3 +3065,18 @@ impl<'hir> Node<'hir> {\n         }\n     }\n }\n+\n+// Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    rustc_data_structures::static_assert_size!(super::Block<'static>, 48);\n+    rustc_data_structures::static_assert_size!(super::Expr<'static>, 64);\n+    rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n+    rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n+    rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n+\n+    rustc_data_structures::static_assert_size!(super::Item<'static>, 184);\n+    rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 128);\n+    rustc_data_structures::static_assert_size!(super::ImplItem<'static>, 152);\n+    rustc_data_structures::static_assert_size!(super::ForeignItem<'static>, 136);\n+}"}, {"sha": "e0b3d9026a07cfe240f0eca7930ae95ce1a87b12", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,4 +1,5 @@\n use crate::def_id::{LocalDefId, CRATE_DEF_INDEX};\n+use rustc_index::vec::IndexVec;\n use std::fmt;\n \n /// Uniquely identifies a node in the HIR of the current crate. It is\n@@ -18,6 +19,22 @@ pub struct HirId {\n     pub local_id: ItemLocalId,\n }\n \n+impl HirId {\n+    pub fn expect_owner(self) -> LocalDefId {\n+        assert_eq!(self.local_id.index(), 0);\n+        self.owner\n+    }\n+\n+    pub fn as_owner(self) -> Option<LocalDefId> {\n+        if self.local_id.index() == 0 { Some(self.owner) } else { None }\n+    }\n+\n+    #[inline]\n+    pub fn make_owner(owner: LocalDefId) -> Self {\n+        Self { owner, local_id: ItemLocalId::from_u32(0) }\n+    }\n+}\n+\n impl fmt::Display for HirId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", self)\n@@ -45,3 +62,69 @@ pub const CRATE_HIR_ID: HirId = HirId {\n     owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n     local_id: ItemLocalId::from_u32(0),\n };\n+\n+#[derive(Clone, Default, Debug, Encodable, Decodable)]\n+pub struct HirIdVec<T> {\n+    map: IndexVec<LocalDefId, IndexVec<ItemLocalId, T>>,\n+}\n+\n+impl<T> HirIdVec<T> {\n+    pub fn push_owner(&mut self, id: LocalDefId) {\n+        self.map.ensure_contains_elem(id, IndexVec::new);\n+    }\n+\n+    pub fn push(&mut self, id: HirId, value: T) {\n+        if id.local_id == ItemLocalId::from_u32(0) {\n+            self.push_owner(id.owner);\n+        }\n+        let submap = &mut self.map[id.owner];\n+        let _ret_id = submap.push(value);\n+        debug_assert_eq!(_ret_id, id.local_id);\n+    }\n+\n+    pub fn push_sparse(&mut self, id: HirId, value: T)\n+    where\n+        T: Default,\n+    {\n+        self.map.ensure_contains_elem(id.owner, IndexVec::new);\n+        let submap = &mut self.map[id.owner];\n+        let i = id.local_id.index();\n+        let len = submap.len();\n+        if i >= len {\n+            submap.extend(std::iter::repeat_with(T::default).take(i - len + 1));\n+        }\n+        submap[id.local_id] = value;\n+    }\n+\n+    pub fn get(&self, id: HirId) -> Option<&T> {\n+        self.map.get(id.owner)?.get(id.local_id)\n+    }\n+\n+    pub fn get_owner(&self, id: LocalDefId) -> &IndexVec<ItemLocalId, T> {\n+        &self.map[id]\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = &T> {\n+        self.map.iter().flat_map(|la| la.iter())\n+    }\n+\n+    pub fn iter_enumerated(&self) -> impl Iterator<Item = (HirId, &T)> {\n+        self.map.iter_enumerated().flat_map(|(owner, la)| {\n+            la.iter_enumerated().map(move |(local_id, attr)| (HirId { owner, local_id }, attr))\n+        })\n+    }\n+}\n+\n+impl<T> std::ops::Index<HirId> for HirIdVec<T> {\n+    type Output = T;\n+\n+    fn index(&self, id: HirId) -> &T {\n+        &self.map[id.owner][id.local_id]\n+    }\n+}\n+\n+impl<T> std::ops::IndexMut<HirId> for HirIdVec<T> {\n+    fn index_mut(&mut self, id: HirId) -> &mut T {\n+        &mut self.map[id.owner][id.local_id]\n+    }\n+}"}, {"sha": "df63f0d48c3dd0a6b62349c26fba98f29b4e2d04", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 46, "deletions": 71, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -101,29 +101,21 @@ where\n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n     /// `#[xxx] pub async/const/extern \"Abi\" fn foo()`\n-    ItemFn(Ident, &'a Generics<'a>, FnHeader, &'a Visibility<'a>, &'a [Attribute]),\n+    ItemFn(Ident, &'a Generics<'a>, FnHeader, &'a Visibility<'a>),\n \n     /// `fn foo(&self)`\n-    Method(Ident, &'a FnSig<'a>, Option<&'a Visibility<'a>>, &'a [Attribute]),\n+    Method(Ident, &'a FnSig<'a>, Option<&'a Visibility<'a>>),\n \n     /// `|x, y| {}`\n-    Closure(&'a [Attribute]),\n+    Closure,\n }\n \n impl<'a> FnKind<'a> {\n-    pub fn attrs(&self) -> &'a [Attribute] {\n-        match *self {\n-            FnKind::ItemFn(.., attrs) => attrs,\n-            FnKind::Method(.., attrs) => attrs,\n-            FnKind::Closure(attrs) => attrs,\n-        }\n-    }\n-\n     pub fn header(&self) -> Option<&FnHeader> {\n         match *self {\n-            FnKind::ItemFn(_, _, ref header, _, _) => Some(header),\n-            FnKind::Method(_, ref sig, _, _) => Some(&sig.header),\n-            FnKind::Closure(_) => None,\n+            FnKind::ItemFn(_, _, ref header, _) => Some(header),\n+            FnKind::Method(_, ref sig, _) => Some(&sig.header),\n+            FnKind::Closure => None,\n         }\n     }\n }\n@@ -133,7 +125,7 @@ pub trait Map<'hir> {\n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     fn find(&self, hir_id: HirId) -> Option<Node<'hir>>;\n     fn body(&self, id: BodyId) -> &'hir Body<'hir>;\n-    fn item(&self, id: HirId) -> &'hir Item<'hir>;\n+    fn item(&self, id: ItemId) -> &'hir Item<'hir>;\n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir>;\n     fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir>;\n     fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir>;\n@@ -150,7 +142,7 @@ impl<'hir> Map<'hir> for ErasedMap<'hir> {\n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.0.body(id)\n     }\n-    fn item(&self, id: HirId) -> &'hir Item<'hir> {\n+    fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n         self.0.item(id)\n     }\n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n@@ -269,7 +261,7 @@ pub trait Visitor<'v>: Sized {\n     /// reason to override this method is if you want a nested pattern\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map().inter().map(|map| map.item(id.id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.item(id));\n         walk_list!(self, visit_item, opt_item);\n     }\n \n@@ -466,7 +458,7 @@ pub trait Visitor<'v>: Sized {\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding<'v>) {\n         walk_assoc_type_binding(self, type_binding)\n     }\n-    fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n+    fn visit_attribute(&mut self, _id: HirId, _attr: &'v Attribute) {}\n     fn visit_macro_def(&mut self, macro_def: &'v MacroDef<'v>) {\n         walk_macro_def(self, macro_def)\n     }\n@@ -484,14 +476,17 @@ pub trait Visitor<'v>: Sized {\n /// Walks the contents of a crate. See also `Crate::visit_all_items`.\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate<'v>) {\n     visitor.visit_mod(&krate.item.module, krate.item.span, CRATE_HIR_ID);\n-    walk_list!(visitor, visit_attribute, krate.item.attrs);\n     walk_list!(visitor, visit_macro_def, krate.exported_macros);\n+    for (&id, attrs) in krate.attrs.iter() {\n+        for a in *attrs {\n+            visitor.visit_attribute(id, a)\n+        }\n+    }\n }\n \n pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef<'v>) {\n-    visitor.visit_id(macro_def.hir_id);\n+    visitor.visit_id(macro_def.hir_id());\n     visitor.visit_ident(macro_def.ident);\n-    walk_list!(visitor, visit_attribute, macro_def.attrs);\n }\n \n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n@@ -510,7 +505,6 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n-    walk_list!(visitor, visit_attribute, local.attrs.iter());\n     visitor.visit_id(local.hir_id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n@@ -557,59 +551,58 @@ pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitR\n pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n     visitor.visit_pat(&param.pat);\n-    walk_list!(visitor, visit_attribute, param.attrs);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_ident(item.ident);\n     match item.kind {\n         ItemKind::ExternCrate(orig_name) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             if let Some(orig_name) = orig_name {\n                 visitor.visit_name(item.span, orig_name);\n             }\n         }\n         ItemKind::Use(ref path, _) => {\n-            visitor.visit_use(path, item.hir_id);\n+            visitor.visit_use(path, item.hir_id());\n         }\n         ItemKind::Static(ref typ, _, body) | ItemKind::Const(ref typ, body) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n         ItemKind::Fn(ref sig, ref generics, body_id) => visitor.visit_fn(\n-            FnKind::ItemFn(item.ident, generics, sig.header, &item.vis, &item.attrs),\n+            FnKind::ItemFn(item.ident, generics, sig.header, &item.vis),\n             &sig.decl,\n             body_id,\n             item.span,\n-            item.hir_id,\n+            item.hir_id(),\n         ),\n         ItemKind::Mod(ref module) => {\n             // `visit_mod()` takes care of visiting the `Item`'s `HirId`.\n-            visitor.visit_mod(module, item.span, item.hir_id)\n+            visitor.visit_mod(module, item.span, item.hir_id())\n         }\n         ItemKind::ForeignMod { abi: _, items } => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             walk_list!(visitor, visit_foreign_item_ref, items);\n         }\n         ItemKind::GlobalAsm(_) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n         }\n         ItemKind::TyAlias(ref ty, ref generics) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_ty(ty);\n             visitor.visit_generics(generics)\n         }\n         ItemKind::OpaqueTy(OpaqueTy { ref generics, bounds, .. }) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n         ItemKind::Enum(ref enum_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             // `visit_enum_def()` takes care of visiting the `Item`'s `HirId`.\n-            visitor.visit_enum_def(enum_definition, generics, item.hir_id, item.span)\n+            visitor.visit_enum_def(enum_definition, generics, item.hir_id(), item.span)\n         }\n         ItemKind::Impl(Impl {\n             unsafety: _,\n@@ -622,7 +615,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             ref self_ty,\n             items,\n         }) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_trait_ref, of_trait);\n             visitor.visit_ty(self_ty);\n@@ -631,28 +624,27 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_variant_data(\n                 struct_definition,\n                 item.ident.name,\n                 generics,\n-                item.hir_id,\n+                item.hir_id(),\n                 item.span,\n             );\n         }\n         ItemKind::Trait(.., ref generics, bounds, trait_item_refs) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n         ItemKind::TraitAlias(ref generics, bounds) => {\n-            visitor.visit_id(item.hir_id);\n+            visitor.visit_id(item.hir_id());\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n     }\n-    walk_list!(visitor, visit_attribute, item.attrs);\n }\n \n pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n@@ -686,7 +678,6 @@ pub fn walk_variant<'v, V: Visitor<'v>>(\n         variant.span,\n     );\n     walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n-    walk_list!(visitor, visit_attribute, variant.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n@@ -836,7 +827,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n }\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n-    visitor.visit_id(foreign_item.hir_id);\n+    visitor.visit_id(foreign_item.hir_id());\n     visitor.visit_vis(&foreign_item.vis);\n     visitor.visit_ident(foreign_item.ident);\n \n@@ -851,8 +842,6 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n         ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n         ForeignItemKind::Type => (),\n     }\n-\n-    walk_list!(visitor, visit_attribute, foreign_item.attrs);\n }\n \n pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n@@ -870,7 +859,6 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericB\n \n pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam<'v>) {\n     visitor.visit_id(param.hir_id);\n-    walk_list!(visitor, visit_attribute, param.attrs);\n     match param.name {\n         ParamName::Plain(ident) => visitor.visit_ident(ident),\n         ParamName::Error | ParamName::Fresh(_) => {}\n@@ -940,7 +928,7 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n         FnKind::ItemFn(_, generics, ..) => {\n             visitor.visit_generics(generics);\n         }\n-        FnKind::Method(..) | FnKind::Closure(_) => {}\n+        FnKind::Method(..) | FnKind::Closure => {}\n     }\n }\n \n@@ -960,32 +948,31 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     visitor.visit_ident(trait_item.ident);\n-    walk_list!(visitor, visit_attribute, trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.kind {\n         TraitItemKind::Const(ref ty, default) => {\n-            visitor.visit_id(trait_item.hir_id);\n+            visitor.visit_id(trait_item.hir_id());\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_nested_body, default);\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Required(param_names)) => {\n-            visitor.visit_id(trait_item.hir_id);\n+            visitor.visit_id(trait_item.hir_id());\n             visitor.visit_fn_decl(&sig.decl);\n             for &param_name in param_names {\n                 visitor.visit_ident(param_name);\n             }\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Provided(body_id)) => {\n             visitor.visit_fn(\n-                FnKind::Method(trait_item.ident, sig, None, &trait_item.attrs),\n+                FnKind::Method(trait_item.ident, sig, None),\n                 &sig.decl,\n                 body_id,\n                 trait_item.span,\n-                trait_item.hir_id,\n+                trait_item.hir_id(),\n             );\n         }\n         TraitItemKind::Type(bounds, ref default) => {\n-            visitor.visit_id(trait_item.hir_id);\n+            visitor.visit_id(trait_item.hir_id());\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n@@ -1003,39 +990,30 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let ImplItem {\n-        hir_id: _,\n-        ident,\n-        ref vis,\n-        ref defaultness,\n-        attrs,\n-        ref generics,\n-        ref kind,\n-        span: _,\n-    } = *impl_item;\n+    let ImplItem { def_id: _, ident, ref vis, ref defaultness, ref generics, ref kind, span: _ } =\n+        *impl_item;\n \n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n     visitor.visit_defaultness(defaultness);\n-    walk_list!(visitor, visit_attribute, attrs);\n     visitor.visit_generics(generics);\n     match *kind {\n         ImplItemKind::Const(ref ty, body) => {\n-            visitor.visit_id(impl_item.hir_id);\n+            visitor.visit_id(impl_item.hir_id());\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(body);\n         }\n         ImplItemKind::Fn(ref sig, body_id) => {\n             visitor.visit_fn(\n-                FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis), &impl_item.attrs),\n+                FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis)),\n                 &sig.decl,\n                 body_id,\n                 impl_item.span,\n-                impl_item.hir_id,\n+                impl_item.hir_id(),\n             );\n         }\n         ImplItemKind::TyAlias(ref ty) => {\n-            visitor.visit_id(impl_item.hir_id);\n+            visitor.visit_id(impl_item.hir_id());\n             visitor.visit_ty(ty);\n         }\n     }\n@@ -1075,7 +1053,6 @@ pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v\n     visitor.visit_vis(&struct_field.vis);\n     visitor.visit_ident(struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n-    walk_list!(visitor, visit_attribute, struct_field.attrs);\n }\n \n pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n@@ -1102,7 +1079,6 @@ pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonCo\n \n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n     visitor.visit_id(expression.hir_id);\n-    walk_list!(visitor, visit_attribute, expression.attrs.iter());\n     match expression.kind {\n         ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::Array(subexpressions) => {\n@@ -1162,7 +1138,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         }\n         ExprKind::Closure(_, ref function_declaration, body, _fn_decl_span, _gen) => visitor\n             .visit_fn(\n-                FnKind::Closure(&expression.attrs),\n+                FnKind::Closure,\n                 function_declaration,\n                 body,\n                 expression.span,\n@@ -1246,7 +1222,6 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n         }\n     }\n     visitor.visit_expr(&arm.body);\n-    walk_list!(visitor, visit_attribute, arm.attrs);\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility<'v>) {"}, {"sha": "498000db50f436a854a9c6e86de2180272aebea5", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -38,27 +38,34 @@ macro_rules! expand_group {\n // So you probably just want to nip down to the end.\n macro_rules! language_item_table {\n     (\n-        $( $variant:ident $($group:expr)?, $name:expr, $method:ident, $target:expr; )*\n+        $( $(#[$attr:meta])* $variant:ident $($group:expr)?, $module:ident :: $name:ident, $method:ident, $target:expr; )*\n     ) => {\n \n         enum_from_u32! {\n             /// A representation of all the valid language items in Rust.\n             #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable)]\n             pub enum LangItem {\n-                $($variant,)*\n+                $(\n+                    #[doc = concat!(\"The `\", stringify!($name), \"` lang item.\")]\n+                    ///\n+                    $(#[$attr])*\n+                    $variant,\n+                )*\n             }\n         }\n \n         impl LangItem {\n             /// Returns the `name` symbol in `#[lang = \"$name\"]`.\n-            /// For example, `LangItem::EqTraitLangItem`,\n-            /// that is `#[lang = \"eq\"]` would result in `sym::eq`.\n+            /// For example, [`LangItem::PartialEq`]`.name()`\n+            /// would result in [`sym::eq`] since it is `#[lang = \"eq\"]`.\n             pub fn name(self) -> Symbol {\n                 match self {\n-                    $( LangItem::$variant => $name, )*\n+                    $( LangItem::$variant => $module::$name, )*\n                 }\n             }\n \n+            /// The [group](LangItemGroup) that this lang item belongs to,\n+            /// or `None` if it doesn't belong to a group.\n             pub fn group(self) -> Option<LangItemGroup> {\n                 use LangItemGroup::*;\n                 match self {\n@@ -67,15 +74,17 @@ macro_rules! language_item_table {\n             }\n         }\n \n+        /// All of the language items, defined or not.\n+        /// Defined lang items can come from the current crate or its dependencies.\n         #[derive(HashStable_Generic, Debug)]\n         pub struct LanguageItems {\n-            /// Mappings from lang items to their possibly found `DefId`s.\n-            /// The index corresponds to the order in `LangItem`.\n+            /// Mappings from lang items to their possibly found [`DefId`]s.\n+            /// The index corresponds to the order in [`LangItem`].\n             pub items: Vec<Option<DefId>>,\n             /// Lang items that were not found during collection.\n             pub missing: Vec<LangItem>,\n-            /// Mapping from `LangItemGroup` discriminants to all\n-            /// `DefId`s of lang items in that group.\n+            /// Mapping from [`LangItemGroup`] discriminants to all\n+            /// [`DefId`]s of lang items in that group.\n             pub groups: [Vec<DefId>; NUM_GROUPS],\n         }\n \n@@ -103,14 +112,13 @@ macro_rules! language_item_table {\n                 self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n             }\n \n+            /// Returns the [`DefId`]s of all lang items in a group.\n             pub fn group(&self, group: LangItemGroup) -> &[DefId] {\n                 self.groups[group as usize].as_ref()\n             }\n \n             $(\n-                /// Returns the corresponding `DefId` for the lang item if it\n-                /// exists.\n-                #[allow(dead_code)]\n+                #[doc = concat!(\"Returns the [`DefId`] of the `\", stringify!($name), \"` lang item if it is defined.\")]\n                 pub fn $method(&self) -> Option<DefId> {\n                     self.items[LangItem::$variant as usize]\n                 }\n@@ -120,7 +128,7 @@ macro_rules! language_item_table {\n         /// A mapping from the name of the lang item to its order and the form it must be of.\n         pub static ITEM_REFS: SyncLazy<FxHashMap<Symbol, (usize, Target)>> = SyncLazy::new(|| {\n             let mut item_refs = FxHashMap::default();\n-            $( item_refs.insert($name, (LangItem::$variant as usize, $target)); )*\n+            $( item_refs.insert($module::$name, (LangItem::$variant as usize, $target)); )*\n             item_refs\n         });\n \n@@ -140,7 +148,7 @@ impl<CTX> HashStable<CTX> for LangItem {\n ///\n /// About the `check_name` argument: passing in a `Session` would be simpler,\n /// because then we could call `Session::check_name` directly. But we want to\n-/// avoid the need for `librustc_hir` to depend on `librustc_session`, so we\n+/// avoid the need for `rustc_hir` to depend on `rustc_session`, so we\n /// use a closure instead.\n pub fn extract<'a, F>(check_name: F, attrs: &'a [ast::Attribute]) -> Option<(Symbol, Span)>\n where\n@@ -190,17 +198,21 @@ language_item_table! {\n \n     Sized,                   sym::sized,               sized_trait,                Target::Trait;\n     Unsize,                  sym::unsize,              unsize_trait,               Target::Trait;\n-    // Trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n+    /// Trait injected by `#[derive(PartialEq)]`, (i.e. \"Partial EQ\").\n     StructuralPeq,           sym::structural_peq,      structural_peq_trait,       Target::Trait;\n-    // Trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n+    /// Trait injected by `#[derive(Eq)]`, (i.e. \"Total EQ\"; no, I will not apologize).\n     StructuralTeq,           sym::structural_teq,      structural_teq_trait,       Target::Trait;\n     Copy,                    sym::copy,                copy_trait,                 Target::Trait;\n     Clone,                   sym::clone,               clone_trait,                Target::Trait;\n     Sync,                    sym::sync,                sync_trait,                 Target::Trait;\n     DiscriminantKind,        sym::discriminant_kind,   discriminant_kind_trait,    Target::Trait;\n-    // The associated item of `trait DiscriminantKind`.\n+    /// The associated item of the [`DiscriminantKind`] trait.\n     Discriminant,            sym::discriminant_type,   discriminant_type,          Target::AssocTy;\n \n+    PointeeTrait,            sym::pointee_trait,       pointee_trait,              Target::Trait;\n+    Metadata,                sym::metadata_type,       metadata_type,              Target::AssocTy;\n+    DynMetadata,             sym::dyn_metadata,        dyn_metadata,               Target::Struct;\n+\n     Freeze,                  sym::freeze,              freeze_trait,               Target::Trait;\n \n     Drop,                    sym::drop,                drop_trait,                 Target::Trait;\n@@ -238,6 +250,7 @@ language_item_table! {\n \n     Deref,                   sym::deref,               deref_trait,                Target::Trait;\n     DerefMut,                sym::deref_mut,           deref_mut_trait,            Target::Trait;\n+    DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy;\n     Receiver,                sym::receiver,            receiver_trait,             Target::Trait;\n \n     Fn,                      kw::Fn,                   fn_trait,                   Target::Trait;\n@@ -268,7 +281,7 @@ language_item_table! {\n     PanicInfo,               sym::panic_info,          panic_info,                 Target::Struct;\n     PanicLocation,           sym::panic_location,      panic_location,             Target::Struct;\n     PanicImpl,               sym::panic_impl,          panic_impl,                 Target::Fn;\n-    // libstd panic entry point. Necessary for const eval to be able to catch it\n+    /// libstd panic entry point. Necessary for const eval to be able to catch it\n     BeginPanic,              sym::begin_panic,         begin_panic_fn,             Target::Fn;\n \n     ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn;\n@@ -290,7 +303,7 @@ language_item_table! {\n \n     MaybeUninit,             sym::maybe_uninit,        maybe_uninit,               Target::Union;\n \n-    // Align offset for stride != 1; must not panic.\n+    /// Align offset for stride != 1; must not panic.\n     AlignOffset,             sym::align_offset,        align_offset_fn,            Target::Fn;\n \n     Termination,             sym::termination,         termination,                Target::Trait;"}, {"sha": "45bb911130960784d427ac9f6eb102a60f7d28f3", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -5,6 +5,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(const_fn)] // For the unsizing cast on `&[]`\n #![feature(const_panic)]\n+#![feature(extended_key_value_attributes)]\n #![feature(in_band_lifetimes)]\n #![feature(once_cell)]\n #![feature(or_patterns)]\n@@ -30,6 +31,9 @@ mod stable_hash_impls;\n mod target;\n pub mod weak_lang_items;\n \n+#[cfg(test)]\n+mod tests;\n+\n pub use hir::*;\n pub use hir_id::*;\n pub use lang_items::{LangItem, LanguageItems};"}, {"sha": "55e87663a1ee773de7187a3d40213fc3be4b99b2", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n \n use crate::hir::{\n-    BodyId, Expr, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, Mod, TraitItem, TraitItemId,\n-    Ty, VisibilityKind,\n+    BodyId, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, MacroDef, Mod,\n+    TraitItem, TraitItemId, Ty, VisibilityKind,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n use rustc_span::def_id::{DefPathHash, LocalDefId};\n@@ -34,30 +34,39 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n     }\n }\n \n+impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n+    }\n+}\n+\n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n-    type KeyType = (DefPathHash, ItemLocalId);\n+    type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        self.hir_id.to_stable_hash_key(hcx)\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n-    type KeyType = (DefPathHash, ItemLocalId);\n+    type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        self.hir_id.to_stable_hash_key(hcx)\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId {\n-    type KeyType = (DefPathHash, ItemLocalId);\n+    type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        self.hir_id.to_stable_hash_key(hcx)\n+    fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n+        hcx.local_def_path_hash(self.def_id)\n     }\n }\n \n@@ -82,25 +91,25 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for BodyId {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ForeignItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItemId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_reference_to_item(self.hir_id, hasher)\n+        hcx.hash_reference_to_item(self.hir_id(), hasher)\n     }\n }\n \n@@ -130,11 +139,10 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for VisibilityKind<'_>\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItem<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let TraitItem { hir_id: _, ident, ref attrs, ref generics, ref kind, span } = *self;\n+        let TraitItem { def_id: _, ident, ref generics, ref kind, span } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n@@ -144,39 +152,55 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItem<'_> {\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ImplItem<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let ImplItem {\n-            hir_id: _,\n-            ident,\n-            ref vis,\n-            defaultness,\n-            ref attrs,\n-            ref generics,\n-            ref kind,\n-            span,\n-        } = *self;\n+        let ImplItem { def_id: _, ident, ref vis, defaultness, ref generics, ref kind, span } =\n+            *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         });\n     }\n }\n \n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for ForeignItem<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        let ForeignItem { def_id: _, ident, ref kind, span, ref vis } = *self;\n+\n+        hcx.hash_hir_item_like(|hcx| {\n+            ident.name.hash_stable(hcx, hasher);\n+            kind.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let Item { ident, ref attrs, hir_id: _, ref kind, ref vis, span } = *self;\n+        let Item { ident, def_id: _, ref kind, ref vis, span } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n             ident.name.hash_stable(hcx, hasher);\n-            attrs.hash_stable(hcx, hasher);\n             kind.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         });\n     }\n }\n+\n+impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for MacroDef<'_> {\n+    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n+        let MacroDef { ident, def_id: _, ref ast, ref vis, span } = *self;\n+\n+        hcx.hash_hir_item_like(|hcx| {\n+            ident.name.hash_stable(hcx, hasher);\n+            ast.hash_stable(hcx, hasher);\n+            vis.hash_stable(hcx, hasher);\n+            span.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "2aafc6afa236d8fd5d2b6c7e0361768d1aace5e5", "filename": "compiler/rustc_hir/src/tests.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftests.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -0,0 +1,39 @@\n+use crate::definitions::{DefKey, DefPathData, DisambiguatedDefPathData};\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_span::crate_disambiguator::CrateDisambiguator;\n+use rustc_span::def_id::{DefPathHash, StableCrateId};\n+\n+#[test]\n+fn def_path_hash_depends_on_crate_id() {\n+    // This test makes sure that *both* halves of a DefPathHash depend on\n+    // the crate-id of the defining crate. This is a desirable property\n+    // because the crate-id can be more easily changed than the DefPath\n+    // of an item, so, in the case of a crate-local DefPathHash collision,\n+    // the user can simply \"role the dice again\" for all DefPathHashes in\n+    // the crate by changing the crate disambiguator (e.g. via bumping the\n+    // crate's version number).\n+\n+    let d0 = CrateDisambiguator::from(Fingerprint::new(12, 34));\n+    let d1 = CrateDisambiguator::from(Fingerprint::new(56, 78));\n+\n+    let h0 = mk_test_hash(\"foo\", d0);\n+    let h1 = mk_test_hash(\"foo\", d1);\n+\n+    assert_ne!(h0.stable_crate_id(), h1.stable_crate_id());\n+    assert_ne!(h0.local_hash(), h1.local_hash());\n+\n+    fn mk_test_hash(crate_name: &str, crate_disambiguator: CrateDisambiguator) -> DefPathHash {\n+        let stable_crate_id = StableCrateId::new(crate_name, crate_disambiguator);\n+        let parent_hash = DefPathHash::new(stable_crate_id, 0);\n+\n+        let key = DefKey {\n+            parent: None,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: DefPathData::CrateRoot,\n+                disambiguator: 0,\n+            },\n+        };\n+\n+        key.compute_stable_hash(parent_hash)\n+    }\n+}"}, {"sha": "9c2766a16318db38794b02f148a9893697618926", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -16,6 +16,7 @@ use rustc_target::spec::abi::Abi;\n \n use std::borrow::Cow;\n use std::cell::Cell;\n+use std::collections::BTreeMap;\n use std::vec;\n \n pub fn id_to_string(map: &dyn rustc_hir::intravisit::Map<'_>, hir_id: hir::HirId) -> String {\n@@ -54,7 +55,7 @@ pub const NO_ANN: &dyn PpAnn = &NoAnn;\n impl PpAnn for hir::Crate<'_> {\n     fn nested(&self, state: &mut State<'_>, nested: Nested) {\n         match nested {\n-            Nested::Item(id) => state.print_item(self.item(id.id)),\n+            Nested::Item(id) => state.print_item(self.item(id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::ForeignItem(id) => state.print_foreign_item(self.foreign_item(id)),\n@@ -69,7 +70,7 @@ impl PpAnn for hir::Crate<'_> {\n impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n     fn nested(&self, state: &mut State<'_>, nested: Nested) {\n         match nested {\n-            Nested::Item(id) => state.print_item(self.item(id.id)),\n+            Nested::Item(id) => state.print_item(self.item(id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::ForeignItem(id) => state.print_foreign_item(self.foreign_item(id)),\n@@ -82,6 +83,7 @@ impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n+    attrs: &'a BTreeMap<hir::HirId, &'a [ast::Attribute]>,\n     ann: &'a (dyn PpAnn + 'a),\n }\n \n@@ -163,12 +165,12 @@ pub fn print_crate<'a>(\n     input: String,\n     ann: &'a dyn PpAnn,\n ) -> String {\n-    let mut s = State::new_from_input(sm, filename, input, ann);\n+    let mut s = State::new_from_input(sm, filename, input, &krate.attrs, ann);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n \n-    s.print_mod(&krate.item.module, &krate.item.attrs);\n+    s.print_mod(&krate.item.module, s.attrs(hir::CRATE_HIR_ID));\n     s.print_remaining_comments();\n     s.s.eof()\n }\n@@ -178,17 +180,28 @@ impl<'a> State<'a> {\n         sm: &'a SourceMap,\n         filename: FileName,\n         input: String,\n+        attrs: &'a BTreeMap<hir::HirId, &[ast::Attribute]>,\n         ann: &'a dyn PpAnn,\n     ) -> State<'a> {\n-        State { s: pp::mk_printer(), comments: Some(Comments::new(sm, filename, input)), ann }\n+        State {\n+            s: pp::mk_printer(),\n+            comments: Some(Comments::new(sm, filename, input)),\n+            attrs,\n+            ann,\n+        }\n+    }\n+\n+    fn attrs(&self, id: hir::HirId) -> &'a [ast::Attribute] {\n+        self.attrs.get(&id).map_or(&[], |la| *la)\n     }\n }\n \n pub fn to_string<F>(ann: &dyn PpAnn, f: F) -> String\n where\n     F: FnOnce(&mut State<'_>),\n {\n-    let mut printer = State { s: pp::mk_printer(), comments: None, ann };\n+    let mut printer =\n+        State { s: pp::mk_printer(), comments: None, attrs: &BTreeMap::default(), ann };\n     f(&mut printer);\n     printer.s.eof()\n }\n@@ -392,7 +405,7 @@ impl<'a> State<'a> {\n                     &f.decl,\n                     None,\n                     &f.generic_params,\n-                    &f.param_names[..],\n+                    f.param_names,\n                 );\n             }\n             hir::TyKind::OpaqueDef(..) => self.s.word(\"/*impl Trait*/\"),\n@@ -441,7 +454,7 @@ impl<'a> State<'a> {\n     pub fn print_foreign_item(&mut self, item: &hir::ForeignItem<'_>) {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n+        self.print_outer_attributes(self.attrs(item.hir_id()));\n         match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, ref arg_names, ref generics) => {\n                 self.head(\"\");\n@@ -549,7 +562,8 @@ impl<'a> State<'a> {\n     pub fn print_item(&mut self, item: &hir::Item<'_>) {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n+        let attrs = self.attrs(item.hir_id());\n+        self.print_outer_attributes(attrs);\n         self.ann.pre(self, AnnNode::Item(item));\n         match item.kind {\n             hir::ItemKind::ExternCrate(orig_name) => {\n@@ -634,14 +648,14 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident);\n                 self.nbsp();\n                 self.bopen();\n-                self.print_mod(_mod, &item.attrs);\n+                self.print_mod(_mod, attrs);\n                 self.bclose(item.span);\n             }\n             hir::ItemKind::ForeignMod { abi, items } => {\n                 self.head(\"extern\");\n                 self.word_nbsp(abi.to_string());\n                 self.bopen();\n-                self.print_inner_attributes(item.attrs);\n+                self.print_inner_attributes(self.attrs(item.hir_id()));\n                 for item in items {\n                     self.ann.nested(self, Nested::ForeignItem(item.id));\n                 }\n@@ -725,7 +739,7 @@ impl<'a> State<'a> {\n \n                 self.s.space();\n                 self.bopen();\n-                self.print_inner_attributes(&item.attrs);\n+                self.print_inner_attributes(attrs);\n                 for impl_item in items {\n                     self.ann.nested(self, Nested::ImplItem(impl_item.id));\n                 }\n@@ -822,7 +836,7 @@ impl<'a> State<'a> {\n         for v in variants {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.attrs);\n+            self.print_outer_attributes(self.attrs(v.id));\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n@@ -876,7 +890,7 @@ impl<'a> State<'a> {\n                     self.popen();\n                     self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n                         s.maybe_print_comment(field.span.lo());\n-                        s.print_outer_attributes(&field.attrs);\n+                        s.print_outer_attributes(s.attrs(field.hir_id));\n                         s.print_visibility(&field.vis);\n                         s.print_type(&field.ty)\n                     });\n@@ -898,7 +912,7 @@ impl<'a> State<'a> {\n                 for field in struct_def.fields() {\n                     self.hardbreak_if_not_bol();\n                     self.maybe_print_comment(field.span.lo());\n-                    self.print_outer_attributes(&field.attrs);\n+                    self.print_outer_attributes(self.attrs(field.hir_id));\n                     self.print_visibility(&field.vis);\n                     self.print_ident(field.ident);\n                     self.word_nbsp(\":\");\n@@ -934,10 +948,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem<'_>) {\n-        self.ann.pre(self, AnnNode::SubItem(ti.hir_id));\n+        self.ann.pre(self, AnnNode::SubItem(ti.hir_id()));\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ti.span.lo());\n-        self.print_outer_attributes(&ti.attrs);\n+        self.print_outer_attributes(self.attrs(ti.hir_id()));\n         match ti.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 let vis =\n@@ -969,14 +983,14 @@ impl<'a> State<'a> {\n                 );\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ti.hir_id))\n+        self.ann.post(self, AnnNode::SubItem(ti.hir_id()))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem<'_>) {\n-        self.ann.pre(self, AnnNode::SubItem(ii.hir_id));\n+        self.ann.pre(self, AnnNode::SubItem(ii.hir_id()));\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(ii.span.lo());\n-        self.print_outer_attributes(&ii.attrs);\n+        self.print_outer_attributes(self.attrs(ii.hir_id()));\n         self.print_defaultness(ii.defaultness);\n \n         match ii.kind {\n@@ -995,7 +1009,7 @@ impl<'a> State<'a> {\n                 self.print_associated_type(ii.ident, &ii.generics, None, Some(ty));\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ii.hir_id))\n+        self.ann.post(self, AnnNode::SubItem(ii.hir_id()))\n     }\n \n     pub fn print_local(&mut self, init: Option<&hir::Expr<'_>>, decl: impl Fn(&mut Self)) {\n@@ -1200,7 +1214,7 @@ impl<'a> State<'a> {\n         self.s.word(\"{\");\n         self.commasep_cmnt(\n             Consistent,\n-            &fields[..],\n+            fields,\n             |s, field| {\n                 s.ibox(INDENT_UNIT);\n                 if !field.is_shorthand {\n@@ -1321,7 +1335,7 @@ impl<'a> State<'a> {\n \n     pub fn print_expr(&mut self, expr: &hir::Expr<'_>) {\n         self.maybe_print_comment(expr.span.lo());\n-        self.print_outer_attributes(&expr.attrs);\n+        self.print_outer_attributes(self.attrs(expr.hir_id));\n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match expr.kind {\n@@ -2020,20 +2034,20 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_param(&mut self, arg: &hir::Param<'_>) {\n-        self.print_outer_attributes(&arg.attrs);\n+        self.print_outer_attributes(self.attrs(arg.hir_id));\n         self.print_pat(&arg.pat);\n     }\n \n     pub fn print_arm(&mut self, arm: &hir::Arm<'_>) {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n-        if arm.attrs.is_empty() {\n+        if self.attrs(arm.hir_id).is_empty() {\n             self.s.space();\n         }\n         self.cbox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n-        self.print_outer_attributes(&arm.attrs);\n+        self.print_outer_attributes(&self.attrs(arm.hir_id));\n         self.print_pat(&arm.pat);\n         self.s.space();\n         if let Some(ref g) = arm.guard {"}, {"sha": "89a5836d6dfe71b12d62e4c512215ed29e85a72a", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -68,7 +68,7 @@ pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n         let (if_this_changed, then_this_would_need) = {\n             let mut visitor =\n                 IfThisChanged { tcx, if_this_changed: vec![], then_this_would_need: vec![] };\n-            visitor.process_attrs(hir::CRATE_HIR_ID, &tcx.hir().krate().item.attrs);\n+            visitor.process_attrs(hir::CRATE_HIR_ID);\n             tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n             (visitor.if_this_changed, visitor.then_this_would_need)\n         };\n@@ -113,9 +113,10 @@ impl IfThisChanged<'tcx> {\n         value\n     }\n \n-    fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n+    fn process_attrs(&mut self, hir_id: hir::HirId) {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n+        let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n             if self.tcx.sess.check_name(attr, sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n@@ -167,22 +168,22 @@ impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id, &item.attrs);\n+        self.process_attrs(item.hir_id());\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.process_attrs(trait_item.hir_id, &trait_item.attrs);\n+        self.process_attrs(trait_item.hir_id());\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.process_attrs(impl_item.hir_id, &impl_item.attrs);\n+        self.process_attrs(impl_item.hir_id());\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.process_attrs(s.hir_id, &s.attrs);\n+        self.process_attrs(s.hir_id);\n         intravisit::walk_struct_field(self, s);\n     }\n }"}, {"sha": "5fb2c1cb9c9236e314a052cf1fb00dd062225da2", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -44,7 +44,7 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n \n         let ams = AssertModuleSource { tcx, available_cgus };\n \n-        for attr in tcx.hir().krate().item.attrs {\n+        for attr in tcx.hir().attrs(rustc_hir::CRATE_HIR_ID) {\n             ams.check_attr(attr);\n         }\n     })"}, {"sha": "0b544b8ab415e4458d4907ff2644b1bcedd6bbc0", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -17,7 +17,7 @@ use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::Node as HirNode;\n@@ -168,7 +168,7 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n         // Note that we cannot use the existing \"unused attribute\"-infrastructure\n         // here, since that is running before codegen. This is also the reason why\n         // all codegen-specific attributes are `AssumedUsed` in rustc_ast::feature_gate.\n-        all_attrs.report_unchecked_attrs(&dirty_clean_visitor.checked_attrs);\n+        all_attrs.report_unchecked_attrs(dirty_clean_visitor.checked_attrs);\n     })\n }\n \n@@ -179,7 +179,7 @@ pub struct DirtyCleanVisitor<'tcx> {\n \n impl DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n-    fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute) -> Option<Assertion> {\n+    fn assertion_maybe(&mut self, item_id: LocalDefId, attr: &Attribute) -> Option<Assertion> {\n         let is_clean = if self.tcx.sess.check_name(attr, sym::rustc_dirty) {\n             false\n         } else if self.tcx.sess.check_name(attr, sym::rustc_clean) {\n@@ -207,7 +207,7 @@ impl DirtyCleanVisitor<'tcx> {\n     /// Gets the \"auto\" assertion on pre-validated attr, along with the `except` labels.\n     fn assertion_auto(\n         &mut self,\n-        item_id: hir::HirId,\n+        item_id: LocalDefId,\n         attr: &Attribute,\n         is_clean: bool,\n     ) -> Assertion {\n@@ -253,8 +253,9 @@ impl DirtyCleanVisitor<'tcx> {\n \n     /// Return all DepNode labels that should be asserted for this item.\n     /// index=0 is the \"name\" used for error messages\n-    fn auto_labels(&mut self, item_id: hir::HirId, attr: &Attribute) -> (&'static str, Labels) {\n-        let node = self.tcx.hir().get(item_id);\n+    fn auto_labels(&mut self, item_id: LocalDefId, attr: &Attribute) -> (&'static str, Labels) {\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(item_id);\n+        let node = self.tcx.hir().get(hir_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n                 match item.kind {\n@@ -430,18 +431,17 @@ impl DirtyCleanVisitor<'tcx> {\n         }\n     }\n \n-    fn check_item(&mut self, item_id: hir::HirId, item_span: Span) {\n-        let def_id = self.tcx.hir().local_def_id(item_id);\n-        for attr in self.tcx.get_attrs(def_id.to_def_id()).iter() {\n+    fn check_item(&mut self, item_id: LocalDefId, item_span: Span) {\n+        for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n             let assertion = match self.assertion_maybe(item_id, attr) {\n                 Some(a) => a,\n                 None => continue,\n             };\n             self.checked_attrs.insert(attr.id);\n-            for dep_node in self.dep_nodes(&assertion.clean, def_id.to_def_id()) {\n+            for dep_node in self.dep_nodes(&assertion.clean, item_id.to_def_id()) {\n                 self.assert_clean(item_span, dep_node);\n             }\n-            for dep_node in self.dep_nodes(&assertion.dirty, def_id.to_def_id()) {\n+            for dep_node in self.dep_nodes(&assertion.dirty, item_id.to_def_id()) {\n                 self.assert_dirty(item_span, dep_node);\n             }\n         }\n@@ -450,19 +450,19 @@ impl DirtyCleanVisitor<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.def_id, item.span);\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem<'_>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.def_id, item.span);\n     }\n \n     fn visit_impl_item(&mut self, item: &hir::ImplItem<'_>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.def_id, item.span);\n     }\n \n     fn visit_foreign_item(&mut self, item: &hir::ForeignItem<'_>) {\n-        self.check_item(item.hir_id, item.span);\n+        self.check_item(item.def_id, item.span);\n     }\n }\n \n@@ -535,13 +535,14 @@ impl FindAllAttrs<'_, 'tcx> {\n         false\n     }\n \n-    fn report_unchecked_attrs(&self, checked_attrs: &FxHashSet<ast::AttrId>) {\n+    fn report_unchecked_attrs(&self, mut checked_attrs: FxHashSet<ast::AttrId>) {\n         for attr in &self.found_attrs {\n             if !checked_attrs.contains(&attr.id) {\n                 self.tcx.sess.span_err(\n                     attr.span,\n                     \"found unchecked `#[rustc_dirty]` / `#[rustc_clean]` attribute\",\n                 );\n+                checked_attrs.insert(attr.id);\n             }\n         }\n     }\n@@ -554,7 +555,7 @@ impl intravisit::Visitor<'tcx> for FindAllAttrs<'_, 'tcx> {\n         intravisit::NestedVisitorMap::All(self.tcx.hir())\n     }\n \n-    fn visit_attribute(&mut self, attr: &'tcx Attribute) {\n+    fn visit_attribute(&mut self, _: hir::HirId, attr: &'tcx Attribute) {\n         if self.is_active_attr(attr) {\n             self.found_attrs.push(attr);\n         }"}, {"sha": "374a9eb41e5c72be10ab654acc630b304649d21e", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -109,7 +109,7 @@ fn report_format_mismatch(report_incremental_info: bool, file: &Path, message: &\n     debug!(\"read_file: {}\", message);\n \n     if report_incremental_info {\n-        println!(\n+        eprintln!(\n             \"[incremental] ignoring cache artifact `{}`: {}\",\n             file.file_name().unwrap().to_string_lossy(),\n             message"}, {"sha": "c7a6c1195c5033cef24a587f55c5e098d0530567", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -440,12 +440,12 @@ fn copy_files(sess: &Session, target_dir: &Path, source_dir: &Path) -> Result<bo\n     }\n \n     if sess.opts.debugging_opts.incremental_info {\n-        println!(\n+        eprintln!(\n             \"[incremental] session directory: \\\n                   {} files hard-linked\",\n             files_linked\n         );\n-        println!(\n+        eprintln!(\n             \"[incremental] session directory: \\\n                  {} files copied\",\n             files_copied"}, {"sha": "2b5649bb0594f57de4d749f630278bb4026c8288", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -170,7 +170,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n \n                 if prev_commandline_args_hash != expected_hash {\n                     if report_incremental_info {\n-                        println!(\n+                        eprintln!(\n                             \"[incremental] completely ignoring cache because of \\\n                                     differing commandline arguments\"\n                         );"}, {"sha": "3882818952c33dfa580c21cf437af25606e1ea64", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -111,6 +111,7 @@ macro_rules! newtype_index {\n         }\n \n         impl Clone for $type {\n+            #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n@@ -694,9 +695,7 @@ impl<I: Idx, T> IndexVec<I, T> {\n     pub fn convert_index_type<Ix: Idx>(self) -> IndexVec<Ix, T> {\n         IndexVec { raw: self.raw, _marker: PhantomData }\n     }\n-}\n \n-impl<I: Idx, T: Clone> IndexVec<I, T> {\n     /// Grows the index vector so that it contains an entry for\n     /// `elem`; if that is already true, then has no\n     /// effect. Otherwise, inserts new values as needed by invoking\n@@ -709,18 +708,20 @@ impl<I: Idx, T: Clone> IndexVec<I, T> {\n         }\n     }\n \n-    #[inline]\n-    pub fn resize(&mut self, new_len: usize, value: T) {\n-        self.raw.resize(new_len, value)\n-    }\n-\n     #[inline]\n     pub fn resize_to_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n         let min_new_len = elem.index() + 1;\n         self.raw.resize_with(min_new_len, fill_value);\n     }\n }\n \n+impl<I: Idx, T: Clone> IndexVec<I, T> {\n+    #[inline]\n+    pub fn resize(&mut self, new_len: usize, value: T) {\n+        self.raw.resize(new_len, value)\n+    }\n+}\n+\n impl<I: Idx, T: Ord> IndexVec<I, T> {\n     #[inline]\n     pub fn binary_search(&self, value: &T) -> Result<I, I> {"}, {"sha": "11ee8fb17ad1b4abc01175e138d765b28e192bb1", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -55,6 +55,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n     fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -178,7 +179,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n+        let trace = ToTrace::to_trace(self.infcx.tcx, self.cause, a_is_expected, a, b);\n         Trace { at: self, trace, a_is_expected }\n     }\n }\n@@ -251,6 +252,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -262,6 +264,7 @@ impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -273,6 +276,7 @@ impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -284,6 +288,7 @@ impl<'tcx> ToTrace<'tcx> for &'tcx Const<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -298,6 +303,7 @@ impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n     fn to_trace(\n+        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -309,3 +315,20 @@ impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> ToTrace<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        let a_ty = tcx.mk_projection(a.item_def_id, a.substs);\n+        let b_ty = tcx.mk_projection(b.item_def_id, b.substs);\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Types(ExpectedFound::new(a_is_expected, a_ty, b_ty)),\n+        }\n+    }\n+}"}, {"sha": "2ec9b9e0be4a81ef810a8231d18b5fc103380fd8", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -507,12 +507,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         // Unify the original value for each variable with the value\n         // taken from `query_response` (after applying `result_subst`).\n-        Ok(self.unify_canonical_vars(\n-            cause,\n-            param_env,\n-            original_values,\n-            substituted_query_response,\n-        )?)\n+        self.unify_canonical_vars(cause, param_env, original_values, substituted_query_response)\n     }\n \n     /// Converts the region constraints resulting from a query into an"}, {"sha": "eeff48a63950e03f58e3a244abf363879e065759", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -50,6 +50,7 @@ use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n use crate::infer;\n+use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -179,7 +180,14 @@ fn msg_span_from_early_bound_and_free_regions(\n         }\n         ty::ReFree(ref fr) => match fr.bound_region {\n             ty::BrAnon(idx) => {\n-                (format!(\"the anonymous lifetime #{} defined on\", idx + 1), tcx.hir().span(node))\n+                if let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region) {\n+                    (\"the anonymous lifetime defined on\".to_string(), ty.span)\n+                } else {\n+                    (\n+                        format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n+                        tcx.hir().span(node),\n+                    )\n+                }\n             }\n             _ => (\n                 format!(\"the lifetime `{}` as defined on\", region),\n@@ -1484,13 +1492,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 for (key, values) in types.iter() {\n                     let count = values.len();\n                     let kind = key.descr();\n+                    let mut returned_async_output_error = false;\n                     for sp in values {\n                         err.span_label(\n                             *sp,\n                             format!(\n                                 \"{}{}{} {}{}\",\n-                                if sp.is_desugaring(DesugaringKind::Async) {\n-                                    \"the `Output` of this `async fn`'s \"\n+                                if sp.is_desugaring(DesugaringKind::Async)\n+                                    && !returned_async_output_error\n+                                {\n+                                    \"checked the `Output` of this `async fn`, \"\n                                 } else if count == 1 {\n                                     \"the \"\n                                 } else {\n@@ -1502,14 +1513,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 pluralize!(count),\n                             ),\n                         );\n+                        if sp.is_desugaring(DesugaringKind::Async)\n+                            && returned_async_output_error == false\n+                        {\n+                            err.note(\"while checking the return type of the `async fn`\");\n+                            returned_async_output_error = true;\n+                        }\n                     }\n                 }\n             }\n         }\n \n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for OpaqueTypesVisitor<'tcx> {\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if let Some((kind, def_id)) = TyCategory::from_ty(t) {\n+                if let Some((kind, def_id)) = TyCategory::from_ty(self.tcx, t) {\n                     let span = self.tcx.def_span(def_id);\n                     // Avoid cluttering the output when the \"found\" and error span overlap:\n                     //\n@@ -1582,11 +1599,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n         if let Some((expected, found)) = expected_found {\n             let expected_label = match exp_found {\n-                Mismatch::Variable(ef) => ef.expected.prefix_string(),\n+                Mismatch::Variable(ef) => ef.expected.prefix_string(self.tcx),\n                 Mismatch::Fixed(s) => s.into(),\n             };\n             let found_label = match exp_found {\n-                Mismatch::Variable(ef) => ef.found.prefix_string(),\n+                Mismatch::Variable(ef) => ef.found.prefix_string(self.tcx),\n                 Mismatch::Fixed(s) => s.into(),\n             };\n             let exp_found = match exp_found {\n@@ -2489,7 +2506,7 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n pub enum TyCategory {\n     Closure,\n     Opaque,\n-    Generator,\n+    Generator(hir::GeneratorKind),\n     Foreign,\n }\n \n@@ -2498,16 +2515,18 @@ impl TyCategory {\n         match self {\n             Self::Closure => \"closure\",\n             Self::Opaque => \"opaque type\",\n-            Self::Generator => \"generator\",\n+            Self::Generator(gk) => gk.descr(),\n             Self::Foreign => \"foreign type\",\n         }\n     }\n \n-    pub fn from_ty(ty: Ty<'_>) -> Option<(Self, DefId)> {\n+    pub fn from_ty(tcx: TyCtxt<'_>, ty: Ty<'_>) -> Option<(Self, DefId)> {\n         match *ty.kind() {\n             ty::Closure(def_id, _) => Some((Self::Closure, def_id)),\n             ty::Opaque(def_id, _) => Some((Self::Opaque, def_id)),\n-            ty::Generator(def_id, ..) => Some((Self::Generator, def_id)),\n+            ty::Generator(def_id, ..) => {\n+                Some((Self::Generator(tcx.generator_kind(def_id).unwrap()), def_id))\n+            }\n             ty::Foreign(def_id) => Some((Self::Foreign, def_id)),\n             _ => None,\n         }"}, {"sha": "d533e267fd702856ad1ca3a3e467fd0cd0fc8274", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -383,7 +383,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 InferenceDiagnosticsData {\n                     name: s,\n                     span: None,\n-                    kind: UnderspecifiedArgKind::Type { prefix: ty.prefix_string() },\n+                    kind: UnderspecifiedArgKind::Type { prefix: ty.prefix_string(self.tcx) },\n                     parent: None,\n                 }\n             }\n@@ -671,7 +671,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if !impl_candidates.is_empty() && e.span.contains(span) {\n                     if let Some(expr) = exprs.first() {\n                         if let ExprKind::Path(hir::QPath::Resolved(_, path)) = expr.kind {\n-                            if let [path_segment] = &path.segments[..] {\n+                            if let [path_segment] = path.segments {\n                                 let candidate_len = impl_candidates.len();\n                                 let suggestions = impl_candidates.iter().map(|candidate| {\n                                     format!("}, {"sha": "1b35c4032f44c5d14e3fe30e935deb79a7dc4a64", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,6 +1,7 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n+use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n@@ -66,9 +67,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let scope_def_id_sub = anon_reg_sub.def_id;\n         let bregion_sub = anon_reg_sub.boundregion;\n \n-        let ty_sup = self.find_anon_type(sup, &bregion_sup)?;\n+        let ty_sup = find_anon_type(self.tcx(), sup, &bregion_sup)?;\n \n-        let ty_sub = self.find_anon_type(sub, &bregion_sub)?;\n+        let ty_sub = find_anon_type(self.tcx(), sub, &bregion_sub)?;\n \n         debug!(\n             \"try_report_anon_anon_conflict: found_param1={:?} sup={:?} br1={:?}\","}, {"sha": "d9ab83190455130b4a6bbee4fb9dfe329fb60af6", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 55, "deletions": 59, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,72 +1,68 @@\n-use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::resolve_lifetime as rl;\n use rustc_middle::ty::{self, Region, TyCtxt};\n \n-impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// This function calls the `visit_ty` method for the parameters\n-    /// corresponding to the anonymous regions. The `nested_visitor.found_type`\n-    /// contains the anonymous type.\n-    ///\n-    /// # Arguments\n-    /// region - the anonymous region corresponding to the anon_anon conflict\n-    /// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n-    ///\n-    /// # Example\n-    /// ```\n-    /// fn foo(x: &mut Vec<&u8>, y: &u8)\n-    ///    { x.push(y); }\n-    /// ```\n-    /// The function returns the nested type corresponding to the anonymous region\n-    /// for e.g., `&u8` and Vec<`&u8`.\n-    pub(super) fn find_anon_type(\n-        &self,\n-        region: Region<'tcx>,\n-        br: &ty::BoundRegionKind,\n-    ) -> Option<(&hir::Ty<'tcx>, &hir::FnDecl<'tcx>)> {\n-        if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n-            let hir_id = self.tcx().hir().local_def_id_to_hir_id(anon_reg.def_id);\n-            let fndecl = match self.tcx().hir().get(hir_id) {\n-                Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n-                | Node::TraitItem(&hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(ref m, ..),\n-                    ..\n-                })\n-                | Node::ImplItem(&hir::ImplItem {\n-                    kind: hir::ImplItemKind::Fn(ref m, ..), ..\n-                }) => &m.decl,\n-                _ => return None,\n-            };\n+/// This function calls the `visit_ty` method for the parameters\n+/// corresponding to the anonymous regions. The `nested_visitor.found_type`\n+/// contains the anonymous type.\n+///\n+/// # Arguments\n+/// region - the anonymous region corresponding to the anon_anon conflict\n+/// br - the bound region corresponding to the above region which is of type `BrAnon(_)`\n+///\n+/// # Example\n+/// ```\n+/// fn foo(x: &mut Vec<&u8>, y: &u8)\n+///    { x.push(y); }\n+/// ```\n+/// The function returns the nested type corresponding to the anonymous region\n+/// for e.g., `&u8` and `Vec<&u8>`.\n+pub(crate) fn find_anon_type(\n+    tcx: TyCtxt<'tcx>,\n+    region: Region<'tcx>,\n+    br: &ty::BoundRegionKind,\n+) -> Option<(&'tcx hir::Ty<'tcx>, &'tcx hir::FnDecl<'tcx>)> {\n+    if let Some(anon_reg) = tcx.is_suitable_region(region) {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n+        let fndecl = match tcx.hir().get(hir_id) {\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n+            | Node::TraitItem(&hir::TraitItem {\n+                kind: hir::TraitItemKind::Fn(ref m, ..), ..\n+            })\n+            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(ref m, ..), .. }) => {\n+                &m.decl\n+            }\n+            _ => return None,\n+        };\n \n-            fndecl\n-                .inputs\n-                .iter()\n-                .find_map(|arg| self.find_component_for_bound_region(arg, br))\n-                .map(|ty| (ty, &**fndecl))\n-        } else {\n-            None\n-        }\n+        fndecl\n+            .inputs\n+            .iter()\n+            .find_map(|arg| find_component_for_bound_region(tcx, arg, br))\n+            .map(|ty| (ty, &**fndecl))\n+    } else {\n+        None\n     }\n+}\n \n-    // This method creates a FindNestedTypeVisitor which returns the type corresponding\n-    // to the anonymous region.\n-    fn find_component_for_bound_region(\n-        &self,\n-        arg: &'tcx hir::Ty<'tcx>,\n-        br: &ty::BoundRegionKind,\n-    ) -> Option<&'tcx hir::Ty<'tcx>> {\n-        let mut nested_visitor = FindNestedTypeVisitor {\n-            tcx: self.tcx(),\n-            bound_region: *br,\n-            found_type: None,\n-            current_index: ty::INNERMOST,\n-        };\n-        nested_visitor.visit_ty(arg);\n-        nested_visitor.found_type\n-    }\n+// This method creates a FindNestedTypeVisitor which returns the type corresponding\n+// to the anonymous region.\n+fn find_component_for_bound_region(\n+    tcx: TyCtxt<'tcx>,\n+    arg: &'tcx hir::Ty<'tcx>,\n+    br: &ty::BoundRegionKind,\n+) -> Option<&'tcx hir::Ty<'tcx>> {\n+    let mut nested_visitor = FindNestedTypeVisitor {\n+        tcx,\n+        bound_region: *br,\n+        found_type: None,\n+        current_index: ty::INNERMOST,\n+    };\n+    nested_visitor.visit_ty(arg);\n+    nested_visitor.found_type\n }\n \n // The FindNestedTypeVisitor captures the corresponding `hir::Ty` of the"}, {"sha": "e20436690b3aa1d42309ea097afa3fa5bc216218", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n \n mod different_lifetimes;\n-mod find_anon_type;\n+pub mod find_anon_type;\n mod named_anon_conflict;\n mod placeholder_error;\n mod static_impl_trait;\n@@ -43,7 +43,7 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'cx>> {\n+    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'tcx>> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n         self.try_report_named_anon_conflict().or_else(|| self.try_report_placeholder_conflict())"}, {"sha": "2f3c0d6957a613f12ff33bd428369aab78cc83e1", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -1,5 +1,6 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n+use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir::intravisit::Visitor;\n@@ -9,7 +10,7 @@ use rustc_middle::ty;\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n-    pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n+    pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'tcx>> {\n         let (span, sub, sup) = self.regions()?;\n \n         debug!(\n@@ -74,7 +75,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             return None;\n         }\n \n-        if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n+        if let Some((_, fndecl)) = find_anon_type(self.tcx(), anon, &br) {\n             if self.is_self_anon(is_first, scope_def_id) {\n                 return None;\n             }"}, {"sha": "4aecc2f40b8741599ee61e8966ff1de700dd8344", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 126, "deletions": 106, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -16,7 +16,7 @@ use std::fmt::{self, Write};\n impl NiceRegionError<'me, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit a descriptive diagnostic error.\n-    pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'me>> {\n+    pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'tcx>> {\n         match &self.error {\n             ///////////////////////////////////////////////////////////////////////////\n             // NB. The ordering of cases in this match is very\n@@ -30,157 +30,153 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_placeholder @ ty::RePlaceholder(_),\n                 _,\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 Some(sub_placeholder),\n                 Some(sup_placeholder),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_placeholder @ ty::RePlaceholder(_),\n                 _,\n                 _,\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 Some(sub_placeholder),\n                 None,\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 _,\n                 _,\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n                 _,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::UpperBoundUniverseConflict(\n                 vid,\n                 _,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_region @ ty::RePlaceholder(_),\n                 sup_region @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 None,\n                 cause,\n                 Some(*sub_region),\n                 Some(*sup_region),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_region @ ty::RePlaceholder(_),\n                 sup_region,\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n-                Some(sup_region),\n+            )) => self.try_report_trait_placeholder_mismatch(\n+                (!sup_region.has_name()).then_some(sup_region),\n                 cause,\n-                Some(*sub_region),\n+                Some(sub_region),\n                 None,\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_region,\n                 sup_region @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n-                Some(sub_region),\n+            )) => self.try_report_trait_placeholder_mismatch(\n+                (!sub_region.has_name()).then_some(sub_region),\n                 cause,\n                 None,\n-                Some(*sup_region),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                Some(sup_region),\n+                values,\n+            ),\n \n             _ => None,\n         }\n     }\n \n+    fn try_report_trait_placeholder_mismatch(\n+        &self,\n+        vid: Option<ty::Region<'tcx>>,\n+        cause: &ObligationCause<'tcx>,\n+        sub_placeholder: Option<ty::Region<'tcx>>,\n+        sup_placeholder: Option<ty::Region<'tcx>>,\n+        value_pairs: &ValuePairs<'tcx>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        let (expected_substs, found_substs, trait_def_id) = match value_pairs {\n+            ValuePairs::TraitRefs(ExpectedFound { expected, found })\n+                if expected.def_id == found.def_id =>\n+            {\n+                (expected.substs, found.substs, expected.def_id)\n+            }\n+            ValuePairs::PolyTraitRefs(ExpectedFound { expected, found })\n+                if expected.def_id() == found.def_id() =>\n+            {\n+                // It's possible that the placeholders come from a binder\n+                // outside of this value pair. Use `no_bound_vars` as a\n+                // simple heuristic for that.\n+                (expected.no_bound_vars()?.substs, found.no_bound_vars()?.substs, expected.def_id())\n+            }\n+            _ => return None,\n+        };\n+\n+        Some(self.report_trait_placeholder_mismatch(\n+            vid,\n+            cause,\n+            sub_placeholder,\n+            sup_placeholder,\n+            trait_def_id,\n+            expected_substs,\n+            found_substs,\n+        ))\n+    }\n+\n     // error[E0308]: implementation of `Foo` does not apply to enough lifetimes\n     //   --> /home/nmatsakis/tmp/foo.rs:12:5\n     //    |\n@@ -190,7 +186,8 @@ impl NiceRegionError<'me, 'tcx> {\n     //    = note: Due to a where-clause on the function `all`,\n     //    = note: `T` must implement `...` for any two lifetimes `'1` and `'2`.\n     //    = note: However, the type `T` only implements `...` for some specific lifetime `'2`.\n-    fn try_report_placeholders_trait(\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn report_trait_placeholder_mismatch(\n         &self,\n         vid: Option<ty::Region<'tcx>>,\n         cause: &ObligationCause<'tcx>,\n@@ -199,28 +196,13 @@ impl NiceRegionError<'me, 'tcx> {\n         trait_def_id: DefId,\n         expected_substs: SubstsRef<'tcx>,\n         actual_substs: SubstsRef<'tcx>,\n-    ) -> DiagnosticBuilder<'me> {\n-        debug!(\n-            \"try_report_placeholders_trait(\\\n-             vid={:?}, \\\n-             sub_placeholder={:?}, \\\n-             sup_placeholder={:?}, \\\n-             trait_def_id={:?}, \\\n-             expected_substs={:?}, \\\n-             actual_substs={:?})\",\n-            vid, sub_placeholder, sup_placeholder, trait_def_id, expected_substs, actual_substs\n-        );\n-\n+    ) -> DiagnosticBuilder<'tcx> {\n         let span = cause.span(self.tcx());\n         let msg = format!(\n             \"implementation of `{}` is not general enough\",\n             self.tcx().def_path_str(trait_def_id),\n         );\n         let mut err = self.tcx().sess.struct_span_err(span, &msg);\n-        err.span_label(\n-            self.tcx().def_span(trait_def_id),\n-            format!(\"trait `{}` defined here\", self.tcx().def_path_str(trait_def_id)),\n-        );\n \n         let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id) = cause.code {\n             err.span_label(span, \"doesn't satisfy where-clause\");\n@@ -285,17 +267,13 @@ impl NiceRegionError<'me, 'tcx> {\n \n         let any_self_ty_has_vid = actual_self_ty_has_vid || expected_self_ty_has_vid;\n \n-        debug!(\"try_report_placeholders_trait: actual_has_vid={:?}\", actual_has_vid);\n-        debug!(\"try_report_placeholders_trait: expected_has_vid={:?}\", expected_has_vid);\n-        debug!(\"try_report_placeholders_trait: has_sub={:?}\", has_sub);\n-        debug!(\"try_report_placeholders_trait: has_sup={:?}\", has_sup);\n         debug!(\n-            \"try_report_placeholders_trait: actual_self_ty_has_vid={:?}\",\n-            actual_self_ty_has_vid\n-        );\n-        debug!(\n-            \"try_report_placeholders_trait: expected_self_ty_has_vid={:?}\",\n-            expected_self_ty_has_vid\n+            ?actual_has_vid,\n+            ?expected_has_vid,\n+            ?has_sub,\n+            ?has_sup,\n+            ?actual_self_ty_has_vid,\n+            ?expected_self_ty_has_vid,\n         );\n \n         self.explain_actual_impl_that_was_found(\n@@ -388,6 +366,8 @@ impl NiceRegionError<'me, 'tcx> {\n             value: trait_ref,\n         };\n \n+        let same_self_type = actual_trait_ref.self_ty() == expected_trait_ref.self_ty();\n+\n         let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n         expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n         expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n@@ -403,7 +383,42 @@ impl NiceRegionError<'me, 'tcx> {\n                 }\n             };\n \n-            let mut note = if passive_voice {\n+            let mut note = if same_self_type {\n+                let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n+                self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+\n+                if self_ty.value.is_closure()\n+                    && self\n+                        .tcx()\n+                        .fn_trait_kind_from_lang_item(expected_trait_ref.value.def_id)\n+                        .is_some()\n+                {\n+                    let closure_sig = self_ty.map(|closure| {\n+                        if let ty::Closure(_, substs) = closure.kind() {\n+                            self.tcx().signature_unclosure(\n+                                substs.as_closure().sig(),\n+                                rustc_hir::Unsafety::Normal,\n+                            )\n+                        } else {\n+                            bug!(\"type is not longer closure\");\n+                        }\n+                    });\n+\n+                    format!(\n+                        \"{}closure with signature `{}` must implement `{}`\",\n+                        if leading_ellipsis { \"...\" } else { \"\" },\n+                        closure_sig,\n+                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+                    )\n+                } else {\n+                    format!(\n+                        \"{}`{}` must implement `{}`\",\n+                        if leading_ellipsis { \"...\" } else { \"\" },\n+                        self_ty,\n+                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+                    )\n+                }\n+            } else if passive_voice {\n                 format!(\n                     \"{}`{}` would have to be implemented for the type `{}`\",\n                     if leading_ellipsis { \"...\" } else { \"\" },\n@@ -449,7 +464,12 @@ impl NiceRegionError<'me, 'tcx> {\n                 None => true,\n             };\n \n-            let mut note = if passive_voice {\n+            let mut note = if same_self_type {\n+                format!(\n+                    \"...but it actually implements `{}`\",\n+                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n+                )\n+            } else if passive_voice {\n                 format!(\n                     \"...but `{}` is actually implemented for the type `{}`\",\n                     actual_trait_ref.map(|tr| tr.print_only_trait_path()),"}, {"sha": "fa0d5b8301349a6fa752519454b3778dc356f754", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -7,10 +7,7 @@ use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{\n-    self as hir, GenericBound, ImplItem, Item, ItemKind, Lifetime, LifetimeName, Node, TraitItem,\n-    TyKind,\n-};\n+use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n use rustc_middle::ty::{self, AssocItemContainer, RegionKind, Ty, TypeFoldable, TypeVisitor};\n use rustc_span::symbol::Ident;\n use rustc_span::{MultiSpan, Span};\n@@ -234,7 +231,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             match fn_return.kind {\n                 TyKind::OpaqueDef(item_id, _) => {\n-                    let item = tcx.hir().item(item_id.id);\n+                    let item = tcx.hir().item(item_id);\n                     let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n                         opaque\n                     } else {\n@@ -343,17 +340,17 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n         let tcx = self.tcx();\n         match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(ImplItem { ident, hir_id, .. })) => {\n-                match tcx.hir().find(tcx.hir().get_parent_item(*hir_id)) {\n+            Some(Node::ImplItem(impl_item)) => {\n+                match tcx.hir().find(tcx.hir().get_parent_item(impl_item.hir_id())) {\n                     Some(Node::Item(Item {\n                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n                         ..\n-                    })) => Some((*ident, self_ty)),\n+                    })) => Some((impl_item.ident, self_ty)),\n                     _ => None,\n                 }\n             }\n-            Some(Node::TraitItem(TraitItem { ident, hir_id, .. })) => {\n-                let parent_id = tcx.hir().get_parent_item(*hir_id);\n+            Some(Node::TraitItem(trait_item)) => {\n+                let parent_id = tcx.hir().get_parent_item(trait_item.hir_id());\n                 match tcx.hir().find(parent_id) {\n                     Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n                         // The method being called is defined in the `trait`, but the `'static`\n@@ -364,8 +361,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             .hir()\n                             .trait_impls(trait_did)\n                             .iter()\n-                            .filter_map(|impl_node| {\n-                                let impl_did = tcx.hir().local_def_id(*impl_node);\n+                            .filter_map(|&impl_did| {\n                                 match tcx.hir().get_if_local(impl_did.to_def_id()) {\n                                     Some(Node::Item(Item {\n                                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n@@ -389,7 +385,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             })\n                             .next()\n                         {\n-                            Some(self_ty) => Some((*ident, self_ty)),\n+                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n                             _ => None,\n                         }\n                     }"}, {"sha": "3df58cb7857f14125b869e14c0f8ed52a828bb4d", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -408,7 +408,7 @@ pub enum SubregionOrigin<'tcx> {\n }\n \n // `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(SubregionOrigin<'_>, 32);\n \n /// Times when we replace late-bound regions with variables:"}, {"sha": "e5eb771603cd7a32b3b49c5ba2c22eace53ef2a8", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -44,7 +44,7 @@ where\n {\n     infcx: &'me InferCtxt<'me, 'tcx>,\n \n-    /// Callback to use when we deduce an outlives relationship\n+    /// Callback to use when we deduce an outlives relationship.\n     delegate: D,\n \n     /// How are we relating `a` and `b`?\n@@ -768,7 +768,7 @@ impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n     }\n }\n \n-/// The \"type generalize\" is used when handling inference variables.\n+/// The \"type generalizer\" is used when handling inference variables.\n ///\n /// The basic strategy for handling a constraint like `?A <: B` is to\n /// apply a \"generalization strategy\" to the type `B` -- this replaces"}, {"sha": "4be0e7948f70b82c18968d948f562fa1c91666e4", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -15,7 +15,7 @@ pub struct Snapshot<'tcx> {\n     _marker: PhantomData<&'tcx ()>,\n }\n \n-/// Records the 'undo' data fora single operation that affects some form of inference variable.\n+/// Records the \"undo\" data for a single operation that affects some form of inference variable.\n pub(crate) enum UndoLog<'tcx> {\n     TypeVariables(type_variable::UndoLog<'tcx>),\n     ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),"}, {"sha": "f9170ef5dc346b7b338221fe00d27751a933de69", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -27,7 +27,7 @@\n \n #[macro_use]\n extern crate rustc_macros;\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n #[macro_use]\n extern crate rustc_data_structures;\n #[macro_use]"}, {"sha": "0882d682e1537012b47bd3045e0d07154f97ba71", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -56,7 +56,7 @@ pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n // `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(PredicateObligation<'_>, 32);\n \n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;"}, {"sha": "3bfe8da505f1c61dac8f06bcb648be1a4a4d8b32", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -10,7 +10,8 @@ doctest = false\n [dependencies]\n libc = \"0.2\"\n tracing = \"0.1\"\n-rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n+rustc-rayon-core = \"0.3.1\"\n+rayon = { version = \"0.3.1\", package = \"rustc-rayon\" }\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }\n@@ -30,6 +31,7 @@ rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_codegen_llvm = { path = \"../rustc_codegen_llvm\", optional = true }\n rustc_hir = { path = \"../rustc_hir\" }\n+rustc_index = { path = \"../rustc_index\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_mir = { path = \"../rustc_mir\" }\n rustc_mir_build = { path = \"../rustc_mir_build\" }\n@@ -39,6 +41,7 @@ rustc_lint = { path = \"../rustc_lint\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n rustc_privacy = { path = \"../rustc_privacy\" }\n+rustc_query_impl = { path = \"../rustc_query_impl\" }\n rustc_resolve = { path = \"../rustc_resolve\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }"}, {"sha": "a1090ee316db48881a508485b2d1f31dd052f7ba", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n-use rustc_errors::ErrorReported;\n+use rustc_errors::{ErrorReported, Handler};\n use rustc_lint::LintStore;\n use rustc_middle::ty;\n use rustc_parse::new_parser_from_source_str;\n@@ -142,6 +142,9 @@ pub struct Config {\n \n     pub lint_caps: FxHashMap<lint::LintId, lint::Level>,\n \n+    /// This is a callback from the driver that is called when [`ParseSess`] is created.\n+    pub parse_sess_created: Option<Box<dyn FnOnce(&mut ParseSess) + Send>>,\n+\n     /// This is a callback from the driver that is called when we're registering lints;\n     /// it is called during plugin registration when we have the LintStore in a non-shared state.\n     ///\n@@ -166,7 +169,7 @@ pub struct Config {\n \n pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R) -> R {\n     let registry = &config.registry;\n-    let (sess, codegen_backend) = util::create_session(\n+    let (mut sess, codegen_backend) = util::create_session(\n         config.opts,\n         config.crate_cfg,\n         config.diagnostic_output,\n@@ -177,6 +180,14 @@ pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R\n         registry.clone(),\n     );\n \n+    if let Some(parse_sess_created) = config.parse_sess_created {\n+        parse_sess_created(\n+            &mut Lrc::get_mut(&mut sess)\n+                .expect(\"create_session() should never share the returned session\")\n+                .parse_sess,\n+        );\n+    }\n+\n     let compiler = Compiler {\n         sess,\n         codegen_backend,\n@@ -213,3 +224,24 @@ pub fn run_compiler<R: Send>(mut config: Config, f: impl FnOnce(&Compiler) -> R\n         || create_compiler_and_run(config, f),\n     )\n }\n+\n+pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n+    eprintln!(\"query stack during panic:\");\n+\n+    // Be careful relying on global state here: this code is called from\n+    // a panic hook, which means that the global `Handler` may be in a weird\n+    // state if it was responsible for triggering the panic.\n+    let i = ty::tls::with_context_opt(|icx| {\n+        if let Some(icx) = icx {\n+            icx.tcx.queries.try_print_query_stack(icx.tcx, icx.query, handler, num_frames)\n+        } else {\n+            0\n+        }\n+    });\n+\n+    if num_frames == None || num_frames >= Some(i) {\n+        eprintln!(\"end of query stack\");\n+    } else {\n+        eprintln!(\"we're just showing a limited slice of the query stack\");\n+    }\n+}"}, {"sha": "94be7a03a932b854e099f165037032b3fc4a4800", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -15,6 +15,7 @@ use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n+use rustc_index::vec::IndexVec;\n use rustc_lint::LintStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n@@ -27,6 +28,7 @@ use rustc_mir_build as mir_build;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n+use rustc_query_impl::Queries as TcxQueries;\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode};\n use rustc_session::lint;\n@@ -64,8 +66,8 @@ pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     }\n \n     if sess.opts.debugging_opts.input_stats {\n-        println!(\"Lines of code:             {}\", sess.source_map().count_lines());\n-        println!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n+        eprintln!(\"Lines of code:             {}\", sess.source_map().count_lines());\n+        eprintln!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n     }\n \n     if let Some(ref s) = sess.opts.debugging_opts.show_span {\n@@ -300,8 +302,10 @@ fn configure_and_expand_inner<'a>(\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n \n-        let extern_mod_loaded = |k: &ast::Crate, ident: Ident| {\n-            pre_expansion_lint(sess, lint_store, k, &*ident.name.as_str())\n+        let extern_mod_loaded = |ident: Ident, attrs, items, span| {\n+            let krate = ast::Crate { attrs, items, span, proc_macros: vec![] };\n+            pre_expansion_lint(sess, lint_store, &krate, &ident.name.as_str());\n+            (krate.attrs, krate.items)\n         };\n         let mut ecx = ExtCtxt::new(&sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n \n@@ -348,7 +352,7 @@ fn configure_and_expand_inner<'a>(\n         rustc_builtin_macros::test_harness::inject(&sess, &mut resolver, &mut krate)\n     });\n \n-    if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n+    if let Some(PpMode::Source(PpSourceMode::EveryBodyLoops)) = sess.opts.pretty {\n         tracing::debug!(\"replacing bodies with loop {{}}\");\n         util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }\n@@ -394,7 +398,7 @@ fn configure_and_expand_inner<'a>(\n     // Done with macro expansion!\n \n     if sess.opts.debugging_opts.input_stats {\n-        println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n+        eprintln!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n \n     if sess.opts.debugging_opts.hir_stats {\n@@ -738,20 +742,18 @@ pub static DEFAULT_EXTERN_QUERY_PROVIDERS: SyncLazy<Providers> = SyncLazy::new(|\n     extern_providers\n });\n \n-pub struct QueryContext<'tcx>(&'tcx GlobalCtxt<'tcx>);\n+pub struct QueryContext<'tcx> {\n+    gcx: &'tcx GlobalCtxt<'tcx>,\n+}\n \n impl<'tcx> QueryContext<'tcx> {\n     pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        let icx = ty::tls::ImplicitCtxt::new(self.0);\n+        let icx = ty::tls::ImplicitCtxt::new(self.gcx);\n         ty::tls::enter_context(&icx, |_| f(icx.tcx))\n     }\n-\n-    pub fn print_stats(&mut self) {\n-        self.enter(ty::query::print_stats)\n-    }\n }\n \n pub fn create_global_ctxt<'tcx>(\n@@ -762,6 +764,7 @@ pub fn create_global_ctxt<'tcx>(\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n+    queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n@@ -785,26 +788,33 @@ pub fn create_global_ctxt<'tcx>(\n         callback(sess, &mut local_providers, &mut extern_providers);\n     }\n \n+    let queries = {\n+        let crates = resolver_outputs.cstore.crates_untracked();\n+        let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n+        providers[LOCAL_CRATE] = local_providers;\n+        queries.get_or_init(|| TcxQueries::new(providers, extern_providers))\n+    };\n+\n     let gcx = sess.time(\"setup_global_ctxt\", || {\n         global_ctxt.get_or_init(|| {\n             TyCtxt::create_global_ctxt(\n                 sess,\n                 lint_store,\n-                local_providers,\n-                extern_providers,\n                 arena,\n                 resolver_outputs,\n                 krate,\n                 defs,\n                 dep_graph,\n                 query_result_on_disk_cache,\n+                queries.as_dyn(),\n                 &crate_name,\n                 &outputs,\n             )\n         })\n     });\n \n-    QueryContext(gcx)\n+    QueryContext { gcx }\n }\n \n /// Runs the resolution, type-checking, region checking and other\n@@ -831,12 +841,11 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n             },\n             {\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                    let local_def_id = tcx.hir().local_def_id(module);\n-                    tcx.ensure().check_mod_loops(local_def_id);\n-                    tcx.ensure().check_mod_attrs(local_def_id);\n-                    tcx.ensure().check_mod_naked_functions(local_def_id);\n-                    tcx.ensure().check_mod_unstable_api_usage(local_def_id);\n-                    tcx.ensure().check_mod_const_bodies(local_def_id);\n+                    tcx.ensure().check_mod_loops(module);\n+                    tcx.ensure().check_mod_attrs(module);\n+                    tcx.ensure().check_mod_naked_functions(module);\n+                    tcx.ensure().check_mod_unstable_api_usage(module);\n+                    tcx.ensure().check_mod_const_bodies(module);\n                 });\n             }\n         );\n@@ -861,10 +870,8 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                         // \"not all control paths return a value\" is reported here.\n                         //\n                         // maybe move the check to a MIR pass?\n-                        let local_def_id = tcx.hir().local_def_id(module);\n-\n-                        tcx.ensure().check_mod_liveness(local_def_id);\n-                        tcx.ensure().check_mod_intrinsics(local_def_id);\n+                        tcx.ensure().check_mod_liveness(module);\n+                        tcx.ensure().check_mod_intrinsics(module);\n                     });\n                 });\n             }\n@@ -926,7 +933,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n             {\n                 sess.time(\"privacy_checking_modules\", || {\n                     par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                        tcx.ensure().check_mod_privacy(tcx.hir().local_def_id(module));\n+                        tcx.ensure().check_mod_privacy(module);\n                     });\n                 });\n             }\n@@ -983,7 +990,7 @@ fn encode_and_write_metadata(\n             .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n         let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n         let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n-        if let Err(e) = fs::rename(&metadata_filename, &out_filename) {\n+        if let Err(e) = util::non_durable_rename(&metadata_filename, &out_filename) {\n             tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n         }\n         if tcx.sess.opts.json_artifact_notifications {"}, {"sha": "4637055a82ded1827fad57cb82a208dbec99831c", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -25,8 +25,9 @@ struct Finder<'tcx> {\n \n impl<'v> ItemLikeVisitor<'v> for Finder<'_> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if self.tcx.sess.contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n-            self.decls = Some(item.hir_id);\n+        let attrs = self.tcx.hir().attrs(item.hir_id());\n+        if self.tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n+            self.decls = Some(item.hir_id());\n         }\n     }\n "}, {"sha": "9c38d2b91ab31b5569d89af76849ebb448e733e4", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -14,6 +14,7 @@ use rustc_lint::LintStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::{GlobalCtxt, ResolverOutputs, TyCtxt};\n+use rustc_query_impl::Queries as TcxQueries;\n use rustc_serialize::json;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n@@ -71,6 +72,7 @@ impl<T> Default for Query<T> {\n pub struct Queries<'tcx> {\n     compiler: &'tcx Compiler,\n     gcx: OnceCell<GlobalCtxt<'tcx>>,\n+    queries: OnceCell<TcxQueries<'tcx>>,\n \n     arena: WorkerLocal<Arena<'tcx>>,\n     hir_arena: WorkerLocal<rustc_ast_lowering::Arena<'tcx>>,\n@@ -92,6 +94,7 @@ impl<'tcx> Queries<'tcx> {\n         Queries {\n             compiler,\n             gcx: OnceCell::new(),\n+            queries: OnceCell::new(),\n             arena: WorkerLocal::new(|_| Arena::default()),\n             hir_arena: WorkerLocal::new(|_| rustc_ast_lowering::Arena::default()),\n             dep_graph_future: Default::default(),\n@@ -265,6 +268,7 @@ impl<'tcx> Queries<'tcx> {\n                 resolver_outputs.steal(),\n                 outputs,\n                 &crate_name,\n+                &self.queries,\n                 &self.gcx,\n                 &self.arena,\n             ))\n@@ -425,11 +429,11 @@ impl Compiler {\n             {\n                 let _prof_timer =\n                     queries.session().prof.generic_activity(\"self_profile_alloc_query_strings\");\n-                gcx.enter(|tcx| tcx.alloc_self_profile_query_strings());\n+                gcx.enter(rustc_query_impl::alloc_self_profile_query_strings);\n             }\n \n             if self.session().opts.debugging_opts.query_stats {\n-                gcx.print_stats();\n+                gcx.enter(rustc_query_impl::print_stats);\n             }\n         }\n "}, {"sha": "93ba2e6a4f1e9c1794944ef0897c5de041216b49", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -20,6 +20,7 @@ use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy}\n use rustc_target::spec::{RelocModel, RelroLevel, SplitDebuginfo, TlsModel};\n use std::collections::{BTreeMap, BTreeSet};\n use std::iter::FromIterator;\n+use std::num::NonZeroUsize;\n use std::path::{Path, PathBuf};\n \n type CfgSpecs = FxHashSet<(String, Option<String>)>;\n@@ -556,15 +557,15 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(function_sections, Some(false));\n     tracked!(human_readable_cgu_names, true);\n     tracked!(inline_in_all_cgus, Some(true));\n-    tracked!(inline_mir_threshold, 123);\n-    tracked!(inline_mir_hint_threshold, 123);\n-    tracked!(insert_sideeffect, true);\n+    tracked!(inline_mir, Some(true));\n+    tracked!(inline_mir_threshold, Some(123));\n+    tracked!(inline_mir_hint_threshold, Some(123));\n     tracked!(instrument_coverage, true);\n     tracked!(instrument_mcount, true);\n     tracked!(link_only, true);\n     tracked!(merge_functions, Some(MergeFunctions::Disabled));\n     tracked!(mir_emit_retag, true);\n-    tracked!(mir_opt_level, 3);\n+    tracked!(mir_opt_level, Some(4));\n     tracked!(mutable_noalias, true);\n     tracked!(new_llvm_pass_manager, true);\n     tracked!(no_codegen, true);\n@@ -595,7 +596,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(tune_cpu, Some(String::from(\"abc\")));\n     tracked!(tls_model, Some(TlsModel::GeneralDynamic));\n     tracked!(trap_unreachable, Some(false));\n-    tracked!(treat_err_as_bug, Some(1));\n+    tracked!(treat_err_as_bug, NonZeroUsize::new(1));\n     tracked!(unleash_the_miri_inside_of_you, true);\n     tracked!(use_ctors_section, Some(true));\n     tracked!(verify_llvm_ir, true);"}, {"sha": "341cfa479002783655f4fca3c493a230d2c918c4", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 64, "deletions": 14, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -10,6 +10,8 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::registry::Registry;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n+#[cfg(parallel_compiler)]\n+use rustc_middle::ty::tls;\n use rustc_resolve::{self, Resolver};\n use rustc_session as session;\n use rustc_session::config::{self, CrateType};\n@@ -29,11 +31,12 @@ use std::io;\n use std::lazy::SyncOnceCell;\n use std::mem;\n use std::ops::DerefMut;\n+#[cfg(not(parallel_compiler))]\n+use std::panic;\n use std::path::{Path, PathBuf};\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::{Arc, Mutex, Once};\n-#[cfg(not(parallel_compiler))]\n-use std::{panic, thread};\n+use std::thread;\n use tracing::info;\n \n /// Adds `target_feature = \"...\"` cfgs for a variety of platform\n@@ -156,22 +159,43 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n     scoped_thread(cfg, main_handler)\n }\n \n+/// Creates a new thread and forwards information in thread locals to it.\n+/// The new thread runs the deadlock handler.\n+/// Must only be called when a deadlock is about to happen.\n+#[cfg(parallel_compiler)]\n+unsafe fn handle_deadlock() {\n+    let registry = rustc_rayon_core::Registry::current();\n+\n+    let context = tls::get_tlv();\n+    assert!(context != 0);\n+    rustc_data_structures::sync::assert_sync::<tls::ImplicitCtxt<'_, '_>>();\n+    let icx: &tls::ImplicitCtxt<'_, '_> = &*(context as *const tls::ImplicitCtxt<'_, '_>);\n+\n+    let session_globals = rustc_span::SESSION_GLOBALS.with(|sg| sg as *const _);\n+    let session_globals = &*session_globals;\n+    thread::spawn(move || {\n+        tls::enter_context(icx, |_| {\n+            rustc_span::SESSION_GLOBALS\n+                .set(session_globals, || tls::with(|tcx| tcx.queries.deadlock(tcx, &registry)))\n+        });\n+    });\n+}\n+\n #[cfg(parallel_compiler)]\n pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     threads: usize,\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n     f: F,\n ) -> R {\n-    use rustc_middle::ty;\n     crate::callbacks::setup_callbacks();\n \n     let mut config = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)\n         .release_thread_handler(jobserver::release_thread)\n         .num_threads(threads)\n-        .deadlock_handler(|| unsafe { ty::query::handle_deadlock() });\n+        .deadlock_handler(|| unsafe { handle_deadlock() });\n \n     if let Some(size) = get_stack_size() {\n         config = config.stack_size(size);\n@@ -670,16 +694,42 @@ pub fn build_output_filenames(\n     }\n }\n \n-// Note: Also used by librustdoc, see PR #43348. Consider moving this struct elsewhere.\n-//\n-// FIXME: Currently the `everybody_loops` transformation is not applied to:\n-//  * `const fn`, due to issue #43636 that `loop` is not supported for const evaluation. We are\n-//    waiting for miri to fix that.\n-//  * `impl Trait`, due to issue #43869 that functions returning impl Trait cannot be diverging.\n-//    Solving this may require `!` to implement every trait, which relies on the an even more\n-//    ambitious form of the closed RFC #1637. See also [#34511].\n-//\n-// [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n+#[cfg(not(target_os = \"linux\"))]\n+pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n+    std::fs::rename(src, dst)\n+}\n+\n+/// This function attempts to bypass the auto_da_alloc heuristic implemented by some filesystems\n+/// such as btrfs and ext4. When renaming over a file that already exists then they will \"helpfully\"\n+/// write back the source file before committing the rename in case a developer forgot some of\n+/// the fsyncs in the open/write/fsync(file)/rename/fsync(dir) dance for atomic file updates.\n+///\n+/// To avoid triggering this heuristic we delete the destination first, if it exists.\n+/// The cost of an extra syscall is much lower than getting descheduled for the sync IO.\n+#[cfg(target_os = \"linux\")]\n+pub fn non_durable_rename(src: &Path, dst: &Path) -> std::io::Result<()> {\n+    let _ = std::fs::remove_file(dst);\n+    std::fs::rename(src, dst)\n+}\n+\n+/// Replaces function bodies with `loop {}` (an infinite loop). This gets rid of\n+/// all semantic errors in the body while still satisfying the return type,\n+/// except in certain cases, see below for more.\n+///\n+/// This pass is known as `everybody_loops`. Very punny.\n+///\n+/// As of March 2021, `everybody_loops` is only used for the\n+/// `-Z unpretty=everybody_loops` debugging option.\n+///\n+/// FIXME: Currently the `everybody_loops` transformation is not applied to:\n+///  * `const fn`; support could be added, but hasn't. Originally `const fn`\n+///    was skipped due to issue #43636 that `loop` was not supported for\n+///    const evaluation.\n+///  * `impl Trait`, due to issue #43869 that functions returning impl Trait cannot be diverging.\n+///    Solving this may require `!` to implement every trait, which relies on the an even more\n+///    ambitious form of the closed RFC #1637. See also [#34511].\n+///\n+/// [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n pub struct ReplaceBodyWithLoop<'a, 'b> {\n     within_static_or_const: bool,\n     nested_blocks: Option<Vec<ast::Block>>,"}, {"sha": "dca5e470e7fb93590d5b1ddd9d27255e865b06ff", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 54, "deletions": 89, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -24,7 +24,7 @@ use crate::{\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n-use rustc_ast::attr::{self, HasAttrs};\n+use rustc_ast::attr;\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::visit::{FnCtxt, FnKind};\n use rustc_ast::{self as ast, *};\n@@ -36,9 +36,9 @@ use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, Att\n use rustc_feature::{GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet};\n use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n-use rustc_hir::{HirId, HirIdSet, Node};\n+use rustc_hir::{HirId, Node};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -173,8 +173,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..) => {\n-                let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-                self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n+                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.def_id))\n             }\n             _ => (),\n         }\n@@ -509,8 +508,7 @@ impl MissingDoc {\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n-        id: Option<hir::HirId>,\n-        attrs: &[ast::Attribute],\n+        id: hir::HirId,\n         sp: Span,\n         article: &'static str,\n         desc: &'static str,\n@@ -529,12 +527,13 @@ impl MissingDoc {\n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a `NodeId`).\n-        if let Some(id) = id {\n+        if id != hir::CRATE_HIR_ID {\n             if !cx.access_levels.is_exported(id) {\n                 return;\n             }\n         }\n \n+        let attrs = cx.tcx.hir().attrs(id);\n         let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n         if !has_doc {\n             cx.struct_span_lint(\n@@ -566,10 +565,11 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'_>, krate: &hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, None, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n+        self.check_missing_docs_attrs(cx, hir::CRATE_HIR_ID, krate.item.span, \"the\", \"crate\");\n \n         for macro_def in krate.exported_macros {\n-            let has_doc = macro_def.attrs.iter().any(|a| has_doc(cx.sess(), a));\n+            let attrs = cx.tcx.hir().attrs(macro_def.hir_id());\n+            let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n             if !has_doc {\n                 cx.struct_span_lint(\n                     MISSING_DOCS,\n@@ -585,9 +585,9 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n-                    self.private_traits.insert(it.hir_id);\n+                    self.private_traits.insert(it.hir_id());\n                     for trait_item_ref in trait_item_refs {\n-                        self.private_traits.insert(trait_item_ref.id.hir_id);\n+                        self.private_traits.insert(trait_item_ref.id.hir_id());\n                     }\n                     return;\n                 }\n@@ -601,7 +601,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                     if let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) {\n                         if let hir::VisibilityKind::Inherited = item.vis.node {\n                             for impl_item_ref in items {\n-                                self.private_traits.insert(impl_item_ref.id.hir_id);\n+                                self.private_traits.insert(impl_item_ref.id.hir_id());\n                             }\n                         }\n                     }\n@@ -621,76 +621,44 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             _ => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, article, desc);\n+        self.check_missing_docs_attrs(cx, it.hir_id(), it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n-        if self.private_traits.contains(&trait_item.hir_id) {\n+        if self.private_traits.contains(&trait_item.hir_id()) {\n             return;\n         }\n \n-        let def_id = cx.tcx.hir().local_def_id(trait_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(\n-            cx,\n-            Some(trait_item.hir_id),\n-            &trait_item.attrs,\n-            trait_item.span,\n-            article,\n-            desc,\n-        );\n+        self.check_missing_docs_attrs(cx, trait_item.hir_id(), trait_item.span, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n-        if method_context(cx, impl_item.hir_id) == MethodLateContext::TraitImpl {\n+        if method_context(cx, impl_item.hir_id()) == MethodLateContext::TraitImpl {\n             return;\n         }\n \n-        let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n-        self.check_missing_docs_attrs(\n-            cx,\n-            Some(impl_item.hir_id),\n-            &impl_item.attrs,\n-            impl_item.span,\n-            article,\n-            desc,\n-        );\n+        let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n+        self.check_missing_docs_attrs(cx, impl_item.hir_id(), impl_item.span, article, desc);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n-        let def_id = cx.tcx.hir().local_def_id(foreign_item.hir_id);\n-        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n-        self.check_missing_docs_attrs(\n-            cx,\n-            Some(foreign_item.hir_id),\n-            &foreign_item.attrs,\n-            foreign_item.span,\n-            article,\n-            desc,\n-        );\n+        let (article, desc) = cx.tcx.article_and_description(foreign_item.def_id.to_def_id());\n+        self.check_missing_docs_attrs(cx, foreign_item.hir_id(), foreign_item.span, article, desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'_>, sf: &hir::StructField<'_>) {\n         if !sf.is_positional() {\n-            self.check_missing_docs_attrs(\n-                cx,\n-                Some(sf.hir_id),\n-                &sf.attrs,\n-                sf.span,\n-                \"a\",\n-                \"struct field\",\n-            )\n+            self.check_missing_docs_attrs(cx, sf.hir_id, sf.span, \"a\", \"struct field\")\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'_>, v: &hir::Variant<'_>) {\n-        self.check_missing_docs_attrs(cx, Some(v.id), &v.attrs, v.span, \"a\", \"variant\");\n+        self.check_missing_docs_attrs(cx, v.id, v.span, \"a\", \"variant\");\n     }\n }\n \n@@ -732,29 +700,29 @@ declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS])\n \n impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.hir_id) {\n+        if !cx.access_levels.is_reachable(item.hir_id()) {\n             return;\n         }\n         let (def, ty) = match item.kind {\n             hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(cx.tcx.hir().local_def_id(item.hir_id));\n+                let def = cx.tcx.adt_def(item.def_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -812,14 +780,14 @@ declare_lint! {\n \n #[derive(Default)]\n pub struct MissingDebugImplementations {\n-    impling_types: Option<HirIdSet>,\n+    impling_types: Option<LocalDefIdSet>,\n }\n \n impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.hir_id) {\n+        if !cx.access_levels.is_reachable(item.hir_id()) {\n             return;\n         }\n \n@@ -834,11 +802,11 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let mut impls = HirIdSet::default();\n+            let mut impls = LocalDefIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n                     if let Some(def_id) = ty_def.did.as_local() {\n-                        impls.insert(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n+                        impls.insert(def_id);\n                     }\n                 }\n             });\n@@ -847,7 +815,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             debug!(\"{:?}\", self.impling_types);\n         }\n \n-        if !self.impling_types.as_ref().unwrap().contains(&item.hir_id) {\n+        if !self.impling_types.as_ref().unwrap().contains(&item.def_id) {\n             cx.struct_span_lint(MISSING_DEBUG_IMPLEMENTATIONS, item.span, |lint| {\n                 lint.build(&format!(\n                     \"type does not implement `{}`; consider adding `#[derive(Debug)]` \\\n@@ -1124,9 +1092,10 @@ declare_lint_pass!(InvalidNoMangleItems => [NO_MANGLE_CONST_ITEMS, NO_MANGLE_GEN\n \n impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n+        let attrs = cx.tcx.hir().attrs(it.hir_id());\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(no_mangle_attr) = cx.sess().find_by_name(attrs, sym::no_mangle) {\n                     for param in generics.params {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n@@ -1152,7 +1121,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if cx.sess().contains_name(&it.attrs, sym::no_mangle) {\n+                if cx.sess().contains_name(attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n@@ -1362,14 +1331,14 @@ impl UnreachablePub {\n \n impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        self.perform_lint(cx, \"item\", item.hir_id, &item.vis, item.span, true);\n+        self.perform_lint(cx, \"item\", item.hir_id(), &item.vis, item.span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n         self.perform_lint(\n             cx,\n             \"item\",\n-            foreign_item.hir_id,\n+            foreign_item.hir_id(),\n             &foreign_item.vis,\n             foreign_item.span,\n             true,\n@@ -1381,7 +1350,7 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n-        self.perform_lint(cx, \"item\", impl_item.hir_id, &impl_item.vis, impl_item.span, false);\n+        self.perform_lint(cx, \"item\", impl_item.hir_id(), &impl_item.vis, impl_item.span, false);\n     }\n }\n \n@@ -1603,8 +1572,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n         use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n-            let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n-            let predicates = cx.tcx.predicates_of(def_id);\n+            let predicates = cx.tcx.predicates_of(item.def_id);\n             for &(predicate, span) in predicates.predicates {\n                 let predicate_kind_name = match predicate.kind().skip_binder() {\n                     Trait(..) => \"Trait\",\n@@ -1810,7 +1778,7 @@ declare_lint! {\n }\n \n pub struct UnnameableTestItems {\n-    boundary: Option<hir::HirId>, // HirId of the item under which things are not nameable\n+    boundary: Option<LocalDefId>, // Id of the item under which things are not nameable\n     items_nameable: bool,\n }\n \n@@ -1828,20 +1796,21 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             if let hir::ItemKind::Mod(..) = it.kind {\n             } else {\n                 self.items_nameable = false;\n-                self.boundary = Some(it.hir_id);\n+                self.boundary = Some(it.def_id);\n             }\n             return;\n         }\n \n-        if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::rustc_test_marker) {\n+        let attrs = cx.tcx.hir().attrs(it.hir_id());\n+        if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n             cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| {\n                 lint.build(\"cannot test inner items\").emit()\n             });\n         }\n     }\n \n     fn check_item_post(&mut self, _cx: &LateContext<'_>, it: &hir::Item<'_>) {\n-        if !self.items_nameable && self.boundary == Some(it.hir_id) {\n+        if !self.items_nameable && self.boundary == Some(it.def_id) {\n             self.items_nameable = true;\n         }\n     }\n@@ -2125,7 +2094,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         let infer_static = cx.tcx.features().infer_static_outlives_requirements;\n-        let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n+        let def_id = item.def_id;\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n         | hir::ItemKind::Enum(_, ref hir_generics)\n         | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n@@ -2680,10 +2649,7 @@ impl ClashingExternDeclarations {\n     /// Insert a new foreign item into the seen set. If a symbol with the same name already exists\n     /// for the item, return its HirId without updating the set.\n     fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<HirId> {\n-        let hid = fi.hir_id;\n-\n-        let local_did = tcx.hir().local_def_id(fi.hir_id);\n-        let did = local_did.to_def_id();\n+        let did = fi.def_id.to_def_id();\n         let instance = Instance::new(did, ty::List::identity_for_item(tcx, did));\n         let name = Symbol::intern(tcx.symbol_name(instance).name);\n         if let Some(&hir_id) = self.seen_decls.get(&name) {\n@@ -2692,24 +2658,23 @@ impl ClashingExternDeclarations {\n             // This lets us avoid emitting \"knock-on\" diagnostics.\n             Some(hir_id)\n         } else {\n-            self.seen_decls.insert(name, hid)\n+            self.seen_decls.insert(name, fi.hir_id())\n         }\n     }\n \n     /// Get the name of the symbol that's linked against for a given extern declaration. That is,\n     /// the name specified in a #[link_name = ...] attribute if one was specified, else, just the\n     /// symbol's name.\n     fn name_of_extern_decl(tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> SymbolName {\n-        let did = tcx.hir().local_def_id(fi.hir_id);\n         if let Some((overridden_link_name, overridden_link_name_span)) =\n-            tcx.codegen_fn_attrs(did).link_name.map(|overridden_link_name| {\n+            tcx.codegen_fn_attrs(fi.def_id).link_name.map(|overridden_link_name| {\n                 // FIXME: Instead of searching through the attributes again to get span\n                 // information, we could have codegen_fn_attrs also give span information back for\n                 // where the attribute was defined. However, until this is found to be a\n                 // bottleneck, this does just fine.\n                 (\n                     overridden_link_name,\n-                    tcx.get_attrs(did.to_def_id())\n+                    tcx.get_attrs(fi.def_id.to_def_id())\n                         .iter()\n                         .find(|at| tcx.sess.check_name(at, sym::link_name))\n                         .unwrap()\n@@ -2937,10 +2902,10 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n             let tcx = cx.tcx;\n             if let Some(existing_hid) = self.insert(tcx, this_fi) {\n                 let existing_decl_ty = tcx.type_of(tcx.hir().local_def_id(existing_hid));\n-                let this_decl_ty = tcx.type_of(tcx.hir().local_def_id(this_fi.hir_id));\n+                let this_decl_ty = tcx.type_of(this_fi.def_id);\n                 debug!(\n                     \"ClashingExternDeclarations: Comparing existing {:?}: {:?} to this {:?}: {:?}\",\n-                    existing_hid, existing_decl_ty, this_fi.hir_id, this_decl_ty\n+                    existing_hid, existing_decl_ty, this_fi.def_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n                 if !Self::structurally_same_type(\n@@ -2962,7 +2927,7 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     // Finally, emit the diagnostic.\n                     tcx.struct_span_lint_hir(\n                         CLASHING_EXTERN_DECLARATIONS,\n-                        this_fi.hir_id,\n+                        this_fi.hir_id(),\n                         get_relevant_span(this_fi),\n                         |lint| {\n                             let mut expected_str = DiagnosticStyledString::new();"}, {"sha": "42ead89ca4f856381729ba4c27786388c3eca739", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -89,6 +89,7 @@ impl SessionLintStore for LintStore {\n }\n \n /// The target of the `by_name` map, which accounts for renaming/deprecation.\n+#[derive(Debug)]\n enum TargetLint {\n     /// A direct lint target\n     Id(LintId),\n@@ -470,7 +471,10 @@ impl LintStore {\n             Some(&Id(ref id)) => {\n                 CheckLintNameResult::Tool(Err((Some(slice::from_ref(id)), complete_name)))\n             }\n-            _ => CheckLintNameResult::NoLint(None),\n+            Some(other) => {\n+                tracing::debug!(\"got renamed lint {:?}\", other);\n+                CheckLintNameResult::NoLint(None)\n+            }\n         }\n     }\n }\n@@ -666,6 +670,9 @@ pub trait LintContext: Sized {\n                         json\n                     );\n                 }\n+                BuiltinLintDiagnostics::ProcMacroBackCompat(note) => {\n+                    db.note(&note);\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(LintDiagnosticBuilder::new(db));"}, {"sha": "0c7b843831ababeff8dee6fa54610af56b8ef0c8", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -18,7 +18,7 @@ use crate::context::{EarlyContext, LintContext, LintStore};\n use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n use rustc_ast as ast;\n use rustc_ast::visit as ast_visit;\n-use rustc_attr::HasAttrs;\n+use rustc_ast::AstLike;\n use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n@@ -188,13 +188,6 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_ident, ident);\n     }\n \n-    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n-        run_early_pass!(self, check_mod, m, s, n);\n-        self.check_id(n);\n-        ast_visit::walk_mod(self, m);\n-        run_early_pass!(self, check_mod_post, m, s, n);\n-    }\n-\n     fn visit_local(&mut self, l: &'a ast::Local) {\n         self.with_lint_attrs(l.id, &l.attrs, |cx| {\n             run_early_pass!(cx, check_local, l);"}, {"sha": "9b1a339572ec3cfe5b9fde1709d72415c3aba51a", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -283,7 +283,7 @@ fn is_doc_keyword(s: Symbol) -> bool {\n \n impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &rustc_hir::Item<'_>) {\n-        for attr in item.attrs {\n+        for attr in cx.tcx.hir().attrs(item.hir_id()) {\n             if !attr.has_name(sym::doc) {\n                 continue;\n             }"}, {"sha": "9a64737f3a25db86c8976752d7103971c9157b4f", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -16,7 +16,6 @@\n \n use crate::{passes::LateLintPassObject, LateContext, LateLintPass, LintStore};\n use rustc_ast as ast;\n-use rustc_ast::walk_list;\n use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n@@ -53,10 +52,11 @@ impl<'tcx, T: LateLintPass<'tcx>> LateContextAndPass<'tcx, T> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &'tcx [ast::Attribute], f: F)\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n+        let attrs = self.context.tcx.hir().attrs(id);\n         let prev = self.context.last_node_with_lint_attrs;\n         self.context.last_node_with_lint_attrs = id;\n         self.enter_attrs(attrs);\n@@ -125,7 +125,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n+        self.with_lint_attrs(param.hir_id, |cx| {\n             lint_callback!(cx, check_param, param);\n             hir_visit::walk_param(cx, param);\n         });\n@@ -142,8 +142,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         self.context.generics = it.kind.generics();\n         let old_cached_typeck_results = self.context.cached_typeck_results.take();\n         let old_enclosing_body = self.context.enclosing_body.take();\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n+        self.with_lint_attrs(it.hir_id(), |cx| {\n+            cx.with_param_env(it.hir_id(), |cx| {\n                 lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 lint_callback!(cx, check_item_post, it);\n@@ -155,8 +155,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n+        self.with_lint_attrs(it.hir_id(), |cx| {\n+            cx.with_param_env(it.hir_id(), |cx| {\n                 lint_callback!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n                 lint_callback!(cx, check_foreign_item_post, it);\n@@ -170,19 +170,17 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n+        self.with_lint_attrs(e.hir_id, |cx| {\n             lint_callback!(cx, check_expr, e);\n             hir_visit::walk_expr(cx, e);\n             lint_callback!(cx, check_expr_post, e);\n         })\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-        let get_item = |id: hir::ItemId| self.context.tcx.hir().item(id.id);\n-        let attrs = &s.kind.attrs(get_item);\n         // See `EarlyContextAndPass::visit_stmt` for an explanation\n         // of why we call `walk_stmt` outside of `with_lint_attrs`\n-        self.with_lint_attrs(s.hir_id, attrs, |cx| {\n+        self.with_lint_attrs(s.hir_id, |cx| {\n             lint_callback!(cx, check_stmt, s);\n         });\n         hir_visit::walk_stmt(self, s);\n@@ -222,7 +220,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n+        self.with_lint_attrs(s.hir_id, |cx| {\n             lint_callback!(cx, check_struct_field, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n@@ -234,7 +232,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n-        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+        self.with_lint_attrs(v.id, |cx| {\n             lint_callback!(cx, check_variant, v);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             lint_callback!(cx, check_variant_post, v);\n@@ -257,7 +255,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n+        self.with_lint_attrs(l.hir_id, |cx| {\n             lint_callback!(cx, check_local, l);\n             hir_visit::walk_local(cx, l);\n         })\n@@ -301,8 +299,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&trait_item.generics);\n-        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n-            cx.with_param_env(trait_item.hir_id, |cx| {\n+        self.with_lint_attrs(trait_item.hir_id(), |cx| {\n+            cx.with_param_env(trait_item.hir_id(), |cx| {\n                 lint_callback!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n                 lint_callback!(cx, check_trait_item_post, trait_item);\n@@ -314,8 +312,8 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&impl_item.generics);\n-        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n-            cx.with_param_env(impl_item.hir_id, |cx| {\n+        self.with_lint_attrs(impl_item.hir_id(), |cx| {\n+            cx.with_param_env(impl_item.hir_id(), |cx| {\n                 lint_callback!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n                 lint_callback!(cx, check_impl_item_post, impl_item);\n@@ -334,8 +332,10 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         hir_visit::walk_path(self, p);\n     }\n \n-    fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        lint_callback!(self, check_attribute, attr);\n+    fn visit_attribute(&mut self, hir_id: hir::HirId, attr: &'tcx ast::Attribute) {\n+        self.with_lint_attrs(hir_id, |cx| {\n+            lint_callback!(cx, check_attribute, attr);\n+        })\n     }\n }\n \n@@ -396,7 +396,9 @@ fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n \n     // Visit the crate attributes\n     if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, tcx.hir().attrs(hir::CRATE_HIR_ID));\n+        for attr in tcx.hir().attrs(hir::CRATE_HIR_ID).iter() {\n+            cx.visit_attribute(hir_id, attr)\n+        }\n     }\n }\n \n@@ -440,7 +442,7 @@ fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T)\n     let mut cx = LateContextAndPass { context, pass };\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.item.attrs, |cx| {\n+    cx.with_lint_attrs(hir::CRATE_HIR_ID, |cx| {\n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         lint_callback!(cx, check_crate, krate);\n@@ -496,7 +498,7 @@ pub fn check_crate<'tcx, T: LateLintPass<'tcx>>(\n             tcx.sess.time(\"module_lints\", || {\n                 // Run per-module lints\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                    tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+                    tcx.ensure().lint_mod(module);\n                 });\n             });\n         },"}, {"sha": "b3bdaf5bdc7d0de54c486117f36e42b3817836fd", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -38,10 +38,10 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> LintLevelMap {\n \n     builder.levels.id_to_set.reserve(krate.exported_macros.len() + 1);\n \n-    let push = builder.levels.push(&krate.item.attrs, &store, true);\n+    let push = builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), &store, true);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     for macro_def in krate.exported_macros {\n-        builder.levels.register_id(macro_def.hir_id);\n+        builder.levels.register_id(macro_def.hir_id());\n     }\n     intravisit::walk_crate(&mut builder, krate);\n     builder.levels.pop(push);\n@@ -321,17 +321,18 @@ impl<'s> LintLevelsBuilder<'s> {\n                     None\n                 };\n                 let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n-                match store.check_lint_name(&name.as_str(), tool_name) {\n+                let lint_result = store.check_lint_name(&name.as_str(), tool_name);\n+                match &lint_result {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintLevelSource::Node(name, li.span(), reason);\n-                        for &id in ids {\n+                        for &id in *ids {\n                             self.check_gated_lint(id, attr.span);\n                             self.insert_spec(&mut specs, id, (level, src));\n                         }\n                     }\n \n                     CheckLintNameResult::Tool(result) => {\n-                        match result {\n+                        match *result {\n                             Ok(ids) => {\n                                 let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n                                 let src = LintLevelSource::Node(\n@@ -343,7 +344,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     self.insert_spec(&mut specs, *id, (level, src));\n                                 }\n                             }\n-                            Err((Some(ids), new_lint_name)) => {\n+                            Err((Some(ids), ref new_lint_name)) => {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                                 let (lvl, src) =\n                                     self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n@@ -392,21 +393,21 @@ impl<'s> LintLevelsBuilder<'s> {\n \n                     CheckLintNameResult::Warning(msg, renamed) => {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (level, src) =\n+                        let (renamed_lint_level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n                         struct_lint_level(\n                             self.sess,\n                             lint,\n-                            level,\n+                            renamed_lint_level,\n                             src,\n                             Some(li.span().into()),\n                             |lint| {\n                                 let mut err = lint.build(&msg);\n-                                if let Some(new_name) = renamed {\n+                                if let Some(new_name) = &renamed {\n                                     err.span_suggestion(\n                                         li.span(),\n                                         \"use the new name\",\n-                                        new_name,\n+                                        new_name.to_string(),\n                                         Applicability::MachineApplicable,\n                                     );\n                                 }\n@@ -444,6 +445,22 @@ impl<'s> LintLevelsBuilder<'s> {\n                         );\n                     }\n                 }\n+                // If this lint was renamed, apply the new lint instead of ignoring the attribute.\n+                // This happens outside of the match because the new lint should be applied even if\n+                // we don't warn about the name change.\n+                if let CheckLintNameResult::Warning(_, Some(new_name)) = lint_result {\n+                    // Ignore any errors or warnings that happen because the new name is inaccurate\n+                    if let CheckLintNameResult::Ok(ids) =\n+                        store.check_lint_name(&new_name, tool_name)\n+                    {\n+                        let src =\n+                            LintLevelSource::Node(Symbol::intern(&new_name), li.span(), reason);\n+                        for &id in ids {\n+                            self.check_gated_lint(id, attr.span);\n+                            self.insert_spec(&mut specs, id, (level, src));\n+                        }\n+                    }\n+                }\n             }\n         }\n \n@@ -549,11 +566,12 @@ struct LintLevelMapBuilder<'a, 'tcx> {\n }\n \n impl LintLevelMapBuilder<'_, '_> {\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &[ast::Attribute], f: F)\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n         let is_crate_hir = id == hir::CRATE_HIR_ID;\n+        let attrs = self.tcx.hir().attrs(id);\n         let push = self.levels.push(attrs, self.store, is_crate_hir);\n         if push.changed {\n             self.levels.register_id(id);\n@@ -571,19 +589,19 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n+        self.with_lint_attrs(param.hir_id, |builder| {\n             intravisit::walk_param(builder, param);\n         });\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id(), |builder| {\n             intravisit::walk_item(builder, it);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id(), |builder| {\n             intravisit::walk_foreign_item(builder, it);\n         })\n     }\n@@ -596,13 +614,13 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n+        self.with_lint_attrs(e.hir_id, |builder| {\n             intravisit::walk_expr(builder, e);\n         })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, &s.attrs, |builder| {\n+        self.with_lint_attrs(s.hir_id, |builder| {\n             intravisit::walk_struct_field(builder, s);\n         })\n     }\n@@ -613,31 +631,31 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n-        self.with_lint_attrs(v.id, &v.attrs, |builder| {\n+        self.with_lint_attrs(v.id, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n+        self.with_lint_attrs(l.hir_id, |builder| {\n             intravisit::walk_local(builder, l);\n         })\n     }\n \n     fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        self.with_lint_attrs(a.hir_id, &a.attrs, |builder| {\n+        self.with_lint_attrs(a.hir_id, |builder| {\n             intravisit::walk_arm(builder, a);\n         })\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n+        self.with_lint_attrs(trait_item.hir_id(), |builder| {\n             intravisit::walk_trait_item(builder, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |builder| {\n+        self.with_lint_attrs(impl_item.hir_id(), |builder| {\n             intravisit::walk_impl_item(builder, impl_item);\n         });\n     }"}, {"sha": "408f41e91b03eb7a1ad29ac5212b2b22b6d32f90", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -57,6 +57,7 @@ mod methods;\n mod non_ascii_idents;\n mod non_fmt_panic;\n mod nonstandard_style;\n+mod noop_method_call;\n mod passes;\n mod redundant_semicolon;\n mod traits;\n@@ -69,9 +70,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n-    BARE_TRAIT_OBJECTS, BROKEN_INTRA_DOC_LINKS, ELIDED_LIFETIMES_IN_PATHS,\n-    EXPLICIT_OUTLIVES_REQUIREMENTS, INVALID_CODEBLOCK_ATTRIBUTES, INVALID_HTML_TAGS,\n-    MISSING_DOC_CODE_EXAMPLES, NON_AUTOLINKS, PRIVATE_DOC_TESTS,\n+    BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n };\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n@@ -83,6 +82,7 @@ use methods::*;\n use non_ascii_idents::*;\n use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n+use noop_method_call::*;\n use redundant_semicolon::*;\n use traits::*;\n use types::*;\n@@ -170,6 +170,7 @@ macro_rules! late_lint_passes {\n                 DropTraitConstraints: DropTraitConstraints,\n                 TemporaryCStringAsPtr: TemporaryCStringAsPtr,\n                 NonPanicFmt: NonPanicFmt,\n+                NoopMethodCall: NoopMethodCall,\n             ]\n         );\n     };\n@@ -314,17 +315,6 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n                                        // MACRO_USE_EXTERN_CRATE\n     );\n \n-    add_lint_group!(\n-        \"rustdoc\",\n-        NON_AUTOLINKS,\n-        BROKEN_INTRA_DOC_LINKS,\n-        PRIVATE_INTRA_DOC_LINKS,\n-        INVALID_CODEBLOCK_ATTRIBUTES,\n-        MISSING_DOC_CODE_EXAMPLES,\n-        PRIVATE_DOC_TESTS,\n-        INVALID_HTML_TAGS\n-    );\n-\n     // Register renamed and removed lints.\n     store.register_renamed(\"single_use_lifetime\", \"single_use_lifetimes\");\n     store.register_renamed(\"elided_lifetime_in_path\", \"elided_lifetimes_in_paths\");\n@@ -334,8 +324,30 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     store.register_renamed(\"async_idents\", \"keyword_idents\");\n     store.register_renamed(\"exceeding_bitshifts\", \"arithmetic_overflow\");\n     store.register_renamed(\"redundant_semicolon\", \"redundant_semicolons\");\n-    store.register_renamed(\"intra_doc_link_resolution_failure\", \"broken_intra_doc_links\");\n     store.register_renamed(\"overlapping_patterns\", \"overlapping_range_endpoints\");\n+\n+    // These were moved to tool lints, but rustc still sees them when compiling normally, before\n+    // tool lints are registered, so `check_tool_name_for_backwards_compat` doesn't work. Use\n+    // `register_removed` explicitly.\n+    const RUSTDOC_LINTS: &[&str] = &[\n+        \"broken_intra_doc_links\",\n+        \"private_intra_doc_links\",\n+        \"missing_crate_level_docs\",\n+        \"missing_doc_code_examples\",\n+        \"private_doc_tests\",\n+        \"invalid_codeblock_attributes\",\n+        \"invalid_html_tags\",\n+        \"non_autolinks\",\n+    ];\n+    for rustdoc_lint in RUSTDOC_LINTS {\n+        store.register_removed(rustdoc_lint, &format!(\"use `rustdoc::{}` instead\", rustdoc_lint));\n+    }\n+    store.register_removed(\n+        \"intra_doc_link_resolution_failure\",\n+        \"use `rustdoc::broken_intra_doc_links` instead\",\n+    );\n+    store.register_removed(\"rustdoc\", \"use `rustdoc::all` instead\");\n+\n     store.register_removed(\"unknown_features\", \"replaced by an error\");\n     store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");\n     store.register_removed(\"negate_unsigned\", \"cast a signed value instead\");"}, {"sha": "5a27135581747f15e5d91d1412996406502c69f6", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0", "patch": "@@ -69,23 +69,65 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n \n     let (span, panic) = panic_call(cx, f);\n \n-    cx.struct_span_lint(NON_FMT_PANIC, arg.span, |lint| {\n+    // Find the span of the argument to `panic!()`, before expansion in the\n+    // case of `panic!(some_macro!())`.\n+    // We don't use source_callsite(), because this `panic!(..)` might itself\n+    // be expanded from another macro, in which case we want to stop at that\n+    // expansion.\n+    let mut arg_span = arg.span;\n+    let mut arg_macro = None;\n+    while !span.contains(arg_span) {\n+        let expn = arg_span.ctxt().outer_expn_data();\n+        if expn.is_root() {\n+            break;\n+        }\n+        arg_macro = expn.macro_def_id;\n+        arg_span = expn.call_site;\n+    }\n+\n+    cx.struct_span_lint(NON_FMT_PANIC, arg_span, |lint| {\n         let mut l = lint.build(\"panic message is not a string literal\");\n         l.note(\"this is no longer accepted in Rust 2021\");\n-        if span.contains(arg.span) {\n+        if !span.contains(arg_span) {\n+            // No clue where this argument is coming from.\n+            l.emit();\n+            return;\n+        }\n+        if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n+            // A case of `panic!(format!(..))`.\n+            l.note(\"the panic!() macro supports formatting, so there's no need for the format!() macro here\");\n+            if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n+                l.multipart_suggestion(\n+                    \"remove the `format!(..)` macro call\",\n+                    vec![\n+                        (arg_span.until(open.shrink_to_hi()), \"\".into()),\n+                        (close.until(arg_span.shrink_to_hi()), \"\".into()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        } else {\n             l.span_suggestion_verbose(\n-                arg.span.shrink_to_lo(),\n+                arg_span.shrink_to_lo(),\n                 \"add a \\\"{}\\\" format string to Display the message\",\n                 \"\\\"{}\\\", \".into(),\n                 Applicability::MaybeIncorrect,\n             );\n             if panic == sym::std_panic_macro {\n-                l.span_suggestion_verbose(\n-                    span.until(arg.span),\n-                    \"or use std::panic::panic_any instead\",\n-                    \"std::panic::panic_any(\".into(),\n-                    Applicability::MachineApplicable,\n-                );\n+                if let Some((open, close, del)) = find_delimiters(cx, span) {\n+                    l.multipart_suggestion(\n+                        \"or use std::panic::panic_any instead\",\n+                        if del == '(' {\n+                            vec![(span.until(open), \"std::panic::panic_any\".into())]\n+                        } else {\n+                            vec![\n+                                (span.until(open.shrink_to_hi()), \"std::panic::panic_any(\".into()),\n+                                (close, \")\".into()),\n+                            ]\n+                        },\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n         }\n         l.emit();\n@@ -159,7 +201,7 @@ fn check_panic_str<'tcx>(\n             Some(v) if v.len() == 1 => \"panic message contains a brace\",\n             _ => \"panic message contains braces\",\n         };\n-        cx.struct_span_lint(NON_FMT_PANIC, brace_spans.unwrap_or(vec![span]), |lint| {\n+        cx.struct_span_lint(NON_FMT_PANIC, brace_spans.unwrap_or_else(|| vec![span]), |lint| {\n             let mut l = lint.build(msg);\n             l.note(\"this message is not used as a format string, but will be in Rust 2021\");\n             if span.contains(arg.span) {\n@@ -175,6 +217,19 @@ fn check_panic_str<'tcx>(\n     }\n }\n \n+/// Given the span of `some_macro!(args);`, gives the span of `(` and `)`,\n+/// and the type of (opening) delimiter used.\n+fn find_delimiters<'tcx>(cx: &LateContext<'tcx>, span: Span) -> Option<(Span, Span, char)> {\n+    let snippet = cx.sess().parse_sess.source_map().span_to_snippet(span).ok()?;\n+    let (open, open_ch) = snippet.char_indices().find(|&(_, c)| \"([{\".contains(c))?;\n+    let close = snippet.rfind(|c| \")]}\".contains(c))?;\n+    Some((\n+        span.from_inner(InnerSpan { start: open, end: open + 1 }),\n+        span.from_inner(InnerSpan { start: close, end: close + 1 }),\n+        open_ch,\n+    ))\n+}\n+\n fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span, Symbol) {\n     let mut expn = f.span.ctxt().outer_expn_data();\n "}, {"sha": "be9c6eafb6fdbf6801a340cd31b9ddf0f72aca61", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "479cc00199f6adb33e54dc76fa47caf4cedb66f3", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "ffbed3a0aff2d111ad897e81ad520085622e26f6", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "e632f29e672c08126edec6d1eb02b4a75d8d15f6", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "2d311cc32f8b7ba869a08aa1a1487734880afc2c", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "67946dfb292a6d6b2c5714077bebb6416dad8e6f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "005c4f9f6eaf73b4af297ec305202da18862dbbc", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 91, "deletions": 113, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "400b367095ec3b7107c4e8ada1db99b181555b0f", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "e97d96e3a4eabc01f7b02bef63cf60f84dc47623", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "f67e06706ea57deca52615f0193058bb4bfd20d2", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "51c80cf7dfa4192ec1c1dc46069931c422427daa", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 116, "deletions": 24, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "a8536595404423b36c8f1425fa5d316a1b24ef3e", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "30569f20793fbae6431915bd63d0c43074690f39", "filename": "compiler/rustc_macros/src/hash_stable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "291e7ef045e4f6c9f7e390c745110dbfa8f89d43", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "8a0fce209b7fbeb0a9b6ddfea32a78c909864d61", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "b5506acf73522994001b95b828c8177924028747", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "3d3071c18f2497c367d337966ed625a0bf87c3a1", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "9e1ac33368c7fdad810b923f1455f56feebe34f9", "filename": "compiler/rustc_metadata/src/link_args.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flink_args.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "a9f58b08f589998245afc46b6f6b5e96818d4a92", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "523e016eeb9f2726dbc700504b8d7634261de200", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "e9b8388c1c915e3dde9879af1a0495e8e94df95a", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "0f860d11dc21a551b7baa68ca42e6f1e47ab9c84", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "06f53bb9282eb382a43d1e9858e155c9e09c0932", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 49, "deletions": 54, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "610528956d0a18ba12d7ccaf736f410dc6ee90f2", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "8cb30e72f79210bcfc396ef3d60d4759bb3e0006", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "ba9d0a40732e6bec841cc6a239bdd9fa61565618", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 9, "deletions": 110, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "c688b23be1d02c74a8132e6e40b55503123692e2", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 11, "deletions": 106, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "706c79009496b903bd1bb81492d105cdf21d6856", "filename": "compiler/rustc_middle/src/hir/map/blocks.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fblocks.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "64d0503834bde34230b34e31ac40fbc3fd0071f1", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 37, "deletions": 57, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "9d00f0715a0126ccabe335511ad3d553c1fc5124", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 90, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "cf4e473d8aca1691561e553411f63f6634e62be4", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "cf29d21927c0d68ac617ef5893d4cdc5a1628568", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "abf56832329b2a6c6a3380eaa1998b4ef90288a2", "filename": "compiler/rustc_middle/src/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "d9e88265050023bfc699eff1e67e38bf277e1166", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "26e61ec8cf8666483ba5ebb14715069a00bee1f0", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "eae02a8cbfcf16386c222a4de5d7a4e41e9f6ecf", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "48595f2badc8fcb99fcd8b545d6806efde74cb9f", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "b2b969e9b34e87adc9b6b4371d4ace405510adee", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "a07ccd4d2b5285e2a3fb2dbff373b09b94b56089", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "f6952667494db5d12f12cdea90484e84e6469dca", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 124, "deletions": 45, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "6c2468b9ffe0b1c937d2a1fc53d5fb331d35668d", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "bde480180136bc9d192e3eb87fd40e7c65d3620b", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "3961fd938be26c55779a32b3fc886c421a88b313", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "887dbefa9f2da411bddbd8e4940b79dec02f1237", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "6fabddbd149ca677d34a6766dec3638b46bfffea", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "4e81612c0b9dee5f76d55668cd7d51730f879905", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "b03b26d64606cf83125138847a029b1daf6fb8b1", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "0bd0a701fb2e7aa2ebd2693130e377fe7ac0b858", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "ab085175762ab2409a2d4e05b630a5f2ea515ec7", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "4f978e63630440561e43fb5c0d4473f0c3d2a69a", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "a50dda69a0fcc4f13fefa21ffef4fb4a38e0af8b", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "95159ea46aec3e9950150c87cbc4aeaf0f287ca0", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "d3770fa416b53e0d51fd2dc7b171a2407aaf0e57", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "76ac6c4e08e910f588c4841824946f5f6cbd3450", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "73ad87a9ef219149776dcc5fd76c6c60507f781c", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "e7b2c9efd63cfa23da83525a5d4b694a76a55aad", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "98c215407a8e037685c150a8751b98b6f68fa352", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "e1d79248171a8b783191585d8511ef78a18ea904", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "f41bb7e6d6350945d172f565e6851340cb90c457", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "f19cc99844926a0d0ce821c8698c2d503695fa26", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "4c7db4e803b8ee5766afb5949086527379e3e548", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "79cd26f5668a13936cde730374aa78a7dbede1ae", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "23cedfd499eaa2e9d86fd2e6d4f2b1daaf1bc72d", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "814581a6cf171f4718590d0947ddb63719a7470f", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "f5aef108927dbfb49d3a8ac256e6919217fdbd0f", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 55, "deletions": 1247, "changes": 1302, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "53c164d44b3e159cb772dc31129a90d68663ff4e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "bd2e7747b7db8abb8e46db49284c550fb294fe97", "filename": "compiler/rustc_middle/src/ty/query/job.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fjob.rs?ref=2285f11724e2fa3251c94c9ab7672544099600e2"}, {"sha": "51a214bc07bacb9bdf6ca2173452784e14ee33fe", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 200, "deletions": 24, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "78193acc74acdfc729a3a2b03ac5de354692f82d", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "0961d4d0091d0a3c953091f0fc89937d91d28021", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "removed", "additions": 0, "deletions": 613, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2285f11724e2fa3251c94c9ab7672544099600e2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=2285f11724e2fa3251c94c9ab7672544099600e2"}, {"sha": "f21545447b2044f11c74ea9a9bc5091378489c8c", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "2cd969d7a16abfe32d7b740bbfc9ad2f45c3aa75", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 94, "deletions": 77, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "ce17a724e25d3ba2dd0f5cc71bf8f6eeb096f138", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "bb7fc661d2d8a193411b0c5e0609b35aea721c83", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "eb942b195b252f5c34b262010a7bcd13c67da05d", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "2f40a90fb5516f8099d8168273efad29e0e2c102", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}, {"sha": "03738f1b40a1c0538dcf1fadbb255e083046c325", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96d6f22a8e7f04f2ae0712f7359470a78c77a9e0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=96d6f22a8e7f04f2ae0712f7359470a78c77a9e0"}]}