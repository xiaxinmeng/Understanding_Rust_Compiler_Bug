{"sha": "d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMzJjMjQ0NzZmZWQ5ZGI3Y2NkMmI3MzNlMmU5YzFhOTBjMTdiM2U=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-07-03T13:04:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-03T13:04:29Z"}, "message": "Merge pull request #1057 from spastorino/store-pairs-in-ssa\n\nStore pairs in ssa", "tree": {"sha": "89316776da192fe2e4beff51a41294390af1d94d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89316776da192fe2e4beff51a41294390af1d94d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/yzdCRBK7hj4Ov3rIwAAdHIIACek2J90IH7fgqL2h6nt5Psi\n9ZWqwwicKLZjlDkpZ1sn0N+Fse64qypRRwsrtAzofa2PK94l+yCZYlqICJLMFXZl\niGii3nXSyFrVLLfZ+tl0cq3JEU7MH7O0Pi3Vn11sVfrgRnDL4teljEt+Nxew+ZJp\nK65EF0Lka2mXQgqjWb9ILla1rz49xTwCWOBSZ9b69i31IO7b1YKyIvLZebEKJ7nI\nFpAIXzFsaUCFi7dVRnwdCQlgZDGmJDNE03fySzm+A4j6EJyyNJ8R8kWTPYtLW4wg\nyDdujuszCmpYnimK9QnHrZL/gWiF/sWRy55wHPi/E04hmC7x45anQtGvn4fBaKM=\n=ayE+\n-----END PGP SIGNATURE-----\n", "payload": "tree 89316776da192fe2e4beff51a41294390af1d94d\nparent bc966492c2296e21cac4df0407f59b5a0cde2aff\nparent ef01b4e3dda14e592946d74169b6ed9ed71cc9b7\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1593781469 +0200\ncommitter GitHub <noreply@github.com> 1593781469 +0200\n\nMerge pull request #1057 from spastorino/store-pairs-in-ssa\n\nStore pairs in ssa"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "html_url": "https://github.com/rust-lang/rust/commit/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc966492c2296e21cac4df0407f59b5a0cde2aff", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc966492c2296e21cac4df0407f59b5a0cde2aff", "html_url": "https://github.com/rust-lang/rust/commit/bc966492c2296e21cac4df0407f59b5a0cde2aff"}, {"sha": "ef01b4e3dda14e592946d74169b6ed9ed71cc9b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef01b4e3dda14e592946d74169b6ed9ed71cc9b7", "html_url": "https://github.com/rust-lang/rust/commit/ef01b4e3dda14e592946d74169b6ed9ed71cc9b7"}], "stats": {"total": 151, "additions": 131, "deletions": 20}, "files": [{"sha": "7c4d7b12f6e99cd4230b62fa1ea73f17890df226", "filename": "src/abi/comments.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "patch": "@@ -78,6 +78,10 @@ pub(super) fn add_local_place_comments<'tcx>(\n             assert_eq!(local, place_local);\n             (\"ssa\", Cow::Owned(format!(\",var={}\", var.index())))\n         }\n+        CPlaceInner::VarPair(place_local, var1, var2) => {\n+            assert_eq!(local, place_local);\n+            (\"ssa\", Cow::Owned(format!(\",var=({}, {})\", var1.index(), var2.index())))\n+        }\n         CPlaceInner::Addr(ptr, meta) => {\n             let meta = if let Some(meta) = meta {\n                 Cow::Owned(format!(\",meta={}\", meta))"}, {"sha": "2c1181c757575de02c1ca130e16be075fda278eb", "filename": "src/abi/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "patch": "@@ -290,7 +290,11 @@ fn local_place<'tcx>(\n     is_ssa: bool,\n ) -> CPlace<'tcx> {\n     let place = if is_ssa {\n-        CPlace::new_var(fx, local, layout)\n+        if let rustc_target::abi::Abi::ScalarPair(_, _) = layout.abi {\n+            CPlace::new_var_pair(fx, local, layout)\n+        } else {\n+            CPlace::new_var(fx, local, layout)\n+        }\n     } else {\n         CPlace::new_stack_slot(fx, layout)\n     };"}, {"sha": "c3436785d90f0e9fe6829b10beba8fba9337065b", "filename": "src/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "patch": "@@ -11,7 +11,8 @@ pub(crate) enum SsaKind {\n \n pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Backend>) -> IndexVec<Local, SsaKind> {\n     let mut flag_map = fx.mir.local_decls.iter().map(|local_decl| {\n-        if fx.clif_type(fx.monomorphize(&local_decl.ty)).is_some() {\n+        let ty = fx.monomorphize(&local_decl.ty);\n+        if fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some() {\n             SsaKind::Ssa\n         } else {\n             SsaKind::NotSsa"}, {"sha": "616eb57307e9320f1bd27ca1b660221490ee7c06", "filename": "src/common.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "patch": "@@ -67,6 +67,26 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n     })\n }\n \n+fn clif_pair_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<(types::Type, types::Type)> {\n+    Some(match ty.kind {\n+        ty::Tuple(substs) if substs.len() == 2 => {\n+            let mut types = substs.types();\n+            (\n+                clif_type_from_ty(tcx, types.next().unwrap())?,\n+                clif_type_from_ty(tcx, types.next().unwrap())?,\n+            )\n+        }\n+        ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n+            if has_ptr_meta(tcx, pointee_ty) {\n+                (pointer_ty(tcx), pointer_ty(tcx))\n+            } else {\n+                return None\n+            }\n+        }\n+        _ => return None,\n+    })\n+}\n+\n /// Is a pointer to this type a fat ptr?\n pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     let ptr_ty = tcx.mk_ptr(TypeAndMut { ty, mutbl: rustc_hir::Mutability::Not });\n@@ -321,6 +341,10 @@ impl<'tcx, B: Backend + 'static> FunctionCx<'_, 'tcx, B> {\n         clif_type_from_ty(self.tcx, ty)\n     }\n \n+    pub(crate) fn clif_pair_type(&self, ty: Ty<'tcx>) -> Option<(Type, Type)> {\n+        clif_pair_type_from_ty(self.tcx, ty)\n+    }\n+\n     pub(crate) fn get_block(&self, bb: BasicBlock) -> Block {\n         *self.block_map.get(bb).unwrap()\n     }"}, {"sha": "709c85d240979c64c6cb208cb95d41690b28a573", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "patch": "@@ -405,6 +405,11 @@ fn place_location<'tcx>(\n                 AttributeValue::Exprloc(Expression::new())\n             }\n         }\n+        CPlaceInner::VarPair(_, _, _) => {\n+            // FIXME implement this\n+\n+            AttributeValue::Exprloc(Expression::new())\n+        }\n         CPlaceInner::Addr(_, _) => {\n             // FIXME implement this (used by arguments and returns)\n "}, {"sha": "1d0990163bb4f52814f6bb558ae6404f62008b45", "filename": "src/value_and_place.rs", "status": "modified", "additions": 91, "deletions": 18, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d032c24476fed9db7ccd2b733e2e9c1a90c17b3e/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=d032c24476fed9db7ccd2b733e2e9c1a90c17b3e", "patch": "@@ -179,12 +179,25 @@ impl<'tcx> CValue<'tcx> {\n                     _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n                 }\n             }\n+            CValueInner::ByValPair(val1, val2) => {\n+                match layout.abi {\n+                    Abi::ScalarPair(_, _) => {\n+                        let val = match field.as_u32() {\n+                            0 => val1,\n+                            1 => val2,\n+                            _ => bug!(\"field should be 0 or 1\"),\n+                        };\n+                        let field_layout = layout.field(&*fx, usize::from(field));\n+                        CValue::by_val(val, field_layout)\n+                    }\n+                    _ => unreachable!(\"value_field for ByValPair with abi {:?}\", layout.abi),\n+                }\n+            }\n             CValueInner::ByRef(ptr, None) => {\n                 let (field_ptr, field_layout) = codegen_field(fx, ptr, None, layout, field);\n                 CValue::by_ref(field_ptr, field_layout)\n             }\n             CValueInner::ByRef(_, Some(_)) => todo!(),\n-            _ => bug!(\"place_field for {:?}\", self),\n         }\n     }\n \n@@ -258,6 +271,7 @@ pub(crate) struct CPlace<'tcx> {\n #[derive(Debug, Copy, Clone)]\n pub(crate) enum CPlaceInner {\n     Var(Local, Variable),\n+    VarPair(Local, Variable, Variable),\n     Addr(Pointer, Option<Value>),\n }\n \n@@ -312,6 +326,25 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    pub(crate) fn new_var_pair(\n+        fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+        local: Local,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        let var1 = Variable::with_u32(fx.next_ssa_var);\n+        fx.next_ssa_var += 1;\n+        let var2 = Variable::with_u32(fx.next_ssa_var);\n+        fx.next_ssa_var += 1;\n+\n+        let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n+        fx.bcx.declare_var(var1, ty1);\n+        fx.bcx.declare_var(var2, ty2);\n+        CPlace {\n+            inner: CPlaceInner::VarPair(local, var1, var2),\n+            layout,\n+        }\n+    }\n+\n     pub(crate) fn for_ptr(ptr: Pointer, layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n         CPlace {\n             inner: CPlaceInner::Addr(ptr, None),\n@@ -334,6 +367,13 @@ impl<'tcx> CPlace<'tcx> {\n                 fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n                 CValue::by_val(val, layout)\n             }\n+            CPlaceInner::VarPair(_local, var1, var2) => {\n+                let val1 = fx.bcx.use_var(var1);\n+                fx.bcx.set_val_label(val1, cranelift_codegen::ir::ValueLabel::new(var1.index()));\n+                let val2 = fx.bcx.use_var(var2);\n+                fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n+                CValue::by_val_pair(val1, val2, layout)\n+            }\n             CPlaceInner::Addr(ptr, extra) => {\n                 if let Some(extra) = extra {\n                     CValue::by_ref_unsized(ptr, extra, layout)\n@@ -354,7 +394,8 @@ impl<'tcx> CPlace<'tcx> {\n     pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n         match self.inner {\n             CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n-            CPlaceInner::Var(_, _) => bug!(\"Expected CPlace::Addr, found {:?}\", self),\n+            CPlaceInner::Var(_, _)\n+            | CPlaceInner::VarPair(_, _, _) => bug!(\"Expected CPlace::Addr, found {:?}\", self),\n         }\n     }\n \n@@ -428,6 +469,30 @@ impl<'tcx> CPlace<'tcx> {\n         #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n         method: &'static str,\n     ) {\n+        fn transmute_value<'tcx>(\n+            fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+            var: Variable,\n+            data: Value,\n+            dst_ty: Type,\n+        ) {\n+            let src_ty = fx.bcx.func.dfg.value_type(data);\n+            let data = match (src_ty, dst_ty) {\n+                (_, _) if src_ty == dst_ty => data,\n+\n+                // This is a `write_cvalue_transmute`.\n+                (types::I32, types::F32) | (types::F32, types::I32)\n+                    | (types::I64, types::F64) | (types::F64, types::I64) => {\n+                        fx.bcx.ins().bitcast(dst_ty, data)\n+                }\n+                _ if src_ty.is_vector() && dst_ty.is_vector() => {\n+                    fx.bcx.ins().raw_bitcast(dst_ty, data)\n+                }\n+                _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n+            };\n+            fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n+            fx.bcx.def_var(var, data);\n+        }\n+\n         assert_eq!(self.layout().size, from.layout().size);\n \n         #[cfg(debug_assertions)]\n@@ -447,23 +512,15 @@ impl<'tcx> CPlace<'tcx> {\n         let to_ptr = match self.inner {\n             CPlaceInner::Var(_local, var) => {\n                 let data = CValue(from.0, dst_layout).load_scalar(fx);\n-                let src_ty = fx.bcx.func.dfg.value_type(data);\n                 let dst_ty = fx.clif_type(self.layout().ty).unwrap();\n-                let data = match (src_ty, dst_ty) {\n-                    (_, _) if src_ty == dst_ty => data,\n-\n-                    // This is a `write_cvalue_transmute`.\n-                    (types::I32, types::F32) | (types::F32, types::I32)\n-                    | (types::I64, types::F64) | (types::F64, types::I64) => {\n-                        fx.bcx.ins().bitcast(dst_ty, data)\n-                    }\n-                    _ if src_ty.is_vector() && dst_ty.is_vector() => {\n-                        fx.bcx.ins().raw_bitcast(dst_ty, data)\n-                    }\n-                    _ => unreachable!(\"write_cvalue_transmute: {:?} -> {:?}\", src_ty, dst_ty),\n-                };\n-                fx.bcx.set_val_label(data, cranelift_codegen::ir::ValueLabel::new(var.index()));\n-                fx.bcx.def_var(var, data);\n+                transmute_value(fx, var, data, dst_ty);\n+                return;\n+            }\n+            CPlaceInner::VarPair(_local, var1, var2) => {\n+                let (data1, data2) = CValue(from.0, dst_layout).load_scalar_pair(fx);\n+                let (dst_ty1, dst_ty2) = fx.clif_pair_type(self.layout().ty).unwrap();\n+                transmute_value(fx, var1, data1, dst_ty1);\n+                transmute_value(fx, var2, data2, dst_ty2);\n                 return;\n             }\n             CPlaceInner::Addr(ptr, None) => {\n@@ -529,6 +586,22 @@ impl<'tcx> CPlace<'tcx> {\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n+        if let CPlaceInner::VarPair(local, var1, var2) = self.inner {\n+            let layout = layout.field(&*fx, field.index());\n+\n+            match field.as_u32() {\n+                0 => return CPlace {\n+                    inner: CPlaceInner::Var(local, var1),\n+                    layout,\n+                },\n+                1 => return CPlace {\n+                    inner: CPlaceInner::Var(local, var2),\n+                    layout,\n+                },\n+                _ => unreachable!(\"field should be 0 or 1\"),\n+            }\n+        }\n+\n         let (base, extra) = self.to_ptr_maybe_unsized();\n \n         let (field_ptr, field_layout) = codegen_field(fx, base, extra, layout, field);"}]}