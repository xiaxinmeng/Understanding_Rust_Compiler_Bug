{"sha": "50ce605f462cf7436ea454a38f99246a2c3bfddb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwY2U2MDVmNDYyY2Y3NDM2ZWE0NTRhMzhmOTkyNDZhMmMzYmZkZGI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-11T00:39:35Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-14T04:58:38Z"}, "message": "Parse `pub(restricted)`", "tree": {"sha": "e218604cf73d2f5e7f180c27ed2382542fbb2afb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e218604cf73d2f5e7f180c27ed2382542fbb2afb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50ce605f462cf7436ea454a38f99246a2c3bfddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50ce605f462cf7436ea454a38f99246a2c3bfddb", "html_url": "https://github.com/rust-lang/rust/commit/50ce605f462cf7436ea454a38f99246a2c3bfddb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50ce605f462cf7436ea454a38f99246a2c3bfddb/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0833a89a3eea21152a5d7fbfa5418da4057f6acd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0833a89a3eea21152a5d7fbfa5418da4057f6acd", "html_url": "https://github.com/rust-lang/rust/commit/0833a89a3eea21152a5d7fbfa5418da4057f6acd"}], "stats": {"total": 41, "additions": 25, "deletions": 16}, "files": [{"sha": "e0e72a152820e6a692f75a734a214f5e3c91e195", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/50ce605f462cf7436ea454a38f99246a2c3bfddb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ce605f462cf7436ea454a38f99246a2c3bfddb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=50ce605f462cf7436ea454a38f99246a2c3bfddb", "patch": "@@ -70,6 +70,7 @@ bitflags! {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n         const NO_NONINLINE_MOD  = 1 << 2,\n+        const ALLOW_MODULE_PATHS = 1 << 3,\n     }\n }\n \n@@ -560,7 +561,9 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        self.check_strict_keywords();\n+        if !self.restrictions.contains(Restrictions::ALLOW_MODULE_PATHS) {\n+            self.check_strict_keywords();\n+        }\n         self.check_reserved_keywords();\n         match self.token {\n             token::Ident(i, _) => {\n@@ -4938,7 +4941,7 @@ impl<'a> Parser<'a> {\n \n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n-        let vis = self.parse_visibility()?;\n+        let vis = self.parse_visibility(true)?;\n         let defaultness = self.parse_defaultness()?;\n         let (name, node) = if self.eat_keyword(keywords::Type) {\n             let name = self.parse_ident()?;\n@@ -5250,7 +5253,7 @@ impl<'a> Parser<'a> {\n             |p| {\n                 let attrs = p.parse_outer_attributes()?;\n                 let lo = p.span.lo;\n-                let vis = p.parse_visibility()?;\n+                let vis = p.parse_visibility(false)?;\n                 let ty = p.parse_ty_sum()?;\n                 Ok(StructField {\n                     span: mk_sp(lo, p.span.hi),\n@@ -5290,20 +5293,26 @@ impl<'a> Parser<'a> {\n \n     /// Parse an element of a struct definition\n     fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n-\n         let attrs = self.parse_outer_attributes()?;\n-\n-        if self.eat_keyword(keywords::Pub) {\n-            return self.parse_single_struct_field(Visibility::Public, attrs);\n-        }\n-\n-        return self.parse_single_struct_field(Visibility::Inherited, attrs);\n+        let vis = self.parse_visibility(true)?;\n+        self.parse_single_struct_field(vis, attrs)\n     }\n \n-    /// Parse visibility: PUB or nothing\n-    fn parse_visibility(&mut self) -> PResult<'a, Visibility> {\n-        if self.eat_keyword(keywords::Pub) { Ok(Visibility::Public) }\n-        else { Ok(Visibility::Inherited) }\n+    fn parse_visibility(&mut self, allow_restricted: bool) -> PResult<'a, Visibility> {\n+        if !self.eat_keyword(keywords::Pub) {\n+            Ok(Visibility::Inherited)\n+        } else if !allow_restricted || !self.eat(&token::OpenDelim(token::Paren)) {\n+            Ok(Visibility::Public)\n+        } else if self.eat_keyword(keywords::Crate) {\n+            let span = self.last_span;\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+            Ok(Visibility::Crate(span))\n+        } else {\n+            let path = self.with_res(Restrictions::ALLOW_MODULE_PATHS,\n+                                     |this| this.parse_path(NoTypesAllowed))?;\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+            Ok(Visibility::Restricted { path: P(path), id: ast::DUMMY_NODE_ID })\n+        }\n     }\n \n     /// Parse defaultness: DEFAULT or nothing\n@@ -5765,7 +5774,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let visibility = self.parse_visibility()?;\n+        let visibility = self.parse_visibility(true)?;\n \n         if self.eat_keyword(keywords::Use) {\n             // USE ITEM\n@@ -6015,7 +6024,7 @@ impl<'a> Parser<'a> {\n     fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span.lo;\n-        let visibility = self.parse_visibility()?;\n+        let visibility = self.parse_visibility(true)?;\n \n         if self.check_keyword(keywords::Static) {\n             // FOREIGN STATIC ITEM"}]}