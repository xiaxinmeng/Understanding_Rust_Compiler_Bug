{"sha": "163892cf50a0f5ffaf4367475e7d4a412b008794", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2Mzg5MmNmNTBhMGY1ZmZhZjQzNjc0NzVlN2Q0YTQxMmIwMDg3OTQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T05:00:28Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T05:00:28Z"}, "message": "Use `Symbol` in two more functions.", "tree": {"sha": "fe14eb6c09faeb573be32f001c2dce7df36ef8b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe14eb6c09faeb573be32f001c2dce7df36ef8b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/163892cf50a0f5ffaf4367475e7d4a412b008794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/163892cf50a0f5ffaf4367475e7d4a412b008794", "html_url": "https://github.com/rust-lang/rust/commit/163892cf50a0f5ffaf4367475e7d4a412b008794", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/163892cf50a0f5ffaf4367475e7d4a412b008794/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca3766e2e58f462a20922e42c821a37eaf0e13db", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3766e2e58f462a20922e42c821a37eaf0e13db", "html_url": "https://github.com/rust-lang/rust/commit/ca3766e2e58f462a20922e42c821a37eaf0e13db"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "b27e9c543377ac0845b90605906f1ca505ca20c3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/163892cf50a0f5ffaf4367475e7d4a412b008794/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163892cf50a0f5ffaf4367475e7d4a412b008794/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=163892cf50a0f5ffaf4367475e7d4a412b008794", "patch": "@@ -877,9 +877,9 @@ fn check_matcher_core(\n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n         'each_last: for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, ref name, ref frag_spec) = *token {\n+            if let TokenTree::MetaVarDecl(_, name, frag_spec) = *token {\n                 for next_token in &suffix_first.tokens {\n-                    match is_in_follow(next_token, &frag_spec.as_str()) {\n+                    match is_in_follow(next_token, frag_spec.name) {\n                         IsInFollow::Invalid(msg, help) => {\n                             sess.span_diagnostic\n                                 .struct_span_err(next_token.span(), &msg)\n@@ -948,7 +948,7 @@ fn check_matcher_core(\n \n fn token_can_be_followed_by_any(tok: &quoted::TokenTree) -> bool {\n     if let quoted::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        frag_can_be_followed_by_any(&frag_spec.as_str())\n+        frag_can_be_followed_by_any(frag_spec.name)\n     } else {\n         // (Non NT's can always be followed by anthing in matchers.)\n         true\n@@ -963,15 +963,15 @@ fn token_can_be_followed_by_any(tok: &quoted::TokenTree) -> bool {\n /// specifier which consumes at most one token tree can be followed by\n /// a fragment specifier (indeed, these fragments can be followed by\n /// ANYTHING without fear of future compatibility hazards).\n-fn frag_can_be_followed_by_any(frag: &str) -> bool {\n+fn frag_can_be_followed_by_any(frag: Symbol) -> bool {\n     match frag {\n-        \"item\"     | // always terminated by `}` or `;`\n-        \"block\"    | // exactly one token tree\n-        \"ident\"    | // exactly one token tree\n-        \"literal\"  | // exactly one token tree\n-        \"meta\"     | // exactly one token tree\n-        \"lifetime\" | // exactly one token tree\n-        \"tt\" =>   // exactly one token tree\n+        sym::item     | // always terminated by `}` or `;`\n+        sym::block    | // exactly one token tree\n+        sym::ident    | // exactly one token tree\n+        sym::literal  | // exactly one token tree\n+        sym::meta     | // exactly one token tree\n+        sym::lifetime | // exactly one token tree\n+        sym::tt =>   // exactly one token tree\n             true,\n \n         _ =>\n@@ -993,7 +993,7 @@ enum IsInFollow {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n+fn is_in_follow(tok: &quoted::TokenTree, frag: Symbol) -> IsInFollow {\n     use quoted::TokenTree;\n \n     if let TokenTree::Token(Token { kind: token::CloseDelim(_), .. }) = *tok {\n@@ -1002,17 +1002,17 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n         IsInFollow::Yes\n     } else {\n         match frag {\n-            \"item\" => {\n+            sym::item => {\n                 // since items *must* be followed by either a `;` or a `}`, we can\n                 // accept anything after them\n                 IsInFollow::Yes\n             }\n-            \"block\" => {\n+            sym::block => {\n                 // anything can follow block, the braces provide an easy boundary to\n                 // maintain\n                 IsInFollow::Yes\n             }\n-            \"stmt\" | \"expr\" => {\n+            sym::stmt | sym::expr => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`;`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1022,7 +1022,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"pat\" => {\n+            sym::pat => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1033,7 +1033,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"path\" | \"ty\" => {\n+            sym::path | sym::ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\",\n                     \"`where`\",\n@@ -1061,20 +1061,20 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"ident\" | \"lifetime\" => {\n+            sym::ident | sym::lifetime => {\n                 // being a single token, idents and lifetimes are harmless\n                 IsInFollow::Yes\n             }\n-            \"literal\" => {\n+            sym::literal => {\n                 // literals may be of a single token, or two tokens (negative numbers)\n                 IsInFollow::Yes\n             }\n-            \"meta\" | \"tt\" => {\n+            sym::meta | sym::tt => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n                 IsInFollow::Yes\n             }\n-            \"vis\" => {\n+            sym::vis => {\n                 // Explicitly disallow `priv`, on the off chance it comes back.\n                 const TOKENS: &[&str] = &[\"`,`\", \"an ident\", \"a type\"];\n                 match tok {\n@@ -1099,7 +1099,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            \"\" => IsInFollow::Yes, // kw::Invalid\n+            kw::Invalid => IsInFollow::Yes,\n             _ => IsInFollow::Invalid(\n                 format!(\"invalid fragment specifier `{}`\", frag),\n                 VALID_FRAGMENT_NAMES_MSG,"}]}