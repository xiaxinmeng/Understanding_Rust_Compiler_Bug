{"sha": "b71107912de76a1092b1a0a18ca70922c1b4be5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MTEwNzkxMmRlNzZhMTA5MmIxYTBhMThjYTcwOTIyYzFiNGJlNWU=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-09T07:57:35Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-04-24T17:51:25Z"}, "message": "hir: make NodeId methods depend on HirId ones", "tree": {"sha": "79d48ddfd6b767f4bfe19acc1c0d5e8188c2d769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79d48ddfd6b767f4bfe19acc1c0d5e8188c2d769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b71107912de76a1092b1a0a18ca70922c1b4be5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b71107912de76a1092b1a0a18ca70922c1b4be5e", "html_url": "https://github.com/rust-lang/rust/commit/b71107912de76a1092b1a0a18ca70922c1b4be5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b71107912de76a1092b1a0a18ca70922c1b4be5e/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "url": "https://api.github.com/repos/rust-lang/rust/commits/16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "html_url": "https://github.com/rust-lang/rust/commit/16fd0f47aabbb17e98eb79ca6da7a95dc617acad"}], "stats": {"total": 220, "additions": 102, "deletions": 118}, "files": [{"sha": "63cf9eae0f99a392e6b3561e81c12bc8e7a6360f", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 102, "deletions": 118, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/b71107912de76a1092b1a0a18ca70922c1b4be5e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71107912de76a1092b1a0a18ca70922c1b4be5e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=b71107912de76a1092b1a0a18ca70922c1b4be5e", "patch": "@@ -200,17 +200,16 @@ impl<'hir> Map<'hir> {\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, id: NodeId) {\n         let hir_id = self.node_to_hir_id(id);\n-        if let Some(entry) = self.map.get(&hir_id) {\n-            self.dep_graph.read_index(entry.dep_node);\n-        } else {\n-            bug!(\"called `HirMap::read()` with invalid `NodeId`: {:?}\", id)\n-        }\n+        self.read_by_hir_id(hir_id);\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn read_by_hir_id(&self, hir_id: HirId) {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.read(node_id);\n+        if let Some(entry) = self.map.get(&hir_id) {\n+            self.dep_graph.read_index(entry.dep_node);\n+        } else {\n+            bug!(\"called `HirMap::read()` with invalid `HirId`: {:?}\", hir_id)\n+        }\n     }\n \n     #[inline]\n@@ -458,17 +457,16 @@ impl<'hir> Map<'hir> {\n \n     pub fn fn_decl(&self, node_id: ast::NodeId) -> Option<FnDecl> {\n         let hir_id = self.node_to_hir_id(node_id);\n-        if let Some(entry) = self.find_entry(hir_id) {\n-            entry.fn_decl().cloned()\n-        } else {\n-            bug!(\"no entry for node_id `{}`\", node_id)\n-        }\n+        self.fn_decl_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.fn_decl(node_id)\n+        if let Some(entry) = self.find_entry(hir_id) {\n+            entry.fn_decl().cloned()\n+        } else {\n+            bug!(\"no entry for hir_id `{}`\", hir_id)\n+        }\n     }\n \n     /// Returns the `NodeId` that corresponds to the definition of\n@@ -488,6 +486,11 @@ impl<'hir> Map<'hir> {\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n         let hir_id = self.node_to_hir_id(id);\n+        self.maybe_body_owned_by_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn maybe_body_owned_by_by_hir_id(&self, hir_id: HirId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             if self.dep_graph.is_fully_enabled() {\n                 let hir_id_owner = hir_id.owner;\n@@ -497,16 +500,10 @@ impl<'hir> Map<'hir> {\n \n             entry.associated_body()\n         } else {\n-            bug!(\"no entry for id `{}`\", id)\n+            bug!(\"no entry for id `{}`\", hir_id)\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn maybe_body_owned_by_by_hir_id(&self, id: HirId) -> Option<BodyId> {\n-        let node_id = self.hir_to_node_id(id);\n-        self.maybe_body_owned_by(node_id)\n-    }\n-\n     /// Given a body owner's id, returns the `BodyId` associated with it.\n     pub fn body_owned_by(&self, id: HirId) -> BodyId {\n         self.maybe_body_owned_by_by_hir_id(id).unwrap_or_else(|| {\n@@ -516,7 +513,13 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n-        match self.get(id) {\n+        let hir_id = self.node_to_hir_id(id);\n+        self.body_owner_kind_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n+        match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n             Node::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n             Node::ImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n@@ -539,12 +542,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n-        let node_id = self.hir_to_node_id(id);\n-        self.body_owner_kind(node_id)\n-    }\n-\n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n         match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n@@ -625,14 +622,15 @@ impl<'hir> Map<'hir> {\n     /// Retrieve the Node corresponding to `id`, panicking if it cannot\n     /// be found.\n     pub fn get(&self, id: NodeId) -> Node<'hir> {\n-        // read recorded by `find`\n-        self.find(id).unwrap_or_else(|| bug!(\"couldn't find node id {} in the AST map\", id))\n+        let hir_id = self.node_to_hir_id(id);\n+        self.get_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn get_by_hir_id(&self, id: HirId) -> Node<'hir> {\n-        let node_id = self.hir_to_node_id(id);\n-        self.get(node_id)\n+        // read recorded by `find`\n+        self.find_by_hir_id(id).unwrap_or_else(||\n+            bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n@@ -669,6 +667,11 @@ impl<'hir> Map<'hir> {\n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n         let hir_id = self.node_to_hir_id(id);\n+        self.find_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n         let result = self.find_entry(hir_id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n                 None\n@@ -682,12 +685,6 @@ impl<'hir> Map<'hir> {\n         result\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn find_by_hir_id(&self, hir_id: HirId) -> Option<Node<'hir>> {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.find(node_id)\n-    }\n-\n     /// Similar to `get_parent`; returns the parent node-id, or own `id` if there is\n     /// no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n     /// present in the map -- so passing the return value of get_parent_node to\n@@ -700,6 +697,12 @@ impl<'hir> Map<'hir> {\n     /// that can happen if the ID is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n         let hir_id = self.node_to_hir_id(id);\n+        let parent_hir_id = self.get_parent_node_by_hir_id(hir_id);\n+        self.hir_to_node_id(parent_hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_node_by_hir_id(&self, hir_id: HirId) -> HirId {\n         if self.dep_graph.is_fully_enabled() {\n             let hir_id_owner = hir_id.owner;\n             let def_path_hash = self.definitions.def_path_hash(hir_id_owner);\n@@ -708,15 +711,7 @@ impl<'hir> Map<'hir> {\n \n         self.find_entry(hir_id)\n             .and_then(|x| x.parent_node())\n-            .map(|x| self.hir_to_node_id(x))\n-            .unwrap_or(id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn get_parent_node_by_hir_id(&self, id: HirId) -> HirId {\n-        let node_id = self.hir_to_node_id(id);\n-        let parent_node_id = self.get_parent_node(node_id);\n-        self.node_to_hir_id(parent_node_id)\n+            .unwrap_or(hir_id)\n     }\n \n     /// Check if the node is an argument. An argument is a local variable whose\n@@ -832,7 +827,13 @@ impl<'hir> Map<'hir> {\n     /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n         let hir_id = self.node_to_hir_id(id);\n-        let parent_hid = match self.walk_parent_nodes(hir_id, |node| match *node {\n+        let parent_hir_id = self.get_parent_item(hir_id);\n+        self.hir_to_node_id(parent_hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n+        match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n             Node::ForeignItem(_) |\n             Node::TraitItem(_) |\n@@ -841,75 +842,65 @@ impl<'hir> Map<'hir> {\n         }, |_| false) {\n             Ok(id) => id,\n             Err(id) => id,\n-        };\n-\n-        self.hir_to_node_id(parent_hid)\n-    }\n-\n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn get_parent_item(&self, id: HirId) -> HirId {\n-        let node_id = self.hir_to_node_id(id);\n-        let parent_node_id = self.get_parent(node_id);\n-        self.node_to_hir_id(parent_node_id)\n+        }\n     }\n \n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n-        self.local_def_id(self.get_module_parent_node(id))\n+        let hir_id = self.node_to_hir_id(id);\n+        self.get_module_parent_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n-        let node_id = self.hir_to_node_id(id);\n-        self.get_module_parent(node_id)\n+        self.local_def_id_from_hir_id(self.get_module_parent_node(id))\n     }\n \n-    /// Returns the `NodeId` of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {\n-        let hir_id = self.node_to_hir_id(id);\n-        let parent_hid = match self.walk_parent_nodes(hir_id, |node| match *node {\n+    pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n+        match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n             Err(id) => id,\n-        };\n-\n-        self.hir_to_node_id(parent_hid)\n+        }\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME: it is not clear to me that all items qualify as scopes -- statics\n     /// and associated types probably shouldn't, for example. Behavior in this\n     /// regard should be expected to be highly unstable.\n-    pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n-        let hir_id = self.node_to_hir_id(id);\n-        let parent_hid = self.walk_parent_nodes(hir_id, |node| match *node {\n+    pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n+        self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n             Node::ForeignItem(_) |\n             Node::TraitItem(_) |\n             Node::ImplItem(_) |\n             Node::Block(_) => true,\n             _ => false,\n-        }, |_| false).ok();\n-\n-        parent_hid.map(|hid| self.hir_to_node_id(hid))\n+        }, |_| false).ok()\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n-        self.local_def_id(self.get_parent(id))\n+        let hir_id = self.node_to_hir_id(id);\n+        self.get_parent_did_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn get_parent_did_by_hir_id(&self, id: HirId) -> DefId {\n-        let node_id = self.hir_to_node_id(id);\n-        self.get_parent_did(node_id)\n+        self.local_def_id_from_hir_id(self.get_parent_item(id))\n     }\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let hir_id = self.node_to_hir_id(id);\n+        self.get_foreign_abi_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn get_foreign_abi_by_hir_id(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n             if let Entry {\n@@ -922,17 +913,9 @@ impl<'hir> Map<'hir> {\n         bug!(\"expected foreign mod or inlined parent, found {}\", self.hir_to_string(parent))\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn get_foreign_abi_by_hir_id(&self, id: HirId) -> Abi {\n-        let node_id = self.hir_to_node_id(id);\n-        self.get_foreign_abi(node_id)\n-    }\n-\n     pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n-        match self.find(id) { // read recorded by `find`\n-            Some(Node::Item(item)) => item,\n-            _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n-        }\n+        let hir_id = self.node_to_hir_id(id);\n+        self.expect_item_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n@@ -987,21 +970,27 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn expect_expr(&self, id: NodeId) -> &'hir Expr {\n-        match self.find(id) { // read recorded by find\n-            Some(Node::Expr(expr)) => expr,\n-            _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n-        }\n+        let hir_id = self.node_to_hir_id(id);\n+        self.expect_expr_by_hir_id(hir_id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n-        let node_id = self.hir_to_node_id(id);\n-        self.expect_expr(node_id)\n+        match self.find_by_hir_id(id) { // read recorded by find\n+            Some(Node::Expr(expr)) => expr,\n+            _ => bug!(\"expected expr, found {}\", self.hir_to_string(id))\n+        }\n     }\n \n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n-        match self.get(id) {\n+        let hir_id = self.node_to_hir_id(id);\n+        self.name_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn name_by_hir_id(&self, id: HirId) -> Name {\n+        match self.get_by_hir_id(id) {\n             Node::Item(i) => i.ident.name,\n             Node::ForeignItem(fi) => fi.ident.name,\n             Node::ImplItem(ii) => ii.ident.name,\n@@ -1011,21 +1000,21 @@ impl<'hir> Map<'hir> {\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n-            Node::Ctor(..) => self.name(self.get_parent(id)),\n-            _ => bug!(\"no name for {}\", self.node_to_string(id))\n+            Node::Ctor(..) => self.name_by_hir_id(self.get_parent_item(id)),\n+            _ => bug!(\"no name for {}\", self.hir_to_string(id))\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn name_by_hir_id(&self, id: HirId) -> Name {\n-        let node_id = self.hir_to_node_id(id);\n-        self.name(node_id)\n-    }\n-\n     /// Given a node ID, get a list of attributes associated with the AST\n     /// corresponding to the Node ID\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n-        self.read(id); // reveals attributes on the node\n+        let hir_id = self.node_to_hir_id(id);\n+        self.attrs_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n+        self.read_by_hir_id(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n@@ -1039,19 +1028,13 @@ impl<'hir> Map<'hir> {\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n-            Some(Node::Ctor(..)) => return self.attrs(self.get_parent(id)),\n+            Some(Node::Ctor(..)) => return self.attrs_by_hir_id(self.get_parent_item(id)),\n             Some(Node::Crate) => Some(&self.forest.krate.attrs[..]),\n             _ => None\n         };\n         attrs.unwrap_or(&[])\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n-        let node_id = self.hir_to_node_id(id);\n-        self.attrs(node_id)\n-    }\n-\n     /// Returns an iterator that yields the node id's with paths that\n     /// match `parts`.  (Requires `parts` is non-empty.)\n     ///\n@@ -1071,6 +1054,11 @@ impl<'hir> Map<'hir> {\n \n     pub fn span(&self, id: NodeId) -> Span {\n         let hir_id = self.node_to_hir_id(id);\n+        self.span_by_hir_id(hir_id)\n+    }\n+\n+    // FIXME(@ljedrz): replace the NodeId variant\n+    pub fn span_by_hir_id(&self, hir_id: HirId) -> Span {\n         self.read_by_hir_id(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n             Some(Node::Item(item)) => item.span,\n@@ -1088,7 +1076,9 @@ impl<'hir> Map<'hir> {\n             Some(Node::Binding(pat)) => pat.span,\n             Some(Node::Pat(pat)) => pat.span,\n             Some(Node::Block(block)) => block.span,\n-            Some(Node::Ctor(..)) => match self.find(self.get_parent_node(id)) {\n+            Some(Node::Ctor(..)) => match self.find_by_hir_id(\n+                self.get_parent_node_by_hir_id(hir_id))\n+            {\n                 Some(Node::Item(item)) => item.span,\n                 Some(Node::Variant(variant)) => variant.span,\n                 _ => unreachable!(),\n@@ -1102,16 +1092,10 @@ impl<'hir> Map<'hir> {\n             Some(Node::Local(local)) => local.span,\n             Some(Node::MacroDef(macro_def)) => macro_def.span,\n             Some(Node::Crate) => self.forest.krate.span,\n-            None => bug!(\"hir::map::Map::span: id not in map: {:?}\", id),\n+            None => bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id),\n         }\n     }\n \n-    // FIXME(@ljedrz): replace the NodeId variant\n-    pub fn span_by_hir_id(&self, id: HirId) -> Span {\n-        let node_id = self.hir_to_node_id(id);\n-        self.span(node_id)\n-    }\n-\n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n         self.as_local_node_id(id).map(|id| self.span(id))\n     }"}]}