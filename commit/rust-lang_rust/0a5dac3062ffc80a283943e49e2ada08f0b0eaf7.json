{"sha": "0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "node_id": "C_kwDOAAsO6NoAKDBhNWRhYzMwNjJmZmM4MGEyODM5NDNlNDllMmFkYTA4ZjBiMGVhZjc", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-10-10T21:40:40Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2023-04-06T08:34:16Z"}, "message": "Add `UnwindAction::Terminate`", "tree": {"sha": "5110a2f63038db9e3e03883b3d3b5685452a5719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5110a2f63038db9e3e03883b3d3b5685452a5719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "html_url": "https://github.com/rust-lang/rust/commit/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5", "html_url": "https://github.com/rust-lang/rust/commit/5e6ed132fa8a1bd1ec6b365e61e9e290528c90f5"}], "stats": {"total": 247, "additions": 126, "deletions": 121}, "files": [{"sha": "1fec2c9fcabb75e93bcb47ffc05ddd34448284a8", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -1663,8 +1663,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 self.assert_iscleanup(body, ctxt, unwind, true);\n             }\n-            UnwindAction::Continue => (),\n-            UnwindAction::Unreachable => (),\n+            UnwindAction::Continue => {\n+                if is_cleanup {\n+                    span_mirbug!(self, ctxt, \"unwind on cleanup block\")\n+                }\n+            }\n+            UnwindAction::Unreachable | UnwindAction::Terminate => (),\n         }\n     }\n "}, {"sha": "5bc78e5dbacfe8985c3f8617543be01ca7ac4869", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 75, "deletions": 81, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -170,22 +170,17 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n \n         let unwind_block = match unwind {\n             mir::UnwindAction::Cleanup(cleanup) => Some(self.llbb_with_cleanup(fx, cleanup)),\n-            _ if fx.mir[self.bb].is_cleanup\n-                && fn_abi.can_unwind\n-                && !base::wants_msvc_seh(fx.cx.tcx().sess) =>\n-            {\n-                // Exception must not propagate out of the execution of a cleanup (doing so\n-                // can cause undefined behaviour). We insert a double unwind guard for\n-                // functions that can potentially unwind to protect against this.\n-                //\n-                // This is not necessary for SEH which does not use successive unwinding\n-                // like Itanium EH. EH frames in SEH are different from normal function\n-                // frames and SEH will abort automatically if an exception tries to\n-                // propagate out from cleanup.\n-                Some(fx.double_unwind_guard())\n-            }\n             mir::UnwindAction::Continue => None,\n             mir::UnwindAction::Unreachable => None,\n+            mir::UnwindAction::Terminate => {\n+                if fx.mir[self.bb].is_cleanup && base::wants_msvc_seh(fx.cx.tcx().sess) {\n+                    // SEH will abort automatically if an exception tries to\n+                    // propagate out from cleanup.\n+                    None\n+                } else {\n+                    Some(fx.terminate_block())\n+                }\n+            }\n         };\n \n         if let Some(unwind_block) = unwind_block {\n@@ -253,7 +248,14 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         instance: Instance<'_>,\n         mergeable_succ: bool,\n     ) -> MergingSucc {\n-        if let mir::UnwindAction::Cleanup(cleanup) = unwind {\n+        let unwind_target = match unwind {\n+            mir::UnwindAction::Cleanup(cleanup) => Some(self.llbb_with_cleanup(fx, cleanup)),\n+            mir::UnwindAction::Terminate => Some(fx.terminate_block()),\n+            mir::UnwindAction::Continue => None,\n+            mir::UnwindAction::Unreachable => None,\n+        };\n+\n+        if let Some(cleanup) = unwind_target {\n             let ret_llbb = if let Some(target) = destination {\n                 fx.llbb(target)\n             } else {\n@@ -266,7 +268,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 options,\n                 line_spans,\n                 instance,\n-                Some((ret_llbb, self.llbb_with_cleanup(fx, cleanup), self.funclet(fx))),\n+                Some((ret_llbb, cleanup, self.funclet(fx))),\n             );\n             MergingSucc::False\n         } else {\n@@ -1551,62 +1553,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn landing_pad_for_uncached(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n         let llbb = self.llbb(bb);\n         if base::wants_msvc_seh(self.cx.sess()) {\n-            let funclet;\n-            let ret_llbb;\n-            match self.mir[bb].terminator.as_ref().map(|t| &t.kind) {\n-                // This is a basic block that we're aborting the program for,\n-                // notably in an `extern` function. These basic blocks are inserted\n-                // so that we assert that `extern` functions do indeed not panic,\n-                // and if they do we abort the process.\n-                //\n-                // On MSVC these are tricky though (where we're doing funclets). If\n-                // we were to do a cleanuppad (like below) the normal functions like\n-                // `longjmp` would trigger the abort logic, terminating the\n-                // program. Instead we insert the equivalent of `catch(...)` for C++\n-                // which magically doesn't trigger when `longjmp` files over this\n-                // frame.\n-                //\n-                // Lots more discussion can be found on #48251 but this codegen is\n-                // modeled after clang's for:\n-                //\n-                //      try {\n-                //          foo();\n-                //      } catch (...) {\n-                //          bar();\n-                //      }\n-                Some(&mir::TerminatorKind::Abort) => {\n-                    let cs_llbb =\n-                        Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n-                    let cp_llbb =\n-                        Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_llbb;\n-\n-                    let mut cs_bx = Bx::build(self.cx, cs_llbb);\n-                    let cs = cs_bx.catch_switch(None, None, &[cp_llbb]);\n-\n-                    // The \"null\" here is actually a RTTI type descriptor for the\n-                    // C++ personality function, but `catch (...)` has no type so\n-                    // it's null. The 64 here is actually a bitfield which\n-                    // represents that this is a catch-all block.\n-                    let mut cp_bx = Bx::build(self.cx, cp_llbb);\n-                    let null = cp_bx.const_null(\n-                        cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n-                    );\n-                    let sixty_four = cp_bx.const_i32(64);\n-                    funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n-                    cp_bx.br(llbb);\n-                }\n-                _ => {\n-                    let cleanup_llbb =\n-                        Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_llbb;\n-                    let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n-                    funclet = cleanup_bx.cleanup_pad(None, &[]);\n-                    cleanup_bx.br(llbb);\n-                }\n-            }\n+            let cleanup_bb = Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n+            let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n+            let funclet = cleanup_bx.cleanup_pad(None, &[]);\n+            cleanup_bx.br(llbb);\n             self.funclets[bb] = Some(funclet);\n-            ret_llbb\n+            cleanup_bb\n         } else {\n             let cleanup_llbb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n             let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n@@ -1633,26 +1585,68 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         })\n     }\n \n-    fn double_unwind_guard(&mut self) -> Bx::BasicBlock {\n-        self.double_unwind_guard.unwrap_or_else(|| {\n-            assert!(!base::wants_msvc_seh(self.cx.sess()));\n+    fn terminate_block(&mut self) -> Bx::BasicBlock {\n+        self.terminate_block.unwrap_or_else(|| {\n+            let funclet;\n+            let llbb;\n+            let mut bx;\n+            if base::wants_msvc_seh(self.cx.sess()) {\n+                // This is a basic block that we're aborting the program for,\n+                // notably in an `extern` function. These basic blocks are inserted\n+                // so that we assert that `extern` functions do indeed not panic,\n+                // and if they do we abort the process.\n+                //\n+                // On MSVC these are tricky though (where we're doing funclets). If\n+                // we were to do a cleanuppad (like below) the normal functions like\n+                // `longjmp` would trigger the abort logic, terminating the\n+                // program. Instead we insert the equivalent of `catch(...)` for C++\n+                // which magically doesn't trigger when `longjmp` files over this\n+                // frame.\n+                //\n+                // Lots more discussion can be found on #48251 but this codegen is\n+                // modeled after clang's for:\n+                //\n+                //      try {\n+                //          foo();\n+                //      } catch (...) {\n+                //          bar();\n+                //      }\n+                llbb = Bx::append_block(self.cx, self.llfn, \"cs_terminate\");\n+                let cp_llbb = Bx::append_block(self.cx, self.llfn, \"cp_terminate\");\n+\n+                let mut cs_bx = Bx::build(self.cx, llbb);\n+                let cs = cs_bx.catch_switch(None, None, &[llbb]);\n+\n+                // The \"null\" here is actually a RTTI type descriptor for the\n+                // C++ personality function, but `catch (...)` has no type so\n+                // it's null. The 64 here is actually a bitfield which\n+                // represents that this is a catch-all block.\n+                bx = Bx::build(self.cx, cp_llbb);\n+                let null =\n+                    bx.const_null(bx.type_i8p_ext(bx.cx().data_layout().instruction_address_space));\n+                let sixty_four = bx.const_i32(64);\n+                funclet = Some(bx.catch_pad(cs, &[null, sixty_four, null]));\n+            } else {\n+                llbb = Bx::append_block(self.cx, self.llfn, \"terminate\");\n+                bx = Bx::build(self.cx, llbb);\n+\n+                let llpersonality = self.cx.eh_personality();\n+                bx.cleanup_landing_pad(llpersonality);\n \n-            let llbb = Bx::append_block(self.cx, self.llfn, \"abort\");\n-            let mut bx = Bx::build(self.cx, llbb);\n-            self.set_debug_loc(&mut bx, mir::SourceInfo::outermost(self.mir.span));\n+                funclet = None;\n+            }\n \n-            let llpersonality = self.cx.eh_personality();\n-            bx.cleanup_landing_pad(llpersonality);\n+            self.set_debug_loc(&mut bx, mir::SourceInfo::outermost(self.mir.span));\n \n             let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicCannotUnwind);\n             let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n-            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], None);\n+            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], funclet.as_ref());\n             bx.do_not_inline(llret);\n \n             bx.unreachable();\n \n-            self.double_unwind_guard = Some(llbb);\n+            self.terminate_block = Some(llbb);\n             llbb\n         })\n     }"}, {"sha": "0b4456dba30d966564abd9cb409e78adb5099c8c", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -74,7 +74,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     unreachable_block: Option<Bx::BasicBlock>,\n \n     /// Cached double unwind guarding block\n-    double_unwind_guard: Option<Bx::BasicBlock>,\n+    terminate_block: Option<Bx::BasicBlock>,\n \n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `PlaceRef` representing an alloca, but not always:\n@@ -189,7 +189,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         personality_slot: None,\n         cached_llbbs,\n         unreachable_block: None,\n-        double_unwind_guard: None,\n+        terminate_block: None,\n         cleanup_kinds,\n         landing_pads: IndexVec::from_elem(None, &mir.basic_blocks),\n         funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks.len()),"}, {"sha": "209656cdf5c5db71890b77120a2f9977c30bf95b", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -736,6 +736,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             mir::UnwindAction::Unreachable => {\n                 throw_ub_format!(\"unwinding past a stack frame that does not allow unwinding\")\n             }\n+            mir::UnwindAction::Terminate => {\n+                M::abort(self, \"panic in a function that cannot unwind\".to_owned())?;\n+            }\n         };\n         Ok(())\n     }"}, {"sha": "0eae5fe69d6f30a669f6d006a9d99cc21ceca37e", "filename": "compiler/rustc_middle/src/mir/patch.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpatch.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -14,6 +14,7 @@ pub struct MirPatch<'tcx> {\n     resume_block: Option<BasicBlock>,\n     // Only for unreachable in cleanup path.\n     unreachable_block: Option<BasicBlock>,\n+    terminate_block: Option<BasicBlock>,\n     body_span: Span,\n     next_local: usize,\n }\n@@ -28,6 +29,7 @@ impl<'tcx> MirPatch<'tcx> {\n             next_local: body.local_decls.len(),\n             resume_block: None,\n             unreachable_block: None,\n+            terminate_block: None,\n             body_span: body.span,\n         };\n "}, {"sha": "f8804f7e5acb00230a7fabf18f7d3e9d71e930c7", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -763,6 +763,10 @@ pub enum UnwindAction {\n     Continue,\n     /// Triggers undefined behavior if unwind happens.\n     Unreachable,\n+    /// Terminates the execution if unwind happens.\n+    ///\n+    /// Depending on the platform and situation this may cause a non-unwindable panic or abort.\n+    Terminate,\n     /// Cleanups to be done.\n     Cleanup(BasicBlock),\n }"}, {"sha": "dbe82a799c6fb4825d9482c29001d37319c80927", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -274,6 +274,7 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n             // Not needed or included in successors\n             None | Some(UnwindAction::Continue) | Some(UnwindAction::Cleanup(_)) => None,\n             Some(UnwindAction::Unreachable) => Some(\"unwind unreachable\"),\n+            Some(UnwindAction::Terminate) => Some(\"unwind terminate\"),\n         };\n \n         match (successor_count, unwind) {"}, {"sha": "05a723a6b6750b73095602589cd168aa1406e92c", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -469,7 +469,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         } else {\n                             Some(destination_block)\n                         },\n-                        unwind: UnwindAction::Continue,\n+                        unwind: if options.contains(InlineAsmOptions::MAY_UNWIND) {\n+                            UnwindAction::Continue\n+                        } else {\n+                            UnwindAction::Unreachable\n+                        },\n                     },\n                 );\n                 if options.contains(InlineAsmOptions::MAY_UNWIND) {"}, {"sha": "6d6b726263b8093a8171a915b109f1e1a755fa91", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -369,7 +369,7 @@ impl DropTree {\n                     let terminator = TerminatorKind::Drop {\n                         target: blocks[drop_data.1].unwrap(),\n                         // The caller will handle this if needed.\n-                        unwind: UnwindAction::Continue,\n+                        unwind: UnwindAction::Terminate,\n                         place: drop_data.0.local.into(),\n                     };\n                     cfg.terminate(block, drop_data.0.source_info, terminator);"}, {"sha": "ba51adee30849ef0020bedd095651c8d372b0c03", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -80,7 +80,7 @@ impl Unwind {\n     fn into_action(self) -> UnwindAction {\n         match self {\n             Unwind::To(bb) => UnwindAction::Cleanup(bb),\n-            Unwind::InCleanup => UnwindAction::Continue,\n+            Unwind::InCleanup => UnwindAction::Terminate,\n         }\n     }\n \n@@ -946,7 +946,7 @@ where\n             args,\n             destination: unit_temp,\n             target: Some(target),\n-            unwind: UnwindAction::Unreachable,\n+            unwind: UnwindAction::Terminate,\n             from_hir_call: false,\n             fn_span: self.source_info.span,\n         }; // FIXME(#43234)"}, {"sha": "5aed89139e2fa0a60916ea4425b6af34d11faf47", "filename": "compiler/rustc_mir_transform/src/abort_unwinding_calls.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -34,11 +34,6 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n             return;\n         }\n \n-        // This pass only runs on functions which themselves cannot unwind,\n-        // forcibly changing the body of the function to structurally provide\n-        // this guarantee by aborting on an unwind. If this function can unwind,\n-        // then there's nothing to do because it already should work correctly.\n-        //\n         // Here we test for this function itself whether its ABI allows\n         // unwinding or not.\n         let body_ty = tcx.type_of(def_id).skip_binder();\n@@ -107,26 +102,9 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n             }\n         }\n \n-        // For call instructions which need to be terminated, we insert a\n-        // singular basic block which simply terminates, and then configure the\n-        // `cleanup` attribute for all calls we found to this basic block we\n-        // insert which means that any unwinding that happens in the functions\n-        // will force an abort of the process.\n-        if !calls_to_terminate.is_empty() {\n-            let bb = BasicBlockData {\n-                statements: Vec::new(),\n-                is_cleanup: true,\n-                terminator: Some(Terminator {\n-                    source_info: SourceInfo::outermost(body.span),\n-                    kind: TerminatorKind::Abort,\n-                }),\n-            };\n-            let abort_bb = body.basic_blocks_mut().push(bb);\n-\n-            for bb in calls_to_terminate {\n-                let cleanup = body.basic_blocks_mut()[bb].terminator_mut().unwind_mut().unwrap();\n-                *cleanup = UnwindAction::Cleanup(abort_bb);\n-            }\n+        for id in calls_to_terminate {\n+            let cleanup = body.basic_blocks_mut()[id].terminator_mut().unwind_mut().unwrap();\n+            *cleanup = UnwindAction::Terminate;\n         }\n \n         for id in cleanups_to_remove {"}, {"sha": "76fdbcdddd9ee6af681e08ed0125daf43111c089", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -417,7 +417,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                                     UnwindAction::Unreachable => {\n                                         Unwind::To(self.patch.unreachable_block())\n                                     }\n-                                    UnwindAction::Terminate => Unwind::To(self.patch.terminate_block()),\n+                                    UnwindAction::Terminate => {\n+                                        Unwind::To(self.patch.terminate_block())\n+                                    }\n                                 }\n                             };\n                             elaborate_drop(\n@@ -558,7 +560,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             if let TerminatorKind::Call {\n                 destination,\n                 target: Some(_),\n-                unwind: UnwindAction::Continue,\n+                unwind: UnwindAction::Continue | UnwindAction::Unreachable | UnwindAction::Terminate,\n                 ..\n             } = data.terminator().kind\n             {"}, {"sha": "bc147d38405c8753edc4031a8c67e590106bf4e5", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -1064,6 +1064,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n                 UnwindAction::Cleanup(tgt) => tgt,\n                 UnwindAction::Continue => elaborator.patch.resume_block(),\n                 UnwindAction::Unreachable => elaborator.patch.unreachable_block(),\n+                UnwindAction::Terminate => elaborator.patch.terminate_block(),\n             })\n         };\n         elaborate_drop("}, {"sha": "b1480a524e5151db2a1027808aa3defac5d177a5", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -1017,15 +1017,15 @@ impl Integrator<'_, '_> {\n     fn map_unwind(&self, unwind: UnwindAction) -> UnwindAction {\n         if self.in_cleanup_block {\n             match unwind {\n-                UnwindAction::Cleanup(_) => {\n+                UnwindAction::Cleanup(_) | UnwindAction::Continue => {\n                     bug!(\"cleanup on cleanup block\");\n                 }\n-                UnwindAction::Continue | UnwindAction::Unreachable => return unwind,\n+                UnwindAction::Unreachable | UnwindAction::Terminate => return unwind,\n             }\n         }\n \n         match unwind {\n-            UnwindAction::Unreachable => unwind,\n+            UnwindAction::Unreachable | UnwindAction::Terminate => unwind,\n             UnwindAction::Cleanup(target) => UnwindAction::Cleanup(self.map_block(target)),\n             // Add an unwind edge to the original call's cleanup block\n             UnwindAction::Continue => self.cleanup_block,\n@@ -1141,7 +1141,10 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n                     terminator.kind = TerminatorKind::Goto { target: tgt };\n                 }\n                 UnwindAction::Continue => (),\n-                UnwindAction::Unreachable => {\n+                UnwindAction::Unreachable | UnwindAction::Terminate => {\n+                    // If the action is terminate, then we would have mapped marked\n+                    // all our call-sites as `UnwindAction::Terminate` and no cleanup\n+                    // blocks would ever be executed.\n                     terminator.kind = TerminatorKind::Unreachable;\n                 }\n             },"}, {"sha": "7dc5878e04701a056509b68c3d30f3eced5a753b", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -54,7 +54,6 @@ fn lower_slice_len_call<'tcx>(\n             args,\n             destination,\n             target: Some(bb),\n-            unwind: UnwindAction::Unreachable,\n             from_hir_call: true,\n             ..\n         } => {"}, {"sha": "05253bb65ac9e6a62241c79dfeb13e90920e8313", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a5dac3062ffc80a283943e49e2ada08f0b0eaf7/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=0a5dac3062ffc80a283943e49e2ada08f0b0eaf7", "patch": "@@ -872,6 +872,16 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             | mir::TerminatorKind::FalseUnwind { .. } => bug!(),\n         }\n \n+        if let Some(mir::UnwindAction::Terminate) = terminator.unwind() {\n+            let instance = Instance::mono(\n+                tcx,\n+                tcx.require_lang_item(LangItem::PanicCannotUnwind, Some(source)),\n+            );\n+            if should_codegen_locally(tcx, &instance) {\n+                self.output.push(create_fn_mono_item(tcx, instance, source));\n+            }\n+        }\n+\n         self.super_terminator(terminator, location);\n     }\n "}]}