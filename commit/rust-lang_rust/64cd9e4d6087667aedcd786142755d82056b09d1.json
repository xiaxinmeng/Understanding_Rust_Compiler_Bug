{"sha": "64cd9e4d6087667aedcd786142755d82056b09d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0Y2Q5ZTRkNjA4NzY2N2FlZGNkNzg2MTQyNzU1ZDgyMDU2YjA5ZDE=", "commit": {"author": {"name": "BO41", "email": "botbob@disroot.org", "date": "2019-08-29T08:06:56Z"}, "committer": {"name": "BO41", "email": "botbob@disroot.org", "date": "2019-09-03T16:56:23Z"}, "message": "Try to fix .fixed", "tree": {"sha": "b39d498044f49b4f9f5897949de0223d071e6206", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b39d498044f49b4f9f5897949de0223d071e6206"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64cd9e4d6087667aedcd786142755d82056b09d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64cd9e4d6087667aedcd786142755d82056b09d1", "html_url": "https://github.com/rust-lang/rust/commit/64cd9e4d6087667aedcd786142755d82056b09d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64cd9e4d6087667aedcd786142755d82056b09d1/comments", "author": null, "committer": null, "parents": [{"sha": "6bbf4187472bf2326de7256feda5d1fc4d0e651e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bbf4187472bf2326de7256feda5d1fc4d0e651e", "html_url": "https://github.com/rust-lang/rust/commit/6bbf4187472bf2326de7256feda5d1fc4d0e651e"}], "stats": {"total": 397, "additions": 49, "deletions": 348}, "files": [{"sha": "8272f8b8a061d3ef74c08db0cc3ddf4e6bd018bd", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/64cd9e4d6087667aedcd786142755d82056b09d1/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cd9e4d6087667aedcd786142755d82056b09d1/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=64cd9e4d6087667aedcd786142755d82056b09d1", "patch": "@@ -1022,9 +1022,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             [\"flat_map\", \"filter_map\"] => lint_filter_map_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", ..] => lint_flat_map_identity(cx, expr, arg_lists[0], method_spans[0]),\n             [\"flatten\", \"map\"] => lint_map_flatten(cx, expr, arg_lists[1]),\n-            [\"is_some\", \"find\"] => lint_search_is_some(cx, expr, \"find\", arg_lists[1], arg_lists[0]),\n-            [\"is_some\", \"position\"] => lint_search_is_some(cx, expr, \"position\", arg_lists[1], arg_lists[0]),\n-            [\"is_some\", \"rposition\"] => lint_search_is_some(cx, expr, \"rposition\", arg_lists[1], arg_lists[0]),\n+            [\"is_some\", \"find\"] => lint_search_is_some(cx, expr, \"find\", arg_lists[1], arg_lists[0], method_spans[1]),\n+            [\"is_some\", \"position\"] => {\n+                lint_search_is_some(cx, expr, \"position\", arg_lists[1], arg_lists[0], method_spans[1])\n+            },\n+            [\"is_some\", \"rposition\"] => {\n+                lint_search_is_some(cx, expr, \"rposition\", arg_lists[1], arg_lists[0], method_spans[1])\n+            },\n             [\"extend\", ..] => lint_extend(cx, expr, arg_lists[0]),\n             [\"as_ptr\", \"unwrap\"] | [\"as_ptr\", \"expect\"] => {\n                 lint_cstring_as_ptr(cx, expr, &arg_lists[1][0], &arg_lists[0][0])\n@@ -2381,6 +2385,7 @@ fn lint_search_is_some<'a, 'tcx>(\n     search_method: &str,\n     search_args: &'tcx [hir::Expr],\n     is_some_args: &'tcx [hir::Expr],\n+    method_span: Span,\n ) {\n     // lint if caller of search is an Iterator\n     if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n@@ -2398,15 +2403,13 @@ fn lint_search_is_some<'a, 'tcx>(\n                 if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].node;\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 if let Some(closure_arg) = closure_body.params.get(0);\n-                if let hir::PatKind::Ref(..) = closure_arg.pat.node;\n                 then {\n-                    match &closure_arg.pat.node {\n-                        hir::PatKind::Ref(..) => Some(search_snippet.replacen('&', \"\", 1)),\n-                        hir::PatKind::Binding(_, _, expr, _) => {\n-                            let closure_arg_snip = snippet(cx, expr.span, \"..\");\n-                            Some(search_snippet.replace(&format!(\"*{}\", closure_arg_snip), &closure_arg_snip))\n-                        }\n-                        _ => None,\n+                    if let hir::PatKind::Ref(..) = closure_arg.pat.node {\n+                        Some(search_snippet.replacen('&', \"\", 1))\n+                    } else if let Some(name) = get_arg_name(&closure_arg.pat) {\n+                        Some(search_snippet.replace(&format!(\"*{}\", name), &name.as_str()))\n+                    } else {\n+                        None\n                     }\n                 } else {\n                     None\n@@ -2416,14 +2419,12 @@ fn lint_search_is_some<'a, 'tcx>(\n             span_lint_and_sugg(\n                 cx,\n                 SEARCH_IS_SOME,\n-                expr.span,\n+                method_span.with_hi(expr.span.hi()),\n                 &msg,\n                 \"try this\",\n                 format!(\n                     \"any({})\",\n-                    any_search_snippet\n-                        .as_ref()\n-                        .map_or(&*search_snippet, String::as_str)\n+                    any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n                 ),\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "2bb09d8e090977211a0c1e35355d660cba13a6e8", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64cd9e4d6087667aedcd786142755d82056b09d1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cd9e4d6087667aedcd786142755d82056b09d1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=64cd9e4d6087667aedcd786142755d82056b09d1", "patch": "@@ -338,7 +338,7 @@ pub fn resolve_node(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> Res {\n }\n \n /// Returns the method names and argument list of nested method call expressions that make up\n-/// `expr`.\n+/// `expr`. method/span lists are sorted with the most recent call first.\n pub fn method_calls(expr: &Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&[Expr]>, Vec<Span>) {\n     let mut method_names = Vec::with_capacity(max_depth);\n     let mut arg_lists = Vec::with_capacity(max_depth);"}, {"sha": "f86da92bae32003f0162799da3233803af053b37", "filename": "tests/ui/methods.fixed", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/6bbf4187472bf2326de7256feda5d1fc4d0e651e/tests%2Fui%2Fmethods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6bbf4187472bf2326de7256feda5d1fc4d0e651e/tests%2Fui%2Fmethods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.fixed?ref=6bbf4187472bf2326de7256feda5d1fc4d0e651e", "patch": "@@ -1,306 +0,0 @@\n-// aux-build:option_helpers.rs\n-// compile-flags: --edition 2018\n-// run-rustfix\n-\n-#![warn(clippy::all, clippy::pedantic, clippy::option_unwrap_used)]\n-#![allow(\n-    clippy::blacklisted_name,\n-    unused,\n-    clippy::print_stdout,\n-    clippy::non_ascii_literal,\n-    clippy::new_without_default,\n-    clippy::missing_docs_in_private_items,\n-    clippy::needless_pass_by_value,\n-    clippy::default_trait_access,\n-    clippy::use_self,\n-    clippy::useless_format,\n-    clippy::wrong_self_convention\n-)]\n-\n-#[macro_use]\n-extern crate option_helpers;\n-\n-use std::collections::BTreeMap;\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n-use std::collections::VecDeque;\n-use std::iter::FromIterator;\n-use std::ops::Mul;\n-use std::rc::{self, Rc};\n-use std::sync::{self, Arc};\n-\n-use option_helpers::IteratorFalsePositives;\n-\n-pub struct T;\n-\n-impl T {\n-    pub fn add(self, other: T) -> T {\n-        self\n-    }\n-\n-    // no error, not public interface\n-    pub(crate) fn drop(&mut self) {}\n-\n-    // no error, private function\n-    fn neg(self) -> Self {\n-        self\n-    }\n-\n-    // no error, private function\n-    fn eq(&self, other: T) -> bool {\n-        true\n-    }\n-\n-    // No error; self is a ref.\n-    fn sub(&self, other: T) -> &T {\n-        self\n-    }\n-\n-    // No error; different number of arguments.\n-    fn div(self) -> T {\n-        self\n-    }\n-\n-    // No error; wrong return type.\n-    fn rem(self, other: T) {}\n-\n-    // Fine\n-    fn into_u32(self) -> u32 {\n-        0\n-    }\n-\n-    fn into_u16(&self) -> u16 {\n-        0\n-    }\n-\n-    fn to_something(self) -> u32 {\n-        0\n-    }\n-\n-    fn new(self) -> Self {\n-        unimplemented!();\n-    }\n-}\n-\n-struct Lt<'a> {\n-    foo: &'a u32,\n-}\n-\n-impl<'a> Lt<'a> {\n-    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n-    #[allow(clippy::needless_lifetimes)]\n-    pub fn new<'b>(s: &'b str) -> Lt<'b> {\n-        unimplemented!()\n-    }\n-}\n-\n-struct Lt2<'a> {\n-    foo: &'a u32,\n-}\n-\n-impl<'a> Lt2<'a> {\n-    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n-    pub fn new(s: &str) -> Lt2 {\n-        unimplemented!()\n-    }\n-}\n-\n-struct Lt3<'a> {\n-    foo: &'a u32,\n-}\n-\n-impl<'a> Lt3<'a> {\n-    // The lifetime is different, but that\u2019s irrelevant; see issue #734.\n-    pub fn new() -> Lt3<'static> {\n-        unimplemented!()\n-    }\n-}\n-\n-#[derive(Clone, Copy)]\n-struct U;\n-\n-impl U {\n-    fn new() -> Self {\n-        U\n-    }\n-    // Ok because `U` is `Copy`.\n-    fn to_something(self) -> u32 {\n-        0\n-    }\n-}\n-\n-struct V<T> {\n-    _dummy: T,\n-}\n-\n-impl<T> V<T> {\n-    fn new() -> Option<V<T>> {\n-        None\n-    }\n-}\n-\n-struct AsyncNew;\n-\n-impl AsyncNew {\n-    async fn new() -> Option<Self> {\n-        None\n-    }\n-}\n-\n-struct BadNew;\n-\n-impl BadNew {\n-    fn new() -> i32 {\n-        0\n-    }\n-}\n-\n-impl Mul<T> for T {\n-    type Output = T;\n-    // No error, obviously.\n-    fn mul(self, other: T) -> T {\n-        self\n-    }\n-}\n-\n-/// Checks implementation of the following lints:\n-/// * `OPTION_MAP_UNWRAP_OR`\n-/// * `OPTION_MAP_UNWRAP_OR_ELSE`\n-#[rustfmt::skip]\n-fn option_methods() {\n-    let opt = Some(1);\n-\n-    // Check `OPTION_MAP_UNWRAP_OR`.\n-    // Single line case.\n-    let _ = opt.map(|x| x + 1)\n-                // Should lint even though this call is on a separate line.\n-               .unwrap_or(0);\n-    // Multi-line cases.\n-    let _ = opt.map(|x| {\n-                        x + 1\n-                    }\n-              ).unwrap_or(0);\n-    let _ = opt.map(|x| x + 1)\n-               .unwrap_or({\n-                    0\n-                });\n-    // Single line `map(f).unwrap_or(None)` case.\n-    let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n-    // Multi-line `map(f).unwrap_or(None)` cases.\n-    let _ = opt.map(|x| {\n-        Some(x + 1)\n-    }\n-    ).unwrap_or(None);\n-    let _ = opt\n-        .map(|x| Some(x + 1))\n-        .unwrap_or(None);\n-    // macro case\n-    let _ = opt_map!(opt, |x| x + 1).unwrap_or(0); // should not lint\n-\n-    // Should not lint if not copyable\n-    let id: String = \"identifier\".to_string();\n-    let _ = Some(\"prefix\").map(|p| format!(\"{}.{}\", p, id)).unwrap_or(id);\n-    // ...but DO lint if the `unwrap_or` argument is not used in the `map`\n-    let id: String = \"identifier\".to_string();\n-    let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n-\n-    // Check OPTION_MAP_UNWRAP_OR_ELSE\n-    // single line case\n-    let _ = opt.map(|x| x + 1)\n-                // Should lint even though this call is on a separate line.\n-               .unwrap_or_else(|| 0);\n-    // Multi-line cases.\n-    let _ = opt.map(|x| {\n-                        x + 1\n-                    }\n-              ).unwrap_or_else(|| 0);\n-    let _ = opt.map(|x| x + 1)\n-               .unwrap_or_else(||\n-                    0\n-                );\n-    // Macro case.\n-    // Should not lint.\n-    let _ = opt_map!(opt, |x| x + 1).unwrap_or_else(|| 0);\n-\n-    // Issue #4144\n-    {\n-        let mut frequencies = HashMap::new();\n-        let word = \"foo\";\n-\n-        frequencies\n-            .get_mut(word)\n-            .map(|count| {\n-                *count += 1;\n-            })\n-            .unwrap_or_else(|| {\n-                frequencies.insert(word.to_owned(), 1);\n-            });\n-    }\n-}\n-\n-/// Checks implementation of `FILTER_NEXT` lint.\n-#[rustfmt::skip]\n-fn filter_next() {\n-    let v = vec![3, 2, 1, 0, -1, -2, -3];\n-\n-    // Single-line case.\n-    let _ = v.iter().filter(|&x| *x < 0).next();\n-\n-    // Multi-line case.\n-    let _ = v.iter().filter(|&x| {\n-                                *x < 0\n-                            }\n-                   ).next();\n-\n-    // Check that hat we don't lint if the caller is not an `Iterator`.\n-    let foo = IteratorFalsePositives { foo: 0 };\n-    let _ = foo.filter().next();\n-}\n-\n-/// Checks implementation of `SEARCH_IS_SOME` lint.\n-#[rustfmt::skip]\n-fn search_is_some() {\n-    let v = vec![3, 2, 1, 0, -1, -2, -3];\n-    let y = &&42;\n-\n-    // Check `find().is_some()`, single-line case.\n-    let _ = any(|x| *x < 0);\n-    let _ = any(|x| **y == x); // one dereference less\n-    let _ = any(|x| x == 0);\n-\n-    // Check `find().is_some()`, multi-line case.\n-    let _ = v.iter().find(|&x| {\n-                              *x < 0\n-                          }\n-                   ).is_some();\n-\n-    // Check `position().is_some()`, single-line case.\n-    let _ = any(|&x| x < 0);\n-\n-    // Check `position().is_some()`, multi-line case.\n-    let _ = v.iter().position(|&x| {\n-                                  x < 0\n-                              }\n-                   ).is_some();\n-\n-    // Check `rposition().is_some()`, single-line case.\n-    let _ = any(|&x| x < 0);\n-\n-    // Check `rposition().is_some()`, multi-line case.\n-    let _ = v.iter().rposition(|&x| {\n-                                   x < 0\n-                               }\n-                   ).is_some();\n-\n-    // Check that we don't lint if the caller is not an `Iterator`.\n-    let foo = IteratorFalsePositives { foo: 0 };\n-    let _ = foo.find().is_some();\n-    let _ = foo.position().is_some();\n-    let _ = foo.rposition().is_some();\n-}\n-\n-#[allow(clippy::similar_names)]\n-fn main() {\n-    let opt = Some(0);\n-    let _ = opt.unwrap();\n-}"}, {"sha": "8f53b8cecbd311341ff92d359993e17e2df370c9", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64cd9e4d6087667aedcd786142755d82056b09d1/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64cd9e4d6087667aedcd786142755d82056b09d1/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=64cd9e4d6087667aedcd786142755d82056b09d1", "patch": "@@ -1,6 +1,5 @@\n // aux-build:option_helpers.rs\n // compile-flags: --edition 2018\n-// run-rustfix\n \n #![warn(clippy::all, clippy::pedantic, clippy::option_unwrap_used)]\n #![allow(\n@@ -267,6 +266,7 @@ fn search_is_some() {\n     let _ = v.iter().find(|&x| *x < 0).is_some();\n     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n     let _ = (0..1).find(|x| *x == 0).is_some();\n+    let _ = v.iter().find(|x| **x == 0).is_some();\n \n     // Check `find().is_some()`, multi-line case.\n     let _ = v.iter().find(|&x| {"}, {"sha": "b30371fa541f84cb384e67290972962b64e6c9e6", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/64cd9e4d6087667aedcd786142755d82056b09d1/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64cd9e4d6087667aedcd786142755d82056b09d1/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=64cd9e4d6087667aedcd786142755d82056b09d1", "patch": "@@ -1,5 +1,5 @@\n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:37:5\n+  --> $DIR/methods.rs:36:5\n    |\n LL | /     pub fn add(self, other: T) -> T {\n LL | |         self\n@@ -9,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n \n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:153:5\n+  --> $DIR/methods.rs:152:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -19,7 +19,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:175:13\n+  --> $DIR/methods.rs:174:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -31,7 +31,7 @@ LL | |                .unwrap_or(0);\n    = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:179:13\n+  --> $DIR/methods.rs:178:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -41,7 +41,7 @@ LL | |               ).unwrap_or(0);\n    | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:183:13\n+  --> $DIR/methods.rs:182:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -51,15 +51,15 @@ LL | |                 });\n    | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:188:13\n+  --> $DIR/methods.rs:187:13\n    |\n LL |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:190:13\n+  --> $DIR/methods.rs:189:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL | |     ).unwrap_or(None);\n    | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-  --> $DIR/methods.rs:194:13\n+  --> $DIR/methods.rs:193:13\n    |\n LL |       let _ = opt\n    |  _____________^\n@@ -80,15 +80,15 @@ LL | |         .unwrap_or(None);\n    = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-  --> $DIR/methods.rs:205:13\n+  --> $DIR/methods.rs:204:13\n    |\n LL |     let _ = Some(\"prefix\").map(|p| format!(\"{}.\", p)).unwrap_or(id);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: replace `map(|p| format!(\"{}.\", p)).unwrap_or(id)` with `map_or(id, |p| format!(\"{}.\", p))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:209:13\n+  --> $DIR/methods.rs:208:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -100,7 +100,7 @@ LL | |                .unwrap_or_else(|| 0);\n    = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:213:13\n+  --> $DIR/methods.rs:212:13\n    |\n LL |       let _ = opt.map(|x| {\n    |  _____________^\n@@ -110,7 +110,7 @@ LL | |               ).unwrap_or_else(|| 0);\n    | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-  --> $DIR/methods.rs:217:13\n+  --> $DIR/methods.rs:216:13\n    |\n LL |       let _ = opt.map(|x| x + 1)\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |                 );\n    | |_________________^\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:247:13\n+  --> $DIR/methods.rs:246:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -129,7 +129,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:250:13\n+  --> $DIR/methods.rs:249:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -139,24 +139,30 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:267:13\n+  --> $DIR/methods.rs:266:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:268:13\n+  --> $DIR/methods.rs:267:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:269:13\n+  --> $DIR/methods.rs:268:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n+  --> $DIR/methods.rs:269:22\n+   |\n+LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n   --> $DIR/methods.rs:272:13\n@@ -169,10 +175,10 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:278:13\n+  --> $DIR/methods.rs:278:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n   --> $DIR/methods.rs:281:13\n@@ -185,10 +191,10 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:287:13\n+  --> $DIR/methods.rs:287:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n   --> $DIR/methods.rs:290:13\n@@ -208,5 +214,5 @@ LL |     let _ = opt.unwrap();\n    |\n    = note: `-D clippy::option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 24 previous errors\n "}]}