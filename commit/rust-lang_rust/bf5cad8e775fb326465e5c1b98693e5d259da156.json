{"sha": "bf5cad8e775fb326465e5c1b98693e5d259da156", "node_id": "C_kwDOAAsO6NoAKGJmNWNhZDhlNzc1ZmIzMjY0NjVlNWMxYjk4NjkzZTVkMjU5ZGExNTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-01T17:51:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-01T17:51:47Z"}, "message": "Auto merge of #13326 - Veykril:proc-macro-srv-config, r=Veykril\n\nDo not use the sysroot proc-macro server when a server path is given explicitly", "tree": {"sha": "f02e83e0d88c98c5e532d93f0bd7ad8f4364e9d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f02e83e0d88c98c5e532d93f0bd7ad8f4364e9d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf5cad8e775fb326465e5c1b98693e5d259da156", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf5cad8e775fb326465e5c1b98693e5d259da156", "html_url": "https://github.com/rust-lang/rust/commit/bf5cad8e775fb326465e5c1b98693e5d259da156", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf5cad8e775fb326465e5c1b98693e5d259da156/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f88293f777678414822be9b4ad3491694cd03337", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88293f777678414822be9b4ad3491694cd03337", "html_url": "https://github.com/rust-lang/rust/commit/f88293f777678414822be9b4ad3491694cd03337"}, {"sha": "26cf250cccf620f02a2df2532bcb99ed503b3f8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/26cf250cccf620f02a2df2532bcb99ed503b3f8a", "html_url": "https://github.com/rust-lang/rust/commit/26cf250cccf620f02a2df2532bcb99ed503b3f8a"}], "stats": {"total": 77, "additions": 44, "deletions": 33}, "files": [{"sha": "dfef6f014ca5c1a9e4dba340c1c46acd4bd983a5", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf5cad8e775fb326465e5c1b98693e5d259da156/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf5cad8e775fb326465e5c1b98693e5d259da156/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=bf5cad8e775fb326465e5c1b98693e5d259da156", "patch": "@@ -7,7 +7,7 @@\n //! configure the server itself, feature flags are passed into analysis, and\n //! tweak things like automatic insertion of `()` in completions.\n \n-use std::{ffi::OsString, fmt, iter, path::PathBuf};\n+use std::{fmt, iter, path::PathBuf};\n \n use flycheck::FlycheckConfig;\n use ide::{\n@@ -977,15 +977,17 @@ impl Config {\n         self.data.lru_capacity\n     }\n \n-    pub fn proc_macro_srv(&self) -> Option<(AbsPathBuf, Vec<OsString>)> {\n+    pub fn proc_macro_srv(&self) -> Option<(AbsPathBuf, /* is path explicitly set */ bool)> {\n         if !self.data.procMacro_enable {\n             return None;\n         }\n-        let path = match &self.data.procMacro_server {\n-            Some(it) => self.root_path.join(it),\n-            None => AbsPathBuf::assert(std::env::current_exe().ok()?),\n-        };\n-        Some((path, vec![\"proc-macro\".into()]))\n+        Some(match &self.data.procMacro_server {\n+            Some(it) => (\n+                AbsPathBuf::try_from(it.clone()).unwrap_or_else(|path| self.root_path.join(path)),\n+                true,\n+            ),\n+            None => (AbsPathBuf::assert(std::env::current_exe().ok()?), false),\n+        })\n     }\n \n     pub fn dummy_replacements(&self) -> &FxHashMap<Box<str>, Box<[Box<str>]>> {"}, {"sha": "f8734893944624e169bc8969da9759707945b9ad", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bf5cad8e775fb326465e5c1b98693e5d259da156/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf5cad8e775fb326465e5c1b98693e5d259da156/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=bf5cad8e775fb326465e5c1b98693e5d259da156", "patch": "@@ -306,41 +306,50 @@ impl GlobalState {\n             format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n \n         if self.proc_macro_clients.is_empty() {\n-            if let Some((path, args)) = self.config.proc_macro_srv() {\n+            if let Some((path, path_manually_set)) = self.config.proc_macro_srv() {\n                 tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n                     .workspaces\n                     .iter()\n                     .map(|ws| {\n-                        let mut args = args.clone();\n-                        let mut path = path.clone();\n-\n-                        if let ProjectWorkspace::Cargo { sysroot, .. }\n-                        | ProjectWorkspace::Json { sysroot, .. } = ws\n-                        {\n-                            tracing::debug!(\"Found a cargo workspace...\");\n-                            if let Some(sysroot) = sysroot.as_ref() {\n-                                tracing::debug!(\"Found a cargo workspace with a sysroot...\");\n-                                let server_path =\n-                                    sysroot.root().join(\"libexec\").join(&standalone_server_name);\n-                                if std::fs::metadata(&server_path).is_ok() {\n-                                    tracing::debug!(\n-                                        \"And the server exists at {}\",\n-                                        server_path.display()\n-                                    );\n-                                    path = server_path;\n-                                    args = vec![];\n-                                } else {\n-                                    tracing::debug!(\n-                                        \"And the server does not exist at {}\",\n-                                        server_path.display()\n-                                    );\n+                        let (path, args) = if path_manually_set {\n+                            tracing::debug!(\n+                                \"Pro-macro server path explicitly set: {}\",\n+                                path.display()\n+                            );\n+                            (path.clone(), vec![])\n+                        } else {\n+                            let mut sysroot_server = None;\n+                            if let ProjectWorkspace::Cargo { sysroot, .. }\n+                            | ProjectWorkspace::Json { sysroot, .. } = ws\n+                            {\n+                                if let Some(sysroot) = sysroot.as_ref() {\n+                                    let server_path = sysroot\n+                                        .root()\n+                                        .join(\"libexec\")\n+                                        .join(&standalone_server_name);\n+                                    if std::fs::metadata(&server_path).is_ok() {\n+                                        tracing::debug!(\n+                                            \"Sysroot proc-macro server exists at {}\",\n+                                            server_path.display()\n+                                        );\n+                                        sysroot_server = Some(server_path);\n+                                    } else {\n+                                        tracing::debug!(\n+                                            \"Sysroot proc-macro server does not exist at {}\",\n+                                            server_path.display()\n+                                        );\n+                                    }\n                                 }\n                             }\n-                        }\n+                            sysroot_server.map_or_else(\n+                                || (path.clone(), vec![\"proc-macro\".to_owned()]),\n+                                |path| (path, vec![]),\n+                            )\n+                        };\n \n                         tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n-                        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|err| {\n+                        ProcMacroServer::spawn(path.clone(), args).map_err(|err| {\n                             let error = format!(\n                                 \"Failed to run proc-macro server from path {}, error: {:?}\",\n                                 path.display(),"}]}