{"sha": "12d553216663b80a6c10921ab52558253ba56920", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZDU1MzIxNjY2M2I4MGE2YzEwOTIxYWI1MjU1ODI1M2JhNTY5MjA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-11T14:47:24Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-12T22:38:24Z"}, "message": "Use switches rather than chained conditionals to compile alt matches\n\nThis also moves the alt-related trans code into its own file.\n\nCloses #467", "tree": {"sha": "1bc59190d606a9cfe483458c42a7ad2e4e5984ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bc59190d606a9cfe483458c42a7ad2e4e5984ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12d553216663b80a6c10921ab52558253ba56920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12d553216663b80a6c10921ab52558253ba56920", "html_url": "https://github.com/rust-lang/rust/commit/12d553216663b80a6c10921ab52558253ba56920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12d553216663b80a6c10921ab52558253ba56920/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ea449e2f6eea837137771fa486a2e3f69cc6fd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea449e2f6eea837137771fa486a2e3f69cc6fd0", "html_url": "https://github.com/rust-lang/rust/commit/1ea449e2f6eea837137771fa486a2e3f69cc6fd0"}], "stats": {"total": 652, "additions": 433, "deletions": 219}, "files": [{"sha": "9865c6209f5df6a7d83e4055e4d53acf281c1d72", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 219, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/12d553216663b80a6c10921ab52558253ba56920/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d553216663b80a6c10921ab52558253ba56920/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=12d553216663b80a6c10921ab52558253ba56920", "patch": "@@ -32,7 +32,6 @@ import back::link;\n import back::x86;\n import back::abi;\n import back::upcall;\n-import middle::ty::pat_ty;\n import syntax::visit;\n import visit::vt;\n import util::common;\n@@ -3370,7 +3369,7 @@ fn move_val_if_temp(@block_ctxt cx, copy_action action, ValueRef dst,\n     }\n }\n \n-fn trans_lit(&@crate_ctxt cx, &ast::lit lit, ast::node_id id) -> ValueRef {\n+fn trans_lit(&@crate_ctxt cx, &ast::lit lit) -> ValueRef {\n     alt (lit.node) {\n         case (ast::lit_int(?i)) { ret C_int(i); }\n         case (ast::lit_uint(?u)) { ret C_int(u as int); }\n@@ -4742,219 +4741,6 @@ fn trans_do_while(&@block_ctxt cx, &ast::block body, &@ast::expr cond) ->\n     ret rslt(next_cx, body_res.val);\n }\n \n-\n-// Pattern matching translation\n-fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n-                   &@block_ctxt next_cx) -> result {\n-    alt (pat.node) {\n-        case (ast::pat_wild) { ret rslt(cx, llval); }\n-        case (ast::pat_bind(_)) { ret rslt(cx, llval); }\n-        case (ast::pat_lit(?lt)) {\n-            auto lllit = trans_lit(cx.fcx.lcx.ccx, *lt, pat.id);\n-            auto lltype = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, pat.id);\n-            auto lleq = trans_compare(cx, ast::eq, lltype, llval, lllit);\n-            auto matched_cx = new_sub_block_ctxt(lleq.bcx, \"matched_cx\");\n-            lleq.bcx.build.CondBr(lleq.val, matched_cx.llbb, next_cx.llbb);\n-            ret rslt(matched_cx, llval);\n-        }\n-        case (ast::pat_tag(?ident, ?subpats)) {\n-            auto vdef;\n-            alt (cx.fcx.lcx.ccx.tcx.def_map.find(pat.id)) {\n-                case (some(?x)) { vdef = ast::variant_def_ids(x); }\n-                case (_) {\n-                    cx.fcx.lcx.ccx.sess.span_fatal(pat.span,\n-                                             \"trans_pat_match: unbound var\");\n-                }\n-            }\n-\n-            auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0);\n-            auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n-            auto llblobptr = llval;\n-\n-            if (std::ivec::len(variants) == 1u) {\n-                cx.build.Br(matched_cx.llbb);\n-            } else {\n-                auto lltagptr =\n-                    cx.build.PointerCast(llval,\n-                                         T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n-                auto lldiscrimptr = cx.build.GEP(lltagptr,\n-                                                 ~[C_int(0), C_int(0)]);\n-                auto lldiscrim = cx.build.Load(lldiscrimptr);\n-                auto variant_tag = 0;\n-                auto i = 0;\n-                for (ty::variant_info v in variants) {\n-                    auto this_variant_id = v.id;\n-                    if (vdef._1._0 == this_variant_id._0 &&\n-                        vdef._1._1 == this_variant_id._1) {\n-                        variant_tag = i;\n-                    }\n-                    i += 1;\n-                }\n-                auto lleq =\n-                    cx.build.ICmp(lib::llvm::LLVMIntEQ, lldiscrim,\n-                                  C_int(variant_tag));\n-                cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n-                if (std::ivec::len(subpats) > 0u) {\n-                    llblobptr =\n-                        matched_cx.build.GEP(lltagptr, ~[C_int(0), C_int(1)]);\n-                }\n-            }\n-\n-            auto ty_params = ty::node_id_to_type_params\n-                (cx.fcx.lcx.ccx.tcx, pat.id);\n-            if (std::ivec::len(subpats) > 0u) {\n-                auto i = 0;\n-                for (@ast::pat subpat in subpats) {\n-                    auto rslt =\n-                        GEP_tag(matched_cx, llblobptr, vdef._0, vdef._1,\n-                                ty_params, i);\n-                    auto llsubvalptr = rslt.val;\n-                    matched_cx = rslt.bcx;\n-                    auto llsubval =\n-                        load_if_immediate(matched_cx, llsubvalptr,\n-                                          pat_ty(cx.fcx.lcx.ccx.tcx, subpat));\n-                    auto subpat_res =\n-                        trans_pat_match(matched_cx, subpat, llsubval,\n-                                        next_cx);\n-                    matched_cx = subpat_res.bcx;\n-                    i += 1;\n-                }\n-            }\n-            ret rslt(matched_cx, llval);\n-        }\n-        case (ast::pat_rec(?field_pats, _)) {\n-            auto bcx = cx;\n-            auto ccx = cx.fcx.lcx.ccx;\n-            auto rec_ty = pat_ty(ccx.tcx, pat);\n-            auto fields = alt (ty::struct(ccx.tcx, rec_ty)) {\n-                ty::ty_rec(?fields) { fields }\n-            };\n-            for (ast::field_pat f in field_pats) {\n-                let uint ix = ty::field_idx(ccx.sess, f.pat.span,\n-                                            f.ident, fields);\n-                auto r = GEP_tup_like(bcx, rec_ty, llval, ~[0, ix as int]);\n-                auto v = load_if_immediate(r.bcx, r.val,\n-                                           pat_ty(ccx.tcx, f.pat));\n-                bcx = trans_pat_match(r.bcx, f.pat, v, next_cx).bcx;\n-            }\n-            ret rslt(bcx, llval);\n-        }\n-    }\n-}\n-\n-type bind_map = hashmap[ast::ident, result];\n-\n-fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n-                     bool is_mem, &bind_map bound) -> result {\n-    alt (pat.node) {\n-        case (ast::pat_wild) { ret rslt(cx, llval); }\n-        case (ast::pat_lit(_)) { ret rslt(cx, llval); }\n-        case (ast::pat_bind(?name)) {\n-            auto val = llval;\n-            if (!is_mem) {\n-                val = spill_if_immediate\n-                    (cx, llval, node_id_type(cx.fcx.lcx.ccx, pat.id));\n-            }\n-            auto r = rslt(cx, val);\n-            bound.insert(name, r);\n-            ret r;\n-        }\n-        case (ast::pat_tag(_, ?subpats)) {\n-            if (std::ivec::len[@ast::pat](subpats) == 0u) {\n-                ret rslt(cx, llval);\n-            }\n-\n-            // Get the appropriate variant for this tag.\n-            auto vdef;\n-            alt (cx.fcx.lcx.ccx.tcx.def_map.find(pat.id)) {\n-                case (some(?x)) { vdef = ast::variant_def_ids(x); }\n-                case (_) { cx.fcx.lcx.ccx.sess.span_fatal(pat.span,\n-                      \"trans_pat_binding: internal error, unbound var\"); }\n-            }\n-            auto llblobptr = llval;\n-            if (std::ivec::len(ty::tag_variants(cx.fcx.lcx.ccx.tcx, vdef._0))\n-                    != 1u) {\n-                auto lltagptr = cx.build.PointerCast\n-                    (llval, T_opaque_tag_ptr(cx.fcx.lcx.ccx.tn));\n-                llblobptr = cx.build.GEP(lltagptr, ~[C_int(0), C_int(1)]);\n-            }\n-\n-            auto ty_param_substs =\n-                ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, pat.id);\n-\n-            auto this_cx = cx;\n-            auto i = 0;\n-            for (@ast::pat subpat in subpats) {\n-                auto rslt =\n-                    GEP_tag(this_cx, llblobptr, vdef._0, vdef._1,\n-                            ty_param_substs, i);\n-                this_cx = rslt.bcx;\n-                auto subpat_res =\n-                    trans_pat_binding(this_cx, subpat, rslt.val, true, bound);\n-                this_cx = subpat_res.bcx;\n-                i += 1;\n-            }\n-            ret rslt(this_cx, llval);\n-        }\n-        case (ast::pat_rec(?field_pats, _)) {\n-            auto bcx = cx;\n-            auto ccx = cx.fcx.lcx.ccx;\n-            auto rec_ty = pat_ty(ccx.tcx, pat);\n-            auto fields = alt (ty::struct(ccx.tcx, rec_ty)) {\n-                ty::ty_rec(?fields) { fields }\n-            };\n-            for (ast::field_pat f in field_pats) {\n-                let uint ix = ty::field_idx(ccx.sess, f.pat.span,\n-                                            f.ident, fields);\n-                auto r = GEP_tup_like(bcx, rec_ty, llval, ~[0, ix as int]);\n-                bcx = trans_pat_binding(bcx, f.pat, r.val, true, bound).bcx;\n-            }\n-            ret rslt(bcx, llval);\n-        }\n-    }\n-}\n-\n-fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &ast::arm[] arms,\n-             ast::node_id id, &out_method output) -> result {\n-    auto expr_res = trans_expr(cx, expr);\n-    auto this_cx = expr_res.bcx;\n-    let result[] arm_results = ~[];\n-    for (ast::arm arm in arms) {\n-        auto bind_maps = ~[];\n-        auto block_cx = new_scope_block_ctxt(expr_res.bcx, \"case block\");\n-        for (@ast::pat pat in arm.pats) {\n-            auto next_cx = new_sub_block_ctxt(expr_res.bcx, \"next\");\n-            auto match_res =\n-                trans_pat_match(this_cx, pat, expr_res.val, next_cx);\n-            auto bind_map = new_str_hash[result]();\n-            auto binding_res = trans_pat_binding\n-                (match_res.bcx, pat, expr_res.val, false, bind_map);\n-            bind_maps += ~[bind_map];\n-            binding_res.bcx.build.Br(block_cx.llbb);\n-            this_cx = next_cx;\n-        }\n-        // Go over the names and node_ids of the bound variables, add a Phi\n-        // node for each and register the bindings.\n-        for each (@tup(ast::ident, ast::node_id) item in\n-                  ast::pat_id_map(arm.pats.(0)).items()) {\n-            auto vals = ~[]; auto llbbs = ~[];\n-            for (bind_map map in bind_maps) {\n-                auto rslt = map.get(item._0);\n-                vals += ~[rslt.val];\n-                llbbs += ~[rslt.bcx.llbb];\n-            }\n-            auto phi = block_cx.build.Phi(val_ty(vals.(0)), vals, llbbs);\n-            block_cx.fcx.lllocals.insert(item._1, phi);\n-        }\n-        auto block_res = trans_block(block_cx, arm.block, output);\n-        arm_results += ~[block_res];\n-    }\n-    auto default_cx = this_cx;\n-    trans_fail(default_cx, some[span](expr.span),\n-               \"non-exhaustive match failure\");\n-    ret rslt(join_branches(cx, arm_results), C_nil());\n-}\n-\n type generic_info =\n     rec(ty::t item_type,\n         (option::t[@tydesc_info])[] static_tis,\n@@ -6224,10 +6010,9 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n    result {\n     // FIXME Fill in cx.sp\n-\n     alt (e.node) {\n         case (ast::expr_lit(?lit)) {\n-            ret rslt(cx, trans_lit(cx.fcx.lcx.ccx, *lit, e.id));\n+            ret rslt(cx, trans_lit(cx.fcx.lcx.ccx, *lit));\n         }\n         case (ast::expr_unary(?op, ?x)) {\n             if (op != ast::deref) { ret trans_unary(cx, op, x, e.id); }\n@@ -6259,7 +6044,8 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             ret trans_do_while(cx, body, cond);\n         }\n         case (ast::expr_alt(?expr, ?arms)) {\n-            ret with_out_method(bind trans_alt(cx, expr, arms, e.id, _),\n+            ret with_out_method(bind trans_alt::trans_alt(cx, expr,\n+                                                          arms, e.id, _),\n                                 cx, e.id, output);\n         }\n         case (ast::expr_fn(?f)) {\n@@ -8692,7 +8478,7 @@ fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n // that does so later on?\n fn trans_const_expr(&@crate_ctxt cx, @ast::expr e) -> ValueRef {\n     alt (e.node) {\n-        case (ast::expr_lit(?lit)) { ret trans_lit(cx, *lit, e.id); }\n+        case (ast::expr_lit(?lit)) { ret trans_lit(cx, *lit); }\n         case (_) {\n             cx.sess.span_unimpl(e.span, \"consts that's not a plain literal\");\n         }"}, {"sha": "53bc5866d5ff6be3b1e0f5812f5d5c85e178935d", "filename": "src/comp/middle/trans_alt.rs", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/12d553216663b80a6c10921ab52558253ba56920/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d553216663b80a6c10921ab52558253ba56920/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=12d553216663b80a6c10921ab52558253ba56920", "patch": "@@ -0,0 +1,426 @@\n+import std::str;\n+import std::ivec;\n+import std::option;\n+import option::some;\n+import option::none;\n+import std::map::hashmap;\n+\n+import lib::llvm::llvm;\n+import lib::llvm::llvm::ValueRef;\n+import lib::llvm::llvm::TypeRef;\n+import lib::llvm::llvm::BasicBlockRef;\n+import trans::result;\n+import trans::rslt;\n+import trans::crate_ctxt;\n+import trans::block_ctxt;\n+import trans::new_sub_block_ctxt;\n+import trans::new_scope_block_ctxt;\n+import trans::load_if_immediate;\n+import trans::C_int;\n+import trans::C_uint;\n+import trans::C_nil;\n+import trans::val_ty;\n+import ty::pat_ty;\n+import syntax::ast;\n+import syntax::ast::def_id;\n+import syntax::codemap::span;\n+import util::common::lit_eq;\n+\n+// An option identifying a branch (either a literal or a tag variant)\n+tag opt {\n+    lit(@ast::lit);\n+    var(uint /* variant id */, tup(def_id, def_id) /* variant def ids */);\n+}\n+fn opt_eq(&opt a, &opt b) -> bool {\n+    alt (a) {\n+        lit(?la) {\n+            ret alt (b) { lit(?lb) { lit_eq(la, lb) } var(_, _) { false } };\n+        }\n+        var(?ida, _) {\n+            ret alt (b) { lit(_) { false } var(?idb, _) { ida == idb } };\n+        }\n+    }\n+}\n+fn trans_opt(&@crate_ctxt ccx, &opt o) -> ValueRef {\n+    alt (o) {\n+        lit(?l) { ret trans::trans_lit(ccx, *l); }\n+        var(?id, _) { ret C_int(id as int); }\n+    }\n+}\n+\n+fn variant_opt(&@crate_ctxt ccx, ast::node_id pat_id) -> opt {\n+    auto vdef = ast::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n+    auto variants = ty::tag_variants(ccx.tcx, vdef._0);\n+    auto i = 0u;\n+    for (ty::variant_info v in variants) {\n+        if (vdef._1 == v.id) { ret var(i, vdef); }\n+        i += 1u;\n+    }\n+    fail;\n+}\n+\n+type bind_map = tup(ast::ident, ValueRef)[];\n+type match_branch = @rec((@ast::pat)[] pats,\n+                         BasicBlockRef body,\n+                         mutable bind_map bound);\n+type match = match_branch[];\n+\n+fn matches_always(&@ast::pat p) -> bool {\n+    ret alt p.node {\n+        ast::pat_wild { true }\n+        ast::pat_bind(_) { true }\n+        ast::pat_rec(_, _) { true }\n+        _ { false }\n+    };\n+}\n+\n+\n+fn bind_for_pat(&@ast::pat p, &match_branch br, ValueRef val) {\n+    alt p.node {\n+        ast::pat_bind(?name) {\n+            br.bound += ~[tup(name, val)];\n+        }\n+        _ {}\n+    }\n+}\n+\n+fn enter_default(&match m, uint col, ValueRef val) -> match {\n+    auto result = ~[];\n+    for (match_branch br in m) {\n+        if (matches_always(br.pats.(col))) {\n+            auto pats = ivec::slice(br.pats, 0u, col) +\n+                ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n+            auto new_br = @rec(pats=pats with *br);\n+            result += ~[new_br];\n+            bind_for_pat(br.pats.(col), new_br, val);\n+        }\n+    }\n+    ret result;\n+}\n+\n+fn enter_opt(&@crate_ctxt ccx, &match m, &opt opt,\n+             uint col, uint tag_size, ValueRef val) -> match {\n+    auto result = ~[];\n+    auto dummy = @rec(id=0, node=ast::pat_wild, span=rec(lo=0u, hi=0u));\n+    for (match_branch br in m) {\n+        auto pats = ivec::slice(br.pats, 0u, col);\n+        auto include = true;\n+        alt (br.pats.(col).node) {\n+            ast::pat_tag(?ctor, _) {\n+                include = opt_eq(variant_opt(ccx, br.pats.(col).id), opt);\n+            }\n+            ast::pat_lit(?l) {\n+                include = opt_eq(lit(l), opt);\n+            }\n+            _ {}\n+        }\n+        if (include) {\n+            alt (br.pats.(col).node) {\n+                ast::pat_tag(_, ?subpats) {\n+                    assert ivec::len(subpats) == tag_size;\n+                    pats += subpats;\n+                }\n+                _ {\n+                    pats += ivec::init_elt(dummy, tag_size);\n+                }\n+            }\n+            pats += ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n+            auto new_br = @rec(pats=pats with *br);\n+            result += ~[new_br];\n+            bind_for_pat(br.pats.(col), new_br, val);\n+        }\n+    }\n+    ret result;\n+}\n+\n+fn enter_rec(&@crate_ctxt ccx, &match m, uint col, &ast::ident[] fields,\n+             ValueRef val) -> match {\n+    auto result = ~[];\n+    auto dummy = @rec(id=0, node=ast::pat_wild, span=rec(lo=0u, hi=0u));\n+    for (match_branch br in m) {\n+        auto pats = ivec::slice(br.pats, 0u, col);\n+        alt (br.pats.(col).node) {\n+            ast::pat_rec(?fpats, _) {\n+                for (ast::ident fname in fields) {\n+                    auto pat = dummy;\n+                    for (ast::field_pat fpat in fpats) {\n+                        if (str::eq(fpat.ident, fname)) {\n+                            pat = fpat.pat;\n+                            break;\n+                        }\n+                    }\n+                    pats += ~[pat];\n+                }\n+            }\n+            _ {\n+                pats += ivec::init_elt(dummy, ivec::len(fields));\n+            }\n+        }\n+        pats += ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n+        auto new_br = @rec(pats=pats with *br);\n+        result += ~[new_br];\n+        bind_for_pat(br.pats.(col), new_br, val);\n+    }\n+    ret result;\n+}\n+\n+fn get_options(&@crate_ctxt ccx, &match m, uint col) -> opt[] {\n+    fn add_to_set(&mutable opt[] set, &opt val) {\n+        for (opt l in set) {\n+            if (opt_eq(l, val)) { ret; }\n+        }\n+        set += ~[val];\n+    }\n+\n+    auto found = ~[];\n+    for (match_branch br in m) {\n+        alt (br.pats.(col).node) {\n+            ast::pat_lit(?l) { add_to_set(found, lit(l)); }\n+            ast::pat_tag(_, _) { \n+                add_to_set(found, variant_opt(ccx, br.pats.(col).id));\n+            }\n+            _ {}\n+        }\n+    }\n+    ret found;\n+}\n+\n+fn extract_variant_args(@block_ctxt bcx, ast::node_id pat_id,\n+                        &tup(def_id, def_id) vdefs, ValueRef val)\n+    -> tup(ValueRef[], @block_ctxt) {\n+    auto ccx = bcx.fcx.lcx.ccx;\n+    auto ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n+    auto blobptr = val;\n+    auto variants = ty::tag_variants(ccx.tcx, vdefs._0);\n+    auto args = ~[];\n+    auto size = ivec::len(ty::tag_variant_with_id\n+                          (ccx.tcx, vdefs._0, vdefs._1).args);\n+    if (size > 0u && ivec::len(variants) != 1u) {\n+        auto tagptr = bcx.build.PointerCast\n+            (val, trans::T_opaque_tag_ptr(ccx.tn));\n+        blobptr = bcx.build.GEP(tagptr, ~[C_int(0), C_int(1)]);\n+    }\n+    auto i = 0u;\n+    while (i < size) {\n+        auto r = trans::GEP_tag(bcx, blobptr, vdefs._0, vdefs._1,\n+                                ty_param_substs, i as int);\n+        bcx = r.bcx;\n+        args += ~[r.val];\n+        i += 1u;\n+    }\n+    ret tup(args, bcx);\n+}\n+\n+type exit_node = rec(bind_map bound,\n+                     BasicBlockRef from,\n+                     BasicBlockRef to);\n+type mk_fail = fn() -> BasicBlockRef;\n+\n+fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n+                    &mutable exit_node[] exits) {\n+    if (ivec::len(m) == 0u) {\n+        bcx.build.Br(f());\n+        ret;\n+    }\n+    if (ivec::len(m.(0).pats) == 0u) {\n+        exits += ~[rec(bound=m.(0).bound,\n+                       from=bcx.llbb,\n+                       to=m.(0).body)];\n+        bcx.build.Br(m.(0).body);\n+        ret;\n+    }\n+\n+    // FIXME maybe be clever about picking a column.\n+    auto col = 0u;\n+    auto val = vals.(col);\n+    auto vals_left = ivec::slice(vals, 1u, ivec::len(vals));\n+    auto ccx = bcx.fcx.lcx.ccx;\n+    auto pat_id = 0;\n+\n+    auto rec_fields = ~[];\n+    for (match_branch br in m) {\n+        // Find a real id (we're adding placeholder wildcard patterns, but\n+        // each column is guaranteed to have at least one real pattern)\n+        if (pat_id == 0) { pat_id = br.pats.(col).id; }\n+        // Gather field names\n+        alt (br.pats.(col).node) {\n+            ast::pat_rec(?fs, _) {\n+                for (ast::field_pat f in fs) {\n+                    if (!ivec::any(bind str::eq(f.ident, _), rec_fields)) {\n+                        rec_fields += ~[f.ident];\n+                    }\n+                }\n+            }\n+            _ {}\n+        }\n+    }\n+    // Separate path for extracting and binding record fields\n+    if (ivec::len(rec_fields) > 0u) {\n+        auto rec_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n+        auto fields = alt (ty::struct(ccx.tcx, rec_ty)) {\n+            ty::ty_rec(?fields) { fields }\n+        };\n+        auto rec_vals = ~[];\n+        for (ast::ident field_name in rec_fields) {\n+            let uint ix = ty::field_idx(ccx.sess, rec(lo=0u, hi=0u),\n+                                        field_name, fields);\n+            auto r = trans::GEP_tup_like(bcx, rec_ty, val, ~[0, ix as int]);\n+            rec_vals += ~[r.val];\n+            bcx = r.bcx;\n+        }\n+        compile_submatch(bcx, enter_rec(ccx, m, col, rec_fields, val),\n+                         rec_vals + vals_left, f, exits);\n+        ret;\n+    }\n+\n+    // Decide what kind of branch we need\n+    auto opts = get_options(ccx, m, col);\n+    tag branch_kind { no_branch; single; switch; compare; }\n+    auto kind = no_branch;\n+    auto test_val = val;\n+    if (ivec::len(opts) > 0u) {\n+        alt (opts.(0)) {\n+            var(_, ?vdef) {\n+                if (ivec::len(ty::tag_variants(ccx.tcx, vdef._0)) == 1u) {\n+                    kind = single;\n+                } else {\n+                    auto tagptr = bcx.build.PointerCast\n+                        (val, trans::T_opaque_tag_ptr(ccx.tn));\n+                    auto discrimptr = bcx.build.GEP\n+                        (tagptr, ~[C_int(0), C_int(0)]);\n+                    test_val = bcx.build.Load(discrimptr);\n+                    kind = switch;\n+                }\n+            }\n+            lit(?l) {\n+                test_val = bcx.build.Load(val); \n+                kind = alt (l.node) {\n+                    ast::lit_str(_, _) { compare }\n+                    _ { switch }\n+                };\n+            }\n+        }\n+    }\n+    auto else_cx = alt (kind) {\n+        no_branch | single { bcx }\n+        _ { new_sub_block_ctxt(bcx, \"match_else\") }\n+    };\n+    auto sw = if (kind == switch) {\n+        bcx.build.Switch(test_val, else_cx.llbb, ivec::len(opts))\n+    } else { C_int(0) }; // Placeholder for when not using a switch\n+\n+    // Compile subtrees for each option\n+    for (opt opt in opts) {\n+        auto opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n+        alt (kind) {\n+            single { bcx.build.Br(opt_cx.llbb); }\n+            switch { llvm::LLVMAddCase(sw, trans_opt(ccx, opt), opt_cx.llbb);}\n+            compare {\n+                auto t = ty::node_id_to_type(ccx.tcx, pat_id);\n+                auto eq = trans::trans_compare(bcx, ast::eq, t, test_val,\n+                                               trans_opt(ccx, opt));\n+                bcx = new_sub_block_ctxt(bcx, \"next\");\n+                eq.bcx.build.CondBr(eq.val, opt_cx.llbb, bcx.llbb);\n+            }\n+            _ {}\n+        }\n+        auto size = 0u;\n+        auto unpacked = ~[];\n+        alt opt {\n+             var(_, ?vdef) {\n+                 auto args = extract_variant_args(opt_cx, pat_id, vdef, val);\n+                 size = ivec::len(args._0);\n+                 unpacked = args._0;\n+                 opt_cx = args._1;\n+             }\n+             lit(_) { }\n+        }\n+        compile_submatch(opt_cx, enter_opt(ccx, m, opt, col, size, val),\n+                         unpacked + vals_left, f, exits);\n+    }\n+\n+    // Compile the fall-through case\n+    if (kind == compare) { bcx.build.Br(else_cx.llbb); }\n+    if (kind != single) {\n+        compile_submatch(else_cx, enter_default(m, col, val), vals_left,\n+                         f, exits);\n+    }\n+}\n+\n+// FIXME breaks on unreacheable cases\n+fn make_phi_bindings(&@block_ctxt bcx, &exit_node[] map,\n+                     &ast::pat_id_map ids) {\n+    fn assoc(str key, &tup(str, ValueRef)[] list) -> ValueRef {\n+        for (tup(str, ValueRef) elt in list) {\n+            if (str::eq(elt._0, key)) { ret elt._1; }\n+        }\n+        fail;\n+    }\n+    \n+    auto our_block = bcx.llbb as uint;\n+    for each (@tup(ast::ident, ast::node_id) item in ids.items()) {\n+        auto llbbs = ~[];\n+        auto vals = ~[];\n+        for (exit_node ex in map) {\n+            if (ex.to as uint == our_block) {\n+                llbbs += ~[ex.from];\n+                vals += ~[assoc(item._0, ex.bound)];\n+            }\n+        }\n+        auto phi = bcx.build.Phi(val_ty(vals.(0)), vals, llbbs);\n+        bcx.fcx.lllocals.insert(item._1, phi);\n+    }\n+}\n+\n+fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &ast::arm[] arms,\n+             ast::node_id id, &trans::out_method output) -> result {\n+    auto bodies = ~[];\n+    let match match = ~[];\n+    for (ast::arm a in arms) {\n+        auto body = new_scope_block_ctxt(cx, \"case_body\");\n+        bodies += ~[body];\n+        for (@ast::pat p in a.pats) {\n+            match += ~[@rec(pats=~[p], body=body.llbb, mutable bound=~[])];\n+        }\n+    }\n+\n+    // Cached fail-on-fallthrough block\n+    auto fail_cx = @mutable none;\n+    fn mk_fail(&@block_ctxt cx, &span sp,\n+               @mutable option::t[BasicBlockRef] done) -> BasicBlockRef {\n+        alt (*done) {\n+            some(?bb) { ret bb; }\n+            _ {}\n+        }\n+        auto fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n+        trans::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");\n+        *done = some(fail_cx.llbb);\n+        ret fail_cx.llbb;\n+    }\n+\n+    auto exit_map = ~[];\n+    auto er = trans::trans_expr(cx, expr);\n+    auto t = trans::node_id_type(cx.fcx.lcx.ccx, expr.id);\n+    auto v = trans::spill_if_immediate(er.bcx, er.val, t);\n+    compile_submatch(er.bcx, match, ~[v],\n+                     bind mk_fail(cx, expr.span, fail_cx), exit_map);\n+\n+    auto i = 0u;\n+    auto arm_results = ~[];\n+    for (ast::arm a in arms) {\n+        auto body_cx = bodies.(i);\n+        make_phi_bindings(body_cx, exit_map, ast::pat_id_map(a.pats.(0)));\n+        auto block_res = trans::trans_block(body_cx, a.block, output);\n+        arm_results += ~[block_res];\n+        i += 1u;\n+    }\n+    ret rslt(trans::join_branches(cx, arm_results), C_nil());\n+}\n+\n+// Local Variables:\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "1968cafbe14bf6682a1ed4449f06fefc6e9aa445", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12d553216663b80a6c10921ab52558253ba56920/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/12d553216663b80a6c10921ab52558253ba56920/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=12d553216663b80a6c10921ab52558253ba56920", "patch": "@@ -16,6 +16,7 @@ use std (name = \"std\",\n \n mod middle {\n     mod trans;\n+    mod trans_alt;\n     mod ty;\n     mod ast_map;\n     mod resolve;"}, {"sha": "9be31ec860792f6b8ff2e9afbb86baac2d4902e6", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12d553216663b80a6c10921ab52558253ba56920/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d553216663b80a6c10921ab52558253ba56920/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=12d553216663b80a6c10921ab52558253ba56920", "patch": "@@ -195,6 +195,7 @@ fn call_kind_str(call_kind c) -> str {\n         case (kind_bind)  { \"Bind\" }\n     }\n }\n+\n //\n // Local Variables:\n // mode: rust"}]}