{"sha": "1efd8049837aec86f21da1486e8a459a7efd7806", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZmQ4MDQ5ODM3YWVjODZmMjFkYTE0ODZlOGE0NTlhN2VmZDc4MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-11T04:40:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-11T04:40:57Z"}, "message": "Auto merge of #81126 - oxalica:retain-early-drop, r=m-ou-se\n\nOptimize Vec::retain\n\nUse `copy_non_overlapping` instead of `swap` to reduce memory writes, like what we've done in #44355 and `String::retain`.\n#48065 already tried to do this optimization but it is reverted in #67300 due to bad codegen of `DrainFilter::drop`.\n\nThis PR re-implement the drop-then-move approach. I did a [benchmark](https://gist.github.com/oxalica/3360eec9376f22533fcecff02798b698) on small-no-drop, small-need-drop, large-no-drop elements with different predicate functions. It turns out that the new implementation is >20% faster in average for almost all cases. Only 2/24 cases are slower by 3% and 5%. See the link above for more detail.\n\nI think regression in may-panic cases is due to drop-guard preventing some optimization. If it's permitted to leak elements when predicate function of element's `drop` panic, the new implementation should be almost always faster than current one.\nI'm not sure if we should leak on panic, since there is indeed an issue (#52267) complains about it before.", "tree": {"sha": "8f8c3ebfed31260b12470da6431a96231e39f7aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f8c3ebfed31260b12470da6431a96231e39f7aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1efd8049837aec86f21da1486e8a459a7efd7806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1efd8049837aec86f21da1486e8a459a7efd7806", "html_url": "https://github.com/rust-lang/rust/commit/1efd8049837aec86f21da1486e8a459a7efd7806", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1efd8049837aec86f21da1486e8a459a7efd7806/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ce7268bcfc17265bd05e4c08713d170d39618ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ce7268bcfc17265bd05e4c08713d170d39618ad", "html_url": "https://github.com/rust-lang/rust/commit/9ce7268bcfc17265bd05e4c08713d170d39618ad"}, {"sha": "2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e", "html_url": "https://github.com/rust-lang/rust/commit/2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e"}], "stats": {"total": 136, "additions": 125, "deletions": 11}, "files": [{"sha": "b40c1a8c57aa405ce4701f8eca4f55ed7c38eb52", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1efd8049837aec86f21da1486e8a459a7efd7806/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efd8049837aec86f21da1486e8a459a7efd7806/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=1efd8049837aec86f21da1486e8a459a7efd7806", "patch": "@@ -1399,22 +1399,75 @@ impl<T, A: Allocator> Vec<T, A> {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        let len = self.len();\n-        let mut del = 0;\n-        {\n-            let v = &mut **self;\n+        let original_len = self.len();\n+        // Avoid double drop if the drop guard is not executed,\n+        // since we may make some holes during the process.\n+        unsafe { self.set_len(0) };\n+\n+        // Vec: [Kept, Kept, Hole, Hole, Hole, Hole, Unchecked, Unchecked]\n+        //      |<-              processed len   ->| ^- next to check\n+        //                  |<-  deleted cnt     ->|\n+        //      |<-              original_len                          ->|\n+        // Kept: Elements which predicate returns true on.\n+        // Hole: Moved or dropped element slot.\n+        // Unchecked: Unchecked valid elements.\n+        //\n+        // This drop guard will be invoked when predicate or `drop` of element panicked.\n+        // It shifts unchecked elements to cover holes and `set_len` to the correct length.\n+        // In cases when predicate and `drop` never panick, it will be optimized out.\n+        struct BackshiftOnDrop<'a, T, A: Allocator> {\n+            v: &'a mut Vec<T, A>,\n+            processed_len: usize,\n+            deleted_cnt: usize,\n+            original_len: usize,\n+        }\n \n-            for i in 0..len {\n-                if !f(&v[i]) {\n-                    del += 1;\n-                } else if del > 0 {\n-                    v.swap(i - del, i);\n+        impl<T, A: Allocator> Drop for BackshiftOnDrop<'_, T, A> {\n+            fn drop(&mut self) {\n+                if self.deleted_cnt > 0 {\n+                    // SAFETY: Trailing unchecked items must be valid since we never touch them.\n+                    unsafe {\n+                        ptr::copy(\n+                            self.v.as_ptr().add(self.processed_len),\n+                            self.v.as_mut_ptr().add(self.processed_len - self.deleted_cnt),\n+                            self.original_len - self.processed_len,\n+                        );\n+                    }\n+                }\n+                // SAFETY: After filling holes, all items are in contiguous memory.\n+                unsafe {\n+                    self.v.set_len(self.original_len - self.deleted_cnt);\n                 }\n             }\n         }\n-        if del > 0 {\n-            self.truncate(len - del);\n+\n+        let mut g = BackshiftOnDrop { v: self, processed_len: 0, deleted_cnt: 0, original_len };\n+\n+        while g.processed_len < original_len {\n+            // SAFETY: Unchecked element must be valid.\n+            let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };\n+            if !f(cur) {\n+                // Advance early to avoid double drop if `drop_in_place` panicked.\n+                g.processed_len += 1;\n+                g.deleted_cnt += 1;\n+                // SAFETY: We never touch this element again after dropped.\n+                unsafe { ptr::drop_in_place(cur) };\n+                // We already advanced the counter.\n+                continue;\n+            }\n+            if g.deleted_cnt > 0 {\n+                // SAFETY: `deleted_cnt` > 0, so the hole slot must not overlap with current element.\n+                // We use copy for move, and never touch this element again.\n+                unsafe {\n+                    let hole_slot = g.v.as_mut_ptr().add(g.processed_len - g.deleted_cnt);\n+                    ptr::copy_nonoverlapping(cur, hole_slot, 1);\n+                }\n+            }\n+            g.processed_len += 1;\n         }\n+\n+        // All item are processed. This can be optimized to `set_len` by LLVM.\n+        drop(g);\n     }\n \n     /// Removes all but the first of consecutive elements in the vector that resolve to the same"}, {"sha": "e3d74791dcf466142a7070a107748bb172d4bd2d", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1efd8049837aec86f21da1486e8a459a7efd7806/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efd8049837aec86f21da1486e8a459a7efd7806/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=1efd8049837aec86f21da1486e8a459a7efd7806", "patch": "@@ -287,6 +287,67 @@ fn test_retain() {\n     assert_eq!(vec, [2, 4]);\n }\n \n+#[test]\n+fn test_retain_pred_panic_with_hole() {\n+    let v = (0..5).map(Rc::new).collect::<Vec<_>>();\n+    catch_unwind(AssertUnwindSafe(|| {\n+        let mut v = v.clone();\n+        v.retain(|r| match **r {\n+            0 => true,\n+            1 => false,\n+            2 => true,\n+            _ => panic!(),\n+        });\n+    }))\n+    .unwrap_err();\n+    // Everything is dropped when predicate panicked.\n+    assert!(v.iter().all(|r| Rc::strong_count(r) == 1));\n+}\n+\n+#[test]\n+fn test_retain_pred_panic_no_hole() {\n+    let v = (0..5).map(Rc::new).collect::<Vec<_>>();\n+    catch_unwind(AssertUnwindSafe(|| {\n+        let mut v = v.clone();\n+        v.retain(|r| match **r {\n+            0 | 1 | 2 => true,\n+            _ => panic!(),\n+        });\n+    }))\n+    .unwrap_err();\n+    // Everything is dropped when predicate panicked.\n+    assert!(v.iter().all(|r| Rc::strong_count(r) == 1));\n+}\n+\n+#[test]\n+fn test_retain_drop_panic() {\n+    struct Wrap(Rc<i32>);\n+\n+    impl Drop for Wrap {\n+        fn drop(&mut self) {\n+            if *self.0 == 3 {\n+                panic!();\n+            }\n+        }\n+    }\n+\n+    let v = (0..5).map(|x| Rc::new(x)).collect::<Vec<_>>();\n+    catch_unwind(AssertUnwindSafe(|| {\n+        let mut v = v.iter().map(|r| Wrap(r.clone())).collect::<Vec<_>>();\n+        v.retain(|w| match *w.0 {\n+            0 => true,\n+            1 => false,\n+            2 => true,\n+            3 => false, // Drop panic.\n+            _ => true,\n+        });\n+    }))\n+    .unwrap_err();\n+    // Other elements are dropped when `drop` of one element panicked.\n+    // The panicked wrapper also has its Rc dropped.\n+    assert!(v.iter().all(|r| Rc::strong_count(r) == 1));\n+}\n+\n #[test]\n fn test_dedup() {\n     fn case(a: Vec<i32>, b: Vec<i32>) {"}]}