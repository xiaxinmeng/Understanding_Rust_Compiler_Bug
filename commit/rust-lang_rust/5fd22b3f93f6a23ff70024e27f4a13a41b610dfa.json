{"sha": "5fd22b3f93f6a23ff70024e27f4a13a41b610dfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZDIyYjNmOTNmNmEyM2ZmNzAwMjRlMjdmNGExM2E0MWI2MTBkZmE=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-02-04T15:07:09Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-02-06T18:13:45Z"}, "message": "Optionally indent snippet_block relative to an Expr", "tree": {"sha": "91573fe6045354d4c946015dac4b6c5a725b325b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91573fe6045354d4c946015dac4b6c5a725b325b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl48V1kACgkQaTCGhp1Q\nZjd05RAAiyTkv20a0Vts7t7K85p0eSe//X1danFh/HMzlRE5C0RClIwDcfBhn4xn\nkhnsPYFHtBYb6tTFSoimfTpsS/6jVy/v7qU51H6sSHbxzrsh8a2EB9K65Jpagghe\ncWEjxHIq2GeKZf8panyaUW6/Zuzu3fSn1y6eAZ28ghd1NJSzY2EIL0PnX6qMa7Dh\niw7WUTC/ieZcMHR2V+s6aGYFZBj/exP1UGOIUUNSd87xRdIjLNVU2ddvBR7N/Bf3\n1cFd/5u+jyc4l631NblxkOB5gdCofkRhuE0BrXCrQ8P6n1fbsv2EwLXq9Ht79TM+\nI/iIf+TNH0+/8UHXNOjqWPrDi6/kNi1RFA+75nil9mn50PKAqh42Oq+uOVKTObYf\nntVN1FdNOEzVpHk/PiXUX9WvFJUYClW6G2jW0tshMzUjvdi8Or6lkBJGDMdjP0hU\nnbFpIVJLzHa2aDE4CU07dKF995wPc0wdRCaKFuPkqwL9QMqwu8BnlcwV8rU0esuT\n1OomQn0SgrbD4oEzHkRPueU5iYkYL4CQV7mWhZaJ2lDb18IpoFl8Nqh3kppF5BUn\nr27808Crh4I88NQ4hczfmB5OVDoi1raCT5gFxO61gYfioyKaQPe5ZAOsgpmx5sKg\ngzMi77yob6zdlR1C7ZVaUPUQ3Nl65qv2RiPdQTb16bbeoymlJkE=\n=IO3I\n-----END PGP SIGNATURE-----", "payload": "tree 91573fe6045354d4c946015dac4b6c5a725b325b\nparent a6f310ed0e22a422e7001efbe7e4bf2a0c9a0eff\nauthor flip1995 <hello@philkrones.com> 1580828829 +0100\ncommitter flip1995 <hello@philkrones.com> 1581012825 +0100\n\nOptionally indent snippet_block relative to an Expr\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa", "html_url": "https://github.com/rust-lang/rust/commit/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6f310ed0e22a422e7001efbe7e4bf2a0c9a0eff", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6f310ed0e22a422e7001efbe7e4bf2a0c9a0eff", "html_url": "https://github.com/rust-lang/rust/commit/a6f310ed0e22a422e7001efbe7e4bf2a0c9a0eff"}], "stats": {"total": 131, "additions": 96, "deletions": 35}, "files": [{"sha": "6f67acb29219e806c2e04bcbb5e9d0033458c68e", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=5fd22b3f93f6a23ff70024e27f4a13a41b610dfa", "patch": "@@ -2,7 +2,7 @@\n \n use crate::reexport::*;\n use crate::utils::{\n-    is_present_in_source, last_line_of_span, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg,\n+    first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg,\n     span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n@@ -261,7 +261,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Attributes {\n                                             _ => {},\n                                         }\n                                     }\n-                                    let line_span = last_line_of_span(cx, attr.span);\n+                                    let line_span = first_line_of_span(cx, attr.span);\n \n                                     if let Some(mut sugg) = snippet_opt(cx, line_span) {\n                                         if sugg.contains(\"#[\") {"}, {"sha": "c6ca85b0cdf43a2fcded6ace944c25278ee10076", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=5fd22b3f93f6a23ff70024e27f4a13a41b610dfa", "patch": "@@ -95,7 +95,7 @@ fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n \n fn block_starts_with_comment(cx: &EarlyContext<'_>, expr: &ast::Block) -> bool {\n     // We trim all opening braces and whitespaces and then check if the next string is a comment.\n-    let trimmed_block_text = snippet_block(cx, expr.span, \"..\")\n+    let trimmed_block_text = snippet_block(cx, expr.span, \"..\", None)\n         .trim_start_matches(|c: char| c.is_whitespace() || c == '{')\n         .to_owned();\n     trimmed_block_text.starts_with(\"//\") || trimmed_block_text.starts_with(\"/*\")\n@@ -116,7 +116,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n                 block.span,\n                 \"this `else { if .. }` block can be collapsed\",\n                 \"try\",\n-                snippet_block_with_applicability(cx, else_.span, \"..\", &mut applicability).into_owned(),\n+                snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability).into_owned(),\n                 applicability,\n             );\n         }\n@@ -146,7 +146,7 @@ fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &\n                     format!(\n                         \"if {} {}\",\n                         lhs.and(&rhs),\n-                        snippet_block(cx, content.span, \"..\"),\n+                        snippet_block(cx, content.span, \"..\", Some(expr.span)),\n                     ),\n                     Applicability::MachineApplicable, // snippet\n                 );"}, {"sha": "0545353534706906fc74bae2fe2bdc61bfe32ca3", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=5fd22b3f93f6a23ff70024e27f4a13a41b610dfa", "patch": "@@ -434,7 +434,7 @@ fn report_single_match_single_pattern(\n ) {\n     let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n     let els_str = els.map_or(String::new(), |els| {\n-        format!(\" else {}\", expr_block(cx, els, None, \"..\"))\n+        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n     });\n     span_lint_and_sugg(\n         cx,\n@@ -447,7 +447,7 @@ fn report_single_match_single_pattern(\n             \"if let {} = {} {}{}\",\n             snippet(cx, arms[0].pat.span, \"..\"),\n             snippet(cx, ex.span, \"..\"),\n-            expr_block(cx, &arms[0].body, None, \"..\"),\n+            expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n             els_str,\n         ),\n         Applicability::HasPlaceholders,\n@@ -523,17 +523,21 @@ fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], e\n                             (false, false) => Some(format!(\n                                 \"if {} {} else {}\",\n                                 snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\"),\n-                                expr_block(cx, false_expr, None, \"..\")\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n+                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n                             )),\n                             (false, true) => Some(format!(\n                                 \"if {} {}\",\n                                 snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\")\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n                             )),\n                             (true, false) => {\n                                 let test = Sugg::hir(cx, ex, \"..\");\n-                                Some(format!(\"if {} {}\", !test, expr_block(cx, false_expr, None, \"..\")))\n+                                Some(format!(\n+                                    \"if {} {}\",\n+                                    !test,\n+                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                                ))\n                             },\n                             (true, true) => None,\n                         };"}, {"sha": "e00c65569b3d79900aaf37433b0623973bc54262", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 81, "deletions": 24, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd22b3f93f6a23ff70024e27f4a13a41b610dfa/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=5fd22b3f93f6a23ff70024e27f4a13a41b610dfa", "patch": "@@ -44,6 +44,7 @@ use rustc_hir::Node;\n use rustc_hir::*;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n+use rustc_span::source_map::original_sp;\n use rustc_span::symbol::{self, kw, Symbol};\n use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n use smallvec::SmallVec;\n@@ -541,11 +542,17 @@ pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n ///\n /// # Example\n /// ```rust,ignore\n-/// snippet_block(cx, expr.span, \"..\")\n+/// snippet_block(cx, expr.span, \"..\", None)\n /// ```\n-pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet_block<'a, T: LintContext>(\n+    cx: &T,\n+    span: Span,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n-    trim_multiline(snip, true)\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    trim_multiline(snip, true, indent)\n }\n \n /// Same as `snippet_block`, but adapts the applicability level by the rules of\n@@ -554,27 +561,73 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n     cx: &T,\n     span: Span,\n     default: &'a str,\n+    indent_relative_to: Option<Span>,\n     applicability: &mut Applicability,\n ) -> Cow<'a, str> {\n     let snip = snippet_with_applicability(cx, span, default, applicability);\n-    trim_multiline(snip, true)\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    trim_multiline(snip, true, indent)\n }\n \n-/// Returns a new Span that covers the full last line of the given Span\n-pub fn last_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+/// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n+/// line.\n+///\n+/// ```rust,ignore\n+///     let x = ();\n+/// //          ^^\n+/// // will be converted to\n+///     let x = ();\n+/// //  ^^^^^^^^^^\n+/// ```\n+pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    if let Some(first_char_pos) = first_char_in_first_line(cx, span) {\n+        span.with_lo(first_char_pos)\n+    } else {\n+        span\n+    }\n+}\n+\n+fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n+    let line_span = line_span(cx, span);\n+    if let Some(snip) = snippet_opt(cx, line_span) {\n+        snip.find(|c: char| !c.is_whitespace())\n+            .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Returns the indentation of the line of a span\n+///\n+/// ```rust,ignore\n+/// let x = ();\n+/// //      ^^ -- will return 0\n+///     let x = ();\n+/// //          ^^ -- will return 4\n+/// ```\n+pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n+    if let Some(snip) = snippet_opt(cx, line_span(cx, span)) {\n+        snip.find(|c: char| !c.is_whitespace())\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Extends the span to the beginning of the spans line, incl. whitespaces.\n+///\n+/// ```rust,ignore\n+///        let x = ();\n+/// //             ^^\n+/// // will be converted to\n+///        let x = ();\n+/// // ^^^^^^^^^^^^^^\n+/// ```\n+fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n+    let span = original_sp(span, DUMMY_SP);\n     let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n     let line_no = source_map_and_line.line;\n-    let line_start = &source_map_and_line.sf.lines[line_no];\n-    let span = Span::new(*line_start, span.hi(), span.ctxt());\n-    if_chain! {\n-        if let Some(snip) = snippet_opt(cx, span);\n-        if let Some(first_ch_pos) = snip.find(|c: char| !c.is_whitespace());\n-        then {\n-            span.with_lo(span.lo() + BytePos::from_usize(first_ch_pos))\n-        } else {\n-            span\n-        }\n-    }\n+    let line_start = source_map_and_line.sf.lines[line_no];\n+    Span::new(line_start, span.hi(), span.ctxt())\n }\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n@@ -584,8 +637,9 @@ pub fn expr_block<'a, T: LintContext>(\n     expr: &Expr<'_>,\n     option: Option<String>,\n     default: &'a str,\n+    indent_relative_to: Option<Span>,\n ) -> Cow<'a, str> {\n-    let code = snippet_block(cx, expr.span, default);\n+    let code = snippet_block(cx, expr.span, default, indent_relative_to);\n     let string = option.unwrap_or_default();\n     if expr.span.from_expansion() {\n         Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n@@ -600,14 +654,14 @@ pub fn expr_block<'a, T: LintContext>(\n \n /// Trim indentation from a multiline string with possibility of ignoring the\n /// first line.\n-pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool) -> Cow<'_, str> {\n-    let s_space = trim_multiline_inner(s, ignore_first, ' ');\n-    let s_tab = trim_multiline_inner(s_space, ignore_first, '\\t');\n-    trim_multiline_inner(s_tab, ignore_first, ' ')\n+pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>) -> Cow<'_, str> {\n+    let s_space = trim_multiline_inner(s, ignore_first, indent, ' ');\n+    let s_tab = trim_multiline_inner(s_space, ignore_first, indent, '\\t');\n+    trim_multiline_inner(s_tab, ignore_first, indent, ' ')\n }\n \n-fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_, str> {\n-    let x = s\n+fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, indent: Option<usize>, ch: char) -> Cow<'_, str> {\n+    let mut x = s\n         .lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n@@ -620,6 +674,9 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_\n         })\n         .min()\n         .unwrap_or(0);\n+    if let Some(indent) = indent {\n+        x = x.saturating_sub(indent);\n+    }\n     if x > 0 {\n         Cow::Owned(\n             s.lines()"}]}