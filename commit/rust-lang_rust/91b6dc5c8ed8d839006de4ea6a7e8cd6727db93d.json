{"sha": "91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYjZkYzVjOGVkOGQ4MzkwMDZkZTRlYTZhN2U4Y2Q2NzI3ZGI5M2Q=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-05T23:15:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-05T23:15:21Z"}, "message": "Merge remote-tracking branch 'erickt/master'\n\nConflicts:\n\tsrc/libcore/vec.rs\n\tsrc/libstd/getopts.rs", "tree": {"sha": "3442d5275d820c0440e7f4e230a7555fda87fa43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3442d5275d820c0440e7f4e230a7555fda87fa43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "html_url": "https://github.com/rust-lang/rust/commit/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6be25c8a0cfe28f032ce2b65f8cb07dd1a1ae148", "url": "https://api.github.com/repos/rust-lang/rust/commits/6be25c8a0cfe28f032ce2b65f8cb07dd1a1ae148", "html_url": "https://github.com/rust-lang/rust/commit/6be25c8a0cfe28f032ce2b65f8cb07dd1a1ae148"}, {"sha": "29ba19633651e4c51cddf3c2c089c1c36ed531c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ba19633651e4c51cddf3c2c089c1c36ed531c6", "html_url": "https://github.com/rust-lang/rust/commit/29ba19633651e4c51cddf3c2c089c1c36ed531c6"}], "stats": {"total": 488, "additions": 458, "deletions": 30}, "files": [{"sha": "ad6dd68d82392e3ffab871d3316fe474608a6b7f", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "patch": "@@ -922,8 +922,8 @@ for the parameter list, as in `{|| ...}`.\n Partial application is done using the `bind` keyword in Rust.\n \n ~~~~\n-let daynum = bind vec::position(_, [\"mo\", \"tu\", \"we\", \"do\",\n-                                    \"fr\", \"sa\", \"su\"]);\n+let daynum = bind vec::position_elt([\"mo\", \"tu\", \"we\", \"do\",\n+                                     \"fr\", \"sa\", \"su\"], _);\n ~~~~\n \n Binding a function produces a boxed closure (`fn@` type) in which some"}, {"sha": "a6177e015c58eb1e27815db58c7317e9e9ab72c5", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "patch": "@@ -702,7 +702,7 @@ fn filter_invalid(src: list<@invalid>, bs: [binding]) -> list<@invalid> {\n     while cur != list::nil {\n         alt cur {\n           list::cons(head, tail) {\n-            let p = vec::position_pred(bs, {|b| b.node_id == head.node_id});\n+            let p = vec::position(bs, {|b| b.node_id == head.node_id});\n             if !is_none(p) { out = list::cons(head, @out); }\n             cur = *tail;\n           }"}, {"sha": "500a8591516f4ffdb2345caa350021269795d764", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "patch": "@@ -426,7 +426,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       }\n       ty::ty_param(n, _) {\n         // Find the type parameter in the parameter list.\n-        alt vec::position(n, ty_param_map) {\n+        alt vec::position_elt(ty_param_map, n) {\n           some(i) { s += [shape_var, i as u8]; }\n           none { fail \"ty param not found in ty_param_map\"; }\n         }"}, {"sha": "37e410e9d5c91c1359f9f34e771fab98f62a267a", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "patch": "@@ -3395,7 +3395,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n            have a record type\") } };\n     let temp_cleanups = [];\n     for fld in fields {\n-        let ix = option::get(vec::position_pred(ty_fields, {|ft|\n+        let ix = option::get(vec::position(ty_fields, {|ft|\n             str::eq(fld.node.ident, ft.ident)\n         }));\n         let dst = GEP_tup_like_1(bcx, t, addr, [0, ix as int]);"}, {"sha": "50f5dd2100737b3b9ad64f076306f9b1f04a9c41", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "patch": "@@ -1480,7 +1480,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                     }\n                 };\n                 let ifce_methods = ty::iface_methods(tcx, iid);\n-                alt vec::position_pred(*ifce_methods, {|m| m.ident == name}) {\n+                alt vec::position(*ifce_methods, {|m| m.ident == name}) {\n                   some(pos) {\n                     let m = ifce_methods[pos];\n                     ret some({method_ty: ty::mk_fn(tcx, m.fty),"}, {"sha": "0dc5dea59bcd8050d036f3f69ecd865462a40411", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 449, "deletions": 22, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "patch": "@@ -278,6 +278,110 @@ fn slice_mut<T: copy>(v: [const T], start: uint, end: uint) -> [mutable T] {\n     ret result;\n }\n \n+/*\n+Function: split\n+\n+Split the vector `v` by applying each element against the predicate `f`.\n+*/\n+fn split<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n+    let ln = len(v);\n+    if (ln == 0u) { ret [] }\n+\n+    let start = 0u;\n+    let result = [];\n+    while start < ln {\n+        alt position_from(v, start, ln, f) {\n+          none { break }\n+          some(i) {\n+            push(result, slice(v, start, i));\n+            start = i + 1u;\n+          }\n+        }\n+    }\n+    push(result, slice(v, start, ln));\n+    result\n+}\n+\n+/*\n+Function: splitn\n+\n+Split the vector `v` by applying each element against the predicate `f` up\n+to `n` times.\n+*/\n+fn splitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+    let ln = len(v);\n+    if (ln == 0u) { ret [] }\n+\n+    let start = 0u;\n+    let count = n;\n+    let result = [];\n+    while start < ln && count > 0u {\n+        alt position_from(v, start, ln, f) {\n+          none { break }\n+          some(i) {\n+            push(result, slice(v, start, i));\n+            // Make sure to skip the separator.\n+            start = i + 1u;\n+            count -= 1u;\n+          }\n+        }\n+    }\n+    push(result, slice(v, start, ln));\n+    result\n+}\n+\n+/*\n+Function: rsplit\n+\n+Reverse split the vector `v` by applying each element against the predicate\n+`f`.\n+*/\n+fn rsplit<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n+    let ln = len(v);\n+    if (ln == 0u) { ret [] }\n+\n+    let end = ln;\n+    let result = [];\n+    while end > 0u {\n+        alt rposition_from(v, 0u, end, f) {\n+          none { break }\n+          some(i) {\n+            push(result, slice(v, i + 1u, end));\n+            end = i;\n+          }\n+        }\n+    }\n+    push(result, slice(v, 0u, end));\n+    reversed(result)\n+}\n+\n+/*\n+Function: rsplitn\n+\n+Reverse split the vector `v` by applying each element against the predicate\n+`f` up to `n times.\n+*/\n+fn rsplitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+    let ln = len(v);\n+    if (ln == 0u) { ret [] }\n+\n+    let end = ln;\n+    let count = n;\n+    let result = [];\n+    while end > 0u && count > 0u {\n+        alt rposition_from(v, 0u, end, f) {\n+          none { break }\n+          some(i) {\n+            push(result, slice(v, i + 1u, end));\n+            // Make sure to skip the separator.\n+            end = i;\n+            count -= 1u;\n+          }\n+        }\n+    }\n+    push(result, slice(v, 0u, end));\n+    reversed(result)\n+}\n \n // Mutators\n \n@@ -486,6 +590,21 @@ fn concat<T: copy>(v: [const [const T]]) -> [T] {\n     ret new;\n }\n \n+/*\n+Function: connect\n+\n+Concatenate a vector of vectors, placing a given separator between each\n+*/\n+fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n+    let new: [T] = [];\n+    let first = true;\n+    for inner: [T] in v {\n+        if first { first = false; } else { push(new, sep); }\n+        new += inner;\n+    }\n+    ret new;\n+}\n+\n /*\n Function: foldl\n \n@@ -593,19 +712,59 @@ fn count<T>(x: T, v: [const T]) -> uint {\n /*\n Function: find\n \n-Search for an element that matches a given predicate\n+Search for the first element that matches a given predicate\n \n Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n */\n fn find<T: copy>(v: [T], f: fn(T) -> bool) -> option<T> {\n-    for elt: T in v { if f(elt) { ret some(elt); } }\n-    ret none;\n+    find_from(v, 0u, len(v), f)\n }\n \n /*\n-Function: position\n+Function: find_from\n+\n+Search for the first element that matches a given predicate within a range\n+\n+Apply function `f` to each element of `v` within the range [`start`, `end`).\n+When function `f` returns true then an option containing the element\n+is returned. If `f` matches no elements then none is returned.\n+*/\n+fn find_from<T: copy>(v: [T], start: uint, end: uint, f: fn(T) -> bool) ->\n+  option<T> {\n+    option::map(position_from(v, start, end, f)) { |i| v[i] }\n+}\n+\n+/*\n+Function: rfind\n+\n+Search for the last element that matches a given predicate\n+\n+Apply function `f` to each element of `v` in reverse order. When function `f`\n+returns true then an option containing the element is returned. If `f`\n+matches no elements then none is returned.\n+*/\n+fn rfind<T: copy>(v: [T], f: fn(T) -> bool) -> option<T> {\n+    rfind_from(v, 0u, len(v), f)\n+}\n+\n+/*\n+Function: rfind_from\n+\n+Search for the last element that matches a given predicate within a range\n+\n+Apply function `f` to each element of `v` in reverse order within the range\n+[`start`, `end`). When function `f` returns true then an option containing\n+the element is returned. If `f` matches no elements then none is returned.\n+*/\n+fn rfind_from<T: copy>(v: [T], start: uint, end: uint, f: fn(T) -> bool) ->\n+  option<T> {\n+    option::map(rposition_from(v, start, end, f)) { |i| v[i] }\n+}\n+\n+/*\n+Function: position_elt\n \n Find the first index containing a matching value\n \n@@ -614,20 +773,86 @@ Returns:\n option::some(uint) - The first index containing a matching value\n option::none - No elements matched\n */\n-fn position<T>(x: T, v: [T]) -> option<uint> {\n-    let i: uint = 0u;\n-    while i < len(v) { if x == v[i] { ret some::<uint>(i); } i += 1u; }\n+fn position_elt<T>(v: [T], x: T) -> option<uint> {\n+    position(v) { |y| x == y }\n+}\n+\n+/*\n+Function: position\n+\n+Find the first index matching some predicate\n+\n+Apply function `f` to each element of `v`.  When function `f` returns true\n+then an option containing the index is returned. If `f` matches no elements\n+then none is returned.\n+*/\n+fn position<T>(v: [T], f: fn(T) -> bool) -> option<uint> {\n+    position_from(v, 0u, len(v), f)\n+}\n+\n+/*\n+Function: position_from\n+\n+Find the first index matching some predicate within a range\n+\n+Apply function `f` to each element of `v` between the range [`start`, `end`).\n+When function `f` returns true then an option containing the index is\n+returned. If `f` matches no elements then none is returned.\n+*/\n+fn position_from<T>(v: [T], start: uint, end: uint, f: fn(T) -> bool) ->\n+  option<uint> {\n+    assert start <= end;\n+    assert end <= len(v);\n+    let i = start;\n+    while i < end { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n     ret none;\n }\n \n /*\n-Function: position_pred\n+Function: rposition_elt\n+\n+Find the last index containing a matching value\n+\n+Returns:\n+\n+option::some(uint) - The last index containing a matching value\n+option::none - No elements matched\n+*/\n+fn rposition_elt<T>(v: [T], x: T) -> option<uint> {\n+    rposition(v) { |y| x == y }\n+}\n+\n+/*\n+Function: rposition\n+\n+Find the last index matching some predicate\n \n-Find the first index for which the value matches some predicate\n+Apply function `f` to each element of `v` in reverse order.  When function\n+`f` returns true then an option containing the index is returned. If `f`\n+matches no elements then none is returned.\n */\n-fn position_pred<T>(v: [T], f: fn(T) -> bool) -> option<uint> {\n-    let i: uint = 0u;\n-    while i < len(v) { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n+fn rposition<T>(v: [T], f: fn(T) -> bool) -> option<uint> {\n+    rposition_from(v, 0u, len(v), f)\n+}\n+\n+/*\n+Function: rposition_from\n+\n+Find the last index matching some predicate within a range\n+\n+Apply function `f` to each element of `v` in reverse order between the range\n+[`start`, `end`). When function `f` returns true then an option containing\n+the index is returned. If `f` matches no elements then none is returned.\n+*/\n+fn rposition_from<T>(v: [T], start: uint, end: uint, f: fn(T) -> bool) ->\n+  option<uint> {\n+    assert start <= end;\n+    assert end <= len(v);\n+    let i = end;\n+    while i > start {\n+        if f(v[i - 1u]) { ret some::<uint>(i - 1u); }\n+        i -= 1u;\n+    }\n     ret none;\n }\n \n@@ -1444,21 +1669,174 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_position() {\n-        let v1: [int] = [1, 2, 3, 3, 2, 5];\n-        assert (position(1, v1) == option::some::<uint>(0u));\n-        assert (position(2, v1) == option::some::<uint>(1u));\n-        assert (position(5, v1) == option::some::<uint>(5u));\n-        assert (position(4, v1) == option::none::<uint>);\n+    fn test_position_elt() {\n+        assert position_elt([], 1) == none;\n+\n+        let v1 = [1, 2, 3, 3, 2, 5];\n+        assert position_elt(v1, 1) == some(0u);\n+        assert position_elt(v1, 2) == some(1u);\n+        assert position_elt(v1, 5) == some(5u);\n+        assert position_elt(v1, 4) == none;\n     }\n \n     #[test]\n-    fn test_position_pred() {\n+    fn test_position() {\n         fn less_than_three(&&i: int) -> bool { ret i < 3; }\n         fn is_eighteen(&&i: int) -> bool { ret i == 18; }\n-        let v1: [int] = [5, 4, 3, 2, 1];\n-        assert position_pred(v1, less_than_three) == option::some::<uint>(3u);\n-        assert position_pred(v1, is_eighteen) == option::none::<uint>;\n+\n+        assert position([], less_than_three) == none;\n+\n+        let v1 = [5, 4, 3, 2, 1];\n+        assert position(v1, less_than_three) == some(3u);\n+        assert position(v1, is_eighteen) == none;\n+    }\n+\n+    #[test]\n+    fn test_position_from() {\n+        assert position_from([], 0u, 0u, f) == none;\n+\n+        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+        assert position_from(v, 0u, 0u, f) == none;\n+        assert position_from(v, 0u, 1u, f) == none;\n+        assert position_from(v, 0u, 2u, f) == some(1u);\n+        assert position_from(v, 0u, 3u, f) == some(1u);\n+        assert position_from(v, 0u, 4u, f) == some(1u);\n+\n+        assert position_from(v, 1u, 1u, f) == none;\n+        assert position_from(v, 1u, 2u, f) == some(1u);\n+        assert position_from(v, 1u, 3u, f) == some(1u);\n+        assert position_from(v, 1u, 4u, f) == some(1u);\n+\n+        assert position_from(v, 2u, 2u, f) == none;\n+        assert position_from(v, 2u, 3u, f) == none;\n+        assert position_from(v, 2u, 4u, f) == some(3u);\n+\n+        assert position_from(v, 3u, 3u, f) == none;\n+        assert position_from(v, 3u, 4u, f) == some(3u);\n+\n+        assert position_from(v, 4u, 4u, f) == none;\n+    }\n+\n+    #[test]\n+    fn test_find() {\n+        assert find([], f) == none;\n+\n+        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+        assert find(v, f) == some((1, 'b'));\n+        assert find(v, g) == none;\n+    }\n+\n+    #[test]\n+    fn test_find_from() {\n+        assert find_from([], 0u, 0u, f) == none;\n+\n+        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+        assert find_from(v, 0u, 0u, f) == none;\n+        assert find_from(v, 0u, 1u, f) == none;\n+        assert find_from(v, 0u, 2u, f) == some((1, 'b'));\n+        assert find_from(v, 0u, 3u, f) == some((1, 'b'));\n+        assert find_from(v, 0u, 4u, f) == some((1, 'b'));\n+\n+        assert find_from(v, 1u, 1u, f) == none;\n+        assert find_from(v, 1u, 2u, f) == some((1, 'b'));\n+        assert find_from(v, 1u, 3u, f) == some((1, 'b'));\n+        assert find_from(v, 1u, 4u, f) == some((1, 'b'));\n+\n+        assert find_from(v, 2u, 2u, f) == none;\n+        assert find_from(v, 2u, 3u, f) == none;\n+        assert find_from(v, 2u, 4u, f) == some((3, 'b'));\n+\n+        assert find_from(v, 3u, 3u, f) == none;\n+        assert find_from(v, 3u, 4u, f) == some((3, 'b'));\n+\n+        assert find_from(v, 4u, 4u, f) == none;\n+    }\n+\n+    #[test]\n+    fn test_rposition() {\n+        assert find([], f) == none;\n+\n+        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+        assert position(v, f) == some(1u);\n+        assert position(v, g) == none;\n+    }\n+\n+    #[test]\n+    fn test_rposition_from() {\n+        assert rposition_from([], 0u, 0u, f) == none;\n+\n+        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+        assert rposition_from(v, 0u, 0u, f) == none;\n+        assert rposition_from(v, 0u, 1u, f) == none;\n+        assert rposition_from(v, 0u, 2u, f) == some(1u);\n+        assert rposition_from(v, 0u, 3u, f) == some(1u);\n+        assert rposition_from(v, 0u, 4u, f) == some(3u);\n+\n+        assert rposition_from(v, 1u, 1u, f) == none;\n+        assert rposition_from(v, 1u, 2u, f) == some(1u);\n+        assert rposition_from(v, 1u, 3u, f) == some(1u);\n+        assert rposition_from(v, 1u, 4u, f) == some(3u);\n+\n+        assert rposition_from(v, 2u, 2u, f) == none;\n+        assert rposition_from(v, 2u, 3u, f) == none;\n+        assert rposition_from(v, 2u, 4u, f) == some(3u);\n+\n+        assert rposition_from(v, 3u, 3u, f) == none;\n+        assert rposition_from(v, 3u, 4u, f) == some(3u);\n+\n+        assert rposition_from(v, 4u, 4u, f) == none;\n+    }\n+\n+    #[test]\n+    fn test_rfind() {\n+        assert rfind([], f) == none;\n+\n+        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        fn g(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'd' }\n+        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+        assert rfind(v, f) == some((3, 'b'));\n+        assert rfind(v, g) == none;\n+    }\n+\n+    #[test]\n+    fn test_rfind_from() {\n+        assert rfind_from([], 0u, 0u, f) == none;\n+\n+        fn f(xy: (int, char)) -> bool { let (_x, y) = xy; y == 'b' }\n+        let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+        assert rfind_from(v, 0u, 0u, f) == none;\n+        assert rfind_from(v, 0u, 1u, f) == none;\n+        assert rfind_from(v, 0u, 2u, f) == some((1, 'b'));\n+        assert rfind_from(v, 0u, 3u, f) == some((1, 'b'));\n+        assert rfind_from(v, 0u, 4u, f) == some((3, 'b'));\n+\n+        assert rfind_from(v, 1u, 1u, f) == none;\n+        assert rfind_from(v, 1u, 2u, f) == some((1, 'b'));\n+        assert rfind_from(v, 1u, 3u, f) == some((1, 'b'));\n+        assert rfind_from(v, 1u, 4u, f) == some((3, 'b'));\n+\n+        assert rfind_from(v, 2u, 2u, f) == none;\n+        assert rfind_from(v, 2u, 3u, f) == none;\n+        assert rfind_from(v, 2u, 4u, f) == some((3, 'b'));\n+\n+        assert rfind_from(v, 3u, 3u, f) == none;\n+        assert rfind_from(v, 3u, 4u, f) == some((3, 'b'));\n+\n+        assert rfind_from(v, 4u, 4u, f) == none;\n     }\n \n     #[test]\n@@ -1495,6 +1873,48 @@ mod tests {\n         assert v == [1, 2];\n     }\n \n+    #[test]\n+    fn test_split() {\n+        fn f(&&x: int) -> bool { x == 3 }\n+\n+        assert split([], f) == [];\n+        assert split([1, 2], f) == [[1, 2]];\n+        assert split([3, 1, 2], f) == [[], [1, 2]];\n+        assert split([1, 2, 3], f) == [[1, 2], []];\n+        assert split([1, 2, 3, 4, 3, 5], f) == [[1, 2], [4], [5]];\n+    }\n+\n+    #[test]\n+    fn test_splitn() {\n+        fn f(&&x: int) -> bool { x == 3 }\n+\n+        assert splitn([], 1u, f) == [];\n+        assert splitn([1, 2], 1u, f) == [[1, 2]];\n+        assert splitn([3, 1, 2], 1u, f) == [[], [1, 2]];\n+        assert splitn([1, 2, 3], 1u, f) == [[1, 2], []];\n+        assert splitn([1, 2, 3, 4, 3, 5], 1u, f) == [[1, 2], [4, 3, 5]];\n+    }\n+\n+    #[test]\n+    fn test_rsplit() {\n+        fn f(&&x: int) -> bool { x == 3 }\n+\n+        assert rsplit([], f) == [];\n+        assert rsplit([1, 2], f) == [[1, 2]];\n+        assert rsplit([1, 2, 3], f) == [[1, 2], []];\n+        assert rsplit([1, 2, 3, 4, 3, 5], f) == [[1, 2], [4], [5]];\n+    }\n+\n+    #[test]\n+    fn test_rsplitn() {\n+        fn f(&&x: int) -> bool { x == 3 }\n+\n+        assert rsplitn([], 1u, f) == [];\n+        assert rsplitn([1, 2], 1u, f) == [[1, 2]];\n+        assert rsplitn([1, 2, 3], 1u, f) == [[1, 2], []];\n+        assert rsplitn([1, 2, 3, 4, 3, 5], 1u, f) == [[1, 2, 3, 4], [5]];\n+    }\n+\n     #[test]\n     // FIXME: Windows can't undwind\n     #[ignore(cfg(target_os = \"win32\"))]\n@@ -1513,6 +1933,13 @@ mod tests {\n         assert concat([[1], [2,3]]) == [1, 2, 3];\n     }\n \n+    #[test]\n+    fn test_connect() {\n+        assert connect([], 0) == [];\n+        assert connect([[1], [2, 3]], 0) == [1, 0, 2, 3];\n+        assert connect([[1], [2], [3]], 0) == [1, 0, 2, 0, 3];\n+    }\n+\n     #[test]\n     fn test_windowed () {\n         assert [[1u,2u,3u],[2u,3u,4u],[3u,4u,5u],[4u,5u,6u]]"}, {"sha": "48d83f0e5c2c825f452db3d15ca2382160ab2101", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "patch": "@@ -149,7 +149,7 @@ fn name_str(nm: name) -> str {\n }\n \n fn find_opt(opts: [opt], nm: name) -> option<uint> {\n-    vec::position_pred(opts, { |opt| opt.name == nm })\n+    vec::position(opts, { |opt| opt.name == nm })\n }\n \n /*"}, {"sha": "8da3d78552d5f452336db0cdc2cb34220bb683bc", "filename": "src/libstd/map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=91b6dc5c8ed8d839006de4ea6a7e8cd6727db93d", "patch": "@@ -95,6 +95,7 @@ iface map<K: copy, V: copy> {\n     Iterate over all the keys in the map\n     */\n     fn keys(fn(K));\n+\n     /*\n     Iterate over all the values in the map\n     */\n@@ -631,4 +632,4 @@ mod tests {\n         map.insert(key, \"val\");\n         assert (option::get(map.find(key)) == \"val\");\n     }\n-}\n\\ No newline at end of file\n+}"}]}