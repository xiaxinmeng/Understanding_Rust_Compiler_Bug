{"sha": "f7d0e0423b3874e348dcf322342c29f31f5f98d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZDBlMDQyM2IzODc0ZTM0OGRjZjMyMjM0MmMyOWYzMWY1Zjk4ZDk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-21T04:59:13Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-21T04:59:13Z"}, "message": "Support fat pointer reborrowing, length checking.", "tree": {"sha": "55e3f6612e9595543f2e1b79dfae08e070faa8c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55e3f6612e9595543f2e1b79dfae08e070faa8c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7d0e0423b3874e348dcf322342c29f31f5f98d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7d0e0423b3874e348dcf322342c29f31f5f98d9", "html_url": "https://github.com/rust-lang/rust/commit/f7d0e0423b3874e348dcf322342c29f31f5f98d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7d0e0423b3874e348dcf322342c29f31f5f98d9/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbd01d071a7e86b90b57f2db01113b7f2f4f9204", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd01d071a7e86b90b57f2db01113b7f2f4f9204", "html_url": "https://github.com/rust-lang/rust/commit/dbd01d071a7e86b90b57f2db01113b7f2f4f9204"}], "stats": {"total": 107, "additions": 72, "deletions": 35}, "files": [{"sha": "c6f840f71c24bc7e1a85f1496169595667f4e8d1", "filename": "src/interpreter.rs", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f7d0e0423b3874e348dcf322342c29f31f5f98d9/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7d0e0423b3874e348dcf322342c29f31f5f98d9/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=f7d0e0423b3874e348dcf322342c29f31f5f98d9", "patch": "@@ -74,6 +74,19 @@ struct Frame<'a, 'tcx: 'a> {\n     temp_offset: usize,\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+struct Lvalue {\n+    ptr: Pointer,\n+    extra: LvalueExtra,\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+enum LvalueExtra {\n+    None,\n+    Length(u64),\n+    // Vtable(memory::AllocId),\n+}\n+\n #[derive(Clone)]\n enum CachedMir<'mir, 'tcx: 'mir> {\n     Ref(&'mir mir::Mir<'tcx>),\n@@ -195,7 +208,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                let discr_ptr = try!(self.eval_lvalue(discr));\n+                let discr_ptr = try!(self.eval_lvalue(discr)).ptr;\n                 let discr_size = self.lvalue_repr(discr).size();\n                 let discr_val = try!(self.memory.read_uint(discr_ptr, discr_size));\n \n@@ -215,7 +228,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             Switch { ref discr, ref targets, .. } => {\n-                let adt_ptr = try!(self.eval_lvalue(discr));\n+                let adt_ptr = try!(self.eval_lvalue(discr)).ptr;\n                 let adt_repr = self.lvalue_repr(discr);\n                 let discr_size = match *adt_repr {\n                     Repr::Aggregate { discr_size, .. } => discr_size,\n@@ -229,7 +242,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                 let mut return_ptr = None;\n                 if let Some((ref lv, target)) = *destination {\n                     self.frame_mut().next_block = target;\n-                    return_ptr = Some(try!(self.eval_lvalue(lv)));\n+                    return_ptr = Some(try!(self.eval_lvalue(lv)).ptr);\n                 }\n \n                 let func_ty = self.operand_ty(func);\n@@ -475,7 +488,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n         -> EvalResult<()>\n     {\n-        let dest = try!(self.eval_lvalue(lvalue));\n+        let dest = try!(self.eval_lvalue(lvalue)).ptr;\n         let dest_repr = self.lvalue_repr(lvalue);\n \n         use rustc::mir::repr::Rvalue::*;\n@@ -532,22 +545,33 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             Len(ref lvalue) => {\n+                let src = try!(self.eval_lvalue(lvalue));\n                 let ty = self.lvalue_ty(lvalue);\n-                match ty.sty {\n-                    ty::TyArray(_, n) => {\n-                        let psize = self.memory.pointer_size;\n-                        self.memory.write_uint(dest, n as u64, psize)\n-                    }\n-                    ty::TySlice(_) => {\n-                        unimplemented!()\n-                    }\n+                let len = match ty.sty {\n+                    ty::TyArray(_, n) => n as u64,\n+                    ty::TySlice(_) => if let LvalueExtra::Length(n) = src.extra {\n+                        n\n+                    } else {\n+                        panic!(\"Rvalue::Len of a slice given non-slice pointer: {:?}\", src);\n+                    },\n                     _ => panic!(\"Rvalue::Len expected array or slice, got {:?}\", ty),\n-                }\n+                };\n+                let psize = self.memory.pointer_size;\n+                self.memory.write_uint(dest, len, psize)\n             }\n \n             Ref(_, _, ref lvalue) => {\n-                let ptr = try!(self.eval_lvalue(lvalue));\n-                self.memory.write_ptr(dest, ptr)\n+                let lv = try!(self.eval_lvalue(lvalue));\n+                try!(self.memory.write_ptr(dest, lv.ptr));\n+                match lv.extra {\n+                    LvalueExtra::None => {},\n+                    LvalueExtra::Length(len) => {\n+                        let psize = self.memory.pointer_size;\n+                        let len_ptr = dest.offset(psize as isize);\n+                        try!(self.memory.write_uint(len_ptr, len, psize));\n+                    }\n+                }\n+                Ok(())\n             }\n \n             Box(ty) => {\n@@ -557,18 +581,6 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             Cast(kind, ref operand, dest_ty) => {\n-                fn pointee_type<'tcx>(ptr_ty: ty::Ty<'tcx>) -> Option<ty::Ty<'tcx>> {\n-                    match ptr_ty.sty {\n-                        ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-                        ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-                        ty::TyBox(ty) => {\n-                            Some(ty)\n-                        }\n-\n-                        _ => None,\n-                    }\n-                }\n-\n                 let src = try!(self.eval_operand(operand));\n                 let src_ty = self.operand_ty(operand);\n \n@@ -597,7 +609,6 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                         // FIXME(tsion): Wrong for almost everything.\n                         let size = dest_repr.size();\n                         self.memory.copy(src, dest, size)\n-                        // panic!(\"can't handle cast: {:?}\", rvalue);\n                     }\n \n                     _ => panic!(\"can't handle cast: {:?}\", rvalue),\n@@ -622,7 +633,8 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n-            Consume(ref lvalue) => Ok((try!(self.eval_lvalue(lvalue)), self.lvalue_repr(lvalue))),\n+            Consume(ref lvalue) =>\n+                Ok((try!(self.eval_lvalue(lvalue)).ptr, self.lvalue_repr(lvalue))),\n             Constant(mir::Constant { ref literal, ty, .. }) => {\n                 use rustc::mir::repr::Literal::*;\n                 match *literal {\n@@ -649,7 +661,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         }\n     }\n \n-    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Pointer> {\n+    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n             ReturnPointer => self.frame().return_ptr\n@@ -659,8 +671,9 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             Temp(i) => self.frame().locals[self.frame().temp_offset + i as usize],\n \n             Projection(ref proj) => {\n-                let base_ptr = try!(self.eval_lvalue(&proj.base));\n+                let base_ptr = try!(self.eval_lvalue(&proj.base)).ptr;\n                 let base_repr = self.lvalue_repr(&proj.base);\n+                let base_ty = self.lvalue_ty(&proj.base);\n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n                     Field(field, _) => match *base_repr {\n@@ -676,11 +689,24 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                         _ => panic!(\"variant downcast on non-aggregate type: {:?}\", base_repr),\n                     },\n \n-                    // FIXME(tsion): Wrong for fat pointers.\n-                    Deref => try!(self.memory.read_ptr(base_ptr)),\n+                    Deref => {\n+                        let pointee_ty = pointee_type(base_ty).expect(\"Deref of non-pointer\");\n+                        println!(\"{:?}\", pointee_ty);\n+                        let ptr = try!(self.memory.read_ptr(base_ptr));\n+                        let extra = match pointee_ty.sty {\n+                            ty::TySlice(_) => {\n+                                let psize = self.memory.pointer_size;\n+                                let len_ptr = base_ptr.offset(psize as isize);\n+                                let len = try!(self.memory.read_uint(len_ptr, psize));\n+                                LvalueExtra::Length(len)\n+                            }\n+                            ty::TyTrait(_) => unimplemented!(),\n+                            _ => LvalueExtra::None,\n+                        };\n+                        return Ok(Lvalue { ptr: ptr, extra: extra });\n+                    }\n \n                     Index(ref operand) => {\n-                        let base_ty = self.lvalue_ty(&proj.base);\n                         let elem_size = match base_ty.sty {\n                             ty::TyArray(elem_ty, _) => self.ty_size(elem_ty),\n                             ty::TySlice(elem_ty) => self.ty_size(elem_ty),\n@@ -698,7 +724,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             ref l => panic!(\"can't handle lvalue: {:?}\", l),\n         };\n \n-        Ok(ptr)\n+        Ok(Lvalue { ptr: ptr, extra: LvalueExtra::None })\n     }\n \n     // TODO(tsion): Try making const_to_primval instead.\n@@ -1004,6 +1030,17 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     }\n }\n \n+fn pointee_type<'tcx>(ptr_ty: ty::Ty<'tcx>) -> Option<ty::Ty<'tcx>> {\n+    match ptr_ty.sty {\n+        ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+        ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+        ty::TyBox(ty) => {\n+            Some(ty)\n+        }\n+        _ => None,\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n     type Target = mir::Mir<'tcx>;\n     fn deref(&self) -> &mir::Mir<'tcx> {"}]}