{"sha": "b8329da5e88683bf497f5584d2dde2b824cb86b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MzI5ZGE1ZTg4NjgzYmY0OTdmNTU4NGQyZGRlMmI4MjRjYjg2YjY=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-29T07:53:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-29T07:53:34Z"}, "message": "Merge pull request #311 from RalfJung/memory\n\nMemory API refactoring", "tree": {"sha": "23fccdea7ca314b3e83c4873eebe8b2894322d39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23fccdea7ca314b3e83c4873eebe8b2894322d39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8329da5e88683bf497f5584d2dde2b824cb86b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8329da5e88683bf497f5584d2dde2b824cb86b6", "html_url": "https://github.com/rust-lang/rust/commit/b8329da5e88683bf497f5584d2dde2b824cb86b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8329da5e88683bf497f5584d2dde2b824cb86b6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44a360d8ba3cd77e86fcb510808e2b1c550d4c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/44a360d8ba3cd77e86fcb510808e2b1c550d4c46", "html_url": "https://github.com/rust-lang/rust/commit/44a360d8ba3cd77e86fcb510808e2b1c550d4c46"}, {"sha": "55eaf5eb5e5854f7f7b47e9a990ef17fbc505f14", "url": "https://api.github.com/repos/rust-lang/rust/commits/55eaf5eb5e5854f7f7b47e9a990ef17fbc505f14", "html_url": "https://github.com/rust-lang/rust/commit/55eaf5eb5e5854f7f7b47e9a990ef17fbc505f14"}], "stats": {"total": 1013, "additions": 466, "deletions": 547}, "files": [{"sha": "00ae333b4671c0981f3c902e238aa505e2530880", "filename": "Cargo.lock", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -21,24 +21,24 @@ dependencies = [\n [[package]]\n name = \"backtrace\"\n version = \"0.3.2\"\n-source = \"git+https://github.com/alexcrichton/backtrace-rs#3d96a9242ed2096984d15d177f4762b699bee6d4\"\n+source = \"git+https://github.com/alexcrichton/backtrace-rs#ac8f8d150ad114b735a020c37762426fc7ad18c4\"\n dependencies = [\n  \"backtrace-sys 0.1.12 (git+https://github.com/alexcrichton/backtrace-rs)\",\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"backtrace-sys\"\n version = \"0.1.12\"\n-source = \"git+https://github.com/alexcrichton/backtrace-rs#3d96a9242ed2096984d15d177f4762b699bee6d4\"\n+source = \"git+https://github.com/alexcrichton/backtrace-rs#ac8f8d150ad114b735a020c37762426fc7ad18c4\"\n dependencies = [\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -99,7 +99,7 @@ dependencies = [\n \n [[package]]\n name = \"dtoa\"\n-version = \"0.4.1\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -113,12 +113,12 @@ dependencies = [\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.51\"\n+version = \"0.3.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"itoa\"\n-version = \"0.3.1\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -137,7 +137,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.28\"\n+version = \"0.2.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -175,7 +175,7 @@ name = \"memchr\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -207,7 +207,7 @@ name = \"rand\"\n version = \"0.3.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -230,7 +230,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.4\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -267,8 +267,8 @@ name = \"serde_json\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -353,13 +353,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum conv 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"78ff10625fd0ac447827aa30ea8b861fead473bb60aeb73af6c1c58caf0d1299\"\n \"checksum custom_derive 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef8ae57c4978a2acd8b869ce6b9ca1dfe817bff704c220209fdef2c0b75a01b9\"\n \"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n-\"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n+\"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n-\"checksum gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\" = \"120d07f202dcc3f72859422563522b66fe6463a4c513df062874daad05f85f0a\"\n-\"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n+\"checksum gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8310f7e9c890398b0e80e301c4f474e9918d2b27fca8f48486ca775fa9ffc5a\"\n+\"checksum itoa 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f74cf6ca1bdbc28496a2b9798ab7fccc2ca5a42cace95bb2b219577216a5fb90\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n-\"checksum libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb7b49972ee23d8aa1026c365a5b440ba08e35075f18c459980c7395c221ec48\"\n+\"checksum libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2370ca07ec338939e356443dac2296f581453c35fe1e3a3ed06023c49435f915\"\n \"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n \"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n \"checksum magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4bf0336886480e671965f794bc9b6fce88503563013d1bfb7a502c81fe3ac527\"\n@@ -370,7 +370,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rand 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb250fd207a4729c976794d03db689c9be1d634ab5a1c9da9492a13d8fecbcdf\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n-\"checksum rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3058a43ada2c2d0b92b3ae38007a2d0fa5e9db971be260e0171408a4ff471c95\"\n+\"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7726f29ddf9731b17ff113c461e362c381d9d69433f79de4f3dd572488823e9\"\n \"checksum serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf823e706be268e73e7747b147aa31c8f633ab4ba31f115efb57e5047c3a76dd\""}, {"sha": "337a723a40d6e16b173976b883b7fd2fbd9942b8", "filename": "miri/bin/miri.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/miri%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/miri%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fmiri.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -19,7 +19,11 @@ use rustc::ty::TyCtxt;\n use syntax::ast::{self, MetaItemKind, NestedMetaItemKind};\n use std::path::PathBuf;\n \n-struct MiriCompilerCalls(RustcDefaultCalls);\n+struct MiriCompilerCalls {\n+    default: RustcDefaultCalls,\n+    /// whether we are building for the host\n+    host_target: bool,\n+}\n \n impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n     fn early_callback(\n@@ -30,7 +34,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         descriptions: &rustc_errors::registry::Registry,\n         output: ErrorOutputType,\n     ) -> Compilation {\n-        self.0.early_callback(\n+        self.default.early_callback(\n             matches,\n             sopts,\n             cfg,\n@@ -47,7 +51,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         ofile: &Option<PathBuf>,\n         descriptions: &rustc_errors::registry::Registry,\n     ) -> Option<(Input, Option<PathBuf>)> {\n-        self.0.no_input(\n+        self.default.no_input(\n             matches,\n             sopts,\n             cfg,\n@@ -64,17 +68,17 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n     ) -> Compilation {\n-        self.0.late_callback(matches, sess, input, odir, ofile)\n+        self.default.late_callback(matches, sess, input, odir, ofile)\n     }\n     fn build_controller(\n         &mut self,\n         sess: &Session,\n         matches: &getopts::Matches,\n     ) -> CompileController<'a> {\n-        let mut control = self.0.build_controller(sess, matches);\n+        let mut control = self.default.build_controller(sess, matches);\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n         control.after_analysis.callback = Box::new(after_analysis);\n-        if std::env::var(\"MIRI_HOST_TARGET\") != Ok(\"yes\".to_owned()) {\n+        if !self.host_target {\n             // only fully compile targets on the host\n             control.after_analysis.stop = Compilation::Stop;\n         }\n@@ -254,6 +258,16 @@ fn main() {\n \n     // for auxilary builds in unit tests\n     args.push(\"-Zalways-encode-mir\".to_owned());\n+    let mut host_target = false;\n+    args.retain(|arg| if arg == \"--miri_host_target\" {\n+        host_target = true;\n+        false // remove the flag, rustc doesn't know it\n+    } else {\n+        true\n+    });\n \n-    rustc_driver::run_compiler(&args, &mut MiriCompilerCalls(RustcDefaultCalls), None, None);\n+    rustc_driver::run_compiler(&args, &mut MiriCompilerCalls {\n+        default: RustcDefaultCalls,\n+        host_target,\n+    }, None, None);\n }"}, {"sha": "7dc8f54849f0af0d359882f6bb7f3aabd5e9d45b", "filename": "miri/fn_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -421,11 +421,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                // TODO: Does this need checking for alignment?\n-                self.memory.write_uint(\n+                self.memory.write_primval(\n                     key_ptr.to_ptr()?,\n-                    key,\n+                    PrimVal::Bytes(key),\n                     key_size.bytes(),\n+                    false,\n                 )?;\n \n                 // Return success (0)"}, {"sha": "8c722a46ae3081df68d8d12c02c7e5c81f430040", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::Layout;\n use rustc::ty::{self, Ty};\n \n use rustc_miri::interpret::{EvalResult, Lvalue, LvalueExtra, PrimVal, PrimValKind, Value, Pointer,\n-                            HasMemory, EvalContext, PtrAndAlign, ValTy};\n+                            HasMemory, AccessKind, EvalContext, PtrAndAlign, ValTy};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n \n@@ -624,7 +624,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n                     // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n-                    self.memory.check_align(ptr, ty_align)?;\n+                    self.memory.check_align(ptr, ty_align, Some(AccessKind::Write))?;\n                     self.memory.write_repeat(ptr, val_byte, size * count)?;\n                 }\n             }"}, {"sha": "f2ad1c2c3b0d6db8bdf3a470031470e2610ff408", "filename": "rustc_tests/Cargo.lock", "status": "modified", "additions": 67, "deletions": 92, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/rustc_tests%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/rustc_tests%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2FCargo.lock?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -13,25 +13,47 @@ dependencies = [\n  \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"backtrace\"\n+version = \"0.3.2\"\n+source = \"git+https://github.com/alexcrichton/backtrace-rs#ac8f8d150ad114b735a020c37762426fc7ad18c4\"\n+dependencies = [\n+ \"backtrace-sys 0.1.12 (git+https://github.com/alexcrichton/backtrace-rs)\",\n+ \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"backtrace-sys\"\n+version = \"0.1.12\"\n+source = \"git+https://github.com/alexcrichton/backtrace-rs#ac8f8d150ad114b735a020c37762426fc7ad18c4\"\n+dependencies = [\n+ \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"byteorder\"\n version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n-name = \"cargo_metadata\"\n-version = \"0.2.3\"\n+name = \"cfg-if\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n-name = \"dtoa\"\n-version = \"0.4.1\"\n+name = \"dbghelp-sys\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n name = \"env_logger\"\n@@ -43,10 +65,19 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"itoa\"\n-version = \"0.3.1\"\n+name = \"gcc\"\n+version = \"0.3.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"0.2.8\"\n@@ -83,23 +114,12 @@ name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_miri 0.1.0\",\n ]\n \n-[[package]]\n-name = \"num-traits\"\n-version = \"0.1.40\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"quote\"\n-version = \"0.3.15\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"regex\"\n version = \"0.2.2\"\n@@ -117,70 +137,23 @@ name = \"regex-syntax\"\n version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"rustc_miri\"\n version = \"0.1.0\"\n dependencies = [\n+ \"backtrace 0.3.2 (git+https://github.com/alexcrichton/backtrace-rs)\",\n  \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"serde\"\n-version = \"1.0.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"serde_derive\"\n-version = \"1.0.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"serde_derive_internals\"\n-version = \"0.15.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"serde_json\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"syn\"\n-version = \"0.11.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"synom\"\n-version = \"0.11.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"thread_local\"\n version = \"0.3.4\"\n@@ -190,11 +163,6 @@ dependencies = [\n  \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"unicode-xid\"\n-version = \"0.0.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"unreachable\"\n version = \"1.0.0\"\n@@ -213,30 +181,37 @@ name = \"void\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [metadata]\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n+\"checksum backtrace 0.3.2 (git+https://github.com/alexcrichton/backtrace-rs)\" = \"<none>\"\n+\"checksum backtrace-sys 0.1.12 (git+https://github.com/alexcrichton/backtrace-rs)\" = \"<none>\"\n \"checksum byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff81738b726f5d099632ceaffe7fb65b90212e8dce59d518729e7e8634032d3d\"\n-\"checksum cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be1057b8462184f634c3a208ee35b0f935cfd94b694b26deadccd98732088d7b\"\n-\"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n+\"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n+\"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n-\"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n+\"checksum gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8310f7e9c890398b0e80e301c4f474e9918d2b27fca8f48486ca775fa9ffc5a\"\n+\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n \"checksum libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb7b49972ee23d8aa1026c365a5b440ba08e35075f18c459980c7395c221ec48\"\n \"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n \"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n-\"checksum num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99843c856d68d8b4313b03a17e33c4bb42ae8f6610ea81b28abe076ac721b9b0\"\n-\"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n-\"checksum serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7726f29ddf9731b17ff113c461e362c381d9d69433f79de4f3dd572488823e9\"\n-\"checksum serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf823e706be268e73e7747b147aa31c8f633ab4ba31f115efb57e5047c3a76dd\"\n-\"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n-\"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n-\"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n-\"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n+\"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n \"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\"\n-\"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n \"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n+\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n+\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "ea699833f6f60bbc5c73a1d2f5649394f2c2871e", "filename": "rustc_tests/src/main.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/rustc_tests%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/rustc_tests%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2Fsrc%2Fmain.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -20,7 +20,11 @@ use rustc::hir::{self, itemlikevisit};\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n-struct MiriCompilerCalls(RustcDefaultCalls);\n+struct MiriCompilerCalls {\n+    default: RustcDefaultCalls,\n+    /// whether we are building for the host\n+    host_target: bool,\n+}\n \n impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n     fn early_callback(\n@@ -31,7 +35,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         descriptions: &rustc_errors::registry::Registry,\n         output: ErrorOutputType\n     ) -> Compilation {\n-        self.0.early_callback(matches, sopts, cfg, descriptions, output)\n+        self.default.early_callback(matches, sopts, cfg, descriptions, output)\n     }\n     fn no_input(\n         &mut self,\n@@ -42,7 +46,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         ofile: &Option<PathBuf>,\n         descriptions: &rustc_errors::registry::Registry\n     ) -> Option<(Input, Option<PathBuf>)> {\n-        self.0.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n+        self.default.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n     }\n     fn late_callback(\n         &mut self,\n@@ -52,13 +56,13 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>\n     ) -> Compilation {\n-        self.0.late_callback(matches, sess, input, odir, ofile)\n+        self.default.late_callback(matches, sess, input, odir, ofile)\n     }\n     fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n-        let mut control = self.0.build_controller(sess, matches);\n+        let mut control = self.default.build_controller(sess, matches);\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n         control.after_analysis.callback = Box::new(after_analysis);\n-        if std::env::var(\"MIRI_HOST_TARGET\") != Ok(\"yes\".to_owned()) {\n+        if !self.host_target {\n             // only fully compile targets on the host\n             control.after_analysis.stop = Compilation::Stop;\n         }\n@@ -139,7 +143,15 @@ fn main() {\n         }\n         let stderr = std::io::stderr();\n         write!(stderr.lock(), \"test [miri-pass] {} ... \", path.display()).unwrap();\n-        let mut args: Vec<String> = std::env::args().collect();\n+        let mut host_target = false;\n+        let mut args: Vec<String> = std::env::args().filter(|arg| {\n+            if arg == \"--miri_host_target\" {\n+                host_target = true;\n+                false // remove the flag, rustc doesn't know it\n+            } else {\n+                true\n+            }\n+        }).collect();\n         // file to process\n         args.push(path.display().to_string());\n \n@@ -168,7 +180,10 @@ fn main() {\n         let buf = BufWriter::default();\n         let output = buf.clone();\n         let result = std::panic::catch_unwind(|| {\n-            rustc_driver::run_compiler(&args, &mut MiriCompilerCalls(RustcDefaultCalls), None, Some(Box::new(buf)));\n+            rustc_driver::run_compiler(&args, &mut MiriCompilerCalls {\n+                default: RustcDefaultCalls,\n+                host_target,\n+            }, None, Some(Box::new(buf)));\n         });\n \n         match result {"}, {"sha": "2f45347d113c2cb0734370f845e2d58b603b92aa", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -10,6 +10,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n+        trace!(\"Casting {:?}: {:?} to {:?}\", val, src_ty, dest_ty);\n         let src_kind = self.ty_to_primval_kind(src_ty)?;\n \n         match val {"}, {"sha": "044f37947d30e276b3a7e62e5dec35796acf0366", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 161, "deletions": 57, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -578,12 +578,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         discr_val: u128,\n         variant_idx: usize,\n         discr_size: u64,\n+        discr_signed: bool,\n     ) -> EvalResult<'tcx> {\n         // FIXME(solson)\n         let dest_ptr = self.force_allocation(dest)?.to_ptr()?;\n \n         let discr_dest = dest_ptr.offset(discr_offset, &self)?;\n-        self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n+        self.memory.write_primval(discr_dest, PrimVal::Bytes(discr_val), discr_size, discr_signed)?;\n \n         let dest = Lvalue::Ptr {\n             ptr: PtrAndAlign {\n@@ -723,6 +724,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 discr_val,\n                                 variant,\n                                 discr_size,\n+                                false,\n                             )?;\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::General\", kind);\n@@ -765,24 +767,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                     let operand_ty = self.operand_ty(operand);\n                                     assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                let (offset, TyAndPacked { ty, packed: _ }) =\n-                                    self.nonnull_offset_and_ty(\n-                                        dest_ty,\n-                                        nndiscr,\n-                                        discrfield_source,\n-                                    )?;\n-                                // TODO: The packed flag is ignored\n-\n-                                // FIXME(solson)\n-                                let dest = self.force_allocation(dest)?.to_ptr()?;\n-\n-                                let dest = dest.offset(offset.bytes(), &self)?;\n-                                let dest_size = self.type_size(ty)?.expect(\n-                                    \"bad StructWrappedNullablePointer discrfield\",\n-                                );\n-                                self.memory.write_maybe_aligned_mut(\n-                                    !nonnull.packed,\n-                                    |mem| mem.write_int(dest, 0, dest_size),\n+                                self.write_struct_wrapped_null_pointer(\n+                                    dest_ty,\n+                                    nndiscr,\n+                                    discrfield_source,\n+                                    dest,\n                                 )?;\n                             }\n                         } else {\n@@ -997,16 +986,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let ptr = self.force_allocation(lval)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(ptr, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n+                    trace!(\"Read discriminant {}, valid discriminants {:?}\", discr_val, adt_def.discriminants(self.tcx).collect::<Vec<_>>());\n                     if adt_def.discriminants(self.tcx).all(|v| {\n                         discr_val != v.to_u128_unchecked()\n                     })\n                     {\n                         return err!(InvalidDiscriminant);\n                     }\n+                    self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n                 } else {\n                     bug!(\"rustc only generates Rvalue::Discriminant for enums\");\n                 }\n-                self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n         }\n \n@@ -1017,6 +1007,33 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n+    pub(crate) fn write_struct_wrapped_null_pointer(\n+        &mut self,\n+        dest_ty: ty::Ty<'tcx>,\n+        nndiscr: u64,\n+        discrfield_source: &layout::FieldPath,\n+        dest: Lvalue,\n+    ) -> EvalResult<'tcx> {\n+        let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n+            dest_ty,\n+            nndiscr,\n+            discrfield_source,\n+        )?;\n+        let nonnull = self.force_allocation(dest)?.to_ptr()?.offset(\n+            offset.bytes(),\n+            &self,\n+        )?;\n+        trace!(\"struct wrapped nullable pointer type: {}\", ty);\n+        // only the pointer part of a fat pointer is used for this space optimization\n+        let discr_size = self.type_size(ty)?.expect(\n+            \"bad StructWrappedNullablePointer discrfield\",\n+        );\n+        self.memory.write_maybe_aligned_mut(!packed, |mem| {\n+            // We're writing 0, signedness does not matter\n+            mem.write_primval(nonnull, PrimVal::Bytes(0), discr_size, false)\n+        })\n+    }\n+\n     pub(super) fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::TyRawPtr(ref tam) |\n@@ -1294,6 +1311,96 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n+    pub fn read_discriminant_value(\n+        &self,\n+        adt_ptr: MemoryPointer,\n+        adt_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, u128> {\n+        use rustc::ty::layout::Layout::*;\n+        let adt_layout = self.type_layout(adt_ty)?;\n+        //trace!(\"read_discriminant_value {:#?}\", adt_layout);\n+\n+        let discr_val = match *adt_layout {\n+            General { discr, .. } => {\n+                let discr_size = discr.size().bytes();\n+                self.memory.read_primval(adt_ptr, discr_size, false)?.to_bytes()?\n+            }\n+\n+            CEnum {\n+                discr,\n+                signed,\n+                ..\n+            } => {\n+                let discr_size = discr.size().bytes();\n+                self.memory.read_primval(adt_ptr, discr_size, signed)?.to_bytes()?\n+            }\n+\n+            RawNullablePointer { nndiscr, value } => {\n+                let discr_size = value.size(&self.tcx.data_layout).bytes();\n+                trace!(\"rawnullablepointer with size {}\", discr_size);\n+                self.read_nonnull_discriminant_value(\n+                    adt_ptr,\n+                    nndiscr as u128,\n+                    discr_size,\n+                )?\n+            }\n+\n+            StructWrappedNullablePointer {\n+                nndiscr,\n+                ref discrfield_source,\n+                ..\n+            } => {\n+                let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n+                    adt_ty,\n+                    nndiscr,\n+                    discrfield_source,\n+                )?;\n+                let nonnull = adt_ptr.offset(offset.bytes(), &*self)?;\n+                trace!(\"struct wrapped nullable pointer type: {}\", ty);\n+                // only the pointer part of a fat pointer is used for this space optimization\n+                let discr_size = self.type_size(ty)?.expect(\n+                    \"bad StructWrappedNullablePointer discrfield\",\n+                );\n+                self.read_maybe_aligned(!packed, |ectx| {\n+                    ectx.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size)\n+                })?\n+            }\n+\n+            // The discriminant_value intrinsic returns 0 for non-sum types.\n+            Array { .. } |\n+            FatPointer { .. } |\n+            Scalar { .. } |\n+            Univariant { .. } |\n+            Vector { .. } |\n+            UntaggedUnion { .. } => 0,\n+        };\n+\n+        Ok(discr_val)\n+    }\n+\n+    fn read_nonnull_discriminant_value(\n+        &self,\n+        ptr: MemoryPointer,\n+        nndiscr: u128,\n+        discr_size: u64,\n+    ) -> EvalResult<'tcx, u128> {\n+        trace!(\n+            \"read_nonnull_discriminant_value: {:?}, {}, {}\",\n+            ptr,\n+            nndiscr,\n+            discr_size\n+        );\n+        // We are only interested in 0 vs. non-0, the sign does not matter for this\n+        let null = match self.memory.read_primval(ptr, discr_size, false)? {\n+            PrimVal::Bytes(0) => true,\n+            PrimVal::Bytes(_) |\n+            PrimVal::Ptr(..) => false,\n+            PrimVal::Undef => return err!(ReadUndefBytes),\n+        };\n+        assert!(nndiscr == 0 || nndiscr == 1);\n+        Ok(if !null { nndiscr } else { 1 - nndiscr })\n+    }\n+\n     pub fn read_global_as_value(&self, gid: GlobalId) -> Value {\n         Value::ByRef(*self.globals.get(&gid).expect(\"global not cached\"))\n     }\n@@ -1515,7 +1622,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n-                self.memory.write_primval(dest, primval, size)\n+                if size == 0 {\n+                    assert!(primval.is_undef());\n+                    Ok(())\n+                } else {\n+                    // TODO: Do we need signedness?\n+                    self.memory.write_primval(dest.to_ptr()?, primval, size, false)\n+                }\n             }\n             Value::ByValPair(a, b) => self.write_pair_to_ptr(a, b, dest.to_ptr()?, dest_ty),\n         }\n@@ -1553,11 +1666,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         );\n         let field_0_ptr = ptr.offset(field_0.bytes(), &self)?.into();\n         let field_1_ptr = ptr.offset(field_1.bytes(), &self)?.into();\n+        // TODO: What about signedess?\n         self.write_maybe_aligned_mut(!packed, |ectx| {\n-            ectx.memory.write_primval(field_0_ptr, a, field_0_size)\n+            ectx.memory.write_primval(field_0_ptr, a, field_0_size, false)\n         })?;\n         self.write_maybe_aligned_mut(!packed, |ectx| {\n-            ectx.memory.write_primval(field_1_ptr, b, field_1_size)\n+            ectx.memory.write_primval(field_1_ptr, b, field_1_size, false)\n         })?;\n         Ok(())\n     }\n@@ -1675,18 +1789,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ptr: MemoryPointer,\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n-        let p = self.memory.read_ptr(ptr)?;\n+        let ptr_size = self.memory.pointer_size();\n+        let p : Pointer = self.memory.read_ptr_sized_unsigned(ptr)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n-            let extra = ptr.offset(self.memory.pointer_size(), self)?;\n+            let extra = ptr.offset(ptr_size, self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n-                    self.memory.read_ptr(extra)?.to_ptr()?,\n+                    self.memory.read_ptr_sized_unsigned(extra)?.to_ptr()?,\n                 )),\n                 ty::TySlice(..) | ty::TyStr => Ok(\n-                    p.to_value_with_len(self.memory.read_usize(extra)?),\n+                    p.to_value_with_len(self.memory.read_ptr_sized_unsigned(extra)?.to_bytes()? as u64),\n                 ),\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             }\n@@ -1696,10 +1811,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn try_read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n+        let ptr = ptr.to_ptr()?;\n         let val = match ty.sty {\n-            ty::TyBool => PrimVal::from_bool(self.memory.read_bool(ptr.to_ptr()?)?),\n+            ty::TyBool => {\n+                let val = self.memory.read_primval(ptr, 1, false)?;\n+                let val = match val {\n+                    PrimVal::Bytes(0) => false,\n+                    PrimVal::Bytes(1) => true,\n+                    _ => return err!(InvalidBool),\n+                };\n+                PrimVal::from_bool(val)\n+            }\n             ty::TyChar => {\n-                let c = self.memory.read_uint(ptr.to_ptr()?, 4)? as u32;\n+                let c = self.memory.read_primval(ptr, 4, false)?.to_bytes()? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::from_char(ch),\n                     None => return err!(InvalidChar(c as u128)),\n@@ -1716,15 +1840,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     I128 => 16,\n                     Is => self.memory.pointer_size(),\n                 };\n-                // if we transmute a ptr to an isize, reading it back into a primval shouldn't panic\n-                // Due to read_ptr ignoring the sign, we need to jump around some hoops\n-                match self.memory.read_int(ptr.to_ptr()?, size) {\n-                    Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. }) if size == self.memory.pointer_size() =>\n-                        // Reading as an int failed because we are seeing ptr bytes *and* we are actually reading at ptr size.\n-                        // Let's try again, reading a ptr this time.\n-                        self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n-                    other => PrimVal::from_i128(other?),\n-                }\n+                self.memory.read_primval(ptr, size, true)?\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1737,36 +1853,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     U128 => 16,\n                     Us => self.memory.pointer_size(),\n                 };\n-                // if we transmute a ptr to an usize, reading it back into a primval shouldn't panic\n-                // for consistency's sake, we use the same code as above\n-                match self.memory.read_uint(ptr.to_ptr()?, size) {\n-                    Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. })\n-                        if size == self.memory.pointer_size() => {\n-                        self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval()\n-                    }\n-                    other => PrimVal::from_u128(other?),\n-                }\n+                self.memory.read_primval(ptr, size, false)?\n             }\n \n-            ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr.to_ptr()?)?),\n-            ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr.to_ptr()?)?),\n+            ty::TyFloat(FloatTy::F32) => PrimVal::Bytes(self.memory.read_primval(ptr, 4, false)?.to_bytes()?),\n+            ty::TyFloat(FloatTy::F64) => PrimVal::Bytes(self.memory.read_primval(ptr, 8, false)?.to_bytes()?),\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n+            ty::TyFnPtr(_) => self.memory.read_ptr_sized_unsigned(ptr)?,\n             ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr.to_ptr()?, tam.ty).map(Some),\n+            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, tam.ty).map(Some),\n \n             ty::TyAdt(def, _) => {\n                 if def.is_box() {\n-                    return self.read_ptr(ptr.to_ptr()?, ty.boxed_ty()).map(Some);\n+                    return self.read_ptr(ptr, ty.boxed_ty()).map(Some);\n                 }\n                 use rustc::ty::layout::Layout::*;\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes();\n-                    if signed {\n-                        PrimVal::from_i128(self.memory.read_int(ptr.to_ptr()?, size)?)\n-                    } else {\n-                        PrimVal::from_u128(self.memory.read_uint(ptr.to_ptr()?, size)?)\n-                    }\n+                    self.memory.read_primval(ptr, size, signed)?\n                 } else {\n                     return Ok(None);\n                 }"}, {"sha": "e1a0a7d365908bf124c72bf029673c99212fbc20", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 107, "deletions": 202, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -3,7 +3,7 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, ptr, mem, io};\n use std::cell::Cell;\n \n-use rustc::ty;\n+use rustc::ty::Instance;\n use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n use syntax::ast::Mutability;\n use rustc::middle::region::CodeExtent;\n@@ -250,10 +250,10 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n \n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: Vec<ty::Instance<'tcx>>,\n+    functions: Vec<Instance<'tcx>>,\n \n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n-    function_alloc_cache: HashMap<ty::Instance<'tcx>, AllocId>,\n+    function_alloc_cache: HashMap<Instance<'tcx>, AllocId>,\n \n     /// Target machine data layout to emulate.\n     pub layout: &'a TargetDataLayout,\n@@ -297,7 +297,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         })\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> MemoryPointer {\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&instance) {\n             return MemoryPointer::new(alloc_id, 0);\n         }\n@@ -476,27 +476,38 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     /// Check that the pointer is aligned AND non-NULL.\n-    pub fn check_align(&self, ptr: Pointer, align: u64) -> EvalResult<'tcx> {\n-        let offset = match ptr.into_inner_primval() {\n+    pub fn check_align(&self, ptr: Pointer, align: u64, access: Option<AccessKind>) -> EvalResult<'tcx> {\n+        // Check non-NULL/Undef, extract offset\n+        let (offset, alloc_align) = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n-                if alloc.align < align {\n-                    return err!(AlignmentCheckFailed {\n-                        has: alloc.align,\n-                        required: align,\n-                    });\n-                }\n-                ptr.offset\n+                (ptr.offset, alloc.align)\n             }\n             PrimVal::Bytes(bytes) => {\n                 let v = ((bytes as u128) % (1 << self.pointer_size())) as u64;\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n-                v\n+                (v, align) // the base address if the \"integer allocation\" is 0 and hence always aligned\n             }\n             PrimVal::Undef => return err!(ReadUndefBytes),\n         };\n+        // See if alignment checking is disabled\n+        let enforce_alignment = match access {\n+            Some(AccessKind::Read) => self.reads_are_aligned.get(),\n+            Some(AccessKind::Write) => self.writes_are_aligned.get(),\n+            None => true,\n+        };\n+        if !enforce_alignment {\n+            return Ok(());\n+        }\n+        // Check alignment\n+        if alloc_align < align {\n+            return err!(AlignmentCheckFailed {\n+                has: alloc_align,\n+                required: align,\n+            });\n+        }\n         if offset % align == 0 {\n             Ok(())\n         } else {\n@@ -804,7 +815,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n+    fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n         let alloc = self.get_mut_unchecked(id)?;\n         if alloc.mutable == Mutability::Mutable {\n             Ok(alloc)\n@@ -813,7 +824,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Instance<'tcx>> {\n         if ptr.offset != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n@@ -933,9 +944,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         align: u64,\n     ) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        if self.reads_are_aligned.get() {\n-            self.check_align(ptr.into(), align)?;\n-        }\n+        self.check_align(ptr.into(), align, Some(AccessKind::Read))?;\n         if size == 0 {\n             return Ok(&[]);\n         }\n@@ -955,9 +964,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         align: u64,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        if self.writes_are_aligned.get() {\n-            self.check_align(ptr.into(), align)?;\n-        }\n+        self.check_align(ptr.into(), align, Some(AccessKind::Write))?;\n         if size == 0 {\n             return Ok(&mut []);\n         }\n@@ -995,7 +1002,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n /// Reading and writing\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     /// mark an allocation pointed to by a static as static and initialized\n-    pub fn mark_inner_allocation(\n+    fn mark_inner_allocation_initialized(\n         &mut self,\n         alloc: AllocId,\n         mutability: Mutability,\n@@ -1056,7 +1063,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.mark_inner_allocation(alloc, mutability)?;\n+            self.mark_inner_allocation_initialized(alloc, mutability)?;\n         }\n         // put back the relocations\n         self.alloc_map\n@@ -1074,14 +1081,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         align: u64,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n+        // Empty accesses don't need to be valid pointers, but they should still be aligned\n+        self.check_align(src, align, Some(AccessKind::Read))?;\n+        self.check_align(dest, align, Some(AccessKind::Write))?;\n         if size == 0 {\n-            // Empty accesses don't need to be valid pointers, but they should still be aligned\n-            if self.reads_are_aligned.get() {\n-                self.check_align(src, align)?;\n-            }\n-            if self.writes_are_aligned.get() {\n-                self.check_align(dest, align)?;\n-            }\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -1148,22 +1151,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n+        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+        self.check_align(ptr, 1, Some(AccessKind::Read))?;\n         if size == 0 {\n-            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.reads_are_aligned.get() {\n-                self.check_align(ptr, 1)?;\n-            }\n             return Ok(&[]);\n         }\n         self.get_bytes(ptr.to_ptr()?, size, 1)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n+        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+        self.check_align(ptr, 1, Some(AccessKind::Write))?;\n         if src.is_empty() {\n-            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.writes_are_aligned.get() {\n-                self.check_align(ptr, 1)?;\n-            }\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, 1)?;\n@@ -1172,11 +1171,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n+        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+        self.check_align(ptr, 1, Some(AccessKind::Write))?;\n         if count == 0 {\n-            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.writes_are_aligned.get() {\n-                self.check_align(ptr, 1)?;\n-            }\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, 1)?;\n@@ -1186,40 +1183,48 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_ptr(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Pointer> {\n-        let size = self.pointer_size();\n+    pub fn read_primval(&self, ptr: MemoryPointer, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianess = self.endianess();\n-        let bytes = self.get_bytes_unchecked(ptr, size, size)?;\n+        let bytes = self.get_bytes_unchecked(ptr, size, self.int_align(size))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n             return Ok(PrimVal::Undef.into());\n         }\n-        let offset = read_target_uint(endianess, bytes).unwrap();\n-        assert_eq!(offset as u64 as u128, offset);\n-        let offset = offset as u64;\n-        let alloc = self.get(ptr.alloc_id)?;\n-        match alloc.relocations.get(&ptr.offset) {\n-            Some(&alloc_id) => Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, offset)).into()),\n-            None => Ok(PrimVal::Bytes(offset as u128).into()),\n+        // Now we do the actual reading\n+        let bytes = if signed {\n+            read_target_int(endianess, bytes).unwrap() as u128\n+        } else {\n+            read_target_uint(endianess, bytes).unwrap()\n+        };\n+        // See if we got a pointer\n+        if size != self.pointer_size() {\n+            if self.relocations(ptr, size)?.count() != 0 {\n+                return err!(ReadPointerAsBytes);\n+            }\n+        } else {\n+            let alloc = self.get(ptr.alloc_id)?;\n+            match alloc.relocations.get(&ptr.offset) {\n+                Some(&alloc_id) => return Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, bytes as u64))),\n+                None => {},\n+            }\n         }\n+        // We don't. Just return the bytes.\n+        Ok(PrimVal::Bytes(bytes))\n     }\n \n-    pub fn write_ptr(&mut self, dest: MemoryPointer, ptr: MemoryPointer) -> EvalResult<'tcx> {\n-        self.write_usize(dest, ptr.offset as u64)?;\n-        self.get_mut(dest.alloc_id)?.relocations.insert(\n-            dest.offset,\n-            ptr.alloc_id,\n-        );\n-        Ok(())\n+    pub fn read_ptr_sized_unsigned(&self, ptr: MemoryPointer) -> EvalResult<'tcx, PrimVal> {\n+        self.read_primval(ptr, self.pointer_size(), false)\n     }\n \n-    pub fn write_primval(&mut self, dest: Pointer, val: PrimVal, size: u64) -> EvalResult<'tcx> {\n-        match val {\n-            PrimVal::Ptr(ptr) => {\n+    pub fn write_primval(&mut self, ptr: MemoryPointer, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n+        let endianess = self.endianess();\n+\n+        let bytes = match val {\n+            PrimVal::Ptr(val) => {\n                 assert_eq!(size, self.pointer_size());\n-                self.write_ptr(dest.to_ptr()?, ptr)\n+                val.offset as u128\n             }\n \n             PrimVal::Bytes(bytes) => {\n@@ -1233,118 +1238,55 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     16 => !0,\n                     n => bug!(\"unexpected PrimVal::Bytes size: {}\", n),\n                 };\n-                self.write_uint(dest.to_ptr()?, bytes & mask, size)\n+                bytes & mask\n             }\n \n-            PrimVal::Undef => self.mark_definedness(dest, size, false),\n-        }\n-    }\n+            PrimVal::Undef => {\n+                self.mark_definedness(PrimVal::Ptr(ptr).into(), size, false)?;\n+                return Ok(());\n+            }\n+        };\n \n-    pub fn read_bool(&self, ptr: MemoryPointer) -> EvalResult<'tcx, bool> {\n-        let bytes = self.get_bytes(ptr, 1, self.layout.i1_align.abi())?;\n-        match bytes[0] {\n-            0 => Ok(false),\n-            1 => Ok(true),\n-            _ => err!(InvalidBool),\n+        {\n+            let align = self.int_align(size);\n+            let dst = self.get_bytes_mut(ptr, size, align)?;\n+            if signed {\n+                write_target_int(endianess, dst, bytes as i128).unwrap();\n+            } else {\n+                write_target_uint(endianess, dst, bytes).unwrap();\n+            }\n         }\n-    }\n-\n-    pub fn write_bool(&mut self, ptr: MemoryPointer, b: bool) -> EvalResult<'tcx> {\n-        let align = self.layout.i1_align.abi();\n-        self.get_bytes_mut(ptr, 1, align).map(\n-            |bytes| bytes[0] = b as u8,\n-        )\n-    }\n \n-    fn int_align(&self, size: u64) -> EvalResult<'tcx, u64> {\n-        match size {\n-            1 => Ok(self.layout.i8_align.abi()),\n-            2 => Ok(self.layout.i16_align.abi()),\n-            4 => Ok(self.layout.i32_align.abi()),\n-            8 => Ok(self.layout.i64_align.abi()),\n-            16 => Ok(self.layout.i128_align.abi()),\n-            _ => bug!(\"bad integer size: {}\", size),\n+        // See if we have to also write a relocation\n+        match val {\n+            PrimVal::Ptr(val) => {\n+                self.get_mut(ptr.alloc_id)?.relocations.insert(\n+                    ptr.offset,\n+                    val.alloc_id,\n+                );\n+            }\n+            _ => {}\n         }\n-    }\n-\n-    pub fn read_int(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, i128> {\n-        let align = self.int_align(size)?;\n-        self.get_bytes(ptr, size, align).map(|b| {\n-            read_target_int(self.endianess(), b).unwrap()\n-        })\n-    }\n-\n-    pub fn write_int(&mut self, ptr: MemoryPointer, n: i128, size: u64) -> EvalResult<'tcx> {\n-        let align = self.int_align(size)?;\n-        let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, size, align)?;\n-        write_target_int(endianess, b, n).unwrap();\n-        Ok(())\n-    }\n-\n-    pub fn read_uint(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, u128> {\n-        let align = self.int_align(size)?;\n-        self.get_bytes(ptr, size, align).map(|b| {\n-            read_target_uint(self.endianess(), b).unwrap()\n-        })\n-    }\n \n-    pub fn write_uint(&mut self, ptr: MemoryPointer, n: u128, size: u64) -> EvalResult<'tcx> {\n-        let align = self.int_align(size)?;\n-        let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, size, align)?;\n-        write_target_uint(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_isize(&self, ptr: MemoryPointer) -> EvalResult<'tcx, i64> {\n-        self.read_int(ptr, self.pointer_size()).map(|i| i as i64)\n-    }\n-\n-    pub fn write_isize(&mut self, ptr: MemoryPointer, n: i64) -> EvalResult<'tcx> {\n-        let size = self.pointer_size();\n-        self.write_int(ptr, n as i128, size)\n+    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, val: PrimVal) -> EvalResult<'tcx> {\n+        let ptr_size = self.pointer_size();\n+        self.write_primval(ptr, val, ptr_size, false)\n     }\n \n-    pub fn read_usize(&self, ptr: MemoryPointer) -> EvalResult<'tcx, u64> {\n-        self.read_uint(ptr, self.pointer_size()).map(|i| i as u64)\n-    }\n-\n-    pub fn write_usize(&mut self, ptr: MemoryPointer, n: u64) -> EvalResult<'tcx> {\n-        let size = self.pointer_size();\n-        self.write_uint(ptr, n as u128, size)\n-    }\n-\n-    pub fn write_f32(&mut self, ptr: MemoryPointer, f: f32) -> EvalResult<'tcx> {\n-        let endianess = self.endianess();\n-        let align = self.layout.f32_align.abi();\n-        let b = self.get_bytes_mut(ptr, 4, align)?;\n-        write_target_f32(endianess, b, f).unwrap();\n-        Ok(())\n-    }\n-\n-    pub fn write_f64(&mut self, ptr: MemoryPointer, f: f64) -> EvalResult<'tcx> {\n-        let endianess = self.endianess();\n-        let align = self.layout.f64_align.abi();\n-        let b = self.get_bytes_mut(ptr, 8, align)?;\n-        write_target_f64(endianess, b, f).unwrap();\n-        Ok(())\n-    }\n-\n-    pub fn read_f32(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f32> {\n-        self.get_bytes(ptr, 4, self.layout.f32_align.abi()).map(\n-            |b| {\n-                read_target_f32(self.endianess(), b).unwrap()\n-            },\n-        )\n-    }\n-\n-    pub fn read_f64(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f64> {\n-        self.get_bytes(ptr, 8, self.layout.f64_align.abi()).map(\n-            |b| {\n-                read_target_f64(self.endianess(), b).unwrap()\n-            },\n-        )\n+    fn int_align(&self, size: u64) -> u64 {\n+        // We assume pointer-sized integers have the same alignment as pointers.\n+        // We also assume signed and unsigned integers of the same size have the same alignment.\n+        match size {\n+            1 => self.layout.i8_align.abi(),\n+            2 => self.layout.i16_align.abi(),\n+            4 => self.layout.i32_align.abi(),\n+            8 => self.layout.i64_align.abi(),\n+            16 => self.layout.i128_align.abi(),\n+            _ => bug!(\"bad integer size: {}\", size),\n+        }\n     }\n }\n \n@@ -1493,51 +1435,14 @@ fn read_target_uint(endianess: layout::Endian, mut source: &[u8]) -> Result<u128\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n+\n fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n     match endianess {\n         layout::Endian::Little => source.read_int128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_int128::<BigEndian>(source.len()),\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Methods to access floats in the target endianess\n-////////////////////////////////////////////////////////////////////////////////\n-\n-fn write_target_f32(\n-    endianess: layout::Endian,\n-    mut target: &mut [u8],\n-    data: f32,\n-) -> Result<(), io::Error> {\n-    match endianess {\n-        layout::Endian::Little => target.write_f32::<LittleEndian>(data),\n-        layout::Endian::Big => target.write_f32::<BigEndian>(data),\n-    }\n-}\n-fn write_target_f64(\n-    endianess: layout::Endian,\n-    mut target: &mut [u8],\n-    data: f64,\n-) -> Result<(), io::Error> {\n-    match endianess {\n-        layout::Endian::Little => target.write_f64::<LittleEndian>(data),\n-        layout::Endian::Big => target.write_f64::<BigEndian>(data),\n-    }\n-}\n-\n-fn read_target_f32(endianess: layout::Endian, mut source: &[u8]) -> Result<f32, io::Error> {\n-    match endianess {\n-        layout::Endian::Little => source.read_f32::<LittleEndian>(),\n-        layout::Endian::Big => source.read_f32::<BigEndian>(),\n-    }\n-}\n-fn read_target_f64(endianess: layout::Endian, mut source: &[u8]) -> Result<f64, io::Error> {\n-    match endianess {\n-        layout::Endian::Little => source.read_f64::<LittleEndian>(),\n-        layout::Endian::Big => source.read_f64::<BigEndian>(),\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9dcb1c9b0f5f2cf3315de54012c2e7ef4e83e7a5", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -27,9 +27,9 @@ pub use self::eval_context::{EvalContext, Frame, ResourceLimits, StackPopCleanup\n \n pub use self::lvalue::{Lvalue, LvalueExtra, GlobalId};\n \n-pub use self::memory::{AllocId, Memory, MemoryPointer, MemoryKind, HasMemory, AllocIdKind};\n+pub use self::memory::{AllocId, Memory, MemoryPointer, MemoryKind, HasMemory, AccessKind, AllocIdKind};\n \n-use self::memory::{PointerArithmetic, Lock, AccessKind};\n+use self::memory::{PointerArithmetic, Lock};\n \n use self::range_map::RangeMap;\n "}, {"sha": "ea90e39489d5e3e9f8a77288e9e355443848e34e", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -11,8 +11,8 @@ use rustc::ty;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n \n-use super::{EvalResult, EvalContext, StackPopCleanup, TyAndPacked, PtrAndAlign, GlobalId, Lvalue,\n-            HasMemory, MemoryKind, Machine};\n+use super::{EvalResult, EvalContext, StackPopCleanup, PtrAndAlign, GlobalId, Lvalue,\n+            MemoryKind, Machine, PrimVal};\n \n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n@@ -106,10 +106,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Layout::General { discr, .. } => {\n                         let discr_size = discr.size().bytes();\n                         let dest_ptr = self.force_allocation(dest)?.to_ptr()?;\n-                        self.memory.write_uint(\n+                        self.memory.write_primval(\n                             dest_ptr,\n-                            variant_index as u128,\n+                            PrimVal::Bytes(variant_index as u128),\n                             discr_size,\n+                            false\n                         )?\n                     }\n \n@@ -125,23 +126,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         ..\n                     } => {\n                         if variant_index as u64 != nndiscr {\n-                            let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n+                            self.write_struct_wrapped_null_pointer(\n                                 dest_ty,\n                                 nndiscr,\n                                 discrfield_source,\n+                                dest,\n                             )?;\n-                            let nonnull = self.force_allocation(dest)?.to_ptr()?.offset(\n-                                offset.bytes(),\n-                                &self,\n-                            )?;\n-                            trace!(\"struct wrapped nullable pointer type: {}\", ty);\n-                            // only the pointer part of a fat pointer is used for this space optimization\n-                            let discr_size = self.type_size(ty)?.expect(\n-                                \"bad StructWrappedNullablePointer discrfield\",\n-                            );\n-                            self.write_maybe_aligned_mut(!packed, |ectx| {\n-                                ectx.memory.write_uint(nonnull, 0, discr_size)\n-                            })?;\n                         }\n                     }\n \n@@ -229,7 +219,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 ptr_size,\n                 MemoryKind::UninitializedStatic,\n             )?;\n-            self.memory.write_usize(ptr, 0)?;\n+            self.memory.write_ptr_sized_unsigned(ptr, PrimVal::Bytes(0))?;\n             self.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n             self.globals.insert(\n                 cid,"}, {"sha": "60893fcec18b3102134afe424f7e34b966cf1b05", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 102, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -1,12 +1,11 @@\n use rustc::mir;\n-use rustc::ty::{self, TypeVariants, Ty};\n+use rustc::ty::{self, TypeVariants};\n use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n-use super::{EvalError, EvalResult, EvalErrorKind, EvalContext, eval_context, TyAndPacked,\n-            PtrAndAlign, Lvalue, MemoryPointer, PrimVal, Value, Machine, HasMemory, ValTy};\n-use super::eval_context::IntegerExt;\n+use super::{EvalResult, EvalContext, eval_context,\n+            PtrAndAlign, Lvalue, PrimVal, Value, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -395,10 +394,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let (ptr, vtable) = args[0].into_ptr_vtable_pair(&self.memory)?;\n-                let fn_ptr = self.memory.read_ptr(\n-                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n-                )?;\n-                let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n+                let fn_ptr = self.memory.read_ptr_sized_unsigned(\n+                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?\n+                )?.to_ptr()?;\n+                let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();\n                 let ty = self.get_field_ty(args[0].ty, 0)?.ty; // TODO: packed flag is ignored\n                 args[0].ty = ty;\n@@ -408,98 +407,4 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n         }\n     }\n-\n-    pub fn read_discriminant_value(\n-        &self,\n-        adt_ptr: MemoryPointer,\n-        adt_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, u128> {\n-        use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty)?;\n-        //trace!(\"read_discriminant_value {:#?}\", adt_layout);\n-\n-        let discr_val = match *adt_layout {\n-            General { discr, .. } |\n-            CEnum {\n-                discr,\n-                signed: false,\n-                ..\n-            } => {\n-                let discr_size = discr.size().bytes();\n-                self.memory.read_uint(adt_ptr, discr_size)?\n-            }\n-\n-            CEnum {\n-                discr,\n-                signed: true,\n-                ..\n-            } => {\n-                let discr_size = discr.size().bytes();\n-                self.memory.read_int(adt_ptr, discr_size)? as u128\n-            }\n-\n-            RawNullablePointer { nndiscr, value } => {\n-                let discr_size = value.size(&self.tcx.data_layout).bytes();\n-                trace!(\"rawnullablepointer with size {}\", discr_size);\n-                self.read_nonnull_discriminant_value(\n-                    adt_ptr,\n-                    nndiscr as u128,\n-                    discr_size,\n-                )?\n-            }\n-\n-            StructWrappedNullablePointer {\n-                nndiscr,\n-                ref discrfield_source,\n-                ..\n-            } => {\n-                let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n-                    adt_ty,\n-                    nndiscr,\n-                    discrfield_source,\n-                )?;\n-                let nonnull = adt_ptr.offset(offset.bytes(), &*self)?;\n-                trace!(\"struct wrapped nullable pointer type: {}\", ty);\n-                // only the pointer part of a fat pointer is used for this space optimization\n-                let discr_size = self.type_size(ty)?.expect(\n-                    \"bad StructWrappedNullablePointer discrfield\",\n-                );\n-                self.read_maybe_aligned(!packed, |ectx| {\n-                    ectx.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size)\n-                })?\n-            }\n-\n-            // The discriminant_value intrinsic returns 0 for non-sum types.\n-            Array { .. } |\n-            FatPointer { .. } |\n-            Scalar { .. } |\n-            Univariant { .. } |\n-            Vector { .. } |\n-            UntaggedUnion { .. } => 0,\n-        };\n-\n-        Ok(discr_val)\n-    }\n-\n-    fn read_nonnull_discriminant_value(\n-        &self,\n-        ptr: MemoryPointer,\n-        nndiscr: u128,\n-        discr_size: u64,\n-    ) -> EvalResult<'tcx, u128> {\n-        trace!(\n-            \"read_nonnull_discriminant_value: {:?}, {}, {}\",\n-            ptr,\n-            nndiscr,\n-            discr_size\n-        );\n-        let not_null = match self.memory.read_uint(ptr, discr_size) {\n-            Ok(0) => false,\n-            Ok(_) |\n-            Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. }) => true,\n-            Err(e) => return Err(e),\n-        };\n-        assert!(nndiscr == 0 || nndiscr == 1);\n-        Ok(if not_null { nndiscr } else { 1 - nndiscr })\n-    }\n }"}, {"sha": "3f7e10a9eaff0bd929247141b34c3f4690300bfb", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -63,19 +63,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr(vtable, drop)?;\n+        self.memory.write_ptr_sized_unsigned(vtable, PrimVal::Ptr(drop))?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_usize(size_ptr, size)?;\n+        self.memory.write_ptr_sized_unsigned(size_ptr, PrimVal::Bytes(size as u128))?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_usize(align_ptr, align)?;\n+        self.memory.write_ptr_sized_unsigned(align_ptr, PrimVal::Bytes(align as u128))?;\n \n         for (i, method) in ::rustc::traits::get_vtable_methods(self.tcx, trait_ref).enumerate() {\n             if let Some((def_id, substs)) = method {\n                 let instance = eval_context::resolve(self.tcx, def_id, substs);\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr(method_ptr, fn_ptr)?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, PrimVal::Ptr(fn_ptr))?;\n             }\n         }\n \n@@ -105,10 +105,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         vtable: MemoryPointer,\n     ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        let size = self.memory.read_usize(vtable.offset(pointer_size, self)?)?;\n-        let align = self.memory.read_usize(\n-            vtable.offset(pointer_size * 2, self)?,\n-        )?;\n+        let size = self.memory.read_ptr_sized_unsigned(vtable.offset(pointer_size, self)?)?.to_bytes()? as u64;\n+        let align = self.memory.read_ptr_sized_unsigned(\n+            vtable.offset(pointer_size * 2, self)?\n+        )?.to_bytes()? as u64;\n         Ok((size, align))\n     }\n "}, {"sha": "6454e12e037f4919de13e18b71ec4d922f91dfbd", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = val.into_ptr(&self.memory)?;\n-        self.memory.check_align(ptr, align)?;\n+        self.memory.check_align(ptr, align, None)?;\n \n         // Recurse\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;"}, {"sha": "e052ec1e391cd30f1a69449602b5ebdf446d5319", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -176,13 +176,13 @@ impl<'a, 'tcx: 'a> Value {\n         mem: &Memory<'a, 'tcx, M>,\n     ) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n-        match *self {\n+        Ok(match *self {\n             ByRef(PtrAndAlign { ptr, aligned }) => {\n-                mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?))\n+                mem.read_maybe_aligned(aligned, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n             }\n             ByVal(ptr) |\n-            ByValPair(ptr, _) => Ok(ptr.into()),\n-        }\n+            ByValPair(ptr, _) => ptr,\n+        }.into())\n     }\n \n     pub(super) fn into_ptr_vtable_pair<M: Machine<'tcx>>(\n@@ -196,11 +196,11 @@ impl<'a, 'tcx: 'a> Value {\n                       aligned,\n                   }) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n-                    let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n-                    let vtable = mem.read_ptr(\n+                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n+                    let vtable = mem.read_ptr_sized_unsigned(\n                         ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?,\n-                    )?;\n-                    Ok((ptr, vtable.to_ptr()?))\n+                    )?.to_ptr()?;\n+                    Ok((ptr, vtable))\n                 })\n             }\n \n@@ -222,10 +222,10 @@ impl<'a, 'tcx: 'a> Value {\n                       aligned,\n                   }) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n-                    let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n-                    let len = mem.read_usize(\n+                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n+                    let len = mem.read_ptr_sized_unsigned(\n                         ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?,\n-                    )?;\n+                    )?.to_bytes()? as u64;\n                     Ok((ptr, len))\n                 })\n             }"}, {"sha": "5a26856eba0879d8cd55f0b4f6d1b589844e174e", "filename": "tests/compile-fail/null_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnull_pointer_deref.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: a memory access tried to interpret some bytes as a pointer\n+    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: invalid use of NULL pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "57da8dfc01b27f2931f05c0bff5cf0bc18c58816", "filename": "tests/compile-fail/wild_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwild_pointer_deref.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let p = 42 as *const i32;\n+    let p = 44 as *const i32;\n     let x = unsafe { *p }; //~ ERROR: a memory access tried to interpret some bytes as a pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "e7c82367b29dc241857ad3028eea68e49d3350b2", "filename": "tests/compiletest.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -126,15 +126,14 @@ fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n         // For now, only validate without optimizations.  Inlining breaks validation.\n         flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     }\n+    if target == host {\n+        flags.push(\"--miri_host_target\".to_owned());\n+    }\n     config.target_rustcflags = Some(flags.join(\" \"));\n     // don't actually execute the final binary, it might be for other targets and we only care\n     // about running miri, not the binary.\n     config.runtool = Some(\"echo \\\"\\\" || \".to_owned());\n-    if target == host {\n-        std::env::set_var(\"MIRI_HOST_TARGET\", \"yes\");\n-    }\n     compiletest::run_tests(&config);\n-    std::env::set_var(\"MIRI_HOST_TARGET\", \"\");\n }\n \n fn is_target_dir<P: Into<PathBuf>>(path: P) -> bool {\n@@ -182,17 +181,24 @@ fn get_host() -> String {\n     String::from(host)\n }\n \n-#[test]\n-fn run_pass_miri() {\n+fn run_pass_miri(opt: bool) {\n     let sysroot = get_sysroot();\n     let host = get_host();\n \n-    for &opt in [false, true].iter() {\n-        for_all_targets(&sysroot, |target| {\n-            miri_pass(\"tests/run-pass\", &target, &host, false, opt);\n-        });\n-        miri_pass(\"tests/run-pass-fullmir\", &host, &host, true, opt);\n-    }\n+    for_all_targets(&sysroot, |target| {\n+        miri_pass(\"tests/run-pass\", &target, &host, false, opt);\n+    });\n+    miri_pass(\"tests/run-pass-fullmir\", &host, &host, true, opt);\n+}\n+\n+#[test]\n+fn run_pass_miri_noopt() {\n+    run_pass_miri(false);\n+}\n+\n+#[test]\n+fn run_pass_miri_opt() {\n+    run_pass_miri(true);\n }\n \n #[test]"}, {"sha": "0964b1b32b5c4d416e9a419b02e29e36f600f142", "filename": "tests/run-pass-fullmir/integer-ops.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8329da5e88683bf497f5584d2dde2b824cb86b6/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8329da5e88683bf497f5584d2dde2b824cb86b6/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Finteger-ops.rs?ref=b8329da5e88683bf497f5584d2dde2b824cb86b6", "patch": "@@ -14,6 +14,10 @@\n use std::i32;\n \n pub fn main() {\n+    // This tests that do (not) do sign extension properly when loading integers\n+    assert_eq!(u32::max_value() as i64, 4294967295);\n+    assert_eq!(i32::min_value() as i64, -2147483648);\n+\n     assert_eq!(i8::min_value(), -128);\n \n     assert_eq!(i8::max_value(), 127);"}]}