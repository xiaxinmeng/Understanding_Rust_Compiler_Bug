{"sha": "90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwYzI0NzBlMjJkYWRmYTRkNDNiN2FiYjllNmMzZTExYzYzYmRhZDI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-07-25T23:24:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-25T23:24:15Z"}, "message": "Merge pull request #44 from oli-obk/alignment\n\nAlignment", "tree": {"sha": "68643bcc3cc16f016f75efecd5c13056153df4ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68643bcc3cc16f016f75efecd5c13056153df4ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "html_url": "https://github.com/rust-lang/rust/commit/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "url": "https://api.github.com/repos/rust-lang/rust/commits/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "html_url": "https://github.com/rust-lang/rust/commit/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06"}, {"sha": "f8cfc387fd3eef88033c93086ef4beb9d8e4f082", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8cfc387fd3eef88033c93086ef4beb9d8e4f082", "html_url": "https://github.com/rust-lang/rust/commit/f8cfc387fd3eef88033c93086ef4beb9d8e4f082"}], "stats": {"total": 200, "additions": 143, "deletions": 57}, "files": [{"sha": "5b39399070c22cefa799f6550b0f95092873dfa1", "filename": "src/error.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "patch": "@@ -36,6 +36,10 @@ pub enum EvalError<'tcx> {\n     },\n     ExecutionTimeLimitReached,\n     StackFrameLimitReached,\n+    AlignmentCheckFailed {\n+        required: usize,\n+        has: usize,\n+    },\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -82,6 +86,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"reached the configured maximum execution time\",\n             EvalError::StackFrameLimitReached =>\n                 \"reached the configured maximum number of stack frames\",\n+            EvalError::AlignmentCheckFailed{..} =>\n+                \"tried to execute a misaligned read or write\",\n         }\n     }\n \n@@ -106,6 +112,9 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n             EvalError::OutOfMemory { allocation_size, memory_size, memory_usage } =>\n                 write!(f, \"tried to allocate {} more bytes, but only {} bytes are free of the {} byte memory\",\n                        allocation_size, memory_size - memory_usage, memory_size),\n+            EvalError::AlignmentCheckFailed { required, has } =>\n+               write!(f, \"tried to access memory with alignment {}, but alignment {} is required\",\n+                      has, required),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "c1e1fff999fd3a74395888077e69eb2ee06743d0", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "patch": "@@ -152,7 +152,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match output_ty {\n             ty::FnConverging(ty) => {\n                 let size = self.type_size_with_substs(ty, substs);\n-                self.memory.allocate(size).map(Some)\n+                let align = self.type_align_with_substs(ty, substs);\n+                self.memory.allocate(size, align).map(Some)\n             }\n             ty::FnDiverging => Ok(None),\n         }\n@@ -176,19 +177,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstFloat};\n         macro_rules! i2p {\n             ($i:ident, $n:expr) => {{\n-                let ptr = self.memory.allocate($n)?;\n+                let ptr = self.memory.allocate($n, $n)?;\n                 self.memory.write_int(ptr, $i as i64, $n)?;\n                 Ok(ptr)\n             }}\n         }\n         match *const_val {\n             Float(ConstFloat::F32(f)) => {\n-                let ptr = self.memory.allocate(4)?;\n+                let ptr = self.memory.allocate(4, 4)?;\n                 self.memory.write_f32(ptr, f)?;\n                 Ok(ptr)\n             },\n             Float(ConstFloat::F64(f)) => {\n-                let ptr = self.memory.allocate(8)?;\n+                let ptr = self.memory.allocate(8, 8)?;\n                 self.memory.write_f64(ptr, f)?;\n                 Ok(ptr)\n             },\n@@ -197,42 +198,42 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Integral(ConstInt::InferSigned(_)) => unreachable!(),\n             Integral(ConstInt::I8(i)) => i2p!(i, 1),\n             Integral(ConstInt::U8(i)) => i2p!(i, 1),\n+            Integral(ConstInt::Isize(ConstIsize::Is16(i))) |\n             Integral(ConstInt::I16(i)) => i2p!(i, 2),\n+            Integral(ConstInt::Usize(ConstUsize::Us16(i))) |\n             Integral(ConstInt::U16(i)) => i2p!(i, 2),\n+            Integral(ConstInt::Isize(ConstIsize::Is32(i))) |\n             Integral(ConstInt::I32(i)) => i2p!(i, 4),\n+            Integral(ConstInt::Usize(ConstUsize::Us32(i))) |\n             Integral(ConstInt::U32(i)) => i2p!(i, 4),\n+            Integral(ConstInt::Isize(ConstIsize::Is64(i))) |\n             Integral(ConstInt::I64(i)) => i2p!(i, 8),\n+            Integral(ConstInt::Usize(ConstUsize::Us64(i))) |\n             Integral(ConstInt::U64(i)) => i2p!(i, 8),\n-            Integral(ConstInt::Isize(ConstIsize::Is16(i))) => i2p!(i, 2),\n-            Integral(ConstInt::Isize(ConstIsize::Is32(i))) => i2p!(i, 4),\n-            Integral(ConstInt::Isize(ConstIsize::Is64(i))) => i2p!(i, 8),\n-            Integral(ConstInt::Usize(ConstUsize::Us16(i))) => i2p!(i, 2),\n-            Integral(ConstInt::Usize(ConstUsize::Us32(i))) => i2p!(i, 4),\n-            Integral(ConstInt::Usize(ConstUsize::Us64(i))) => i2p!(i, 8),\n             Str(ref s) => {\n                 let psize = self.memory.pointer_size();\n-                let static_ptr = self.memory.allocate(s.len())?;\n-                let ptr = self.memory.allocate(psize * 2)?;\n+                let static_ptr = self.memory.allocate(s.len(), 1)?;\n+                let ptr = self.memory.allocate(psize * 2, psize)?;\n                 self.memory.write_bytes(static_ptr, s.as_bytes())?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n                 Ok(ptr)\n             }\n             ByteStr(ref bs) => {\n                 let psize = self.memory.pointer_size();\n-                let static_ptr = self.memory.allocate(bs.len())?;\n-                let ptr = self.memory.allocate(psize)?;\n+                let static_ptr = self.memory.allocate(bs.len(), 1)?;\n+                let ptr = self.memory.allocate(psize, psize)?;\n                 self.memory.write_bytes(static_ptr, bs)?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 Ok(ptr)\n             }\n             Bool(b) => {\n-                let ptr = self.memory.allocate(1)?;\n+                let ptr = self.memory.allocate(1, 1)?;\n                 self.memory.write_bool(ptr, b)?;\n                 Ok(ptr)\n             }\n             Char(c) => {\n-                let ptr = self.memory.allocate(4)?;\n+                let ptr = self.memory.allocate(4, 4)?;\n                 self.memory.write_uint(ptr, c as u64, 4)?;\n                 Ok(ptr)\n             },\n@@ -278,10 +279,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n+    fn type_align(&self, ty: Ty<'tcx>) -> usize {\n+        self.type_align_with_substs(ty, self.substs())\n+    }\n+\n     fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n         self.type_layout_with_substs(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n     }\n \n+    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n+        self.type_layout_with_substs(ty, substs).align(&self.tcx.data_layout).abi() as usize\n+    }\n+\n     fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n         self.type_layout_with_substs(ty, self.substs())\n     }\n@@ -315,7 +324,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let locals: EvalResult<'tcx, Vec<Pointer>> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n             let size = self.type_size_with_substs(ty, substs);\n-            self.memory.allocate(size)\n+            let align = self.type_align_with_substs(ty, substs);\n+            self.memory.allocate(size, align)\n         }).collect();\n \n         self.stack.push(Frame {\n@@ -519,15 +529,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Repeat(ref operand, _) => {\n-                let (elem_size, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), n),\n+                let (elem_size, elem_align, length) = match dest_ty.sty {\n+                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), self.type_align(elem_ty), n),\n                     _ => panic!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n \n                 let src = self.eval_operand(operand)?;\n                 for i in 0..length {\n                     let elem_dest = dest.offset((i * elem_size) as isize);\n-                    self.memory.copy(src, elem_dest, elem_size)?;\n+                    self.memory.copy(src, elem_dest, elem_size, elem_align)?;\n                 }\n             }\n \n@@ -562,7 +572,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 let size = self.type_size(ty);\n-                let ptr = self.memory.allocate(size)?;\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n@@ -593,13 +604,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         warn!(\"misc cast from {:?} to {:?}\", src_ty, dest_ty);\n                         let dest_size = self.type_size(dest_ty);\n                         let src_size = self.type_size(src_ty);\n+                        let dest_align = self.type_align(dest_ty);\n \n                         // Hack to support fat pointer -> thin pointer casts to keep tests for\n                         // other things passing for now.\n                         let is_fat_ptr_cast = pointee_type(src_ty).map_or(false, |ty| !self.type_is_sized(ty));\n \n                         if dest_size == src_size || is_fat_ptr_cast {\n-                            self.memory.copy(src, dest, dest_size)?;\n+                            self.memory.copy(src, dest, dest_size, dest_align)?;\n                         } else {\n                             return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue)));\n                         }\n@@ -710,7 +722,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n                             // function items are zero sized\n-                            Ok(self.memory.allocate(0)?)\n+                            Ok(self.memory.allocate(0, 0)?)\n                         } else {\n                             let cid = ConstantId {\n                                 def_id: def_id,\n@@ -843,7 +855,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         let size = self.type_size(ty);\n-        self.memory.copy(src, dest, size)?;\n+        let align = self.type_align(ty);\n+        self.memory.copy(src, dest, size, align)?;\n         Ok(())\n     }\n \n@@ -967,9 +980,9 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     if mir.arg_decls.len() == 2 {\n         // start function\n         let ptr_size = ecx.memory().pointer_size();\n-        let nargs = ecx.memory_mut().allocate(ptr_size).expect(\"can't allocate memory for nargs\");\n+        let nargs = ecx.memory_mut().allocate(ptr_size, ptr_size).expect(\"can't allocate memory for nargs\");\n         ecx.memory_mut().write_usize(nargs, 0).unwrap();\n-        let args = ecx.memory_mut().allocate(ptr_size).expect(\"can't allocate memory for arg pointer\");\n+        let args = ecx.memory_mut().allocate(ptr_size, ptr_size).expect(\"can't allocate memory for arg pointer\");\n         ecx.memory_mut().write_usize(args, 0).unwrap();\n         ecx.frame_mut().locals[0] = nargs;\n         ecx.frame_mut().locals[1] = args;"}, {"sha": "568d8358f0874d6c3a93cf80610c909669896e3c", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "patch": "@@ -88,7 +88,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n                         let ptr = self.eval_operand(func)?;\n-                        assert_eq!(ptr.offset, 0);\n                         let fn_ptr = self.memory.read_ptr(ptr)?;\n                         let FunctionDefinition { def_id, substs, fn_ty } = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         if fn_ty != bare_fn_ty {\n@@ -290,10 +289,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"copy_nonoverlapping\" => {\n                 let elem_ty = *substs.types.get(subst::FnSpace, 0);\n                 let elem_size = self.type_size(elem_ty);\n+                let elem_align = self.type_align(elem_ty);\n                 let src = self.memory.read_ptr(args_ptrs[0])?;\n                 let dest = self.memory.read_ptr(args_ptrs[1])?;\n                 let count = self.memory.read_isize(args_ptrs[2])?;\n-                self.memory.copy(src, dest, count as usize * elem_size)?;\n+                self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n             }\n \n             \"discriminant_value\" => {\n@@ -308,8 +308,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n \n             \"min_align_of\" => {\n-                // FIXME: use correct value\n-                self.memory.write_int(dest, 1, pointer_size)?;\n+                let elem_ty = *substs.types.get(subst::FnSpace, 0);\n+                let elem_align = self.type_align(elem_ty);\n+                self.memory.write_uint(dest, elem_align as u64, pointer_size)?;\n             }\n \n             \"move_val_init\" => {\n@@ -416,14 +417,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match &link_name[..] {\n             \"__rust_allocate\" => {\n                 let size = self.memory.read_usize(args[0])?;\n-                let ptr = self.memory.allocate(size as usize)?;\n+                let align = self.memory.read_usize(args[1])?;\n+                let ptr = self.memory.allocate(size as usize, align as usize)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n             \"__rust_reallocate\" => {\n                 let ptr = self.memory.read_ptr(args[0])?;\n                 let size = self.memory.read_usize(args[2])?;\n-                let new_ptr = self.memory.reallocate(ptr, size as usize)?;\n+                let align = self.memory.read_usize(args[3])?;\n+                let new_ptr = self.memory.reallocate(ptr, size as usize, align as usize)?;\n                 self.memory.write_ptr(dest, new_ptr)?;\n             }\n "}, {"sha": "d99d2c8132e32263882facdc6d1e367e88099858", "filename": "src/memory.rs", "status": "modified", "additions": 72, "deletions": 25, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "patch": "@@ -29,6 +29,7 @@ pub struct Allocation {\n     pub bytes: Vec<u8>,\n     pub relocations: BTreeMap<usize, AllocId>,\n     pub undef_mask: UndefMask,\n+    pub align: usize,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -98,15 +99,16 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             bytes: Vec::new(),\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(0),\n+            align: 1,\n         };\n         mem.alloc_map.insert(ZST_ALLOC_ID, alloc);\n         // check that additional zst allocs work\n-        debug_assert!(mem.allocate(0).unwrap().points_to_zst());\n+        debug_assert!(mem.allocate(0, 1).unwrap().points_to_zst());\n         debug_assert!(mem.get(ZST_ALLOC_ID).is_ok());\n         mem\n     }\n \n-    pub fn allocations<'b>(&'b self) -> ::std::collections::hash_map::Iter<'b, AllocId, Allocation> {\n+    pub fn allocations(&self) -> ::std::collections::hash_map::Iter<AllocId, Allocation> {\n         self.alloc_map.iter()\n     }\n \n@@ -133,7 +135,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn allocate(&mut self, size: usize) -> EvalResult<'tcx, Pointer> {\n+    pub fn allocate(&mut self, size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n+        assert!(align != 0);\n         if size == 0 {\n             return Ok(Pointer::zst_ptr());\n         }\n@@ -149,6 +152,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             bytes: vec![0; size],\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n+            align: align,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -161,16 +165,16 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize) -> EvalResult<'tcx, Pointer> {\n+    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n+        // TODO(solson): Report error about non-__rust_allocate'd pointer.\n         if ptr.offset != 0 {\n-            // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n         if ptr.points_to_zst() {\n-            return self.allocate(new_size);\n+            return self.allocate(new_size, align);\n         }\n \n-        let size = self.get_mut(ptr.alloc_id)?.bytes.len();\n+        let size = self.get(ptr.alloc_id)?.bytes.len();\n \n         if new_size > size {\n             let amount = new_size - size;\n@@ -187,7 +191,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             alloc.undef_mask.truncate(new_size);\n         }\n \n-        Ok(ptr)\n+        Ok(Pointer {\n+            alloc_id: ptr.alloc_id,\n+            offset: 0,\n+        })\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n@@ -220,6 +227,24 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn endianess(&self) -> layout::Endian {\n         self.layout.endian\n     }\n+\n+    pub fn check_align(&self, ptr: Pointer, align: usize) -> EvalResult<'tcx, ()> {\n+        let alloc = self.get(ptr.alloc_id)?;\n+        if alloc.align < align {\n+            return Err(EvalError::AlignmentCheckFailed {\n+                has: alloc.align,\n+                required: align,\n+            });\n+        }\n+        if ptr.offset % align == 0 {\n+            Ok(())\n+        } else {\n+            Err(EvalError::AlignmentCheckFailed {\n+                has: ptr.offset % align,\n+                required: align,\n+            })\n+        }\n+    }\n }\n \n /// Allocation accessors\n@@ -337,15 +362,17 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n-    fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: Pointer, size: usize, align: usize) -> EvalResult<'tcx, &[u8]> {\n+        self.check_align(ptr, align)?;\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n         self.check_defined(ptr, size)?;\n         self.get_bytes_unchecked(ptr, size)\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize, align: usize) -> EvalResult<'tcx, &mut [u8]> {\n+        self.check_align(ptr, align)?;\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(ptr, size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size)\n@@ -354,11 +381,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize, align: usize) -> EvalResult<'tcx, ()> {\n         self.check_relocation_edges(src, size)?;\n \n         let src_bytes = self.get_bytes_unchecked_mut(src, size)?.as_mut_ptr();\n-        let dest_bytes = self.get_bytes_mut(dest, size)?.as_mut_ptr();\n+        let dest_bytes = self.get_bytes_mut(dest, size, align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n@@ -378,17 +405,17 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn read_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n-        self.get_bytes(ptr, size)\n+        self.get_bytes(ptr, size, 1)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx, ()> {\n-        let bytes = self.get_bytes_mut(ptr, src.len())?;\n+        let bytes = self.get_bytes_mut(ptr, src.len(), 1)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<'tcx, ()> {\n-        let bytes = self.get_bytes_mut(ptr, count)?;\n+        let bytes = self.get_bytes_mut(ptr, count, 1)?;\n         for b in bytes { *b = val; }\n         Ok(())\n     }\n@@ -434,7 +461,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {\n-        let bytes = self.get_bytes(ptr, 1)?;\n+        let bytes = self.get_bytes(ptr, 1, self.layout.i1_align.abi() as usize)?;\n         match bytes[0] {\n             0 => Ok(false),\n             1 => Ok(true),\n@@ -443,27 +470,43 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx, ()> {\n-        self.get_bytes_mut(ptr, 1).map(|bytes| bytes[0] = b as u8)\n+        let align = self.layout.i1_align.abi() as usize;\n+        self.get_bytes_mut(ptr, 1, align)\n+            .map(|bytes| bytes[0] = b as u8)\n+    }\n+\n+    fn int_align(&self, size: usize) -> EvalResult<'tcx, usize> {\n+        match size {\n+            1 => Ok(self.layout.i8_align.abi() as usize),\n+            2 => Ok(self.layout.i16_align.abi() as usize),\n+            4 => Ok(self.layout.i32_align.abi() as usize),\n+            8 => Ok(self.layout.i64_align.abi() as usize),\n+            _ => panic!(\"bad integer size\"),\n+        }\n     }\n \n     pub fn read_int(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, i64> {\n-        self.get_bytes(ptr, size).map(|b| read_target_int(self.endianess(), b).unwrap())\n+        let align = self.int_align(size)?;\n+        self.get_bytes(ptr, size, align).map(|b| read_target_int(self.endianess(), b).unwrap())\n     }\n \n     pub fn write_int(&mut self, ptr: Pointer, n: i64, size: usize) -> EvalResult<'tcx, ()> {\n+        let align = self.int_align(size)?;\n         let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, size)?;\n+        let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_int(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n     pub fn read_uint(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, u64> {\n-        self.get_bytes(ptr, size).map(|b| read_target_uint(self.endianess(), b).unwrap())\n+        let align = self.int_align(size)?;\n+        self.get_bytes(ptr, size, align).map(|b| read_target_uint(self.endianess(), b).unwrap())\n     }\n \n     pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: usize) -> EvalResult<'tcx, ()> {\n+        let align = self.int_align(size)?;\n         let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, size)?;\n+        let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_uint(endianess, b, n).unwrap();\n         Ok(())\n     }\n@@ -488,24 +531,28 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx, ()> {\n         let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, 4)?;\n+        let align = self.layout.f32_align.abi() as usize;\n+        let b = self.get_bytes_mut(ptr, 4, align)?;\n         write_target_f32(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n     pub fn write_f64(&mut self, ptr: Pointer, f: f64) -> EvalResult<'tcx, ()> {\n         let endianess = self.endianess();\n-        let b = self.get_bytes_mut(ptr, 8)?;\n+        let align = self.layout.f64_align.abi() as usize;\n+        let b = self.get_bytes_mut(ptr, 8, align)?;\n         write_target_f64(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n     pub fn read_f32(&self, ptr: Pointer) -> EvalResult<'tcx, f32> {\n-        self.get_bytes(ptr, 4).map(|b| read_target_f32(self.endianess(), b).unwrap())\n+        self.get_bytes(ptr, 4, self.layout.f32_align.abi() as usize)\n+            .map(|b| read_target_f32(self.endianess(), b).unwrap())\n     }\n \n     pub fn read_f64(&self, ptr: Pointer) -> EvalResult<'tcx, f64> {\n-        self.get_bytes(ptr, 8).map(|b| read_target_f64(self.endianess(), b).unwrap())\n+        self.get_bytes(ptr, 8, self.layout.f64_align.abi() as usize)\n+            .map(|b| read_target_f64(self.endianess(), b).unwrap())\n     }\n }\n "}, {"sha": "1ec75168170344f9cbd2973c37a4a56d5d070567", "filename": "src/primval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "patch": "@@ -1,3 +1,6 @@\n+#![allow(unknown_lints)]\n+#![allow(float_cmp)]\n+\n use rustc::mir::repr as mir;\n \n use error::{EvalError, EvalResult};"}, {"sha": "4faaa359df6244fe57a8d6c00301d735f0dfbafe", "filename": "tests/compile-fail/alignment.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/tests%2Fcompile-fail%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2/tests%2Fcompile-fail%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Falignment.rs?ref=90c2470e22dadfa4d43b7abb9e6c3e11c63bdad2", "patch": "@@ -0,0 +1,11 @@\n+fn main() {\n+    // miri always gives allocations the worst possible alignment, so a `u8` array is guaranteed\n+    // to be at the virtual location 1 (so one byte offset from the ultimate alignemnt location 0)\n+    let mut x = [0u8; 20];\n+    let x_ptr: *mut u8 = &mut x[0];\n+    let y_ptr = x_ptr as *mut u64;\n+    unsafe {\n+        *y_ptr = 42; //~ ERROR tried to access memory with alignment 1, but alignment\n+    }\n+    panic!(\"unreachable in miri\");\n+}"}]}