{"sha": "4c7be32606f023c5a9f298d43a0b6617147cafa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjN2JlMzI2MDZmMDIzYzVhOWYyOThkNDNhMGI2NjE3MTQ3Y2FmYTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-14T21:24:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-15T18:49:11Z"}, "message": "add node_ids to blocks", "tree": {"sha": "d10d56d86d4a2f8ca417cb1011a05ed506aa4afe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10d56d86d4a2f8ca417cb1011a05ed506aa4afe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c7be32606f023c5a9f298d43a0b6617147cafa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c7be32606f023c5a9f298d43a0b6617147cafa8", "html_url": "https://github.com/rust-lang/rust/commit/4c7be32606f023c5a9f298d43a0b6617147cafa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c7be32606f023c5a9f298d43a0b6617147cafa8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1397933130fcc3f6d9274894be7d43d881c7072", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1397933130fcc3f6d9274894be7d43d881c7072", "html_url": "https://github.com/rust-lang/rust/commit/e1397933130fcc3f6d9274894be7d43d881c7072"}], "stats": {"total": 275, "additions": 167, "deletions": 108}, "files": [{"sha": "f1b5d7e6c952cde3c680711a91a9bf7cd33b4b4b", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=4c7be32606f023c5a9f298d43a0b6617147cafa8", "patch": "@@ -370,8 +370,10 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n                 let loc = local_mem(option::get(assoc(key, m[0].bound)));\n                 bcx.fcx.lllocals.insert(val, loc);\n             };\n-            let {bcx: guard_cx, val} = with_scope_result(bcx, \"guard\") {|bcx|\n-                trans_temp_expr(bcx, e)\n+            let {bcx: guard_cx, val} = {\n+                with_scope_result(bcx, e.info(), \"guard\") {|bcx|\n+                    trans_temp_expr(bcx, e)\n+                }\n             };\n             bcx = with_cond(guard_cx, Not(guard_cx, val)) {|bcx|\n                 compile_submatch(bcx, vec::tail(m), vals, chk, exits);\n@@ -517,19 +519,20 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n               }\n               compare {\n                 let t = node_id_type(bcx, pat_id);\n-                let {bcx: after_cx, val: matches} =\n-                    with_scope_result(bcx, \"compare_scope\") {|bcx|\n-                    alt trans_opt(bcx, opt) {\n-                      single_result({bcx, val}) {\n-                        trans_compare(bcx, ast::eq, test_val, t, val, t)\n-                      }\n-                      range_result({val: vbegin, _}, {bcx, val: vend}) {\n-                        let {bcx, val: ge} = trans_compare(\n-                            bcx, ast::ge, test_val, t, vbegin, t);\n-                        let {bcx, val: le} = trans_compare(\n-                            bcx, ast::le, test_val, t, vend, t);\n-                        {bcx: bcx, val: And(bcx, ge, le)}\n-                      }\n+                let {bcx: after_cx, val: matches} = {\n+                    with_scope_result(bcx, none, \"compare_scope\") {|bcx|\n+                        alt trans_opt(bcx, opt) {\n+                          single_result({bcx, val}) {\n+                            trans_compare(bcx, ast::eq, test_val, t, val, t)\n+                          }\n+                          range_result({val: vbegin, _}, {bcx, val: vend}) {\n+                            let {bcx, val: ge} = trans_compare(\n+                                bcx, ast::ge, test_val, t, vbegin, t);\n+                            let {bcx, val: le} = trans_compare(\n+                                bcx, ast::le, test_val, t, vend, t);\n+                            {bcx: bcx, val: And(bcx, ge, le)}\n+                          }\n+                        }\n                     }\n                 };\n                 bcx = sub_block(after_cx, \"compare_next\");\n@@ -608,10 +611,14 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n     ret success;\n }\n \n-fn trans_alt(bcx: block, expr: @ast::expr, arms: [ast::arm],\n-             mode: ast::alt_mode, dest: dest) -> block {\n+fn trans_alt(bcx: block,\n+             alt_expr: @ast::expr,\n+             expr: @ast::expr,\n+             arms: [ast::arm],\n+             mode: ast::alt_mode,\n+             dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n-    with_scope(bcx, \"alt\") {|bcx|\n+    with_scope(bcx, alt_expr.info(), \"alt\") {|bcx|\n         trans_alt_inner(bcx, expr, arms, mode, dest)\n     }\n }\n@@ -626,8 +633,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n     if bcx.unreachable { ret bcx; }\n \n     for vec::each(arms) {|a|\n-        let body = scope_block(bcx, \"case_body\");\n-        body.block_span = some(a.body.span);\n+        let body = scope_block(bcx, a.body.info(), \"case_body\");\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         bodies += [body];\n         for vec::each(a.pats) {|p|"}, {"sha": "f5b762105742f475287c9f4ab00b590407ca2516", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 111, "deletions": 78, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4c7be32606f023c5a9f298d43a0b6617147cafa8", "patch": "@@ -1408,9 +1408,11 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(un_expr);\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(bcx, fty, expr_ty(bcx, un_expr), {|bcx|\n-            impl::trans_method_callee(bcx, callee_id, e, origin)\n-        }, arg_exprs([]), dest);\n+        ret trans_call_inner(\n+            bcx, un_expr.info(), fty,\n+            expr_ty(bcx, un_expr),\n+            {|bcx| impl::trans_method_callee(bcx, callee_id, e, origin) },\n+            arg_exprs([]), dest);\n       }\n       _ {}\n     }\n@@ -1601,10 +1603,14 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(bcx, fty, expr_ty(bcx, ex), {|bcx|\n-            // FIXME provide the already-computed address, not the expr\n-            impl::trans_method_callee(bcx, callee_id, dst, origin)\n-        }, arg_exprs([src]), save_in(lhs_res.val));\n+        ret trans_call_inner(\n+            bcx, ex.info(), fty,\n+            expr_ty(bcx, ex),\n+            {|bcx|\n+                // FIXME provide the already-computed address, not the expr\n+                impl::trans_method_callee(bcx, callee_id, dst, origin)\n+            },\n+            arg_exprs([src]), save_in(lhs_res.val));\n       }\n       _ {}\n     }\n@@ -1688,17 +1694,23 @@ enum lazy_binop_ty { lazy_and, lazy_or }\n fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n-    let {bcx: past_lhs, val: lhs} = with_scope_result(bcx, \"lhs\")\n-        {|bcx| trans_temp_expr(bcx, a)};\n+    let {bcx: past_lhs, val: lhs} = {\n+        with_scope_result(bcx, a.info(), \"lhs\") { |bcx|\n+            trans_temp_expr(bcx, a)\n+        }\n+    };\n     if past_lhs.unreachable { ret past_lhs; }\n     let join = sub_block(bcx, \"join\"), before_rhs = sub_block(bcx, \"rhs\");\n \n     alt op {\n       lazy_and { CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb); }\n       lazy_or { CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb); }\n     }\n-    let {bcx: past_rhs, val: rhs} = with_scope_result(before_rhs, \"rhs\")\n-        {|bcx| trans_temp_expr(bcx, b)};\n+    let {bcx: past_rhs, val: rhs} = {\n+        with_scope_result(before_rhs, b.info(), \"rhs\") { |bcx|\n+            trans_temp_expr(bcx, b)\n+        }\n+    };\n \n     if past_rhs.unreachable { ret store_in_dest(join, lhs, dest); }\n     Br(past_rhs, join.llbb);\n@@ -1714,9 +1726,13 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(bcx, fty, expr_ty(bcx, ex), {|bcx|\n-            impl::trans_method_callee(bcx, callee_id, lhs, origin)\n-        }, arg_exprs([rhs]), dest);\n+        ret trans_call_inner(\n+            bcx, ex.info(), fty,\n+            expr_ty(bcx, ex),\n+            {|bcx|\n+                impl::trans_method_callee(bcx, callee_id, lhs, origin)\n+            },\n+            arg_exprs([rhs]), dest);\n       }\n       _ {}\n     }\n@@ -1748,10 +1764,8 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n \n     let then_dest = dup_for_join(dest);\n     let else_dest = dup_for_join(dest);\n-    let then_cx = scope_block(bcx, \"then\");\n-    then_cx.block_span = some(thn.span);\n-    let else_cx = scope_block(bcx, \"else\");\n-    option::iter(els) {|e| else_cx.block_span = some(e.span); }\n+    let then_cx = scope_block(bcx, thn.info(), \"then\");\n+    let else_cx = scope_block(bcx, els.info(), \"else\");\n     CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n     let then_bcx = trans_block(then_cx, thn, then_dest);\n     let then_bcx = trans_block_cleanups(then_bcx, then_cx);\n@@ -1783,9 +1797,9 @@ fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n     -> block {\n     let _icx = cx.insn_ctxt(\"trans_while\");\n     let next_cx = sub_block(cx, \"while next\");\n-    let loop_cx = loop_scope_block(cx, next_cx, \"`while`\", body.span);\n-    let cond_cx = scope_block(loop_cx, \"while loop cond\");\n-    let body_cx = scope_block(loop_cx, \"while loop body\");\n+    let loop_cx = loop_scope_block(cx, next_cx, \"`while`\", body.info());\n+    let cond_cx = scope_block(loop_cx, cond.info(), \"while loop cond\");\n+    let body_cx = scope_block(loop_cx, body.info(), \"while loop body\");\n     Br(cx, loop_cx.llbb);\n     Br(loop_cx, cond_cx.llbb);\n     let cond_res = trans_temp_expr(cond_cx, cond);\n@@ -1799,7 +1813,7 @@ fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n fn trans_loop(cx:block, body: ast::blk) -> block {\n     let _icx = cx.insn_ctxt(\"trans_loop\");\n     let next_cx = sub_block(cx, \"next\");\n-    let body_cx = loop_scope_block(cx, next_cx, \"`loop`\", body.span);\n+    let body_cx = loop_scope_block(cx, next_cx, \"`loop`\", body.info());\n     let body_end = trans_block(body_cx, body, ignore);\n     cleanup_and_Br(body_end, body_cx, body_cx.llbb);\n     Br(cx, body_cx.llbb);\n@@ -2808,12 +2822,13 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n          retslot: llretslot};\n }\n \n-fn trans_call(in_cx: block, f: @ast::expr,\n+fn trans_call(in_cx: block, call_ex: @ast::expr, f: @ast::expr,\n               args: call_args, id: ast::node_id, dest: dest)\n     -> block {\n     let _icx = in_cx.insn_ctxt(\"trans_call\");\n-    trans_call_inner(in_cx, expr_ty(in_cx, f), node_id_type(in_cx, id),\n-                     {|cx| trans_callee(cx, f)}, args, dest)\n+    trans_call_inner(\n+        in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n+        {|cx| trans_callee(cx, f)}, args, dest)\n }\n \n fn body_contains_ret(body: ast::blk) -> bool {\n@@ -2832,20 +2847,26 @@ fn body_contains_ret(body: ast::blk) -> bool {\n     cx.found\n }\n \n-fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n-                    get_callee: fn(block) -> lval_maybe_callee,\n-                    args: call_args, dest: dest)\n-    -> block {\n-    let ret_in_loop = alt args {\n-      arg_exprs(args) { args.len() > 0u && alt vec::last(args).node {\n-        ast::expr_loop_body(@{node: ast::expr_fn_block(_, body, _), _}) {\n-          body_contains_ret(body)\n-        }\n-        _ { false }\n-      } }\n-      _ { false }\n-    };\n-    with_scope(in_cx, \"call\") {|cx|\n+fn trans_call_inner(\n+    in_cx: block,\n+    call_info: option<node_info>,\n+    fn_expr_ty: ty::t,\n+    ret_ty: ty::t,\n+    get_callee: fn(block) -> lval_maybe_callee,\n+    args: call_args,\n+    dest: dest) -> block {\n+\n+    with_scope(in_cx, call_info, \"call\") {|cx|\n+        let ret_in_loop = alt args {\n+          arg_exprs(args) { args.len() > 0u && alt vec::last(args).node {\n+            ast::expr_loop_body(@{node: ast::expr_fn_block(_, body, _), _}) {\n+              body_contains_ret(body)\n+            }\n+            _ { false }\n+          } }\n+          _ { false }\n+        };\n+\n         let f_res = get_callee(cx);\n         let mut bcx = f_res.bcx;\n         let ccx = cx.ccx();\n@@ -3177,11 +3198,10 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         ret trans_if(bcx, cond, thn, els, dest);\n       }\n       ast::expr_alt(expr, arms, mode) {\n-        ret alt::trans_alt(bcx, expr, arms, mode, dest);\n+        ret alt::trans_alt(bcx, e, expr, arms, mode, dest);\n       }\n       ast::expr_block(blk) {\n-        ret with_scope(bcx, \"block-expr body\") {|bcx|\n-            bcx.block_span = some(blk.span);\n+        ret with_scope(bcx, blk.info(), \"block-expr body\") {|bcx|\n             trans_block(bcx, blk, dest)\n         };\n       }\n@@ -3231,7 +3251,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       }\n       ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n       ast::expr_call(f, args, _) {\n-        ret trans_call(bcx, f, arg_exprs(args), e.id, dest);\n+        ret trans_call(bcx, e, f, arg_exprs(args), e.id, dest);\n       }\n       ast::expr_field(base, _, _) {\n         if dest == ignore { ret trans_expr(bcx, base, ignore); }\n@@ -3246,9 +3266,13 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let origin = bcx.ccx().maps.method_map.get(e.id);\n         let callee_id = ast_util::op_expr_callee_id(e);\n         let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(bcx, fty, expr_ty(bcx, e), {|bcx|\n-            impl::trans_method_callee(bcx, callee_id, base, origin)\n-        }, arg_exprs([idx]), dest);\n+        ret trans_call_inner(\n+            bcx, e.info(), fty,\n+            expr_ty(bcx, e),\n+            { |bcx|\n+                impl::trans_method_callee(bcx, callee_id, base, origin)\n+            },\n+            arg_exprs([idx]), dest);\n       }\n \n       // These return nothing\n@@ -3270,15 +3294,15 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n       }\n       ast::expr_log(_, lvl, a) {\n         assert dest == ignore;\n-        ret trans_log(lvl, bcx, a);\n+        ret trans_log(e, lvl, bcx, a);\n       }\n       ast::expr_assert(a) {\n         assert dest == ignore;\n-        ret trans_check_expr(bcx, a, \"Assertion\");\n+        ret trans_check_expr(bcx, e, a, \"Assertion\");\n       }\n       ast::expr_check(ast::checked_expr, a) {\n         assert dest == ignore;\n-        ret trans_check_expr(bcx, a, \"Predicate\");\n+        ret trans_check_expr(bcx, e, a, \"Predicate\");\n       }\n       ast::expr_check(ast::claimed_expr, a) {\n         assert dest == ignore;\n@@ -3290,7 +3314,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let c = get_extern_const(bcx.ccx().externs, bcx.ccx().llmod,\n                                  \"check_claims\", T_bool());\n         ret with_cond(bcx, Load(bcx, c)) {|bcx|\n-            trans_check_expr(bcx, a, \"Claim\")\n+            trans_check_expr(bcx, e, a, \"Claim\")\n         };\n       }\n       ast::expr_while(cond, body) {\n@@ -3361,9 +3385,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let args = [llsize_of(ccx, llval_ty), llalign_of(ccx, llval_ty)];\n         let origin = bcx.ccx().maps.method_map.get(alloc_id);\n         let bcx = trans_call_inner(\n-            bcx,\n-            node_id_type(bcx, alloc_id),\n-            void_ty,\n+            bcx, e.info(), node_id_type(bcx, alloc_id), void_ty,\n             {|bcx| impl::trans_method_callee(bcx, alloc_id, pool, origin) },\n             arg_vals(args),\n             save_in(voidval));\n@@ -3440,7 +3462,8 @@ fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     ret v;\n }\n \n-fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n+fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n+             bcx: block, e: @ast::expr) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     if ty::type_is_bot(expr_ty(bcx, lvl)) {\n@@ -3468,12 +3491,14 @@ fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n         global\n     };\n     let current_level = Load(bcx, global);\n-    let {bcx, val: level} = with_scope_result(bcx, \"level\") {|bcx|\n-        trans_temp_expr(bcx, lvl)\n+    let {bcx, val: level} = {\n+        with_scope_result(bcx, lvl.info(), \"level\") {|bcx|\n+            trans_temp_expr(bcx, lvl)\n+        }\n     };\n \n     with_cond(bcx, ICmp(bcx, lib::llvm::IntUGE, current_level, level)) {|bcx|\n-        with_scope(bcx, \"log\") {|bcx|\n+        with_scope(bcx, log_ex.info(), \"log\") {|bcx|\n             let {bcx, val, _} = trans_temp_expr(bcx, e);\n             let e_ty = expr_ty(bcx, e);\n             let tydesc = get_tydesc_simple(ccx, e_ty);\n@@ -3486,14 +3511,17 @@ fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n     }\n }\n \n-fn trans_check_expr(bcx: block, e: @ast::expr, s: str) -> block {\n+fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n+                    pred_expr: @ast::expr, s: str) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n-    let expr_str = s + \" \" + expr_to_str(e) + \" failed\";\n-    let {bcx, val} = with_scope_result(bcx, \"check\") {|bcx|\n-        trans_temp_expr(bcx, e)\n+    let expr_str = s + \" \" + expr_to_str(pred_expr) + \" failed\";\n+    let {bcx, val} = {\n+        with_scope_result(bcx, chk_expr.info(), \"check\") {|bcx|\n+            trans_temp_expr(bcx, pred_expr)\n+        }\n     };\n     with_cond(bcx, Not(bcx, val)) {|bcx|\n-        trans_fail(bcx, some(e.span), expr_str)\n+        trans_fail(bcx, some(pred_expr.span), expr_str)\n     }\n }\n \n@@ -3725,7 +3753,8 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n // You probably don't want to use this one. See the\n // next three functions instead.\n fn new_block(cx: fn_ctxt, parent: block_parent, kind: block_kind,\n-             name: str, block_span: option<span>) -> block {\n+             name: str, opt_node_info: option<node_info>) -> block {\n+\n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n         cx.ccx.names(name)\n     } else { \"\" };\n@@ -3737,7 +3766,7 @@ fn new_block(cx: fn_ctxt, parent: block_parent, kind: block_kind,\n                 mut unreachable: false,\n                 parent: parent,\n                 kind: kind,\n-                mut block_span: block_span,\n+                node_info: opt_node_info,\n                 fcx: cx};\n     alt parent {\n       parent_some(cx) {\n@@ -3754,24 +3783,26 @@ fn simple_block_scope() -> block_kind {\n }\n \n // Use this when you're at the top block of a function or the like.\n-fn top_scope_block(fcx: fn_ctxt, sp: option<span>) -> block {\n+fn top_scope_block(fcx: fn_ctxt, opt_node_info: option<node_info>) -> block {\n     ret new_block(fcx, parent_none, simple_block_scope(),\n-                  \"function top level\", sp);\n+                  \"function top level\", opt_node_info);\n }\n \n-fn scope_block(bcx: block, n: str) -> block {\n+fn scope_block(bcx: block,\n+               opt_node_info: option<node_info>,\n+               n: str) -> block {\n     ret new_block(bcx.fcx, parent_some(bcx), simple_block_scope(),\n-                  n, none);\n+                  n, opt_node_info);\n }\n \n-fn loop_scope_block(bcx: block, loop_break: block, n: str, sp: span)\n-    -> block {\n+fn loop_scope_block(bcx: block, loop_break: block, n: str,\n+                    opt_node_info: option<node_info>) -> block {\n     ret new_block(bcx.fcx, parent_some(bcx), block_scope({\n         loop_break: some(loop_break),\n         mut cleanups: [],\n         mut cleanup_paths: [],\n         mut landing_pad: none\n-    }), n, some(sp));\n+    }), n, opt_node_info);\n }\n \n \n@@ -3786,7 +3817,7 @@ fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n           mut unreachable: false,\n           parent: parent_none,\n           kind: block_non_scope,\n-          mut block_span: none,\n+          node_info: none,\n           fcx: fcx};\n }\n \n@@ -3879,17 +3910,19 @@ fn leave_block(bcx: block, out_of: block) -> block {\n     next_cx\n }\n \n-fn with_scope(bcx: block, name: str, f: fn(block) -> block) -> block {\n+fn with_scope(bcx: block, opt_node_info: option<node_info>,\n+              name: str, f: fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n-    let scope_cx = scope_block(bcx, name);\n+    let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     leave_block(f(scope_cx), scope_cx)\n }\n \n-fn with_scope_result(bcx: block, name: str, f: fn(block) -> result)\n+fn with_scope_result(bcx: block, opt_node_info: option<node_info>,\n+                     name: str, f: fn(block) -> result)\n     -> result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n-    let scope_cx = scope_block(bcx, name);\n+    let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     let {bcx, val} = f(scope_cx);\n     {bcx: leave_block(bcx, scope_cx), val: val}\n@@ -4138,7 +4171,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = top_scope_block(fcx, some(body.span));\n+    let bcx_top = top_scope_block(fcx, body.info());\n     let mut bcx = bcx_top;\n     let lltop = bcx.llbb;\n     let block_ty = node_id_type(bcx, body.node.id);\n@@ -4429,7 +4462,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                                    some(psubsts), some(sp));\n   // FIXME: need to substitute into the fn arg types too?\n   create_llargs_for_fn_args(fcx, no_self, decl.inputs);\n-  let mut bcx_top = top_scope_block(fcx, some(sp));\n+  let mut bcx_top = top_scope_block(fcx, body.info());\n   let lltop = bcx_top.llbb;\n   bcx_top = copy_args_to_allocas(fcx, bcx_top, decl.inputs,\n               ty::ty_fn_args(node_id_type(bcx_top, ctor_id)));"}, {"sha": "8e2bad1163610457f95e5f993299eeb0b6dba22d", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4c7be32606f023c5a9f298d43a0b6617147cafa8", "patch": "@@ -313,6 +313,29 @@ type scope_info = {\n     mut landing_pad: option<BasicBlockRef>,\n };\n \n+impl node_info for @ast::expr {\n+    fn info() -> option<node_info> {\n+        some({id: self.id, span: self.span})\n+    }\n+}\n+\n+impl node_info for ast::blk {\n+    fn info() -> option<node_info> {\n+        some({id: self.node.id, span: self.span})\n+    }\n+}\n+\n+impl node_info for option<@ast::expr> {\n+    fn info() -> option<node_info> {\n+        self.chain { |s| s.info() }\n+    }\n+}\n+\n+type node_info = {\n+    id: ast::node_id,\n+    span: span\n+};\n+\n // Basic block context.  We create a block context for each basic block\n // (single-entry, single-exit sequence of instructions) we generate from Rust\n // code.  Each basic block we generate is attached to a function, typically\n@@ -330,9 +353,8 @@ type block = @{\n     parent: block_parent,\n     // The 'kind' of basic block this is.\n     kind: block_kind,\n-    // The source span where the block came from, if it is a block that\n-    // actually appears in the source code.\n-    mut block_span: option<span>,\n+    // info about the AST node this block originated from, if any\n+    node_info: option<node_info>,\n     // The function context for the function to which this block is\n     // attached.\n     fcx: fn_ctxt"}, {"sha": "b2e707243aa5fb611c10b47657d0a35df6ae3a19", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4c7be32606f023c5a9f298d43a0b6617147cafa8", "patch": "@@ -236,19 +236,17 @@ fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n fn create_block(cx: block) -> @metadata<block_md> {\n     let cache = get_cache(cx.ccx());\n     let mut cx = cx;\n-    while option::is_none(cx.block_span) {\n+    while option::is_none(cx.node_info) {\n         alt cx.parent {\n           parent_some(b) { cx = b; }\n           parent_none { fail; }\n         }\n     }\n-    let sp = option::get(cx.block_span);\n+    let sp = option::get(cx.node_info).span;\n \n-    let start = codemap::lookup_char_pos(cx.sess().codemap,\n-                                         sp.lo);\n+    let start = codemap::lookup_char_pos(cx.sess().codemap, sp.lo);\n     let fname = start.file.name;\n-    let end = codemap::lookup_char_pos(cx.sess().codemap,\n-                                       sp.hi);\n+    let end = codemap::lookup_char_pos(cx.sess().codemap, sp.hi);\n     let tg = LexicalBlockTag;\n     /*alt cached_metadata::<@metadata<block_md>>(\n         cache, tg,"}, {"sha": "7f153c60207f187961e2807c4c093fdb7d8cced9", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c7be32606f023c5a9f298d43a0b6617147cafa8/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=4c7be32606f023c5a9f298d43a0b6617147cafa8", "patch": "@@ -864,7 +864,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n                                                     some(sub_origins));\n                     {env: self_env(visitor, vp_ty, none) with lval}\n                 };\n-                bcx = trans_call_inner(bcx, mth_ty, ty::mk_bool(ccx.tcx),\n+                bcx = trans_call_inner(bcx, none, mth_ty, ty::mk_bool(ccx.tcx),\n                                        get_lval, arg_vals(args), ignore);\n             }\n           }"}]}