{"sha": "6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "node_id": "C_kwDOAAsO6NoAKDZkZjFkODI4NjlkMDZiODhmZjQxM2U2M2ExZThlZmJiMzExZTNiNWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-29T00:16:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-29T00:16:17Z"}, "message": "Auto merge of #88950 - Nadrieril:deconstruct-pat, r=oli-obk\n\nAdd an intermediate representation to exhaustiveness checking\n\nThe exhaustiveness checking algorithm keeps deconstructing patterns into a `Constructor` and some `Fields`, but does so a bit all over the place. This PR introduces a new representation for patterns that already has that information, so we only compute it once at the start.\nI find this makes code easier to follow. In particular `DeconstructedPat::specialize` is a lot simpler than what happened before, and more closely matches the description of the algorithm. I'm also hoping this could help for the project of librarifying exhaustiveness for rust_analyzer since it decouples the algorithm from `rustc_middle::Pat`.", "tree": {"sha": "22d0ccf49286fc65743e82737db0f731b8f504af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22d0ccf49286fc65743e82737db0f731b8f504af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "html_url": "https://github.com/rust-lang/rust/commit/6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f8092cc32ec171becef8ceacec7dbb06c5d7d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f8092cc32ec171becef8ceacec7dbb06c5d7d7e", "html_url": "https://github.com/rust-lang/rust/commit/8f8092cc32ec171becef8ceacec7dbb06c5d7d7e"}, {"sha": "b7e358ee17a5794603b2324858de078c4586acfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e358ee17a5794603b2324858de078c4586acfc", "html_url": "https://github.com/rust-lang/rust/commit/b7e358ee17a5794603b2324858de078c4586acfc"}], "stats": {"total": 1887, "additions": 893, "deletions": 994}, "files": [{"sha": "08f8850e78ed252cab51e8b323ffda0cbd912588", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 89, "deletions": 119, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -1,6 +1,6 @@\n+use super::deconstruct_pat::{Constructor, DeconstructedPat};\n use super::usefulness::{\n-    compute_match_usefulness, expand_pattern, is_wildcard, MatchArm, MatchCheckCtxt, Reachability,\n-    UsefulnessReport,\n+    compute_match_usefulness, MatchArm, MatchCheckCtxt, Reachability, UsefulnessReport,\n };\n use super::{PatCtxt, PatternError};\n \n@@ -12,26 +12,25 @@ use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n-use rustc_middle::thir::PatKind;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_session::lint::builtin::{\n     BINDINGS_WITH_VARIANT_NAME, IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS,\n };\n use rustc_session::Session;\n use rustc_span::{DesugaringKind, ExpnKind, Span};\n-use std::slice;\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n         None => return,\n         Some(id) => tcx.hir().body_owned_by(tcx.hir().local_def_id_to_hir_id(id)),\n     };\n \n+    let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {\n         tcx,\n         typeck_results: tcx.typeck_body(body_id),\n         param_env: tcx.param_env(def_id),\n-        pattern_arena: TypedArena::default(),\n+        pattern_arena: &pattern_arena,\n     };\n     visitor.visit_body(tcx.hir().body(body_id));\n }\n@@ -40,14 +39,14 @@ fn create_e0004(sess: &Session, sp: Span, error_message: String) -> DiagnosticBu\n     struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n }\n \n-struct MatchVisitor<'a, 'tcx> {\n+struct MatchVisitor<'a, 'p, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    pattern_arena: TypedArena<super::Pat<'tcx>>,\n+    pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n }\n \n-impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n     type Map = intravisit::ErasedMap<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n@@ -113,31 +112,30 @@ impl PatCtxt<'_, '_> {\n     }\n }\n \n-impl<'tcx> MatchVisitor<'_, 'tcx> {\n+impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n     fn check_patterns(&self, pat: &Pat<'_>) {\n         pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         check_for_bindings_named_same_as_variants(self, pat);\n     }\n \n-    fn lower_pattern<'p>(\n+    fn lower_pattern(\n         &self,\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         pat: &'tcx hir::Pat<'tcx>,\n         have_errors: &mut bool,\n-    ) -> (&'p super::Pat<'tcx>, Ty<'tcx>) {\n+    ) -> &'p DeconstructedPat<'p, 'tcx> {\n         let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.typeck_results);\n         patcx.include_lint_checks();\n         let pattern = patcx.lower_pattern(pat);\n-        let pattern_ty = pattern.ty;\n-        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(pattern));\n+        let pattern: &_ = cx.pattern_arena.alloc(DeconstructedPat::from_pat(cx, &pattern));\n         if !patcx.errors.is_empty() {\n             *have_errors = true;\n             patcx.report_inlining_errors();\n         }\n-        (pattern, pattern_ty)\n+        pattern\n     }\n \n-    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'_, 'tcx> {\n+    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'p, 'tcx> {\n         MatchCheckCtxt {\n             tcx: self.tcx,\n             param_env: self.param_env,\n@@ -149,8 +147,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, expr: &hir::Expr<'_>, span: Span) {\n         self.check_patterns(pat);\n         let mut cx = self.new_cx(expr.hir_id);\n-        let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n-        check_let_reachability(&mut cx, pat.hir_id, &tpat, span);\n+        let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n+        check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n     }\n \n     fn check_match(\n@@ -166,8 +164,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             self.check_patterns(&arm.pat);\n             if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n                 self.check_patterns(pat);\n-                let tpat = self.lower_pattern(&mut cx, pat, &mut false).0;\n-                check_let_reachability(&mut cx, pat.hir_id, &tpat, tpat.span);\n+                let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n+                check_let_reachability(&mut cx, pat.hir_id, tpat, tpat.span());\n             }\n         }\n \n@@ -176,7 +174,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         let arms: Vec<_> = arms\n             .iter()\n             .map(|hir::Arm { pat, guard, .. }| MatchArm {\n-                pat: self.lower_pattern(&mut cx, pat, &mut have_errors).0,\n+                pat: self.lower_pattern(&mut cx, pat, &mut have_errors),\n                 hir_id: pat.hir_id,\n                 has_guard: guard.is_some(),\n             })\n@@ -190,20 +188,16 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         let scrut_ty = self.typeck_results.expr_ty_adjusted(scrut);\n         let report = compute_match_usefulness(&cx, &arms, scrut.hir_id, scrut_ty);\n \n-        report_arm_reachability(&cx, &report, |_, arm_span, arm_hir_id, catchall| {\n-            match source {\n-                hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                    unreachable_pattern(cx.tcx, arm_span, arm_hir_id, catchall);\n-                }\n-                // Unreachable patterns in try and await expressions occur when one of\n-                // the arms are an uninhabited type. Which is OK.\n-                hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n+        match source {\n+            hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n+                report_arm_reachability(&cx, &report)\n             }\n-        });\n+            // Unreachable patterns in try and await expressions occur when one of\n+            // the arms are an uninhabited type. Which is OK.\n+            hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n+        }\n \n         // Check if the match is exhaustive.\n-        // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n-        // since an empty matrix can occur when there are arms, if those arms all have guards.\n         let is_empty_match = arms.is_empty();\n         let witnesses = report.non_exhaustiveness_witnesses;\n         if !witnesses.is_empty() {\n@@ -214,7 +208,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(pat.hir_id);\n \n-        let (pattern, pattern_ty) = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pattern = self.lower_pattern(&mut cx, pat, &mut false);\n+        let pattern_ty = pattern.ty();\n         let arms = vec![MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false }];\n         let report = compute_match_usefulness(&cx, &arms, pat.hir_id, pattern_ty);\n \n@@ -226,7 +221,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             return;\n         }\n \n-        let joined_patterns = joined_uncovered_patterns(&witnesses);\n+        let joined_patterns = joined_uncovered_patterns(&cx, &witnesses);\n         let mut err = struct_span_err!(\n             self.tcx.sess,\n             pat.span,\n@@ -302,7 +297,7 @@ fn const_not_var(\n     }\n }\n \n-fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n+fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_, '_>, pat: &Pat<'_>) {\n     pat.walk_always(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(ty::BindByValue(hir::Mutability::Not)) =\n@@ -344,12 +339,11 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n-    use PatKind::*;\n-    match &*pat.kind {\n-        Binding { subpattern: None, .. } => true,\n-        Binding { subpattern: Some(s), .. } | Deref { subpattern: s } => pat_is_catchall(s),\n-        Leaf { subpatterns: s } => s.iter().all(|p| pat_is_catchall(&p.pattern)),\n+fn pat_is_catchall(pat: &DeconstructedPat<'_, '_>) -> bool {\n+    use Constructor::*;\n+    match pat.ctor() {\n+        Wildcard => true,\n+        Single => pat.iter_fields().all(|pat| pat_is_catchall(pat)),\n         _ => false,\n     }\n }\n@@ -428,29 +422,16 @@ fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n fn check_let_reachability<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     pat_id: HirId,\n-    pat: &'p super::Pat<'tcx>,\n+    pat: &'p DeconstructedPat<'p, 'tcx>,\n     span: Span,\n ) {\n     let arms = [MatchArm { pat, hir_id: pat_id, has_guard: false }];\n-    let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty);\n-\n-    report_arm_reachability(&cx, &report, |arm_index, arm_span, arm_hir_id, _| {\n-        match let_source(cx.tcx, pat_id) {\n-            LetSource::IfLet | LetSource::WhileLet => {\n-                match arm_index {\n-                    // The arm with the user-specified pattern.\n-                    0 => unreachable_pattern(cx.tcx, arm_span, arm_hir_id, None),\n-                    // The arm with the wildcard pattern.\n-                    1 => irrefutable_let_pattern(cx.tcx, pat_id, arm_span),\n-                    _ => bug!(),\n-                }\n-            }\n-            LetSource::IfLetGuard if arm_index == 0 => {\n-                unreachable_pattern(cx.tcx, arm_span, arm_hir_id, None);\n-            }\n-            _ => {}\n-        }\n-    });\n+    let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty());\n+\n+    // Report if the pattern is unreachable, which can only occur when the type is uninhabited.\n+    // This also reports unreachable sub-patterns though, so we can't just replace it with an\n+    // `is_uninhabited` check.\n+    report_arm_reachability(&cx, &report);\n \n     if report.non_exhaustiveness_witnesses.is_empty() {\n         // The match is exhaustive, i.e. the `if let` pattern is irrefutable.\n@@ -459,18 +440,15 @@ fn check_let_reachability<'p, 'tcx>(\n }\n \n /// Report unreachable arms, if any.\n-fn report_arm_reachability<'p, 'tcx, F>(\n+fn report_arm_reachability<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     report: &UsefulnessReport<'p, 'tcx>,\n-    unreachable: F,\n-) where\n-    F: Fn(usize, Span, HirId, Option<Span>),\n-{\n+) {\n     use Reachability::*;\n     let mut catchall = None;\n-    for (arm_index, (arm, is_useful)) in report.arm_usefulness.iter().enumerate() {\n+    for (arm, is_useful) in report.arm_usefulness.iter() {\n         match is_useful {\n-            Unreachable => unreachable(arm_index, arm.pat.span, arm.hir_id, catchall),\n+            Unreachable => unreachable_pattern(cx.tcx, arm.pat.span(), arm.hir_id, catchall),\n             Reachable(unreachables) if unreachables.is_empty() => {}\n             // The arm is reachable, but contains unreachable subpatterns (from or-patterns).\n             Reachable(unreachables) => {\n@@ -483,7 +461,7 @@ fn report_arm_reachability<'p, 'tcx, F>(\n             }\n         }\n         if !arm.has_guard && catchall.is_none() && pat_is_catchall(arm.pat) {\n-            catchall = Some(arm.pat.span);\n+            catchall = Some(arm.pat.span());\n         }\n     }\n }\n@@ -493,7 +471,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    witnesses: Vec<super::Pat<'tcx>>,\n+    witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n     is_empty_match: bool,\n ) {\n     let non_empty_enum = match scrut_ty.kind() {\n@@ -510,7 +488,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n             format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n         );\n     } else {\n-        let joined_patterns = joined_uncovered_patterns(&witnesses);\n+        let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n         err = create_e0004(\n             cx.tcx.sess,\n             sp,\n@@ -537,7 +515,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     if (scrut_ty == cx.tcx.types.usize || scrut_ty == cx.tcx.types.isize)\n         && !is_empty_match\n         && witnesses.len() == 1\n-        && is_wildcard(&witnesses[0])\n+        && matches!(witnesses[0].ctor(), Constructor::NonExhaustive)\n     {\n         err.note(&format!(\n             \"`{}` does not have a fixed maximum value, \\\n@@ -560,33 +538,40 @@ fn non_exhaustive_match<'p, 'tcx>(\n     err.emit();\n }\n \n-crate fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n+crate fn joined_uncovered_patterns<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    witnesses: &[DeconstructedPat<'p, 'tcx>],\n+) -> String {\n     const LIMIT: usize = 3;\n+    let pat_to_str = |pat: &DeconstructedPat<'p, 'tcx>| pat.to_pat(cx).to_string();\n     match witnesses {\n         [] => bug!(),\n-        [witness] => format!(\"`{}`\", witness),\n+        [witness] => format!(\"`{}`\", witness.to_pat(cx)),\n         [head @ .., tail] if head.len() < LIMIT => {\n-            let head: Vec<_> = head.iter().map(<_>::to_string).collect();\n-            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n+            let head: Vec<_> = head.iter().map(pat_to_str).collect();\n+            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail.to_pat(cx))\n         }\n         _ => {\n             let (head, tail) = witnesses.split_at(LIMIT);\n-            let head: Vec<_> = head.iter().map(<_>::to_string).collect();\n+            let head: Vec<_> = head.iter().map(pat_to_str).collect();\n             format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n         }\n     }\n }\n \n-crate fn pattern_not_covered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n+crate fn pattern_not_covered_label(\n+    witnesses: &[DeconstructedPat<'_, '_>],\n+    joined_patterns: &str,\n+) -> String {\n     format!(\"pattern{} {} not covered\", rustc_errors::pluralize!(witnesses.len()), joined_patterns)\n }\n \n /// Point at the definition of non-covered `enum` variants.\n-fn adt_defined_here(\n-    cx: &MatchCheckCtxt<'_, '_>,\n+fn adt_defined_here<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n     err: &mut DiagnosticBuilder<'_>,\n-    ty: Ty<'_>,\n-    witnesses: &[super::Pat<'_>],\n+    ty: Ty<'tcx>,\n+    witnesses: &[DeconstructedPat<'p, 'tcx>],\n ) {\n     let ty = ty.peel_refs();\n     if let ty::Adt(def, _) = ty.kind() {\n@@ -595,57 +580,42 @@ fn adt_defined_here(\n         }\n \n         if witnesses.len() < 4 {\n-            for sp in maybe_point_at_variant(ty, &witnesses) {\n+            for sp in maybe_point_at_variant(cx, def, witnesses.iter()) {\n                 err.span_label(sp, \"not covered\");\n             }\n         }\n     }\n }\n \n-fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span> {\n+fn maybe_point_at_variant<'a, 'p: 'a, 'tcx: 'a>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    def: &AdtDef,\n+    patterns: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n+) -> Vec<Span> {\n+    use Constructor::*;\n     let mut covered = vec![];\n-    if let ty::Adt(def, _) = ty.kind() {\n-        // Don't point at variants that have already been covered due to other patterns to avoid\n-        // visual clutter.\n-        for pattern in patterns {\n-            use PatKind::{AscribeUserType, Deref, Leaf, Or, Variant};\n-            match &*pattern.kind {\n-                AscribeUserType { subpattern, .. } | Deref { subpattern } => {\n-                    covered.extend(maybe_point_at_variant(ty, slice::from_ref(&subpattern)));\n-                }\n-                Variant { adt_def, variant_index, subpatterns, .. } if adt_def.did == def.did => {\n-                    let sp = def.variants[*variant_index].ident.span;\n-                    if covered.contains(&sp) {\n-                        continue;\n-                    }\n-                    covered.push(sp);\n-\n-                    let pats = subpatterns\n-                        .iter()\n-                        .map(|field_pattern| field_pattern.pattern.clone())\n-                        .collect::<Box<[_]>>();\n-                    covered.extend(maybe_point_at_variant(ty, &pats));\n-                }\n-                Leaf { subpatterns } => {\n-                    let pats = subpatterns\n-                        .iter()\n-                        .map(|field_pattern| field_pattern.pattern.clone())\n-                        .collect::<Box<[_]>>();\n-                    covered.extend(maybe_point_at_variant(ty, &pats));\n+    for pattern in patterns {\n+        if let Variant(variant_index) = pattern.ctor() {\n+            if let ty::Adt(this_def, _) = pattern.ty().kind() {\n+                if this_def.did != def.did {\n+                    continue;\n                 }\n-                Or { pats } => {\n-                    let pats = pats.iter().cloned().collect::<Box<[_]>>();\n-                    covered.extend(maybe_point_at_variant(ty, &pats));\n-                }\n-                _ => {}\n             }\n+            let sp = def.variants[*variant_index].ident.span;\n+            if covered.contains(&sp) {\n+                // Don't point at variants that have already been covered due to other patterns to avoid\n+                // visual clutter.\n+                continue;\n+            }\n+            covered.push(sp);\n         }\n+        covered.extend(maybe_point_at_variant(cx, def, pattern.iter_fields()));\n     }\n     covered\n }\n \n /// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n-fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> bool {\n+fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId, span: Span) -> bool {\n     !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n }\n \n@@ -659,7 +629,7 @@ fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> b\n /// - `x @ Some(ref mut? y)`.\n ///\n /// This analysis is *not* subsumed by NLL.\n-fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n+fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pat<'_>) {\n     // Extract `sub` in `binding @ sub`.\n     let (name, sub) = match &pat.kind {\n         hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),"}, {"sha": "69a7d44ff3972894bcc7d0768e8844086db54fe9", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 598, "deletions": 366, "changes": 964, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -46,7 +46,7 @@ use self::Constructor::*;\n use self::SliceKind::*;\n \n use super::compare_const_vals;\n-use super::usefulness::{is_wildcard, MatchCheckCtxt, PatCtxt};\n+use super::usefulness::{MatchCheckCtxt, PatCtxt};\n \n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n@@ -56,16 +56,35 @@ use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::Field;\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt, VariantDef};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n+use std::cell::Cell;\n use std::cmp::{self, max, min, Ordering};\n+use std::fmt;\n use std::iter::{once, IntoIterator};\n use std::ops::RangeInclusive;\n \n+/// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n+fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n+    fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n+        if let PatKind::Or { pats } = pat.kind.as_ref() {\n+            for pat in pats {\n+                expand(pat, vec);\n+            }\n+        } else {\n+            vec.push(pat)\n+        }\n+    }\n+\n+    let mut pats = Vec::new();\n+    expand(pat, &mut pats);\n+    pats\n+}\n+\n /// An inclusive interval, used for precise integer exhaustiveness checking.\n /// `IntRange`s always store a contiguous range. This means that values are\n /// encoded such that `0` encodes the minimum value for the integer,\n@@ -76,9 +95,13 @@ use std::ops::RangeInclusive;\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq)]\n pub(super) struct IntRange {\n     range: RangeInclusive<u128>,\n+    /// Keeps the bias used for encoding the range. It depends on the type of the range and\n+    /// possibly the pointer size of the current architecture. The algorithm ensures we never\n+    /// compare `IntRange`s with different types/architectures.\n+    bias: u128,\n }\n \n impl IntRange {\n@@ -131,7 +154,7 @@ impl IntRange {\n                 value.try_eval_bits(tcx, param_env, ty)\n             })()?;\n             let val = val ^ bias;\n-            Some(IntRange { range: val..=val })\n+            Some(IntRange { range: val..=val, bias })\n         } else {\n             None\n         }\n@@ -155,7 +178,7 @@ impl IntRange {\n                 // This should have been caught earlier by E0030.\n                 bug!(\"malformed range pattern: {}..={}\", lo, (hi - offset));\n             }\n-            Some(IntRange { range: lo..=(hi - offset) })\n+            Some(IntRange { range: lo..=(hi - offset), bias })\n         } else {\n             None\n         }\n@@ -180,7 +203,7 @@ impl IntRange {\n         let (lo, hi) = self.boundaries();\n         let (other_lo, other_hi) = other.boundaries();\n         if lo <= other_hi && other_lo <= hi {\n-            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi) })\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), bias: self.bias })\n         } else {\n             None\n         }\n@@ -203,10 +226,11 @@ impl IntRange {\n         (lo == other_hi || hi == other_lo) && !self.is_singleton() && !other.is_singleton()\n     }\n \n+    /// Only used for displaying the range properly.\n     fn to_pat<'tcx>(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n         let (lo, hi) = self.boundaries();\n \n-        let bias = IntRange::signed_bias(tcx, ty);\n+        let bias = self.bias;\n         let (lo, hi) = (lo ^ bias, hi ^ bias);\n \n         let env = ty::ParamEnv::empty().and(ty);\n@@ -223,10 +247,10 @@ impl IntRange {\n     }\n \n     /// Lint on likely incorrect range patterns (#63987)\n-    pub(super) fn lint_overlapping_range_endpoints<'a, 'tcx: 'a>(\n+    pub(super) fn lint_overlapping_range_endpoints<'a, 'p: 'a, 'tcx: 'a>(\n         &self,\n-        pcx: PatCtxt<'_, '_, 'tcx>,\n-        ctors: impl Iterator<Item = (&'a Constructor<'tcx>, Span)>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n+        pats: impl Iterator<Item = &'a DeconstructedPat<'p, 'tcx>>,\n         column_count: usize,\n         hir_id: HirId,\n     ) {\n@@ -248,8 +272,8 @@ impl IntRange {\n             return;\n         }\n \n-        let overlaps: Vec<_> = ctors\n-            .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)))\n+        let overlaps: Vec<_> = pats\n+            .filter_map(|pat| Some((pat.ctor().as_int_range()?, pat.span())))\n             .filter(|(range, _)| self.suspicious_intersection(range))\n             .map(|(range, span)| (self.intersection(&range).unwrap(), span))\n             .collect();\n@@ -291,6 +315,19 @@ impl IntRange {\n     }\n }\n \n+/// Note: this is often not what we want: e.g. `false` is converted into the range `0..=0` and\n+/// would be displayed as such. To render properly, convert to a pattern first.\n+impl fmt::Debug for IntRange {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let (lo, hi) = self.boundaries();\n+        let bias = self.bias;\n+        let (lo, hi) = (lo ^ bias, hi ^ bias);\n+        write!(f, \"{}\", lo)?;\n+        write!(f, \"{}\", RangeEnd::Included)?;\n+        write!(f, \"{}\", hi)\n+    }\n+}\n+\n /// Represents a border between 2 integers. Because the intervals spanning borders must be able to\n /// cover every integer, we need to be able to represent 2^128 + 1 such borders.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n@@ -375,39 +412,39 @@ impl SplitIntRange {\n             // Skip duplicates.\n             .filter(|(prev_border, border)| prev_border != border)\n             // Finally, convert to ranges.\n-            .map(|(prev_border, border)| {\n+            .map(move |(prev_border, border)| {\n                 let range = match (prev_border, border) {\n                     (JustBefore(n), JustBefore(m)) if n < m => n..=(m - 1),\n                     (JustBefore(n), AfterMax) => n..=u128::MAX,\n                     _ => unreachable!(), // Ruled out by the sorting and filtering we did\n                 };\n-                IntRange { range }\n+                IntRange { range, bias: self.range.bias }\n             })\n     }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum SliceKind {\n     /// Patterns of length `n` (`[x, y]`).\n-    FixedLen(u64),\n+    FixedLen(usize),\n     /// Patterns using the `..` notation (`[x, .., y]`).\n     /// Captures any array constructor of `length >= i + j`.\n     /// In the case where `array_len` is `Some(_)`,\n     /// this indicates that we only care about the first `i` and the last `j` values of the array,\n     /// and everything in between is a wildcard `_`.\n-    VarLen(u64, u64),\n+    VarLen(usize, usize),\n }\n \n impl SliceKind {\n-    fn arity(self) -> u64 {\n+    fn arity(self) -> usize {\n         match self {\n             FixedLen(length) => length,\n             VarLen(prefix, suffix) => prefix + suffix,\n         }\n     }\n \n     /// Whether this pattern includes patterns of length `other_len`.\n-    fn covers_length(self, other_len: u64) -> bool {\n+    fn covers_length(self, other_len: usize) -> bool {\n         match self {\n             FixedLen(len) => len == other_len,\n             VarLen(prefix, suffix) => prefix + suffix <= other_len,\n@@ -419,13 +456,13 @@ impl SliceKind {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(super) struct Slice {\n     /// `None` if the matched value is a slice, `Some(n)` if it is an array of size `n`.\n-    array_len: Option<u64>,\n+    array_len: Option<usize>,\n     /// The kind of pattern it is: fixed-length `[x, y]` or variable length `[x, .., y]`.\n     kind: SliceKind,\n }\n \n impl Slice {\n-    fn new(array_len: Option<u64>, kind: SliceKind) -> Self {\n+    fn new(array_len: Option<usize>, kind: SliceKind) -> Self {\n         let kind = match (array_len, kind) {\n             // If the middle `..` is empty, we effectively have a fixed-length pattern.\n             (Some(len), VarLen(prefix, suffix)) if prefix + suffix >= len => FixedLen(len),\n@@ -434,7 +471,7 @@ impl Slice {\n         Slice { array_len, kind }\n     }\n \n-    fn arity(self) -> u64 {\n+    fn arity(self) -> usize {\n         self.kind.arity()\n     }\n \n@@ -508,16 +545,16 @@ impl Slice {\n #[derive(Debug)]\n struct SplitVarLenSlice {\n     /// If the type is an array, this is its size.\n-    array_len: Option<u64>,\n+    array_len: Option<usize>,\n     /// The arity of the input slice.\n-    arity: u64,\n+    arity: usize,\n     /// The smallest slice bigger than any slice seen. `max_slice.arity()` is the length `L`\n     /// described above.\n     max_slice: SliceKind,\n }\n \n impl SplitVarLenSlice {\n-    fn new(prefix: u64, suffix: u64, array_len: Option<u64>) -> Self {\n+    fn new(prefix: usize, suffix: usize, array_len: Option<usize>) -> Self {\n         SplitVarLenSlice { array_len, arity: prefix + suffix, max_slice: VarLen(prefix, suffix) }\n     }\n \n@@ -611,6 +648,8 @@ pub(super) enum Constructor<'tcx> {\n     Missing { nonexhaustive_enum_missing_real_variants: bool },\n     /// Wildcard pattern.\n     Wildcard,\n+    /// Or-pattern.\n+    Or,\n }\n \n impl<'tcx> Constructor<'tcx> {\n@@ -647,60 +686,34 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n-    /// Determines the constructor that the given pattern can be specialized to.\n-    pub(super) fn from_pat<'p>(cx: &MatchCheckCtxt<'p, 'tcx>, pat: &'p Pat<'tcx>) -> Self {\n-        match pat.kind.as_ref() {\n-            PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n-            PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n-            PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n-            &PatKind::Variant { variant_index, .. } => Variant(variant_index),\n-            PatKind::Constant { value } => {\n-                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value) {\n-                    IntRange(int_range)\n-                } else {\n-                    match pat.ty.kind() {\n-                        ty::Float(_) => FloatRange(value, value, RangeEnd::Included),\n-                        // In `expand_pattern`, we convert string literals to `&CONST` patterns with\n-                        // `CONST` a pattern of type `str`. In truth this contains a constant of type\n-                        // `&str`.\n-                        ty::Str => Str(value),\n-                        // All constants that can be structurally matched have already been expanded\n-                        // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n-                        // opaque.\n-                        _ => Opaque,\n+    /// The number of fields for this constructor. This must be kept in sync with\n+    /// `Fields::wildcards`.\n+    pub(super) fn arity(&self, pcx: PatCtxt<'_, '_, 'tcx>) -> usize {\n+        match self {\n+            Single | Variant(_) => match pcx.ty.kind() {\n+                ty::Tuple(fs) => fs.len(),\n+                ty::Ref(..) => 1,\n+                ty::Adt(adt, ..) => {\n+                    if adt.is_box() {\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n+                        1\n+                    } else {\n+                        let variant = &adt.variants[self.variant_index_for_adt(adt)];\n+                        Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant).count()\n                     }\n                 }\n-            }\n-            &PatKind::Range(PatRange { lo, hi, end }) => {\n-                let ty = lo.ty;\n-                if let Some(int_range) = IntRange::from_range(\n-                    cx.tcx,\n-                    lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n-                    hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n-                    ty,\n-                    &end,\n-                ) {\n-                    IntRange(int_range)\n-                } else {\n-                    FloatRange(lo, hi, end)\n-                }\n-            }\n-            PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n-                let array_len = match pat.ty.kind() {\n-                    ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env)),\n-                    ty::Slice(_) => None,\n-                    _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n-                };\n-                let prefix = prefix.len() as u64;\n-                let suffix = suffix.len() as u64;\n-                let kind = if slice.is_some() {\n-                    VarLen(prefix, suffix)\n-                } else {\n-                    FixedLen(prefix + suffix)\n-                };\n-                Slice(Slice::new(array_len, kind))\n-            }\n-            PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n+                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx.ty),\n+            },\n+            Slice(slice) => slice.arity(),\n+            Str(..)\n+            | FloatRange(..)\n+            | IntRange(..)\n+            | NonExhaustive\n+            | Opaque\n+            | Missing { .. }\n+            | Wildcard => 0,\n+            Or => bug!(\"The `Or` constructor doesn't have a fixed arity\"),\n         }\n     }\n \n@@ -823,7 +836,7 @@ impl<'tcx> Constructor<'tcx> {\n         match self {\n             // If `self` is `Single`, `used_ctors` cannot contain anything else than `Single`s.\n             Single => !used_ctors.is_empty(),\n-            Variant(_) => used_ctors.iter().any(|c| c == self),\n+            Variant(vid) => used_ctors.iter().any(|c| matches!(c, Variant(i) if i == vid)),\n             IntRange(range) => used_ctors\n                 .iter()\n                 .filter_map(|c| c.as_int_range())\n@@ -834,7 +847,7 @@ impl<'tcx> Constructor<'tcx> {\n                 .any(|other| slice.is_covered_by(other)),\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n-            Str(..) | FloatRange(..) | Opaque | Missing { .. } | Wildcard => {\n+            Str(..) | FloatRange(..) | Opaque | Missing { .. } | Wildcard | Or => {\n                 span_bug!(pcx.span, \"found unexpected ctor in all_ctors: {:?}\", self)\n             }\n         }\n@@ -885,7 +898,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n         let all_ctors = match pcx.ty.kind() {\n             ty::Bool => smallvec![make_range(0, 1)],\n             ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n-                let len = len.eval_usize(cx.tcx, cx.param_env);\n+                let len = len.eval_usize(cx.tcx, cx.param_env) as usize;\n                 if len != 0 && cx.is_uninhabited(sub_ty) {\n                     smallvec![]\n                 } else {\n@@ -1073,120 +1086,106 @@ impl<'tcx> SplitWildcard<'tcx> {\n     }\n }\n \n-/// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n-/// `Fields` struct. This struct represents such a potentially-hidden field.\n-#[derive(Debug, Copy, Clone)]\n-pub(super) enum FilteredField<'p, 'tcx> {\n-    Kept(&'p Pat<'tcx>),\n-    Hidden,\n-}\n-\n-impl<'p, 'tcx> FilteredField<'p, 'tcx> {\n-    fn kept(self) -> Option<&'p Pat<'tcx>> {\n-        match self {\n-            FilteredField::Kept(p) => Some(p),\n-            FilteredField::Hidden => None,\n-        }\n-    }\n-}\n-\n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n /// those fields, generalized to allow patterns in each field. See also `Constructor`.\n-/// This is constructed from a constructor using [`Fields::wildcards()`].\n ///\n-/// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n-/// uninhabited. For that, we filter these fields out of the matrix. This is handled automatically\n-/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rarely used,\n-/// so we avoid it when possible to preserve performance.\n-#[derive(Debug, Clone)]\n-pub(super) enum Fields<'p, 'tcx> {\n-    /// Lists of patterns that don't contain any filtered fields.\n-    /// `Slice` and `Vec` behave the same; the difference is only to avoid allocating and\n-    /// triple-dereferences when possible. Frankly this is premature optimization, I (Nadrieril)\n-    /// have not measured if it really made a difference.\n-    Slice(&'p [Pat<'tcx>]),\n-    Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n-    /// Patterns where some of the fields need to be hidden. For all intents and purposes we only\n-    /// care about the non-hidden fields. We need to keep the real field index for those fields;\n-    /// we're morally storing a `Vec<(usize, &Pat)>` but what we do is more convenient.\n-    /// `len` counts the number of non-hidden fields\n-    Filtered {\n-        fields: SmallVec<[FilteredField<'p, 'tcx>; 2]>,\n-        len: usize,\n-    },\n+/// This is constructed for a constructor using [`Fields::wildcards()`]. The idea is that\n+/// [`Fields::wildcards()`] constructs a list of fields where all entries are wildcards, and then\n+/// given a pattern we fill some of the fields with its subpatterns.\n+/// In the following example `Fields::wildcards` returns `[_, _, _, _]`. Then in\n+/// `extract_pattern_arguments` we fill some of the entries, and the result is\n+/// `[Some(0), _, _, _]`.\n+/// ```rust\n+/// let x: [Option<u8>; 4] = foo();\n+/// match x {\n+///     [Some(0), ..] => {}\n+/// }\n+/// ```\n+///\n+/// Note that the number of fields of a constructor may not match the fields declared in the\n+/// original struct/variant. This happens if a private or `non_exhaustive` field is uninhabited,\n+/// because the code mustn't observe that it is uninhabited. In that case that field is not\n+/// included in `fields`. For that reason, when you have a `mir::Field` you must use\n+/// `index_with_declared_idx`.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) struct Fields<'p, 'tcx> {\n+    fields: &'p [DeconstructedPat<'p, 'tcx>],\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n-    /// Internal use. Use `Fields::wildcards()` instead.\n-    /// Must not be used if the pattern is a field of a struct/tuple/variant.\n-    fn from_single_pattern(pat: &'p Pat<'tcx>) -> Self {\n-        Fields::Slice(std::slice::from_ref(pat))\n+    fn empty() -> Self {\n+        Fields { fields: &[] }\n+    }\n+\n+    fn singleton(cx: &MatchCheckCtxt<'p, 'tcx>, field: DeconstructedPat<'p, 'tcx>) -> Self {\n+        let field: &_ = cx.pattern_arena.alloc(field);\n+        Fields { fields: std::slice::from_ref(field) }\n+    }\n+\n+    pub(super) fn from_iter(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        fields: impl IntoIterator<Item = DeconstructedPat<'p, 'tcx>>,\n+    ) -> Self {\n+        let fields: &[_] = cx.pattern_arena.alloc_from_iter(fields);\n+        Fields { fields }\n     }\n \n-    /// Convenience; internal use.\n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         tys: impl IntoIterator<Item = Ty<'tcx>>,\n     ) -> Self {\n-        let wilds = tys.into_iter().map(Pat::wildcard_from_ty);\n-        let pats = cx.pattern_arena.alloc_from_iter(wilds);\n-        Fields::Slice(pats)\n+        Fields::from_iter(cx, tys.into_iter().map(DeconstructedPat::wildcard))\n     }\n \n-    /// Creates a new list of wildcard fields for a given constructor.\n-    pub(super) fn wildcards(pcx: PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n-        let ty = pcx.ty;\n-        let cx = pcx.cx;\n-        let wildcard_from_ty = |ty| &*cx.pattern_arena.alloc(Pat::wildcard_from_ty(ty));\n+    // In the cases of either a `#[non_exhaustive]` field list or a non-public field, we hide\n+    // uninhabited fields in order not to reveal the uninhabitedness of the whole variant.\n+    // This lists the fields we keep along with their types.\n+    fn list_variant_nonhidden_fields<'a>(\n+        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n+        ty: Ty<'tcx>,\n+        variant: &'a VariantDef,\n+    ) -> impl Iterator<Item = (Field, Ty<'tcx>)> + Captures<'a> + Captures<'p> {\n+        let (adt, substs) = match ty.kind() {\n+            ty::Adt(adt, substs) => (adt, substs),\n+            _ => bug!(),\n+        };\n+        // Whether we must not match the fields of this variant exhaustively.\n+        let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n+\n+        variant.fields.iter().enumerate().filter_map(move |(i, field)| {\n+            let ty = field.ty(cx.tcx, substs);\n+            let is_visible = adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n+            let is_uninhabited = cx.is_uninhabited(ty);\n+\n+            if is_uninhabited && (!is_visible || is_non_exhaustive) {\n+                None\n+            } else {\n+                Some((Field::new(i), ty))\n+            }\n+        })\n+    }\n \n+    /// Creates a new list of wildcard fields for a given constructor. The result must have a\n+    /// length of `constructor.arity()`.\n+    pub(super) fn wildcards(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        ty: Ty<'tcx>,\n+        constructor: &Constructor<'tcx>,\n+    ) -> Self {\n         let ret = match constructor {\n             Single | Variant(_) => match ty.kind() {\n-                ty::Tuple(ref fs) => {\n-                    Fields::wildcards_from_tys(cx, fs.into_iter().map(|ty| ty.expect_ty()))\n-                }\n-                ty::Ref(_, rty, _) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter().map(|ty| ty.expect_ty())),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n-                        // Use T as the sub pattern type of Box<T>.\n-                        Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n+                        Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variants[constructor.variant_index_for_adt(adt)];\n-                        // Whether we must not match the fields of this variant exhaustively.\n-                        let is_non_exhaustive =\n-                            variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n-                        let field_tys = variant.fields.iter().map(|field| field.ty(cx.tcx, substs));\n-                        // In the following cases, we don't need to filter out any fields. This is\n-                        // the vast majority of real cases, since uninhabited fields are uncommon.\n-                        let has_no_hidden_fields = (adt.is_enum() && !is_non_exhaustive)\n-                            || !field_tys.clone().any(|ty| cx.is_uninhabited(ty));\n-\n-                        if has_no_hidden_fields {\n-                            Fields::wildcards_from_tys(cx, field_tys)\n-                        } else {\n-                            let mut len = 0;\n-                            let fields = variant\n-                                .fields\n-                                .iter()\n-                                .map(|field| {\n-                                    let ty = field.ty(cx.tcx, substs);\n-                                    let is_visible = adt.is_enum()\n-                                        || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                                    let is_uninhabited = cx.is_uninhabited(ty);\n-\n-                                    // In the cases of either a `#[non_exhaustive]` field list\n-                                    // or a non-public field, we hide uninhabited fields in\n-                                    // order not to reveal the uninhabitedness of the whole\n-                                    // variant.\n-                                    if is_uninhabited && (!is_visible || is_non_exhaustive) {\n-                                        FilteredField::Hidden\n-                                    } else {\n-                                        len += 1;\n-                                        FilteredField::Kept(wildcard_from_ty(ty))\n-                                    }\n-                                })\n-                                .collect();\n-                            Fields::Filtered { fields, len }\n-                        }\n+                        let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n+                            .map(|(_, ty)| ty);\n+                        Fields::wildcards_from_tys(cx, tys)\n                     }\n                 }\n                 _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n@@ -1204,250 +1203,483 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             | NonExhaustive\n             | Opaque\n             | Missing { .. }\n-            | Wildcard => Fields::Slice(&[]),\n+            | Wildcard => Fields::empty(),\n+            Or => {\n+                bug!(\"called `Fields::wildcards` on an `Or` ctor\")\n+            }\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n     }\n \n-    /// Apply a constructor to a list of patterns, yielding a new pattern. `self`\n-    /// must have as many elements as this constructor's arity.\n-    ///\n-    /// This is roughly the inverse of `specialize_constructor`.\n-    ///\n-    /// Examples:\n-    ///\n-    /// ```text\n-    /// ctor: `Constructor::Single`\n-    /// ty: `Foo(u32, u32, u32)`\n-    /// self: `[10, 20, _]`\n-    /// returns `Foo(10, 20, _)`\n-    ///\n-    /// ctor: `Constructor::Variant(Option::Some)`\n-    /// ty: `Option<bool>`\n-    /// self: `[false]`\n-    /// returns `Some(false)`\n-    /// ```\n-    pub(super) fn apply(self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Pat<'tcx> {\n-        let subpatterns_and_indices = self.patterns_and_indices();\n-        let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p).cloned();\n-\n-        let pat = match ctor {\n-            Single | Variant(_) => match pcx.ty.kind() {\n-                ty::Adt(..) | ty::Tuple(..) => {\n-                    // We want the real indices here.\n-                    let subpatterns = subpatterns_and_indices\n-                        .iter()\n-                        .map(|&(field, p)| FieldPat { field, pattern: p.clone() })\n-                        .collect();\n+    /// Returns the list of patterns.\n+    pub(super) fn iter_patterns<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = &'p DeconstructedPat<'p, 'tcx>> + Captures<'a> {\n+        self.fields.iter()\n+    }\n+}\n \n-                    if let ty::Adt(adt, substs) = pcx.ty.kind() {\n-                        if adt.is_enum() {\n-                            PatKind::Variant {\n-                                adt_def: adt,\n-                                substs,\n-                                variant_index: ctor.variant_index_for_adt(adt),\n-                                subpatterns,\n-                            }\n+/// Values and patterns can be represented as a constructor applied to some fields. This represents\n+/// a pattern in this form.\n+/// This also keeps track of whether the pattern has been foundreachable during analysis. For this\n+/// reason we should be careful not to clone patterns for which we care about that. Use\n+/// `clone_and_forget_reachability` is you're sure.\n+pub(crate) struct DeconstructedPat<'p, 'tcx> {\n+    ctor: Constructor<'tcx>,\n+    fields: Fields<'p, 'tcx>,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+    reachable: Cell<bool>,\n+}\n+\n+impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n+    pub(super) fn wildcard(ty: Ty<'tcx>) -> Self {\n+        Self::new(Wildcard, Fields::empty(), ty, DUMMY_SP)\n+    }\n+\n+    pub(super) fn new(\n+        ctor: Constructor<'tcx>,\n+        fields: Fields<'p, 'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Self {\n+        DeconstructedPat { ctor, fields, ty, span, reachable: Cell::new(false) }\n+    }\n+\n+    /// Construct a pattern that matches everything that starts with this constructor.\n+    /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n+    /// `Some(_)`.\n+    pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n+        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n+        DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n+    }\n+\n+    /// Clone this value. This method emphasizes that cloning loses reachability information and\n+    /// should be done carefully.\n+    pub(super) fn clone_and_forget_reachability(&self) -> Self {\n+        DeconstructedPat::new(self.ctor.clone(), self.fields, self.ty, self.span)\n+    }\n+\n+    pub(crate) fn from_pat(cx: &MatchCheckCtxt<'p, 'tcx>, pat: &Pat<'tcx>) -> Self {\n+        let mkpat = |pat| DeconstructedPat::from_pat(cx, pat);\n+        let ctor;\n+        let fields;\n+        match pat.kind.as_ref() {\n+            PatKind::AscribeUserType { subpattern, .. } => return mkpat(subpattern),\n+            PatKind::Binding { subpattern: Some(subpat), .. } => return mkpat(subpat),\n+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => {\n+                ctor = Wildcard;\n+                fields = Fields::empty();\n+            }\n+            PatKind::Deref { subpattern } => {\n+                ctor = Single;\n+                fields = Fields::singleton(cx, mkpat(subpattern));\n+            }\n+            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n+                match pat.ty.kind() {\n+                    ty::Tuple(fs) => {\n+                        ctor = Single;\n+                        let mut wilds: SmallVec<[_; 2]> = fs\n+                            .iter()\n+                            .map(|ty| ty.expect_ty())\n+                            .map(DeconstructedPat::wildcard)\n+                            .collect();\n+                        for pat in subpatterns {\n+                            wilds[pat.field.index()] = mkpat(&pat.pattern);\n+                        }\n+                        fields = Fields::from_iter(cx, wilds);\n+                    }\n+                    ty::Adt(adt, substs) if adt.is_box() => {\n+                        // The only legal patterns of type `Box` (outside `std`) are `_` and box\n+                        // patterns. If we're here we can assume this is a box pattern.\n+                        // FIXME(Nadrieril): A `Box` can in theory be matched either with `Box(_,\n+                        // _)` or a box pattern. As a hack to avoid an ICE with the former, we\n+                        // ignore other fields than the first one. This will trigger an error later\n+                        // anyway.\n+                        // See https://github.com/rust-lang/rust/issues/82772 ,\n+                        // explanation: https://github.com/rust-lang/rust/pull/82789#issuecomment-796921977\n+                        // The problem is that we can't know from the type whether we'll match\n+                        // normally or through box-patterns. We'll have to figure out a proper\n+                        // solution when we introduce generalized deref patterns. Also need to\n+                        // prevent mixing of those two options.\n+                        let pat = subpatterns.into_iter().find(|pat| pat.field.index() == 0);\n+                        let pat = if let Some(pat) = pat {\n+                            mkpat(&pat.pattern)\n                         } else {\n-                            PatKind::Leaf { subpatterns }\n+                            DeconstructedPat::wildcard(substs.type_at(0))\n+                        };\n+                        ctor = Single;\n+                        fields = Fields::singleton(cx, pat);\n+                    }\n+                    ty::Adt(adt, _) => {\n+                        ctor = match pat.kind.as_ref() {\n+                            PatKind::Leaf { .. } => Single,\n+                            PatKind::Variant { variant_index, .. } => Variant(*variant_index),\n+                            _ => bug!(),\n+                        };\n+                        let variant = &adt.variants[ctor.variant_index_for_adt(adt)];\n+                        // For each field in the variant, we store the relevant index into `self.fields` if any.\n+                        let mut field_id_to_id: Vec<Option<usize>> =\n+                            (0..variant.fields.len()).map(|_| None).collect();\n+                        let tys = Fields::list_variant_nonhidden_fields(cx, pat.ty, variant)\n+                            .enumerate()\n+                            .map(|(i, (field, ty))| {\n+                                field_id_to_id[field.index()] = Some(i);\n+                                ty\n+                            });\n+                        let mut wilds: SmallVec<[_; 2]> =\n+                            tys.map(DeconstructedPat::wildcard).collect();\n+                        for pat in subpatterns {\n+                            if let Some(i) = field_id_to_id[pat.field.index()] {\n+                                wilds[i] = mkpat(&pat.pattern);\n+                            }\n+                        }\n+                        fields = Fields::from_iter(cx, wilds);\n+                    }\n+                    _ => bug!(\"pattern has unexpected type: pat: {:?}, ty: {:?}\", pat, pat.ty),\n+                }\n+            }\n+            PatKind::Constant { value } => {\n+                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value) {\n+                    ctor = IntRange(int_range);\n+                    fields = Fields::empty();\n+                } else {\n+                    match pat.ty.kind() {\n+                        ty::Float(_) => {\n+                            ctor = FloatRange(value, value, RangeEnd::Included);\n+                            fields = Fields::empty();\n+                        }\n+                        ty::Ref(_, t, _) if t.is_str() => {\n+                            // We want a `&str` constant to behave like a `Deref` pattern, to be compatible\n+                            // with other `Deref` patterns. This could have been done in `const_to_pat`,\n+                            // but that causes issues with the rest of the matching code.\n+                            // So here, the constructor for a `\"foo\"` pattern is `&` (represented by\n+                            // `Single`), and has one field. That field has constructor `Str(value)` and no\n+                            // fields.\n+                            // Note: `t` is `str`, not `&str`.\n+                            let subpattern =\n+                                DeconstructedPat::new(Str(value), Fields::empty(), t, pat.span);\n+                            ctor = Single;\n+                            fields = Fields::singleton(cx, subpattern)\n+                        }\n+                        // All constants that can be structurally matched have already been expanded\n+                        // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n+                        // opaque.\n+                        _ => {\n+                            ctor = Opaque;\n+                            fields = Fields::empty();\n                         }\n+                    }\n+                }\n+            }\n+            &PatKind::Range(PatRange { lo, hi, end }) => {\n+                let ty = lo.ty;\n+                ctor = if let Some(int_range) = IntRange::from_range(\n+                    cx.tcx,\n+                    lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n+                    hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n+                    ty,\n+                    &end,\n+                ) {\n+                    IntRange(int_range)\n+                } else {\n+                    FloatRange(lo, hi, end)\n+                };\n+                fields = Fields::empty();\n+            }\n+            PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n+                let array_len = match pat.ty.kind() {\n+                    ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env) as usize),\n+                    ty::Slice(_) => None,\n+                    _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n+                };\n+                let kind = if slice.is_some() {\n+                    VarLen(prefix.len(), suffix.len())\n+                } else {\n+                    FixedLen(prefix.len() + suffix.len())\n+                };\n+                ctor = Slice(Slice::new(array_len, kind));\n+                fields = Fields::from_iter(cx, prefix.iter().chain(suffix).map(mkpat));\n+            }\n+            PatKind::Or { .. } => {\n+                ctor = Or;\n+                let pats = expand_or_pat(pat);\n+                fields = Fields::from_iter(cx, pats.into_iter().map(mkpat));\n+            }\n+        }\n+        DeconstructedPat::new(ctor, fields, pat.ty, pat.span)\n+    }\n+\n+    pub(crate) fn to_pat(&self, cx: &MatchCheckCtxt<'p, 'tcx>) -> Pat<'tcx> {\n+        let is_wildcard = |pat: &Pat<'_>| {\n+            matches!(*pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n+        };\n+        let mut subpatterns = self.iter_fields().map(|p| p.to_pat(cx));\n+        let pat = match &self.ctor {\n+            Single | Variant(_) => match self.ty.kind() {\n+                ty::Tuple(..) => PatKind::Leaf {\n+                    subpatterns: subpatterns\n+                        .enumerate()\n+                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                        .collect(),\n+                },\n+                ty::Adt(adt_def, _) if adt_def.is_box() => {\n+                    // Without `box_patterns`, the only legal pattern of type `Box` is `_` (outside\n+                    // of `std`). So this branch is only reachable when the feature is enabled and\n+                    // the pattern is a box pattern.\n+                    PatKind::Deref { subpattern: subpatterns.next().unwrap() }\n+                }\n+                ty::Adt(adt_def, substs) => {\n+                    let variant_index = self.ctor.variant_index_for_adt(adt_def);\n+                    let variant = &adt_def.variants[variant_index];\n+                    let subpatterns = Fields::list_variant_nonhidden_fields(cx, self.ty, variant)\n+                        .zip(subpatterns)\n+                        .map(|((field, _ty), pattern)| FieldPat { field, pattern })\n+                        .collect();\n+\n+                    if adt_def.is_enum() {\n+                        PatKind::Variant { adt_def, substs, variant_index, subpatterns }\n                     } else {\n                         PatKind::Leaf { subpatterns }\n                     }\n                 }\n                 // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n                 // be careful to reconstruct the correct constant pattern here. However a string\n                 // literal pattern will never be reported as a non-exhaustiveness witness, so we\n-                // can ignore this issue.\n+                // ignore this issue.\n                 ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n-                ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", ctor, pcx.ty),\n-                _ => PatKind::Wild,\n+                _ => bug!(\"unexpected ctor for type {:?} {:?}\", self.ctor, self.ty),\n             },\n-            Slice(slice) => match slice.kind {\n-                FixedLen(_) => {\n-                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-                }\n-                VarLen(prefix, _) => {\n-                    let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix as usize).collect();\n-                    if slice.array_len.is_some() {\n-                        // Improves diagnostics a bit: if the type is a known-size array, instead\n-                        // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n-                        // This is incorrect if the size is not known, since `[_, ..]` captures\n-                        // arrays of lengths `>= 1` whereas `[..]` captures any length.\n-                        while !prefix.is_empty() && is_wildcard(prefix.last().unwrap()) {\n-                            prefix.pop();\n+            Slice(slice) => {\n+                match slice.kind {\n+                    FixedLen(_) => PatKind::Slice {\n+                        prefix: subpatterns.collect(),\n+                        slice: None,\n+                        suffix: vec![],\n+                    },\n+                    VarLen(prefix, _) => {\n+                        let mut subpatterns = subpatterns.peekable();\n+                        let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix).collect();\n+                        if slice.array_len.is_some() {\n+                            // Improves diagnostics a bit: if the type is a known-size array, instead\n+                            // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n+                            // This is incorrect if the size is not known, since `[_, ..]` captures\n+                            // arrays of lengths `>= 1` whereas `[..]` captures any length.\n+                            while !prefix.is_empty() && is_wildcard(prefix.last().unwrap()) {\n+                                prefix.pop();\n+                            }\n+                            while subpatterns.peek().is_some()\n+                                && is_wildcard(subpatterns.peek().unwrap())\n+                            {\n+                                subpatterns.next();\n+                            }\n                         }\n+                        let suffix: Vec<_> = subpatterns.collect();\n+                        let wild = Pat::wildcard_from_ty(self.ty);\n+                        PatKind::Slice { prefix, slice: Some(wild), suffix }\n                     }\n-                    let suffix: Vec<_> = if slice.array_len.is_some() {\n-                        // Same as above.\n-                        subpatterns.skip_while(is_wildcard).collect()\n-                    } else {\n-                        subpatterns.collect()\n-                    };\n-                    let wild = Pat::wildcard_from_ty(pcx.ty);\n-                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n                 }\n-            },\n+            }\n             &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n-            IntRange(range) => return range.to_pat(pcx.cx.tcx, pcx.ty),\n-            NonExhaustive => PatKind::Wild,\n-            Wildcard => return Pat::wildcard_from_ty(pcx.ty),\n-            Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n+            IntRange(range) => return range.to_pat(cx.tcx, self.ty),\n+            Wildcard | NonExhaustive => PatKind::Wild,\n             Missing { .. } => bug!(\n-                \"trying to apply the `Missing` constructor; this should have been done in `apply_constructors`\"\n+                \"trying to convert a `Missing` constructor into a `Pat`; this is probably a bug,\n+                `Missing` should have been processed in `apply_constructors`\"\n             ),\n+            Opaque | Or => {\n+                bug!(\"can't convert to pattern: {:?}\", self)\n+            }\n         };\n \n-        Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n+        Pat { ty: self.ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n \n-    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n-    /// construct `self`.\n-    pub(super) fn len(&self) -> usize {\n-        match self {\n-            Fields::Slice(pats) => pats.len(),\n-            Fields::Vec(pats) => pats.len(),\n-            Fields::Filtered { len, .. } => *len,\n-        }\n+    pub(super) fn is_or_pat(&self) -> bool {\n+        matches!(self.ctor, Or)\n     }\n \n-    /// Returns the list of patterns along with the corresponding field indices.\n-    fn patterns_and_indices(&self) -> SmallVec<[(Field, &'p Pat<'tcx>); 2]> {\n-        match self {\n-            Fields::Slice(pats) => {\n-                pats.iter().enumerate().map(|(i, p)| (Field::new(i), p)).collect()\n-            }\n-            Fields::Vec(pats) => {\n-                pats.iter().copied().enumerate().map(|(i, p)| (Field::new(i), p)).collect()\n-            }\n-            Fields::Filtered { fields, .. } => {\n-                // Indices must be relative to the full list of patterns\n-                fields\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, p)| Some((Field::new(i), p.kept()?)))\n-                    .collect()\n-            }\n-        }\n+    pub(super) fn ctor(&self) -> &Constructor<'tcx> {\n+        &self.ctor\n     }\n-\n-    /// Returns the list of patterns.\n-    pub(super) fn into_patterns(self) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n-        match self {\n-            Fields::Slice(pats) => pats.iter().collect(),\n-            Fields::Vec(pats) => pats,\n-            Fields::Filtered { fields, .. } => fields.iter().filter_map(|p| p.kept()).collect(),\n-        }\n+    pub(super) fn ty(&self) -> Ty<'tcx> {\n+        self.ty\n     }\n-\n-    /// Overrides some of the fields with the provided patterns. Exactly like\n-    /// `replace_fields_indexed`, except that it takes `FieldPat`s as input.\n-    fn replace_with_fieldpats(\n-        &self,\n-        new_pats: impl IntoIterator<Item = &'p FieldPat<'tcx>>,\n-    ) -> Self {\n-        self.replace_fields_indexed(\n-            new_pats.into_iter().map(|pat| (pat.field.index(), &pat.pattern)),\n-        )\n+    pub(super) fn span(&self) -> Span {\n+        self.span\n     }\n \n-    /// Overrides some of the fields with the provided patterns. This is used when a pattern\n-    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start\n-    /// with a `Fields` that is just one wildcard per field of the `Foo` struct, and override the\n-    /// entry corresponding to `field1` with the pattern `Some(_)`. This is also used for slice\n-    /// patterns for the same reason.\n-    fn replace_fields_indexed(\n-        &self,\n-        new_pats: impl IntoIterator<Item = (usize, &'p Pat<'tcx>)>,\n-    ) -> Self {\n-        let mut fields = self.clone();\n-        if let Fields::Slice(pats) = fields {\n-            fields = Fields::Vec(pats.iter().collect());\n-        }\n+    pub(super) fn iter_fields<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = &'p DeconstructedPat<'p, 'tcx>> + Captures<'a> {\n+        self.fields.iter_patterns()\n+    }\n \n-        match &mut fields {\n-            Fields::Vec(pats) => {\n-                for (i, pat) in new_pats {\n-                    if let Some(p) = pats.get_mut(i) {\n-                        *p = pat;\n-                    }\n-                }\n+    /// Specialize this pattern with a constructor.\n+    /// `other_ctor` can be different from `self.ctor`, but must be covered by it.\n+    pub(super) fn specialize<'a>(\n+        &'a self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        other_ctor: &Constructor<'tcx>,\n+    ) -> SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]> {\n+        match (&self.ctor, other_ctor) {\n+            (Wildcard, _) => {\n+                // We return a wildcard for each field of `other_ctor`.\n+                Fields::wildcards(cx, self.ty, other_ctor).iter_patterns().collect()\n             }\n-            Fields::Filtered { fields, .. } => {\n-                for (i, pat) in new_pats {\n-                    if let FilteredField::Kept(p) = &mut fields[i] {\n-                        *p = pat\n+            (Slice(self_slice), Slice(other_slice))\n+                if self_slice.arity() != other_slice.arity() =>\n+            {\n+                // The only tricky case: two slices of different arity. Since `self_slice` covers\n+                // `other_slice`, `self_slice` must be `VarLen`, i.e. of the form\n+                // `[prefix, .., suffix]`. Moreover `other_slice` is guaranteed to have a larger\n+                // arity. So we fill the middle part with enough wildcards to reach the length of\n+                // the new, larger slice.\n+                match self_slice.kind {\n+                    FixedLen(_) => bug!(\"{:?} doesn't cover {:?}\", self_slice, other_slice),\n+                    VarLen(prefix, suffix) => {\n+                        let inner_ty = match *self.ty.kind() {\n+                            ty::Slice(ty) | ty::Array(ty, _) => ty,\n+                            _ => bug!(\"bad slice pattern {:?} {:?}\", self.ctor, self.ty),\n+                        };\n+                        let prefix = &self.fields.fields[..prefix];\n+                        let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n+                        let wildcard: &_ =\n+                            cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n+                        let extra_wildcards = other_slice.arity() - self_slice.arity();\n+                        let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n+                        prefix.iter().chain(extra_wildcards).chain(suffix).collect()\n                     }\n                 }\n             }\n-            Fields::Slice(_) => unreachable!(),\n+            _ => self.fields.iter_patterns().collect(),\n         }\n-        fields\n     }\n \n-    /// Replaces contained fields with the given list of patterns. There must be `len()` patterns\n-    /// in `pats`.\n-    pub(super) fn replace_fields(\n-        &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        pats: impl IntoIterator<Item = Pat<'tcx>>,\n-    ) -> Self {\n-        let pats: &[_] = cx.pattern_arena.alloc_from_iter(pats);\n+    /// We keep track for each pattern if it was ever reachable during the analysis. This is used\n+    /// with `unreachable_spans` to report unreachable subpatterns arising from or patterns.\n+    pub(super) fn set_reachable(&self) {\n+        self.reachable.set(true)\n+    }\n+    pub(super) fn is_reachable(&self) -> bool {\n+        self.reachable.get()\n+    }\n \n-        match self {\n-            Fields::Filtered { fields, len } => {\n-                let mut pats = pats.iter();\n-                let mut fields = fields.clone();\n-                for f in &mut fields {\n-                    if let FilteredField::Kept(p) = f {\n-                        // We take one input pattern for each `Kept` field, in order.\n-                        *p = pats.next().unwrap();\n-                    }\n-                }\n-                Fields::Filtered { fields, len: *len }\n+    /// Report the spans of subpatterns that were not reachable, if any.\n+    pub(super) fn unreachable_spans(&self) -> Vec<Span> {\n+        let mut spans = Vec::new();\n+        self.collect_unreachable_spans(&mut spans);\n+        spans\n+    }\n+\n+    fn collect_unreachable_spans(&self, spans: &mut Vec<Span>) {\n+        // We don't look at subpatterns if we already reported the whole pattern as unreachable.\n+        if !self.is_reachable() {\n+            spans.push(self.span);\n+        } else {\n+            for p in self.iter_fields() {\n+                p.collect_unreachable_spans(spans);\n             }\n-            _ => Fields::Slice(pats),\n         }\n     }\n+}\n \n-    /// Replaces contained fields with the arguments of the given pattern. Only use on a pattern\n-    /// that is compatible with the constructor used to build `self`.\n-    /// This is meant to be used on the result of `Fields::wildcards()`. The idea is that\n-    /// `wildcards` constructs a list of fields where all entries are wildcards, and the pattern\n-    /// provided to this function fills some of the fields with non-wildcards.\n-    /// In the following example `Fields::wildcards` would return `[_, _, _, _]`. If we call\n-    /// `replace_with_pattern_arguments` on it with the pattern, the result will be `[Some(0), _,\n-    /// _, _]`.\n-    /// ```rust\n-    /// let x: [Option<u8>; 4] = foo();\n-    /// match x {\n-    ///     [Some(0), ..] => {}\n-    /// }\n-    /// ```\n-    /// This is guaranteed to preserve the number of patterns in `self`.\n-    pub(super) fn replace_with_pattern_arguments(&self, pat: &'p Pat<'tcx>) -> Self {\n-        match pat.kind.as_ref() {\n-            PatKind::Deref { subpattern } => {\n-                assert_eq!(self.len(), 1);\n-                Fields::from_single_pattern(subpattern)\n+/// This is mostly copied from the `Pat` impl. This is best effort and not good enough for a\n+/// `Display` impl.\n+impl<'p, 'tcx> fmt::Debug for DeconstructedPat<'p, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Printing lists is a chore.\n+        let mut first = true;\n+        let mut start_or_continue = |s| {\n+            if first {\n+                first = false;\n+                \"\"\n+            } else {\n+                s\n             }\n-            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n-                self.replace_with_fieldpats(subpatterns)\n+        };\n+        let mut start_or_comma = || start_or_continue(\", \");\n+\n+        match &self.ctor {\n+            Single | Variant(_) => match self.ty.kind() {\n+                ty::Adt(def, _) if def.is_box() => {\n+                    // Without `box_patterns`, the only legal pattern of type `Box` is `_` (outside\n+                    // of `std`). So this branch is only reachable when the feature is enabled and\n+                    // the pattern is a box pattern.\n+                    let subpattern = self.iter_fields().next().unwrap();\n+                    write!(f, \"box {:?}\", subpattern)\n+                }\n+                ty::Adt(..) | ty::Tuple(..) => {\n+                    let variant = match self.ty.kind() {\n+                        ty::Adt(adt, _) => {\n+                            Some(&adt.variants[self.ctor.variant_index_for_adt(adt)])\n+                        }\n+                        ty::Tuple(_) => None,\n+                        _ => unreachable!(),\n+                    };\n+\n+                    if let Some(variant) = variant {\n+                        write!(f, \"{}\", variant.ident)?;\n+                    }\n+\n+                    // Without `cx`, we can't know which field corresponds to which, so we can't\n+                    // get the names of the fields. Instead we just display everything as a suple\n+                    // struct, which should be good enough.\n+                    write!(f, \"(\")?;\n+                    for p in self.iter_fields() {\n+                        write!(f, \"{}\", start_or_comma())?;\n+                        write!(f, \"{:?}\", p)?;\n+                    }\n+                    write!(f, \")\")\n+                }\n+                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n+                // be careful to detect strings here. However a string literal pattern will never\n+                // be reported as a non-exhaustiveness witness, so we can ignore this issue.\n+                ty::Ref(_, _, mutbl) => {\n+                    let subpattern = self.iter_fields().next().unwrap();\n+                    write!(f, \"&{}{:?}\", mutbl.prefix_str(), subpattern)\n+                }\n+                _ => write!(f, \"_\"),\n+            },\n+            Slice(slice) => {\n+                let mut subpatterns = self.fields.iter_patterns();\n+                write!(f, \"[\")?;\n+                match slice.kind {\n+                    FixedLen(_) => {\n+                        for p in subpatterns {\n+                            write!(f, \"{}{:?}\", start_or_comma(), p)?;\n+                        }\n+                    }\n+                    VarLen(prefix_len, _) => {\n+                        for p in subpatterns.by_ref().take(prefix_len) {\n+                            write!(f, \"{}{:?}\", start_or_comma(), p)?;\n+                        }\n+                        write!(f, \"{}\", start_or_comma())?;\n+                        write!(f, \"..\")?;\n+                        for p in subpatterns {\n+                            write!(f, \"{}{:?}\", start_or_comma(), p)?;\n+                        }\n+                    }\n+                }\n+                write!(f, \"]\")\n+            }\n+            &FloatRange(lo, hi, end) => {\n+                write!(f, \"{}\", lo)?;\n+                write!(f, \"{}\", end)?;\n+                write!(f, \"{}\", hi)\n             }\n-            PatKind::Array { prefix, suffix, .. } | PatKind::Slice { prefix, suffix, .. } => {\n-                // Number of subpatterns for the constructor\n-                let ctor_arity = self.len();\n-\n-                // Replace the prefix and the suffix with the given patterns, leaving wildcards in\n-                // the middle if there was a subslice pattern `..`.\n-                let prefix = prefix.iter().enumerate();\n-                let suffix =\n-                    suffix.iter().enumerate().map(|(i, p)| (ctor_arity - suffix.len() + i, p));\n-                self.replace_fields_indexed(prefix.chain(suffix))\n+            IntRange(range) => write!(f, \"{:?}\", range), // Best-effort, will render e.g. `false` as `0..=0`\n+            Wildcard | Missing { .. } | NonExhaustive => write!(f, \"_\"),\n+            Or => {\n+                for pat in self.iter_fields() {\n+                    write!(f, \"{}{:?}\", start_or_continue(\" | \"), pat)?;\n+                }\n+                Ok(())\n             }\n-            _ => self.clone(),\n+            Str(value) => write!(f, \"{}\", value),\n+            Opaque => write!(f, \"<constant pattern>\"),\n         }\n     }\n }"}, {"sha": "650a87b2d885976e8a9b04a0e9492e58c52e0069", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 107, "deletions": 492, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -284,27 +284,22 @@ use self::ArmType::*;\n use self::Usefulness::*;\n \n use super::check_match::{joined_uncovered_patterns, pattern_not_covered_label};\n-use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n-use super::{PatternFoldable, PatternFolder};\n+use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashMap;\n \n-use hir::def_id::DefId;\n-use hir::HirId;\n use rustc_arena::TypedArena;\n-use rustc_hir as hir;\n-use rustc_middle::thir::{Pat, PatKind};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};\n use std::fmt;\n-use std::iter::{FromIterator, IntoIterator};\n-use std::lazy::OnceCell;\n+use std::iter::once;\n \n-crate struct MatchCheckCtxt<'a, 'tcx> {\n+crate struct MatchCheckCtxt<'p, 'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n@@ -313,7 +308,7 @@ crate struct MatchCheckCtxt<'a, 'tcx> {\n     /// outside its module and should not be matchable with an empty match statement.\n     crate module: DefId,\n     crate param_env: ty::ParamEnv<'tcx>,\n-    crate pattern_arena: &'a TypedArena<Pat<'tcx>>,\n+    crate pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -356,78 +351,20 @@ impl<'a, 'p, 'tcx> fmt::Debug for PatCtxt<'a, 'p, 'tcx> {\n     }\n }\n \n-crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n-    LiteralExpander.fold_pattern(&pat)\n-}\n-\n-struct LiteralExpander;\n-\n-impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n-    fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n-        debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n-        match (pat.ty.kind(), pat.kind.as_ref()) {\n-            (_, PatKind::Binding { subpattern: Some(s), .. }) => s.fold_with(self),\n-            (_, PatKind::AscribeUserType { subpattern: s, .. }) => s.fold_with(self),\n-            (ty::Ref(_, t, _), PatKind::Constant { .. }) if t.is_str() => {\n-                // Treat string literal patterns as deref patterns to a `str` constant, i.e.\n-                // `&CONST`. This expands them like other const patterns. This could have been done\n-                // in `const_to_pat`, but that causes issues with the rest of the matching code.\n-                let mut new_pat = pat.super_fold_with(self);\n-                // Make a fake const pattern of type `str` (instead of `&str`). That the carried\n-                // constant value still knows it is of type `&str`.\n-                new_pat.ty = t;\n-                Pat {\n-                    kind: Box::new(PatKind::Deref { subpattern: new_pat }),\n-                    span: pat.span,\n-                    ty: pat.ty,\n-                }\n-            }\n-            _ => pat.super_fold_with(self),\n-        }\n-    }\n-}\n-\n-pub(super) fn is_wildcard(pat: &Pat<'_>) -> bool {\n-    matches!(*pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n-}\n-\n-fn is_or_pat(pat: &Pat<'_>) -> bool {\n-    matches!(*pat.kind, PatKind::Or { .. })\n-}\n-\n-/// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n-fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n-    fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n-        if let PatKind::Or { pats } = pat.kind.as_ref() {\n-            for pat in pats {\n-                expand(pat, vec);\n-            }\n-        } else {\n-            vec.push(pat)\n-        }\n-    }\n-\n-    let mut pats = Vec::new();\n-    expand(pat, &mut pats);\n-    pats\n-}\n-\n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n #[derive(Clone)]\n struct PatStack<'p, 'tcx> {\n-    pats: SmallVec<[&'p Pat<'tcx>; 2]>,\n-    /// Cache for the constructor of the head\n-    head_ctor: OnceCell<Constructor<'tcx>>,\n+    pats: SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]>,\n }\n \n impl<'p, 'tcx> PatStack<'p, 'tcx> {\n-    fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n+    fn from_pattern(pat: &'p DeconstructedPat<'p, 'tcx>) -> Self {\n         Self::from_vec(smallvec![pat])\n     }\n \n-    fn from_vec(vec: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n-        PatStack { pats: vec, head_ctor: OnceCell::new() }\n+    fn from_vec(vec: SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]>) -> Self {\n+        PatStack { pats: vec }\n     }\n \n     fn is_empty(&self) -> bool {\n@@ -438,79 +375,56 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         self.pats.len()\n     }\n \n-    fn head(&self) -> &'p Pat<'tcx> {\n+    fn head(&self) -> &'p DeconstructedPat<'p, 'tcx> {\n         self.pats[0]\n     }\n \n-    #[inline]\n-    fn head_ctor<'a>(&'a self, cx: &MatchCheckCtxt<'p, 'tcx>) -> &'a Constructor<'tcx> {\n-        self.head_ctor.get_or_init(|| Constructor::from_pat(cx, self.head()))\n-    }\n-\n-    fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n+    fn iter(&self) -> impl Iterator<Item = &DeconstructedPat<'p, 'tcx>> {\n         self.pats.iter().copied()\n     }\n \n     // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n     // or-pattern. Panics if `self` is empty.\n     fn expand_or_pat<'a>(&'a self) -> impl Iterator<Item = PatStack<'p, 'tcx>> + Captures<'a> {\n-        expand_or_pat(self.head()).into_iter().map(move |pat| {\n+        self.head().iter_fields().map(move |pat| {\n             let mut new_patstack = PatStack::from_pattern(pat);\n             new_patstack.pats.extend_from_slice(&self.pats[1..]);\n             new_patstack\n         })\n     }\n \n-    /// This computes `S(self.head_ctor(), self)`. See top of the file for explanations.\n+    /// This computes `S(self.head().ctor(), self)`. See top of the file for explanations.\n     ///\n     /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n     /// fields filled with wild patterns.\n     ///\n     /// This is roughly the inverse of `Constructor::apply`.\n-    fn pop_head_constructor(&self, ctor_wild_subpatterns: &Fields<'p, 'tcx>) -> PatStack<'p, 'tcx> {\n+    fn pop_head_constructor(\n+        &self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        ctor: &Constructor<'tcx>,\n+    ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields =\n-            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head()).into_patterns();\n+        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(cx, ctor);\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n }\n \n-impl<'p, 'tcx> Default for PatStack<'p, 'tcx> {\n-    fn default() -> Self {\n-        Self::from_vec(smallvec![])\n-    }\n-}\n-\n-impl<'p, 'tcx> PartialEq for PatStack<'p, 'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.pats == other.pats\n-    }\n-}\n-\n-impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n-    fn from_iter<T>(iter: T) -> Self\n-    where\n-        T: IntoIterator<Item = &'p Pat<'tcx>>,\n-    {\n-        Self::from_vec(iter.into_iter().collect())\n-    }\n-}\n-\n /// Pretty-printing for matrix row.\n impl<'p, 'tcx> fmt::Debug for PatStack<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"+\")?;\n         for pat in self.iter() {\n-            write!(f, \" {} +\", pat)?;\n+            write!(f, \" {:?} +\", pat)?;\n         }\n         Ok(())\n     }\n }\n \n /// A 2D matrix.\n-#[derive(Clone, PartialEq)]\n+#[derive(Clone)]\n pub(super) struct Matrix<'p, 'tcx> {\n     patterns: Vec<PatStack<'p, 'tcx>>,\n }\n@@ -528,7 +442,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this recursively\n     /// expands it.\n     fn push(&mut self, row: PatStack<'p, 'tcx>) {\n-        if !row.is_empty() && is_or_pat(row.head()) {\n+        if !row.is_empty() && row.head().is_or_pat() {\n             for row in row.expand_or_pat() {\n                 self.patterns.push(row);\n             }\n@@ -538,38 +452,26 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     }\n \n     /// Iterate over the first component of each row\n-    fn heads<'a>(&'a self) -> impl Iterator<Item = &'a Pat<'tcx>> + Captures<'p> {\n-        self.patterns.iter().map(|r| r.head())\n-    }\n-\n-    /// Iterate over the first constructor of each row.\n-    pub(super) fn head_ctors<'a>(\n+    fn heads<'a>(\n         &'a self,\n-        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    ) -> impl Iterator<Item = &'a Constructor<'tcx>> + Captures<'p> + Clone {\n-        self.patterns.iter().map(move |r| r.head_ctor(cx))\n-    }\n-\n-    /// Iterate over the first constructor and the corresponding span of each row.\n-    pub(super) fn head_ctors_and_spans<'a>(\n-        &'a self,\n-        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n-    ) -> impl Iterator<Item = (&'a Constructor<'tcx>, Span)> + Captures<'p> {\n-        self.patterns.iter().map(move |r| (r.head_ctor(cx), r.head().span))\n+    ) -> impl Iterator<Item = &'p DeconstructedPat<'p, 'tcx>> + Clone + Captures<'a> {\n+        self.patterns.iter().map(|r| r.head())\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n-        self.patterns\n-            .iter()\n-            .filter(|r| ctor.is_covered_by(pcx, r.head_ctor(pcx.cx)))\n-            .map(|r| r.pop_head_constructor(ctor_wild_subpatterns))\n-            .collect()\n+        let mut matrix = Matrix::empty();\n+        for row in &self.patterns {\n+            if ctor.is_covered_by(pcx, row.head().ctor()) {\n+                let new_row = row.pop_head_constructor(pcx.cx, ctor);\n+                matrix.push(new_row);\n+            }\n+        }\n+        matrix\n     }\n }\n \n@@ -588,7 +490,7 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n \n         let Matrix { patterns: m, .. } = self;\n         let pretty_printed_matrix: Vec<Vec<String>> =\n-            m.iter().map(|row| row.iter().map(|pat| format!(\"{}\", pat)).collect()).collect();\n+            m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n \n         let column_count = m.iter().map(|row| row.len()).next().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n@@ -609,296 +511,40 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     }\n }\n \n-impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n-    fn from_iter<T>(iter: T) -> Self\n-    where\n-        T: IntoIterator<Item = PatStack<'p, 'tcx>>,\n-    {\n-        let mut matrix = Matrix::empty();\n-        for x in iter {\n-            // Using `push` ensures we correctly expand or-patterns.\n-            matrix.push(x);\n-        }\n-        matrix\n-    }\n-}\n-\n-/// Given a pattern or a pattern-stack, this struct captures a set of its subpatterns. We use that\n-/// to track reachable sub-patterns arising from or-patterns. In the absence of or-patterns this\n-/// will always be either `Empty` (the whole pattern is unreachable) or `Full` (the whole pattern\n-/// is reachable). When there are or-patterns, some subpatterns may be reachable while others\n-/// aren't. In this case the whole pattern still counts as reachable, but we will lint the\n-/// unreachable subpatterns.\n-///\n-/// This supports a limited set of operations, so not all possible sets of subpatterns can be\n-/// represented. That's ok, we only want the ones that make sense for our usage.\n-///\n-/// What we're doing is illustrated by this:\n-/// ```\n-/// match (true, 0) {\n-///     (true, 0) => {}\n-///     (_, 1) => {}\n-///     (true | false, 0 | 1) => {}\n-/// }\n-/// ```\n-/// When we try the alternatives of the `true | false` or-pattern, the last `0` is reachable in the\n-/// `false` alternative but not the `true`. So overall it is reachable. By contrast, the last `1`\n-/// is not reachable in either alternative, so we want to signal this to the user.\n-/// Therefore we take the union of sets of reachable patterns coming from different alternatives in\n-/// order to figure out which subpatterns are overall reachable.\n-///\n-/// Invariant: we try to construct the smallest representation we can. In particular if\n-/// `self.is_empty()` we ensure that `self` is `Empty`, and same with `Full`. This is not important\n-/// for correctness currently.\n-#[derive(Debug, Clone)]\n-enum SubPatSet<'p, 'tcx> {\n-    /// The empty set. This means the pattern is unreachable.\n-    Empty,\n-    /// The set containing the full pattern.\n-    Full,\n-    /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n-    /// of its subpatterns. Missing entries in the map are implicitly full, because that's the\n-    /// common case.\n-    Seq { subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>> },\n-    /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n-    /// entries in the map are implicitly empty. Note: we always flatten nested or-patterns.\n-    Alt {\n-        subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>>,\n-        /// Counts the total number of alternatives in the pattern\n-        alt_count: usize,\n-        /// We keep the pattern around to retrieve spans.\n-        pat: &'p Pat<'tcx>,\n-    },\n-}\n-\n-impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n-    fn full() -> Self {\n-        SubPatSet::Full\n-    }\n-    fn empty() -> Self {\n-        SubPatSet::Empty\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        match self {\n-            SubPatSet::Empty => true,\n-            SubPatSet::Full => false,\n-            // If any subpattern in a sequence is unreachable, the whole pattern is unreachable.\n-            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_empty()),\n-            // An or-pattern is reachable if any of its alternatives is.\n-            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_empty()),\n-        }\n-    }\n-\n-    fn is_full(&self) -> bool {\n-        match self {\n-            SubPatSet::Empty => false,\n-            SubPatSet::Full => true,\n-            // The whole pattern is reachable only when all its alternatives are.\n-            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_full()),\n-            // The whole or-pattern is reachable only when all its alternatives are.\n-            SubPatSet::Alt { subpats, alt_count, .. } => {\n-                subpats.len() == *alt_count && subpats.values().all(|set| set.is_full())\n-            }\n-        }\n-    }\n-\n-    /// Union `self` with `other`, mutating `self`.\n-    fn union(&mut self, other: Self) {\n-        use SubPatSet::*;\n-        // Union with full stays full; union with empty changes nothing.\n-        if self.is_full() || other.is_empty() {\n-            return;\n-        } else if self.is_empty() {\n-            *self = other;\n-            return;\n-        } else if other.is_full() {\n-            *self = Full;\n-            return;\n-        }\n-\n-        match (&mut *self, other) {\n-            (Seq { subpats: s_set }, Seq { subpats: mut o_set }) => {\n-                s_set.retain(|i, s_sub_set| {\n-                    // Missing entries count as full.\n-                    let o_sub_set = o_set.remove(&i).unwrap_or(Full);\n-                    s_sub_set.union(o_sub_set);\n-                    // We drop full entries.\n-                    !s_sub_set.is_full()\n-                });\n-                // Everything left in `o_set` is missing from `s_set`, i.e. counts as full. Since\n-                // unioning with full returns full, we can drop those entries.\n-            }\n-            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n-                s_set.retain(|i, s_sub_set| {\n-                    // Missing entries count as empty.\n-                    let o_sub_set = o_set.remove(&i).unwrap_or(Empty);\n-                    s_sub_set.union(o_sub_set);\n-                    // We drop empty entries.\n-                    !s_sub_set.is_empty()\n-                });\n-                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n-                // unioning with empty changes nothing, we can take those entries as is.\n-                s_set.extend(o_set);\n-            }\n-            _ => bug!(),\n-        }\n-\n-        if self.is_full() {\n-            *self = Full;\n-        }\n-    }\n-\n-    /// Returns a list of the spans of the unreachable subpatterns. If `self` is empty (i.e. the\n-    /// whole pattern is unreachable) we return `None`.\n-    fn list_unreachable_spans(&self) -> Option<Vec<Span>> {\n-        /// Panics if `set.is_empty()`.\n-        fn fill_spans(set: &SubPatSet<'_, '_>, spans: &mut Vec<Span>) {\n-            match set {\n-                SubPatSet::Empty => bug!(),\n-                SubPatSet::Full => {}\n-                SubPatSet::Seq { subpats } => {\n-                    for (_, sub_set) in subpats {\n-                        fill_spans(sub_set, spans);\n-                    }\n-                }\n-                SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n-                    let expanded = expand_or_pat(pat);\n-                    for i in 0..*alt_count {\n-                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n-                        if sub_set.is_empty() {\n-                            // Found an unreachable subpattern.\n-                            spans.push(expanded[i].span);\n-                        } else {\n-                            fill_spans(sub_set, spans);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        if self.is_empty() {\n-            return None;\n-        }\n-        if self.is_full() {\n-            // No subpatterns are unreachable.\n-            return Some(Vec::new());\n-        }\n-        let mut spans = Vec::new();\n-        fill_spans(self, &mut spans);\n-        Some(spans)\n-    }\n-\n-    /// When `self` refers to a patstack that was obtained from specialization, after running\n-    /// `unspecialize` it will refer to the original patstack before specialization.\n-    fn unspecialize(self, arity: usize) -> Self {\n-        use SubPatSet::*;\n-        match self {\n-            Full => Full,\n-            Empty => Empty,\n-            Seq { subpats } => {\n-                // We gather the first `arity` subpatterns together and shift the remaining ones.\n-                let mut new_subpats = FxHashMap::default();\n-                let mut new_subpats_first_col = FxHashMap::default();\n-                for (i, sub_set) in subpats {\n-                    if i < arity {\n-                        // The first `arity` indices are now part of the pattern in the first\n-                        // column.\n-                        new_subpats_first_col.insert(i, sub_set);\n-                    } else {\n-                        // Indices after `arity` are simply shifted\n-                        new_subpats.insert(i - arity + 1, sub_set);\n-                    }\n-                }\n-                // If `new_subpats_first_col` has no entries it counts as full, so we can omit it.\n-                if !new_subpats_first_col.is_empty() {\n-                    new_subpats.insert(0, Seq { subpats: new_subpats_first_col });\n-                }\n-                Seq { subpats: new_subpats }\n-            }\n-            Alt { .. } => bug!(), // `self` is a patstack\n-        }\n-    }\n-\n-    /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n-    /// running `unspecialize` it will refer to the original patstack before splitting.\n-    ///\n-    /// For example:\n-    /// ```\n-    /// match Some(true) {\n-    ///     Some(true) => {}\n-    ///     None | Some(true | false) => {}\n-    /// }\n-    /// ```\n-    /// Here `None` would return the full set and `Some(true | false)` would return the set\n-    /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n-    /// This is what this function does.\n-    fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n-        use SubPatSet::*;\n-        if self.is_empty() {\n-            return Empty;\n-        }\n-\n-        // Subpatterns coming from inside the or-pattern alternative itself, e.g. in `None | Some(0\n-        // | 1)`.\n-        let set_first_col = match &mut self {\n-            Full => Full,\n-            Seq { subpats } => subpats.remove(&0).unwrap_or(Full),\n-            Empty => unreachable!(),\n-            Alt { .. } => bug!(), // `self` is a patstack\n-        };\n-        let mut subpats_first_col = FxHashMap::default();\n-        subpats_first_col.insert(alt_id, set_first_col);\n-        let set_first_col = Alt { subpats: subpats_first_col, pat, alt_count };\n-\n-        let mut subpats = match self {\n-            Full => FxHashMap::default(),\n-            Seq { subpats } => subpats,\n-            Empty => unreachable!(),\n-            Alt { .. } => bug!(), // `self` is a patstack\n-        };\n-        subpats.insert(0, set_first_col);\n-        Seq { subpats }\n-    }\n-}\n-\n /// This carries the results of computing usefulness, as described at the top of the file. When\n /// checking usefulness of a match branch, we use the `NoWitnesses` variant, which also keeps track\n /// of potential unreachable sub-patterns (in the presence of or-patterns). When checking\n /// exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of\n /// witnesses of non-exhaustiveness when there are any.\n /// Which variant to use is dictated by `ArmType`.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n enum Usefulness<'p, 'tcx> {\n-    /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n-    /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n-    /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n-    /// or-patterns this will always be either `Empty` (the whole pattern is unreachable) or `Full`\n-    /// (the whole pattern is reachable).\n-    NoWitnesses(SubPatSet<'p, 'tcx>),\n+    /// If we don't care about witnesses, simply remember if the pattern was useful.\n+    NoWitnesses { useful: bool },\n     /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n     /// pattern is unreachable.\n-    WithWitnesses(Vec<Witness<'tcx>>),\n+    WithWitnesses(Vec<Witness<'p, 'tcx>>),\n }\n \n impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n     fn new_useful(preference: ArmType) -> Self {\n         match preference {\n+            // A single (empty) witness of reachability.\n             FakeExtraWildcard => WithWitnesses(vec![Witness(vec![])]),\n-            RealArm => NoWitnesses(SubPatSet::full()),\n+            RealArm => NoWitnesses { useful: true },\n         }\n     }\n \n     fn new_not_useful(preference: ArmType) -> Self {\n         match preference {\n             FakeExtraWildcard => WithWitnesses(vec![]),\n-            RealArm => NoWitnesses(SubPatSet::empty()),\n+            RealArm => NoWitnesses { useful: false },\n         }\n     }\n \n     fn is_useful(&self) -> bool {\n         match self {\n-            Usefulness::NoWitnesses(set) => !set.is_empty(),\n+            Usefulness::NoWitnesses { useful } => *useful,\n             Usefulness::WithWitnesses(witnesses) => !witnesses.is_empty(),\n         }\n     }\n@@ -909,33 +555,10 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n             (WithWitnesses(_), WithWitnesses(o)) if o.is_empty() => {}\n             (WithWitnesses(s), WithWitnesses(o)) if s.is_empty() => *self = WithWitnesses(o),\n             (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n-            (NoWitnesses(s), NoWitnesses(o)) => s.union(o),\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    /// When trying several branches and each returns a `Usefulness`, we need to combine the\n-    /// results together.\n-    fn merge(pref: ArmType, usefulnesses: impl Iterator<Item = Self>) -> Self {\n-        let mut ret = Self::new_not_useful(pref);\n-        for u in usefulnesses {\n-            ret.extend(u);\n-            if let NoWitnesses(subpats) = &ret {\n-                if subpats.is_full() {\n-                    // Once we reach the full set, more unions won't change the result.\n-                    return ret;\n-                }\n+            (NoWitnesses { useful: s_useful }, NoWitnesses { useful: o_useful }) => {\n+                *s_useful = *s_useful || o_useful\n             }\n-        }\n-        ret\n-    }\n-\n-    /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n-    /// usefulness mergeable with those from the other branches.\n-    fn unsplit_or_pat(self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n-        match self {\n-            NoWitnesses(subpats) => NoWitnesses(subpats.unsplit_or_pat(alt_id, alt_count, pat)),\n-            WithWitnesses(_) => bug!(),\n+            _ => unreachable!(),\n         }\n     }\n \n@@ -947,55 +570,55 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n         ctor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n-            WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n+            NoWitnesses { .. } => self,\n+            WithWitnesses(ref witnesses) if witnesses.is_empty() => self,\n             WithWitnesses(witnesses) => {\n                 let new_witnesses = if let Constructor::Missing { .. } = ctor {\n                     // We got the special `Missing` constructor, so each of the missing constructors\n                     // gives a new pattern that is not caught by the match. We list those patterns.\n                     let new_patterns = if pcx.is_non_exhaustive {\n                         // Here we don't want the user to try to list all variants, we want them to add\n                         // a wildcard, so we only suggest that.\n-                        vec![\n-                            Fields::wildcards(pcx, &Constructor::NonExhaustive)\n-                                .apply(pcx, &Constructor::NonExhaustive),\n-                        ]\n+                        vec![DeconstructedPat::wildcard(pcx.ty)]\n                     } else {\n                         let mut split_wildcard = SplitWildcard::new(pcx);\n-                        split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                        split_wildcard.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n                         // Construct for each missing constructor a \"wild\" version of this\n                         // constructor, that matches everything that can be built with\n                         // it. For example, if `ctor` is a `Constructor::Variant` for\n                         // `Option::Some`, we get the pattern `Some(_)`.\n                         split_wildcard\n                             .iter_missing(pcx)\n-                            .map(|missing_ctor| {\n-                                Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n-                            })\n+                            .cloned()\n+                            .map(|missing_ctor| DeconstructedPat::wild_from_ctor(pcx, missing_ctor))\n                             .collect()\n                     };\n \n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {\n                             new_patterns.iter().map(move |pat| {\n-                                let mut witness = witness.clone();\n-                                witness.0.push(pat.clone());\n-                                witness\n+                                Witness(\n+                                    witness\n+                                        .0\n+                                        .iter()\n+                                        .chain(once(pat))\n+                                        .map(DeconstructedPat::clone_and_forget_reachability)\n+                                        .collect(),\n+                                )\n                             })\n                         })\n                         .collect()\n                 } else {\n                     witnesses\n                         .into_iter()\n-                        .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n+                        .map(|witness| witness.apply_constructor(pcx, &ctor))\n                         .collect()\n                 };\n                 WithWitnesses(new_witnesses)\n             }\n-            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor_wild_subpatterns.len())),\n         }\n     }\n }\n@@ -1039,12 +662,12 @@ enum ArmType {\n ///     `Witness(vec![Pair(Some(_), true)])`\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n-#[derive(Clone, Debug)]\n-crate struct Witness<'tcx>(Vec<Pat<'tcx>>);\n+#[derive(Debug)]\n+crate struct Witness<'p, 'tcx>(Vec<DeconstructedPat<'p, 'tcx>>);\n \n-impl<'tcx> Witness<'tcx> {\n+impl<'p, 'tcx> Witness<'p, 'tcx> {\n     /// Asserts that the witness contains a single pattern, and returns it.\n-    fn single_pattern(self) -> Pat<'tcx> {\n+    fn single_pattern(self) -> DeconstructedPat<'p, 'tcx> {\n         assert_eq!(self.0.len(), 1);\n         self.0.into_iter().next().unwrap()\n     }\n@@ -1062,17 +685,13 @@ impl<'tcx> Witness<'tcx> {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor<'p>(\n-        mut self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        ctor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-    ) -> Self {\n+    fn apply_constructor(mut self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Self {\n         let pat = {\n             let len = self.0.len();\n-            let arity = ctor_wild_subpatterns.len();\n+            let arity = ctor.arity(pcx);\n             let pats = self.0.drain((len - arity)..).rev();\n-            ctor_wild_subpatterns.replace_fields(pcx.cx, pats).apply(pcx, ctor)\n+            let fields = Fields::from_iter(pcx.cx, pats);\n+            DeconstructedPat::new(ctor.clone(), fields, pcx.ty, DUMMY_SP)\n         };\n \n         self.0.push(pat);\n@@ -1090,9 +709,9 @@ fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n     hir_id: HirId,\n-    witnesses: Vec<Pat<'tcx>>,\n+    witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n ) {\n-    let joined_patterns = joined_uncovered_patterns(&witnesses);\n+    let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n     cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, |build| {\n         let mut lint = build.build(\"some variants are not matched explicitly\");\n         lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n@@ -1163,56 +782,52 @@ fn is_useful<'p, 'tcx>(\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n-    let ty = matrix.heads().next().map_or(v.head().ty, |r| r.ty);\n+    let ty = matrix.heads().next().map_or(v.head().ty(), |r| r.ty());\n     let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n-    let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level, is_non_exhaustive };\n+    let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n \n     // If the first pattern is an or-pattern, expand it.\n-    let ret = if is_or_pat(v.head()) {\n+    let mut ret = Usefulness::new_not_useful(witness_preference);\n+    if v.head().is_or_pat() {\n         debug!(\"expanding or-pattern\");\n-        let v_head = v.head();\n-        let vs: Vec<_> = v.expand_or_pat().collect();\n-        let alt_count = vs.len();\n         // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n-        let usefulnesses = vs.into_iter().enumerate().map(|(i, v)| {\n+        for v in v.expand_or_pat() {\n             let usefulness =\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+            ret.extend(usefulness);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n                 // We push the already-seen patterns into the matrix in order to detect redundant\n                 // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n-            usefulness.unsplit_or_pat(i, alt_count, v_head)\n-        });\n-        Usefulness::merge(witness_preference, usefulnesses)\n+        }\n     } else {\n-        let v_ctor = v.head_ctor(cx);\n+        let v_ctor = v.head().ctor();\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n             // Lint on likely incorrect range patterns (#63987)\n             ctor_range.lint_overlapping_range_endpoints(\n                 pcx,\n-                matrix.head_ctors_and_spans(cx),\n+                matrix.heads(),\n                 matrix.column_count().unwrap_or(0),\n                 hir_id,\n             )\n         }\n         // We split the head constructor of `v`.\n-        let split_ctors = v_ctor.split(pcx, matrix.head_ctors(cx));\n+        let split_ctors = v_ctor.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n         let is_non_exhaustive_and_wild = is_non_exhaustive && v_ctor.is_wildcard();\n         // For each constructor, we compute whether there's a value that starts with it that would\n         // witness the usefulness of `v`.\n         let start_matrix = &matrix;\n-        let usefulnesses = split_ctors.into_iter().map(|ctor| {\n+        for ctor in split_ctors {\n             debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n-            let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n-            let spec_matrix =\n-                start_matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n-            let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n+            let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n+            let v = v.pop_head_constructor(cx, &ctor);\n             let usefulness =\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+            let usefulness = usefulness.apply_constructor(pcx, start_matrix, &ctor);\n \n             // When all the conditions are met we have a match with a `non_exhaustive` enum\n             // that has the potential to trigger the `non_exhaustive_omitted_patterns` lint.\n@@ -1229,29 +844,31 @@ fn is_useful<'p, 'tcx>(\n             {\n                 let patterns = {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n-                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                    split_wildcard.split(pcx, matrix.heads().map(DeconstructedPat::ctor));\n                     // Construct for each missing constructor a \"wild\" version of this\n                     // constructor, that matches everything that can be built with\n                     // it. For example, if `ctor` is a `Constructor::Variant` for\n                     // `Option::Some`, we get the pattern `Some(_)`.\n                     split_wildcard\n                         .iter_missing(pcx)\n-                        // Filter out the `Constructor::NonExhaustive` variant it's meaningless\n-                        // to our lint\n+                        // Filter out the `NonExhaustive` because we want to list only real\n+                        // variants.\n                         .filter(|c| !c.is_non_exhaustive())\n-                        .map(|missing_ctor| {\n-                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n-                        })\n+                        .cloned()\n+                        .map(|missing_ctor| DeconstructedPat::wild_from_ctor(pcx, missing_ctor))\n                         .collect::<Vec<_>>()\n                 };\n \n                 lint_non_exhaustive_omitted_patterns(pcx.cx, pcx.ty, pcx.span, hir_id, patterns);\n             }\n \n-            usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n-        });\n-        Usefulness::merge(witness_preference, usefulnesses)\n-    };\n+            ret.extend(usefulness);\n+        }\n+    }\n+\n+    if ret.is_useful() {\n+        v.head().set_reachable();\n+    }\n \n     debug!(?ret);\n     ret\n@@ -1261,7 +878,7 @@ fn is_useful<'p, 'tcx>(\n #[derive(Clone, Copy)]\n crate struct MatchArm<'p, 'tcx> {\n     /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n-    crate pat: &'p Pat<'tcx>,\n+    crate pat: &'p DeconstructedPat<'p, 'tcx>,\n     crate hir_id: HirId,\n     crate has_guard: bool,\n }\n@@ -1283,7 +900,7 @@ crate struct UsefulnessReport<'p, 'tcx> {\n     crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n-    crate non_exhaustiveness_witnesses: Vec<Pat<'tcx>>,\n+    crate non_exhaustiveness_witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n }\n \n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n@@ -1303,27 +920,25 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n         .copied()\n         .map(|arm| {\n             let v = PatStack::from_pattern(arm.pat);\n-            let usefulness = is_useful(cx, &matrix, &v, RealArm, arm.hir_id, arm.has_guard, true);\n+            is_useful(cx, &matrix, &v, RealArm, arm.hir_id, arm.has_guard, true);\n             if !arm.has_guard {\n                 matrix.push(v);\n             }\n-            let reachability = match usefulness {\n-                NoWitnesses(subpats) if subpats.is_empty() => Reachability::Unreachable,\n-                NoWitnesses(subpats) => {\n-                    Reachability::Reachable(subpats.list_unreachable_spans().unwrap())\n-                }\n-                WithWitnesses(..) => bug!(),\n+            let reachability = if arm.pat.is_reachable() {\n+                Reachability::Reachable(arm.pat.unreachable_spans())\n+            } else {\n+                Reachability::Unreachable\n             };\n             (arm, reachability)\n         })\n         .collect();\n \n-    let wild_pattern = cx.pattern_arena.alloc(Pat::wildcard_from_ty(scrut_ty));\n+    let wild_pattern = cx.pattern_arena.alloc(DeconstructedPat::wildcard(scrut_ty));\n     let v = PatStack::from_pattern(wild_pattern);\n     let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n         WithWitnesses(pats) => pats.into_iter().map(|w| w.single_pattern()).collect(),\n-        NoWitnesses(_) => bug!(),\n+        NoWitnesses { .. } => bug!(),\n     };\n     UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n }"}, {"sha": "35619594f75b86546248042bb6fb9004240e7c3c", "filename": "src/test/ui/consts/const_in_pattern/issue-78057.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-78057.stderr?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -7,8 +7,11 @@ LL |         FOO => {},\n error: unreachable pattern\n   --> $DIR/issue-78057.rs:14:9\n    |\n+LL |         FOO => {},\n+   |         --- matches any value\n+LL |\n LL |         _ => {}\n-   |         ^\n+   |         ^ unreachable pattern\n    |\n note: the lint level is defined here\n   --> $DIR/issue-78057.rs:1:9"}, {"sha": "06c832ca46a6bb0a685e1ace3804424c71698a09", "filename": "src/test/ui/pattern/usefulness/const-private-fields.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconst-private-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconst-private-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconst-private-fields.rs?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+//\n+// Check that we don't ignore private fields in usefulness checking\n+#![deny(unreachable_patterns)]\n+\n+mod inner {\n+    #[derive(PartialEq, Eq)]\n+    pub struct PrivateField {\n+        pub x: bool,\n+        y: bool,\n+    }\n+\n+    pub const FOO: PrivateField = PrivateField { x: true, y: true };\n+    pub const BAR: PrivateField = PrivateField { x: true, y: false };\n+}\n+use inner::*;\n+\n+fn main() {\n+    match FOO {\n+        FOO => {}\n+        BAR => {}\n+        _ => {}\n+    }\n+\n+    match FOO {\n+        FOO => {}\n+        PrivateField { x: true, .. } => {}\n+        _ => {}\n+    }\n+}"}, {"sha": "05c009a6f3fe147b15eca27fbedade1cb8b4889d", "filename": "src/test/ui/pattern/usefulness/consts-opaque.stderr", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fconsts-opaque.stderr?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -7,8 +7,11 @@ LL |         FOO => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:32:9\n    |\n+LL |         FOO => {}\n+   |         --- matches any value\n+LL |\n LL |         _ => {} // should not be emitting unreachable warning\n-   |         ^\n+   |         ^ unreachable pattern\n    |\n note: the lint level is defined here\n   --> $DIR/consts-opaque.rs:6:9\n@@ -25,8 +28,11 @@ LL |         FOO_REF => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:39:9\n    |\n+LL |         FOO_REF => {}\n+   |         ------- matches any value\n+LL |\n LL |         Foo(_) => {} // should not be emitting unreachable warning\n-   |         ^^^^^^\n+   |         ^^^^^^ unreachable pattern\n \n warning: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:45:9\n@@ -70,15 +76,18 @@ LL |         BAR => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:63:9\n    |\n+LL |         BAR => {}\n+   |         --- matches any value\n+LL |\n LL |         Bar => {} // should not be emitting unreachable warning\n-   |         ^^^\n+   |         ^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:65:9\n    |\n-LL |         Bar => {} // should not be emitting unreachable warning\n+LL |         BAR => {}\n    |         --- matches any value\n-LL |\n+...\n LL |         _ => {}\n    |         ^ unreachable pattern\n \n@@ -97,14 +106,20 @@ LL |         BAR => {} // should not be emitting unreachable warning\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:72:9\n    |\n+LL |         BAR => {}\n+   |         --- matches any value\n+LL |\n LL |         BAR => {} // should not be emitting unreachable warning\n-   |         ^^^\n+   |         ^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:75:9\n    |\n+LL |         BAR => {}\n+   |         --- matches any value\n+...\n LL |         _ => {} // should not be emitting unreachable warning\n-   |         ^\n+   |         ^ unreachable pattern\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:80:9\n@@ -115,14 +130,20 @@ LL |         BAZ => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:82:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+LL |\n LL |         Baz::Baz1 => {} // should not be emitting unreachable warning\n-   |         ^^^^^^^^^\n+   |         ^^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:84:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+...\n LL |         _ => {}\n-   |         ^\n+   |         ^ unreachable pattern\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:90:9\n@@ -133,8 +154,11 @@ LL |         BAZ => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:92:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+LL |\n LL |         _ => {}\n-   |         ^\n+   |         ^ unreachable pattern\n \n error: to use a constant of type `Baz` in a pattern, `Baz` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/consts-opaque.rs:97:9\n@@ -145,20 +169,28 @@ LL |         BAZ => {}\n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:99:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+LL |\n LL |         Baz::Baz2 => {} // should not be emitting unreachable warning\n-   |         ^^^^^^^^^\n+   |         ^^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:101:9\n    |\n+LL |         BAZ => {}\n+   |         --- matches any value\n+...\n LL |         _ => {} // should not be emitting unreachable warning\n-   |         ^\n+   |         ^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:127:9\n    |\n+LL |         Wrap(_) => {}\n+   |         ------- matches any value\n LL |         WRAPQUUX => {} // detected unreachable because we do inspect the `Wrap` layer\n-   |         ^^^^^^^^\n+   |         ^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/consts-opaque.rs:141:9"}, {"sha": "0ffb0ffd82aa0f6735b19c09b065240cd2aa573c", "filename": "src/test/ui/pattern/usefulness/integer-ranges/reachability.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Finteger-ranges%2Freachability.stderr?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -133,8 +133,10 @@ LL |         5..15 => {},\n error: unreachable pattern\n   --> $DIR/reachability.rs:83:9\n    |\n+LL |         _ => {},\n+   |         - matches any value\n LL |         '\\u{D7FF}'..='\\u{E000}' => {},\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ unreachable pattern\n \n error: unreachable pattern\n   --> $DIR/reachability.rs:104:9"}, {"sha": "48ed14915084a5d607ae44e57b8a0cedcc4a6d3b", "filename": "src/test/ui/pattern/usefulness/issue-3601.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `Box(_, _)` not covered\n+error[E0004]: non-exhaustive patterns: `box _` not covered\n   --> $DIR/issue-3601.rs:30:44\n    |\n LL |         box NodeKind::Element(ed) => match ed.kind {\n-   |                                            ^^^^^^^ pattern `Box(_, _)` not covered\n+   |                                            ^^^^^^^ pattern `box _` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `Box<ElementKind>`"}, {"sha": "c1bfcc73402ced39b796d01e55c0d3e7725f2dd5", "filename": "src/test/ui/pattern/usefulness/issue-82772-match-box-as-struct.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-82772-match-box-as-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-82772-match-box-as-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-82772-match-box-as-struct.rs?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -0,0 +1,6 @@\n+// This used to ICE in exhaustiveness checking. Explanation here:\n+// https://github.com/rust-lang/rust/issues/82772#issuecomment-905946768\n+fn main() {\n+    let Box { 1: _, .. }: Box<()>; //~ ERROR field `1` of\n+    let Box { .. }: Box<()>;\n+}"}, {"sha": "2c8c85bb1e00548ca10ee5f51fdc3f66a0191294", "filename": "src/test/ui/pattern/usefulness/issue-82772-match-box-as-struct.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-82772-match-box-as-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6df1d82869d06b88ff413e63a1e8efbb311e3b5c/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-82772-match-box-as-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-82772-match-box-as-struct.stderr?ref=6df1d82869d06b88ff413e63a1e8efbb311e3b5c", "patch": "@@ -0,0 +1,9 @@\n+error[E0451]: field `1` of struct `Box` is private\n+  --> $DIR/issue-82772-match-box-as-struct.rs:4:15\n+   |\n+LL |     let Box { 1: _, .. }: Box<()>;\n+   |               ^^^^ private field\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0451`."}]}