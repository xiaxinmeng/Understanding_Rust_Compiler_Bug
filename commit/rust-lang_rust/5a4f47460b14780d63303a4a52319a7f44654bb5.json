{"sha": "5a4f47460b14780d63303a4a52319a7f44654bb5", "node_id": "C_kwDOAAsO6NoAKDVhNGY0NzQ2MGIxNDc4MGQ2MzMwM2E0YTUyMzE5YTdmNDQ2NTRiYjU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-18T21:00:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-18T21:00:47Z"}, "message": "Rollup merge of #92780 - b-naber:postpone-const-eval-coherence, r=lcnr\n\nDirectly use ConstValue for single literals in blocks\n\nAddresses the minimal repro in https://github.com/rust-lang/rust/issues/92186, but doesn't fix the underlying problem (which would be solved by solving the anon subst problem afaict).\n\nI do, however, think that it makes sense in general to treat single literals in anon blocks as const values directly, especially in light of the problem that the issue refers to (anon const evaluation being postponed until infer variables in substs can be resolved, which was introduced by https://github.com/rust-lang/rust/pull/90023), i.e. while we do get warnings for those unnecessary braces, we should try to avoid errors caused by those braces if possible.", "tree": {"sha": "454e2359ed3de519e6e812a12386fd5b6ff4a8e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/454e2359ed3de519e6e812a12386fd5b6ff4a8e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a4f47460b14780d63303a4a52319a7f44654bb5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh5yqACRBK7hj4Ov3rIwAAHMwIACePWRpolko96QvP3D7Ua1JV\nVwwX/rO69B3GmUvav2yodAo9eEKnxGTnd2L8k02wyl9KxnesU10pzKJE2BE9ZSTE\niIWiwm/+dENJKeFb4+t3CxBvKWHXe9LnXg7JXa+yWaJGf0nqCnqnJg6OB/m6v6pH\nPCxbA6xM798w+Lyil2K63dYJHASfWSDSyhMg9a9SYMu7kZ9rix4giE7oieT3XIXf\nVw7UOwf6sBXaSUfzULx2DkLki74z3h9e3zsgM5+lDs+0Pp/QgIiOsNNA+P7JCK3X\nuD//E6euFlObgYdIF0/bLWK49qw/zmSClBPCZoAiVPxaKGXrJ18oleVx/ZHI120=\n=moQp\n-----END PGP SIGNATURE-----\n", "payload": "tree 454e2359ed3de519e6e812a12386fd5b6ff4a8e2\nparent ff476b3009bd0f0137ade6eb02af2794c19066d2\nparent 7dac6260920bc4fbd6988609bd80af05aa60a400\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642539647 +0100\ncommitter GitHub <noreply@github.com> 1642539647 +0100\n\nRollup merge of #92780 - b-naber:postpone-const-eval-coherence, r=lcnr\n\nDirectly use ConstValue for single literals in blocks\n\nAddresses the minimal repro in https://github.com/rust-lang/rust/issues/92186, but doesn't fix the underlying problem (which would be solved by solving the anon subst problem afaict).\n\nI do, however, think that it makes sense in general to treat single literals in anon blocks as const values directly, especially in light of the problem that the issue refers to (anon const evaluation being postponed until infer variables in substs can be resolved, which was introduced by https://github.com/rust-lang/rust/pull/90023), i.e. while we do get warnings for those unnecessary braces, we should try to avoid errors caused by those braces if possible.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a4f47460b14780d63303a4a52319a7f44654bb5", "html_url": "https://github.com/rust-lang/rust/commit/5a4f47460b14780d63303a4a52319a7f44654bb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a4f47460b14780d63303a4a52319a7f44654bb5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff476b3009bd0f0137ade6eb02af2794c19066d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff476b3009bd0f0137ade6eb02af2794c19066d2", "html_url": "https://github.com/rust-lang/rust/commit/ff476b3009bd0f0137ade6eb02af2794c19066d2"}, {"sha": "7dac6260920bc4fbd6988609bd80af05aa60a400", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dac6260920bc4fbd6988609bd80af05aa60a400", "html_url": "https://github.com/rust-lang/rust/commit/7dac6260920bc4fbd6988609bd80af05aa60a400"}], "stats": {"total": 76, "additions": 55, "deletions": 21}, "files": [{"sha": "19a73732fcac3aaba32925a705fb4b9dd471385c", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5a4f47460b14780d63303a4a52319a7f44654bb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4f47460b14780d63303a4a52319a7f44654bb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=5a4f47460b14780d63303a4a52319a7f44654bb5", "patch": "@@ -36,6 +36,7 @@ impl<'tcx> Const<'tcx> {\n         Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id))\n     }\n \n+    #[instrument(skip(tcx), level = \"debug\")]\n     pub fn from_opt_const_arg_anon_const(\n         tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n@@ -51,6 +52,7 @@ impl<'tcx> Const<'tcx> {\n         };\n \n         let expr = &tcx.hir().body(body_id).value;\n+        debug!(?expr);\n \n         let ty = tcx.type_of(def.def_id_for_type_of());\n \n@@ -67,11 +69,21 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n+    #[instrument(skip(tcx), level = \"debug\")]\n     fn try_eval_lit_or_param(\n         tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Option<&'tcx Self> {\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        let expr = match &expr.kind {\n+            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n+                block.expr.as_ref().unwrap()\n+            }\n+            _ => expr,\n+        };\n+\n         let lit_input = match expr.kind {\n             hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n             hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n@@ -97,15 +109,6 @@ impl<'tcx> Const<'tcx> {\n             }\n         }\n \n-        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n-        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        let expr = match &expr.kind {\n-            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n-                block.expr.as_ref().unwrap()\n-            }\n-            _ => expr,\n-        };\n-\n         use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n         match expr.kind {\n             ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {"}, {"sha": "af3540386f9fc71fdde9b4c9f4f8bce51575db35", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a4f47460b14780d63303a4a52319a7f44654bb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4f47460b14780d63303a4a52319a7f44654bb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=5a4f47460b14780d63303a4a52319a7f44654bb5", "patch": "@@ -53,6 +53,7 @@ pub fn add_placeholder_note(err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n /// If there are types that satisfy both impls, invokes `on_overlap`\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, invokes `no_overlap`.\n+#[instrument(skip(tcx, skip_leak_check, on_overlap, no_overlap), level = \"debug\")]\n pub fn overlapping_impls<F1, F2, R>(\n     tcx: TyCtxt<'_>,\n     impl1_def_id: DefId,\n@@ -65,12 +66,6 @@ where\n     F1: FnOnce(OverlapResult<'_>) -> R,\n     F2: FnOnce() -> R,\n {\n-    debug!(\n-        \"overlapping_impls(\\\n-           impl1_def_id={:?}, \\\n-           impl2_def_id={:?})\",\n-        impl1_def_id, impl2_def_id,\n-    );\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n@@ -85,6 +80,7 @@ where\n     .any(|(ty1, ty2)| {\n         let t1 = fast_reject::simplify_type(tcx, ty1, SimplifyParams::No, StripReferences::No);\n         let t2 = fast_reject::simplify_type(tcx, ty2, SimplifyParams::No, StripReferences::No);\n+\n         if let (Some(t1), Some(t2)) = (t1, t2) {\n             // Simplified successfully\n             t1 != t2"}, {"sha": "cd2e0f18e0cc0f6404c801f1a20941f209f6e74f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a4f47460b14780d63303a4a52319a7f44654bb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4f47460b14780d63303a4a52319a7f44654bb5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=5a4f47460b14780d63303a4a52319a7f44654bb5", "patch": "@@ -117,9 +117,8 @@ pub fn translate_substs<'a, 'tcx>(\n /// Specialization is determined by the sets of types to which the impls apply;\n /// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n+#[instrument(skip(tcx), level = \"debug\")]\n pub(super) fn specializes(tcx: TyCtxt<'_>, (impl1_def_id, impl2_def_id): (DefId, DefId)) -> bool {\n-    debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n-\n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n     let features = tcx.features();"}, {"sha": "9ced4667d249a887cc3ade7507d4e368a1098eec", "filename": "src/test/ui/const-generics/issues/issue-92186.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a4f47460b14780d63303a4a52319a7f44654bb5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-92186.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4f47460b14780d63303a4a52319a7f44654bb5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-92186.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-92186.rs?ref=5a4f47460b14780d63303a4a52319a7f44654bb5", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+pub struct Foo<const N: usize>;\n+pub trait Bar<T> {}\n+\n+impl<T> Bar<T> for Foo<{ 1 }> {}\n+impl<T> Bar<T> for Foo<{ 2 }> {}\n+\n+fn main() {}"}, {"sha": "4d6b752867f1b0bd23c00e779a99483c6c70803d", "filename": "src/test/ui/const-generics/types-mismatch-const-args.full.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5a4f47460b14780d63303a4a52319a7f44654bb5/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a4f47460b14780d63303a4a52319a7f44654bb5/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr?ref=5a4f47460b14780d63303a4a52319a7f44654bb5", "patch": "@@ -15,9 +15,20 @@ LL |     let _: A<'a, u16, {2u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `A<'a, u16, {2u32}, {3u32}>`\n-              found struct `A<'b, u32, {2u32}, {3u32}>`\n+   = note: expected struct `A<'a, u16, _, _>`\n+              found struct `A<'b, u32, _, _>`\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/types-mismatch-const-args.rs:18:41\n+   |\n+LL |     let _: A<'a, u16, {4u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data: PhantomData };\n+   |            --------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected struct `A<'a, u16, 4_u32, _>`\n+              found struct `A<'b, u32, 2_u32, _>`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "8b60238cb0c030469a4c04ab9b03968c67500072", "filename": "src/test/ui/const-generics/types-mismatch-const-args.min.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a4f47460b14780d63303a4a52319a7f44654bb5/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a4f47460b14780d63303a4a52319a7f44654bb5/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.min.stderr?ref=5a4f47460b14780d63303a4a52319a7f44654bb5", "patch": "@@ -20,6 +20,17 @@ LL |     let _: A<'a, u16, {2u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data\n    = note: expected struct `A<'a, u16, _, _>`\n               found struct `A<'b, u32, _, _>`\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/types-mismatch-const-args.rs:18:41\n+   |\n+LL |     let _: A<'a, u16, {4u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data: PhantomData };\n+   |            --------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found `u32`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected struct `A<'a, u16, 4_u32, _>`\n+              found struct `A<'b, u32, 2_u32, _>`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "43ef28b268f56becba15ecfd8504385455a74b3d", "filename": "src/test/ui/const-generics/types-mismatch-const-args.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a4f47460b14780d63303a4a52319a7f44654bb5/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4f47460b14780d63303a4a52319a7f44654bb5/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.rs?ref=5a4f47460b14780d63303a4a52319a7f44654bb5", "patch": "@@ -15,6 +15,8 @@ fn a<'a, 'b>() {\n     //~^ ERROR mismatched types\n     let _: A<'a, u16, {2u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data: PhantomData };\n     //~^ ERROR mismatched types\n+    let _: A<'a, u16, {4u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data: PhantomData };\n+    //~^ ERROR mismatched types\n }\n \n pub fn main() {}"}]}