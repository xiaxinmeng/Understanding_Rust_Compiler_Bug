{"sha": "e41a6fc042cdd40f415eba4288d5c5e1161266b1", "node_id": "C_kwDOAAsO6NoAKGU0MWE2ZmMwNDJjZGQ0MGY0MTVlYmE0Mjg4ZDVjNWUxMTYxMjY2YjE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T18:42:17Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:20:18Z"}, "message": "Split out `match_like_matches_macro`", "tree": {"sha": "65dc291e2e544ab6de2a12bc224a023ceb71abb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65dc291e2e544ab6de2a12bc224a023ceb71abb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e41a6fc042cdd40f415eba4288d5c5e1161266b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e41a6fc042cdd40f415eba4288d5c5e1161266b1", "html_url": "https://github.com/rust-lang/rust/commit/e41a6fc042cdd40f415eba4288d5c5e1161266b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e41a6fc042cdd40f415eba4288d5c5e1161266b1/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7be9564e5e7803365d6225883c1711dae694de5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7be9564e5e7803365d6225883c1711dae694de5", "html_url": "https://github.com/rust-lang/rust/commit/f7be9564e5e7803365d6225883c1711dae694de5"}], "stats": {"total": 338, "additions": 175, "deletions": 163}, "files": [{"sha": "d605b6d73c09d8b9684e4d2b83a76a91a19b82f2", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/e41a6fc042cdd40f415eba4288d5c5e1161266b1/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41a6fc042cdd40f415eba4288d5c5e1161266b1/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=e41a6fc042cdd40f415eba4288d5c5e1161266b1", "patch": "@@ -0,0 +1,166 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{higher, is_wild};\n+use rustc_ast::{Attribute, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Guard, MatchSource, Pat};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Spanned;\n+\n+use super::MATCH_LIKE_MATCHES_MACRO;\n+\n+/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        return find_matches_sugg(\n+            cx,\n+            let_expr,\n+            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n+            expr,\n+            true,\n+        );\n+    }\n+\n+    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n+        return find_matches_sugg(\n+            cx,\n+            scrut,\n+            arms.iter().map(|arm| {\n+                (\n+                    cx.tcx.hir().attrs(arm.hir_id),\n+                    Some(arm.pat),\n+                    arm.body,\n+                    arm.guard.as_ref(),\n+                )\n+            }),\n+            expr,\n+            false,\n+        );\n+    }\n+\n+    false\n+}\n+\n+/// Lint a `match` or `if let` for replacement by `matches!`\n+fn find_matches_sugg<'a, 'b, I>(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    mut iter: I,\n+    expr: &Expr<'_>,\n+    is_if_let: bool,\n+) -> bool\n+where\n+    'b: 'a,\n+    I: Clone\n+        + DoubleEndedIterator\n+        + ExactSizeIterator\n+        + Iterator<\n+            Item = (\n+                &'a [Attribute],\n+                Option<&'a Pat<'b>>,\n+                &'a Expr<'b>,\n+                Option<&'a Guard<'b>>,\n+            ),\n+        >,\n+{\n+    if_chain! {\n+        if iter.len() >= 2;\n+        if cx.typeck_results().expr_ty(expr).is_bool();\n+        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n+        let iter_without_last = iter.clone();\n+        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n+        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n+        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n+        if b0 != b1;\n+        if first_guard.is_none() || iter.len() == 0;\n+        if first_attrs.is_empty();\n+        if iter\n+            .all(|arm| {\n+                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n+            });\n+        then {\n+            if let Some(last_pat) = last_pat_opt {\n+                if !is_wild(last_pat) {\n+                    return false;\n+                }\n+            }\n+\n+            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n+            // evaluated into `false` and so such arms will be stripped before.\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let pat = {\n+                use itertools::Itertools as _;\n+                iter_without_last\n+                    .filter_map(|arm| {\n+                        let pat_span = arm.1?.span;\n+                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n+                    })\n+                    .join(\" | \")\n+            };\n+            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n+                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            } else {\n+                pat\n+            };\n+\n+            // strip potential borrows (#6503), but only if the type is a reference\n+            let mut ex_new = ex;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n+                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n+                    ex_new = ex_inner;\n+                }\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_LIKE_MATCHES_MACRO,\n+                expr.span,\n+                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n+                \"try this\",\n+                format!(\n+                    \"{}matches!({}, {})\",\n+                    if b0 { \"\" } else { \"!\" },\n+                    snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n+                    pat_and_guard,\n+                ),\n+                applicability,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Extract a `bool` or `{ bool }`\n+fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n+    match ex {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Bool(b), ..\n+        }) => Some(*b),\n+        ExprKind::Block(\n+            rustc_hir::Block {\n+                stmts: &[],\n+                expr: Some(exp),\n+                ..\n+            },\n+            _,\n+        ) if is_if_let => {\n+            if let ExprKind::Lit(Spanned {\n+                node: LitKind::Bool(b), ..\n+            }) = exp.kind\n+            {\n+                Some(b)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "ff07fc6d4d46572c94bdbead26ee65a1ead5c99f", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 9, "deletions": 163, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e41a6fc042cdd40f415eba4288d5c5e1161266b1/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41a6fc042cdd40f415eba4288d5c5e1161266b1/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=e41a6fc042cdd40f415eba4288d5c5e1161266b1", "patch": "@@ -3,6 +3,7 @@ use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n use clippy_utils::macros::{is_panic, root_macro_call};\n+use clippy_utils::peel_blocks_with_stmt;\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n@@ -12,28 +13,28 @@ use clippy_utils::{\n     path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n     strip_pat_refs,\n };\n-use clippy_utils::{higher, peel_blocks_with_stmt};\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n-use core::iter::{once, ExactSizeIterator};\n+use core::iter::once;\n use if_chain::if_chain;\n-use rustc_ast::ast::{Attribute, LitKind};\n+use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource,\n-    Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n+    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, HirId, Local, MatchSource, Mutability,\n+    Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n };\n use rustc_hir::{HirIdMap, HirIdSet};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::{sym, symbol::kw};\n+use rustc_span::{sym, symbol::kw, Span};\n use std::cmp::{max, Ordering};\n use std::collections::hash_map::Entry;\n \n+mod match_like_matches;\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for matches with a single arm where an `if let`\n@@ -622,7 +623,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         redundant_pattern_match::check(cx, expr);\n \n         if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n-            if !check_match_like_matches(cx, expr) {\n+            if !match_like_matches::check(cx, expr) {\n                 lint_match_arms(cx, expr);\n             }\n         } else {\n@@ -1382,161 +1383,6 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     }\n }\n \n-/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some(higher::IfLet {\n-        let_pat,\n-        let_expr,\n-        if_then,\n-        if_else: Some(if_else),\n-    }) = higher::IfLet::hir(cx, expr)\n-    {\n-        return find_matches_sugg(\n-            cx,\n-            let_expr,\n-            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n-            expr,\n-            true,\n-        );\n-    }\n-\n-    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n-        return find_matches_sugg(\n-            cx,\n-            scrut,\n-            arms.iter().map(|arm| {\n-                (\n-                    cx.tcx.hir().attrs(arm.hir_id),\n-                    Some(arm.pat),\n-                    arm.body,\n-                    arm.guard.as_ref(),\n-                )\n-            }),\n-            expr,\n-            false,\n-        );\n-    }\n-\n-    false\n-}\n-\n-/// Lint a `match` or `if let` for replacement by `matches!`\n-fn find_matches_sugg<'a, 'b, I>(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    mut iter: I,\n-    expr: &Expr<'_>,\n-    is_if_let: bool,\n-) -> bool\n-where\n-    'b: 'a,\n-    I: Clone\n-        + DoubleEndedIterator\n-        + ExactSizeIterator\n-        + Iterator<\n-            Item = (\n-                &'a [Attribute],\n-                Option<&'a Pat<'b>>,\n-                &'a Expr<'b>,\n-                Option<&'a Guard<'b>>,\n-            ),\n-        >,\n-{\n-    if_chain! {\n-        if iter.len() >= 2;\n-        if cx.typeck_results().expr_ty(expr).is_bool();\n-        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n-        let iter_without_last = iter.clone();\n-        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n-        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n-        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n-        if b0 != b1;\n-        if first_guard.is_none() || iter.len() == 0;\n-        if first_attrs.is_empty();\n-        if iter\n-            .all(|arm| {\n-                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n-            });\n-        then {\n-            if let Some(last_pat) = last_pat_opt {\n-                if !is_wild(last_pat) {\n-                    return false;\n-                }\n-            }\n-\n-            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n-            // evaluated into `false` and so such arms will be stripped before.\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            let pat = {\n-                use itertools::Itertools as _;\n-                iter_without_last\n-                    .filter_map(|arm| {\n-                        let pat_span = arm.1?.span;\n-                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n-                    })\n-                    .join(\" | \")\n-            };\n-            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n-                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n-            } else {\n-                pat\n-            };\n-\n-            // strip potential borrows (#6503), but only if the type is a reference\n-            let mut ex_new = ex;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n-                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n-                    ex_new = ex_inner;\n-                }\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_LIKE_MATCHES_MACRO,\n-                expr.span,\n-                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n-                \"try this\",\n-                format!(\n-                    \"{}matches!({}, {})\",\n-                    if b0 { \"\" } else { \"!\" },\n-                    snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n-                    pat_and_guard,\n-                ),\n-                applicability,\n-            );\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-/// Extract a `bool` or `{ bool }`\n-fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n-    match ex {\n-        ExprKind::Lit(Spanned {\n-            node: LitKind::Bool(b), ..\n-        }) => Some(*b),\n-        ExprKind::Block(\n-            rustc_hir::Block {\n-                stmts: &[],\n-                expr: Some(exp),\n-                ..\n-            },\n-            _,\n-        ) if is_if_let => {\n-            if let ExprKind::Lit(Spanned {\n-                node: LitKind::Bool(b), ..\n-            }) = exp.kind\n-            {\n-                Some(b)\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None,\n-    }\n-}\n-\n #[allow(clippy::too_many_lines)]\n fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {"}]}