{"sha": "c66cca44c815baf7d4b01d0aa66bf79ee4e3a610", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NmNjYTQ0YzgxNWJhZjdkNGIwMWQwYWE2NmJmNzllZTRlM2E2MTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-03T18:36:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-03T18:36:19Z"}, "message": "Auto merge of #4877 - flip1995:manual_swap_4853, r=llogiq\n\nFix FP in manual_swap lint with slice-like types\n\nFixes #4853\n\nchangelog: Fix FP in [`manual_swap`] lint with slice-like types and make it auto applicable", "tree": {"sha": "7f9db91c2acf9a786d09a9f1ac90722480b9d4ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f9db91c2acf9a786d09a9f1ac90722480b9d4ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610", "html_url": "https://github.com/rust-lang/rust/commit/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0fc18a71057d5fc01927d03cc04cc830fe416fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0fc18a71057d5fc01927d03cc04cc830fe416fc", "html_url": "https://github.com/rust-lang/rust/commit/f0fc18a71057d5fc01927d03cc04cc830fe416fc"}, {"sha": "aa2381d9d0c83ce4a2c0a6de6ac472d3fef4c7a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2381d9d0c83ce4a2c0a6de6ac472d3fef4c7a1", "html_url": "https://github.com/rust-lang/rust/commit/aa2381d9d0c83ce4a2c0a6de6ac472d3fef4c7a1"}], "stats": {"total": 254, "additions": 196, "deletions": 58}, "files": [{"sha": "b792423917eab0492bb8fea17f62f446970e6239", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 94, "deletions": 51, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=c66cca44c815baf7d4b01d0aa66bf79ee4e3a610", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    differing_macro_contexts, is_type_diagnostic_item, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty,\n-    SpanlessEq,\n+    differing_macro_contexts, is_type_diagnostic_item, match_type, paths, snippet_with_applicability,\n+    span_lint_and_then, walk_ptrs_ty, SpanlessEq,\n };\n use if_chain::if_chain;\n use matches::matches;\n@@ -97,29 +97,6 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1);\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n             then {\n-                fn check_for_slice<'a>(\n-                    cx: &LateContext<'_, '_>,\n-                    lhs1: &'a Expr,\n-                    lhs2: &'a Expr,\n-                ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n-                    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n-                        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n-                            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n-                                let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n-\n-                                if matches!(ty.kind, ty::Slice(_)) ||\n-                                    matches!(ty.kind, ty::Array(_, _)) ||\n-                                    is_type_diagnostic_item(cx, ty, Symbol::intern(\"vec_type\")) ||\n-                                    match_type(cx, ty, &paths::VEC_DEQUE) {\n-                                        return Some((lhs1, idx1, idx2));\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    None\n-                }\n-\n                 if let ExprKind::Field(ref lhs1, _) = lhs1.kind {\n                     if let ExprKind::Field(ref lhs2, _) = lhs2.kind {\n                         if lhs1.hir_id.owner_def_id() == lhs2.hir_id.owner_def_id() {\n@@ -128,47 +105,113 @@ fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n                     }\n                 }\n \n-                let (replace, what, sugg) = if let Some((slice, idx1, idx2)) = check_for_slice(cx, lhs1, lhs2) {\n+                let mut applicability = Applicability::MachineApplicable;\n+\n+                let slice = check_for_slice(cx, lhs1, lhs2);\n+                let (replace, what, sugg) = if let Slice::NotSwappable = slice {\n+                    return;\n+                } else if let Slice::Swappable(slice, idx1, idx2) = slice {\n                     if let Some(slice) = Sugg::hir_opt(cx, slice) {\n-                        (false,\n-                         format!(\" elements of `{}`\", slice),\n-                         format!(\"{}.swap({}, {})\",\n-                                 slice.maybe_par(),\n-                                 snippet(cx, idx1.span, \"..\"),\n-                                 snippet(cx, idx2.span, \"..\")))\n+                        (\n+                            false,\n+                            format!(\" elements of `{}`\", slice),\n+                            format!(\n+                                \"{}.swap({}, {})\",\n+                                slice.maybe_par(),\n+                                snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability),\n+                                snippet_with_applicability(cx, idx2.span, \"..\", &mut applicability),\n+                            ),\n+                        )\n                     } else {\n                         (false, String::new(), String::new())\n                     }\n                 } else if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n-                    (true, format!(\" `{}` and `{}`\", first, second),\n-                        format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()))\n+                    (\n+                        true,\n+                        format!(\" `{}` and `{}`\", first, second),\n+                        format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n+                    )\n                 } else {\n                     (true, String::new(), String::new())\n                 };\n \n                 let span = w[0].span.to(second.span);\n \n-                span_lint_and_then(cx,\n-                                   MANUAL_SWAP,\n-                                   span,\n-                                   &format!(\"this looks like you are swapping{} manually\", what),\n-                                   |db| {\n-                                       if !sugg.is_empty() {\n-                                           db.span_suggestion(\n-                                               span,\n-                                               \"try\",\n-                                               sugg,\n-                                               Applicability::Unspecified,\n-                                           );\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_SWAP,\n+                    span,\n+                    &format!(\"this looks like you are swapping{} manually\", what),\n+                    |db| {\n+                        if !sugg.is_empty() {\n+                            db.span_suggestion(\n+                                span,\n+                                \"try\",\n+                                sugg,\n+                                applicability,\n+                            );\n \n-                                           if replace {\n-                                               db.note(\"or maybe you should use `std::mem::replace`?\");\n-                                           }\n-                                       }\n-                                   });\n+                            if replace {\n+                                db.note(\"or maybe you should use `std::mem::replace`?\");\n+                            }\n+                        }\n+                    }\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+enum Slice<'a> {\n+    /// `slice.swap(idx1, idx2)` can be used\n+    ///\n+    /// ## Example\n+    ///\n+    /// ```rust\n+    /// # let mut a = vec![0, 1];\n+    /// let t = a[1];\n+    /// a[1] = a[0];\n+    /// a[0] = t;\n+    /// // can be written as\n+    /// a.swap(0, 1);\n+    /// ```\n+    Swappable(&'a Expr, &'a Expr, &'a Expr),\n+    /// The `swap` function cannot be used.\n+    ///\n+    /// ## Example\n+    ///\n+    /// ```rust\n+    /// # let mut a = [vec![1, 2], vec![3, 4]];\n+    /// let t = a[0][1];\n+    /// a[0][1] = a[1][0];\n+    /// a[1][0] = t;\n+    /// ```\n+    NotSwappable,\n+    /// Not a slice\n+    None,\n+}\n+\n+/// Checks if both expressions are index operations into \"slice-like\" types.\n+fn check_for_slice<'a>(cx: &LateContext<'_, '_>, lhs1: &'a Expr, lhs2: &'a Expr) -> Slice<'a> {\n+    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n+        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n+            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n+                let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n+\n+                if matches!(ty.kind, ty::Slice(_))\n+                    || matches!(ty.kind, ty::Array(_, _))\n+                    || is_type_diagnostic_item(cx, ty, Symbol::intern(\"vec_type\"))\n+                    || match_type(cx, ty, &paths::VEC_DEQUE)\n+                {\n+                    return Slice::Swappable(lhs1, idx1, idx2);\n+                }\n+            } else {\n+                return Slice::NotSwappable;\n             }\n         }\n     }\n+\n+    Slice::None\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint."}, {"sha": "82931bf91fdf2c025a2a679f8794dbe2ef05abf1", "filename": "tests/ui/swap.fixed", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/tests%2Fui%2Fswap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/tests%2Fui%2Fswap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.fixed?ref=c66cca44c815baf7d4b01d0aa66bf79ee4e3a610", "patch": "@@ -0,0 +1,83 @@\n+// run-rustfix\n+\n+#![warn(clippy::all)]\n+#![allow(\n+    clippy::blacklisted_name,\n+    clippy::no_effect,\n+    clippy::redundant_clone,\n+    redundant_semicolon,\n+    unused_assignments\n+)]\n+\n+struct Foo(u32);\n+\n+#[derive(Clone)]\n+struct Bar {\n+    a: u32,\n+    b: u32,\n+}\n+\n+fn field() {\n+    let mut bar = Bar { a: 1, b: 2 };\n+\n+    let temp = bar.a;\n+    bar.a = bar.b;\n+    bar.b = temp;\n+\n+    let mut baz = vec![bar.clone(), bar.clone()];\n+    let temp = baz[0].a;\n+    baz[0].a = baz[1].a;\n+    baz[1].a = temp;\n+}\n+\n+fn array() {\n+    let mut foo = [1, 2];\n+    foo.swap(0, 1);\n+\n+    foo.swap(0, 1);\n+}\n+\n+fn slice() {\n+    let foo = &mut [1, 2];\n+    foo.swap(0, 1);\n+\n+    foo.swap(0, 1);\n+}\n+\n+fn unswappable_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    let temp = foo[0][1];\n+    foo[0][1] = foo[1][0];\n+    foo[1][0] = temp;\n+\n+    // swap(foo[0][1], foo[1][0]) would fail\n+}\n+\n+fn vec() {\n+    let mut foo = vec![1, 2];\n+    foo.swap(0, 1);\n+\n+    foo.swap(0, 1);\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    field();\n+    array();\n+    slice();\n+    unswappable_slice();\n+    vec();\n+\n+    let mut a = 42;\n+    let mut b = 1337;\n+\n+    std::mem::swap(&mut a, &mut b);\n+\n+    ; std::mem::swap(&mut a, &mut b);\n+\n+    let mut c = Foo(42);\n+\n+    std::mem::swap(&mut c.0, &mut a);\n+\n+    ; std::mem::swap(&mut c.0, &mut a);\n+}"}, {"sha": "4582db4b40e29158c312dda948b6c970d275eece", "filename": "tests/ui/swap.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/tests%2Fui%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/tests%2Fui%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.rs?ref=c66cca44c815baf7d4b01d0aa66bf79ee4e3a610", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![warn(clippy::all)]\n #![allow(\n     clippy::blacklisted_name,\n@@ -46,6 +48,15 @@ fn slice() {\n     foo.swap(0, 1);\n }\n \n+fn unswappable_slice() {\n+    let foo = &mut [vec![1, 2], vec![3, 4]];\n+    let temp = foo[0][1];\n+    foo[0][1] = foo[1][0];\n+    foo[1][0] = temp;\n+\n+    // swap(foo[0][1], foo[1][0]) would fail\n+}\n+\n fn vec() {\n     let mut foo = vec![1, 2];\n     let temp = foo[0];\n@@ -60,6 +71,7 @@ fn main() {\n     field();\n     array();\n     slice();\n+    unswappable_slice();\n     vec();\n \n     let mut a = 42;"}, {"sha": "f49bcfedf3a1970b59751afe03ef8bf400d5cc23", "filename": "tests/ui/swap.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/tests%2Fui%2Fswap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c66cca44c815baf7d4b01d0aa66bf79ee4e3a610/tests%2Fui%2Fswap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.stderr?ref=c66cca44c815baf7d4b01d0aa66bf79ee4e3a610", "patch": "@@ -1,5 +1,5 @@\n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:33:5\n+  --> $DIR/swap.rs:35:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n@@ -9,23 +9,23 @@ LL | |     foo[1] = temp;\n    = note: `-D clippy::manual-swap` implied by `-D warnings`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:42:5\n+  --> $DIR/swap.rs:44:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping elements of `foo` manually\n-  --> $DIR/swap.rs:51:5\n+  --> $DIR/swap.rs:62:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n    | |_________________^ help: try: `foo.swap(0, 1)`\n \n error: this looks like you are swapping `a` and `b` manually\n-  --> $DIR/swap.rs:71:7\n+  --> $DIR/swap.rs:83:7\n    |\n LL |       ; let t = a;\n    |  _______^\n@@ -36,7 +36,7 @@ LL | |     b = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are swapping `c.0` and `a` manually\n-  --> $DIR/swap.rs:80:7\n+  --> $DIR/swap.rs:92:7\n    |\n LL |       ; let t = c.0;\n    |  _______^\n@@ -47,7 +47,7 @@ LL | |     a = t;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `a` and `b`\n-  --> $DIR/swap.rs:68:5\n+  --> $DIR/swap.rs:80:5\n    |\n LL | /     a = b;\n LL | |     b = a;\n@@ -57,7 +57,7 @@ LL | |     b = a;\n    = note: or maybe you should use `std::mem::replace`?\n \n error: this looks like you are trying to swap `c.0` and `a`\n-  --> $DIR/swap.rs:77:5\n+  --> $DIR/swap.rs:89:5\n    |\n LL | /     c.0 = a;\n LL | |     a = c.0;"}]}