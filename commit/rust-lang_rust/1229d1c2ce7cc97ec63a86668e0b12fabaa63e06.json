{"sha": "1229d1c2ce7cc97ec63a86668e0b12fabaa63e06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMjlkMWMyY2U3Y2M5N2VjNjNhODY2NjhlMGIxMmZhYmFhNjNlMDY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T21:08:34Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T21:12:36Z"}, "message": "De-export option and option_iter. Part of #3583.", "tree": {"sha": "39871d0977b4b0cda67ed39961ec591f078be781", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39871d0977b4b0cda67ed39961ec591f078be781"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06", "html_url": "https://github.com/rust-lang/rust/commit/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21", "url": "https://api.github.com/repos/rust-lang/rust/commits/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21", "html_url": "https://github.com/rust-lang/rust/commit/db44dc5cf27d9e3ff2b16b18e9ea5ea5c273ff21"}], "stats": {"total": 49, "additions": 24, "deletions": 25}, "files": [{"sha": "3faa8eab0182923377afdd12e217cfb0b384cf51", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=1229d1c2ce7cc97ec63a86668e0b12fabaa63e06", "patch": "@@ -190,13 +190,10 @@ mod either;\n #[legacy_exports]\n mod iter;\n mod logging;\n-#[legacy_exports]\n mod option;\n #[path=\"iter-trait\"]\n mod option_iter {\n-    #[legacy_exports];\n     #[path = \"option.rs\"]\n-    #[legacy_exports]\n     mod inst;\n }\n #[legacy_exports]"}, {"sha": "44afe9f54f00c6eca225176f675ead7e268129b7", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=1229d1c2ce7cc97ec63a86668e0b12fabaa63e06", "patch": "@@ -1,14 +1,14 @@\n #[allow(non_camel_case_types)]\n-type IMPL_T<A> = Option<A>;\n+pub type IMPL_T<A> = Option<A>;\n \n-pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n+pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n     match *self {\n       None => (),\n       Some(ref a) => { f(a); }\n     }\n }\n \n-pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n+pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n     match *self {\n       None => Some(0),\n       Some(_) => Some(1)"}, {"sha": "50cd0fdb5ba3287214eb9b4e48ed799e08ae287b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1229d1c2ce7cc97ec63a86668e0b12fabaa63e06/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=1229d1c2ce7cc97ec63a86668e0b12fabaa63e06", "patch": "@@ -15,12 +15,12 @@\n use cmp::Eq;\n \n /// The option type\n-enum Option<T> {\n+pub enum Option<T> {\n     None,\n     Some(T),\n }\n \n-pure fn get<T: Copy>(opt: &Option<T>) -> T {\n+pub pure fn get<T: Copy>(opt: &Option<T>) -> T {\n     /*!\n      * Gets the value out of an option\n      *\n@@ -35,7 +35,7 @@ pure fn get<T: Copy>(opt: &Option<T>) -> T {\n     }\n }\n \n-pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n+pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     /*!\n      * Gets an immutable reference to the value inside an option.\n      *\n@@ -49,7 +49,7 @@ pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n-pure fn expect<T: Copy>(opt: &Option<T>, +reason: ~str) -> T {\n+pub pure fn expect<T: Copy>(opt: &Option<T>, +reason: ~str) -> T {\n     /*!\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -61,21 +61,23 @@ pure fn expect<T: Copy>(opt: &Option<T>, +reason: ~str) -> T {\n     match *opt { Some(copy x) => x, None => fail reason }\n }\n \n-pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n+pub pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n-pure fn map_consume<T, U>(+opt: Option<T>, f: fn(+v: T) -> U) -> Option<U> {\n+pub pure fn map_consume<T, U>(+opt: Option<T>,\n+                              f: fn(+v: T) -> U) -> Option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n      */\n     if opt.is_some() { Some(f(option::unwrap(move opt))) } else { None }\n }\n \n-pure fn chain<T, U>(+opt: Option<T>, f: fn(+t: T) -> Option<U>) -> Option<U> {\n+pub pure fn chain<T, U>(+opt: Option<T>,\n+                        f: fn(+t: T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n@@ -89,8 +91,8 @@ pure fn chain<T, U>(+opt: Option<T>, f: fn(+t: T) -> Option<U>) -> Option<U> {\n     }\n }\n \n-pure fn chain_ref<T, U>(opt: &Option<T>,\n-                        f: fn(x: &T) -> Option<U>) -> Option<U> {\n+pub pure fn chain_ref<T, U>(opt: &Option<T>,\n+                            f: fn(x: &T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n@@ -99,7 +101,7 @@ pure fn chain_ref<T, U>(opt: &Option<T>,\n     match *opt { Some(ref x) => f(x), None => None }\n }\n \n-pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n+pub pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost some() value, or none if both are none.\n      */\n@@ -110,7 +112,7 @@ pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n }\n \n #[inline(always)]\n-pure fn while_some<T>(+x: Option<T>, blk: fn(+v: T) -> Option<T>) {\n+pub pure fn while_some<T>(+x: Option<T>, blk: fn(+v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n     let mut opt <- x;\n@@ -119,40 +121,40 @@ pure fn while_some<T>(+x: Option<T>, blk: fn(+v: T) -> Option<T>) {\n     }\n }\n \n-pure fn is_none<T>(opt: &Option<T>) -> bool {\n+pub pure fn is_none<T>(opt: &Option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n     match *opt { None => true, Some(_) => false }\n }\n \n-pure fn is_some<T>(opt: &Option<T>) -> bool {\n+pub pure fn is_some<T>(opt: &Option<T>) -> bool {\n     //! Returns true if the option contains some value\n \n     !is_none(opt)\n }\n \n-pure fn get_default<T: Copy>(opt: &Option<T>, +def: T) -> T {\n+pub pure fn get_default<T: Copy>(opt: &Option<T>, +def: T) -> T {\n     //! Returns the contained value or a default\n \n     match *opt { Some(copy x) => x, None => def }\n }\n \n-pure fn map_default<T, U>(opt: &Option<T>, +def: U,\n+pub pure fn map_default<T, U>(opt: &Option<T>, +def: U,\n                               f: fn(x: &T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => move def, Some(ref t) => f(t) }\n }\n \n-pure fn iter<T>(opt: &Option<T>, f: fn(x: &T)) {\n+pub pure fn iter<T>(opt: &Option<T>, f: fn(x: &T)) {\n     //! Performs an operation on the contained value by reference\n     match *opt { None => (), Some(ref t) => f(t) }\n }\n \n // tjc: shouldn't this be - instead of +?\n // then could get rid of some superfluous moves\n #[inline(always)]\n-pure fn unwrap<T>(+opt: Option<T>) -> T {\n+pub pure fn unwrap<T>(+opt: Option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it.\n      *\n@@ -167,12 +169,12 @@ pure fn unwrap<T>(+opt: Option<T>) -> T {\n \n /// The ubiquitous option dance.\n #[inline(always)]\n-fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n+pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n     if opt.is_none() { fail ~\"option::swap_unwrap none\" }\n     unwrap(util::replace(opt, None))\n }\n \n-pure fn unwrap_expect<T>(+opt: Option<T>, reason: &str) -> T {\n+pub pure fn unwrap_expect<T>(+opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n     unwrap(move opt)"}]}