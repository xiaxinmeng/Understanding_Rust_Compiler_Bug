{"sha": "2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZmNjYmU0NzcyN2Q5ZDI3ODdmNzZlZmQ2N2Y1YjVkOWZmMWQ1NWE=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-03-23T05:42:32Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-03-23T06:28:25Z"}, "message": "implement fill match arm assist for tuple of enums", "tree": {"sha": "01cd96ea1bbcd492df1082907a1106b89aab7eaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01cd96ea1bbcd492df1082907a1106b89aab7eaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "html_url": "https://github.com/rust-lang/rust/commit/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baa11d52f45fed76a65863c64938e43443bb9bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/baa11d52f45fed76a65863c64938e43443bb9bb8", "html_url": "https://github.com/rust-lang/rust/commit/baa11d52f45fed76a65863c64938e43443bb9bb8"}], "stats": {"total": 174, "additions": 160, "deletions": 14}, "files": [{"sha": "eb5247b6974e205eb51ead78a5b5a5a80800698e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "patch": "@@ -876,6 +876,7 @@ name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n  \"format-buf\",\n+ \"itertools\",\n  \"join_to_string\",\n  \"ra_db\",\n  \"ra_fmt\","}, {"sha": "85adddb5bb57217e0f97669dae0234f303816ea0", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "patch": "@@ -11,6 +11,7 @@ doctest = false\n format-buf = \"1.0.0\"\n join_to_string = \"0.1.3\"\n rustc-hash = \"1.1.0\"\n+itertools = \"0.8.2\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "d207c3307a6977360fcce561e6f2f3d8e675a8e8", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 149, "deletions": 14, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "patch": "@@ -2,6 +2,8 @@\n \n use std::iter;\n \n+use itertools::Itertools;\n+\n use hir::{Adt, HasSource, Semantics};\n use ra_ide_db::RootDatabase;\n \n@@ -39,13 +41,6 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     let match_arm_list = match_expr.match_arm_list()?;\n \n     let expr = match_expr.expr()?;\n-    let enum_def = resolve_enum_def(&ctx.sema, &expr)?;\n-    let module = ctx.sema.scope(expr.syntax()).module()?;\n-\n-    let variants = enum_def.variants(ctx.db);\n-    if variants.is_empty() {\n-        return None;\n-    }\n \n     let mut arms: Vec<MatchArm> = match_arm_list.arms().collect();\n     if arms.len() == 1 {\n@@ -54,13 +49,40 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         }\n     }\n \n-    let db = ctx.db;\n-    let missing_arms: Vec<MatchArm> = variants\n-        .into_iter()\n-        .filter_map(|variant| build_pat(db, module, variant))\n-        .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n-        .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n-        .collect();\n+    let module = ctx.sema.scope(expr.syntax()).module()?;\n+\n+    let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n+        let variants = enum_def.variants(ctx.db);\n+\n+        variants\n+            .into_iter()\n+            .filter_map(|variant| build_pat(ctx.db, module, variant))\n+            .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+            .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n+            .collect()\n+    } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n+        // partial fill not currently supported for tuple of enums\n+        if !arms.is_empty() {\n+            return None;\n+        }\n+\n+        enum_defs\n+            .into_iter()\n+            .map(|enum_def| enum_def.variants(ctx.db))\n+            .multi_cartesian_product()\n+            .map(|variants| {\n+                let patterns = variants\n+                    .into_iter()\n+                    .filter_map(|variant| build_pat(ctx.db, module, variant))\n+                    .collect::<Vec<_>>();\n+                ast::Pat::from(make::tuple_pat(patterns))\n+            })\n+            .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+            .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n+            .collect()\n+    } else {\n+        return None;\n+    };\n \n     if missing_arms.is_empty() {\n         return None;\n@@ -104,6 +126,22 @@ fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<\n     })\n }\n \n+fn resolve_tuple_of_enum_def(\n+    sema: &Semantics<RootDatabase>,\n+    expr: &ast::Expr,\n+) -> Option<Vec<hir::Enum>> {\n+    Some(\n+        sema.type_of_expr(&expr)?\n+            .tuple_fields(sema.db)\n+            .iter()\n+            .map(|ty| match ty.as_adt() {\n+                Some(Adt::Enum(e)) => e,\n+                _ => panic!(\"handle the case of tuple containing non-enum\"),\n+            })\n+            .collect(),\n+    )\n+}\n+\n fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::EnumVariant) -> Option<ast::Pat> {\n     let path = crate::ast_transform::path_to_ast(module.find_use_path(db, var.into())?);\n \n@@ -307,6 +345,103 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn fill_match_arms_tuple_of_enum() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (a<|>, b) {}\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match <|>(a, b) {\n+                    (A::One, B::One) => (),\n+                    (A::One, B::Two) => (),\n+                    (A::Two, B::One) => (),\n+                    (A::Two, B::Two) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_tuple_of_enum_partial() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (a<|>, b) {\n+                    (A::Two, B::One) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_tuple_of_enum_not_applicable() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                One,\n+                Two,\n+            }\n+            enum B {\n+                One,\n+                Two,\n+            }\n+\n+            fn main() {\n+                let a = A::One;\n+                let b = B::One;\n+                match (a<|>, b) {\n+                    (A::Two, B::One) => (),\n+                    (A::One, B::One) => (),\n+                    (A::One, B::Two) => (),\n+                    (A::Two, B::Two) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_fill_match_arm_refs() {\n         check_assist("}, {"sha": "9d8ed6238c3c900a0e0eb17e933851a0307fb81f", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2afccbe47727d9d2787f76efd67f5b5d9ff1d55a/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=2afccbe47727d9d2787f76efd67f5b5d9ff1d55a", "patch": "@@ -136,6 +136,15 @@ pub fn placeholder_pat() -> ast::PlaceholderPat {\n     }\n }\n \n+pub fn tuple_pat(pats: impl IntoIterator<Item = ast::Pat>) -> ast::TuplePat {\n+    let pats_str = pats.into_iter().map(|p| p.syntax().to_string()).join(\", \");\n+    return from_text(&format!(\"({})\", pats_str));\n+\n+    fn from_text(text: &str) -> ast::TuplePat {\n+        ast_from_text(&format!(\"fn f({}: ())\", text))\n+    }\n+}\n+\n pub fn tuple_struct_pat(\n     path: ast::Path,\n     pats: impl IntoIterator<Item = ast::Pat>,"}]}