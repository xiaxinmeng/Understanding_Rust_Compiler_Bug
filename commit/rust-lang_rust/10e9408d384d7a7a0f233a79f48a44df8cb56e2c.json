{"sha": "10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZTk0MDhkMzg0ZDdhN2EwZjIzM2E3OWY0OGE0NGRmOGNiNTZlMmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-28T20:38:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-28T20:38:58Z"}, "message": "Merge #10066\n\n10066: internal: improve compile times a bit r=matklad a=matklad\n\nI wanted to *quickly* remove `smol_str = {features = \"serde\"}`, and figured out that the simplest way to do that is to replace our straightforward proc macro serialization with something significantly more obscure. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "fdaf0356b6cd357ec68e82c50c6c0b11a796deb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdaf0356b6cd357ec68e82c50c6c0b11a796deb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhKp7iCRBK7hj4Ov3rIwAAEtYIAEo/M65eLfGsnGosfSpQD75o\nlO68YwMqrDma3tABgIzfJwP1n47gUtgEidLGccxwM1fVZpilAQG5C0AzB4BIO1/E\nxnHr8ZYkWAEjSacw6ETSvS1Gsh3VCRd5E3113MX0TfocvjD24FXxHD/f6abh8yuL\nLlcbOoXaYuRl7p0k5SmIsiVh/5XOb2bY+OhzgIa66IJ89HtFSSXyQDi7KYcjLY9R\n9MF54h2RGoJadJ8wTNNlzB1zCoc1d7ImO3cDoHS3LlqnRl0P/wpGd02fGbb97Y0W\n7Qp9UO9FxxpOBXF4JccvrgTwVHIHMkwSTLp2uMuJCS0fjj5XoACH92bgjiaAOYA=\n=jVRb\n-----END PGP SIGNATURE-----\n", "payload": "tree fdaf0356b6cd357ec68e82c50c6c0b11a796deb7\nparent 2e3322d3f536e619ec67d05846c1b1bac8b36721\nparent 0d5c671d768d3e03fb425499d3a864d6e535f612\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1630183138 +0000\ncommitter GitHub <noreply@github.com> 1630183138 +0000\n\nMerge #10066\n\n10066: internal: improve compile times a bit r=matklad a=matklad\n\nI wanted to *quickly* remove `smol_str = {features = \"serde\"}`, and figured out that the simplest way to do that is to replace our straightforward proc macro serialization with something significantly more obscure. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "html_url": "https://github.com/rust-lang/rust/commit/10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e3322d3f536e619ec67d05846c1b1bac8b36721", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e3322d3f536e619ec67d05846c1b1bac8b36721", "html_url": "https://github.com/rust-lang/rust/commit/2e3322d3f536e619ec67d05846c1b1bac8b36721"}, {"sha": "0d5c671d768d3e03fb425499d3a864d6e535f612", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d5c671d768d3e03fb425499d3a864d6e535f612", "html_url": "https://github.com/rust-lang/rust/commit/0d5c671d768d3e03fb425499d3a864d6e535f612"}], "stats": {"total": 636, "additions": 379, "deletions": 257}, "files": [{"sha": "1d4ad302985ff3e2310433a3e0e0a4ade7bf4cae", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -1064,9 +1064,6 @@ checksum = \"acbf547ad0c65e31259204bd90935776d1c693cec2f4ff7abb7a1bbbd40dfe58\"\n [[package]]\n name = \"paths\"\n version = \"0.0.0\"\n-dependencies = [\n- \"serde\",\n-]\n \n [[package]]\n name = \"percent-encoding\"\n@@ -1505,9 +1502,6 @@ name = \"smol_str\"\n version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b203e79e90905594272c1c97c7af701533d42adaab0beb3859018e477d54a3b0\"\n-dependencies = [\n- \"serde\",\n-]\n \n [[package]]\n name = \"snap\"\n@@ -1574,7 +1568,6 @@ dependencies = [\n  \"rowan\",\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-hash\",\n- \"serde\",\n  \"smol_str\",\n  \"sourcegen\",\n  \"stdx\","}, {"sha": "cc062ebb7cbe525454a20b1c27fc4ee5ba486bc8", "filename": "crates/paths/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fpaths%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fpaths%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2FCargo.toml?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -9,4 +9,7 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n-serde = \"1\"\n+# Adding this dep sadly puts a lot of rust-analyzer crates after the\n+# serde-derive crate. Even though we don't activate the derive feature here,\n+# someone else in the crate graph certainly does!\n+# serde = \"1\""}, {"sha": "90909f4e8eaa3f7e1e7b35829f021acbb2781715", "filename": "crates/paths/src/lib.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fpaths%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fpaths%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2Fsrc%2Flib.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -66,27 +66,6 @@ impl PartialEq<AbsPath> for AbsPathBuf {\n     }\n }\n \n-impl serde::Serialize for AbsPathBuf {\n-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: serde::Serializer,\n-    {\n-        self.0.serialize(serializer)\n-    }\n-}\n-\n-impl<'de> serde::Deserialize<'de> for AbsPathBuf {\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: serde::Deserializer<'de>,\n-    {\n-        let path = PathBuf::deserialize(deserializer)?;\n-        AbsPathBuf::try_from(path).map_err(|path| {\n-            serde::de::Error::custom(format!(\"expected absolute path, got {}\", path.display()))\n-        })\n-    }\n-}\n-\n impl AbsPathBuf {\n     /// Wrap the given absolute path in `AbsPathBuf`\n     ///"}, {"sha": "04a4d7ca5872c84b1ac3a469f4884b4ec1d5982e", "filename": "crates/proc_macro_api/src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Flib.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -21,7 +21,9 @@ use tt::{SmolStr, Subtree};\n \n use crate::process::ProcMacroProcessSrv;\n \n-pub use rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind};\n+pub use rpc::{\n+    flat::FlatTree, ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind,\n+};\n pub use version::{read_dylib_info, RustCInfo};\n \n #[derive(Debug, Clone)]\n@@ -58,10 +60,10 @@ impl ProcMacroProcessExpander {\n         env: Vec<(String, String)>,\n     ) -> Result<Subtree, tt::ExpansionError> {\n         let task = ExpansionTask {\n-            macro_body: subtree.clone(),\n+            macro_body: FlatTree::new(subtree),\n             macro_name: self.name.to_string(),\n-            attributes: attr.cloned(),\n-            lib: self.dylib_path.to_path_buf(),\n+            attributes: attr.map(FlatTree::new),\n+            lib: self.dylib_path.to_path_buf().into(),\n             env,\n         };\n \n@@ -70,7 +72,7 @@ impl ProcMacroProcessExpander {\n             .lock()\n             .unwrap_or_else(|e| e.into_inner())\n             .send_task(msg::Request::ExpansionMacro(task))?;\n-        Ok(result.expansion)\n+        Ok(result.expansion.to_subtree())\n     }\n }\n "}, {"sha": "fd10d87f08c86546989580107a4b09ad3afcc6f0", "filename": "crates/proc_macro_api/src/msg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -12,13 +12,13 @@ use crate::{\n     ExpansionResult, ExpansionTask,\n };\n \n-#[derive(Debug, Serialize, Deserialize, Clone)]\n+#[derive(Debug, Serialize, Deserialize)]\n pub enum Request {\n     ListMacro(ListMacrosTask),\n     ExpansionMacro(ExpansionTask),\n }\n \n-#[derive(Debug, Serialize, Deserialize, Clone)]\n+#[derive(Debug, Serialize, Deserialize)]\n pub enum Response {\n     Error(ResponseError),\n     ListMacro(ListMacrosResult),"}, {"sha": "79c749d55ad89c9d1cdb14e70aa7516141b49aed", "filename": "crates/proc_macro_api/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -39,7 +39,7 @@ impl ProcMacroProcessSrv {\n         &mut self,\n         dylib_path: &AbsPath,\n     ) -> Result<Vec<(String, ProcMacroKind)>, tt::ExpansionError> {\n-        let task = ListMacrosTask { lib: dylib_path.to_path_buf() };\n+        let task = ListMacrosTask { lib: dylib_path.to_path_buf().into() };\n \n         let result: ListMacrosResult = self.send_task(Request::ListMacro(task))?;\n         Ok(result.macros)"}, {"sha": "9fdbf04576508ea99486d8422f02880a3fdb4866", "filename": "crates/proc_macro_api/src/rpc.rs", "status": "modified", "additions": 26, "deletions": 208, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -5,17 +5,17 @@\n //! Although adding `Serialize` and `Deserialize` traits to `tt` directly seems\n //! to be much easier, we deliberately duplicate `tt` structs with `#[serde(with = \"XXDef\")]`\n //! for separation of code responsibility.\n+pub(crate) mod flat;\n+\n+use std::path::PathBuf;\n \n-use paths::AbsPathBuf;\n use serde::{Deserialize, Serialize};\n-use tt::{\n-    Delimiter, DelimiterKind, Ident, Leaf, Literal, Punct, SmolStr, Spacing, Subtree, TokenId,\n-    TokenTree,\n-};\n+\n+use crate::rpc::flat::FlatTree;\n \n #[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n pub struct ListMacrosTask {\n-    pub lib: AbsPathBuf,\n+    pub lib: PathBuf,\n }\n \n #[derive(Copy, Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n@@ -30,14 +30,13 @@ pub struct ListMacrosResult {\n     pub macros: Vec<(String, ProcMacroKind)>,\n }\n \n-#[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n+#[derive(Debug, Serialize, Deserialize)]\n pub struct ExpansionTask {\n     /// Argument of macro call.\n     ///\n     /// In custom derive this will be a struct or enum; in attribute-like macro - underlying\n     /// item; in function-like macro - the macro body.\n-    #[serde(with = \"SubtreeDef\")]\n-    pub macro_body: Subtree,\n+    pub macro_body: FlatTree,\n \n     /// Name of macro to expand.\n     ///\n@@ -46,208 +45,23 @@ pub struct ExpansionTask {\n     pub macro_name: String,\n \n     /// Possible attributes for the attribute-like macros.\n-    #[serde(with = \"opt_subtree_def\")]\n-    pub attributes: Option<Subtree>,\n+    pub attributes: Option<FlatTree>,\n \n-    pub lib: AbsPathBuf,\n+    pub lib: PathBuf,\n \n     /// Environment variables to set during macro expansion.\n     pub env: Vec<(String, String)>,\n }\n \n-#[derive(Clone, Eq, PartialEq, Debug, Default, Serialize, Deserialize)]\n+#[derive(Debug, Serialize, Deserialize)]\n pub struct ExpansionResult {\n-    #[serde(with = \"SubtreeDef\")]\n-    pub expansion: Subtree,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"DelimiterKind\")]\n-enum DelimiterKindDef {\n-    Parenthesis,\n-    Brace,\n-    Bracket,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"TokenId\")]\n-struct TokenIdDef(u32);\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Delimiter\")]\n-struct DelimiterDef {\n-    #[serde(\n-        with = \"TokenIdDef\",\n-        default = \"tt::TokenId::unspecified\",\n-        skip_serializing_if = \"token_id_def::skip_if\"\n-    )]\n-    id: TokenId,\n-    #[serde(with = \"DelimiterKindDef\")]\n-    kind: DelimiterKind,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Subtree\")]\n-struct SubtreeDef {\n-    #[serde(default, with = \"opt_delimiter_def\")]\n-    delimiter: Option<Delimiter>,\n-    #[serde(with = \"vec_token_tree\")]\n-    token_trees: Vec<TokenTree>,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"TokenTree\")]\n-enum TokenTreeDef {\n-    #[serde(with = \"LeafDef\")]\n-    Leaf(Leaf),\n-    #[serde(with = \"SubtreeDef\")]\n-    Subtree(Subtree),\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Leaf\")]\n-enum LeafDef {\n-    #[serde(with = \"LiteralDef\")]\n-    Literal(Literal),\n-    #[serde(with = \"PunctDef\")]\n-    Punct(Punct),\n-    #[serde(with = \"IdentDef\")]\n-    Ident(Ident),\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Literal\")]\n-struct LiteralDef {\n-    text: SmolStr,\n-    #[serde(\n-        with = \"TokenIdDef\",\n-        default = \"tt::TokenId::unspecified\",\n-        skip_serializing_if = \"token_id_def::skip_if\"\n-    )]\n-    id: TokenId,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Punct\")]\n-struct PunctDef {\n-    char: char,\n-    #[serde(with = \"SpacingDef\")]\n-    spacing: Spacing,\n-    #[serde(\n-        with = \"TokenIdDef\",\n-        default = \"tt::TokenId::unspecified\",\n-        skip_serializing_if = \"token_id_def::skip_if\"\n-    )]\n-    id: TokenId,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Spacing\")]\n-enum SpacingDef {\n-    Alone,\n-    Joint,\n-}\n-\n-#[derive(Serialize, Deserialize)]\n-#[serde(remote = \"Ident\")]\n-struct IdentDef {\n-    text: SmolStr,\n-    #[serde(\n-        with = \"TokenIdDef\",\n-        default = \"tt::TokenId::unspecified\",\n-        skip_serializing_if = \"token_id_def::skip_if\"\n-    )]\n-    id: TokenId,\n-}\n-\n-mod token_id_def {\n-    pub(super) fn skip_if(value: &tt::TokenId) -> bool {\n-        *value == tt::TokenId::unspecified()\n-    }\n-}\n-\n-mod opt_delimiter_def {\n-    use super::{Delimiter, DelimiterDef};\n-    use serde::{Deserialize, Deserializer, Serialize, Serializer};\n-\n-    pub(super) fn serialize<S>(value: &Option<Delimiter>, serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: Serializer,\n-    {\n-        #[derive(Serialize)]\n-        struct Helper<'a>(#[serde(with = \"DelimiterDef\")] &'a Delimiter);\n-        value.as_ref().map(Helper).serialize(serializer)\n-    }\n-\n-    pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Option<Delimiter>, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        #[derive(Deserialize)]\n-        struct Helper(#[serde(with = \"DelimiterDef\")] Delimiter);\n-        let helper = Option::deserialize(deserializer)?;\n-        Ok(helper.map(|Helper(external)| external))\n-    }\n-}\n-\n-mod opt_subtree_def {\n-    use super::{Subtree, SubtreeDef};\n-    use serde::{Deserialize, Deserializer, Serialize, Serializer};\n-\n-    pub(super) fn serialize<S>(value: &Option<Subtree>, serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: Serializer,\n-    {\n-        #[derive(Serialize)]\n-        struct Helper<'a>(#[serde(with = \"SubtreeDef\")] &'a Subtree);\n-        value.as_ref().map(Helper).serialize(serializer)\n-    }\n-\n-    pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Option<Subtree>, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        #[derive(Deserialize)]\n-        struct Helper(#[serde(with = \"SubtreeDef\")] Subtree);\n-        let helper = Option::deserialize(deserializer)?;\n-        Ok(helper.map(|Helper(external)| external))\n-    }\n-}\n-\n-mod vec_token_tree {\n-    use super::{TokenTree, TokenTreeDef};\n-    use serde::{ser::SerializeSeq, Deserialize, Deserializer, Serialize, Serializer};\n-\n-    pub(super) fn serialize<S>(value: &[TokenTree], serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: Serializer,\n-    {\n-        #[derive(Serialize)]\n-        struct Helper<'a>(#[serde(with = \"TokenTreeDef\")] &'a TokenTree);\n-\n-        let items: Vec<_> = value.iter().map(Helper).collect();\n-        let mut seq = serializer.serialize_seq(Some(items.len()))?;\n-        for element in items {\n-            seq.serialize_element(&element)?;\n-        }\n-        seq.end()\n-    }\n-\n-    pub(super) fn deserialize<'de, D>(deserializer: D) -> Result<Vec<TokenTree>, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        #[derive(Deserialize)]\n-        struct Helper(#[serde(with = \"TokenTreeDef\")] TokenTree);\n-\n-        let helper = Vec::deserialize(deserializer)?;\n-        Ok(helper.into_iter().map(|Helper(external)| external).collect())\n-    }\n+    pub expansion: FlatTree,\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use tt::*;\n \n     fn fixture_token_tree() -> Subtree {\n         let mut subtree = Subtree::default();\n@@ -257,6 +71,15 @@ mod tests {\n         subtree\n             .token_trees\n             .push(TokenTree::Leaf(Ident { text: \"Foo\".into(), id: TokenId(1) }.into()));\n+        subtree.token_trees.push(TokenTree::Leaf(Leaf::Literal(Literal {\n+            text: \"Foo\".into(),\n+            id: TokenId::unspecified(),\n+        })));\n+        subtree.token_trees.push(TokenTree::Leaf(Leaf::Punct(Punct {\n+            char: '@',\n+            id: TokenId::unspecified(),\n+            spacing: Spacing::Joint,\n+        })));\n         subtree.token_trees.push(TokenTree::Subtree(Subtree {\n             delimiter: Some(Delimiter { id: TokenId(2), kind: DelimiterKind::Brace }),\n             token_trees: vec![],\n@@ -268,22 +91,17 @@ mod tests {\n     fn test_proc_macro_rpc_works() {\n         let tt = fixture_token_tree();\n         let task = ExpansionTask {\n-            macro_body: tt.clone(),\n+            macro_body: FlatTree::new(&tt),\n             macro_name: Default::default(),\n             attributes: None,\n-            lib: AbsPathBuf::assert(std::env::current_dir().unwrap()),\n+            lib: std::env::current_dir().unwrap(),\n             env: Default::default(),\n         };\n \n         let json = serde_json::to_string(&task).unwrap();\n+        println!(\"{}\", json);\n         let back: ExpansionTask = serde_json::from_str(&json).unwrap();\n \n-        assert_eq!(task.macro_body, back.macro_body);\n-\n-        let result = ExpansionResult { expansion: tt };\n-        let json = serde_json::to_string(&result).unwrap();\n-        let back: ExpansionResult = serde_json::from_str(&json).unwrap();\n-\n-        assert_eq!(result, back);\n+        assert_eq!(tt, back.macro_body.to_subtree());\n     }\n }"}, {"sha": "d427fa87d23a8a1f088efaceb3039dcd52900f0f", "filename": "crates/proc_macro_api/src/rpc/flat.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Frpc%2Fflat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_api%2Fsrc%2Frpc%2Fflat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Frpc%2Fflat.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -0,0 +1,328 @@\n+//! Serialization-friendly representation of `tt::Subtree`.\n+//!\n+//! It is possible to serialize `Subtree` as is, as a tree, but using\n+//! arbitrary-nested trees in JSON is problematic, as they can cause the JSON\n+//! parser to overflow the stack.\n+//!\n+//! Additionally, such implementation would be pretty verbose, and we do care\n+//! about performance here a bit.\n+//!\n+//! So what this module does is dumping a `tt::Subtree` into a bunch of flat\n+//! array of numbers. See the test in the parent module to get an example\n+//! output.\n+//!\n+//! ```json\n+//!  {\n+//!    // Array of subtrees, each subtree is represented by 4 numbers:\n+//!    // id of delimiter, delimiter kind, index of first child in `token_tree`,\n+//!    // index of last child in `token_tree`\n+//!    \"subtree\":[4294967295,0,0,5,2,2,5,5],\n+//!    // 2 ints per literal: [token id, index into `text`]\n+//!    \"literal\":[4294967295,1],\n+//!    // 3 ints per punct: [token id, char, spacing]\n+//!    \"punct\":[4294967295,64,1],\n+//!    // 2 ints per ident: [token id, index into `text`]\n+//!    \"ident\":   [0,0,1,1],\n+//!    // children of all subtrees, concatenated. Each child is represented as `index << 2 | tag`\n+//!    // where tag denotes one of subtree, literal, punct or ident.\n+//!    \"token_tree\":[3,7,1,4],\n+//!    // Strings shared by idents and literals\n+//!    \"text\": [\"struct\",\"Foo\"]\n+//!  }\n+//! ```\n+//!\n+//! We probably should replace most of the code here with bincode someday, but,\n+//! as we don't have bincode in Cargo.toml yet, lets stick with serde_json for\n+//! the time being.\n+\n+use std::{\n+    collections::{HashMap, VecDeque},\n+    convert::TryInto,\n+};\n+\n+use serde::{Deserialize, Serialize};\n+use tt::TokenId;\n+\n+#[derive(Serialize, Deserialize, Debug)]\n+pub struct FlatTree {\n+    subtree: Vec<u32>,\n+    literal: Vec<u32>,\n+    punct: Vec<u32>,\n+    ident: Vec<u32>,\n+    token_tree: Vec<u32>,\n+    text: Vec<String>,\n+}\n+\n+struct SubtreeRepr {\n+    id: tt::TokenId,\n+    kind: Option<tt::DelimiterKind>,\n+    tt: [u32; 2],\n+}\n+\n+struct LiteralRepr {\n+    id: tt::TokenId,\n+    text: u32,\n+}\n+\n+struct PunctRepr {\n+    id: tt::TokenId,\n+    char: char,\n+    spacing: tt::Spacing,\n+}\n+\n+struct IdentRepr {\n+    id: tt::TokenId,\n+    text: u32,\n+}\n+\n+impl FlatTree {\n+    pub fn new(subtree: &tt::Subtree) -> FlatTree {\n+        let mut w = Writer {\n+            string_table: HashMap::new(),\n+            work: VecDeque::new(),\n+\n+            subtree: Vec::new(),\n+            literal: Vec::new(),\n+            punct: Vec::new(),\n+            ident: Vec::new(),\n+            token_tree: Vec::new(),\n+            text: Vec::new(),\n+        };\n+        w.write(subtree);\n+\n+        return FlatTree {\n+            subtree: write_vec(w.subtree, SubtreeRepr::write),\n+            literal: write_vec(w.literal, LiteralRepr::write),\n+            punct: write_vec(w.punct, PunctRepr::write),\n+            ident: write_vec(w.ident, IdentRepr::write),\n+            token_tree: w.token_tree,\n+            text: w.text,\n+        };\n+\n+        fn write_vec<T, F: Fn(T) -> [u32; N], const N: usize>(xs: Vec<T>, f: F) -> Vec<u32> {\n+            xs.into_iter().flat_map(f).collect()\n+        }\n+    }\n+\n+    pub fn to_subtree(self) -> tt::Subtree {\n+        return Reader {\n+            subtree: read_vec(self.subtree, SubtreeRepr::read),\n+            literal: read_vec(self.literal, LiteralRepr::read),\n+            punct: read_vec(self.punct, PunctRepr::read),\n+            ident: read_vec(self.ident, IdentRepr::read),\n+            token_tree: self.token_tree,\n+            text: self.text,\n+        }\n+        .read();\n+\n+        fn read_vec<T, F: Fn([u32; N]) -> T, const N: usize>(xs: Vec<u32>, f: F) -> Vec<T> {\n+            let mut chunks = xs.chunks_exact(N);\n+            let res = chunks.by_ref().map(|chunk| f(chunk.try_into().unwrap())).collect();\n+            assert!(chunks.remainder().is_empty());\n+            res\n+        }\n+    }\n+}\n+\n+impl SubtreeRepr {\n+    fn write(self) -> [u32; 4] {\n+        let kind = match self.kind {\n+            None => 0,\n+            Some(tt::DelimiterKind::Parenthesis) => 1,\n+            Some(tt::DelimiterKind::Brace) => 2,\n+            Some(tt::DelimiterKind::Bracket) => 3,\n+        };\n+        [self.id.0, kind, self.tt[0], self.tt[1]]\n+    }\n+    fn read([id, kind, lo, len]: [u32; 4]) -> SubtreeRepr {\n+        let kind = match kind {\n+            0 => None,\n+            1 => Some(tt::DelimiterKind::Parenthesis),\n+            2 => Some(tt::DelimiterKind::Brace),\n+            3 => Some(tt::DelimiterKind::Bracket),\n+            other => panic!(\"bad kind {}\", other),\n+        };\n+        SubtreeRepr { id: TokenId(id), kind, tt: [lo, len] }\n+    }\n+}\n+\n+impl LiteralRepr {\n+    fn write(self) -> [u32; 2] {\n+        [self.id.0, self.text]\n+    }\n+    fn read([id, text]: [u32; 2]) -> LiteralRepr {\n+        LiteralRepr { id: TokenId(id), text }\n+    }\n+}\n+\n+impl PunctRepr {\n+    fn write(self) -> [u32; 3] {\n+        let spacing = match self.spacing {\n+            tt::Spacing::Alone => 0,\n+            tt::Spacing::Joint => 1,\n+        };\n+        [self.id.0, self.char as u32, spacing]\n+    }\n+    fn read([id, char, spacing]: [u32; 3]) -> PunctRepr {\n+        let spacing = match spacing {\n+            0 => tt::Spacing::Alone,\n+            1 => tt::Spacing::Joint,\n+            other => panic!(\"bad spacing {}\", other),\n+        };\n+        PunctRepr { id: TokenId(id), char: char.try_into().unwrap(), spacing }\n+    }\n+}\n+\n+impl IdentRepr {\n+    fn write(self) -> [u32; 2] {\n+        [self.id.0, self.text]\n+    }\n+    fn read(data: [u32; 2]) -> IdentRepr {\n+        IdentRepr { id: TokenId(data[0]), text: data[1] }\n+    }\n+}\n+\n+struct Writer<'a> {\n+    work: VecDeque<(usize, &'a tt::Subtree)>,\n+    string_table: HashMap<&'a str, u32>,\n+\n+    subtree: Vec<SubtreeRepr>,\n+    literal: Vec<LiteralRepr>,\n+    punct: Vec<PunctRepr>,\n+    ident: Vec<IdentRepr>,\n+    token_tree: Vec<u32>,\n+    text: Vec<String>,\n+}\n+\n+impl<'a> Writer<'a> {\n+    fn write(&mut self, root: &'a tt::Subtree) {\n+        self.enqueue(root);\n+        while let Some((idx, subtree)) = self.work.pop_front() {\n+            self.subtree(idx, subtree);\n+        }\n+    }\n+\n+    fn subtree(&mut self, idx: usize, subtree: &'a tt::Subtree) {\n+        let mut first_tt = self.token_tree.len();\n+        let n_tt = subtree.token_trees.len();\n+        self.token_tree.resize(first_tt + n_tt, !0);\n+\n+        self.subtree[idx].tt = [first_tt as u32, (first_tt + n_tt) as u32];\n+\n+        for child in &subtree.token_trees {\n+            let idx_tag = match child {\n+                tt::TokenTree::Subtree(it) => {\n+                    let idx = self.enqueue(it);\n+                    idx << 2 | 0b00\n+                }\n+                tt::TokenTree::Leaf(leaf) => match leaf {\n+                    tt::Leaf::Literal(lit) => {\n+                        let idx = self.literal.len() as u32;\n+                        let text = self.intern(&lit.text);\n+                        self.literal.push(LiteralRepr { id: lit.id, text });\n+                        idx << 2 | 0b01\n+                    }\n+                    tt::Leaf::Punct(punct) => {\n+                        let idx = self.punct.len() as u32;\n+                        self.punct.push(PunctRepr {\n+                            char: punct.char,\n+                            spacing: punct.spacing,\n+                            id: punct.id,\n+                        });\n+                        idx << 2 | 0b10\n+                    }\n+                    tt::Leaf::Ident(ident) => {\n+                        let idx = self.ident.len() as u32;\n+                        let text = self.intern(&ident.text);\n+                        self.ident.push(IdentRepr { id: ident.id, text });\n+                        idx << 2 | 0b11\n+                    }\n+                },\n+            };\n+            self.token_tree[first_tt] = idx_tag;\n+            first_tt += 1;\n+        }\n+    }\n+\n+    fn enqueue(&mut self, subtree: &'a tt::Subtree) -> u32 {\n+        let idx = self.subtree.len();\n+        let delimiter_id = subtree.delimiter.map(|it| it.id).unwrap_or(TokenId::unspecified());\n+        let delimiter_kind = subtree.delimiter.map(|it| it.kind);\n+        self.subtree.push(SubtreeRepr { id: delimiter_id, kind: delimiter_kind, tt: [!0, !0] });\n+        self.work.push_back((idx, subtree));\n+        idx as u32\n+    }\n+\n+    pub(crate) fn intern(&mut self, text: &'a str) -> u32 {\n+        let table = &mut self.text;\n+        *self.string_table.entry(text).or_insert_with(|| {\n+            let idx = table.len();\n+            table.push(text.to_string());\n+            idx as u32\n+        })\n+    }\n+}\n+\n+struct Reader {\n+    subtree: Vec<SubtreeRepr>,\n+    literal: Vec<LiteralRepr>,\n+    punct: Vec<PunctRepr>,\n+    ident: Vec<IdentRepr>,\n+    token_tree: Vec<u32>,\n+    text: Vec<String>,\n+}\n+\n+impl Reader {\n+    pub(crate) fn read(self) -> tt::Subtree {\n+        let mut res: Vec<Option<tt::Subtree>> = vec![None; self.subtree.len()];\n+        for i in (0..self.subtree.len()).rev() {\n+            let repr = &self.subtree[i];\n+            let token_trees = &self.token_tree[repr.tt[0] as usize..repr.tt[1] as usize];\n+            let s = tt::Subtree {\n+                delimiter: repr.kind.map(|kind| tt::Delimiter { id: repr.id, kind }),\n+                token_trees: token_trees\n+                    .iter()\n+                    .copied()\n+                    .map(|idx_tag| {\n+                        let tag = idx_tag & 0b11;\n+                        let idx = (idx_tag >> 2) as usize;\n+                        match tag {\n+                            // XXX: we iterate subtrees in reverse to guarantee\n+                            // that this unwrap doesn't fire.\n+                            0b00 => res[idx].take().unwrap().into(),\n+                            0b01 => {\n+                                let repr = &self.literal[idx];\n+                                tt::Leaf::Literal(tt::Literal {\n+                                    text: self.text[repr.text as usize].as_str().into(),\n+                                    id: repr.id,\n+                                })\n+                                .into()\n+                            }\n+                            0b10 => {\n+                                let repr = &self.punct[idx];\n+                                tt::Leaf::Punct(tt::Punct {\n+                                    char: repr.char,\n+                                    spacing: repr.spacing,\n+                                    id: repr.id,\n+                                })\n+                                .into()\n+                            }\n+                            0b11 => {\n+                                let repr = &self.ident[idx];\n+                                tt::Leaf::Ident(tt::Ident {\n+                                    text: self.text[repr.text as usize].as_str().into(),\n+                                    id: repr.id,\n+                                })\n+                                .into()\n+                            }\n+                            other => panic!(\"bad tag: {}\", other),\n+                        }\n+                    })\n+                    .collect(),\n+            };\n+            res[i] = Some(s.into())\n+        }\n+\n+        res[0].take().unwrap()\n+    }\n+}"}, {"sha": "fe3665110db7366e2a115dfdd5e0c890da5b7d16", "filename": "crates/proc_macro_srv/src/cli.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -12,7 +12,7 @@ pub fn run() -> io::Result<()> {\n         let res = match req {\n             msg::Request::ListMacro(task) => srv.list_macros(&task).map(msg::Response::ListMacro),\n             msg::Request::ExpansionMacro(task) => {\n-                srv.expand(&task).map(msg::Response::ExpansionMacro)\n+                srv.expand(task).map(msg::Response::ExpansionMacro)\n             }\n         };\n "}, {"sha": "c60dd2efc53f1944043799524245513788fbe1a4", "filename": "crates/proc_macro_srv/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -15,7 +15,7 @@ mod dylib;\n \n mod abis;\n \n-use proc_macro_api::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n+use proc_macro_api::{ExpansionResult, ExpansionTask, FlatTree, ListMacrosResult, ListMacrosTask};\n use std::{\n     collections::{hash_map::Entry, HashMap},\n     env, fs,\n@@ -29,7 +29,7 @@ pub(crate) struct ProcMacroSrv {\n }\n \n impl ProcMacroSrv {\n-    pub fn expand(&mut self, task: &ExpansionTask) -> Result<ExpansionResult, String> {\n+    pub fn expand(&mut self, task: ExpansionTask) -> Result<ExpansionResult, String> {\n         let expander = self.expander(task.lib.as_ref())?;\n \n         let mut prev_env = HashMap::new();\n@@ -38,7 +38,11 @@ impl ProcMacroSrv {\n             env::set_var(k, v);\n         }\n \n-        let result = expander.expand(&task.macro_name, &task.macro_body, task.attributes.as_ref());\n+        let macro_body = task.macro_body.to_subtree();\n+        let attributes = task.attributes.map(|it| it.to_subtree());\n+        let result = expander\n+            .expand(&task.macro_name, &macro_body, attributes.as_ref())\n+            .map(|it| FlatTree::new(&it));\n \n         for (k, _) in &task.env {\n             match &prev_env[k.as_str()] {"}, {"sha": "e5520174488f27962ad4d1689ac28986e3b441ea", "filename": "crates/proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -3,7 +3,6 @@\n use crate::dylib;\n use crate::ProcMacroSrv;\n use expect_test::Expect;\n-use paths::AbsPathBuf;\n use proc_macro_api::ListMacrosTask;\n use std::str::FromStr;\n \n@@ -42,8 +41,7 @@ fn assert_expand_impl(macro_name: &str, input: &str, attr: Option<&str>, expect:\n }\n \n pub fn list() -> Vec<String> {\n-    let path = AbsPathBuf::assert(fixtures::proc_macro_test_dylib_path());\n-    let task = ListMacrosTask { lib: path };\n+    let task = ListMacrosTask { lib: fixtures::proc_macro_test_dylib_path() };\n     let mut srv = ProcMacroSrv::default();\n     let res = srv.list_macros(&task).unwrap();\n     res.macros.into_iter().map(|(name, kind)| format!(\"{} [{:?}]\", name, kind)).collect()"}, {"sha": "0b2134705b6e5da8f7cbaa136e79579f9bb2f94d", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -18,8 +18,7 @@ rustc-hash = \"1.1.0\"\n arrayvec = \"0.7\"\n once_cell = \"1.3.1\"\n indexmap = \"1.4.0\"\n-smol_str = { version = \"0.1.15\", features = [\"serde\"] }\n-serde = { version = \"1.0.106\", features = [\"derive\"] }\n+smol_str = \"0.1.15\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n text_edit = { path = \"../text_edit\", version = \"0.0.0\" }"}, {"sha": "e24a9998c71eaf963d49d85398f9868c659963d7", "filename": "crates/tt/Cargo.toml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Ftt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/10e9408d384d7a7a0f233a79f48a44df8cb56e2c/crates%2Ftt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2FCargo.toml?ref=10e9408d384d7a7a0f233a79f48a44df8cb56e2c", "patch": "@@ -9,8 +9,6 @@ edition = \"2018\"\n doctest = false\n \n [dependencies]\n-# ideally, `serde` should be enabled by `rust-analyzer`, but we enable it here\n-# to reduce number of compilations\n-smol_str = { version = \"0.1.15\", features = [\"serde\"] }\n+smol_str = \"0.1\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}]}