{"sha": "7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYWZmNTdmMjY4ZWZmNzljZDhlZDZhOGQ3ZmQ0OGQ0YjNmODE4Nzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-03T05:34:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-05T06:28:23Z"}, "message": "Improve name mangling for gdb\n\nRemove __extensions__ from method symbols as well as the meth_XXX. The XXX is\nnow used to append a few characters at the end of the name of the symbol.\n\nCloses #6602", "tree": {"sha": "d0784b2dcf15ac1ac75acd254b3872dbc835dc24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0784b2dcf15ac1ac75acd254b3872dbc835dc24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "html_url": "https://github.com/rust-lang/rust/commit/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36a4af49e0d66026e8ee7d156b2631208c4de2e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/36a4af49e0d66026e8ee7d156b2631208c4de2e5", "html_url": "https://github.com/rust-lang/rust/commit/36a4af49e0d66026e8ee7d156b2631208c4de2e5"}], "stats": {"total": 157, "additions": 99, "deletions": 58}, "files": [{"sha": "fe2d59a0ba7c4b24bd1e1df2582c2a94f4fc2805", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "patch": "@@ -663,8 +663,7 @@ pub fn truncated_hash_result(symbol_hasher: &mut hash::State) -> ~str {\n pub fn symbol_hash(tcx: ty::ctxt,\n                    symbol_hasher: &mut hash::State,\n                    t: ty::t,\n-                   link_meta: LinkMeta)\n-                   -> @str {\n+                   link_meta: LinkMeta) -> @str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -719,7 +718,7 @@ pub fn sanitize(s: &str) -> ~str {\n             'a' .. 'z'\n             | 'A' .. 'Z'\n             | '0' .. '9'\n-            | '_' => result.push_char(c),\n+            | '_' | '.' => result.push_char(c),\n \n             _ => {\n                 let mut tstr = ~\"\";\n@@ -740,22 +739,37 @@ pub fn sanitize(s: &str) -> ~str {\n     return result;\n }\n \n-pub fn mangle(sess: Session, ss: path) -> ~str {\n+pub fn mangle(sess: Session, ss: path,\n+              hash: Option<&str>, vers: Option<&str>) -> ~str {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n+    //\n+    // It turns out that on OSX you can actually have arbitrary symbols in\n+    // function names (at least when given to LLVM), but this is not possible\n+    // when using unix's linker. Perhaps one day when we just a linker from LLVM\n+    // we won't need to do this name mangling. The problem with name mangling is\n+    // that it seriously limits the available characters. For example we can't\n+    // have things like @T or ~[T] in symbol names when one would theoretically\n+    // want them for things like impls of traits on that type.\n+    //\n+    // To be able to work on all platforms and get *some* reasonable output, we\n+    // use C++ name-mangling.\n \n     let mut n = ~\"_ZN\"; // _Z == Begin name-sequence, N == nested\n \n+    let push = |s: &str| {\n+        let sani = sanitize(s);\n+        n.push_str(fmt!(\"%u%s\", sani.len(), sani));\n+    };\n+\n     // First, connect each component with <len, name> pairs.\n     for s in ss.iter() {\n         match *s {\n             path_name(s) | path_mod(s) | path_pretty_name(s, _) => {\n-                let sani = sanitize(sess.str_of(s));\n-                n.push_str(fmt!(\"%u%s\", sani.len(), sani));\n+                push(sess.str_of(s))\n             }\n         }\n     }\n-    n.push_char('E'); // End name-sequence.\n \n     // next, if any identifiers are \"pretty\" and need extra information tacked\n     // on, then use the hash to generate two unique characters. For now\n@@ -764,28 +778,43 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n         \"abcdefghijklmnopqrstuvwxyz\\\n          ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n          0123456789\";\n+    let mut hash = match hash { Some(s) => s.to_owned(), None => ~\"\" };\n     for s in ss.iter() {\n         match *s {\n             path_pretty_name(_, extra) => {\n                 let hi = (extra >> 32) as u32 as uint;\n                 let lo = extra as u32 as uint;\n-                n.push_char(EXTRA_CHARS[hi % EXTRA_CHARS.len()] as char);\n-                n.push_char(EXTRA_CHARS[lo % EXTRA_CHARS.len()] as char);\n+                hash.push_char(EXTRA_CHARS[hi % EXTRA_CHARS.len()] as char);\n+                hash.push_char(EXTRA_CHARS[lo % EXTRA_CHARS.len()] as char);\n             }\n             _ => {}\n         }\n     }\n+    if hash.len() > 0 {\n+        push(hash);\n+    }\n+    match vers {\n+        Some(s) => push(s),\n+        None => {}\n+    }\n+\n+    n.push_char('E'); // End name-sequence.\n     n\n }\n \n pub fn exported_name(sess: Session,\n                      path: path,\n                      hash: &str,\n                      vers: &str) -> ~str {\n-    mangle(sess,\n-           vec::append_one(\n-               vec::append_one(path, path_name(sess.ident_of(hash))),\n-               path_name(sess.ident_of(vers))))\n+    // The version will get mangled to have a leading '_', but it makes more\n+    // sense to lead with a 'v' b/c this is a version...\n+    let vers = if vers.len() > 0 && !char::is_XID_start(vers.char_at(0)) {\n+        \"v\" + vers\n+    } else {\n+        vers.to_owned()\n+    };\n+\n+    mangle(sess, path, Some(hash), Some(vers.as_slice()))\n }\n \n pub fn mangle_exported_name(ccx: &mut CrateContext,\n@@ -803,31 +832,33 @@ pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n-        ~[path_name(ccx.sess.ident_of(name)),\n-          path_name(ccx.sess.ident_of(s)),\n-          path_name(ccx.sess.ident_of(hash))]);\n+                  ~[path_name(ccx.sess.ident_of(name)),\n+                    path_name(ccx.sess.ident_of(s))],\n+                  Some(hash.as_slice()),\n+                  None);\n }\n \n pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n-                                         t: ty::t,\n-                                         name: &str) -> ~str {\n+                                            t: ty::t,\n+                                            name: &str) -> ~str {\n     let s = ppaux::ty_to_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n-        ~[path_name(ccx.sess.ident_of(s)),\n-          path_name(ccx.sess.ident_of(hash)),\n-          path_name(gensym_name(name))]);\n+                  ~[path_name(ccx.sess.ident_of(s)),\n+                    path_name(gensym_name(name))],\n+                  Some(hash.as_slice()),\n+                  None);\n }\n \n pub fn mangle_internal_name_by_path_and_seq(ccx: &mut CrateContext,\n                                             mut path: path,\n                                             flav: &str) -> ~str {\n     path.push(path_name(gensym_name(flav)));\n-    mangle(ccx.sess, path)\n+    mangle(ccx.sess, path, None, None)\n }\n \n pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str {\n-    mangle(ccx.sess, path)\n+    mangle(ccx.sess, path, None, None)\n }\n \n pub fn mangle_internal_name_by_seq(_ccx: &mut CrateContext, flav: &str) -> ~str {"}, {"sha": "16afc6f36caa271afe3fdfa62edb8d3bae7589ff", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "patch": "@@ -77,7 +77,7 @@ use std::local_data;\n use extra::time;\n use extra::sort;\n use syntax::ast::Ident;\n-use syntax::ast_map::{path, path_elt_to_str, path_name};\n+use syntax::ast_map::{path, path_elt_to_str, path_name, path_pretty_name};\n use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n@@ -2646,8 +2646,7 @@ pub fn register_method(ccx: @mut CrateContext,\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n     let mut path = (*path).clone();\n-    path.push(path_name(gensym_name(\"meth\")));\n-    path.push(path_name(m.ident));\n+    path.push(path_pretty_name(m.ident, token::gensym(\"meth\") as u64));\n \n     let sym = exported_name(ccx, path, mty, m.attrs);\n "}, {"sha": "1165ca0c68f21f8a1e2c005e9082ebeb3abb5542", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "patch": "@@ -16,20 +16,20 @@ use ast_util;\n use codemap::Span;\n use codemap;\n use diagnostic::span_handler;\n+use parse::token::get_ident_interner;\n use parse::token::ident_interner;\n use parse::token::special_idents;\n use print::pprust;\n use visit::{Visitor, fn_kind};\n use visit;\n \n-use std::hash;\n use std::hashmap::HashMap;\n use std::vec;\n \n #[deriving(Clone, Eq)]\n pub enum path_elt {\n     path_mod(Ident),\n-    path_name(Ident)\n+    path_name(Ident),\n \n     // A pretty name can come from an `impl` block. We attempt to select a\n     // reasonable name for debuggers to see, but to guarantee uniqueness with\n@@ -98,8 +98,8 @@ pub struct Ctx {\n }\n \n impl Ctx {\n-    fn extend(&self, elt: Ident) -> @path {\n-        @vec::append(self.path.clone(), [path_name(elt)])\n+    fn extend(&self, elt: path_elt) -> @path {\n+        @vec::append(self.path.clone(), [elt])\n     }\n \n     fn map_method(&mut self,\n@@ -120,7 +120,7 @@ impl Ctx {\n                       struct_def: @ast::struct_def,\n                       parent_node: ast_node,\n                       ident: ast::Ident) {\n-        let p = self.extend(ident);\n+        let p = self.extend(path_name(ident));\n \n         // If this is a tuple-like struct, register the constructor.\n         match struct_def.ctor_id {\n@@ -196,6 +196,28 @@ impl Ctx {\n \n         visit::walk_pat(self, pat, ());\n     }\n+\n+    fn impl_pretty_name(&self, trait_ref: &Option<trait_ref>,\n+                        ty: &Ty, default: Ident) -> path_elt {\n+        let itr = get_ident_interner();\n+        let ty_ident = match ty.node {\n+            ty_path(ref path, _, _) => path.segments.last().identifier,\n+            _ => default\n+        };\n+        let hash = (trait_ref, ty).hash();\n+        match *trait_ref {\n+            None => path_pretty_name(ty_ident, hash),\n+            Some(ref trait_ref) => {\n+                // XXX: this dollar sign is actually a relic of being one of the\n+                //      very few valid symbol names on unix. These kinds of\n+                //      details shouldn't be exposed way up here in the ast.\n+                let s = fmt!(\"%s$%s\",\n+                             itr.get(trait_ref.path.segments.last().identifier.name),\n+                             itr.get(ty_ident.name));\n+                path_pretty_name(Ident::new(itr.gensym(s)), hash)\n+            }\n+        }\n+    }\n }\n \n impl Visitor<()> for Ctx {\n@@ -205,40 +227,27 @@ impl Visitor<()> for Ctx {\n         self.map.insert(i.id, node_item(i, item_path));\n         match i.node {\n             item_impl(_, ref maybe_trait, ref ty, ref ms) => {\n+                // Right now the ident on impls is __extensions__ which isn't\n+                // very pretty when debugging, so attempt to select a better\n+                // name to use.\n+                let elt = self.impl_pretty_name(maybe_trait, ty, i.ident);\n+\n                 let impl_did = ast_util::local_def(i.id);\n                 for m in ms.iter() {\n-                    let extended = { self.extend(i.ident) };\n+                    let extended = { self.extend(elt) };\n                     self.map_method(impl_did, extended, *m, false)\n                 }\n \n-                // Right now the ident on impls is __extensions__ which isn't\n-                // very pretty when debugging, so attempt to select a better\n-                // name to use.\n-                let name = match *maybe_trait {\n-                    Some(ref trait_ref) => {\n-                        trait_ref.path.segments.last().identifier\n-                    }\n-                    None => {\n-                        match ty.node {\n-                            ty_path(ref p, _, _) => {\n-                                p.segments.last().identifier\n-                            }\n-                            // oh well, just give up for now\n-                            _ => { i.ident }\n-                        }\n-                    }\n-                };\n-\n-                let hash = hash::hash_keyed_2(maybe_trait, ty, 0, 0);\n-                self.path.push(path_pretty_name(name, hash));\n+                self.path.push(elt);\n             }\n             item_enum(ref enum_definition, _) => {\n                 for v in (*enum_definition).variants.iter() {\n+                    let elt = path_name(i.ident);\n                     // FIXME #2543: bad clone\n                     self.map.insert(v.node.id,\n                                     node_variant((*v).clone(),\n                                                  i,\n-                                                 self.extend(i.ident)));\n+                                                 self.extend(elt)));\n                 }\n             }\n             item_foreign_mod(ref nm) => {\n@@ -257,7 +266,9 @@ impl Visitor<()> for Ctx {\n                                                       // FIXME (#2543)\n                                                       if nm.sort ==\n                                                             ast::named {\n-                                                        self.extend(i.ident)\n+                                                          let e = path_name(\n+                                                              i.ident);\n+                                                          self.extend(e)\n                                                       } else {\n                                                         // Anonymous extern\n                                                         // mods go in the\n@@ -276,7 +287,7 @@ impl Visitor<()> for Ctx {\n                     self.map.insert(p.ref_id, node_item(i, item_path));\n                 }\n                 for tm in methods.iter() {\n-                    let ext = { self.extend(i.ident) };\n+                    let ext = { self.extend(path_name(i.ident)) };\n                     let d_id = ast_util::local_def(i.id);\n                     match *tm {\n                         required(ref m) => {"}, {"sha": "0f5bac795e768771efb7eb6f8180e138323dbbfb", "filename": "src/test/compile-fail/ambig_impl_2_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs?ref=7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "patch": "@@ -15,6 +15,6 @@ use ambig_impl_2_lib::me;\n trait me {\n     fn me(&self) -> uint;\n }\n-impl me for uint { fn me(&self) -> uint { *self } } //~ NOTE is `__extensions__::me`\n+impl me for uint { fn me(&self) -> uint { *self } } //~ NOTE is `me$uint::me`\n fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope\n //~^ NOTE is `ambig_impl_2_lib::__extensions__::me`"}, {"sha": "df88ff1f0d02eb55eee607f31fc0a5cacf7c8177", "filename": "src/test/compile-fail/ambig_impl_unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7baff57f268eff79cd8ed6a8d7fd48d4b3f81878/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_unify.rs?ref=7baff57f268eff79cd8ed6a8d7fd48d4b3f81878", "patch": "@@ -13,11 +13,11 @@ trait foo {\n }\n \n impl foo for ~[uint] {\n-    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `__extensions__::foo`\n+    fn foo(&self) -> int {1} //~ NOTE candidate #1 is `foo$__extensions__::foo`\n }\n \n impl foo for ~[int] {\n-    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `__extensions__::foo`\n+    fn foo(&self) -> int {2} //~ NOTE candidate #2 is `foo$__extensions__::foo`\n }\n \n fn main() {"}]}