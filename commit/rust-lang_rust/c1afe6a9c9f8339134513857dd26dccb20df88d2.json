{"sha": "c1afe6a9c9f8339134513857dd26dccb20df88d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYWZlNmE5YzlmODMzOTEzNDUxMzg1N2RkMjZkY2NiMjBkZjg4ZDI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-05T14:48:46Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-07T16:39:41Z"}, "message": "Remove private methods from TyCtxt impl block: rustc::trait::object_safety.", "tree": {"sha": "668ff77587635141ec7ddcdd27d7d895cf8f9120", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/668ff77587635141ec7ddcdd27d7d895cf8f9120"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1afe6a9c9f8339134513857dd26dccb20df88d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1afe6a9c9f8339134513857dd26dccb20df88d2", "html_url": "https://github.com/rust-lang/rust/commit/c1afe6a9c9f8339134513857dd26dccb20df88d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1afe6a9c9f8339134513857dd26dccb20df88d2/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "811adb5ddc539e0084c9311f14004daec0e34d0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/811adb5ddc539e0084c9311f14004daec0e34d0f", "html_url": "https://github.com/rust-lang/rust/commit/811adb5ddc539e0084c9311f14004daec0e34d0f"}], "stats": {"total": 1009, "additions": 508, "deletions": 501}, "files": [{"sha": "3c64a46661d05302601f88f1db0b9c10eaa6d8f7", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 508, "deletions": 501, "changes": 1009, "blob_url": "https://github.com/rust-lang/rust/blob/c1afe6a9c9f8339134513857dd26dccb20df88d2/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1afe6a9c9f8339134513857dd26dccb20df88d2/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=c1afe6a9c9f8339134513857dd26dccb20df88d2", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> Vec<ObjectSafetyViolation> {\n         debug_assert!(self.generics_of(trait_def_id).has_self);\n         let violations = traits::supertrait_def_ids(self, trait_def_id)\n-            .filter(|&def_id| self.predicates_reference_self(def_id, true))\n+            .filter(|&def_id| predicates_reference_self(self, def_id, true))\n             .map(|_| ObjectSafetyViolation::SupertraitSelf)\n             .collect();\n \n@@ -136,7 +136,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug!(\"object_safety_violations: {:?}\", trait_def_id);\n \n         traits::supertrait_def_ids(self, trait_def_id)\n-            .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n+            .flat_map(|def_id| object_safety_violations_for_trait(self, def_id))\n             .collect()\n     }\n \n@@ -148,572 +148,579 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert!(self.generics_of(trait_def_id).has_self);\n         debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n         // Any method that has a `Self: Sized` bound cannot be called.\n-        if self.generics_require_sized_self(method.def_id) {\n+        if generics_require_sized_self(self, method.def_id) {\n             return false;\n         }\n \n-        match self.virtual_call_violation_for_method(trait_def_id, method) {\n+        match virtual_call_violation_for_method(self, trait_def_id, method) {\n             None | Some(MethodViolationCode::WhereClauseReferencesSelf) => true,\n             Some(_) => false,\n         }\n     }\n+}\n \n-    fn object_safety_violations_for_trait(self, trait_def_id: DefId) -> Vec<ObjectSafetyViolation> {\n-        // Check methods for violations.\n-        let mut violations: Vec<_> = self\n-            .associated_items(trait_def_id)\n-            .filter(|item| item.kind == ty::AssocKind::Method)\n-            .filter_map(|item| {\n-                self.object_safety_violation_for_method(trait_def_id, &item).map(|code| {\n-                    ObjectSafetyViolation::Method(item.ident.name, code, item.ident.span)\n-                })\n-            })\n-            .filter(|violation| {\n-                if let ObjectSafetyViolation::Method(\n-                    _,\n-                    MethodViolationCode::WhereClauseReferencesSelf,\n-                    span,\n-                ) = violation\n-                {\n-                    // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n-                    // It's also hard to get a use site span, so we use the method definition span.\n-                    self.lint_node_note(\n-                        lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n-                        hir::CRATE_HIR_ID,\n-                        *span,\n-                        &format!(\n-                            \"the trait `{}` cannot be made into an object\",\n-                            self.def_path_str(trait_def_id)\n-                        ),\n-                        &violation.error_msg(),\n-                    );\n-                    false\n-                } else {\n-                    true\n-                }\n-            })\n-            .collect();\n-\n-        // Check the trait itself.\n-        if self.trait_has_sized_self(trait_def_id) {\n-            violations.push(ObjectSafetyViolation::SizedSelf);\n-        }\n-        if self.predicates_reference_self(trait_def_id, false) {\n-            violations.push(ObjectSafetyViolation::SupertraitSelf);\n-        }\n-\n-        violations.extend(\n-            self.associated_items(trait_def_id)\n-                .filter(|item| item.kind == ty::AssocKind::Const)\n-                .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)),\n-        );\n-\n-        debug!(\n-            \"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n-            trait_def_id, violations\n-        );\n+fn object_safety_violations_for_trait(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+) -> Vec<ObjectSafetyViolation> {\n+    // Check methods for violations.\n+    let mut violations: Vec<_> = tcx\n+        .associated_items(trait_def_id)\n+        .filter(|item| item.kind == ty::AssocKind::Method)\n+        .filter_map(|item| {\n+            object_safety_violation_for_method(tcx, trait_def_id, &item)\n+                .map(|code| ObjectSafetyViolation::Method(item.ident.name, code, item.ident.span))\n+        })\n+        .filter(|violation| {\n+            if let ObjectSafetyViolation::Method(\n+                _,\n+                MethodViolationCode::WhereClauseReferencesSelf,\n+                span,\n+            ) = violation\n+            {\n+                // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n+                // It's also hard to get a use site span, so we use the method definition span.\n+                tcx.lint_node_note(\n+                    lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n+                    hir::CRATE_HIR_ID,\n+                    *span,\n+                    &format!(\n+                        \"the trait `{}` cannot be made into an object\",\n+                        tcx.def_path_str(trait_def_id)\n+                    ),\n+                    &violation.error_msg(),\n+                );\n+                false\n+            } else {\n+                true\n+            }\n+        })\n+        .collect();\n \n-        violations\n+    // Check the trait itself.\n+    if trait_has_sized_self(tcx, trait_def_id) {\n+        violations.push(ObjectSafetyViolation::SizedSelf);\n     }\n-\n-    fn predicates_reference_self(self, trait_def_id: DefId, supertraits_only: bool) -> bool {\n-        let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(self, trait_def_id));\n-        let predicates = if supertraits_only {\n-            self.super_predicates_of(trait_def_id)\n-        } else {\n-            self.predicates_of(trait_def_id)\n-        };\n-        let self_ty = self.types.self_param;\n-        let has_self_ty = |t: Ty<'tcx>| t.walk().any(|t| t == self_ty);\n-        predicates\n-            .predicates\n-            .iter()\n-            .map(|(predicate, _)| predicate.subst_supertrait(self, &trait_ref))\n-            .any(|predicate| {\n-                match predicate {\n-                    ty::Predicate::Trait(ref data) => {\n-                        // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.skip_binder().input_types().skip(1).any(has_self_ty)\n-                    }\n-                    ty::Predicate::Projection(ref data) => {\n-                        // And similarly for projections. This should be redundant with\n-                        // the previous check because any projection should have a\n-                        // matching `Trait` predicate with the same inputs, but we do\n-                        // the check to be safe.\n-                        //\n-                        // Note that we *do* allow projection *outputs* to contain\n-                        // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n-                        // we just require the user to specify *both* outputs\n-                        // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n-                        //\n-                        // This is ALT2 in issue #56288, see that for discussion of the\n-                        // possible alternatives.\n-                        data.skip_binder()\n-                            .projection_ty\n-                            .trait_ref(self)\n-                            .input_types()\n-                            .skip(1)\n-                            .any(has_self_ty)\n-                    }\n-                    ty::Predicate::WellFormed(..)\n-                    | ty::Predicate::ObjectSafe(..)\n-                    | ty::Predicate::TypeOutlives(..)\n-                    | ty::Predicate::RegionOutlives(..)\n-                    | ty::Predicate::ClosureKind(..)\n-                    | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::ConstEvaluatable(..) => false,\n-                }\n-            })\n+    if predicates_reference_self(tcx, trait_def_id, false) {\n+        violations.push(ObjectSafetyViolation::SupertraitSelf);\n     }\n \n-    fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n-        self.generics_require_sized_self(trait_def_id)\n-    }\n+    violations.extend(\n+        tcx.associated_items(trait_def_id)\n+            .filter(|item| item.kind == ty::AssocKind::Const)\n+            .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)),\n+    );\n \n-    fn generics_require_sized_self(self, def_id: DefId) -> bool {\n-        let sized_def_id = match self.lang_items().sized_trait() {\n-            Some(def_id) => def_id,\n-            None => {\n-                return false; /* No Sized trait, can't require it! */\n-            }\n-        };\n+    debug!(\n+        \"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n+        trait_def_id, violations\n+    );\n \n-        // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let predicates = self.predicates_of(def_id);\n-        let predicates = predicates.instantiate_identity(self).predicates;\n-        elaborate_predicates(self, predicates).any(|predicate| match predicate {\n-            ty::Predicate::Trait(ref trait_pred) => {\n-                trait_pred.def_id() == sized_def_id\n-                    && trait_pred.skip_binder().self_ty().is_param(0)\n+    violations\n+}\n+\n+fn predicates_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId, supertraits_only: bool) -> bool {\n+    let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(tcx, trait_def_id));\n+    let predicates = if supertraits_only {\n+        tcx.super_predicates_of(trait_def_id)\n+    } else {\n+        tcx.predicates_of(trait_def_id)\n+    };\n+    let self_ty = tcx.types.self_param;\n+    let has_self_ty = |t: Ty<'_>| t.walk().any(|t| t == self_ty);\n+    predicates\n+        .predicates\n+        .iter()\n+        .map(|(predicate, _)| predicate.subst_supertrait(tcx, &trait_ref))\n+        .any(|predicate| {\n+            match predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    // In the case of a trait predicate, we can skip the \"self\" type.\n+                    data.skip_binder().input_types().skip(1).any(has_self_ty)\n+                }\n+                ty::Predicate::Projection(ref data) => {\n+                    // And similarly for projections. This should be redundant with\n+                    // the previous check because any projection should have a\n+                    // matching `Trait` predicate with the same inputs, but we do\n+                    // the check to be safe.\n+                    //\n+                    // Note that we *do* allow projection *outputs* to contain\n+                    // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n+                    // we just require the user to specify *both* outputs\n+                    // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n+                    //\n+                    // This is ALT2 in issue #56288, see that for discussion of the\n+                    // possible alternatives.\n+                    data.skip_binder()\n+                        .projection_ty\n+                        .trait_ref(tcx)\n+                        .input_types()\n+                        .skip(1)\n+                        .any(has_self_ty)\n+                }\n+                ty::Predicate::WellFormed(..)\n+                | ty::Predicate::ObjectSafe(..)\n+                | ty::Predicate::TypeOutlives(..)\n+                | ty::Predicate::RegionOutlives(..)\n+                | ty::Predicate::ClosureKind(..)\n+                | ty::Predicate::Subtype(..)\n+                | ty::Predicate::ConstEvaluatable(..) => false,\n             }\n-            ty::Predicate::Projection(..)\n-            | ty::Predicate::Subtype(..)\n-            | ty::Predicate::RegionOutlives(..)\n-            | ty::Predicate::WellFormed(..)\n-            | ty::Predicate::ObjectSafe(..)\n-            | ty::Predicate::ClosureKind(..)\n-            | ty::Predicate::TypeOutlives(..)\n-            | ty::Predicate::ConstEvaluatable(..) => false,\n         })\n-    }\n+}\n \n-    /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-    fn object_safety_violation_for_method(\n-        self,\n-        trait_def_id: DefId,\n-        method: &ty::AssocItem,\n-    ) -> Option<MethodViolationCode> {\n-        debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite is otherwise\n-        // exempt from the regulations.\n-        if self.generics_require_sized_self(method.def_id) {\n-            return None;\n+fn trait_has_sized_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n+    generics_require_sized_self(tcx, trait_def_id)\n+}\n+\n+fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let sized_def_id = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => {\n+            return false; /* No Sized trait, can't require it! */\n+        }\n+    };\n+\n+    // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+    let predicates = tcx.predicates_of(def_id);\n+    let predicates = predicates.instantiate_identity(tcx).predicates;\n+    elaborate_predicates(tcx, predicates).any(|predicate| match predicate {\n+        ty::Predicate::Trait(ref trait_pred) => {\n+            trait_pred.def_id() == sized_def_id && trait_pred.skip_binder().self_ty().is_param(0)\n         }\n+        ty::Predicate::Projection(..)\n+        | ty::Predicate::Subtype(..)\n+        | ty::Predicate::RegionOutlives(..)\n+        | ty::Predicate::WellFormed(..)\n+        | ty::Predicate::ObjectSafe(..)\n+        | ty::Predicate::ClosureKind(..)\n+        | ty::Predicate::TypeOutlives(..)\n+        | ty::Predicate::ConstEvaluatable(..) => false,\n+    })\n+}\n \n-        self.virtual_call_violation_for_method(trait_def_id, method)\n+/// Returns `Some(_)` if this method makes the containing trait not object safe.\n+fn object_safety_violation_for_method(\n+    tcx: TyCtxt<'_>,\n+    trait_def_id: DefId,\n+    method: &ty::AssocItem,\n+) -> Option<MethodViolationCode> {\n+    debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n+    // Any method that has a `Self : Sized` requisite is otherwise\n+    // exempt from the regulations.\n+    if generics_require_sized_self(tcx, method.def_id) {\n+        return None;\n     }\n \n-    /// Returns `Some(_)` if this method cannot be called on a trait\n-    /// object; this does not necessarily imply that the enclosing trait\n-    /// is not object safe, because the method might have a where clause\n-    /// `Self:Sized`.\n-    fn virtual_call_violation_for_method(\n-        self,\n-        trait_def_id: DefId,\n-        method: &ty::AssocItem,\n-    ) -> Option<MethodViolationCode> {\n-        // The method's first parameter must be named `self`\n-        if !method.method_has_self_argument {\n-            return Some(MethodViolationCode::StaticMethod);\n-        }\n+    virtual_call_violation_for_method(tcx, trait_def_id, method)\n+}\n \n-        let sig = self.fn_sig(method.def_id);\n+/// Returns `Some(_)` if this method cannot be called on a trait\n+/// object; this does not necessarily imply that the enclosing trait\n+/// is not object safe, because the method might have a where clause\n+/// `Self:Sized`.\n+fn virtual_call_violation_for_method<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    method: &ty::AssocItem,\n+) -> Option<MethodViolationCode> {\n+    // The method's first parameter must be named `self`\n+    if !method.method_has_self_argument {\n+        return Some(MethodViolationCode::StaticMethod);\n+    }\n \n-        for input_ty in &sig.skip_binder().inputs()[1..] {\n-            if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n-                return Some(MethodViolationCode::ReferencesSelf);\n-            }\n-        }\n-        if self.contains_illegal_self_type_reference(trait_def_id, sig.output().skip_binder()) {\n+    let sig = tcx.fn_sig(method.def_id);\n+\n+    for input_ty in &sig.skip_binder().inputs()[1..] {\n+        if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }\n+    }\n+    if contains_illegal_self_type_reference(tcx, trait_def_id, sig.output().skip_binder()) {\n+        return Some(MethodViolationCode::ReferencesSelf);\n+    }\n \n-        // We can't monomorphize things like `fn foo<A>(...)`.\n-        let own_counts = self.generics_of(method.def_id).own_counts();\n-        if own_counts.types + own_counts.consts != 0 {\n-            return Some(MethodViolationCode::Generic);\n-        }\n+    // We can't monomorphize things like `fn foo<A>(...)`.\n+    let own_counts = tcx.generics_of(method.def_id).own_counts();\n+    if own_counts.types + own_counts.consts != 0 {\n+        return Some(MethodViolationCode::Generic);\n+    }\n \n-        if self\n-            .predicates_of(method.def_id)\n-            .predicates\n-            .iter()\n-            // A trait object can't claim to live more than the concrete type,\n-            // so outlives predicates will always hold.\n-            .cloned()\n-            .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-            .collect::<Vec<_>>()\n-            // Do a shallow visit so that `contains_illegal_self_type_reference`\n-            // may apply it's custom visiting.\n-            .visit_tys_shallow(|t| self.contains_illegal_self_type_reference(trait_def_id, t))\n-        {\n-            return Some(MethodViolationCode::WhereClauseReferencesSelf);\n-        }\n+    if tcx\n+        .predicates_of(method.def_id)\n+        .predicates\n+        .iter()\n+        // A trait object can't claim to live more than the concrete type,\n+        // so outlives predicates will always hold.\n+        .cloned()\n+        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n+        .collect::<Vec<_>>()\n+        // Do a shallow visit so that `contains_illegal_self_type_reference`\n+        // may apply it's custom visiting.\n+        .visit_tys_shallow(|t| contains_illegal_self_type_reference(tcx, trait_def_id, t))\n+    {\n+        return Some(MethodViolationCode::WhereClauseReferencesSelf);\n+    }\n \n-        let receiver_ty =\n-            self.liberate_late_bound_regions(method.def_id, &sig.map_bound(|sig| sig.inputs()[0]));\n+    let receiver_ty =\n+        tcx.liberate_late_bound_regions(method.def_id, &sig.map_bound(|sig| sig.inputs()[0]));\n \n-        // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n-        // However, this is already considered object-safe. We allow it as a special case here.\n-        // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n-        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`.\n-        if receiver_ty != self.types.self_param {\n-            if !self.receiver_is_dispatchable(method, receiver_ty) {\n-                return Some(MethodViolationCode::UndispatchableReceiver);\n-            } else {\n-                // Do sanity check to make sure the receiver actually has the layout of a pointer.\n+    // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n+    // However, this is already considered object-safe. We allow it as a special case here.\n+    // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n+    // `Receiver: Unsize<Receiver[Self => dyn Trait]>`.\n+    if receiver_ty != tcx.types.self_param {\n+        if !receiver_is_dispatchable(tcx, method, receiver_ty) {\n+            return Some(MethodViolationCode::UndispatchableReceiver);\n+        } else {\n+            // Do sanity check to make sure the receiver actually has the layout of a pointer.\n \n-                use crate::ty::layout::Abi;\n+            use crate::ty::layout::Abi;\n \n-                let param_env = self.param_env(method.def_id);\n+            let param_env = tcx.param_env(method.def_id);\n \n-                let abi_of_ty = |ty: Ty<'tcx>| -> &Abi {\n-                    match self.layout_of(param_env.and(ty)) {\n-                        Ok(layout) => &layout.abi,\n-                        Err(err) => {\n-                            bug!(\"error: {}\\n while computing layout for type {:?}\", err, ty)\n-                        }\n-                    }\n-                };\n-\n-                // e.g., `Rc<()>`\n-                let unit_receiver_ty =\n-                    self.receiver_for_self_ty(receiver_ty, self.mk_unit(), method.def_id);\n-\n-                match abi_of_ty(unit_receiver_ty) {\n-                    &Abi::Scalar(..) => (),\n-                    abi => {\n-                        self.sess.delay_span_bug(\n-                            self.def_span(method.def_id),\n-                            &format!(\n-                                \"receiver when `Self = ()` should have a Scalar ABI; found {:?}\",\n-                                abi\n-                            ),\n-                        );\n-                    }\n+            let abi_of_ty = |ty: Ty<'tcx>| -> &Abi {\n+                match tcx.layout_of(param_env.and(ty)) {\n+                    Ok(layout) => &layout.abi,\n+                    Err(err) => bug!(\"error: {}\\n while computing layout for type {:?}\", err, ty),\n+                }\n+            };\n+\n+            // e.g., `Rc<()>`\n+            let unit_receiver_ty =\n+                receiver_for_self_ty(tcx, receiver_ty, tcx.mk_unit(), method.def_id);\n+\n+            match abi_of_ty(unit_receiver_ty) {\n+                &Abi::Scalar(..) => (),\n+                abi => {\n+                    tcx.sess.delay_span_bug(\n+                        tcx.def_span(method.def_id),\n+                        &format!(\n+                            \"receiver when `Self = ()` should have a Scalar ABI; found {:?}\",\n+                            abi\n+                        ),\n+                    );\n                 }\n+            }\n \n-                let trait_object_ty =\n-                    self.object_ty_for_trait(trait_def_id, self.mk_region(ty::ReStatic));\n+            let trait_object_ty =\n+                object_ty_for_trait(tcx, trait_def_id, tcx.mk_region(ty::ReStatic));\n \n-                // e.g., `Rc<dyn Trait>`\n-                let trait_object_receiver =\n-                    self.receiver_for_self_ty(receiver_ty, trait_object_ty, method.def_id);\n+            // e.g., `Rc<dyn Trait>`\n+            let trait_object_receiver =\n+                receiver_for_self_ty(tcx, receiver_ty, trait_object_ty, method.def_id);\n \n-                match abi_of_ty(trait_object_receiver) {\n-                    &Abi::ScalarPair(..) => (),\n-                    abi => {\n-                        self.sess.delay_span_bug(\n-                            self.def_span(method.def_id),\n-                            &format!(\n-                                \"receiver when `Self = {}` should have a ScalarPair ABI; \\\n+            match abi_of_ty(trait_object_receiver) {\n+                &Abi::ScalarPair(..) => (),\n+                abi => {\n+                    tcx.sess.delay_span_bug(\n+                        tcx.def_span(method.def_id),\n+                        &format!(\n+                            \"receiver when `Self = {}` should have a ScalarPair ABI; \\\n                                  found {:?}\",\n-                                trait_object_ty, abi\n-                            ),\n-                        );\n-                    }\n+                            trait_object_ty, abi\n+                        ),\n+                    );\n                 }\n             }\n         }\n-\n-        None\n     }\n \n-    /// Performs a type substitution to produce the version of `receiver_ty` when `Self = self_ty`.\n-    /// For example, for `receiver_ty = Rc<Self>` and `self_ty = Foo`, returns `Rc<Foo>`.\n-    fn receiver_for_self_ty(\n-        self,\n-        receiver_ty: Ty<'tcx>,\n-        self_ty: Ty<'tcx>,\n-        method_def_id: DefId,\n-    ) -> Ty<'tcx> {\n-        debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n-        let substs = InternalSubsts::for_item(self, method_def_id, |param, _| {\n-            if param.index == 0 { self_ty.into() } else { self.mk_param_from_def(param) }\n-        });\n-\n-        let result = receiver_ty.subst(self, substs);\n-        debug!(\n-            \"receiver_for_self_ty({:?}, {:?}, {:?}) = {:?}\",\n-            receiver_ty, self_ty, method_def_id, result\n-        );\n-        result\n-    }\n+    None\n+}\n \n-    /// Creates the object type for the current trait. For example,\n-    /// if the current trait is `Deref`, then this will be\n-    /// `dyn Deref<Target = Self::Target> + 'static`.\n-    fn object_ty_for_trait(self, trait_def_id: DefId, lifetime: ty::Region<'tcx>) -> Ty<'tcx> {\n-        debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n+/// Performs a type substitution to produce the version of `receiver_ty` when `Self = self_ty`.\n+/// For example, for `receiver_ty = Rc<Self>` and `self_ty = Foo`, returns `Rc<Foo>`.\n+fn receiver_for_self_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    receiver_ty: Ty<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    method_def_id: DefId,\n+) -> Ty<'tcx> {\n+    debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n+    let substs = InternalSubsts::for_item(tcx, method_def_id, |param, _| {\n+        if param.index == 0 { self_ty.into() } else { tcx.mk_param_from_def(param) }\n+    });\n+\n+    let result = receiver_ty.subst(tcx, substs);\n+    debug!(\n+        \"receiver_for_self_ty({:?}, {:?}, {:?}) = {:?}\",\n+        receiver_ty, self_ty, method_def_id, result\n+    );\n+    result\n+}\n \n-        let trait_ref = ty::TraitRef::identity(self, trait_def_id);\n+/// Creates the object type for the current trait. For example,\n+/// if the current trait is `Deref`, then this will be\n+/// `dyn Deref<Target = Self::Target> + 'static`.\n+fn object_ty_for_trait<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    lifetime: ty::Region<'tcx>,\n+) -> Ty<'tcx> {\n+    debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n \n-        let trait_predicate = ty::ExistentialPredicate::Trait(\n-            ty::ExistentialTraitRef::erase_self_ty(self, trait_ref),\n-        );\n+    let trait_ref = ty::TraitRef::identity(tcx, trait_def_id);\n \n-        let mut associated_types = traits::supertraits(self, ty::Binder::dummy(trait_ref))\n-            .flat_map(|super_trait_ref| {\n-                self.associated_items(super_trait_ref.def_id())\n-                    .map(move |item| (super_trait_ref, item))\n-            })\n-            .filter(|(_, item)| item.kind == ty::AssocKind::Type)\n-            .collect::<Vec<_>>();\n-\n-        // existential predicates need to be in a specific order\n-        associated_types.sort_by_cached_key(|(_, item)| self.def_path_hash(item.def_id));\n-\n-        let projection_predicates = associated_types.into_iter().map(|(super_trait_ref, item)| {\n-            // We *can* get bound lifetimes here in cases like\n-            // `trait MyTrait: for<'s> OtherTrait<&'s T, Output=bool>`.\n-            //\n-            // binder moved to (*)...\n-            let super_trait_ref = super_trait_ref.skip_binder();\n-            ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n-                ty: self.mk_projection(item.def_id, super_trait_ref.substs),\n-                item_def_id: item.def_id,\n-                substs: super_trait_ref.substs,\n-            })\n-        });\n-\n-        let existential_predicates = self\n-            .mk_existential_predicates(iter::once(trait_predicate).chain(projection_predicates));\n-\n-        let object_ty = self.mk_dynamic(\n-            // (*) ... binder re-introduced here\n-            ty::Binder::bind(existential_predicates),\n-            lifetime,\n-        );\n+    let trait_predicate =\n+        ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n \n-        debug!(\"object_ty_for_trait: object_ty=`{}`\", object_ty);\n+    let mut associated_types = traits::supertraits(tcx, ty::Binder::dummy(trait_ref))\n+        .flat_map(|super_trait_ref| {\n+            tcx.associated_items(super_trait_ref.def_id()).map(move |item| (super_trait_ref, item))\n+        })\n+        .filter(|(_, item)| item.kind == ty::AssocKind::Type)\n+        .collect::<Vec<_>>();\n \n-        object_ty\n-    }\n+    // existential predicates need to be in a specific order\n+    associated_types.sort_by_cached_key(|(_, item)| tcx.def_path_hash(item.def_id));\n \n-    /// Checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n-    /// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n-    /// in the following way:\n-    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`,\n-    /// - require the following bound:\n-    ///\n-    ///   ```\n-    ///   Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n-    ///   ```\n-    ///\n-    ///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n-    ///   (substitution notation).\n-    ///\n-    /// Some examples of receiver types and their required obligation:\n-    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`,\n-    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`,\n-    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`.\n-    ///\n-    /// The only case where the receiver is not dispatchable, but is still a valid receiver\n-    /// type (just not object-safe), is when there is more than one level of pointer indirection.\n-    /// E.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n-    /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n-    /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n-    /// contained by the trait object, because the object that needs to be coerced is behind\n-    /// a pointer.\n-    ///\n-    /// In practice, we cannot use `dyn Trait` explicitly in the obligation because it would result\n-    /// in a new check that `Trait` is object safe, creating a cycle (until object_safe_for_dispatch\n-    /// is stabilized, see tracking issue https://github.com/rust-lang/rust/issues/43561).\n-    /// Instead, we fudge a little by introducing a new type parameter `U` such that\n-    /// `Self: Unsize<U>` and `U: Trait + ?Sized`, and use `U` in place of `dyn Trait`.\n-    /// Written as a chalk-style query:\n-    ///\n-    ///     forall (U: Trait + ?Sized) {\n-    ///         if (Self: Unsize<U>) {\n-    ///             Receiver: DispatchFromDyn<Receiver[Self => U]>\n-    ///         }\n-    ///     }\n-    ///\n-    /// for `self: &'a mut Self`, this means `&'a mut Self: DispatchFromDyn<&'a mut U>`\n-    /// for `self: Rc<Self>`, this means `Rc<Self>: DispatchFromDyn<Rc<U>>`\n-    /// for `self: Pin<Box<Self>>`, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`\n-    //\n-    // FIXME(mikeyhew) when unsized receivers are implemented as part of unsized rvalues, add this\n-    // fallback query: `Receiver: Unsize<Receiver[Self => U]>` to support receivers like\n-    // `self: Wrapper<Self>`.\n-    #[allow(dead_code)]\n-    fn receiver_is_dispatchable(self, method: &ty::AssocItem, receiver_ty: Ty<'tcx>) -> bool {\n-        debug!(\"receiver_is_dispatchable: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);\n-\n-        let traits =\n-            (self.lang_items().unsize_trait(), self.lang_items().dispatch_from_dyn_trait());\n-        let (unsize_did, dispatch_from_dyn_did) = if let (Some(u), Some(cu)) = traits {\n-            (u, cu)\n-        } else {\n-            debug!(\"receiver_is_dispatchable: Missing Unsize or DispatchFromDyn traits\");\n-            return false;\n-        };\n+    let projection_predicates = associated_types.into_iter().map(|(super_trait_ref, item)| {\n+        // We *can* get bound lifetimes here in cases like\n+        // `trait MyTrait: for<'s> OtherTrait<&'s T, Output=bool>`.\n+        //\n+        // binder moved to (*)...\n+        let super_trait_ref = super_trait_ref.skip_binder();\n+        ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n+            ty: tcx.mk_projection(item.def_id, super_trait_ref.substs),\n+            item_def_id: item.def_id,\n+            substs: super_trait_ref.substs,\n+        })\n+    });\n \n-        // the type `U` in the query\n-        // use a bogus type parameter to mimick a forall(U) query using u32::MAX for now.\n-        // FIXME(mikeyhew) this is a total hack. Once object_safe_for_dispatch is stabilized, we can\n-        // replace this with `dyn Trait`\n-        let unsized_self_ty: Ty<'tcx> =\n-            self.mk_ty_param(::std::u32::MAX, Symbol::intern(\"RustaceansAreAwesome\"));\n-\n-        // `Receiver[Self => U]`\n-        let unsized_receiver_ty =\n-            self.receiver_for_self_ty(receiver_ty, unsized_self_ty, method.def_id);\n-\n-        // create a modified param env, with `Self: Unsize<U>` and `U: Trait` added to caller bounds\n-        // `U: ?Sized` is already implied here\n-        let param_env = {\n-            let mut param_env = self.param_env(method.def_id);\n-\n-            // Self: Unsize<U>\n-            let unsize_predicate = ty::TraitRef {\n-                def_id: unsize_did,\n-                substs: self.mk_substs_trait(self.types.self_param, &[unsized_self_ty.into()]),\n-            }\n-            .to_predicate();\n-\n-            // U: Trait<Arg1, ..., ArgN>\n-            let trait_predicate = {\n-                let substs =\n-                    InternalSubsts::for_item(self, method.container.assert_trait(), |param, _| {\n-                        if param.index == 0 {\n-                            unsized_self_ty.into()\n-                        } else {\n-                            self.mk_param_from_def(param)\n-                        }\n-                    });\n-\n-                ty::TraitRef { def_id: unsize_did, substs }.to_predicate()\n-            };\n+    let existential_predicates =\n+        tcx.mk_existential_predicates(iter::once(trait_predicate).chain(projection_predicates));\n \n-            let caller_bounds: Vec<Predicate<'tcx>> = param_env\n-                .caller_bounds\n-                .iter()\n-                .cloned()\n-                .chain(iter::once(unsize_predicate))\n-                .chain(iter::once(trait_predicate))\n-                .collect();\n+    let object_ty = tcx.mk_dynamic(\n+        // (*) ... binder re-introduced here\n+        ty::Binder::bind(existential_predicates),\n+        lifetime,\n+    );\n \n-            param_env.caller_bounds = self.intern_predicates(&caller_bounds);\n+    debug!(\"object_ty_for_trait: object_ty=`{}`\", object_ty);\n \n-            param_env\n-        };\n+    object_ty\n+}\n \n-        // Receiver: DispatchFromDyn<Receiver[Self => U]>\n-        let obligation = {\n-            let predicate = ty::TraitRef {\n-                def_id: dispatch_from_dyn_did,\n-                substs: self.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n-            }\n-            .to_predicate();\n+/// Checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n+/// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n+/// in the following way:\n+/// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`,\n+/// - require the following bound:\n+///\n+///   ```\n+///   Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+///   ```\n+///\n+///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n+///   (substitution notation).\n+///\n+/// Some examples of receiver types and their required obligation:\n+/// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`,\n+/// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`,\n+/// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`.\n+///\n+/// The only case where the receiver is not dispatchable, but is still a valid receiver\n+/// type (just not object-safe), is when there is more than one level of pointer indirection.\n+/// E.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+/// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n+/// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n+/// contained by the trait object, because the object that needs to be coerced is behind\n+/// a pointer.\n+///\n+/// In practice, we cannot use `dyn Trait` explicitly in the obligation because it would result\n+/// in a new check that `Trait` is object safe, creating a cycle (until object_safe_for_dispatch\n+/// is stabilized, see tracking issue https://github.com/rust-lang/rust/issues/43561).\n+/// Instead, we fudge a little by introducing a new type parameter `U` such that\n+/// `Self: Unsize<U>` and `U: Trait + ?Sized`, and use `U` in place of `dyn Trait`.\n+/// Written as a chalk-style query:\n+///\n+///     forall (U: Trait + ?Sized) {\n+///         if (Self: Unsize<U>) {\n+///             Receiver: DispatchFromDyn<Receiver[Self => U]>\n+///         }\n+///     }\n+///\n+/// for `self: &'a mut Self`, this means `&'a mut Self: DispatchFromDyn<&'a mut U>`\n+/// for `self: Rc<Self>`, this means `Rc<Self>: DispatchFromDyn<Rc<U>>`\n+/// for `self: Pin<Box<Self>>`, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`\n+//\n+// FIXME(mikeyhew) when unsized receivers are implemented as part of unsized rvalues, add this\n+// fallback query: `Receiver: Unsize<Receiver[Self => U]>` to support receivers like\n+// `self: Wrapper<Self>`.\n+#[allow(dead_code)]\n+fn receiver_is_dispatchable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    method: &ty::AssocItem,\n+    receiver_ty: Ty<'tcx>,\n+) -> bool {\n+    debug!(\"receiver_is_dispatchable: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);\n+\n+    let traits = (tcx.lang_items().unsize_trait(), tcx.lang_items().dispatch_from_dyn_trait());\n+    let (unsize_did, dispatch_from_dyn_did) = if let (Some(u), Some(cu)) = traits {\n+        (u, cu)\n+    } else {\n+        debug!(\"receiver_is_dispatchable: Missing Unsize or DispatchFromDyn traits\");\n+        return false;\n+    };\n+\n+    // the type `U` in the query\n+    // use a bogus type parameter to mimick a forall(U) query using u32::MAX for now.\n+    // FIXME(mikeyhew) this is a total hack. Once object_safe_for_dispatch is stabilized, we can\n+    // replace this with `dyn Trait`\n+    let unsized_self_ty: Ty<'tcx> =\n+        tcx.mk_ty_param(::std::u32::MAX, Symbol::intern(\"RustaceansAreAwesome\"));\n+\n+    // `Receiver[Self => U]`\n+    let unsized_receiver_ty =\n+        receiver_for_self_ty(tcx, receiver_ty, unsized_self_ty, method.def_id);\n+\n+    // create a modified param env, with `Self: Unsize<U>` and `U: Trait` added to caller bounds\n+    // `U: ?Sized` is already implied here\n+    let param_env = {\n+        let mut param_env = tcx.param_env(method.def_id);\n+\n+        // Self: Unsize<U>\n+        let unsize_predicate = ty::TraitRef {\n+            def_id: unsize_did,\n+            substs: tcx.mk_substs_trait(tcx.types.self_param, &[unsized_self_ty.into()]),\n+        }\n+        .to_predicate();\n+\n+        // U: Trait<Arg1, ..., ArgN>\n+        let trait_predicate = {\n+            let substs =\n+                InternalSubsts::for_item(tcx, method.container.assert_trait(), |param, _| {\n+                    if param.index == 0 {\n+                        unsized_self_ty.into()\n+                    } else {\n+                        tcx.mk_param_from_def(param)\n+                    }\n+                });\n \n-            Obligation::new(ObligationCause::dummy(), param_env, predicate)\n+            ty::TraitRef { def_id: unsize_did, substs }.to_predicate()\n         };\n \n-        self.infer_ctxt().enter(|ref infcx| {\n-            // the receiver is dispatchable iff the obligation holds\n-            infcx.predicate_must_hold_modulo_regions(&obligation)\n-        })\n-    }\n+        let caller_bounds: Vec<Predicate<'tcx>> = param_env\n+            .caller_bounds\n+            .iter()\n+            .cloned()\n+            .chain(iter::once(unsize_predicate))\n+            .chain(iter::once(trait_predicate))\n+            .collect();\n \n-    fn contains_illegal_self_type_reference(self, trait_def_id: DefId, ty: Ty<'tcx>) -> bool {\n-        // This is somewhat subtle. In general, we want to forbid\n-        // references to `Self` in the argument and return types,\n-        // since the value of `Self` is erased. However, there is one\n-        // exception: it is ok to reference `Self` in order to access\n-        // an associated type of the current trait, since we retain\n-        // the value of those associated types in the object type\n-        // itself.\n-        //\n-        // ```rust\n-        // trait SuperTrait {\n-        //     type X;\n-        // }\n-        //\n-        // trait Trait : SuperTrait {\n-        //     type Y;\n-        //     fn foo(&self, x: Self) // bad\n-        //     fn foo(&self) -> Self // bad\n-        //     fn foo(&self) -> Option<Self> // bad\n-        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as Trait>::Y // OK\n-        //     fn foo(&self) -> Self::X // OK, desugars to next example\n-        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n-        // }\n-        // ```\n-        //\n-        // However, it is not as simple as allowing `Self` in a projected\n-        // type, because there are illegal ways to use `Self` as well:\n-        //\n-        // ```rust\n-        // trait Trait : SuperTrait {\n-        //     ...\n-        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n-        // }\n-        // ```\n-        //\n-        // Here we will not have the type of `X` recorded in the\n-        // object type, and we cannot resolve `Self as SomeOtherTrait`\n-        // without knowing what `Self` is.\n-\n-        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-        let mut error = false;\n-        let self_ty = self.types.self_param;\n-        ty.maybe_walk(|ty| {\n-            match ty.kind {\n-                ty::Param(_) => {\n-                    if ty == self_ty {\n-                        error = true;\n-                    }\n+        param_env.caller_bounds = tcx.intern_predicates(&caller_bounds);\n+\n+        param_env\n+    };\n+\n+    // Receiver: DispatchFromDyn<Receiver[Self => U]>\n+    let obligation = {\n+        let predicate = ty::TraitRef {\n+            def_id: dispatch_from_dyn_did,\n+            substs: tcx.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n+        }\n+        .to_predicate();\n+\n+        Obligation::new(ObligationCause::dummy(), param_env, predicate)\n+    };\n \n-                    false // no contained types to walk\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        // the receiver is dispatchable iff the obligation holds\n+        infcx.predicate_must_hold_modulo_regions(&obligation)\n+    })\n+}\n+\n+fn contains_illegal_self_type_reference<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    ty: Ty<'tcx>,\n+) -> bool {\n+    // This is somewhat subtle. In general, we want to forbid\n+    // references to `Self` in the argument and return types,\n+    // since the value of `Self` is erased. However, there is one\n+    // exception: it is ok to reference `Self` in order to access\n+    // an associated type of the current trait, since we retain\n+    // the value of those associated types in the object type\n+    // itself.\n+    //\n+    // ```rust\n+    // trait SuperTrait {\n+    //     type X;\n+    // }\n+    //\n+    // trait Trait : SuperTrait {\n+    //     type Y;\n+    //     fn foo(&self, x: Self) // bad\n+    //     fn foo(&self) -> Self // bad\n+    //     fn foo(&self) -> Option<Self> // bad\n+    //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as Trait>::Y // OK\n+    //     fn foo(&self) -> Self::X // OK, desugars to next example\n+    //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+    // }\n+    // ```\n+    //\n+    // However, it is not as simple as allowing `Self` in a projected\n+    // type, because there are illegal ways to use `Self` as well:\n+    //\n+    // ```rust\n+    // trait Trait : SuperTrait {\n+    //     ...\n+    //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+    // }\n+    // ```\n+    //\n+    // Here we will not have the type of `X` recorded in the\n+    // object type, and we cannot resolve `Self as SomeOtherTrait`\n+    // without knowing what `Self` is.\n+\n+    let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+    let mut error = false;\n+    let self_ty = tcx.types.self_param;\n+    ty.maybe_walk(|ty| {\n+        match ty.kind {\n+            ty::Param(_) => {\n+                if ty == self_ty {\n+                    error = true;\n                 }\n \n-                ty::Projection(ref data) => {\n-                    // This is a projected type `<Foo as SomeTrait>::X`.\n+                false // no contained types to walk\n+            }\n \n-                    // Compute supertraits of current trait lazily.\n-                    if supertraits.is_none() {\n-                        let trait_ref =\n-                            ty::Binder::bind(ty::TraitRef::identity(self, trait_def_id));\n-                        supertraits = Some(traits::supertraits(self, trait_ref).collect());\n-                    }\n+            ty::Projection(ref data) => {\n+                // This is a projected type `<Foo as SomeTrait>::X`.\n \n-                    // Determine whether the trait reference `Foo as\n-                    // SomeTrait` is in fact a supertrait of the\n-                    // current trait. In that case, this type is\n-                    // legal, because the type `X` will be specified\n-                    // in the object type.  Note that we can just use\n-                    // direct equality here because all of these types\n-                    // are part of the formal parameter listing, and\n-                    // hence there should be no inference variables.\n-                    let projection_trait_ref = ty::Binder::bind(data.trait_ref(self));\n-                    let is_supertrait_of_current_trait =\n-                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n-\n-                    if is_supertrait_of_current_trait {\n-                        false // do not walk contained types, do not report error, do collect $200\n-                    } else {\n-                        true // DO walk contained types, POSSIBLY reporting an error\n-                    }\n+                // Compute supertraits of current trait lazily.\n+                if supertraits.is_none() {\n+                    let trait_ref = ty::Binder::bind(ty::TraitRef::identity(tcx, trait_def_id));\n+                    supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n                 }\n \n-                _ => true, // walk contained types, if any\n+                // Determine whether the trait reference `Foo as\n+                // SomeTrait` is in fact a supertrait of the\n+                // current trait. In that case, this type is\n+                // legal, because the type `X` will be specified\n+                // in the object type.  Note that we can just use\n+                // direct equality here because all of these types\n+                // are part of the formal parameter listing, and\n+                // hence there should be no inference variables.\n+                let projection_trait_ref = ty::Binder::bind(data.trait_ref(tcx));\n+                let is_supertrait_of_current_trait =\n+                    supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                if is_supertrait_of_current_trait {\n+                    false // do not walk contained types, do not report error, do collect $200\n+                } else {\n+                    true // DO walk contained types, POSSIBLY reporting an error\n+                }\n             }\n-        });\n \n-        error\n-    }\n+            _ => true, // walk contained types, if any\n+        }\n+    });\n+\n+    error\n }\n \n pub(super) fn is_object_safe_provider(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {"}]}