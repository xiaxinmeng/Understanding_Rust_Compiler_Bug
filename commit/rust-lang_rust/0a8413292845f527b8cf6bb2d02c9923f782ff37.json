{"sha": "0a8413292845f527b8cf6bb2d02c9923f782ff37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhODQxMzI5Mjg0NWY1MjdiOGNmNmJiMmQwMmM5OTIzZjc4MmZmMzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-01T07:17:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-07T02:11:02Z"}, "message": "syntax: Conditionally deriving(Hash) with Writers\n\nIf #[feature(default_type_parameters)] is enabled for a crate, then\nderiving(Hash) will expand with Hash<W: Writer> instead of Hash<SipState> so\nmore hash algorithms can be used.", "tree": {"sha": "6c4877cab523a54019eb8e15820c8531913139cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c4877cab523a54019eb8e15820c8531913139cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a8413292845f527b8cf6bb2d02c9923f782ff37", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8413292845f527b8cf6bb2d02c9923f782ff37", "html_url": "https://github.com/rust-lang/rust/commit/0a8413292845f527b8cf6bb2d02c9923f782ff37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a8413292845f527b8cf6bb2d02c9923f782ff37/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bec7b766fbbc9b56a1608e2573390e3894519840", "url": "https://api.github.com/repos/rust-lang/rust/commits/bec7b766fbbc9b56a1608e2573390e3894519840", "html_url": "https://github.com/rust-lang/rust/commit/bec7b766fbbc9b56a1608e2573390e3894519840"}], "stats": {"total": 225, "additions": 128, "deletions": 97}, "files": [{"sha": "5b335d163d8d097084b5c0e31ccfe1b5d11a7ed6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0a8413292845f527b8cf6bb2d02c9923f782ff37", "patch": "@@ -224,8 +224,12 @@ pub fn phase_2_configure_and_expand(sess: Session,\n                  front::config::strip_unconfigured_items(krate));\n \n     krate = time(time_passes, \"expansion\", krate, |krate| {\n+        let cfg = syntax::ext::expand::ExpansionConfig {\n+            loader: loader,\n+            deriving_hash_type_parameter: sess.features.default_type_params.get()\n+        };\n         syntax::ext::expand::expand_crate(sess.parse_sess,\n-                                          loader,\n+                                          cfg,\n                                           krate)\n     });\n     // dump the syntax-time crates"}, {"sha": "ecbb704684b38ad862f9403d50b43d87ded7d234", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=0a8413292845f527b8cf6bb2d02c9923f782ff37", "patch": "@@ -28,6 +28,7 @@ use syntax::attr;\n use syntax::codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n+use syntax::ext::expand::ExpansionConfig;\n use syntax::fold::Folder;\n use syntax::fold;\n use syntax::opt_vec;\n@@ -165,7 +166,11 @@ fn generate_test_harness(sess: session::Session, krate: ast::Crate)\n     let loader = &mut Loader::new(sess);\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n-        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone(), loader),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone(),\n+                             ExpansionConfig {\n+                                 loader: loader,\n+                                 deriving_hash_type_parameter: false,\n+                             }),\n         path: RefCell::new(~[]),\n         testfns: RefCell::new(~[]),\n         is_test_crate: is_test_crate(&krate),"}, {"sha": "9442a2144bdab36a13588662a25989ee38aac673", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0a8413292845f527b8cf6bb2d02c9923f782ff37", "patch": "@@ -179,6 +179,13 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n+#[cfg(stage0)]\n+impl Hash for intern_key {\n+    fn hash(&self, s: &mut sip::SipState) {\n+        unsafe { (*self.sty).hash(s) }\n+    }\n+}\n+#[cfg(not(stage0))]\n impl<W:Writer> Hash<W> for intern_key {\n     fn hash(&self, s: &mut W) {\n         unsafe { (*self.sty).hash(s) }\n@@ -251,6 +258,9 @@ pub struct ctxt_ {\n     diag: @syntax::diagnostic::SpanHandler,\n     // Specifically use a speedy hash algorithm for this hash map, it's used\n     // quite often.\n+    #[cfg(stage0)]\n+    interner: RefCell<HashMap<intern_key, ~t_box_>>,\n+    #[cfg(not(stage0))]\n     interner: RefCell<HashMap<intern_key, ~t_box_, ::util::nodemap::FnvHasher>>,\n     next_id: Cell<uint>,\n     cstore: @metadata::cstore::CStore,\n@@ -1081,12 +1091,19 @@ pub fn mk_ctxt(s: session::Session,\n                region_maps: middle::region::RegionMaps,\n                lang_items: @middle::lang_items::LanguageItems)\n             -> ctxt {\n-\n+    #[cfg(stage0)]\n+    fn hasher() -> HashMap<intern_key, ~t_box_> {\n+        HashMap::new()\n+    }\n+    #[cfg(not(stage0))]\n+    fn hasher() -> HashMap<intern_key, ~t_box_, ::util::nodemap::FnvHasher> {\n+        HashMap::with_hasher(::util::nodemap::FnvHasher)\n+    }\n     @ctxt_ {\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         diag: s.diagnostic(),\n-        interner: RefCell::new(HashMap::with_hasher(::util::nodemap::FnvHasher)),\n+        interner: RefCell::new(hasher()),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         cstore: s.cstore,\n         sess: s,"}, {"sha": "fe24733aba27d8347f07a71d2a790e171772fc8b", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=0a8413292845f527b8cf6bb2d02c9923f782ff37", "patch": "@@ -15,37 +15,84 @@ use std::hash::{Hasher, Hash};\n use std::io;\n use syntax::ast;\n \n+#[cfg(not(stage0))]\n pub type NodeMap<T> = HashMap<ast::NodeId, T, FnvHasher>;\n+#[cfg(not(stage0))]\n pub type DefIdMap<T> = HashMap<ast::DefId, T, FnvHasher>;\n+#[cfg(not(stage0))]\n pub type NodeSet = HashSet<ast::NodeId, FnvHasher>;\n+#[cfg(not(stage0))]\n pub type DefIdSet = HashSet<ast::DefId, FnvHasher>;\n \n // Hacks to get good names\n+#[cfg(not(stage0))]\n pub mod NodeMap {\n     use collections::HashMap;\n     pub fn new<T>() -> super::NodeMap<T> {\n         HashMap::with_hasher(super::FnvHasher)\n     }\n }\n+#[cfg(not(stage0))]\n pub mod NodeSet {\n     use collections::HashSet;\n     pub fn new() -> super::NodeSet {\n         HashSet::with_hasher(super::FnvHasher)\n     }\n }\n+#[cfg(not(stage0))]\n pub mod DefIdMap {\n     use collections::HashMap;\n     pub fn new<T>() -> super::DefIdMap<T> {\n         HashMap::with_hasher(super::FnvHasher)\n     }\n }\n+#[cfg(not(stage0))]\n pub mod DefIdSet {\n     use collections::HashSet;\n     pub fn new() -> super::DefIdSet {\n         HashSet::with_hasher(super::FnvHasher)\n     }\n }\n \n+#[cfg(stage0)]\n+pub type NodeMap<T> = HashMap<ast::NodeId, T>;\n+#[cfg(stage0)]\n+pub type DefIdMap<T> = HashMap<ast::DefId, T>;\n+#[cfg(stage0)]\n+pub type NodeSet = HashSet<ast::NodeId>;\n+#[cfg(stage0)]\n+pub type DefIdSet = HashSet<ast::DefId>;\n+\n+// Hacks to get good names\n+#[cfg(stage0)]\n+pub mod NodeMap {\n+    use collections::HashMap;\n+    pub fn new<T>() -> super::NodeMap<T> {\n+        HashMap::new()\n+    }\n+}\n+#[cfg(stage0)]\n+pub mod NodeSet {\n+    use collections::HashSet;\n+    pub fn new() -> super::NodeSet {\n+        HashSet::new()\n+    }\n+}\n+#[cfg(stage0)]\n+pub mod DefIdMap {\n+    use collections::HashMap;\n+    pub fn new<T>() -> super::DefIdMap<T> {\n+        HashMap::new()\n+    }\n+}\n+#[cfg(stage0)]\n+pub mod DefIdSet {\n+    use collections::HashSet;\n+    pub fn new() -> super::DefIdSet {\n+        HashSet::new()\n+    }\n+}\n+\n /// A speedy hash algorithm for node ids and def ids. The hashmap in\n /// libcollections by default uses SipHash which isn't quite as speedy as we\n /// want. In the compiler we're not really worried about DOS attempts, so we\n@@ -56,7 +103,7 @@ pub mod DefIdSet {\n #[deriving(Clone)]\n pub struct FnvHasher;\n \n-struct FnvState(u64);\n+pub struct FnvState(u64);\n \n impl Hasher<FnvState> for FnvHasher {\n     fn hash<T: Hash<FnvState>>(&self, t: &T) -> u64 {"}, {"sha": "459c0d1d0e3c5135a045cde6fadfc8619acc0fd6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0a8413292845f527b8cf6bb2d02c9923f782ff37", "patch": "@@ -283,21 +283,21 @@ pub struct ExtCtxt<'a> {\n     parse_sess: @parse::ParseSess,\n     cfg: ast::CrateConfig,\n     backtrace: Option<@ExpnInfo>,\n-    loader: &'a mut CrateLoader,\n+    ecfg: expand::ExpansionConfig<'a>,\n \n     mod_path: Vec<ast::Ident> ,\n     trace_mac: bool\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new<'a>(parse_sess: @parse::ParseSess, cfg: ast::CrateConfig,\n-               loader: &'a mut CrateLoader) -> ExtCtxt<'a> {\n+                   ecfg: expand::ExpansionConfig<'a>) -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,\n             backtrace: None,\n-            loader: loader,\n             mod_path: Vec::new(),\n+            ecfg: ecfg,\n             trace_mac: false\n         }\n     }"}, {"sha": "299989d5fe667b47a81580e38fa77ee843ad0d68", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=0a8413292845f527b8cf6bb2d02c9923f782ff37", "patch": "@@ -22,19 +22,31 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             item: @Item,\n                             push: |@Item|) {\n \n+    let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n+        (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,\n+                    vec!(~Literal(Path::new_local(\"__H\"))), true),\n+         LifetimeBounds {\n+             lifetimes: Vec::new(),\n+             bounds: vec!((\"__H\", vec!(Path::new(vec!(\"std\", \"io\", \"Writer\"))))),\n+         },\n+         Path::new_local(\"__H\"))\n+    } else {\n+        (Path::new(vec!(\"std\", \"hash\", \"Hash\")),\n+         LifetimeBounds::empty(),\n+         Path::new(vec!(\"std\", \"hash\", \"sip\", \"SipState\")))\n+    };\n     let hash_trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new(vec!(\"std\", \"hash\", \"Hash\")),\n+        path: path,\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n+        generics: generics,\n         methods: vec!(\n             MethodDef {\n                 name: \"hash\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(~Literal(Path::new(vec!(\"std\", \"hash\", \"sip\", \"SipState\"))),\n-                            Borrowed(None, MutMutable))),\n+                args: vec!(Ptr(~Literal(args), Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 inline: true,\n                 const_nonmatching: false,"}, {"sha": "12eaa759ede9fabe7bf5d8911663805c5d9536c6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0a8413292845f527b8cf6bb2d02c9923f782ff37", "patch": "@@ -443,15 +443,15 @@ pub fn expand_view_item(vi: &ast::ViewItem,\n }\n \n fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n-    let MacroCrate { lib, cnum } = fld.cx.loader.load_crate(krate);\n+    let MacroCrate { lib, cnum } = fld.cx.ecfg.loader.load_crate(krate);\n \n     let crate_name = match krate.node {\n         ast::ViewItemExternMod(name, _, _) => name,\n         _ => unreachable!()\n     };\n     let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n \n-    let exported_macros = fld.cx.loader.get_exported_macros(cnum);\n+    let exported_macros = fld.cx.ecfg.loader.get_exported_macros(cnum);\n     for source in exported_macros.iter() {\n         let item = parse::parse_item_from_source_str(name.clone(),\n                                                      (*source).clone(),\n@@ -468,7 +468,7 @@ fn load_extern_macros(krate: &ast::ViewItem, fld: &mut MacroExpander) {\n     // Make sure the path contains a / or the linker will search for it.\n     let path = os::make_absolute(&path);\n \n-    let registrar = match fld.cx.loader.get_registrar_symbol(cnum) {\n+    let registrar = match fld.cx.ecfg.loader.get_registrar_symbol(cnum) {\n         Some(registrar) => registrar,\n         None => return\n     };\n@@ -823,10 +823,15 @@ impl<'a> Folder for MacroExpander<'a> {\n     }\n }\n \n+pub struct ExpansionConfig<'a> {\n+    loader: &'a mut CrateLoader,\n+    deriving_hash_type_parameter: bool,\n+}\n+\n pub fn expand_crate(parse_sess: @parse::ParseSess,\n-                    loader: &mut CrateLoader,\n+                    cfg: ExpansionConfig,\n                     c: Crate) -> Crate {\n-    let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), loader);\n+    let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander {\n         extsbox: syntax_expander_table(),\n         cx: &mut cx,\n@@ -995,7 +1000,11 @@ mod test {\n             Vec::new(),sess);\n         // should fail:\n         let mut loader = ErrLoader;\n-        expand_crate(sess,&mut loader,crate_ast);\n+        let cfg = ::syntax::ext::expand::ExpansionConfig {\n+            loader: &mut loader,\n+            deriving_hash_type_parameter: false,\n+        };\n+        expand_crate(sess,cfg,crate_ast);\n     }\n \n     // make sure that macros can leave scope for modules\n@@ -1010,7 +1019,11 @@ mod test {\n             Vec::new(),sess);\n         // should fail:\n         let mut loader = ErrLoader;\n-        expand_crate(sess,&mut loader,crate_ast);\n+        let cfg = ::syntax::ext::expand::ExpansionConfig {\n+            loader: &mut loader,\n+            deriving_hash_type_parameter: false,\n+        };\n+        expand_crate(sess,cfg,crate_ast);\n     }\n \n     // macro_escape modules shouldn't cause macros to leave scope\n@@ -1024,7 +1037,11 @@ mod test {\n             Vec::new(), sess);\n         // should fail:\n         let mut loader = ErrLoader;\n-        expand_crate(sess, &mut loader, crate_ast);\n+        let cfg = ::syntax::ext::expand::ExpansionConfig {\n+            loader: &mut loader,\n+            deriving_hash_type_parameter: false,\n+        };\n+        expand_crate(sess, cfg, crate_ast);\n     }\n \n     #[test] fn test_contains_flatten (){\n@@ -1062,7 +1079,11 @@ mod test {\n         let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n         // the cfg argument actually does matter, here...\n         let mut loader = ErrLoader;\n-        expand_crate(ps,&mut loader,crate_ast)\n+        let cfg = ::syntax::ext::expand::ExpansionConfig {\n+            loader: &mut loader,\n+            deriving_hash_type_parameter: false,\n+        };\n+        expand_crate(ps,cfg,crate_ast)\n     }\n \n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {"}, {"sha": "0d465e8475c9ce5a1dc50e3e51f52898558ed5a4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8413292845f527b8cf6bb2d02c9923f782ff37/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=0a8413292845f527b8cf6bb2d02c9923f782ff37", "patch": "@@ -26,7 +26,7 @@ This API is completely unstable and subject to change.\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n-#[feature(macro_rules, globs, managed_boxes)];\n+#[feature(macro_rules, globs, managed_boxes, default_type_params)];\n #[allow(unknown_features)];// Note: remove it after a snapshot.\n #[feature(quote)];\n "}, {"sha": "e9ace61eb9570a667850cee3fd47fc2c3ab596b9", "filename": "src/libsyntax/util/nodemap.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibsyntax%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibsyntax%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnodemap.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -1,75 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An efficient hash map for node IDs\n-\n-use collections::hashmap;\n-use collections::{HashMap, HashSet};\n-use std::hash::{Hasher, Hash};\n-use std::iter;\n-use ast;\n-\n-pub type NodeMap<T> = HashMap<ast::NodeId, T, NodeHasher>;\n-pub type DefIdMap<T> = HashMap<ast::DefId, T, NodeHasher>;\n-pub type NodeSet = HashSet<ast::NodeId, NodeHasher>;\n-pub type DefIdSet = HashSet<ast::DefId, NodeHasher>;\n-\n-#[deriving(Clone)]\n-struct NodeHasher;\n-\n-impl Hasher<u64> for NodeHasher {\n-    fn hash<T: Hash<u64>>(&self, t: &T) -> u64 {\n-        let mut last = 0;\n-        t.hash(&mut last);\n-        return last\n-    }\n-}\n-\n-impl Hash<u64> for ast::NodeId {\n-    fn hash(&self, state: &mut u64) {\n-        *state = self.get() as u64;\n-    }\n-}\n-\n-impl Hash<u64> for ast::DefId {\n-    fn hash(&self, state: &mut u64) {\n-        let ast::DefId { krate, node } = *self;\n-        // assert that these two types are each 32 bits\n-        let krate: u32 = krate;\n-        let node: u32 = node;\n-        *state = (krate << 32) as u64 | (node as u64);\n-    }\n-}\n-\n-// Hacks to get good names\n-pub mod NodeMap {\n-    use collections::HashMap;\n-    pub fn new<T>() -> super::NodeMap<T> {\n-        HashMap::with_hasher(super::NodeHasher)\n-    }\n-}\n-pub mod NodeSet {\n-    use collections::HashSet;\n-    pub fn new() -> super::NodeSet {\n-        HashSet::with_hasher(super::NodeHasher)\n-    }\n-}\n-pub mod DefIdMap {\n-    use collections::HashMap;\n-    pub fn new<T>() -> super::DefIdMap<T> {\n-        HashMap::with_hasher(super::NodeHasher)\n-    }\n-}\n-pub mod DefIdSet {\n-    use collections::HashSet;\n-    pub fn new() -> super::DefIdSet {\n-        HashSet::with_hasher(super::NodeHasher)\n-    }\n-}"}]}