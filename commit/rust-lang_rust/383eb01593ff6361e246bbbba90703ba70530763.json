{"sha": "383eb01593ff6361e246bbbba90703ba70530763", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4M2ViMDE1OTNmZjYzNjFlMjQ2YmJiYmE5MDcwM2JhNzA1MzA3NjM=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-03T20:42:38Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-06T15:03:56Z"}, "message": "Remove `promotion_candidates` from `Checker`\n\nAlso removes any code used only to populate `promotion_candidates`\nduring const checking.", "tree": {"sha": "71477bc70c300aa7902aea13c23e1959b90d7ed5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71477bc70c300aa7902aea13c23e1959b90d7ed5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/383eb01593ff6361e246bbbba90703ba70530763", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/383eb01593ff6361e246bbbba90703ba70530763", "html_url": "https://github.com/rust-lang/rust/commit/383eb01593ff6361e246bbbba90703ba70530763", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/383eb01593ff6361e246bbbba90703ba70530763/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "328a898d23ce7f415e61399b687d7cdd70bfc566", "url": "https://api.github.com/repos/rust-lang/rust/commits/328a898d23ce7f415e61399b687d7cdd70bfc566", "html_url": "https://github.com/rust-lang/rust/commit/328a898d23ce7f415e61399b687d7cdd70bfc566"}], "stats": {"total": 143, "additions": 12, "deletions": 131}, "files": [{"sha": "44d96ef108442f410f65f31a642f6b54fffca142", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 12, "deletions": 131, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/383eb01593ff6361e246bbbba90703ba70530763/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/383eb01593ff6361e246bbbba90703ba70530763/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=383eb01593ff6361e246bbbba90703ba70530763", "patch": "@@ -6,7 +6,6 @@\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::abi::Abi;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -20,7 +19,6 @@ use rustc::mir::traversal::ReversePostorder;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n-use syntax::ast::LitKind;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -678,7 +676,6 @@ struct Checker<'a, 'tcx> {\n     rpo: ReversePostorder<'a, 'tcx>,\n \n     temp_promotion_state: IndexVec<Local, TempState>,\n-    promotion_candidates: Vec<Candidate>,\n     unchecked_promotion_candidates: Vec<Candidate>,\n \n     /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n@@ -748,7 +745,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             def_id,\n             rpo,\n             temp_promotion_state: temps,\n-            promotion_candidates: vec![],\n             unchecked_promotion_candidates,\n             errors: vec![],\n             suppress_errors: false,\n@@ -794,7 +790,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         let mut qualifs = self.qualifs_in_value(source);\n \n         match source {\n-            ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) => {\n+            ValueSource::Rvalue(&Rvalue::Ref(_, kind, _)) => {\n                 // Getting `true` from `HasMutInterior::in_rvalue` means\n                 // the borrowed place is disallowed from being borrowed,\n                 // due to either a mutable borrow (with some exceptions),\n@@ -833,57 +829,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n-                    // Don't promote BorrowKind::Shallow borrows, as they don't\n-                    // reach codegen.\n-                    // FIXME(eddyb) the two other kinds of borrow (`Shallow` and `Unique`)\n-                    // aren't promoted here but *could* be promoted as part of a larger\n-                    // value because `IsNotPromotable` isn't being set for them,\n-                    // need to figure out what is the intended behavior.\n-\n-                    // We might have a candidate for promotion.\n-                    let candidate = Candidate::Ref(location);\n-                    // Start by traversing to the \"base\", with non-deref projections removed.\n-                    let deref_proj =\n-                        place.projection.iter().rev().find(|&elem| *elem == ProjectionElem::Deref);\n-\n-                    debug!(\n-                        \"qualify_consts: promotion candidate: place={:?} {:?}\",\n-                        place.base, deref_proj\n-                    );\n-                    // We can only promote interior borrows of promotable temps (non-temps\n-                    // don't get promoted anyway).\n-                    // (If we bailed out of the loop due to a `Deref` above, we will definitely\n-                    // not enter the conditional here.)\n-                    if let (PlaceBase::Local(local), None) = (&place.base, deref_proj) {\n-                        if self.body.local_kind(*local) == LocalKind::Temp {\n-                            debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n-                            // The borrowed place doesn't have `HasMutInterior`\n-                            // (from `in_rvalue`), so we can safely ignore\n-                            // `HasMutInterior` from the local's qualifications.\n-                            // This allows borrowing fields which don't have\n-                            // `HasMutInterior`, from a type that does, e.g.:\n-                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                            let mut local_qualifs = self.qualifs_in_local(*local);\n-                            // Any qualifications, except HasMutInterior (see above), disqualify\n-                            // from promotion.\n-                            // This is, in particular, the \"implicit promotion\" version of\n-                            // the check making sure that we don't run drop glue during const-eval.\n-                            local_qualifs[HasMutInterior] = false;\n-                            if !local_qualifs.0.iter().any(|&qualif| qualif) {\n-                                debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n-                                self.promotion_candidates.push(candidate);\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            ValueSource::Rvalue(&Rvalue::Repeat(ref operand, _)) => {\n-                debug!(\"assign: self.cx.mode={:?} self.def_id={:?} location={:?} operand={:?}\",\n-                       self.cx.mode, self.def_id, location, operand);\n-                if self.should_promote_repeat_expression(operand) &&\n-                        self.tcx.features().const_in_array_repeat_expressions {\n-                    self.promotion_candidates.push(Candidate::Repeat(location));\n                 }\n             },\n             _ => {},\n@@ -1047,22 +992,17 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n \n-        // HACK(eddyb) don't try to validate promotion candidates if any\n-        // parts of the control-flow graph were skipped due to an error.\n-        let promotion_candidates = if has_controlflow_error {\n-            let unleash_miri = self\n-                .tcx\n-                .sess\n-                .opts\n-                .debugging_opts\n-                .unleash_the_miri_inside_of_you;\n-            if !unleash_miri {\n-                self.tcx.sess.delay_span_bug(\n-                    body.span,\n-                    \"check_const: expected control-flow error(s)\",\n-                );\n-            }\n-            self.promotion_candidates.clone()\n+        // HACK: if parts of the control-flow graph were skipped due to an error, don't try to\n+        // promote anything, since that can cause errors in a `const` if e.g. rvalue static\n+        // promotion is attempted within a loop body.\n+        let unleash_miri = self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n+        let promotion_candidates = if has_controlflow_error && !unleash_miri {\n+            self.tcx.sess.delay_span_bug(\n+                body.span,\n+                \"check_const: expected control-flow error(s)\",\n+            );\n+\n+            vec![]\n         } else {\n             promote_consts::validate_candidates(\n                 self.tcx,\n@@ -1111,15 +1051,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n     }\n-\n-    /// Returns `true` if the operand of a repeat expression is promotable.\n-    fn should_promote_repeat_expression(&self, operand: &Operand<'tcx>) -> bool {\n-        let not_promotable = IsNotImplicitlyPromotable::in_operand(self, operand) ||\n-                             IsNotPromotable::in_operand(self, operand);\n-        debug!(\"should_promote_repeat_expression: operand={:?} not_promotable={:?}\",\n-               operand, not_promotable);\n-        !not_promotable\n-    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n@@ -1431,11 +1362,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             }\n \n             let fn_ty = func.ty(self.body, self.tcx);\n-            let mut callee_def_id = None;\n-            let mut is_shuffle = false;\n             match fn_ty.kind {\n                 ty::FnDef(def_id, _) => {\n-                    callee_def_id = Some(def_id);\n                     match self.tcx.fn_sig(def_id).abi() {\n                         Abi::RustIntrinsic |\n                         Abi::PlatformIntrinsic => {\n@@ -1459,10 +1387,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     }\n                                 }\n \n-                                name if name.starts_with(\"simd_shuffle\") => {\n-                                    is_shuffle = true;\n-                                }\n-\n                                 // no need to check feature gates, intrinsics are only callable\n                                 // from the libstd or with forever unstable feature gates\n                                 _ => {}\n@@ -1550,36 +1474,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n             }\n \n-            // No need to do anything in constants and statics, as everything is \"constant\" anyway\n-            // so promotion would be useless.\n-            if self.mode != Mode::Static && self.mode != Mode::Const {\n-                let constant_args = callee_def_id.and_then(|id| {\n-                    args_required_const(self.tcx, id)\n-                }).unwrap_or_default();\n-                for (i, arg) in args.iter().enumerate() {\n-                    if !(is_shuffle && i == 2 || constant_args.contains(&i)) {\n-                        continue;\n-                    }\n-\n-                    let candidate = Candidate::Argument { bb: location.block, index: i };\n-                    // Since the argument is required to be constant,\n-                    // we care about constness, not promotability.\n-                    // If we checked for promotability, we'd miss out on\n-                    // the results of function calls (which are never promoted\n-                    // in runtime code).\n-                    // This is not a problem, because the argument explicitly\n-                    // requests constness, in contrast to regular promotion\n-                    // which happens even without the user requesting it.\n-                    //\n-                    // `promote_consts` is responsible for emitting the error if\n-                    // the argument is not promotable.\n-                    if !IsNotPromotable::in_operand(self, arg) {\n-                        debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n-                        self.promotion_candidates.push(candidate);\n-                    }\n-                }\n-            }\n-\n             // Check callee and argument operands.\n             self.visit_operand(func, location);\n             for arg in args {\n@@ -1887,19 +1781,6 @@ fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId)\n     });\n }\n \n-fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n-    let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n-    let mut ret = FxHashSet::default();\n-    for meta in attr.meta_item_list()? {\n-        match meta.literal()?.kind {\n-            LitKind::Int(a, _) => { ret.insert(a as usize); }\n-            _ => return None,\n-        }\n-    }\n-    Some(ret)\n-}\n-\n fn validator_mismatch(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,"}]}