{"sha": "d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YjZiOTVhZWY5NDE2OWI1ZGJlNGRiYjEzNTdkNGJhYjFmYzk4MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-18T08:56:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-18T08:56:12Z"}, "message": "Auto merge of #52553 - Pazzaz:vecdeque-append, r=SimonSapin\n\nNon-naive implementation of `VecDeque.append`\n\nReplaces the old, simple implementation with a more manual (and **unsafe** \ud83d\ude31) one. I've added 1 more test and verified that it covers all 6 code paths in the function.\n\nThis new implementation was about 60% faster than the old naive one when I tried benchmarking it.", "tree": {"sha": "3e481559470fb4d3e90f4a5f5b59067fbd3c1208", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e481559470fb4d3e90f4a5f5b59067fbd3c1208"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800", "html_url": "https://github.com/rust-lang/rust/commit/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b1ff19af36f7bbf1974579ec1b9bf2c8ccd595e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b1ff19af36f7bbf1974579ec1b9bf2c8ccd595e", "html_url": "https://github.com/rust-lang/rust/commit/6b1ff19af36f7bbf1974579ec1b9bf2c8ccd595e"}, {"sha": "b063bd4616bf2f27b814f39f0e452efd171fd539", "url": "https://api.github.com/repos/rust-lang/rust/commits/b063bd4616bf2f27b814f39f0e452efd171fd539", "html_url": "https://github.com/rust-lang/rust/commit/b063bd4616bf2f27b814f39f0e452efd171fd539"}], "stats": {"total": 315, "additions": 313, "deletions": 2}, "files": [{"sha": "1dad323769a07b95f0ae315544cc68dd26df1b4f", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800", "patch": "@@ -23,3 +23,8 @@ path = \"../liballoc/tests/lib.rs\"\n [[bench]]\n name = \"collectionsbenches\"\n path = \"../liballoc/benches/lib.rs\"\n+\n+[[bench]]\n+name = \"vec_deque_append_bench\"\n+path = \"../liballoc/benches/vec_deque_append.rs\"\n+harness = false"}, {"sha": "bd33565113752d1c9d5ecbd97afc1488fde75fd8", "filename": "src/liballoc/benches/vec_deque_append.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs?ref=d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(duration_as_u128)]\n+use std::{collections::VecDeque, time::Instant};\n+\n+const VECDEQUE_LEN: i32 = 100000;\n+const WARMUP_N: usize = 100;\n+const BENCH_N: usize = 1000;\n+\n+fn main() {\n+    let a: VecDeque<i32> = (0..VECDEQUE_LEN).collect();\n+    let b: VecDeque<i32> = (0..VECDEQUE_LEN).collect();\n+\n+    for _ in 0..WARMUP_N {\n+        let mut c = a.clone();\n+        let mut d = b.clone();\n+        c.append(&mut d);\n+    }\n+\n+    let mut durations = Vec::with_capacity(BENCH_N);\n+\n+    for _ in 0..BENCH_N {\n+        let mut c = a.clone();\n+        let mut d = b.clone();\n+        let before = Instant::now();\n+        c.append(&mut d);\n+        let after = Instant::now();\n+        durations.push(after.duration_since(before));\n+    }\n+\n+    let l = durations.len();\n+    durations.sort();\n+\n+    assert!(BENCH_N % 2 == 0);\n+    let median = (durations[(l / 2) - 1] + durations[l / 2]) / 2;\n+    println!(\n+        \"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\",\n+        median.as_nanos()\n+    );\n+}"}, {"sha": "0f759bb8f0b4f9e2f97daf96ca4c6919e75d82cc", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 159, "deletions": 2, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800", "patch": "@@ -202,6 +202,23 @@ impl<T> VecDeque<T> {\n                                  len);\n     }\n \n+    /// Returns a pair of slices which contain the contents of the buffer not used by the VecDeque.\n+    #[inline]\n+    unsafe fn unused_as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n+        let head = self.head;\n+        let tail = self.tail;\n+        let buf = self.buffer_as_mut_slice();\n+        if head != tail {\n+            // In buf, head..tail contains the VecDeque and tail..head is unused.\n+            // So calling `ring_slices` with tail and head swapped returns unused slices.\n+            RingSlices::ring_slices(buf, tail, head)\n+        } else {\n+            // Swapping doesn't help when head == tail.\n+            let (before, after) = buf.split_at_mut(head);\n+            (after, before)\n+        }\n+    }\n+\n     /// Copies a potentially wrapping block of memory len long from src to dest.\n     /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n     /// most one continuous overlapping region between src and dest).\n@@ -1834,8 +1851,148 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        // naive impl\n-        self.extend(other.drain(..));\n+        // Copies all values from `src_slice` to the start of `dst_slice`.\n+        unsafe fn copy_whole_slice<T>(src_slice: &[T], dst_slice: &mut [T]) {\n+            let len = src_slice.len();\n+            ptr::copy_nonoverlapping(src_slice.as_ptr(), dst_slice[..len].as_mut_ptr(), len);\n+        }\n+\n+        let src_total = other.len();\n+\n+        // Guarantees there is space in `self` for `other`.\n+        self.reserve(src_total);\n+\n+        self.head = {\n+            let original_head = self.head;\n+\n+            // The goal is to copy all values from `other` into `self`. To avoid any\n+            // mismatch, all valid values in `other` are retrieved...\n+            let (src_high, src_low) = other.as_slices();\n+            // and unoccupied parts of self are retrieved.\n+            let (dst_high, dst_low) = unsafe { self.unused_as_mut_slices() };\n+\n+            // Then all that is needed is to copy all values from\n+            // src (src_high and src_low) to dst (dst_high and dst_low).\n+            //\n+            // other [o o o . . . . . o o o o]\n+            //       [5 6 7]         [1 2 3 4]\n+            //       src_low         src_high\n+            //\n+            // self  [. . . . . . o o o o . .]\n+            //       [3 4 5 6 7 .]       [1 2]\n+            //       dst_low             dst_high\n+            //\n+            // Values are not copied one by one but as slices in `copy_whole_slice`.\n+            // What slices are used depends on various properties of src and dst.\n+            // There are 6 cases in total:\n+            //     1. `src` is contiguous and fits in dst_high\n+            //     2. `src` is contiguous and does not fit in dst_high\n+            //     3. `src` is discontiguous and fits in dst_high\n+            //     4. `src` is discontiguous and does not fit in dst_high\n+            //        + src_high is smaller than dst_high\n+            //     5. `src` is discontiguous and does not fit in dst_high\n+            //        + dst_high is smaller than src_high\n+            //     6. `src` is discontiguous and does not fit in dst_high\n+            //        + dst_high is the same size as src_high\n+            let src_contiguous = src_low.is_empty();\n+            let dst_high_fits_src = dst_high.len() >= src_total;\n+            match (src_contiguous, dst_high_fits_src) {\n+                (true, true) => {\n+                    // 1.\n+                    // other [. . . o o o . . . . . .]\n+                    //       []    [1 1 1]\n+                    //\n+                    // self  [. o o o o o . . . . . .]\n+                    //       [.]         [1 1 1 . . .]\n+\n+                    unsafe {\n+                        copy_whole_slice(src_high, dst_high);\n+                    }\n+                    original_head + src_total\n+                }\n+                (true, false) => {\n+                    // 2.\n+                    // other [. . . o o o o o . . . .]\n+                    //       []    [1 1 2 2 2]\n+                    //\n+                    // self  [. . . . . . . o o o . .]\n+                    //       [2 2 2 . . . .]     [1 1]\n+\n+                    let (src_1, src_2) = src_high.split_at(dst_high.len());\n+                    unsafe {\n+                        copy_whole_slice(src_1, dst_high);\n+                        copy_whole_slice(src_2, dst_low);\n+                    }\n+                    src_total - dst_high.len()\n+                }\n+                (false, true) => {\n+                    // 3.\n+                    // other [o o . . . . . . . o o o]\n+                    //       [2 2]             [1 1 1]\n+                    //\n+                    // self  [. o o . . . . . . . . .]\n+                    //       [.]   [1 1 1 2 2 . . . .]\n+\n+                    let (dst_1, dst_2) = dst_high.split_at_mut(src_high.len());\n+                    unsafe {\n+                        copy_whole_slice(src_high, dst_1);\n+                        copy_whole_slice(src_low, dst_2);\n+                    }\n+                    original_head + src_total\n+                }\n+                (false, false) => {\n+                    if src_high.len() < dst_high.len() {\n+                        // 4.\n+                        // other [o o o . . . . . . o o o]\n+                        //       [2 3 3]           [1 1 1]\n+                        //\n+                        // self  [. . . . . . o o . . . .]\n+                        //       [3 3 . . . .]   [1 1 1 2]\n+\n+                        let (dst_1, dst_2) = dst_high.split_at_mut(src_high.len());\n+                        let (src_2, src_3) = src_low.split_at(dst_2.len());\n+                        unsafe {\n+                            copy_whole_slice(src_high, dst_1);\n+                            copy_whole_slice(src_2, dst_2);\n+                            copy_whole_slice(src_3, dst_low);\n+                        }\n+                        src_3.len()\n+                    } else if src_high.len() > dst_high.len() {\n+                        // 5.\n+                        // other [o o o . . . . . o o o o]\n+                        //       [3 3 3]         [1 1 2 2]\n+                        //\n+                        // self  [. . . . . . o o o o . .]\n+                        //       [2 2 3 3 3 .]       [1 1]\n+\n+                        let (src_1, src_2) = src_high.split_at(dst_high.len());\n+                        let (dst_2, dst_3) = dst_low.split_at_mut(src_2.len());\n+                        unsafe {\n+                            copy_whole_slice(src_1, dst_high);\n+                            copy_whole_slice(src_2, dst_2);\n+                            copy_whole_slice(src_low, dst_3);\n+                        }\n+                        dst_2.len() + src_low.len()\n+                    } else {\n+                        // 6.\n+                        // other [o o . . . . . . . o o o]\n+                        //       [2 2]             [1 1 1]\n+                        //\n+                        // self  [. . . . . . . o o . . .]\n+                        //       [2 2 . . . . .]   [1 1 1]\n+\n+                        unsafe {\n+                            copy_whole_slice(src_high, dst_high);\n+                            copy_whole_slice(src_low, dst_low);\n+                        }\n+                        src_low.len()\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Some values now exist in both `other` and `self` but are made inaccessible in `other`.\n+        other.tail = other.head;\n     }\n \n     /// Retains only the elements specified by the predicate."}, {"sha": "3ea6c87a6516939ecca7ec94a41b162ba5cd18fc", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=d5b6b95aef94169b5dbe4dbb1357d4bab1fc9800", "patch": "@@ -928,6 +928,107 @@ fn test_append() {\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), []);\n }\n \n+#[test]\n+fn test_append_permutations() {\n+    fn construct_vec_deque(\n+        push_back: usize,\n+        pop_back: usize,\n+        push_front: usize,\n+        pop_front: usize,\n+    ) -> VecDeque<usize> {\n+        let mut out = VecDeque::new();\n+        for a in 0..push_back {\n+            out.push_back(a);\n+        }\n+        for b in 0..push_front {\n+            out.push_front(push_back + b);\n+        }\n+        for _ in 0..pop_back {\n+            out.pop_back();\n+        }\n+        for _ in 0..pop_front {\n+            out.pop_front();\n+        }\n+        out\n+    }\n+\n+    const MAX: usize = 5;\n+\n+    // Many different permutations of both the `VecDeque` getting appended to\n+    // and the one getting appended are generated to check `append`.\n+    // This ensures all 6 code paths of `append` are tested.\n+    for src_push_back in 0..MAX {\n+        for src_push_front in 0..MAX {\n+            // doesn't pop more values than are pushed\n+            for src_pop_back in 0..(src_push_back + src_push_front) {\n+                for src_pop_front in 0..(src_push_back + src_push_front - src_pop_back) {\n+\n+                    let src = construct_vec_deque(\n+                        src_push_back,\n+                        src_pop_back,\n+                        src_push_front,\n+                        src_pop_front,\n+                    );\n+\n+                    for dst_push_back in 0..MAX {\n+                        for dst_push_front in 0..MAX {\n+                            for dst_pop_back in 0..(dst_push_back + dst_push_front) {\n+                                for dst_pop_front\n+                                    in 0..(dst_push_back + dst_push_front - dst_pop_back)\n+                                {\n+                                    let mut dst = construct_vec_deque(\n+                                        dst_push_back,\n+                                        dst_pop_back,\n+                                        dst_push_front,\n+                                        dst_pop_front,\n+                                    );\n+                                    let mut src = src.clone();\n+\n+                                    // Assert that appending `src` to `dst` gives the same order\n+                                    // of values as iterating over both in sequence.\n+                                    let correct = dst\n+                                        .iter()\n+                                        .chain(src.iter())\n+                                        .cloned()\n+                                        .collect::<Vec<usize>>();\n+                                    dst.append(&mut src);\n+                                    assert_eq!(dst, correct);\n+                                    assert!(src.is_empty());\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct DropCounter<'a> {\n+    count: &'a mut u32,\n+}\n+\n+impl<'a> Drop for DropCounter<'a> {\n+    fn drop(&mut self) {\n+        *self.count += 1;\n+    }\n+}\n+\n+#[test]\n+fn test_append_double_drop() {\n+    let (mut count_a, mut count_b) = (0, 0);\n+    {\n+        let mut a = VecDeque::new();\n+        let mut b = VecDeque::new();\n+        a.push_back(DropCounter { count: &mut count_a });\n+        b.push_back(DropCounter { count: &mut count_b });\n+\n+        a.append(&mut b);\n+    }\n+    assert_eq!(count_a, 1);\n+    assert_eq!(count_b, 1);\n+}\n+\n #[test]\n fn test_retain() {\n     let mut buf = VecDeque::new();"}]}