{"sha": "a9619306a512ded537a84a45c7717f32f468d31b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NjE5MzA2YTUxMmRlZDUzN2E4NGE0NWM3NzE3ZjMyZjQ2OGQzMWI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-30T18:10:01Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-30T19:38:28Z"}, "message": "Start moving core::hash to support a Hash trait. Add to_bytes::IterBytes trait.", "tree": {"sha": "55b5484d0ac9166b5b70988b92a7bdd3bf0f4d4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55b5484d0ac9166b5b70988b92a7bdd3bf0f4d4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9619306a512ded537a84a45c7717f32f468d31b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9619306a512ded537a84a45c7717f32f468d31b", "html_url": "https://github.com/rust-lang/rust/commit/a9619306a512ded537a84a45c7717f32f468d31b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9619306a512ded537a84a45c7717f32f468d31b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab53819a2cbbfbc2df7a3aea4e9a0b52dfb830dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab53819a2cbbfbc2df7a3aea4e9a0b52dfb830dc", "html_url": "https://github.com/rust-lang/rust/commit/ab53819a2cbbfbc2df7a3aea4e9a0b52dfb830dc"}], "stats": {"total": 442, "additions": 408, "deletions": 34}, "files": [{"sha": "0e9c9110c8e301b9b087dc2c45fb8ea06e7c0045", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 102, "deletions": 20, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a9619306a512ded537a84a45c7717f32f468d31b/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9619306a512ded537a84a45c7717f32f468d31b/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=a9619306a512ded537a84a45c7717f32f468d31b", "patch": "@@ -15,6 +15,7 @@\n \n import io::Writer;\n import io::WriterUtil;\n+import to_bytes::IterBytes;\n \n export Streaming, State;\n export default_state;\n@@ -33,6 +34,21 @@ export hash_u16;\n export hash_u8;\n export hash_uint;\n \n+/// Types that can meaningfully be hashed should implement this.\n+trait Hash {\n+    pure fn hash_keyed(k0: u64, k1: u64) -> u64;\n+}\n+\n+// When we have default methods, won't need this.\n+trait HashUtil {\n+    pure fn hash() -> u64;\n+}\n+\n+impl <A: Hash> A: HashUtil {\n+    #[inline(always)]\n+    pure fn hash() -> u64 { self.hash_keyed(0,0) }\n+}\n+\n /// Streaming hash-functions should implement this.\n trait Streaming {\n     fn input((&[const u8]));\n@@ -43,38 +59,97 @@ trait Streaming {\n     fn reset();\n }\n \n-fn keyed(k0: u64, k1: u64, f: fn(s: &State)) -> u64 {\n-    let s = &State(k0, k1);\n-    f(s);\n-    s.result_u64()\n+impl <A: IterBytes> A: Hash {\n+    #[inline(always)]\n+    pure fn hash_keyed(k0: u64, k1: u64) -> u64 {\n+        unchecked {\n+            let s = &State(k0, k1);\n+            for self.iter_le_bytes |bytes| {\n+                s.input(bytes);\n+            }\n+            s.result_u64()\n+        }\n+    }\n }\n \n-pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n-    unchecked { keyed(k0, k1, |s| s.input(buf)) }\n+// implementations\n+\n+pure fn hash_keyed_2<A: IterBytes,\n+                     B: IterBytes>(a: &A, b: &B,\n+                                   k0: u64, k1: u64) -> u64 {\n+    unchecked {\n+        let s = &State(k0, k1);\n+        for a.iter_le_bytes |bytes| { s.input(bytes); }\n+        for b.iter_le_bytes |bytes| { s.input(bytes); }\n+        s.result_u64()\n+    }\n }\n-pure fn hash_str_keyed(s: &str, k0: u64, k1: u64) -> u64 {\n-    unsafe {\n-        do str::as_buf(s) |buf, len| {\n-            do vec::unsafe::form_slice(buf, len) |slice| {\n-                hash_bytes_keyed(slice, k0, k1)\n-            }\n-        }\n+\n+pure fn hash_keyed_3<A: IterBytes,\n+                     B: IterBytes,\n+                     C: IterBytes>(a: &A, b: &B, c: &C,\n+                                   k0: u64, k1: u64) -> u64 {\n+    unchecked {\n+        let s = &State(k0, k1);\n+        for a.iter_le_bytes |bytes| { s.input(bytes); }\n+        for b.iter_le_bytes |bytes| { s.input(bytes); }\n+        for c.iter_le_bytes |bytes| { s.input(bytes); }\n+        s.result_u64()\n+    }\n+}\n+\n+pure fn hash_keyed_4<A: IterBytes,\n+                     B: IterBytes,\n+                     C: IterBytes,\n+                     D: IterBytes>(a: &A, b: &B, c: &C, d: &D,\n+                                   k0: u64, k1: u64) -> u64 {\n+    unchecked {\n+        let s = &State(k0, k1);\n+        for a.iter_le_bytes |bytes| { s.input(bytes); }\n+        for b.iter_le_bytes |bytes| { s.input(bytes); }\n+        for c.iter_le_bytes |bytes| { s.input(bytes); }\n+        for d.iter_le_bytes |bytes| { s.input(bytes); }\n+        s.result_u64()\n+    }\n+}\n+\n+pure fn hash_keyed_5<A: IterBytes,\n+                     B: IterBytes,\n+                     C: IterBytes,\n+                     D: IterBytes,\n+                     E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n+                                   k0: u64, k1: u64) -> u64 {\n+    unchecked {\n+        let s = &State(k0, k1);\n+        for a.iter_le_bytes |bytes| { s.input(bytes); }\n+        for b.iter_le_bytes |bytes| { s.input(bytes); }\n+        for c.iter_le_bytes |bytes| { s.input(bytes); }\n+        for d.iter_le_bytes |bytes| { s.input(bytes); }\n+        for e.iter_le_bytes |bytes| { s.input(bytes); }\n+        s.result_u64()\n     }\n }\n+\n+pure fn hash_bytes_keyed(val: &[const u8], k0: u64, k1: u64) -> u64 {\n+    val.hash_keyed(k0, k1)\n+}\n+pure fn hash_str_keyed(val: &str, k0: u64, k1: u64) -> u64 {\n+    val.hash_keyed(k0, k1)\n+}\n pure fn hash_u64_keyed(val: u64, k0: u64, k1: u64) -> u64 {\n-    unchecked { keyed(k0, k1, |s| s.write_le_u64(val)) }\n+    val.hash_keyed(k0, k1)\n }\n pure fn hash_u32_keyed(val: u32, k0: u64, k1: u64) -> u64 {\n-    unchecked { keyed(k0, k1, |s| s.write_le_u32(val)) }\n+    val.hash_keyed(k0, k1)\n }\n pure fn hash_u16_keyed(val: u16, k0: u64, k1: u64) -> u64 {\n-    unchecked { keyed(k0, k1, |s| s.write_le_u16(val)) }\n+    val.hash_keyed(k0, k1)\n }\n pure fn hash_u8_keyed(val: u8, k0: u64, k1: u64) -> u64 {\n-    unchecked { keyed(k0, k1, |s| s.write_u8(val)) }\n+    val.hash_keyed(k0, k1)\n }\n pure fn hash_uint_keyed(val: uint, k0: u64, k1: u64) -> u64 {\n-    unchecked { keyed(k0, k1, |s| s.write_le_uint(val)) }\n+    val.hash_keyed(k0, k1)\n }\n \n pure fn hash_bytes(val: &[const u8]) -> u64 { hash_bytes_keyed(val, 0, 0) }\n@@ -89,10 +164,13 @@ pure fn hash_uint(val: uint) -> u64 { hash_uint_keyed(val, 0, 0) }\n // Implement State as SipState\n \n type State = SipState;\n+\n+#[inline(always)]\n fn State(k0: u64, k1: u64) -> State {\n     SipState(k0, k1)\n }\n \n+#[inline(always)]\n fn default_state() -> State {\n     State(0,0)\n }\n@@ -109,6 +187,7 @@ struct SipState {\n     mut ntail: uint;  // how many bytes in tail are valid\n }\n \n+#[inline(always)]\n fn SipState(key0: u64, key1: u64) -> SipState {\n     let state = SipState {\n         k0 : key0,\n@@ -129,6 +208,7 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n impl &SipState : io::Writer {\n \n     // Methods for io::writer\n+    #[inline(always)]\n     fn write(msg: &[const u8]) {\n \n         macro_rules! u8to64_le (\n@@ -235,10 +315,12 @@ impl &SipState : io::Writer {\n \n impl &SipState : Streaming {\n \n+    #[inline(always)]\n     fn input(buf: &[const u8]) {\n         self.write(buf);\n     }\n \n+    #[inline(always)]\n     fn result_u64() -> u64 {\n         let mut v0 = self.v0;\n         let mut v1 = self.v1;\n@@ -269,7 +351,6 @@ impl &SipState : Streaming {\n         return (v0 ^ v1 ^ v2 ^ v3);\n     }\n \n-\n     fn result_bytes() -> ~[u8] {\n         let h = self.result_u64();\n         ~[(h >> 0) as u8,\n@@ -290,6 +371,7 @@ impl &SipState : Streaming {\n         return s;\n     }\n \n+    #[inline(always)]\n     fn reset() {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;\n@@ -385,7 +467,7 @@ fn test_siphash() {\n     while t < 64 {\n         debug!(\"siphash test %?\", t);\n         let vec = u8to64_le!(vecs[t], 0);\n-        let out = hash_bytes_keyed(buf, k0, k1);\n+        let out = buf.hash_keyed(k0, k1);\n         debug!(\"got %?, expected %?\", out, vec);\n         assert vec == out;\n "}, {"sha": "f4305a7491747c42aea28659417cbff0e105dddb", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 302, "deletions": 10, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/a9619306a512ded537a84a45c7717f32f468d31b/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9619306a512ded537a84a45c7717f32f468d31b/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=a9619306a512ded537a84a45c7717f32f468d31b", "patch": "@@ -2,22 +2,314 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-trait ToBytes {\n-    fn to_bytes() -> ~[u8];\n+import io::Writer;\n+\n+type Cb = fn(buf: &[const u8]) -> bool;\n+\n+trait IterBytes {\n+    fn iter_le_bytes(f: Cb);\n+    fn iter_be_bytes(f: Cb);\n+}\n+\n+impl u8: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        f([\n+            self,\n+        ]);\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        f([\n+            self as u8\n+        ]);\n+    }\n+}\n+\n+impl u16: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        f([\n+            self as u8,\n+            (self >> 8) as u8\n+        ]);\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        f([\n+            (self >> 8) as u8,\n+            self as u8\n+        ]);\n+    }\n+}\n+\n+impl u32: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        f([\n+            self as u8,\n+            (self >> 8) as u8,\n+            (self >> 16) as u8,\n+            (self >> 24) as u8,\n+        ]);\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        f([\n+            (self >> 24) as u8,\n+            (self >> 16) as u8,\n+            (self >> 8) as u8,\n+            self as u8\n+        ]);\n+    }\n+}\n+\n+impl u64: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        f([\n+            self as u8,\n+            (self >> 8) as u8,\n+            (self >> 16) as u8,\n+            (self >> 24) as u8,\n+            (self >> 32) as u8,\n+            (self >> 40) as u8,\n+            (self >> 48) as u8,\n+            (self >> 56) as u8\n+        ]);\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        f([\n+            (self >> 56) as u8,\n+            (self >> 48) as u8,\n+            (self >> 40) as u8,\n+            (self >> 32) as u8,\n+            (self >> 24) as u8,\n+            (self >> 16) as u8,\n+            (self >> 8) as u8,\n+            self as u8\n+        ]);\n+    }\n+}\n+\n+impl i8: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { (self as u8).iter_le_bytes(f) }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { (self as u8).iter_be_bytes(f) }\n+}\n+\n+impl i16: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { (self as u16).iter_le_bytes(f) }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { (self as u16).iter_be_bytes(f) }\n+}\n+\n+impl i32: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { (self as u32).iter_le_bytes(f) }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { (self as u32).iter_be_bytes(f) }\n+}\n+\n+impl i64: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { (self as u64).iter_le_bytes(f) }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { (self as u64).iter_be_bytes(f) }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl uint: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { (self as u32).iter_le_bytes(f) }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { (self as u32).iter_be_bytes(f) }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl uint: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { (self as u64).iter_le_bytes(f) }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { (self as u64).iter_be_bytes(f) }\n+}\n+\n+impl int: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { (self as uint).iter_le_bytes(f) }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { (self as uint).iter_be_bytes(f) }\n }\n \n-impl ~[u8]: ToBytes {\n-    fn to_bytes() -> ~[u8] { copy self }\n+impl ~[const u8]: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { f(self); }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { f(self); }\n }\n \n-impl @~[u8]: ToBytes {\n-    fn to_bytes() -> ~[u8] { copy *self }\n+impl @[const u8]: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) { f(self); }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) { f(self); }\n }\n \n-impl ~str: ToBytes {\n-    fn to_bytes() -> ~[u8] { str::to_bytes(self) }\n+impl<A: IterBytes> &[const A]: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        for self.each |elt| {\n+            do elt.iter_le_bytes |bytes| {\n+                f(bytes)\n+            }\n+        }\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        for self.each |elt| {\n+            do elt.iter_be_bytes |bytes| {\n+                f(bytes)\n+            }\n+        }\n+    }\n }\n \n-impl @(~str): ToBytes {\n-    fn to_bytes() -> ~[u8] { str::to_bytes(*self) }\n+fn iter_le_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B, f: Cb) {\n+    let mut flag = true;\n+    a.iter_le_bytes(|bytes| {flag = f(bytes); flag});\n+    if !flag { return; }\n+    b.iter_le_bytes(|bytes| {flag = f(bytes); flag});\n+}\n+\n+fn iter_be_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B, f: Cb) {\n+    let mut flag = true;\n+    a.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+    if !flag { return; }\n+    b.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+}\n+\n+fn iter_le_bytes_3<A: IterBytes,\n+                   B: IterBytes,\n+                   C: IterBytes>(a: &A, b: &B, c: &C, f: Cb) {\n+    let mut flag = true;\n+    a.iter_le_bytes(|bytes| {flag = f(bytes); flag});\n+    if !flag { return; }\n+    b.iter_le_bytes(|bytes| { flag = f(bytes); flag});\n+    if !flag { return; }\n+    c.iter_le_bytes(|bytes| {flag = f(bytes); flag});\n+}\n+\n+fn iter_be_bytes_3<A: IterBytes,\n+                   B: IterBytes,\n+                   C: IterBytes>(a: &A, b: &B, c: &C, f: Cb) {\n+    let mut flag = true;\n+                       a.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+    if !flag { return; }\n+                       b.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+    if !flag { return; }\n+                       c.iter_be_bytes(|bytes| {flag = f(bytes); flag});\n+}\n+\n+impl &str: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        do str::byte_slice(self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        do str::byte_slice(self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+}\n+\n+impl ~str: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        do str::byte_slice(self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        do str::byte_slice(self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+}\n+\n+impl @str: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        do str::byte_slice(self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        do str::byte_slice(self) |bytes| {\n+            f(bytes);\n+        }\n+    }\n+}\n+impl<A: IterBytes> &A: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        (*self).iter_le_bytes(f);\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        (*self).iter_be_bytes(f);\n+    }\n+}\n+\n+impl<A: IterBytes> @A: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        (*self).iter_le_bytes(f);\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        (*self).iter_be_bytes(f);\n+    }\n+}\n+\n+impl<A: IterBytes> ~A: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        (*self).iter_le_bytes(f);\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        (*self).iter_be_bytes(f);\n+    }\n+}\n+\n+\n+trait ToBytes {\n+    fn to_le_bytes() -> ~[u8];\n+    fn to_be_bytes() -> ~[u8];\n+}\n+\n+impl<A: IterBytes> A: ToBytes {\n+    fn to_le_bytes() -> ~[u8] {\n+        let buf = io::mem_buffer();\n+        for self.iter_le_bytes |bytes| {\n+            buf.write(bytes)\n+        }\n+        io::mem_buffer_buf(buf)\n+    }\n+    fn to_be_bytes() -> ~[u8] {\n+        let buf = io::mem_buffer();\n+        for self.iter_be_bytes |bytes| {\n+            buf.write(bytes)\n+        }\n+        io::mem_buffer_buf(buf)\n+    }\n+\n }"}, {"sha": "1533b07861c9685302922502e3040011296ae35e", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9619306a512ded537a84a45c7717f32f468d31b/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9619306a512ded537a84a45c7717f32f468d31b/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a9619306a512ded537a84a45c7717f32f468d31b", "patch": "@@ -1168,7 +1168,7 @@ pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn each<T>(v: &[T], f: fn(T) -> bool) {\n+pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n     do vec::as_buf(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n@@ -1206,7 +1206,7 @@ pure fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn eachi<T>(v: &[T], f: fn(uint, T) -> bool) {\n+pure fn eachi<T>(v: &[const T], f: fn(uint, T) -> bool) {\n     do vec::as_buf(v) |p, n| {\n         let mut i = 0u;\n         let mut p = p;\n@@ -1916,12 +1916,12 @@ mod u8 {\n // This cannot be used with iter-trait.rs because of the region pointer\n // required in the slice.\n \n-impl<A> &[A]: iter::BaseIter<A> {\n+impl<A> &[const A]: iter::BaseIter<A> {\n     pure fn each(blk: fn(A) -> bool) { each(self, blk) }\n     pure fn size_hint() -> Option<uint> { Some(len(self)) }\n }\n \n-impl<A> &[A]: iter::ExtendedIter<A> {\n+impl<A> &[const A]: iter::ExtendedIter<A> {\n     pure fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n     pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }"}]}