{"sha": "e3f8beaed6d70d4b990f834fa617149e2bf40a2d", "node_id": "C_kwDOAAsO6NoAKGUzZjhiZWFlZDZkNzBkNGI5OTBmODM0ZmE2MTcxNDllMmJmNDBhMmQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-17T20:45:14Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-25T03:21:22Z"}, "message": "Check that opaque is a defining use, prefer pre-defined opaques", "tree": {"sha": "feb9ee0d4f332a531778a09af70e1ef449ec40be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/feb9ee0d4f332a531778a09af70e1ef449ec40be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3f8beaed6d70d4b990f834fa617149e2bf40a2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f8beaed6d70d4b990f834fa617149e2bf40a2d", "html_url": "https://github.com/rust-lang/rust/commit/e3f8beaed6d70d4b990f834fa617149e2bf40a2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3f8beaed6d70d4b990f834fa617149e2bf40a2d/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3c9c216583d396e717e967becb42ece74651bd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c9c216583d396e717e967becb42ece74651bd0", "html_url": "https://github.com/rust-lang/rust/commit/f3c9c216583d396e717e967becb42ece74651bd0"}], "stats": {"total": 141, "additions": 127, "deletions": 14}, "files": [{"sha": "ba05135638e1f6f1e965dcd227fa08d6cfc94221", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e3f8beaed6d70d4b990f834fa617149e2bf40a2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f8beaed6d70d4b990f834fa617149e2bf40a2d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=e3f8beaed6d70d4b990f834fa617149e2bf40a2d", "patch": "@@ -518,6 +518,42 @@ impl<'tcx> TyCtxt<'tcx> {\n         Ok(())\n     }\n \n+    /// Checks whether each generic argument is simply a unique generic placeholder.\n+    ///\n+    /// This is used in the new solver, which canonicalizes params to placeholders\n+    /// for better caching.\n+    pub fn uses_unique_placeholders_ignoring_regions(\n+        self,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Result<(), NotUniqueParam<'tcx>> {\n+        let mut seen = GrowableBitSet::default();\n+        for arg in substs {\n+            match arg.unpack() {\n+                // Ignore regions, since we can't resolve those in a canonicalized\n+                // query in the trait solver.\n+                GenericArgKind::Lifetime(_) => {}\n+                GenericArgKind::Type(t) => match t.kind() {\n+                    ty::Placeholder(p) => {\n+                        if !seen.insert(p.bound.var) {\n+                            return Err(NotUniqueParam::DuplicateParam(t.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(t.into())),\n+                },\n+                GenericArgKind::Const(c) => match c.kind() {\n+                    ty::ConstKind::Placeholder(p) => {\n+                        if !seen.insert(p.bound) {\n+                            return Err(NotUniqueParam::DuplicateParam(c.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(c.into())),\n+                },\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Returns `true` if `def_id` refers to a closure (e.g., `|x| x * 2`). Note\n     /// that closures have a `DefId`, but the closure *expression* also\n     /// has a `HirId` that is located within the context where the"}, {"sha": "32a8bda2663daf3b0c2b3512bd5e5aff27d122b5", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e3f8beaed6d70d4b990f834fa617149e2bf40a2d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f8beaed6d70d4b990f834fa617149e2bf40a2d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=e3f8beaed6d70d4b990f834fa617149e2bf40a2d", "patch": "@@ -10,7 +10,8 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::solve::{\n-    CanonicalInput, Certainty, MaybeCause, PredefinedOpaques, PredefinedOpaquesData, QueryResult,\n+    CanonicalInput, CanonicalResponse, Certainty, MaybeCause, PredefinedOpaques,\n+    PredefinedOpaquesData, QueryResult,\n };\n use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{\n@@ -726,7 +727,12 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n-    pub(super) fn handle_opaque_ty(\n+    pub(super) fn can_define_opaque_ty(&mut self, def_id: DefId) -> bool {\n+        let Some(def_id) = def_id.as_local() else { return false; };\n+        self.infcx.opaque_type_origin(def_id).is_some()\n+    }\n+\n+    pub(super) fn register_opaque_ty(\n         &mut self,\n         a: Ty<'tcx>,\n         b: Ty<'tcx>,\n@@ -737,4 +743,42 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         self.add_goals(obligations.into_iter().map(|obligation| obligation.into()));\n         Ok(())\n     }\n+\n+    // Do something for each opaque/hidden pair defined with `def_id` in the\n+    // current inference context.\n+    pub(super) fn unify_existing_opaque_tys(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        key: ty::AliasTy<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Vec<CanonicalResponse<'tcx>> {\n+        let Some(def_id) = key.def_id.as_local() else { return vec![]; };\n+\n+        // FIXME: Super inefficient to be cloning this...\n+        let opaques = self.infcx.clone_opaque_types_for_query_response();\n+\n+        let mut values = vec![];\n+        for (candidate_key, candidate_ty) in opaques {\n+            if candidate_key.def_id != def_id {\n+                continue;\n+            }\n+            values.extend(self.probe(|ecx| {\n+                for (a, b) in std::iter::zip(candidate_key.substs, key.substs) {\n+                    ecx.eq(param_env, a, b)?;\n+                }\n+                ecx.eq(param_env, candidate_ty, ty)?;\n+                let mut obl = vec![];\n+                ecx.infcx.add_item_bounds_for_hidden_type(\n+                    candidate_key,\n+                    ObligationCause::dummy(),\n+                    param_env,\n+                    candidate_ty,\n+                    &mut obl,\n+                );\n+                ecx.add_goals(obl.into_iter().map(Into::into));\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }));\n+        }\n+        values\n+    }\n }"}, {"sha": "1d5bb46450c8ee5efc4f2330271b8f3cae22babf", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e3f8beaed6d70d4b990f834fa617149e2bf40a2d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f8beaed6d70d4b990f834fa617149e2bf40a2d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=e3f8beaed6d70d4b990f834fa617149e2bf40a2d", "patch": "@@ -1,6 +1,8 @@\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::traits::solve::{Certainty, Goal, QueryResult};\n-use rustc_middle::traits::Reveal;\n-use rustc_middle::ty::{self};\n+use rustc_middle::traits::{ObligationCause, Reveal};\n+use rustc_middle::ty;\n+use rustc_middle::ty::util::NotUniqueParam;\n \n use super::{EvalCtxt, SolverMode};\n \n@@ -15,22 +17,53 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         match goal.param_env.reveal() {\n             Reveal::UserFacing => match self.solver_mode() {\n-                SolverMode::Normal => self.probe(|ecx| {\n-                    // FIXME: Check that the usage is \"defining\" (all free params), otherwise bail.\n-                    // FIXME: This should probably just check the anchor directly\n+                SolverMode::Normal => {\n+                    // FIXME: at some point we should call queries without defining\n+                    // new opaque types but having the existing opaque type definitions.\n+                    // This will require moving this below \"Prefer opaques registered already\".\n+                    if !self.can_define_opaque_ty(opaque_ty.def_id) {\n+                        return Err(NoSolution);\n+                    }\n+                    // FIXME: This may have issues when the substs contain aliases...\n+                    match self.tcx().uses_unique_placeholders_ignoring_regions(opaque_ty.substs) {\n+                        Err(NotUniqueParam::NotParam(param)) if param.is_non_region_infer() => {\n+                            return self.evaluate_added_goals_and_make_canonical_response(\n+                                Certainty::AMBIGUOUS,\n+                            );\n+                        }\n+                        Err(_) => {\n+                            return Err(NoSolution);\n+                        }\n+                        Ok(()) => {}\n+                    }\n+                    // Prefer opaques registered already.\n+                    let matches = self.unify_existing_opaque_tys(\n+                        goal.param_env,\n+                        opaque_ty,\n+                        expected\n+                    );\n+                    if !matches.is_empty() {\n+                        if let Some(response) = self.try_merge_responses(&matches) {\n+                            return Ok(response);\n+                        } else {\n+                            return self.flounder(&matches);\n+                        }\n+                    }\n+                    // Otherwise, define a new opaque type\n                     let opaque_ty = tcx.mk_opaque(opaque_ty.def_id, opaque_ty.substs);\n-                    ecx.handle_opaque_ty(expected, opaque_ty, goal.param_env)?;\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                }),\n+                    self.register_opaque_ty(expected, opaque_ty, goal.param_env)?;\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n                 SolverMode::Coherence => {\n                     self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n                 }\n             },\n-            Reveal::All => self.probe(|ecx| {\n+            Reveal::All => {\n+                // FIXME: Add an assertion that opaque type storage is empty.\n                 let actual = tcx.type_of(opaque_ty.def_id).subst(tcx, opaque_ty.substs);\n-                ecx.eq(goal.param_env, expected, actual)?;\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            }),\n+                self.eq(goal.param_env, expected, actual)?;\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n         }\n     }\n }"}]}