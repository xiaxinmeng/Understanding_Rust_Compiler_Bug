{"sha": "0da6d42f297642a60f2640ec313b879b376b9ad8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYTZkNDJmMjk3NjQyYTYwZjI2NDBlYzMxM2I4NzliMzc2YjlhZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-26T18:50:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-26T18:50:22Z"}, "message": "Auto merge of #68965 - eddyb:mir-inline-scope, r=nagisa,oli-obk\n\n rustc_mir: track inlined callees in SourceScopeData.\n\nWe now record which MIR scopes are the roots of *other* (inlined) functions's scope trees, which allows us to generate the correct debuginfo in codegen, similar to what LLVM inlining generates.\nThis PR makes the `ui` test `backtrace-debuginfo` pass, if the MIR inliner is turned on by default.\n\nAlso, `#[track_caller]` is now correct in the face of MIR inlining (cc `@anp).`\n\nFixes #76997.\n\nr? `@rust-lang/wg-mir-opt`", "tree": {"sha": "d6272e429e289507cfb80fbb588f98ca468a4c7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6272e429e289507cfb80fbb588f98ca468a4c7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0da6d42f297642a60f2640ec313b879b376b9ad8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0da6d42f297642a60f2640ec313b879b376b9ad8", "html_url": "https://github.com/rust-lang/rust/commit/0da6d42f297642a60f2640ec313b879b376b9ad8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0da6d42f297642a60f2640ec313b879b376b9ad8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35debd4c111610317346f46d791f32551d449bd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/35debd4c111610317346f46d791f32551d449bd8", "html_url": "https://github.com/rust-lang/rust/commit/35debd4c111610317346f46d791f32551d449bd8"}, {"sha": "2b3f00928c3b0db93c87d462a53c9f0df98f3e27", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3f00928c3b0db93c87d462a53c9f0df98f3e27", "html_url": "https://github.com/rust-lang/rust/commit/2b3f00928c3b0db93c87d462a53c9f0df98f3e27"}], "stats": {"total": 1496, "additions": 878, "deletions": 618}, "files": [{"sha": "978ad37c0f3905c11a8c34762c047d7128474a83", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -56,6 +56,7 @@ impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Funclet = <CodegenCx<'ll, 'tcx> as BackendTypes>::Funclet;\n \n     type DIScope = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIScope;\n+    type DILocation = <CodegenCx<'ll, 'tcx> as BackendTypes>::DILocation;\n     type DIVariable = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIVariable;\n }\n "}, {"sha": "7633dd0600d5f2a2b1228f874c533338df84b321", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -80,13 +80,15 @@ impl Funclet<'ll> {\n \n impl BackendTypes for CodegenCx<'ll, 'tcx> {\n     type Value = &'ll Value;\n+    // FIXME(eddyb) replace this with a `Function` \"subclass\" of `Value`.\n     type Function = &'ll Value;\n \n     type BasicBlock = &'ll BasicBlock;\n     type Type = &'ll Type;\n     type Funclet = Funclet<'ll>;\n \n     type DIScope = &'ll llvm::debuginfo::DIScope;\n+    type DILocation = &'ll llvm::debuginfo::DILocation;\n     type DIVariable = &'ll llvm::debuginfo::DIVariable;\n }\n "}, {"sha": "6737872f203ad0c8b443aebc81d29b5b46f797be", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -3,21 +3,26 @@ use super::utils::DIB;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext};\n use rustc_codegen_ssa::traits::*;\n \n+use crate::abi::FnAbi;\n use crate::common::CodegenCx;\n use crate::llvm;\n-use crate::llvm::debuginfo::{DIScope, DISubprogram};\n+use crate::llvm::debuginfo::{DILocation, DIScope};\n use rustc_middle::mir::{Body, SourceScope};\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::{self, Instance};\n use rustc_session::config::DebugInfo;\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n \n /// Produces DIScope DIEs for each MIR Scope which has variables defined in it.\n+// FIXME(eddyb) almost all of this should be in `rustc_codegen_ssa::mir::debuginfo`.\n pub fn compute_mir_scopes(\n-    cx: &CodegenCx<'ll, '_>,\n-    mir: &Body<'_>,\n-    fn_metadata: &'ll DISubprogram,\n-    debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+    mir: &Body<'tcx>,\n+    fn_dbg_scope: &'ll DIScope,\n+    debug_context: &mut FunctionDebugContext<&'ll DIScope, &'ll DILocation>,\n ) {\n     // Find all the scopes with variables defined in them.\n     let mut has_variables = BitSet::new_empty(mir.source_scopes.len());\n@@ -37,58 +42,82 @@ pub fn compute_mir_scopes(\n     // Instantiate all scopes.\n     for idx in 0..mir.source_scopes.len() {\n         let scope = SourceScope::new(idx);\n-        make_mir_scope(cx, &mir, fn_metadata, &has_variables, debug_context, scope);\n+        make_mir_scope(cx, instance, &mir, fn_dbg_scope, &has_variables, debug_context, scope);\n     }\n }\n \n fn make_mir_scope(\n-    cx: &CodegenCx<'ll, '_>,\n-    mir: &Body<'_>,\n-    fn_metadata: &'ll DISubprogram,\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+    mir: &Body<'tcx>,\n+    fn_dbg_scope: &'ll DIScope,\n     has_variables: &BitSet<SourceScope>,\n-    debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n+    debug_context: &mut FunctionDebugContext<&'ll DIScope, &'ll DILocation>,\n     scope: SourceScope,\n ) {\n-    if debug_context.scopes[scope].is_valid() {\n+    if debug_context.scopes[scope].dbg_scope.is_some() {\n         return;\n     }\n \n     let scope_data = &mir.source_scopes[scope];\n     let parent_scope = if let Some(parent) = scope_data.parent_scope {\n-        make_mir_scope(cx, mir, fn_metadata, has_variables, debug_context, parent);\n+        make_mir_scope(cx, instance, mir, fn_dbg_scope, has_variables, debug_context, parent);\n         debug_context.scopes[parent]\n     } else {\n         // The root is the function itself.\n         let loc = cx.lookup_debug_loc(mir.span.lo());\n         debug_context.scopes[scope] = DebugScope {\n-            scope_metadata: Some(fn_metadata),\n+            dbg_scope: Some(fn_dbg_scope),\n+            inlined_at: None,\n             file_start_pos: loc.file.start_pos,\n             file_end_pos: loc.file.end_pos,\n         };\n         return;\n     };\n \n-    if !has_variables.contains(scope) {\n-        // Do not create a DIScope if there are no variables\n-        // defined in this MIR Scope, to avoid debuginfo bloat.\n+    if !has_variables.contains(scope) && scope_data.inlined.is_none() {\n+        // Do not create a DIScope if there are no variables defined in this\n+        // MIR `SourceScope`, and it's not `inlined`, to avoid debuginfo bloat.\n         debug_context.scopes[scope] = parent_scope;\n         return;\n     }\n \n     let loc = cx.lookup_debug_loc(scope_data.span.lo());\n-    let file_metadata = file_metadata(cx, &loc.file, debug_context.defining_crate);\n+    let file_metadata = file_metadata(cx, &loc.file);\n \n-    let scope_metadata = unsafe {\n-        Some(llvm::LLVMRustDIBuilderCreateLexicalBlock(\n-            DIB(cx),\n-            parent_scope.scope_metadata.unwrap(),\n-            file_metadata,\n-            loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-            loc.col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n-        ))\n+    let dbg_scope = match scope_data.inlined {\n+        Some((callee, _)) => {\n+            // FIXME(eddyb) this would be `self.monomorphize(&callee)`\n+            // if this is moved to `rustc_codegen_ssa::mir::debuginfo`.\n+            let callee = cx.tcx.subst_and_normalize_erasing_regions(\n+                instance.substs,\n+                ty::ParamEnv::reveal_all(),\n+                &callee,\n+            );\n+            let callee_fn_abi = FnAbi::of_instance(cx, callee, &[]);\n+            cx.dbg_scope_fn(callee, &callee_fn_abi, None)\n+        }\n+        None => unsafe {\n+            llvm::LLVMRustDIBuilderCreateLexicalBlock(\n+                DIB(cx),\n+                parent_scope.dbg_scope.unwrap(),\n+                file_metadata,\n+                loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                loc.col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n+            )\n+        },\n     };\n+\n+    let inlined_at = scope_data.inlined.map(|(_, callsite_span)| {\n+        // FIXME(eddyb) this doesn't account for the macro-related\n+        // `Span` fixups that `rustc_codegen_ssa::mir::debuginfo` does.\n+        let callsite_scope = parent_scope.adjust_dbg_scope_for_span(cx, callsite_span);\n+        cx.dbg_loc(callsite_scope, parent_scope.inlined_at, callsite_span)\n+    });\n+\n     debug_context.scopes[scope] = DebugScope {\n-        scope_metadata,\n+        dbg_scope: Some(dbg_scope),\n+        inlined_at: inlined_at.or(parent_scope.inlined_at),\n         file_start_pos: loc.file.start_pos,\n         file_end_pos: loc.file.end_pos,\n     };"}, {"sha": "10dd590652949a3e54d209ea0e23a8f1ac79a6d8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -28,7 +28,7 @@\n //! utilizing a cache. The way to get a shared metadata node when needed is\n //! thus to just call the corresponding function in this module:\n //!\n-//!     let file_metadata = file_metadata(crate_context, path);\n+//!     let file_metadata = file_metadata(cx, file);\n //!\n //! The function will take care of probing the cache for an existing node for\n //! that exact file path."}, {"sha": "73c1f73ec7fe9fc00c9ebdfeba717a622085bfce", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -26,7 +26,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ich::NodeIdHashingMode;\n use rustc_middle::mir::interpret::truncate;\n@@ -760,16 +760,12 @@ fn hex_encode(data: &[u8]) -> String {\n     hex_string\n }\n \n-pub fn file_metadata(\n-    cx: &CodegenCx<'ll, '_>,\n-    source_file: &SourceFile,\n-    defining_crate: CrateNum,\n-) -> &'ll DIFile {\n-    debug!(\"file_metadata: file_name: {}, defining_crate: {}\", source_file.name, defining_crate);\n+pub fn file_metadata(cx: &CodegenCx<'ll, '_>, source_file: &SourceFile) -> &'ll DIFile {\n+    debug!(\"file_metadata: file_name: {}\", source_file.name);\n \n     let hash = Some(&source_file.src_hash);\n     let file_name = Some(source_file.name.to_string());\n-    let directory = if defining_crate == LOCAL_CRATE {\n+    let directory = if source_file.is_real_file() && !source_file.is_imported() {\n         Some(cx.sess().working_dir.0.to_string_lossy().to_string())\n     } else {\n         // If the path comes from an upstream crate we assume it has been made\n@@ -1835,7 +1831,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n                 if !span.is_dummy() {\n                     let loc = cx.lookup_debug_loc(span.lo());\n                     return Some(SourceInfo {\n-                        file: file_metadata(cx, &loc.file, def_id.krate),\n+                        file: file_metadata(cx, &loc.file),\n                         line: loc.line.unwrap_or(UNKNOWN_LINE_NUMBER),\n                     });\n                 }\n@@ -2474,7 +2470,7 @@ pub fn create_global_var_metadata(cx: &CodegenCx<'ll, '_>, def_id: DefId, global\n \n     let (file_metadata, line_number) = if !span.is_dummy() {\n         let loc = cx.lookup_debug_loc(span.lo());\n-        (file_metadata(cx, &loc.file, LOCAL_CRATE), loc.line)\n+        (file_metadata(cx, &loc.file), loc.line)\n     } else {\n         (unknown_file_metadata(cx), None)\n     };\n@@ -2576,9 +2572,8 @@ pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &\n pub fn extend_scope_to_file(\n     cx: &CodegenCx<'ll, '_>,\n     scope_metadata: &'ll DIScope,\n-    file: &rustc_span::SourceFile,\n-    defining_crate: CrateNum,\n+    file: &SourceFile,\n ) -> &'ll DILexicalBlock {\n-    let file_metadata = file_metadata(cx, &file, defining_crate);\n+    let file_metadata = file_metadata(cx, file);\n     unsafe { llvm::LLVMRustDIBuilderCreateLexicalBlockFile(DIB(cx), scope_metadata, file_metadata) }\n }"}, {"sha": "beaea49874e6eabd0bdb8c7437c8cd5ab49cac3e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 113, "deletions": 55, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -3,7 +3,8 @@ mod doc;\n \n use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n \n-use self::metadata::{file_metadata, type_metadata, TypeMap, UNKNOWN_LINE_NUMBER};\n+use self::metadata::{file_metadata, type_metadata, TypeMap};\n+use self::metadata::{UNKNOWN_COLUMN_NUMBER, UNKNOWN_LINE_NUMBER};\n use self::namespace::mangled_name_of_instance;\n use self::type_names::compute_debuginfo_type_name;\n use self::utils::{create_DIArray, is_node_local_to_unit, DIB};\n@@ -13,23 +14,25 @@ use crate::builder::Builder;\n use crate::common::CodegenCx;\n use crate::llvm;\n use crate::llvm::debuginfo::{\n-    DIArray, DIBuilder, DIFile, DIFlags, DILexicalBlock, DISPFlags, DIScope, DIType, DIVariable,\n+    DIArray, DIBuilder, DIFile, DIFlags, DILexicalBlock, DILocation, DISPFlags, DIScope, DIType,\n+    DIVariable,\n };\n use crate::value::Value;\n \n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LOCAL_CRATE};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_hir::def_id::{DefId, DefIdMap, LOCAL_CRATE};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TypeFoldable};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::Symbol;\n-use rustc_span::{self, BytePos, Span};\n+use rustc_span::{self, BytePos, Pos, SourceFile, SourceFileAndLine, Span};\n use rustc_target::abi::{LayoutOf, Primitive, Size};\n \n use libc::c_uint;\n@@ -41,7 +44,6 @@ mod create_scope_map;\n pub mod gdb;\n pub mod metadata;\n mod namespace;\n-mod source_loc;\n mod utils;\n \n pub use self::create_scope_map::compute_mir_scopes;\n@@ -141,14 +143,11 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n     fn dbg_var_addr(\n         &mut self,\n         dbg_var: &'ll DIVariable,\n-        scope_metadata: &'ll DIScope,\n+        dbg_loc: &'ll DILocation,\n         variable_alloca: Self::Value,\n         direct_offset: Size,\n         indirect_offsets: &[Size],\n-        span: Span,\n     ) {\n-        let cx = self.cx();\n-\n         // Convert the direct and indirect offsets to address ops.\n         // FIXME(eddyb) use `const`s instead of getting the values via FFI,\n         // the values should match the ones in the DWARF standard anyway.\n@@ -168,14 +167,10 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n             }\n         }\n \n-        // FIXME(eddyb) maybe this information could be extracted from `dbg_var`,\n-        // to avoid having to pass it down in both places?\n-        // NB: `var` doesn't seem to know about the column, so that's a limitation.\n-        let dbg_loc = cx.create_debug_loc(scope_metadata, span);\n         unsafe {\n             // FIXME(eddyb) replace `llvm.dbg.declare` with `llvm.dbg.addr`.\n             llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n-                DIB(cx),\n+                DIB(self.cx()),\n                 variable_alloca,\n                 dbg_var,\n                 addr_ops.as_ptr(),\n@@ -186,15 +181,13 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn set_source_location(&mut self, scope: &'ll DIScope, span: Span) {\n-        debug!(\"set_source_location: {}\", self.sess().source_map().span_to_string(span));\n-\n-        let dbg_loc = self.cx().create_debug_loc(scope, span);\n-\n+    fn set_dbg_loc(&mut self, dbg_loc: &'ll DILocation) {\n         unsafe {\n-            llvm::LLVMSetCurrentDebugLocation(self.llbuilder, dbg_loc);\n+            let dbg_loc_as_llval = llvm::LLVMRustMetadataAsValue(self.cx().llcx, dbg_loc);\n+            llvm::LLVMSetCurrentDebugLocation(self.llbuilder, dbg_loc_as_llval);\n         }\n     }\n+\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self) {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n     }\n@@ -223,30 +216,95 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n+/// A source code location used to generate debug information.\n+// FIXME(eddyb) rename this to better indicate it's a duplicate of\n+// `rustc_span::Loc` rather than `DILocation`, perhaps by making\n+// `lookup_char_pos` return the right information instead.\n+pub struct DebugLoc {\n+    /// Information about the original source file.\n+    pub file: Lrc<SourceFile>,\n+    /// The (1-based) line number.\n+    pub line: Option<u32>,\n+    /// The (1-based) column number.\n+    pub col: Option<u32>,\n+}\n+\n+impl CodegenCx<'ll, '_> {\n+    /// Looks up debug source information about a `BytePos`.\n+    // FIXME(eddyb) rename this to better indicate it's a duplicate of\n+    // `lookup_char_pos` rather than `dbg_loc`, perhaps by making\n+    // `lookup_char_pos` return the right information instead.\n+    pub fn lookup_debug_loc(&self, pos: BytePos) -> DebugLoc {\n+        let (file, line, col) = match self.sess().source_map().lookup_line(pos) {\n+            Ok(SourceFileAndLine { sf: file, line }) => {\n+                let line_pos = file.line_begin_pos(pos);\n+\n+                // Use 1-based indexing.\n+                let line = (line + 1) as u32;\n+                let col = (pos - line_pos).to_u32() + 1;\n+\n+                (file, Some(line), Some(col))\n+            }\n+            Err(file) => (file, None, None),\n+        };\n+\n+        // For MSVC, omit the column number.\n+        // Otherwise, emit it. This mimics clang behaviour.\n+        // See discussion in https://github.com/rust-lang/rust/issues/42921\n+        if self.sess().target.options.is_like_msvc {\n+            DebugLoc { file, line, col: None }\n+        } else {\n+            DebugLoc { file, line, col }\n+        }\n+    }\n+}\n+\n impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn create_function_debug_context(\n         &self,\n         instance: Instance<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         llfn: &'ll Value,\n-        mir: &mir::Body<'_>,\n-    ) -> Option<FunctionDebugContext<&'ll DIScope>> {\n+        mir: &mir::Body<'tcx>,\n+    ) -> Option<FunctionDebugContext<&'ll DIScope, &'ll DILocation>> {\n         if self.sess().opts.debuginfo == DebugInfo::None {\n             return None;\n         }\n \n-        let span = mir.span;\n+        // Initialize fn debug context (including scopes).\n+        // FIXME(eddyb) figure out a way to not need `Option` for `dbg_scope`.\n+        let empty_scope = DebugScope {\n+            dbg_scope: None,\n+            inlined_at: None,\n+            file_start_pos: BytePos(0),\n+            file_end_pos: BytePos(0),\n+        };\n+        let mut fn_debug_context =\n+            FunctionDebugContext { scopes: IndexVec::from_elem(empty_scope, &mir.source_scopes) };\n \n-        // This can be the case for functions inlined from another crate\n-        if span.is_dummy() {\n-            // FIXME(simulacrum): Probably can't happen; remove.\n-            return None;\n-        }\n+        // Fill in all the scopes, with the information from the MIR body.\n+        compute_mir_scopes(\n+            self,\n+            instance,\n+            mir,\n+            self.dbg_scope_fn(instance, fn_abi, Some(llfn)),\n+            &mut fn_debug_context,\n+        );\n+\n+        Some(fn_debug_context)\n+    }\n \n+    fn dbg_scope_fn(\n+        &self,\n+        instance: Instance<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        maybe_definition_llfn: Option<&'ll Value>,\n+    ) -> &'ll DIScope {\n         let def_id = instance.def_id();\n         let containing_scope = get_containing_scope(self, instance);\n+        let span = self.tcx.def_span(def_id);\n         let loc = self.lookup_debug_loc(span.lo());\n-        let file_metadata = file_metadata(self, &loc.file, def_id.krate);\n+        let file_metadata = file_metadata(self, &loc.file);\n \n         let function_type_metadata = unsafe {\n             let fn_signature = get_function_signature(self, fn_abi);\n@@ -291,8 +349,8 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n         }\n \n-        let fn_metadata = unsafe {\n-            llvm::LLVMRustDIBuilderCreateFunction(\n+        unsafe {\n+            return llvm::LLVMRustDIBuilderCreateFunction(\n                 DIB(self),\n                 containing_scope,\n                 name.as_ptr().cast(),\n@@ -305,28 +363,11 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 scope_line.unwrap_or(UNKNOWN_LINE_NUMBER),\n                 flags,\n                 spflags,\n-                llfn,\n+                maybe_definition_llfn,\n                 template_parameters,\n                 None,\n-            )\n-        };\n-\n-        // Initialize fn debug context (including scopes).\n-        // FIXME(eddyb) figure out a way to not need `Option` for `scope_metadata`.\n-        let null_scope = DebugScope {\n-            scope_metadata: None,\n-            file_start_pos: BytePos(0),\n-            file_end_pos: BytePos(0),\n-        };\n-        let mut fn_debug_context = FunctionDebugContext {\n-            scopes: IndexVec::from_elem(null_scope, &mir.source_scopes),\n-            defining_crate: def_id.krate,\n-        };\n-\n-        // Fill in all the scopes, with the information from the MIR body.\n-        compute_mir_scopes(self, mir, fn_metadata, &mut fn_debug_context);\n-\n-        return Some(fn_debug_context);\n+            );\n+        }\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n@@ -501,6 +542,25 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n+    fn dbg_loc(\n+        &self,\n+        scope: &'ll DIScope,\n+        inlined_at: Option<&'ll DILocation>,\n+        span: Span,\n+    ) -> &'ll DILocation {\n+        let DebugLoc { line, col, .. } = self.lookup_debug_loc(span.lo());\n+\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateDebugLocation(\n+                utils::debug_context(self).llcontext,\n+                line.unwrap_or(UNKNOWN_LINE_NUMBER),\n+                col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n+                scope,\n+                inlined_at,\n+            )\n+        }\n+    }\n+\n     fn create_vtable_metadata(&self, ty: Ty<'tcx>, vtable: Self::Value) {\n         metadata::create_vtable_metadata(self, ty, vtable)\n     }\n@@ -509,9 +569,8 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         &self,\n         scope_metadata: &'ll DIScope,\n         file: &rustc_span::SourceFile,\n-        defining_crate: CrateNum,\n     ) -> &'ll DILexicalBlock {\n-        metadata::extend_scope_to_file(&self, scope_metadata, file, defining_crate)\n+        metadata::extend_scope_to_file(&self, scope_metadata, file)\n     }\n \n     fn debuginfo_finalize(&self) {\n@@ -522,15 +581,14 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n     fn create_dbg_var(\n         &self,\n-        dbg_context: &FunctionDebugContext<&'ll DIScope>,\n         variable_name: Symbol,\n         variable_type: Ty<'tcx>,\n         scope_metadata: &'ll DIScope,\n         variable_kind: VariableKind,\n         span: Span,\n     ) -> &'ll DIVariable {\n         let loc = self.lookup_debug_loc(span.lo());\n-        let file_metadata = file_metadata(self, &loc.file, dbg_context.defining_crate);\n+        let file_metadata = file_metadata(self, &loc.file);\n \n         let type_metadata = type_metadata(self, variable_type, span);\n "}, {"sha": "517246cd0b24b8a3a641bab86cb95f8b125ef51f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/source_loc.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/35debd4c111610317346f46d791f32551d449bd8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35debd4c111610317346f46d791f32551d449bd8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs?ref=35debd4c111610317346f46d791f32551d449bd8", "patch": "@@ -1,61 +0,0 @@\n-use super::metadata::{UNKNOWN_COLUMN_NUMBER, UNKNOWN_LINE_NUMBER};\n-use super::utils::debug_context;\n-\n-use crate::common::CodegenCx;\n-use crate::llvm::debuginfo::DIScope;\n-use crate::llvm::{self, Value};\n-use rustc_codegen_ssa::traits::*;\n-\n-use rustc_data_structures::sync::Lrc;\n-use rustc_span::{BytePos, Pos, SourceFile, SourceFileAndLine, Span};\n-\n-/// A source code location used to generate debug information.\n-pub struct DebugLoc {\n-    /// Information about the original source file.\n-    pub file: Lrc<SourceFile>,\n-    /// The (1-based) line number.\n-    pub line: Option<u32>,\n-    /// The (1-based) column number.\n-    pub col: Option<u32>,\n-}\n-\n-impl CodegenCx<'ll, '_> {\n-    /// Looks up debug source information about a `BytePos`.\n-    pub fn lookup_debug_loc(&self, pos: BytePos) -> DebugLoc {\n-        let (file, line, col) = match self.sess().source_map().lookup_line(pos) {\n-            Ok(SourceFileAndLine { sf: file, line }) => {\n-                let line_pos = file.line_begin_pos(pos);\n-\n-                // Use 1-based indexing.\n-                let line = (line + 1) as u32;\n-                let col = (pos - line_pos).to_u32() + 1;\n-\n-                (file, Some(line), Some(col))\n-            }\n-            Err(file) => (file, None, None),\n-        };\n-\n-        // For MSVC, omit the column number.\n-        // Otherwise, emit it. This mimics clang behaviour.\n-        // See discussion in https://github.com/rust-lang/rust/issues/42921\n-        if self.sess().target.options.is_like_msvc {\n-            DebugLoc { file, line, col: None }\n-        } else {\n-            DebugLoc { file, line, col }\n-        }\n-    }\n-\n-    pub fn create_debug_loc(&self, scope: &'ll DIScope, span: Span) -> &'ll Value {\n-        let DebugLoc { line, col, .. } = self.lookup_debug_loc(span.lo());\n-\n-        unsafe {\n-            llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                debug_context(self).llcontext,\n-                line.unwrap_or(UNKNOWN_LINE_NUMBER),\n-                col.unwrap_or(UNKNOWN_COLUMN_NUMBER),\n-                scope,\n-                None,\n-            )\n-        }\n-    }\n-}"}, {"sha": "daceda20097da244290b555b3ea8248297fedb73", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -5,8 +5,9 @@ use rustc_codegen_ssa::coverageinfo::map as coverage_map;\n \n use super::debuginfo::{\n     DIArray, DIBasicType, DIBuilder, DICompositeType, DIDerivedType, DIDescriptor, DIEnumerator,\n-    DIFile, DIFlags, DIGlobalVariableExpression, DILexicalBlock, DINameSpace, DISPFlags, DIScope,\n-    DISubprogram, DISubrange, DITemplateTypeParameter, DIType, DIVariable, DebugEmissionKind,\n+    DIFile, DIFlags, DIGlobalVariableExpression, DILexicalBlock, DILocation, DINameSpace,\n+    DISPFlags, DIScope, DISubprogram, DISubrange, DITemplateTypeParameter, DIType, DIVariable,\n+    DebugEmissionKind,\n };\n \n use libc::{c_char, c_int, c_uint, size_t};\n@@ -794,6 +795,7 @@ pub mod debuginfo {\n     pub struct DIBuilder<'a>(InvariantOpaque<'a>);\n \n     pub type DIDescriptor = Metadata;\n+    pub type DILocation = Metadata;\n     pub type DIScope = DIDescriptor;\n     pub type DIFile = DIScope;\n     pub type DILexicalBlock = DIScope;\n@@ -1854,7 +1856,7 @@ extern \"C\" {\n         ScopeLine: c_uint,\n         Flags: DIFlags,\n         SPFlags: DISPFlags,\n-        Fn: &'a Value,\n+        MaybeFn: Option<&'a Value>,\n         TParam: &'a DIArray,\n         Decl: Option<&'a DIDescriptor>,\n     ) -> &'a DISubprogram;\n@@ -2005,7 +2007,7 @@ extern \"C\" {\n         VarInfo: &'a DIVariable,\n         AddrOps: *const i64,\n         AddrOpsCount: c_uint,\n-        DL: &'a Value,\n+        DL: &'a DILocation,\n         InsertAtEnd: &'a BasicBlock,\n     ) -> &'a Value;\n \n@@ -2093,8 +2095,8 @@ extern \"C\" {\n         Line: c_uint,\n         Column: c_uint,\n         Scope: &'a DIScope,\n-        InlinedAt: Option<&'a Metadata>,\n-    ) -> &'a Value;\n+        InlinedAt: Option<&'a DILocation>,\n+    ) -> &'a DILocation;\n     pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n     pub fn LLVMRustDIBuilderCreateOpPlusUconst() -> i64;\n "}, {"sha": "da4637b1afcfbdaea24f01ec0a6dd657a3407ff4", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -405,7 +405,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(&mut bx, terminator.source_info);\n \n         // Get the location information.\n-        let location = self.get_caller_location(&mut bx, span).immediate();\n+        let location = self.get_caller_location(&mut bx, terminator.source_info).immediate();\n \n         // Put together the arguments to the panic entry point.\n         let (lang_item, args) = match msg {\n@@ -442,7 +442,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         intrinsic: Option<Symbol>,\n         instance: Option<Instance<'tcx>>,\n-        span: Span,\n+        source_info: mir::SourceInfo,\n         destination: &Option<(mir::Place<'tcx>, mir::BasicBlock)>,\n         cleanup: Option<mir::BasicBlock>,\n     ) -> bool {\n@@ -484,11 +484,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 });\n                 let msg = bx.const_str(Symbol::intern(&msg_str));\n-                let location = self.get_caller_location(bx, span).immediate();\n+                let location = self.get_caller_location(bx, source_info).immediate();\n \n                 // Obtain the panic entry point.\n                 // FIXME: dedup this with `codegen_assert_terminator` above.\n-                let def_id = common::langcall(bx.tcx(), Some(span), \"\", LangItem::Panic);\n+                let def_id =\n+                    common::langcall(bx.tcx(), Some(source_info.span), \"\", LangItem::Panic);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n                 let fn_abi = FnAbi::of_instance(bx, instance, &[]);\n                 let llfn = bx.get_fn_addr(instance);\n@@ -529,7 +530,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         cleanup: Option<mir::BasicBlock>,\n         fn_span: Span,\n     ) {\n-        let span = terminator.source_info.span;\n+        let source_info = terminator.source_info;\n+        let span = source_info.span;\n+\n         // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n         let callee = self.codegen_operand(&mut bx, func);\n \n@@ -606,7 +609,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             &mut bx,\n             intrinsic,\n             instance,\n-            span,\n+            source_info,\n             destination,\n             cleanup,\n         ) {\n@@ -627,7 +630,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if intrinsic == Some(sym::caller_location) {\n             if let Some((_, target)) = destination.as_ref() {\n-                let location = self.get_caller_location(&mut bx, fn_span);\n+                let location = self\n+                    .get_caller_location(&mut bx, mir::SourceInfo { span: fn_span, ..source_info });\n \n                 if let ReturnDest::IndirectOperand(tmp, _) = ret_dest {\n                     location.val.store(&mut bx, tmp);\n@@ -686,7 +690,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 &fn_abi,\n                 &args,\n                 dest,\n-                terminator.source_info.span,\n+                span,\n             );\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -793,7 +797,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args.len() + 1,\n                 \"#[track_caller] fn's must have 1 more argument in their ABI than in their MIR\",\n             );\n-            let location = self.get_caller_location(&mut bx, fn_span);\n+            let location =\n+                self.get_caller_location(&mut bx, mir::SourceInfo { span: fn_span, ..source_info });\n             debug!(\n                 \"codegen_call_terminator({:?}): location={:?} (fn_span {:?})\",\n                 terminator, location, fn_span\n@@ -1179,17 +1184,49 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    fn get_caller_location(&mut self, bx: &mut Bx, span: Span) -> OperandRef<'tcx, Bx::Value> {\n-        self.caller_location.unwrap_or_else(|| {\n+    fn get_caller_location(\n+        &mut self,\n+        bx: &mut Bx,\n+        mut source_info: mir::SourceInfo,\n+    ) -> OperandRef<'tcx, Bx::Value> {\n+        let tcx = bx.tcx();\n+\n+        let mut span_to_caller_location = |span: Span| {\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n-            let caller = bx.tcx().sess.source_map().lookup_char_pos(topmost.lo());\n-            let const_loc = bx.tcx().const_caller_location((\n+            let caller = tcx.sess.source_map().lookup_char_pos(topmost.lo());\n+            let const_loc = tcx.const_caller_location((\n                 Symbol::intern(&caller.file.name.to_string()),\n                 caller.line as u32,\n                 caller.col_display as u32 + 1,\n             ));\n             OperandRef::from_const(bx, const_loc, bx.tcx().caller_location_ty())\n-        })\n+        };\n+\n+        // Walk up the `SourceScope`s, in case some of them are from MIR inlining.\n+        // If so, the starting `source_info.span` is in the innermost inlined\n+        // function, and will be replaced with outer callsite spans as long\n+        // as the inlined functions were `#[track_caller]`.\n+        loop {\n+            let scope_data = &self.mir.source_scopes[source_info.scope];\n+\n+            if let Some((callee, callsite_span)) = scope_data.inlined {\n+                // Stop inside the most nested non-`#[track_caller]` function,\n+                // before ever reaching its caller (which is irrelevant).\n+                if !callee.def.requires_caller_location(tcx) {\n+                    return span_to_caller_location(source_info.span);\n+                }\n+                source_info.span = callsite_span;\n+            }\n+\n+            // Skip past all of the parents with `inlined: None`.\n+            match scope_data.inlined_parent_scope {\n+                Some(parent) => source_info.scope = parent,\n+                None => break,\n+            }\n+        }\n+\n+        // No inlined `SourceScope`s, or all of them were `#[track_caller]`.\n+        self.caller_location.unwrap_or_else(|| span_to_caller_location(source_info.span))\n     }\n \n     fn get_personality_slot(&mut self, bx: &mut Bx) -> PlaceRef<'tcx, Bx::Value> {"}, {"sha": "4e0396a15a6466f341efbb4260b70b4eb443567d", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 84, "deletions": 93, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,5 +1,4 @@\n use crate::traits::*;\n-use rustc_hir::def_id::CrateNum;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir;\n@@ -13,9 +12,8 @@ use super::operand::OperandValue;\n use super::place::PlaceRef;\n use super::{FunctionCx, LocalRef};\n \n-pub struct FunctionDebugContext<D> {\n-    pub scopes: IndexVec<mir::SourceScope, DebugScope<D>>,\n-    pub defining_crate: CrateNum,\n+pub struct FunctionDebugContext<S, L> {\n+    pub scopes: IndexVec<mir::SourceScope, DebugScope<S, L>>,\n }\n \n #[derive(Copy, Clone)]\n@@ -38,77 +36,84 @@ pub struct PerLocalVarDebugInfo<'tcx, D> {\n }\n \n #[derive(Clone, Copy, Debug)]\n-pub struct DebugScope<D> {\n-    pub scope_metadata: Option<D>,\n+pub struct DebugScope<S, L> {\n+    // FIXME(eddyb) this should never be `None`, after initialization.\n+    pub dbg_scope: Option<S>,\n+\n+    /// Call site location, if this scope was inlined from another function.\n+    pub inlined_at: Option<L>,\n+\n     // Start and end offsets of the file to which this DIScope belongs.\n     // These are used to quickly determine whether some span refers to the same file.\n     pub file_start_pos: BytePos,\n     pub file_end_pos: BytePos,\n }\n \n-impl<D> DebugScope<D> {\n-    pub fn is_valid(&self) -> bool {\n-        self.scope_metadata.is_some()\n+impl<'tcx, S: Copy, L: Copy> DebugScope<S, L> {\n+    /// DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+    /// it may so happen that the current span belongs to a different file than the DIScope\n+    /// corresponding to span's containing source scope.  If so, we need to create a DIScope\n+    /// \"extension\" into that file.\n+    pub fn adjust_dbg_scope_for_span<Cx: CodegenMethods<'tcx, DIScope = S, DILocation = L>>(\n+        &self,\n+        cx: &Cx,\n+        span: Span,\n+    ) -> S {\n+        // FIXME(eddyb) this should never be `None`.\n+        let dbg_scope = self\n+            .dbg_scope\n+            .unwrap_or_else(|| bug!(\"`dbg_scope` is only `None` during initialization\"));\n+\n+        let pos = span.lo();\n+        if pos < self.file_start_pos || pos >= self.file_end_pos {\n+            let sm = cx.sess().source_map();\n+            cx.extend_scope_to_file(dbg_scope, &sm.lookup_char_pos(pos).file)\n+        } else {\n+            dbg_scope\n+        }\n     }\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn set_debug_loc(&self, bx: &mut Bx, source_info: mir::SourceInfo) {\n-        let (scope, span) = self.debug_loc(source_info);\n-        bx.set_span(span);\n-        if let Some(scope) = scope {\n-            bx.set_source_location(scope, span);\n+        bx.set_span(source_info.span);\n+        if let Some(dbg_loc) = self.dbg_loc(source_info) {\n+            bx.set_dbg_loc(dbg_loc);\n         }\n     }\n \n-    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> (Option<Bx::DIScope>, Span) {\n+    fn dbg_loc(&self, source_info: mir::SourceInfo) -> Option<Bx::DILocation> {\n+        let (dbg_scope, inlined_at, span) = self.adjusted_span_and_dbg_scope(source_info)?;\n+        Some(self.cx.dbg_loc(dbg_scope, inlined_at, span))\n+    }\n+\n+    fn adjusted_span_and_dbg_scope(\n+        &self,\n+        source_info: mir::SourceInfo,\n+    ) -> Option<(Bx::DIScope, Option<Bx::DILocation>, Span)> {\n+        let span = self.adjust_span_for_debugging(source_info.span);\n+        let scope = &self.debug_context.as_ref()?.scopes[source_info.scope];\n+        Some((scope.adjust_dbg_scope_for_span(self.cx, span), scope.inlined_at, span))\n+    }\n+\n+    /// In order to have a good line stepping behavior in debugger, we overwrite debug\n+    /// locations of macro expansions with that of the outermost expansion site\n+    /// (unless the crate is being compiled with `-Z debug-macros`).\n+    fn adjust_span_for_debugging(&self, mut span: Span) -> Span {\n         // Bail out if debug info emission is not enabled.\n-        match self.debug_context {\n-            None => return (None, source_info.span),\n-            Some(_) => {}\n+        if self.debug_context.is_none() {\n+            return span;\n         }\n \n-        // In order to have a good line stepping behavior in debugger, we overwrite debug\n-        // locations of macro expansions with that of the outermost expansion site\n-        // (unless the crate is being compiled with `-Z debug-macros`).\n-        if !source_info.span.from_expansion() || self.cx.sess().opts.debugging_opts.debug_macros {\n-            let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n-            (scope, source_info.span)\n-        } else {\n+        if span.from_expansion() && !self.cx.sess().opts.debugging_opts.debug_macros {\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             // We also stop at the function body level because no line stepping can occur\n             // at the level above that.\n-            let span = rustc_span::hygiene::walk_chain(source_info.span, self.mir.span.ctxt());\n-            let scope = self.scope_metadata_for_loc(source_info.scope, span.lo());\n             // Use span of the outermost expansion site, while keeping the original lexical scope.\n-            (scope, span)\n+            span = rustc_span::hygiene::walk_chain(span, self.mir.span.ctxt());\n         }\n-    }\n \n-    // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n-    // it may so happen that the current span belongs to a different file than the DIScope\n-    // corresponding to span's containing source scope.  If so, we need to create a DIScope\n-    // \"extension\" into that file.\n-    fn scope_metadata_for_loc(\n-        &self,\n-        scope_id: mir::SourceScope,\n-        pos: BytePos,\n-    ) -> Option<Bx::DIScope> {\n-        let debug_context = self.debug_context.as_ref()?;\n-        let scope_metadata = debug_context.scopes[scope_id].scope_metadata;\n-        if pos < debug_context.scopes[scope_id].file_start_pos\n-            || pos >= debug_context.scopes[scope_id].file_end_pos\n-        {\n-            let sm = self.cx.sess().source_map();\n-            let defining_crate = debug_context.defining_crate;\n-            Some(self.cx.extend_scope_to_file(\n-                scope_metadata.unwrap(),\n-                &sm.lookup_char_pos(pos).file,\n-                defining_crate,\n-            ))\n-        } else {\n-            scope_metadata\n-        }\n+        span\n     }\n \n     /// Apply debuginfo and/or name, after creating the `alloca` for a local,\n@@ -149,24 +154,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             } else {\n                 let name = kw::Invalid;\n                 let decl = &self.mir.local_decls[local];\n-                let (scope, span) = if full_debug_info {\n-                    self.debug_loc(decl.source_info)\n+                let dbg_var = if full_debug_info {\n+                    self.adjusted_span_and_dbg_scope(decl.source_info).map(\n+                        |(dbg_scope, _, span)| {\n+                            // FIXME(eddyb) is this `+ 1` needed at all?\n+                            let kind = VariableKind::ArgumentVariable(arg_index + 1);\n+\n+                            let arg_ty = self.monomorphize(&decl.ty);\n+\n+                            self.cx.create_dbg_var(name, arg_ty, dbg_scope, kind, span)\n+                        },\n+                    )\n                 } else {\n-                    (None, decl.source_info.span)\n+                    None\n                 };\n-                let dbg_var = scope.map(|scope| {\n-                    // FIXME(eddyb) is this `+ 1` needed at all?\n-                    let kind = VariableKind::ArgumentVariable(arg_index + 1);\n-\n-                    self.cx.create_dbg_var(\n-                        self.debug_context.as_ref().unwrap(),\n-                        name,\n-                        self.monomorphize(&decl.ty),\n-                        scope,\n-                        kind,\n-                        span,\n-                    )\n-                });\n \n                 Some(PerLocalVarDebugInfo {\n                     name,\n@@ -247,6 +248,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let vars = vars.iter().copied().chain(fallback_var);\n \n         for var in vars {\n+            let dbg_var = match var.dbg_var {\n+                Some(dbg_var) => dbg_var,\n+                None => continue,\n+            };\n+            let dbg_loc = match self.dbg_loc(var.source_info) {\n+                Some(dbg_loc) => dbg_loc,\n+                None => continue,\n+            };\n+\n             let mut layout = base.layout;\n             let mut direct_offset = Size::ZERO;\n             // FIXME(eddyb) use smallvec here.\n@@ -283,19 +293,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            let (scope, span) = self.debug_loc(var.source_info);\n-            if let Some(scope) = scope {\n-                if let Some(dbg_var) = var.dbg_var {\n-                    bx.dbg_var_addr(\n-                        dbg_var,\n-                        scope,\n-                        base.llval,\n-                        direct_offset,\n-                        &indirect_offsets,\n-                        span,\n-                    );\n-                }\n-            }\n+            bx.dbg_var_addr(dbg_var, dbg_loc, base.llval, direct_offset, &indirect_offsets);\n         }\n     }\n \n@@ -319,12 +317,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let mut per_local = IndexVec::from_elem(vec![], &self.mir.local_decls);\n         for var in &self.mir.var_debug_info {\n-            let (scope, span) = if full_debug_info {\n-                self.debug_loc(var.source_info)\n+            let dbg_scope_and_span = if full_debug_info {\n+                self.adjusted_span_and_dbg_scope(var.source_info)\n             } else {\n-                (None, var.source_info.span)\n+                None\n             };\n-            let dbg_var = scope.map(|scope| {\n+            let dbg_var = dbg_scope_and_span.map(|(dbg_scope, _, span)| {\n                 let place = var.place;\n                 let var_ty = self.monomorphized_place_ty(place.as_ref());\n                 let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg\n@@ -340,14 +338,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 } else {\n                     VariableKind::LocalVariable\n                 };\n-                self.cx.create_dbg_var(\n-                    self.debug_context.as_ref().unwrap(),\n-                    var.name,\n-                    var_ty,\n-                    scope,\n-                    var_kind,\n-                    span,\n-                )\n+                self.cx.create_dbg_var(var.name, var_ty, dbg_scope, var_kind, span)\n             });\n \n             per_local[var.place.local].push(PerLocalVarDebugInfo {"}, {"sha": "84e82e88e8eeaafffc89bf2f49237a4c3278f590", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -26,7 +26,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     mir: &'tcx mir::Body<'tcx>,\n \n-    debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n+    debug_context: Option<FunctionDebugContext<Bx::DIScope, Bx::DILocation>>,\n \n     llfn: Bx::Function,\n "}, {"sha": "b9c555c2eb0691fc8992eb033c1dbf60cedac826", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -34,6 +34,7 @@ pub trait BackendTypes {\n     // FIXME(eddyb) find a common convention for all of the debuginfo-related\n     // names (choose between `Dbg`, `Debug`, `DebugInfo`, `DI` etc.).\n     type DIScope: Copy;\n+    type DILocation: Copy;\n     type DIVariable: Copy;\n }\n "}, {"sha": "3e66d711d2ef59a79e1c7dc3b1597ac018f32ae3", "filename": "compiler/rustc_codegen_ssa/src/traits/debuginfo.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,6 +1,5 @@\n use super::BackendTypes;\n use crate::mir::debuginfo::{FunctionDebugContext, VariableKind};\n-use rustc_hir::def_id::CrateNum;\n use rustc_middle::mir;\n use rustc_middle::ty::{Instance, Ty};\n use rustc_span::{SourceFile, Span, Symbol};\n@@ -19,22 +18,36 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         instance: Instance<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         llfn: Self::Function,\n-        mir: &mir::Body<'_>,\n-    ) -> Option<FunctionDebugContext<Self::DIScope>>;\n+        mir: &mir::Body<'tcx>,\n+    ) -> Option<FunctionDebugContext<Self::DIScope, Self::DILocation>>;\n+\n+    // FIXME(eddyb) find a common convention for all of the debuginfo-related\n+    // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n+    fn dbg_scope_fn(\n+        &self,\n+        instance: Instance<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        maybe_definition_llfn: Option<Self::Function>,\n+    ) -> Self::DIScope;\n+\n+    fn dbg_loc(\n+        &self,\n+        scope: Self::DIScope,\n+        inlined_at: Option<Self::DILocation>,\n+        span: Span,\n+    ) -> Self::DILocation;\n \n     fn extend_scope_to_file(\n         &self,\n         scope_metadata: Self::DIScope,\n         file: &SourceFile,\n-        defining_crate: CrateNum,\n     ) -> Self::DIScope;\n     fn debuginfo_finalize(&self);\n \n     // FIXME(eddyb) find a common convention for all of the debuginfo-related\n     // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n     fn create_dbg_var(\n         &self,\n-        dbg_context: &FunctionDebugContext<Self::DIScope>,\n         variable_name: Symbol,\n         variable_type: Ty<'tcx>,\n         scope_metadata: Self::DIScope,\n@@ -49,14 +62,13 @@ pub trait DebugInfoBuilderMethods: BackendTypes {\n     fn dbg_var_addr(\n         &mut self,\n         dbg_var: Self::DIVariable,\n-        scope_metadata: Self::DIScope,\n+        dbg_loc: Self::DILocation,\n         variable_alloca: Self::Value,\n         direct_offset: Size,\n         // NB: each offset implies a deref (i.e. they're steps in a pointer chain).\n         indirect_offsets: &[Size],\n-        span: Span,\n     );\n-    fn set_source_location(&mut self, scope: Self::DIScope, span: Span);\n+    fn set_dbg_loc(&mut self, dbg_loc: Self::DILocation);\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n     fn set_var_name(&mut self, value: Self::Value, name: &str);\n }"}, {"sha": "8ada6c10479daff9f8cec9d444756b4b4ad7d7e1", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -95,6 +95,7 @@ pub trait HasCodegen<'tcx>:\n             Type = Self::Type,\n             Funclet = Self::Funclet,\n             DIScope = Self::DIScope,\n+            DILocation = Self::DILocation,\n             DIVariable = Self::DIVariable,\n         >;\n }"}, {"sha": "3beb328339e7ab1e51b58a59003affd4d0bb74df", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -733,7 +733,7 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n     const char *LinkageName, size_t LinkageNameLen,\n     LLVMMetadataRef File, unsigned LineNo,\n     LLVMMetadataRef Ty, unsigned ScopeLine, LLVMRustDIFlags Flags,\n-    LLVMRustDISPFlags SPFlags, LLVMValueRef Fn, LLVMMetadataRef TParam,\n+    LLVMRustDISPFlags SPFlags, LLVMValueRef MaybeFn, LLVMMetadataRef TParam,\n     LLVMMetadataRef Decl) {\n   DITemplateParameterArray TParams =\n       DITemplateParameterArray(unwrap<MDTuple>(TParam));\n@@ -750,7 +750,8 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n       unwrapDI<DIFile>(File), LineNo,\n       unwrapDI<DISubroutineType>(Ty), ScopeLine, llvmFlags,\n       llvmSPFlags, TParams, unwrapDIPtr<DISubprogram>(Decl));\n-  unwrap<Function>(Fn)->setSubprogram(Sub);\n+  if (MaybeFn)\n+    unwrap<Function>(MaybeFn)->setSubprogram(Sub);\n   return wrap(Sub);\n }\n \n@@ -930,12 +931,12 @@ LLVMRustDIBuilderGetOrCreateArray(LLVMRustDIBuilderRef Builder,\n \n extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareAtEnd(\n     LLVMRustDIBuilderRef Builder, LLVMValueRef V, LLVMMetadataRef VarInfo,\n-    int64_t *AddrOps, unsigned AddrOpsCount, LLVMValueRef DL,\n+    int64_t *AddrOps, unsigned AddrOpsCount, LLVMMetadataRef DL,\n     LLVMBasicBlockRef InsertAtEnd) {\n   return wrap(Builder->insertDeclare(\n       unwrap(V), unwrap<DILocalVariable>(VarInfo),\n       Builder->createExpression(llvm::ArrayRef<int64_t>(AddrOps, AddrOpsCount)),\n-      DebugLoc(cast<MDNode>(unwrap<MetadataAsValue>(DL)->getMetadata())),\n+      DebugLoc(cast<MDNode>(DL)),\n       unwrap(InsertAtEnd)));\n }\n \n@@ -1002,7 +1003,7 @@ LLVMRustDICompositeTypeReplaceArrays(LLVMRustDIBuilderRef Builder,\n                          DINodeArray(unwrap<MDTuple>(Params)));\n }\n \n-extern \"C\" LLVMValueRef\n+extern \"C\" LLVMMetadataRef\n LLVMRustDIBuilderCreateDebugLocation(LLVMContextRef ContextRef, unsigned Line,\n                                      unsigned Column, LLVMMetadataRef Scope,\n                                      LLVMMetadataRef InlinedAt) {\n@@ -1011,7 +1012,7 @@ LLVMRustDIBuilderCreateDebugLocation(LLVMContextRef ContextRef, unsigned Line,\n   DebugLoc debug_loc = DebugLoc::get(Line, Column, unwrapDIPtr<MDNode>(Scope),\n                                      unwrapDIPtr<MDNode>(InlinedAt));\n \n-  return wrap(MetadataAsValue::get(Context, debug_loc.getAsMDNode()));\n+  return wrap(debug_loc.getAsMDNode());\n }\n \n extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref() {"}, {"sha": "c4ce8667c9082118f761ba700ef1c9d0a70c5ad9", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -161,7 +161,7 @@ pub struct Body<'tcx> {\n \n     /// A list of source scopes; these are referenced by statements\n     /// and used for debuginfo. Indexed by a `SourceScope`.\n-    pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n+    pub source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n \n     /// The yield type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n@@ -244,7 +244,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn new(\n         source: MirSource<'tcx>,\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-        source_scopes: IndexVec<SourceScope, SourceScopeData>,\n+        source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n@@ -1865,11 +1865,21 @@ rustc_index::newtype_index! {\n     }\n }\n \n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n-pub struct SourceScopeData {\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n+pub struct SourceScopeData<'tcx> {\n     pub span: Span,\n     pub parent_scope: Option<SourceScope>,\n \n+    /// Whether this scope is the root of a scope tree of another body,\n+    /// inlined into this body by the MIR inliner.\n+    /// `ty::Instance` is the callee, and the `Span` is the call site.\n+    pub inlined: Option<(ty::Instance<'tcx>, Span)>,\n+\n+    /// Nearest (transitive) parent scope (if any) which is inlined.\n+    /// This is an optimization over walking up `parent_scope`\n+    /// until a scope with `inlined: Some(...)` is found.\n+    pub inlined_parent_scope: Option<SourceScope>,\n+\n     /// Crate-local information for this source scope, that can't (and\n     /// needn't) be tracked across crates.\n     pub local_data: ClearCrossCrate<SourceScopeLocalData>,"}, {"sha": "6aab54b92748d61c224f23f8f5116355d9e752cd", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -10,7 +10,6 @@ CloneTypeFoldableAndLiftImpls! {\n     FakeReadCause,\n     RetagKind,\n     SourceScope,\n-    SourceScopeData,\n     SourceScopeLocalData,\n     UserTypeAnnotationIndex,\n }"}, {"sha": "d8d639ab73451c8c838ed3e561bbded87a7dc871", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -85,7 +85,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_source_scope_data(&mut self,\n-                                           scope_data: & $($mutability)? SourceScopeData) {\n+                                           scope_data: & $($mutability)? SourceScopeData<'tcx>) {\n                 self.super_source_scope_data(scope_data);\n             }\n \n@@ -317,17 +317,50 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_source_scope_data(&mut self, scope_data: & $($mutability)? SourceScopeData) {\n+            fn super_source_scope_data(\n+                &mut self,\n+                scope_data: & $($mutability)? SourceScopeData<'tcx>,\n+            ) {\n                 let SourceScopeData {\n                     span,\n                     parent_scope,\n+                    inlined,\n+                    inlined_parent_scope,\n                     local_data: _,\n                 } = scope_data;\n \n                 self.visit_span(span);\n                 if let Some(parent_scope) = parent_scope {\n                     self.visit_source_scope(parent_scope);\n                 }\n+                if let Some((callee, callsite_span)) = inlined {\n+                    let location = START_BLOCK.start_location();\n+\n+                    self.visit_span(callsite_span);\n+\n+                    let ty::Instance { def: callee_def, substs: callee_substs } = callee;\n+                    match callee_def {\n+                        ty::InstanceDef::Item(_def_id) => {}\n+\n+                        ty::InstanceDef::Intrinsic(_def_id) |\n+                        ty::InstanceDef::VtableShim(_def_id) |\n+                        ty::InstanceDef::ReifyShim(_def_id) |\n+                        ty::InstanceDef::Virtual(_def_id, _) |\n+                        ty::InstanceDef::ClosureOnceShim { call_once: _def_id } |\n+                        ty::InstanceDef::DropGlue(_def_id, None) => {}\n+\n+                        ty::InstanceDef::FnPtrShim(_def_id, ty) |\n+                        ty::InstanceDef::DropGlue(_def_id, Some(ty)) |\n+                        ty::InstanceDef::CloneShim(_def_id, ty) => {\n+                            // FIXME(eddyb) use a better `TyContext` here.\n+                            self.visit_ty(ty, TyContext::Location(location));\n+                        }\n+                    }\n+                    self.visit_substs(callee_substs, location);\n+                }\n+                if let Some(inlined_parent_scope) = inlined_parent_scope {\n+                    self.visit_source_scope(inlined_parent_scope);\n+                }\n             }\n \n             fn super_statement(&mut self,"}, {"sha": "5c917f00d157bd9080c52c9443f275d25f48c08b", "filename": "compiler/rustc_mir/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -15,38 +15,61 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n     /// frame which is not `#[track_caller]`.\n     crate fn find_closest_untracked_caller_location(&self) -> Span {\n-        let frame = self\n-            .stack()\n-            .iter()\n-            .rev()\n-            // Find first non-`#[track_caller]` frame.\n-            .find(|frame| {\n+        for frame in self.stack().iter().rev() {\n+            debug!(\"find_closest_untracked_caller_location: checking frame {:?}\", frame.instance);\n+\n+            // Assert that the frame we look at is actually executing code currently\n+            // (`loc` is `Err` when we are unwinding and the frame does not require cleanup).\n+            let loc = frame.loc.unwrap();\n+\n+            // This could be a non-`Call` terminator (such as `Drop`), or not a terminator at all\n+            // (such as `box`). Use the normal span by default.\n+            let mut source_info = *frame.body.source_info(loc);\n+\n+            // If this is a `Call` terminator, use the `fn_span` instead.\n+            let block = &frame.body.basic_blocks()[loc.block];\n+            if loc.statement_index == block.statements.len() {\n                 debug!(\n-                    \"find_closest_untracked_caller_location: checking frame {:?}\",\n-                    frame.instance\n+                    \"find_closest_untracked_caller_location: got terminator {:?} ({:?})\",\n+                    block.terminator(),\n+                    block.terminator().kind\n                 );\n-                !frame.instance.def.requires_caller_location(*self.tcx)\n-            })\n-            // Assert that there is always such a frame.\n-            .unwrap();\n-        // Assert that the frame we look at is actually executing code currently\n-        // (`loc` is `Err` when we are unwinding and the frame does not require cleanup).\n-        let loc = frame.loc.unwrap();\n-        // If this is a `Call` terminator, use the `fn_span` instead.\n-        let block = &frame.body.basic_blocks()[loc.block];\n-        if loc.statement_index == block.statements.len() {\n-            debug!(\n-                \"find_closest_untracked_caller_location:: got terminator {:?} ({:?})\",\n-                block.terminator(),\n-                block.terminator().kind\n-            );\n-            if let TerminatorKind::Call { fn_span, .. } = block.terminator().kind {\n-                return fn_span;\n+                if let TerminatorKind::Call { fn_span, .. } = block.terminator().kind {\n+                    source_info.span = fn_span;\n+                }\n+            }\n+\n+            // Walk up the `SourceScope`s, in case some of them are from MIR inlining.\n+            // If so, the starting `source_info.span` is in the innermost inlined\n+            // function, and will be replaced with outer callsite spans as long\n+            // as the inlined functions were `#[track_caller]`.\n+            loop {\n+                let scope_data = &frame.body.source_scopes[source_info.scope];\n+\n+                if let Some((callee, callsite_span)) = scope_data.inlined {\n+                    // Stop inside the most nested non-`#[track_caller]` function,\n+                    // before ever reaching its caller (which is irrelevant).\n+                    if !callee.def.requires_caller_location(*self.tcx) {\n+                        return source_info.span;\n+                    }\n+                    source_info.span = callsite_span;\n+                }\n+\n+                // Skip past all of the parents with `inlined: None`.\n+                match scope_data.inlined_parent_scope {\n+                    Some(parent) => source_info.scope = parent,\n+                    None => break,\n+                }\n+            }\n+\n+            // Stop inside the most nested non-`#[track_caller]` function,\n+            // before ever reaching its caller (which is irrelevant).\n+            if !frame.instance.def.requires_caller_location(*self.tcx) {\n+                return source_info.span;\n             }\n         }\n-        // This is a different terminator (such as `Drop`) or not a terminator at all\n-        // (such as `box`). Use the normal span.\n-        frame.body.source_info(loc).span\n+\n+        bug!(\"no non-`#[track_caller]` frame found\")\n     }\n \n     /// Allocate a `const core::panic::Location` with the provided filename and line/column numbers."}, {"sha": "b2fa4b11f36589fb5b46068eadc46cead1eef544", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -212,7 +212,13 @@ fn new_body<'tcx>(\n         source,\n         basic_blocks,\n         IndexVec::from_elem_n(\n-            SourceScopeData { span, parent_scope: None, local_data: ClearCrossCrate::Clear },\n+            SourceScopeData {\n+                span,\n+                parent_scope: None,\n+                inlined: None,\n+                inlined_parent_scope: None,\n+                local_data: ClearCrossCrate::Clear,\n+            },\n             1,\n         ),\n         local_decls,"}, {"sha": "c743104f6ba1904eabc373aa0a4bac957b3c1a99", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -313,7 +313,7 @@ struct ConstPropagator<'mir, 'tcx> {\n     param_env: ParamEnv<'tcx>,\n     // FIXME(eddyb) avoid cloning these two fields more than once,\n     // by accessing them through `ecx` instead.\n-    source_scopes: IndexVec<SourceScope, SourceScopeData>,\n+    source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it."}, {"sha": "944f41c61a2b58a1834dae145d397461e438e19f", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 125, "deletions": 117, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,20 +1,20 @@\n //! Inlining pass for MIR functions\n \n use rustc_attr as attr;\n-use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ConstKind, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_target::spec::abi::Abi;\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n use crate::transform::MirPass;\n use std::collections::VecDeque;\n use std::iter;\n+use std::ops::RangeFrom;\n \n const DEFAULT_THRESHOLD: usize = 50;\n const HINT_THRESHOLD: usize = 100;\n@@ -30,10 +30,9 @@ pub struct Inline;\n \n #[derive(Copy, Clone, Debug)]\n struct CallSite<'tcx> {\n-    callee: DefId,\n-    substs: SubstsRef<'tcx>,\n+    callee: Instance<'tcx>,\n     bb: BasicBlock,\n-    location: SourceInfo,\n+    source_info: SourceInfo,\n }\n \n impl<'tcx> MirPass<'tcx> for Inline {\n@@ -101,14 +100,20 @@ impl Inliner<'tcx> {\n             local_change = false;\n             while let Some(callsite) = callsites.pop_front() {\n                 debug!(\"checking whether to inline callsite {:?}\", callsite);\n-                if !self.tcx.is_mir_available(callsite.callee) {\n-                    debug!(\"checking whether to inline callsite {:?} - MIR unavailable\", callsite);\n-                    continue;\n+\n+                if let InstanceDef::Item(_) = callsite.callee.def {\n+                    if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n+                        debug!(\n+                            \"checking whether to inline callsite {:?} - MIR unavailable\",\n+                            callsite,\n+                        );\n+                        continue;\n+                    }\n                 }\n \n-                let callee_body = if let Some(callee_def_id) = callsite.callee.as_local() {\n+                let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n                     let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n-                    // Avoid a cycle here by only using `optimized_mir` only if we have\n+                    // Avoid a cycle here by only using `instance_mir` only if we have\n                     // a lower `HirId` than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation.\n                     // So don't do it if that is enabled. Also avoid inlining into generators,\n@@ -119,19 +124,21 @@ impl Inliner<'tcx> {\n                         && self_hir_id < callee_hir_id\n                         && caller_body.generator_kind.is_none()\n                     {\n-                        self.tcx.optimized_mir(callsite.callee)\n+                        self.tcx.instance_mir(callsite.callee.def)\n                     } else {\n                         continue;\n                     }\n                 } else {\n                     // This cannot result in a cycle since the callee MIR is from another crate\n                     // and is already optimized.\n-                    self.tcx.optimized_mir(callsite.callee)\n+                    self.tcx.instance_mir(callsite.callee.def)\n                 };\n \n+                let callee_body: &Body<'tcx> = &*callee_body;\n+\n                 let callee_body = if self.consider_optimizing(callsite, callee_body) {\n                     self.tcx.subst_and_normalize_erasing_regions(\n-                        &callsite.substs,\n+                        &callsite.callee.substs,\n                         self.param_env,\n                         callee_body,\n                     )\n@@ -204,21 +211,16 @@ impl Inliner<'tcx> {\n                 // To resolve an instance its substs have to be fully normalized, so\n                 // we do this here.\n                 let normalized_substs = self.tcx.normalize_erasing_regions(self.param_env, substs);\n-                let instance =\n+                let callee =\n                     Instance::resolve(self.tcx, self.param_env, callee_def_id, normalized_substs)\n                         .ok()\n                         .flatten()?;\n \n-                if let InstanceDef::Virtual(..) = instance.def {\n+                if let InstanceDef::Virtual(..) | InstanceDef::Intrinsic(_) = callee.def {\n                     return None;\n                 }\n \n-                return Some(CallSite {\n-                    callee: instance.def_id(),\n-                    substs: instance.substs,\n-                    bb,\n-                    location: terminator.source_info,\n-                });\n+                return Some(CallSite { callee, bb, source_info: terminator.source_info });\n             }\n         }\n \n@@ -243,12 +245,7 @@ impl Inliner<'tcx> {\n             return false;\n         }\n \n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee);\n-\n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::TRACK_CALLER) {\n-            debug!(\"`#[track_caller]` present - not inlining\");\n-            return false;\n-        }\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee.def_id());\n \n         let self_features = &self.codegen_fn_attrs.target_features;\n         let callee_features = &codegen_fn_attrs.target_features;\n@@ -282,8 +279,8 @@ impl Inliner<'tcx> {\n         // Only inline local functions if they would be eligible for cross-crate\n         // inlining. This is to ensure that the final crate doesn't have MIR that\n         // reference unexported symbols\n-        if callsite.callee.is_local() {\n-            if callsite.substs.non_erasable_generics().count() == 0 && !hinted {\n+        if callsite.callee.def_id().is_local() {\n+            if callsite.callee.substs.non_erasable_generics().count() == 0 && !hinted {\n                 debug!(\"    callee is an exported function - not inlining\");\n                 return false;\n             }\n@@ -336,7 +333,7 @@ impl Inliner<'tcx> {\n                     work_list.push(target);\n                     // If the place doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = place.ty(callee_body, tcx).subst(tcx, callsite.substs).ty;\n+                    let ty = place.ty(callee_body, tcx).subst(tcx, callsite.callee.substs).ty;\n                     if ty.needs_drop(tcx, self.param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -399,7 +396,7 @@ impl Inliner<'tcx> {\n \n         for v in callee_body.vars_and_temps_iter() {\n             let v = &callee_body.local_decls[v];\n-            let ty = v.ty.subst(tcx, callsite.substs);\n+            let ty = v.ty.subst(tcx, callsite.callee.substs);\n             // Cost of the var is the size in machine-words, if we know\n             // it.\n             if let Some(size) = type_size_of(tcx, self.param_env, ty) {\n@@ -435,36 +432,6 @@ impl Inliner<'tcx> {\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"inlined {:?} into {:?}\", callsite.callee, caller_body.source);\n \n-                let mut local_map = IndexVec::with_capacity(callee_body.local_decls.len());\n-                let mut scope_map = IndexVec::with_capacity(callee_body.source_scopes.len());\n-\n-                for mut scope in callee_body.source_scopes.iter().cloned() {\n-                    if scope.parent_scope.is_none() {\n-                        scope.parent_scope = Some(callsite.location.scope);\n-                        // FIXME(eddyb) is this really needed?\n-                        // (also note that it's always overwritten below)\n-                        scope.span = callee_body.span;\n-                    }\n-\n-                    // FIXME(eddyb) this doesn't seem right at all.\n-                    // The inlined source scopes should probably be annotated as\n-                    // such, but also contain all of the original information.\n-                    scope.span = callsite.location.span;\n-\n-                    let idx = caller_body.source_scopes.push(scope);\n-                    scope_map.push(idx);\n-                }\n-\n-                for loc in callee_body.vars_and_temps_iter() {\n-                    let mut local = callee_body.local_decls[loc].clone();\n-\n-                    local.source_info.scope = scope_map[local.source_info.scope];\n-                    local.source_info.span = callsite.location.span;\n-\n-                    let idx = caller_body.local_decls.push(local);\n-                    local_map.push(idx);\n-                }\n-\n                 // If the call is something like `a[*i] = f(i)`, where\n                 // `i : &mut usize`, then just duplicating the `a[*i]`\n                 // Place could result in two different locations if `f`\n@@ -491,13 +458,13 @@ impl Inliner<'tcx> {\n \n                     let ty = dest.ty(caller_body, self.tcx);\n \n-                    let temp = LocalDecl::new(ty, callsite.location.span);\n+                    let temp = LocalDecl::new(ty, callsite.source_info.span);\n \n                     let tmp = caller_body.local_decls.push(temp);\n                     let tmp = Place::from(tmp);\n \n                     let stmt = Statement {\n-                        source_info: callsite.location,\n+                        source_info: callsite.source_info,\n                         kind: StatementKind::Assign(box (tmp, dest)),\n                     };\n                     caller_body[callsite.bb].statements.push(stmt);\n@@ -511,35 +478,63 @@ impl Inliner<'tcx> {\n                 // Copy the arguments if needed.\n                 let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, return_block);\n \n-                let bb_len = caller_body.basic_blocks().len();\n                 let mut integrator = Integrator {\n-                    block_idx: bb_len,\n                     args: &args,\n-                    local_map,\n-                    scope_map,\n+                    new_locals: Local::new(caller_body.local_decls.len())..,\n+                    new_scopes: SourceScope::new(caller_body.source_scopes.len())..,\n+                    new_blocks: BasicBlock::new(caller_body.basic_blocks().len())..,\n                     destination: dest,\n                     return_block,\n                     cleanup_block: cleanup,\n                     in_cleanup_block: false,\n                     tcx: self.tcx,\n                 };\n \n-                for mut var_debug_info in callee_body.var_debug_info.drain(..) {\n-                    integrator.visit_var_debug_info(&mut var_debug_info);\n-                    caller_body.var_debug_info.push(var_debug_info);\n-                }\n+                // Map all `Local`s, `SourceScope`s and `BasicBlock`s to new ones\n+                // (or existing ones, in a few special cases) in the caller.\n+                integrator.visit_body(&mut callee_body);\n \n-                for (bb, mut block) in callee_body.basic_blocks_mut().drain_enumerated(..) {\n-                    integrator.visit_basic_block_data(bb, &mut block);\n-                    caller_body.basic_blocks_mut().push(block);\n+                for scope in &mut callee_body.source_scopes {\n+                    // FIXME(eddyb) move this into a `fn visit_scope_data` in `Integrator`.\n+                    if scope.parent_scope.is_none() {\n+                        let callsite_scope = &caller_body.source_scopes[callsite.source_info.scope];\n+\n+                        // Attach the outermost callee scope as a child of the callsite\n+                        // scope, via the `parent_scope` and `inlined_parent_scope` chains.\n+                        scope.parent_scope = Some(callsite.source_info.scope);\n+                        assert_eq!(scope.inlined_parent_scope, None);\n+                        scope.inlined_parent_scope = if callsite_scope.inlined.is_some() {\n+                            Some(callsite.source_info.scope)\n+                        } else {\n+                            callsite_scope.inlined_parent_scope\n+                        };\n+\n+                        // Mark the outermost callee scope as an inlined one.\n+                        assert_eq!(scope.inlined, None);\n+                        scope.inlined = Some((callsite.callee, callsite.source_info.span));\n+                    } else if scope.inlined_parent_scope.is_none() {\n+                        // Make it easy to find the scope with `inlined` set above.\n+                        scope.inlined_parent_scope =\n+                            Some(integrator.map_scope(OUTERMOST_SOURCE_SCOPE));\n+                    }\n                 }\n \n-                let terminator = Terminator {\n-                    source_info: callsite.location,\n-                    kind: TerminatorKind::Goto { target: BasicBlock::new(bb_len) },\n-                };\n+                // Insert all of the (mapped) parts of the callee body into the caller.\n+                caller_body.local_decls.extend(\n+                    // FIXME(eddyb) make `Range<Local>` iterable so that we can use\n+                    // `callee_body.local_decls.drain(callee_body.vars_and_temps())`\n+                    callee_body\n+                        .vars_and_temps_iter()\n+                        .map(|local| callee_body.local_decls[local].clone()),\n+                );\n+                caller_body.source_scopes.extend(callee_body.source_scopes.drain(..));\n+                caller_body.var_debug_info.extend(callee_body.var_debug_info.drain(..));\n+                caller_body.basic_blocks_mut().extend(callee_body.basic_blocks_mut().drain(..));\n \n-                caller_body[callsite.bb].terminator = Some(terminator);\n+                caller_body[callsite.bb].terminator = Some(Terminator {\n+                    source_info: callsite.source_info,\n+                    kind: TerminatorKind::Goto { target: integrator.map_block(START_BLOCK) },\n+                });\n \n                 true\n             }\n@@ -583,7 +578,9 @@ impl Inliner<'tcx> {\n         //     tmp2 = tuple_tmp.2\n         //\n         // and the vector is `[closure_ref, tmp0, tmp1, tmp2]`.\n-        if tcx.is_closure(callsite.callee) {\n+        // FIXME(eddyb) make this check for `\"rust-call\"` ABI combined with\n+        // `callee_body.spread_arg == None`, instead of special-casing closures.\n+        if tcx.is_closure(callsite.callee.def_id()) {\n             let mut args = args.into_iter();\n             let self_ = self.create_temp_if_necessary(\n                 args.next().unwrap(),\n@@ -654,20 +651,23 @@ impl Inliner<'tcx> {\n \n         let ty = arg.ty(caller_body, self.tcx);\n \n-        let arg_tmp = LocalDecl::new(ty, callsite.location.span);\n+        let arg_tmp = LocalDecl::new(ty, callsite.source_info.span);\n         let arg_tmp = caller_body.local_decls.push(arg_tmp);\n \n         caller_body[callsite.bb].statements.push(Statement {\n-            source_info: callsite.location,\n+            source_info: callsite.source_info,\n             kind: StatementKind::StorageLive(arg_tmp),\n         });\n         caller_body[callsite.bb].statements.push(Statement {\n-            source_info: callsite.location,\n+            source_info: callsite.source_info,\n             kind: StatementKind::Assign(box (Place::from(arg_tmp), arg)),\n         });\n         caller_body[return_block].statements.insert(\n             0,\n-            Statement { source_info: callsite.location, kind: StatementKind::StorageDead(arg_tmp) },\n+            Statement {\n+                source_info: callsite.source_info,\n+                kind: StatementKind::StorageDead(arg_tmp),\n+            },\n         );\n \n         arg_tmp\n@@ -690,10 +690,10 @@ fn type_size_of<'tcx>(\n  * stuff.\n */\n struct Integrator<'a, 'tcx> {\n-    block_idx: usize,\n     args: &'a [Local],\n-    local_map: IndexVec<Local, Local>,\n-    scope_map: IndexVec<SourceScope, SourceScope>,\n+    new_locals: RangeFrom<Local>,\n+    new_scopes: RangeFrom<SourceScope>,\n+    new_blocks: RangeFrom<BasicBlock>,\n     destination: Place<'tcx>,\n     return_block: BasicBlock,\n     cleanup_block: Option<BasicBlock>,\n@@ -702,23 +702,31 @@ struct Integrator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Integrator<'a, 'tcx> {\n-    fn update_target(&self, tgt: BasicBlock) -> BasicBlock {\n-        let new = BasicBlock::new(tgt.index() + self.block_idx);\n-        debug!(\"updating target `{:?}`, new: `{:?}`\", tgt, new);\n+    fn map_local(&self, local: Local) -> Local {\n+        let new = if local == RETURN_PLACE {\n+            self.destination.local\n+        } else {\n+            let idx = local.index() - 1;\n+            if idx < self.args.len() {\n+                self.args[idx]\n+            } else {\n+                Local::new(self.new_locals.start.index() + (idx - self.args.len()))\n+            }\n+        };\n+        debug!(\"mapping local `{:?}` to `{:?}`\", local, new);\n         new\n     }\n \n-    fn make_integrate_local(&self, local: Local) -> Local {\n-        if local == RETURN_PLACE {\n-            return self.destination.local;\n-        }\n-\n-        let idx = local.index() - 1;\n-        if idx < self.args.len() {\n-            return self.args[idx];\n-        }\n+    fn map_scope(&self, scope: SourceScope) -> SourceScope {\n+        let new = SourceScope::new(self.new_scopes.start.index() + scope.index());\n+        debug!(\"mapping scope `{:?}` to `{:?}`\", scope, new);\n+        new\n+    }\n \n-        self.local_map[Local::new(idx - self.args.len())]\n+    fn map_block(&self, block: BasicBlock) -> BasicBlock {\n+        let new = BasicBlock::new(self.new_blocks.start.index() + block.index());\n+        debug!(\"mapping block `{:?}` to `{:?}`\", block, new);\n+        new\n     }\n }\n \n@@ -728,7 +736,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &mut Local, _ctxt: PlaceContext, _location: Location) {\n-        *local = self.make_integrate_local(*local);\n+        *local = self.map_local(*local);\n+    }\n+\n+    fn visit_source_scope(&mut self, scope: &mut SourceScope) {\n+        *scope = self.map_scope(*scope);\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n@@ -772,18 +784,18 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         match terminator.kind {\n             TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => bug!(),\n             TerminatorKind::Goto { ref mut target } => {\n-                *target = self.update_target(*target);\n+                *target = self.map_block(*target);\n             }\n             TerminatorKind::SwitchInt { ref mut targets, .. } => {\n                 for tgt in targets.all_targets_mut() {\n-                    *tgt = self.update_target(*tgt);\n+                    *tgt = self.map_block(*tgt);\n                 }\n             }\n             TerminatorKind::Drop { ref mut target, ref mut unwind, .. }\n             | TerminatorKind::DropAndReplace { ref mut target, ref mut unwind, .. } => {\n-                *target = self.update_target(*target);\n+                *target = self.map_block(*target);\n                 if let Some(tgt) = *unwind {\n-                    *unwind = Some(self.update_target(tgt));\n+                    *unwind = Some(self.map_block(tgt));\n                 } else if !self.in_cleanup_block {\n                     // Unless this drop is in a cleanup block, add an unwind edge to\n                     // the original call's cleanup block\n@@ -792,20 +804,20 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             }\n             TerminatorKind::Call { ref mut destination, ref mut cleanup, .. } => {\n                 if let Some((_, ref mut tgt)) = *destination {\n-                    *tgt = self.update_target(*tgt);\n+                    *tgt = self.map_block(*tgt);\n                 }\n                 if let Some(tgt) = *cleanup {\n-                    *cleanup = Some(self.update_target(tgt));\n+                    *cleanup = Some(self.map_block(tgt));\n                 } else if !self.in_cleanup_block {\n                     // Unless this call is in a cleanup block, add an unwind edge to\n                     // the original call's cleanup block\n                     *cleanup = self.cleanup_block;\n                 }\n             }\n             TerminatorKind::Assert { ref mut target, ref mut cleanup, .. } => {\n-                *target = self.update_target(*target);\n+                *target = self.map_block(*target);\n                 if let Some(tgt) = *cleanup {\n-                    *cleanup = Some(self.update_target(tgt));\n+                    *cleanup = Some(self.map_block(tgt));\n                 } else if !self.in_cleanup_block {\n                     // Unless this assert is in a cleanup block, add an unwind edge to\n                     // the original call's cleanup block\n@@ -823,8 +835,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             TerminatorKind::Abort => {}\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n-                *real_target = self.update_target(*real_target);\n-                *imaginary_target = self.update_target(*imaginary_target);\n+                *real_target = self.map_block(*real_target);\n+                *imaginary_target = self.map_block(*imaginary_target);\n             }\n             TerminatorKind::FalseUnwind { real_target: _, unwind: _ } =>\n             // see the ordering of passes in the optimized_mir query.\n@@ -833,13 +845,9 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             }\n             TerminatorKind::InlineAsm { ref mut destination, .. } => {\n                 if let Some(ref mut tgt) = *destination {\n-                    *tgt = self.update_target(*tgt);\n+                    *tgt = self.map_block(*tgt);\n                 }\n             }\n         }\n     }\n-\n-    fn visit_source_scope(&mut self, scope: &mut SourceScope) {\n-        *scope = self.scope_map[*scope];\n-    }\n }"}, {"sha": "ac4d6563d6c24c9e4177f61fdef83992baf97e88", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -548,8 +548,36 @@ fn write_scope_tree(\n     };\n \n     for &child in children {\n-        assert_eq!(body.source_scopes[child].parent_scope, Some(parent));\n-        writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n+        let child_data = &body.source_scopes[child];\n+        assert_eq!(child_data.parent_scope, Some(parent));\n+\n+        let (special, span) = if let Some((callee, callsite_span)) = child_data.inlined {\n+            (\n+                format!(\n+                    \" (inlined {}{})\",\n+                    if callee.def.requires_caller_location(tcx) { \"#[track_caller] \" } else { \"\" },\n+                    callee\n+                ),\n+                Some(callsite_span),\n+            )\n+        } else {\n+            (String::new(), None)\n+        };\n+\n+        let indented_header = format!(\"{0:1$}scope {2}{3} {{\", \"\", indent, child.index(), special);\n+\n+        if let Some(span) = span {\n+            writeln!(\n+                w,\n+                \"{0:1$} // at {2}\",\n+                indented_header,\n+                ALIGN,\n+                tcx.sess.source_map().span_to_string(span),\n+            )?;\n+        } else {\n+            writeln!(w, \"{}\", indented_header)?;\n+        }\n+\n         write_scope_tree(tcx, body, scope_tree, w, child, depth + 1)?;\n         writeln!(w, \"{0:1$}}}\", \"\", depth * INDENT.len())?;\n     }"}, {"sha": "f9995f43f5a8d9e1cd4656c86a1e7fb49601103a", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -334,7 +334,7 @@ struct Builder<'a, 'tcx> {\n \n     /// The vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later.\n-    source_scopes: IndexVec<SourceScope, SourceScopeData>,\n+    source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n     source_scope: SourceScope,\n \n     /// The guard-context: each time we build the guard expression for"}, {"sha": "b6321c3bf670274c61ff2bb4f113e2ef6b6bd543", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -705,6 +705,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.source_scopes.push(SourceScopeData {\n             span,\n             parent_scope: Some(parent),\n+            inlined: None,\n+            inlined_parent_scope: None,\n             local_data: ClearCrossCrate::Set(scope_local_data),\n         })\n     }"}, {"sha": "1546dfa10a3130771829616fff11d2577262a30c", "filename": "src/test/codegen/inline-debuginfo.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fcodegen%2Finline-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fcodegen%2Finline-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finline-debuginfo.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -0,0 +1,17 @@\n+#![crate_type=\"rlib\"]\n+// compile-flags: -Copt-level=3 -g\n+// ignore-tidy-linelength\n+\n+#[no_mangle]\n+#[inline(always)]\n+pub extern \"C\" fn callee(x: u32) -> u32 {\n+    x + 4\n+}\n+\n+// CHECK-LABEL: caller\n+// CHECK: call void @llvm.dbg.value(metadata i32 %y, metadata !{{.*}}, metadata !DIExpression(DW_OP_constu, 3, DW_OP_minus, DW_OP_stack_value)), !dbg [[A:!.*]]\n+// CHECK: [[A]] = !DILocation(line: {{.*}}, scope: {{.*}}, inlinedAt: {{.*}})\n+#[no_mangle]\n+pub extern \"C\" fn caller(y: u32) -> u32 {\n+    callee(y - 3)\n+}"}, {"sha": "bba10f09c3fbb1efa5aa18fd12a7936ddcf1b687", "filename": "src/test/mir-opt/dest-prop/cycle.main.DestinationPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -18,7 +18,7 @@\n               scope 3 {\n -                 debug z => _3;           // in scope 3 at $DIR/cycle.rs:11:9: 11:10\n +                 debug z => _4;           // in scope 3 at $DIR/cycle.rs:11:9: 11:10\n-                  scope 4 {\n+                  scope 4 (inlined std::mem::drop::<i32>) { // at $DIR/cycle.rs:14:5: 14:12\n                       debug _x => _6;      // in scope 4 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n                   }\n               }"}, {"sha": "0028e280516da956a5701c212bd4a9464472e57d", "filename": "src/test/mir-opt/dest-prop/union.main.DestinationPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -11,7 +11,7 @@\n           debug un => _1;                  // in scope 1 at $DIR/union.rs:13:9: 13:11\n           scope 2 {\n           }\n-          scope 3 {\n+          scope 3 (inlined std::mem::drop::<u32>) { // at $DIR/union.rs:15:5: 15:27\n               debug _x => _4;              // in scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n           }\n       }"}, {"sha": "164e769e93b027b45fc2257c736b4e85ba47eaad", "filename": "src/test/mir-opt/generator_drop_cleanup.main-{closure#0}.generator_drop.0.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fgenerator_drop_cleanup.main-%7Bclosure%230%7D.generator_drop.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fgenerator_drop_cleanup.main-%7Bclosure%230%7D.generator_drop.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator_drop_cleanup.main-%7Bclosure%230%7D.generator_drop.0.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -26,9 +26,9 @@ fn main::{closure#0}(_1: *mut [generator@$DIR/generator-drop-cleanup.rs:10:15: 1\n     scope 1 {\n         debug _s => (((*_1) as variant#3).0: std::string::String); // in scope 1 at $DIR/generator-drop-cleanup.rs:11:13: 11:15\n     }\n-    scope 2 {\n-        let mut _6: std::vec::Vec<u8>;   // in scope 2 at $DIR/generator-drop-cleanup.rs:11:18: 11:31\n-        scope 3 {\n+    scope 2 (inlined String::new) {      // at $DIR/generator-drop-cleanup.rs:11:18: 11:31\n+        let mut _6: std::vec::Vec<u8>;   // in scope 2 at $SRC_DIR/alloc/src/string.rs:LL:COL\n+        scope 3 (inlined Vec::<u8>::new) { // at $SRC_DIR/alloc/src/string.rs:LL:COL\n         }\n     }\n "}, {"sha": "b2745a17e97172975b5f18ceac801b0f62893295", "filename": "src/test/mir-opt/inline/inline_any_operand.bar.Inline.after.mir", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_any_operand.bar.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_any_operand.bar.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_any_operand.bar.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -4,15 +4,15 @@ fn bar() -> bool {\n     let mut _0: bool;                    // return place in scope 0 at $DIR/inline-any-operand.rs:10:13: 10:17\n     let _1: fn(i32, i32) -> bool {foo};  // in scope 0 at $DIR/inline-any-operand.rs:11:9: 11:10\n     let mut _2: fn(i32, i32) -> bool {foo}; // in scope 0 at $DIR/inline-any-operand.rs:12:5: 12:6\n-    let mut _5: i32;                     // in scope 0 at $DIR/inline-any-operand.rs:12:5: 12:13\n-    let mut _6: i32;                     // in scope 0 at $DIR/inline-any-operand.rs:12:5: 12:13\n+    let mut _3: i32;                     // in scope 0 at $DIR/inline-any-operand.rs:12:5: 12:13\n+    let mut _4: i32;                     // in scope 0 at $DIR/inline-any-operand.rs:12:5: 12:13\n     scope 1 {\n         debug f => _1;                   // in scope 1 at $DIR/inline-any-operand.rs:11:9: 11:10\n-        scope 2 {\n-            debug x => _5;               // in scope 2 at $DIR/inline-any-operand.rs:16:8: 16:9\n-            debug y => _6;               // in scope 2 at $DIR/inline-any-operand.rs:16:16: 16:17\n-            let mut _3: i32;             // in scope 2 at $DIR/inline-any-operand.rs:12:5: 12:13\n-            let mut _4: i32;             // in scope 2 at $DIR/inline-any-operand.rs:12:5: 12:13\n+        scope 2 (inlined foo) {          // at $DIR/inline-any-operand.rs:12:5: 12:13\n+            debug x => _3;               // in scope 2 at $DIR/inline-any-operand.rs:16:8: 16:9\n+            debug y => _4;               // in scope 2 at $DIR/inline-any-operand.rs:16:16: 16:17\n+            let mut _5: i32;             // in scope 2 at $DIR/inline-any-operand.rs:17:5: 17:6\n+            let mut _6: i32;             // in scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n         }\n     }\n \n@@ -24,19 +24,19 @@ fn bar() -> bool {\n                                          // + literal: Const { ty: fn(i32, i32) -> bool {foo}, val: Value(Scalar(<ZST>)) }\n         StorageLive(_2);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:6\n         _2 = _1;                         // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:6\n-        StorageLive(_5);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n-        _5 = const 1_i32;                // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n-        StorageLive(_6);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n-        _6 = const -1_i32;               // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n-        StorageLive(_3);                 // scope 2 at $DIR/inline-any-operand.rs:17:5: 17:6\n-        _3 = _5;                         // scope 2 at $DIR/inline-any-operand.rs:17:5: 17:6\n-        StorageLive(_4);                 // scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n-        _4 = _6;                         // scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n-        _0 = Eq(move _3, move _4);       // scope 2 at $DIR/inline-any-operand.rs:17:5: 17:11\n-        StorageDead(_4);                 // scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n-        StorageDead(_3);                 // scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n-        StorageDead(_6);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n-        StorageDead(_5);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n+        StorageLive(_3);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n+        _3 = const 1_i32;                // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n+        StorageLive(_4);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n+        _4 = const -1_i32;               // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n+        StorageLive(_5);                 // scope 2 at $DIR/inline-any-operand.rs:17:5: 17:6\n+        _5 = _3;                         // scope 2 at $DIR/inline-any-operand.rs:17:5: 17:6\n+        StorageLive(_6);                 // scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n+        _6 = _4;                         // scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n+        _0 = Eq(move _5, move _6);       // scope 2 at $DIR/inline-any-operand.rs:17:5: 17:11\n+        StorageDead(_6);                 // scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n+        StorageDead(_5);                 // scope 2 at $DIR/inline-any-operand.rs:17:10: 17:11\n+        StorageDead(_4);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n+        StorageDead(_3);                 // scope 1 at $DIR/inline-any-operand.rs:12:5: 12:13\n         StorageDead(_2);                 // scope 1 at $DIR/inline-any-operand.rs:12:12: 12:13\n         StorageDead(_1);                 // scope 0 at $DIR/inline-any-operand.rs:13:1: 13:2\n         return;                          // scope 0 at $DIR/inline-any-operand.rs:13:2: 13:2"}, {"sha": "93a63c84783915312b0f14afcb29e7faae19dbc1", "filename": "src/test/mir-opt/inline/inline_closure.foo.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure.foo.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -13,7 +13,7 @@ fn foo(_1: T, _2: i32) -> i32 {\n     let mut _9: i32;                     // in scope 0 at $DIR/inline-closure.rs:12:5: 12:12\n     scope 1 {\n         debug x => _3;                   // in scope 1 at $DIR/inline-closure.rs:11:9: 11:10\n-        scope 2 {\n+        scope 2 (inlined foo::<T>::{closure#0}) { // at $DIR/inline-closure.rs:12:5: 12:12\n             debug _t => _8;              // in scope 2 at $DIR/inline-closure.rs:11:14: 11:16\n             debug _q => _9;              // in scope 2 at $DIR/inline-closure.rs:11:18: 11:20\n         }"}, {"sha": "c6893022be60ac45f3b8ae72a6aa7cf34a0fbd07", "filename": "src/test/mir-opt/inline/inline_closure_borrows_arg.foo.Inline.after.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -9,19 +9,19 @@ fn foo(_1: T, _2: &i32) -> i32 {\n     let mut _5: (&i32, &i32);            // in scope 0 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n     let mut _6: &i32;                    // in scope 0 at $DIR/inline-closure-borrows-arg.rs:16:7: 16:8\n     let mut _7: &i32;                    // in scope 0 at $DIR/inline-closure-borrows-arg.rs:16:10: 16:11\n+    let mut _8: &i32;                    // in scope 0 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n     let mut _9: &i32;                    // in scope 0 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n-    let mut _10: &i32;                   // in scope 0 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n     scope 1 {\n         debug x => _3;                   // in scope 1 at $DIR/inline-closure-borrows-arg.rs:12:9: 12:10\n-        scope 2 {\n-            debug r => _9;               // in scope 2 at $DIR/inline-closure-borrows-arg.rs:12:14: 12:15\n-            debug _s => _10;             // in scope 2 at $DIR/inline-closure-borrows-arg.rs:12:23: 12:25\n-            let _8: &i32;                // in scope 2 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+        scope 2 (inlined foo::<T>::{closure#0}) { // at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+            debug r => _8;               // in scope 2 at $DIR/inline-closure-borrows-arg.rs:12:14: 12:15\n+            debug _s => _9;              // in scope 2 at $DIR/inline-closure-borrows-arg.rs:12:23: 12:25\n+            let _10: &i32;               // in scope 2 at $DIR/inline-closure-borrows-arg.rs:13:13: 13:21\n+            scope 3 {\n+                debug variable => _10;   // in scope 3 at $DIR/inline-closure-borrows-arg.rs:13:13: 13:21\n+            }\n         }\n     }\n-    scope 3 {\n-        debug variable => _8;            // in scope 3 at $DIR/inline-closure-borrows-arg.rs:13:13: 13:21\n-    }\n \n     bb0: {\n         StorageLive(_3);                 // scope 0 at $DIR/inline-closure-borrows-arg.rs:12:9: 12:10\n@@ -34,16 +34,16 @@ fn foo(_1: T, _2: &i32) -> i32 {\n         _7 = &(*_2);                     // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:10: 16:11\n         (_5.0: &i32) = move _6;          // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         (_5.1: &i32) = move _7;          // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+        StorageLive(_8);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+        _8 = move (_5.0: &i32);          // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageLive(_9);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n-        _9 = move (_5.0: &i32);          // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n-        StorageLive(_10);                // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n-        _10 = move (_5.1: &i32);         // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n-        StorageLive(_8);                 // scope 2 at $DIR/inline-closure-borrows-arg.rs:13:13: 13:21\n-        _8 = _9;                         // scope 2 at $DIR/inline-closure-borrows-arg.rs:13:24: 13:27\n-        _0 = (*_9);                      // scope 3 at $DIR/inline-closure-borrows-arg.rs:14:9: 14:18\n-        StorageDead(_8);                 // scope 2 at $DIR/inline-closure-borrows-arg.rs:15:5: 15:6\n-        StorageDead(_10);                // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+        _9 = move (_5.1: &i32);          // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+        StorageLive(_10);                // scope 2 at $DIR/inline-closure-borrows-arg.rs:13:13: 13:21\n+        _10 = _8;                        // scope 2 at $DIR/inline-closure-borrows-arg.rs:13:24: 13:27\n+        _0 = (*_8);                      // scope 3 at $DIR/inline-closure-borrows-arg.rs:14:9: 14:18\n+        StorageDead(_10);                // scope 2 at $DIR/inline-closure-borrows-arg.rs:15:5: 15:6\n         StorageDead(_9);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+        StorageDead(_8);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageDead(_7);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:11: 16:12\n         StorageDead(_6);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:11: 16:12\n         StorageDead(_5);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:11: 16:12"}, {"sha": "2950af63d3c607e48aef67b8c9fbc14edab585c4", "filename": "src/test/mir-opt/inline/inline_closure_captures.foo.Inline.after.mir", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -10,14 +10,14 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n     let mut _6: &[closure@foo<T>::{closure#0}]; // in scope 0 at $DIR/inline-closure-captures.rs:12:5: 12:6\n     let mut _7: (i32,);                  // in scope 0 at $DIR/inline-closure-captures.rs:12:5: 12:9\n     let mut _8: i32;                     // in scope 0 at $DIR/inline-closure-captures.rs:12:7: 12:8\n-    let mut _10: i32;                    // in scope 0 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+    let mut _9: i32;                     // in scope 0 at $DIR/inline-closure-captures.rs:12:5: 12:9\n     scope 1 {\n         debug x => _3;                   // in scope 1 at $DIR/inline-closure-captures.rs:11:9: 11:10\n-        scope 2 {\n-            debug _q => _10;             // in scope 2 at $DIR/inline-closure-captures.rs:11:14: 11:16\n+        scope 2 (inlined foo::<T>::{closure#0}) { // at $DIR/inline-closure-captures.rs:12:5: 12:9\n+            debug _q => _9;              // in scope 2 at $DIR/inline-closure-captures.rs:11:14: 11:16\n             debug q => (*((*_6).0: &i32)); // in scope 2 at $DIR/inline-closure-captures.rs:10:23: 10:24\n             debug t => (*((*_6).1: &T)); // in scope 2 at $DIR/inline-closure-captures.rs:10:17: 10:18\n-            let mut _9: T;               // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+            let mut _10: T;              // in scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n         }\n     }\n \n@@ -37,14 +37,14 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n         StorageLive(_8);                 // scope 1 at $DIR/inline-closure-captures.rs:12:7: 12:8\n         _8 = _2;                         // scope 1 at $DIR/inline-closure-captures.rs:12:7: 12:8\n         (_7.0: i32) = move _8;           // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-        StorageLive(_10);                // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-        _10 = move (_7.0: i32);          // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        StorageLive(_9);                 // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        _9 = move (_7.0: i32);           // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         (_0.0: i32) = (*((*_6).0: &i32)); // scope 2 at $DIR/inline-closure-captures.rs:11:19: 11:20\n-        StorageLive(_9);                 // scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n-        _9 = (*((*_6).1: &T));           // scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n-        (_0.1: T) = move _9;             // scope 2 at $DIR/inline-closure-captures.rs:11:18: 11:24\n-        StorageDead(_9);                 // scope 2 at $DIR/inline-closure-captures.rs:11:23: 11:24\n-        StorageDead(_10);                // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        StorageLive(_10);                // scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n+        _10 = (*((*_6).1: &T));          // scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n+        (_0.1: T) = move _10;            // scope 2 at $DIR/inline-closure-captures.rs:11:18: 11:24\n+        StorageDead(_10);                // scope 2 at $DIR/inline-closure-captures.rs:11:23: 11:24\n+        StorageDead(_9);                 // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         StorageDead(_8);                 // scope 1 at $DIR/inline-closure-captures.rs:12:8: 12:9\n         StorageDead(_7);                 // scope 1 at $DIR/inline-closure-captures.rs:12:8: 12:9\n         StorageDead(_6);                 // scope 1 at $DIR/inline-closure-captures.rs:12:8: 12:9"}, {"sha": "2fc908b51f39aef24ff0ecd14a073fe0fa81a236", "filename": "src/test/mir-opt/inline/inline_compatibility.inlined_no_sanitize.Inline.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_no_sanitize.Inline.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -4,7 +4,7 @@\n   fn inlined_no_sanitize() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:24:37: 24:37\n       let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:25:5: 25:18\n-+     scope 1 {\n++     scope 1 (inlined no_sanitize) {      // at $DIR/inline-compatibility.rs:25:5: 25:18\n +     }\n   \n       bb0: {"}, {"sha": "c92594d08de2bec9c71081a8abc150066559435d", "filename": "src/test/mir-opt/inline/inline_compatibility.inlined_target_feature.Inline.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_compatibility.inlined_target_feature.Inline.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -4,7 +4,7 @@\n   fn inlined_target_feature() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline-compatibility.rs:13:40: 13:40\n       let _1: ();                          // in scope 0 at $DIR/inline-compatibility.rs:14:5: 14:21\n-+     scope 1 {\n++     scope 1 (inlined target_feature) {   // at $DIR/inline-compatibility.rs:14:5: 14:21\n +     }\n   \n       bb0: {"}, {"sha": "f5c8ee134dbab00a0b488d2a6b7f85123458ad39", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.32bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.32bit.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -10,7 +10,7 @@\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/inline-into-box-place.rs:8:9: 8:11\n       }\n-+     scope 2 {\n++     scope 2 (inlined Vec::<u32>::new) {  // at $DIR/inline-into-box-place.rs:8:33: 8:43\n +     }\n   \n       bb0: {"}, {"sha": "5aeffa9c2a542aa136e8d08e01c3656f1d34d306", "filename": "src/test/mir-opt/inline/inline_into_box_place.main.Inline.64bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.64bit.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -10,7 +10,7 @@\n       scope 1 {\n           debug _x => _1;                  // in scope 1 at $DIR/inline-into-box-place.rs:8:9: 8:11\n       }\n-+     scope 2 {\n++     scope 2 (inlined Vec::<u32>::new) {  // at $DIR/inline-into-box-place.rs:8:33: 8:43\n +     }\n   \n       bb0: {"}, {"sha": "0cace4e32c405a1ff486dc074f1652fa19a46577", "filename": "src/test/mir-opt/inline/inline_retag.bar.Inline.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -14,11 +14,11 @@ fn bar() -> bool {\n         debug f => _1;                   // in scope 1 at $DIR/inline-retag.rs:11:9: 11:10\n         let mut _9: &i32;                // in scope 1 at $DIR/inline-retag.rs:12:11: 12:14\n         let mut _10: &i32;               // in scope 1 at $DIR/inline-retag.rs:12:7: 12:9\n-        scope 2 {\n+        scope 2 (inlined foo) {          // at $DIR/inline-retag.rs:12:5: 12:15\n             debug x => _3;               // in scope 2 at $DIR/inline-retag.rs:16:8: 16:9\n             debug y => _6;               // in scope 2 at $DIR/inline-retag.rs:16:17: 16:18\n-            let mut _11: i32;            // in scope 2 at $DIR/inline-retag.rs:12:5: 12:15\n-            let mut _12: i32;            // in scope 2 at $DIR/inline-retag.rs:12:5: 12:15\n+            let mut _11: i32;            // in scope 2 at $DIR/inline-retag.rs:17:5: 17:7\n+            let mut _12: i32;            // in scope 2 at $DIR/inline-retag.rs:17:11: 17:13\n         }\n     }\n "}, {"sha": "96442842bd5983c4831322f40e46de93f914ea58", "filename": "src/test/mir-opt/inline/inline_specialization.main.Inline.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_specialization.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_specialization.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_specialization.main.Inline.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -7,7 +7,7 @@\n       scope 1 {\n           debug x => _1;                   // in scope 1 at $DIR/inline-specialization.rs:5:9: 5:10\n       }\n-+     scope 2 {\n++     scope 2 (inlined <Vec<()> as Foo>::bar) { // at $DIR/inline-specialization.rs:5:13: 5:38\n +     }\n   \n       bb0: {"}, {"sha": "907a56d6a0e421d1d48470dcdc510d8914f20dda", "filename": "src/test/mir-opt/inline/inline_trait_method_2.test2.Inline.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_trait_method_2.test2.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Finline_trait_method_2.test2.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_trait_method_2.test2.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -5,9 +5,9 @@ fn test2(_1: &dyn X) -> bool {\n     let mut _0: bool;                    // return place in scope 0 at $DIR/inline-trait-method_2.rs:4:24: 4:28\n     let mut _2: &dyn X;                  // in scope 0 at $DIR/inline-trait-method_2.rs:5:10: 5:11\n     let mut _3: &dyn X;                  // in scope 0 at $DIR/inline-trait-method_2.rs:5:10: 5:11\n-    scope 1 {\n+    scope 1 (inlined test) {             // at $DIR/inline-trait-method_2.rs:5:5: 5:12\n         debug x => _2;                   // in scope 1 at $DIR/inline-trait-method_2.rs:9:9: 9:10\n-        let mut _4: &dyn X;              // in scope 1 at $DIR/inline-trait-method_2.rs:5:5: 5:12\n+        let mut _4: &dyn X;              // in scope 1 at $DIR/inline-trait-method_2.rs:10:5: 10:6\n     }\n \n     bb0: {"}, {"sha": "76d806acc63491e97118171a14b1a2260e33fe94", "filename": "src/test/mir-opt/inline/issue-76997-inline-scopes-parenting.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue-76997-inline-scopes-parenting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue-76997-inline-scopes-parenting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-76997-inline-scopes-parenting.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -0,0 +1,7 @@\n+// Tests that MIR inliner can handle `SourceScopeData` parenting correctly. (#76997)\n+\n+// EMIT_MIR issue_76997_inline_scopes_parenting.main.Inline.after.mir\n+fn main() {\n+    let f = |x| { let y = x; y };\n+    f(())\n+}"}, {"sha": "08f0dac2e9d05c160da4955427c40c53a1b03c2b", "filename": "src/test/mir-opt/inline/issue_58867_inline_as_ref_as_mut.a.Inline.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.a.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.a.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.a.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -6,9 +6,9 @@ fn a(_1: &mut [T]) -> &mut [T] {\n     let mut _2: &mut [T];                // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n     let mut _3: &mut [T];                // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n     let mut _4: &mut [T];                // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:6\n-    scope 1 {\n+    scope 1 (inlined <[T] as AsMut<[T]>>::as_mut) { // at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n         debug self => _4;                // in scope 1 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n-        let mut _5: &mut [T];            // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n+        let mut _5: &mut [T];            // in scope 1 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n     }\n \n     bb0: {"}, {"sha": "af97434f62929c746a6250d99f4067078fda17cb", "filename": "src/test/mir-opt/inline/issue_58867_inline_as_ref_as_mut.b.Inline.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.b.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.b.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.b.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -6,10 +6,10 @@ fn b(_1: &mut Box<T>) -> &mut T {\n     let mut _2: &mut T;                  // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n     let mut _3: &mut T;                  // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n     let mut _4: &mut std::boxed::Box<T>; // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:6\n-    scope 1 {\n+    scope 1 (inlined <Box<T> as AsMut<T>>::as_mut) { // at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n         debug self => _4;                // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n-        let mut _5: &mut T;              // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n-        let mut _6: &mut T;              // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n+        let mut _5: &mut T;              // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+        let mut _6: &mut T;              // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n     }\n \n     bb0: {"}, {"sha": "670f055dc054b164b850921057a2adf52b8760bf", "filename": "src/test/mir-opt/inline/issue_58867_inline_as_ref_as_mut.c.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.c.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.c.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.c.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -5,7 +5,7 @@ fn c(_1: &[T]) -> &[T] {\n     let mut _0: &[T];                    // return place in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:12:25: 12:29\n     let _2: &[T];                        // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:15\n     let mut _3: &[T];                    // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:6\n-    scope 1 {\n+    scope 1 (inlined <[T] as AsRef<[T]>>::as_ref) { // at $DIR/issue-58867-inline-as-ref-as-mut.rs:13:5: 13:15\n         debug self => _3;                // in scope 1 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n     }\n "}, {"sha": "c33e859eb6b0c3b531fbaae3dd64f177a48e1c70", "filename": "src/test/mir-opt/inline/issue_58867_inline_as_ref_as_mut.d.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.d.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.d.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue_58867_inline_as_ref_as_mut.d.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -5,7 +5,7 @@ fn d(_1: &Box<T>) -> &T {\n     let mut _0: &T;                      // return place in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:17:28: 17:30\n     let _2: &T;                          // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n     let mut _3: &std::boxed::Box<T>;     // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:6\n-    scope 1 {\n+    scope 1 (inlined <Box<T> as AsRef<T>>::as_ref) { // at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n         debug self => _3;                // in scope 1 at $SRC_DIR/alloc/src/boxed.rs:LL:COL\n     }\n "}, {"sha": "df5355e905eb0704f329c3af0ccf588696a2d85f", "filename": "src/test/mir-opt/inline/issue_76997_inline_scopes_parenting.main.Inline.after.mir", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -0,0 +1,41 @@\n+// MIR for `main` after Inline\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:4:11: 4:11\n+    let _1: [closure@$DIR/issue-76997-inline-scopes-parenting.rs:5:13: 5:33]; // in scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:5:9: 5:10\n+    let mut _2: &[closure@$DIR/issue-76997-inline-scopes-parenting.rs:5:13: 5:33]; // in scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:6\n+    let mut _3: ((),);                   // in scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:10\n+    let mut _4: ();                      // in scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:6:7: 6:9\n+    let mut _5: ();                      // in scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:10\n+    scope 1 {\n+        debug f => _1;                   // in scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:5:9: 5:10\n+        scope 2 (inlined main::{closure#0}) { // at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:10\n+            debug x => _5;               // in scope 2 at $DIR/issue-76997-inline-scopes-parenting.rs:5:14: 5:15\n+            let _6: ();                  // in scope 2 at $DIR/issue-76997-inline-scopes-parenting.rs:5:23: 5:24\n+            scope 3 {\n+                debug y => _6;           // in scope 3 at $DIR/issue-76997-inline-scopes-parenting.rs:5:23: 5:24\n+            }\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:5:9: 5:10\n+        StorageLive(_2);                 // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:6\n+        _2 = &_1;                        // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:6\n+        StorageLive(_3);                 // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:10\n+        StorageLive(_4);                 // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:7: 6:9\n+        (_3.0: ()) = move _4;            // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:10\n+        StorageLive(_5);                 // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:10\n+        _5 = move (_3.0: ());            // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:10\n+        StorageLive(_6);                 // scope 2 at $DIR/issue-76997-inline-scopes-parenting.rs:5:23: 5:24\n+        _6 = const ();                   // scope 2 at $DIR/issue-76997-inline-scopes-parenting.rs:5:27: 5:28\n+        _0 = const ();                   // scope 3 at $DIR/issue-76997-inline-scopes-parenting.rs:5:30: 5:31\n+        StorageDead(_6);                 // scope 2 at $DIR/issue-76997-inline-scopes-parenting.rs:5:32: 5:33\n+        StorageDead(_5);                 // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:5: 6:10\n+        StorageDead(_4);                 // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:9: 6:10\n+        StorageDead(_3);                 // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:9: 6:10\n+        StorageDead(_2);                 // scope 1 at $DIR/issue-76997-inline-scopes-parenting.rs:6:9: 6:10\n+        StorageDead(_1);                 // scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:7:1: 7:2\n+        return;                          // scope 0 at $DIR/issue-76997-inline-scopes-parenting.rs:7:2: 7:2\n+    }\n+}"}, {"sha": "23aefe07892fd44434392a3dc2c39c820a4c398f", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.32bit.diff", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -35,38 +35,38 @@\n                   scope 5 {\n                       debug arg0 => _25;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       debug arg1 => _28;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                      scope 6 {\n+                      scope 6 (inlined ArgumentV1::new::<&i32>) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                           debug x => _25;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                           debug f => _24;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _23: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _24: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _25: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _23: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _24: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _25: &&i32; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          scope 7 {\n+                          }\n                       }\n-                      scope 8 {\n+                      scope 8 (inlined ArgumentV1::new::<&i32>) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                           debug x => _28;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                           debug f => _27;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _26: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _27: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _28: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _26: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _27: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _28: &&i32; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          scope 9 {\n+                          }\n                       }\n                   }\n-                  scope 10 {\n+                  scope 10 (inlined Arguments::new_v1) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                       debug pieces => _29; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                       debug args => _31;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      let mut _29: &[&str]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _30: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _31: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _29: &[&str]; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _30: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _31: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                   }\n               }\n           }\n       }\n       scope 2 {\n           debug v => _3;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n       }\n-      scope 7 {\n-      }\n-      scope 9 {\n-      }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/issue-73223.rs:2:9: 2:14"}, {"sha": "23aefe07892fd44434392a3dc2c39c820a4c398f", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.64bit.diff", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -35,38 +35,38 @@\n                   scope 5 {\n                       debug arg0 => _25;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       debug arg1 => _28;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                      scope 6 {\n+                      scope 6 (inlined ArgumentV1::new::<&i32>) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                           debug x => _25;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                           debug f => _24;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _23: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _24: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _25: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _23: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _24: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _25: &&i32; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          scope 7 {\n+                          }\n                       }\n-                      scope 8 {\n+                      scope 8 (inlined ArgumentV1::new::<&i32>) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                           debug x => _28;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                           debug f => _27;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _26: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _27: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _28: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _26: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _27: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _28: &&i32; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          scope 9 {\n+                          }\n                       }\n                   }\n-                  scope 10 {\n+                  scope 10 (inlined Arguments::new_v1) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                       debug pieces => _29; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                       debug args => _31;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      let mut _29: &[&str]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _30: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _31: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _29: &[&str]; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _30: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _31: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                   }\n               }\n           }\n       }\n       scope 2 {\n           debug v => _3;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n       }\n-      scope 7 {\n-      }\n-      scope 9 {\n-      }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/issue-73223.rs:2:9: 2:14"}, {"sha": "b9cb58e14c45dda02bc3cfe2e46e8c0fe3f8851a", "filename": "src/test/mir-opt/issue_73223.main.SimplifyArmIdentity.32bit.diff", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.32bit.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -58,40 +58,40 @@\n                   scope 5 {\n                       debug arg0 => _36;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       debug arg1 => _37;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                      scope 6 {\n+                      scope 6 (inlined ArgumentV1::new::<&i32>) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                           debug x => _39;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                           debug f => _40;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _46: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _47: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _48: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _49: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _46: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _47: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _48: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _49: &&i32; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          scope 7 {\n+                          }\n                       }\n-                      scope 8 {\n+                      scope 8 (inlined ArgumentV1::new::<&i32>) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                           debug x => _42;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                           debug f => _43;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _50: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _51: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _52: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _53: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _50: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _51: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _52: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _53: &&i32; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          scope 9 {\n+                          }\n                       }\n                   }\n-                  scope 10 {\n+                  scope 10 (inlined Arguments::new_v1) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                       debug pieces => _23; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                       debug args => _27;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      let mut _54: &[&str]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _55: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _56: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _54: &[&str]; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _55: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _56: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                   }\n               }\n           }\n       }\n       scope 2 {\n           debug v => _4;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n       }\n-      scope 7 {\n-      }\n-      scope 9 {\n-      }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/issue-73223.rs:2:9: 2:14"}, {"sha": "b9cb58e14c45dda02bc3cfe2e46e8c0fe3f8851a", "filename": "src/test/mir-opt/issue_73223.main.SimplifyArmIdentity.64bit.diff", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.64bit.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -58,40 +58,40 @@\n                   scope 5 {\n                       debug arg0 => _36;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       debug arg1 => _37;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                      scope 6 {\n+                      scope 6 (inlined ArgumentV1::new::<&i32>) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                           debug x => _39;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                           debug f => _40;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _46: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _47: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _48: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _49: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _46: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _47: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _48: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _49: &&i32; // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          scope 7 {\n+                          }\n                       }\n-                      scope 8 {\n+                      scope 8 (inlined ArgumentV1::new::<&i32>) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                           debug x => _42;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                           debug f => _43;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _50: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _51: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _52: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _53: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _50: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _51: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _52: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _53: &&i32; // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          scope 9 {\n+                          }\n                       }\n                   }\n-                  scope 10 {\n+                  scope 10 (inlined Arguments::new_v1) { // at $SRC_DIR/std/src/macros.rs:LL:COL\n                       debug pieces => _23; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                       debug args => _27;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      let mut _54: &[&str]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _55: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                      let mut _56: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _54: &[&str]; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _55: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _56: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                   }\n               }\n           }\n       }\n       scope 2 {\n           debug v => _4;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n       }\n-      scope 7 {\n-      }\n-      scope 9 {\n-      }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/issue-73223.rs:2:9: 2:14"}, {"sha": "d84012295e4d3c81dba9842f41331c0ce0e79441", "filename": "src/test/mir-opt/remove_unneeded_drops.cannot_opt_generic.RemoveUnneededDrops.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.cannot_opt_generic.RemoveUnneededDrops.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.cannot_opt_generic.RemoveUnneededDrops.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.cannot_opt_generic.RemoveUnneededDrops.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -6,7 +6,7 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/remove_unneeded_drops.rs:20:32: 20:32\n       let _2: ();                          // in scope 0 at $DIR/remove_unneeded_drops.rs:21:5: 21:12\n       let mut _3: T;                       // in scope 0 at $DIR/remove_unneeded_drops.rs:21:10: 21:11\n-      scope 1 {\n+      scope 1 (inlined std::mem::drop::<T>) { // at $DIR/remove_unneeded_drops.rs:21:5: 21:12\n           debug _x => _3;                  // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n       }\n   "}, {"sha": "b0b1e80e864c4ec22bff2e6dd5c4802ae502d4e9", "filename": "src/test/mir-opt/remove_unneeded_drops.dont_opt.RemoveUnneededDrops.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.dont_opt.RemoveUnneededDrops.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.dont_opt.RemoveUnneededDrops.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.dont_opt.RemoveUnneededDrops.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -6,7 +6,7 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/remove_unneeded_drops.rs:8:27: 8:27\n       let _2: ();                          // in scope 0 at $DIR/remove_unneeded_drops.rs:9:5: 9:12\n       let mut _3: std::vec::Vec<bool>;     // in scope 0 at $DIR/remove_unneeded_drops.rs:9:10: 9:11\n-      scope 1 {\n+      scope 1 (inlined std::mem::drop::<Vec<bool>>) { // at $DIR/remove_unneeded_drops.rs:9:5: 9:12\n           debug _x => _3;                  // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n       }\n   "}, {"sha": "0984829435b66bb144078f48c041075162ebcf6f", "filename": "src/test/mir-opt/remove_unneeded_drops.opt.RemoveUnneededDrops.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.opt.RemoveUnneededDrops.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.opt.RemoveUnneededDrops.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.opt.RemoveUnneededDrops.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -6,7 +6,7 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/remove_unneeded_drops.rs:3:17: 3:17\n       let _2: ();                          // in scope 0 at $DIR/remove_unneeded_drops.rs:4:5: 4:12\n       let mut _3: bool;                    // in scope 0 at $DIR/remove_unneeded_drops.rs:4:10: 4:11\n-      scope 1 {\n+      scope 1 (inlined std::mem::drop::<bool>) { // at $DIR/remove_unneeded_drops.rs:4:5: 4:12\n           debug _x => _3;                  // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n       }\n   "}, {"sha": "0b0ce968af076068678acfb28cc916a5d98adb26", "filename": "src/test/mir-opt/remove_unneeded_drops.opt_generic_copy.RemoveUnneededDrops.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.opt_generic_copy.RemoveUnneededDrops.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.opt_generic_copy.RemoveUnneededDrops.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_unneeded_drops.opt_generic_copy.RemoveUnneededDrops.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -6,7 +6,7 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/remove_unneeded_drops.rs:13:36: 13:36\n       let _2: ();                          // in scope 0 at $DIR/remove_unneeded_drops.rs:14:5: 14:12\n       let mut _3: T;                       // in scope 0 at $DIR/remove_unneeded_drops.rs:14:10: 14:11\n-      scope 1 {\n+      scope 1 (inlined std::mem::drop::<T>) { // at $DIR/remove_unneeded_drops.rs:14:5: 14:12\n           debug _x => _3;                  // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n       }\n   "}, {"sha": "9a9395c3c889116c67ac466d6c9e61f35b90de2e", "filename": "src/test/mir-opt/simplify_arm.id_try.SimplifyArmIdentity.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyArmIdentity.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -22,14 +22,14 @@\n -         debug err => _6;                 // in scope 2 at $DIR/simplify-arm.rs:24:14: 24:15\n +         debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify-arm.rs:24:14: 24:15\n           scope 3 {\n-              scope 7 {\n+              scope 7 (inlined <i32 as From<i32>>::from) { // at $DIR/simplify-arm.rs:24:14: 24:15\n -                 debug t => _9;           // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n +                 debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n               }\n-              scope 8 {\n+              scope 8 (inlined <std::result::Result<u8, i32> as Try>::from_error) { // at $DIR/simplify-arm.rs:24:13: 24:15\n -                 debug v => _8;           // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify-arm.rs:24:13: 24:15\n+                  let mut _12: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n               }\n           }\n       }\n@@ -39,7 +39,7 @@\n           scope 5 {\n           }\n       }\n-      scope 6 {\n+      scope 6 (inlined <std::result::Result<u8, i32> as Try>::into_result) { // at $DIR/simplify-arm.rs:24:13: 24:15\n           debug self => _4;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   "}, {"sha": "ed96a22f8e3d0e980107b4c1de929d124538d047", "filename": "src/test/mir-opt/simplify_arm.id_try.SimplifyBranchSame.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyBranchSame.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -20,12 +20,12 @@\n       scope 2 {\n           debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify-arm.rs:24:14: 24:15\n           scope 3 {\n-              scope 7 {\n+              scope 7 (inlined <i32 as From<i32>>::from) { // at $DIR/simplify-arm.rs:24:14: 24:15\n                   debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n               }\n-              scope 8 {\n+              scope 8 (inlined <std::result::Result<u8, i32> as Try>::from_error) { // at $DIR/simplify-arm.rs:24:13: 24:15\n                   debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify-arm.rs:24:13: 24:15\n+                  let mut _12: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n               }\n           }\n       }\n@@ -34,7 +34,7 @@\n           scope 5 {\n           }\n       }\n-      scope 6 {\n+      scope 6 (inlined <std::result::Result<u8, i32> as Try>::into_result) { // at $DIR/simplify-arm.rs:24:13: 24:15\n           debug self => _4;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   "}, {"sha": "38da3a8a9e8d3d6ee92dab4d6800d6d7591ace0a", "filename": "src/test/mir-opt/simplify_try.try_identity.DestinationPropagation.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -20,12 +20,12 @@\n       scope 2 {\n           debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:8:14: 8:15\n           scope 3 {\n-              scope 7 {\n+              scope 7 (inlined <i32 as From<i32>>::from) { // at $DIR/simplify_try.rs:8:14: 8:15\n                   debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n               }\n-              scope 8 {\n+              scope 8 (inlined <std::result::Result<u32, i32> as Try>::from_error) { // at $DIR/simplify_try.rs:8:13: 8:15\n                   debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:13: 8:15\n+                  let mut _12: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n               }\n           }\n       }\n@@ -34,7 +34,7 @@\n           scope 5 {\n           }\n       }\n-      scope 6 {\n+      scope 6 (inlined <std::result::Result<u32, i32> as Try>::into_result) { // at $DIR/simplify_try.rs:8:13: 8:15\n -         debug self => _4;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n +         debug self => _0;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n       }"}, {"sha": "29b338b339b26f532a22293826c497400d416f60", "filename": "src/test/mir-opt/simplify_try.try_identity.SimplifyArmIdentity.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -22,14 +22,14 @@\n -         debug err => _6;                 // in scope 2 at $DIR/simplify_try.rs:8:14: 8:15\n +         debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:8:14: 8:15\n           scope 3 {\n-              scope 7 {\n+              scope 7 (inlined <i32 as From<i32>>::from) { // at $DIR/simplify_try.rs:8:14: 8:15\n -                 debug t => _9;           // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n +                 debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n               }\n-              scope 8 {\n+              scope 8 (inlined <std::result::Result<u32, i32> as Try>::from_error) { // at $DIR/simplify_try.rs:8:13: 8:15\n -                 debug v => _8;           // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:13: 8:15\n+                  let mut _12: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n               }\n           }\n       }\n@@ -39,7 +39,7 @@\n           scope 5 {\n           }\n       }\n-      scope 6 {\n+      scope 6 (inlined <std::result::Result<u32, i32> as Try>::into_result) { // at $DIR/simplify_try.rs:8:13: 8:15\n           debug self => _4;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   "}, {"sha": "e3527b99576fdb86b4c5b3f63f09a9d10b909431", "filename": "src/test/mir-opt/simplify_try.try_identity.SimplifyBranchSame.after.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -19,12 +19,12 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n     scope 2 {\n         debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:8:14: 8:15\n         scope 3 {\n-            scope 7 {\n+            scope 7 (inlined <i32 as From<i32>>::from) { // at $DIR/simplify_try.rs:8:14: 8:15\n                 debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n             }\n-            scope 8 {\n+            scope 8 (inlined <std::result::Result<u32, i32> as Try>::from_error) { // at $DIR/simplify_try.rs:8:13: 8:15\n                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:13: 8:15\n+                let mut _12: i32;        // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n             }\n         }\n     }\n@@ -33,7 +33,7 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n         scope 5 {\n         }\n     }\n-    scope 6 {\n+    scope 6 (inlined <std::result::Result<u32, i32> as Try>::into_result) { // at $DIR/simplify_try.rs:8:13: 8:15\n         debug self => _4;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n "}, {"sha": "51029c3021a8b5fec7656d9c5723325e669858cf", "filename": "src/test/mir-opt/simplify_try.try_identity.SimplifyLocals.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyLocals.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyLocals.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyLocals.after.mir?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -9,10 +9,10 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n     scope 2 {\n         debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:8:14: 8:15\n         scope 3 {\n-            scope 7 {\n+            scope 7 (inlined <i32 as From<i32>>::from) { // at $DIR/simplify_try.rs:8:14: 8:15\n                 debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n             }\n-            scope 8 {\n+            scope 8 (inlined <std::result::Result<u32, i32> as Try>::from_error) { // at $DIR/simplify_try.rs:8:13: 8:15\n                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n             }\n         }\n@@ -22,7 +22,7 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n         scope 5 {\n         }\n     }\n-    scope 6 {\n+    scope 6 (inlined <std::result::Result<u32, i32> as Try>::into_result) { // at $DIR/simplify_try.rs:8:13: 8:15\n         debug self => _0;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n "}, {"sha": "b2ed8a0d7da685c305460228cb18ac0c3992a61c", "filename": "src/test/ui/rfc-2091-track-caller/caller-location-intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+// revisions: default mir-opt\n+//[mir-opt] compile-flags: -Zmir-opt-level=3\n \n #[inline(never)]\n #[track_caller]\n@@ -13,13 +15,13 @@ macro_rules! caller_location_from_macro {\n fn main() {\n     let loc = codegen_caller_loc();\n     assert_eq!(loc.file(), file!());\n-    assert_eq!(loc.line(), 14);\n+    assert_eq!(loc.line(), 16);\n     assert_eq!(loc.column(), 15);\n \n     // `Location::caller()` in a macro should behave similarly to `file!` and `line!`,\n     // i.e. point to where the macro was invoked, instead of the macro itself.\n     let loc2 = caller_location_from_macro!();\n     assert_eq!(loc2.file(), file!());\n-    assert_eq!(loc2.line(), 21);\n+    assert_eq!(loc2.line(), 23);\n     assert_eq!(loc2.column(), 16);\n }"}, {"sha": "89a42acafba782823dc52ae0519fd6600270c88b", "filename": "src/test/ui/rfc-2091-track-caller/const-caller-location.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fconst-caller-location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fconst-caller-location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fconst-caller-location.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+// revisions: default mir-opt\n+//[mir-opt] compile-flags: -Zmir-opt-level=3\n \n #![feature(const_caller_location, const_fn)]\n \n@@ -24,18 +26,18 @@ const fn contained() -> &'static Location<'static> {\n \n fn main() {\n     assert_eq!(LOCATION.file(), file!());\n-    assert_eq!(LOCATION.line(), 7);\n+    assert_eq!(LOCATION.line(), 9);\n     assert_eq!(LOCATION.column(), 29);\n \n     assert_eq!(TRACKED.file(), file!());\n-    assert_eq!(TRACKED.line(), 9);\n+    assert_eq!(TRACKED.line(), 11);\n     assert_eq!(TRACKED.column(), 28);\n \n     assert_eq!(NESTED.file(), file!());\n-    assert_eq!(NESTED.line(), 17);\n+    assert_eq!(NESTED.line(), 19);\n     assert_eq!(NESTED.column(), 5);\n \n     assert_eq!(CONTAINED.file(), file!());\n-    assert_eq!(CONTAINED.line(), 22);\n+    assert_eq!(CONTAINED.line(), 24);\n     assert_eq!(CONTAINED.column(), 5);\n }"}, {"sha": "d072fb76f10d8b74fc936894c43cf020eb52da3e", "filename": "src/test/ui/rfc-2091-track-caller/intrinsic-wrapper.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+// revisions: default mir-opt\n+//[mir-opt] compile-flags: -Zmir-opt-level=3\n \n macro_rules! caller_location_from_macro {\n     () => (core::panic::Location::caller());\n@@ -7,13 +9,13 @@ macro_rules! caller_location_from_macro {\n fn main() {\n     let loc = core::panic::Location::caller();\n     assert_eq!(loc.file(), file!());\n-    assert_eq!(loc.line(), 8);\n+    assert_eq!(loc.line(), 10);\n     assert_eq!(loc.column(), 15);\n \n     // `Location::caller()` in a macro should behave similarly to `file!` and `line!`,\n     // i.e. point to where the macro was invoked, instead of the macro itself.\n     let loc2 = caller_location_from_macro!();\n     assert_eq!(loc2.file(), file!());\n-    assert_eq!(loc2.line(), 15);\n+    assert_eq!(loc2.line(), 17);\n     assert_eq!(loc2.column(), 16);\n }"}, {"sha": "4d548d4f0aa395e22e092371d4a4ce547480e3c3", "filename": "src/test/ui/rfc-2091-track-caller/pass.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fpass.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,4 +1,7 @@\n // run-pass\n+// revisions: default mir-opt\n+//[mir-opt] compile-flags: -Zmir-opt-level=3\n+\n #[track_caller]\n fn f() {}\n "}, {"sha": "0d7a5c42532f1cd53f9a1134c4c9e8c4b942ed9d", "filename": "src/test/ui/rfc-2091-track-caller/std-panic-locations.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,5 +1,7 @@\n // run-pass\n // ignore-wasm32-bare compiled with panic=abort by default\n+// revisions: default mir-opt\n+//[mir-opt] compile-flags: -Zmir-opt-level=3\n \n #![feature(option_expect_none, option_unwrap_none)]\n #![allow(unconditional_panic)]"}, {"sha": "43135ebbf65df3e223ba26e2808d3f011ef1a589", "filename": "src/test/ui/rfc-2091-track-caller/track-caller-attribute.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftrack-caller-attribute.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+// revisions: default mir-opt\n+//[mir-opt] compile-flags: -Zmir-opt-level=3\n \n use std::panic::Location;\n \n@@ -18,21 +20,21 @@ fn nested_tracked() -> &'static Location<'static> {\n fn main() {\n     let location = Location::caller();\n     assert_eq!(location.file(), file!());\n-    assert_eq!(location.line(), 19);\n+    assert_eq!(location.line(), 21);\n     assert_eq!(location.column(), 20);\n \n     let tracked = tracked();\n     assert_eq!(tracked.file(), file!());\n-    assert_eq!(tracked.line(), 24);\n+    assert_eq!(tracked.line(), 26);\n     assert_eq!(tracked.column(), 19);\n \n     let nested = nested_intrinsic();\n     assert_eq!(nested.file(), file!());\n-    assert_eq!(nested.line(), 11);\n+    assert_eq!(nested.line(), 13);\n     assert_eq!(nested.column(), 5);\n \n     let contained = nested_tracked();\n     assert_eq!(contained.file(), file!());\n-    assert_eq!(contained.line(), 15);\n+    assert_eq!(contained.line(), 17);\n     assert_eq!(contained.column(), 5);\n }"}, {"sha": "2122a4ca219250d18568283032fb4b2e1dd0601d", "filename": "src/test/ui/rfc-2091-track-caller/tracked-fn-ptr-with-arg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr-with-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr-with-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr-with-arg.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+// revisions: default mir-opt\n+//[mir-opt] compile-flags: -Zmir-opt-level=3\n \n fn pass_to_ptr_call<T>(f: fn(T), x: T) {\n     f(x);"}, {"sha": "922d2d7b7021a9d7c187b91270c36f7a9adbb5e3", "filename": "src/test/ui/rfc-2091-track-caller/tracked-fn-ptr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da6d42f297642a60f2640ec313b879b376b9ad8/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Ftracked-fn-ptr.rs?ref=0da6d42f297642a60f2640ec313b879b376b9ad8", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+// revisions: default mir-opt\n+//[mir-opt] compile-flags: -Zmir-opt-level=3\n \n fn ptr_call(f: fn()) {\n     f();"}]}