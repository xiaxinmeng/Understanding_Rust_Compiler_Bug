{"sha": "2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5", "node_id": "C_kwDOAAsO6NoAKDJhOTIxNzYwMWMwZTVhZTgzZmE4YmNhNjc5NzEzN2E2ZDJmN2U0ZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-13T00:37:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-13T00:37:28Z"}, "message": "Auto merge of #102372 - abrown:issue-102157, r=thomcc\n\nAllow compiling the `wasm32-wasi` std library with atomics\n\nThe issue #102157 demonstrates how currently the `-Z build-std` option will fail when re-compiling the standard library with `RUSTFLAGS` like `RUSTFLAGS=\"-C target-feature=+atomics,+bulk-memory -C link-args=--shared-memory\"`. This change attempts to resolve those build issues by depending on the the WebAssembly `futex` module and providing an implementation for `env_lock`. Fixes #102157.", "tree": {"sha": "c25ae335d6dc9bd35d582122abccbfcda152eab8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c25ae335d6dc9bd35d582122abccbfcda152eab8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5", "html_url": "https://github.com/rust-lang/rust/commit/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0938e1680daf66ca6aad428aedf9a920a0dab5ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/0938e1680daf66ca6aad428aedf9a920a0dab5ad", "html_url": "https://github.com/rust-lang/rust/commit/0938e1680daf66ca6aad428aedf9a920a0dab5ad"}, {"sha": "95b0b2d34956c232ace714c1f5971b20e2767c6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b0b2d34956c232ace714c1f5971b20e2767c6c", "html_url": "https://github.com/rust-lang/rust/commit/95b0b2d34956c232ace714c1f5971b20e2767c6c"}], "stats": {"total": 37, "additions": 28, "deletions": 9}, "files": [{"sha": "c8c47763a340b30299e61d6fa4a358b82759c678", "filename": "library/std/src/sys/wasi/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs?ref=2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5", "patch": "@@ -25,6 +25,9 @@ pub mod cmath;\n pub mod env;\n pub mod fd;\n pub mod fs;\n+#[allow(unused)]\n+#[path = \"../wasm/atomics/futex.rs\"]\n+pub mod futex;\n pub mod io;\n #[path = \"../unsupported/locks/mod.rs\"]\n pub mod locks;"}, {"sha": "f5513e9996d40b1d41e037898aab3c4e6ec40277", "filename": "library/std/src/sys/wasi/os.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fos.rs?ref=2a9217601c0e5ae83fa8bca6797137a6d2f7e4e5", "patch": "@@ -1,11 +1,11 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n \n-use crate::any::Any;\n use crate::error::Error as StdError;\n use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n+use crate::ops::Drop;\n use crate::os::wasi::prelude::*;\n use crate::path::{self, PathBuf};\n use crate::str;\n@@ -24,10 +24,26 @@ mod libc {\n     }\n }\n \n-#[cfg(not(target_feature = \"atomics\"))]\n-pub unsafe fn env_lock() -> impl Any {\n-    // No need for a lock if we're single-threaded, but this function will need\n-    // to get implemented for multi-threaded scenarios\n+cfg_if::cfg_if! {\n+    if #[cfg(target_feature = \"atomics\")] {\n+        // Access to the environment must be protected by a lock in multi-threaded scenarios.\n+        use crate::sync::{PoisonError, RwLock};\n+        static ENV_LOCK: RwLock<()> = RwLock::new(());\n+        pub fn env_read_lock() -> impl Drop {\n+            ENV_LOCK.read().unwrap_or_else(PoisonError::into_inner)\n+        }\n+        pub fn env_write_lock() -> impl Drop {\n+            ENV_LOCK.write().unwrap_or_else(PoisonError::into_inner)\n+        }\n+    } else {\n+        // No need for a lock if we are single-threaded.\n+        pub fn env_read_lock() -> impl Drop {\n+            Box::new(())\n+        }\n+        pub fn env_write_lock() -> impl Drop {\n+            Box::new(())\n+        }\n+    }\n }\n \n pub fn errno() -> i32 {\n@@ -144,7 +160,7 @@ impl Iterator for Env {\n \n pub fn env() -> Env {\n     unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_read_lock();\n         let mut environ = libc::environ;\n         let mut result = Vec::new();\n         if !environ.is_null() {\n@@ -175,7 +191,7 @@ pub fn env() -> Env {\n \n pub fn getenv(k: &OsStr) -> Option<OsString> {\n     let s = run_with_cstr(k.as_bytes(), |k| unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_read_lock();\n         Ok(libc::getenv(k.as_ptr()) as *const libc::c_char)\n     })\n     .ok()?;\n@@ -189,15 +205,15 @@ pub fn getenv(k: &OsStr) -> Option<OsString> {\n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     run_with_cstr(k.as_bytes(), |k| {\n         run_with_cstr(v.as_bytes(), |v| unsafe {\n-            let _guard = env_lock();\n+            let _guard = env_write_lock();\n             cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n         })\n     })\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     run_with_cstr(n.as_bytes(), |nbuf| unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_write_lock();\n         cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n     })\n }"}]}