{"sha": "7c7cb264876d0ac75c4428ceeef0b7ef822c1818", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjN2NiMjY0ODc2ZDBhYzc1YzQ0MjhjZWVlZjBiN2VmODIyYzE4MTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T05:44:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-14T22:32:25Z"}, "message": "treat different kinds of closures differently", "tree": {"sha": "f33103bcbb61768604b1ffa125ff5063be101222", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f33103bcbb61768604b1ffa125ff5063be101222"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c7cb264876d0ac75c4428ceeef0b7ef822c1818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c7cb264876d0ac75c4428ceeef0b7ef822c1818", "html_url": "https://github.com/rust-lang/rust/commit/7c7cb264876d0ac75c4428ceeef0b7ef822c1818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c7cb264876d0ac75c4428ceeef0b7ef822c1818/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35fe86dab74254cf4b74a4e28506fa84d81871e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/35fe86dab74254cf4b74a4e28506fa84d81871e2", "html_url": "https://github.com/rust-lang/rust/commit/35fe86dab74254cf4b74a4e28506fa84d81871e2"}], "stats": {"total": 72, "additions": 53, "deletions": 19}, "files": [{"sha": "d2ee2105be726448f7fe4d3af56b62393b96def3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7c7cb264876d0ac75c4428ceeef0b7ef822c1818/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c7cb264876d0ac75c4428ceeef0b7ef822c1818/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7c7cb264876d0ac75c4428ceeef0b7ef822c1818", "patch": "@@ -1292,20 +1292,27 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n \n fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n     let bcx = cx;\n+    let tcx = bcx_tcx(cx);\n     // NB: v is an *alias* of type t here, not a direct value.\n-    if ty::type_is_boxed(bcx_tcx(bcx), t) {\n+    alt ty::struct(tcx, t) {\n+      ty::ty_box(_) {\n         bcx = incr_refcnt_of_boxed(bcx, Load(bcx, v));\n-    } else if ty::type_is_unique_box(bcx_tcx(bcx), t) {\n+      }\n+      ty::ty_uniq(_) {\n         check trans_uniq::type_is_unique_box(bcx, t);\n         let {bcx: cx, val} = trans_uniq::duplicate(bcx, Load(bcx, v), t);\n         bcx = cx;\n         Store(bcx, val, v);\n-    } else if ty::type_is_structural(bcx_tcx(bcx), t) {\n-        bcx = iter_structural_ty(bcx, v, t, take_ty);\n-    } else if ty::type_is_vec(bcx_tcx(bcx), t) {\n+      }\n+      ty::ty_vec(_) | ty::ty_str. {\n         let {bcx: cx, val} = tvec::duplicate(bcx, Load(bcx, v), t);\n         bcx = cx;\n         Store(bcx, val, v);\n+      }\n+      _ when ty::type_is_structural(bcx_tcx(bcx), t) {\n+        bcx = iter_structural_ty(bcx, v, t, take_ty);\n+      }\n+      _ { /* fallthrough */ }\n     }\n \n     build_return(bcx);\n@@ -1321,6 +1328,19 @@ fn incr_refcnt_of_boxed(cx: @block_ctxt, box_ptr: ValueRef) -> @block_ctxt {\n     ret cx;\n }\n \n+fn call_bound_data_glue_for_closure(bcx: @block_ctxt,\n+                                    v: ValueRef,\n+                                    field: int) {\n+    // Call through the closure's own fields-drop glue.\n+    let ccx = bcx_ccx(bcx);\n+    let v = PointerCast(bcx, v, T_opaque_closure_ptr(ccx));\n+    let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n+    let bindings = GEPi(bcx, body, [0, abi::closure_elt_bindings]);\n+    let tydescptr = GEPi(bcx, body, [0, abi::closure_elt_tydesc]);\n+    let ti = none;\n+    call_tydesc_glue_full(bcx, bindings, Load(bcx, tydescptr), field, ti);\n+}\n+\n fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n     // v is a pointer to the actual box component of the type here. The\n     // ValueRef will have the wrong type here (make_generic_glue is casting\n@@ -1359,19 +1379,22 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n             trans_non_gc_free(bcx, b)\n         } else { bcx }\n       }\n-      ty::ty_fn(_, _, _, _, _) {\n-        // Call through the closure's own fields-drop glue first.\n-        // Then free the body.\n-        let ccx = bcx_ccx(bcx);\n-        let v = PointerCast(bcx, v, T_opaque_closure_ptr(ccx));\n-        let body = GEPi(bcx, v, [0, abi::box_rc_field_body]);\n-        let bindings =\n-            GEPi(bcx, body, [0, abi::closure_elt_bindings]);\n-        let tydescptr =\n-            GEPi(bcx, body, [0, abi::closure_elt_tydesc]);\n-        let ti = none;\n-        call_tydesc_glue_full(bcx, bindings, Load(bcx, tydescptr),\n-                              abi::tydesc_field_drop_glue, ti);\n+      ty::ty_fn(ast::proto_bare., _, _, _, _) {\n+        bcx\n+      }\n+      ty::ty_fn(ast::proto_block., _, _, _, _) {\n+        bcx\n+      }\n+      ty::ty_fn(ast::proto_send., _, _, _, _) {\n+        // n.b.: When we drop a function, we actually invoke the\n+        // free glue only on the environment part.\n+        call_bound_data_glue_for_closure(bcx, v, abi::tydesc_field_drop_glue);\n+        trans_shared_free(bcx, v)\n+      }\n+      ty::ty_fn(ast::proto_shared(_), _, _, _, _) {\n+        // n.b.: When we drop a function, we actually invoke the\n+        // free glue only on the environment part.\n+        call_bound_data_glue_for_closure(bcx, v, abi::tydesc_field_drop_glue);\n         if !bcx_ccx(bcx).sess.get_opts().do_gc {\n             trans_non_gc_free(bcx, v)\n         } else { bcx }\n@@ -1398,7 +1421,18 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n           ty::ty_res(did, inner, tps) {\n             trans_res_drop(bcx, v0, did, inner, tps)\n           }\n-          ty::ty_fn(_, _, _, _, _) {\n+          ty::ty_fn(ast::proto_bare., _, _, _, _) {\n+            bcx // No environment to free.\n+          }\n+          ty::ty_fn(ast::proto_block., _, _, _, _) {\n+            bcx // Environment is stack allocated and needs no free.\n+          }\n+          ty::ty_fn(ast::proto_send., _, _, _, _) {\n+            // Environment is a unique pointer.\n+            let box_cell = GEPi(bcx, v0, [0, abi::fn_field_box]);\n+            free_ty(bcx, Load(bcx, box_cell), t)\n+          }\n+          ty::ty_fn(ast::proto_shared(_), _, _, _, _) {\n             let box_cell = GEPi(bcx, v0, [0, abi::fn_field_box]);\n             decr_refcnt_maybe_free(bcx, Load(bcx, box_cell), t)\n           }"}]}