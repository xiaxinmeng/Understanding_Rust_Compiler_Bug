{"sha": "9bce4d669647c11c87be39fd08db5a68bf324c12", "node_id": "C_kwDOAAsO6NoAKDliY2U0ZDY2OTY0N2MxMWM4N2JlMzlmZDA4ZGI1YTY4YmYzMjRjMTI", "commit": {"author": {"name": "Anatol Ulrich", "email": "anatol.ulrich@ferrous-systems.com", "date": "2021-11-02T20:38:38Z"}, "committer": {"name": "Anatol Ulrich", "email": "anatol.ulrich@ferrous-systems.com", "date": "2021-11-02T20:38:38Z"}, "message": "accept identical Indels when merging; add rename test case", "tree": {"sha": "967bf34a96320e6f519224e3a577422dd3bbb986", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/967bf34a96320e6f519224e3a577422dd3bbb986"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bce4d669647c11c87be39fd08db5a68bf324c12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bce4d669647c11c87be39fd08db5a68bf324c12", "html_url": "https://github.com/rust-lang/rust/commit/9bce4d669647c11c87be39fd08db5a68bf324c12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bce4d669647c11c87be39fd08db5a68bf324c12/comments", "author": null, "committer": null, "parents": [{"sha": "1ac35532c4f934b2453501ec39efa87bf1e5724d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac35532c4f934b2453501ec39efa87bf1e5724d", "html_url": "https://github.com/rust-lang/rust/commit/1ac35532c4f934b2453501ec39efa87bf1e5724d"}], "stats": {"total": 72, "additions": 57, "deletions": 15}, "files": [{"sha": "9ce0dd7404a7d9169eb4ea83899f4acc593746c3", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9bce4d669647c11c87be39fd08db5a68bf324c12/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bce4d669647c11c87be39fd08db5a68bf324c12/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=9bce4d669647c11c87be39fd08db5a68bf324c12", "patch": "@@ -100,6 +100,7 @@ pub(crate) fn rename(\n             def.rename(&sema, new_name)\n         })\n         .collect();\n+\n     ops?.into_iter()\n         .reduce(|acc, elem| acc.merge(elem))\n         .ok_or_else(|| format_err!(\"No references found at position\"))\n@@ -186,13 +187,14 @@ fn find_definitions(\n             res\n         });\n \n-    let res: RenameResult<Vec<(ast::NameLike, Definition)>> = symbols.collect();\n+    let res: RenameResult<Vec<_>> = symbols.collect();\n     match res {\n-        // remove duplicates\n         Ok(v) => {\n             if v.is_empty() {\n+                // FIXME: some semantic duplication between \"empty vec\" and \"Err()\"\n                 Err(format_err!(\"No references found at position\"))\n             } else {\n+                // remove duplicates, comparing `Definition`s\n                 Ok(v.into_iter().unique_by(|t| t.1))\n             }\n         }\n@@ -569,6 +571,36 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_macro_multiple_occurrences() {\n+        check(\n+            \"Baaah\",\n+            r#\"macro_rules! foo {\n+    ($ident:ident) => {\n+        const $ident: () = ();\n+        struct $ident {}\n+    };\n+}\n+\n+foo!($0Foo);\n+const _: () = Foo;\n+const _: Foo = Foo {};\n+    \"#,\n+            r#\"\n+macro_rules! foo {\n+    ($ident:ident) => {\n+        const $ident: () = ();\n+        struct $ident {}\n+    };\n+}\n+\n+foo!(Baaah);\n+const _: () = Baaah;\n+const _: Baaah = Baaah {};\n+    \"#,\n+        )\n+    }\n+\n     #[test]\n     fn test_rename_for_macro_args() {\n         check("}, {"sha": "c4000d80522f68750e97c87e900334bfa10f638d", "filename": "crates/text_edit/src/lib.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9bce4d669647c11c87be39fd08db5a68bf324c12/crates%2Ftext_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bce4d669647c11c87be39fd08db5a68bf324c12/crates%2Ftext_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftext_edit%2Fsrc%2Flib.rs?ref=9bce4d669647c11c87be39fd08db5a68bf324c12", "patch": "@@ -3,12 +3,14 @@\n //! `rust-analyzer` never mutates text itself and only sends diffs to clients,\n //! so `TextEdit` is the ultimate representation of the work done by\n //! rust-analyzer.\n+use std::collections::HashSet;\n+\n pub use text_size::{TextRange, TextSize};\n \n /// `InsertDelete` -- a single \"atomic\" change to text\n ///\n /// Must not overlap with other `InDel`s\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Indel {\n     pub insert: String,\n     /// Refers to offsets in the original text\n@@ -114,13 +116,20 @@ impl TextEdit {\n     }\n \n     pub fn union(&mut self, other: TextEdit) -> Result<(), TextEdit> {\n+        dbg!(&self, &other);\n         // FIXME: can be done without allocating intermediate vector\n         let mut all = self.iter().chain(other.iter()).collect::<Vec<_>>();\n-        if !check_disjoint(&mut all) {\n+        if !check_disjoint_or_equal(&mut all) {\n             return Err(other);\n         }\n-        self.indels.extend(other.indels);\n-        assert_disjoint(&mut self.indels);\n+\n+        // remove duplicates\n+        // FIXME: maybe make indels a HashSet instead to get rid of this?\n+        let our_indels = self.indels.clone();\n+        let our_indels = our_indels.iter().collect::<HashSet<_>>();\n+        let other_indels = other.indels.into_iter().filter(|i| !our_indels.contains(i));\n+\n+        self.indels.extend(other_indels);\n         Ok(())\n     }\n \n@@ -173,7 +182,7 @@ impl TextEditBuilder {\n     }\n     pub fn finish(self) -> TextEdit {\n         let mut indels = self.indels;\n-        assert_disjoint(&mut indels);\n+        assert_disjoint_or_equal(&mut indels);\n         TextEdit { indels }\n     }\n     pub fn invalidates_offset(&self, offset: TextSize) -> bool {\n@@ -182,18 +191,19 @@ impl TextEditBuilder {\n     fn indel(&mut self, indel: Indel) {\n         self.indels.push(indel);\n         if self.indels.len() <= 16 {\n-            assert_disjoint(&mut self.indels);\n+            assert_disjoint_or_equal(&mut self.indels);\n         }\n     }\n }\n \n-fn assert_disjoint(indels: &mut [impl std::borrow::Borrow<Indel>]) {\n-    assert!(check_disjoint(indels));\n+fn assert_disjoint_or_equal(indels: &mut [impl std::borrow::Borrow<Indel>]) {\n+    assert!(check_disjoint_or_equal(indels));\n }\n-fn check_disjoint(indels: &mut [impl std::borrow::Borrow<Indel>]) -> bool {\n+fn check_disjoint_or_equal(indels: &mut [impl std::borrow::Borrow<Indel>]) -> bool {\n     indels.sort_by_key(|indel| (indel.borrow().delete.start(), indel.borrow().delete.end()));\n-    indels\n-        .iter()\n-        .zip(indels.iter().skip(1))\n-        .all(|(l, r)| l.borrow().delete.end() <= r.borrow().delete.start())\n+    indels.iter().zip(indels.iter().skip(1)).all(|(l, r)| {\n+        let l = l.borrow();\n+        let r = r.borrow();\n+        l.delete.end() <= r.delete.start() || l == r\n+    })\n }"}]}