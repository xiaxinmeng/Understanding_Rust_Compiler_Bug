{"sha": "dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkN2I4Yzg1YTZhMmJmZmIyY2NlMWM0MGJhNzI2ODBhMWQ3YmU5M2I=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-20T04:32:00Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-24T01:04:20Z"}, "message": "Perform most diagnostic lookups in `resolution_failure`\n\nPreviously, these were spread throughout the codebase. This had two\ndrawbacks:\n\n1. It caused the fast path to be slower: even if a link resolved,\nrustdoc would still perform various lookups for the error diagnostic.\n2. It was inconsistent and didn't always give all diagnostics (https://github.com/rust-lang/rust/issues/76925)\n\nNow, diagnostics only perform expensive lookups in the error case.\nAdditionally, the error handling is much more consistent, both in\nwording and behavior.\n\n- Remove `CannotHaveAssociatedItems`, `NotInScope`, `NoAssocItem`, and `NotAVariant`\n  in favor of the more general `NotResolved`\n\n  `resolution_failure` will now look up which of the four above\n  categories is relevant, instead of requiring the rest of the code to\n  be consistent and accurate in which it picked.\n\n- Remove unnecessary lookups throughout the intra-doc link pass. These\nare now done by `resolution_failure`.\n  + Remove unnecessary `extra_fragment` argument to `variant_field()`;\n    it was only used to do lookups on failure.\n  + Remove various lookups related to associated items\n  + Remove distinction between 'not in scope' and 'no associated item'\n\n- Don't perform unnecessary copies\n- Remove unused variables and code\n- Update tests\n- Note why looking at other namespaces is still necessary\n- 'has no inner item' -> 'contains no item'\n\nbless tests", "tree": {"sha": "2a23e7415df3f7537d4399bce754b155fc1388ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a23e7415df3f7537d4399bce754b155fc1388ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "html_url": "https://github.com/rust-lang/rust/commit/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc5e4d4d5715cfe111def11bbd1d8afae2ea80e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc5e4d4d5715cfe111def11bbd1d8afae2ea80e", "html_url": "https://github.com/rust-lang/rust/commit/cbc5e4d4d5715cfe111def11bbd1d8afae2ea80e"}], "stats": {"total": 516, "additions": 263, "deletions": 253}, "files": [{"sha": "71fd5deca54b74983ee0c7f243d5882b4652ff9d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 191, "deletions": 206, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -60,48 +60,26 @@ impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n \n #[derive(Debug)]\n enum ResolutionFailure<'a> {\n-    /// This resolved, but with the wrong namespace.\n-    /// `Namespace` is the expected namespace (as opposed to the actual).\n-    WrongNamespace(Res, Namespace),\n-    /// This has a partial resolution, but is not in the TypeNS and so cannot\n-    /// have associated items or fields.\n-    CannotHaveAssociatedItems(Res, Namespace),\n-    /// `name` is the base name of the path (not necessarily the whole link)\n-    NotInScope { module_id: DefId, name: Cow<'a, str> },\n     /// this is a primitive type without an impls (no associated methods)\n     /// when will this actually happen?\n     /// the `Res` is the primitive it resolved to\n     NoPrimitiveImpl(Res, String),\n     /// `[u8::not_found]`\n     /// the `Res` is the primitive it resolved to\n     NoPrimitiveAssocItem { res: Res, prim_name: &'a str, assoc_item: Symbol },\n-    /// `[S::not_found]`\n-    /// the `String` is the associated item that wasn't found\n-    NoAssocItem(Res, Symbol),\n+    /// This resolved, but with the wrong namespace.\n+    /// `Namespace` is the expected namespace (as opposed to the actual).\n+    WrongNamespace(Res, Namespace),\n+    /// The link failed to resolve. `resolution_failure` should look to see if there's\n+    /// a more helpful error that can be given.\n+    NotResolved { module_id: DefId, partial_res: Option<Res>, unresolved: Cow<'a, str> },\n     /// should not ever happen\n     NoParentItem,\n-    /// this could be an enum variant, but the last path fragment wasn't resolved.\n-    /// the `String` is the variant that didn't exist\n-    NotAVariant(Res, Symbol),\n     /// used to communicate that this should be ignored, but shouldn't be reported to the user\n     Dummy,\n }\n \n impl ResolutionFailure<'a> {\n-    // A partial or full resolution\n-    fn res(&self) -> Option<Res> {\n-        use ResolutionFailure::*;\n-        match self {\n-            NoPrimitiveAssocItem { res, .. }\n-            | NoAssocItem(res, _)\n-            | NoPrimitiveImpl(res, _)\n-            | NotAVariant(res, _)\n-            | WrongNamespace(res, _)\n-            | CannotHaveAssociatedItems(res, _) => Some(*res),\n-            NotInScope { .. } | NoParentItem | Dummy => None,\n-        }\n-    }\n-\n     // This resolved fully (not just partially) but is erroneous for some other reason\n     fn full_res(&self) -> Option<Res> {\n         match self {\n@@ -136,22 +114,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         current_item: &Option<String>,\n         module_id: DefId,\n-        extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n+        let no_res = || ResolutionFailure::NotResolved {\n+            module_id,\n+            partial_res: None,\n+            unresolved: path_str.into(),\n+        };\n \n         debug!(\"looking for enum variant {}\", path_str);\n         let mut split = path_str.rsplitn(3, \"::\");\n-        let variant_field_name = split\n+        let (variant_field_str, variant_field_name) = split\n             .next()\n-            .map(|f| Symbol::intern(f))\n+            .map(|f| (f, Symbol::intern(f)))\n             .expect(\"fold_item should ensure link is non-empty\");\n-        let variant_name =\n+        let (variant_str, variant_name) =\n             // we're not sure this is a variant at all, so use the full string\n-            split.next().map(|f| Symbol::intern(f)).ok_or_else(|| ResolutionFailure::NotInScope {\n-                module_id,\n-                name: path_str.into(),\n-            })?;\n+            // If there's no second component, the link looks like `[path]`.\n+            // So there's no partial res and we should say the whole link failed to resolve.\n+            split.next().map(|f| (f, Symbol::intern(f))).ok_or_else(no_res)?;\n         let path = split\n             .next()\n             .map(|f| {\n@@ -162,18 +143,17 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 f.to_owned()\n             })\n-            .ok_or_else(|| ResolutionFailure::NotInScope {\n-                module_id,\n-                name: variant_name.to_string().into(),\n-            })?;\n+            // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n+            // So there's no partial res.\n+            .ok_or_else(no_res)?;\n         let ty_res = cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n             .map(|(_, res)| res)\n             .unwrap_or(Res::Err);\n         if let Res::Err = ty_res {\n-            return Err(ResolutionFailure::NotInScope { module_id, name: path.into() }.into());\n+            return Err(no_res().into());\n         }\n         let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n         match ty_res {\n@@ -196,38 +176,27 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 ty_res,\n                                 Some(format!(\n                                     \"variant.{}.field.{}\",\n-                                    variant_name, variant_field_name\n+                                    variant_str, variant_field_name\n                                 )),\n                             ))\n                         } else {\n-                            Err(ResolutionFailure::NotAVariant(ty_res, variant_field_name).into())\n+                            Err(ResolutionFailure::NotResolved {\n+                                module_id,\n+                                partial_res: Some(Res::Def(DefKind::Enum, def.did)),\n+                                unresolved: variant_field_str.into(),\n+                            }\n+                            .into())\n                         }\n                     }\n                     _ => unreachable!(),\n                 }\n             }\n-            // `variant_field` looks at 3 different path segments in a row.\n-            // But `NoAssocItem` assumes there are only 2. Check to see if there's\n-            // an intermediate segment that resolves.\n-            _ => {\n-                let intermediate_path = format!(\"{}::{}\", path, variant_name);\n-                // NOTE: we have to be careful here, because we're already in `resolve`.\n-                // We know this doesn't recurse forever because we use a shorter path each time.\n-                // NOTE: this uses `TypeNS` because nothing else has a valid path segment after\n-                let kind = if let Some(intermediate) = self.check_full_res(\n-                    TypeNS,\n-                    &intermediate_path,\n-                    module_id,\n-                    current_item,\n-                    extra_fragment,\n-                ) {\n-                    ResolutionFailure::NoAssocItem(intermediate, variant_field_name)\n-                } else {\n-                    // Even with the shorter path, it didn't resolve, so say that.\n-                    ResolutionFailure::NoAssocItem(ty_res, variant_name)\n-                };\n-                Err(kind.into())\n+            _ => Err(ResolutionFailure::NotResolved {\n+                module_id,\n+                partial_res: Some(ty_res),\n+                unresolved: variant_str.into(),\n             }\n+            .into()),\n         }\n     }\n \n@@ -248,11 +217,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 false,\n             ) {\n                 if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                    return Some(Ok(res.map_id(|_| panic!(\"unexpected id\"))));\n+                    return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }\n             if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Some(Ok(res.map_id(|_| panic!(\"unexpected id\"))));\n+                return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n             }\n             debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n             if let Ok((_, res)) =\n@@ -261,28 +230,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // don't resolve builtins like `#[derive]`\n                 if let Res::Def(..) = res {\n                     let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                    return Some(Ok(res));\n-                }\n-            }\n-            None\n-        })\n-        // This weird control flow is so we don't borrow the resolver more than once at a time\n-        .unwrap_or_else(|| {\n-            let mut split = path_str.rsplitn(2, \"::\");\n-            if let Some((parent, base)) = split.next().and_then(|x| Some((split.next()?, x))) {\n-                if let Some(res) = self.check_full_res(TypeNS, parent, module_id, &None, &None) {\n-                    return Err(if matches!(res, Res::PrimTy(_)) {\n-                        ResolutionFailure::NoPrimitiveAssocItem {\n-                            res,\n-                            prim_name: parent,\n-                            assoc_item: Symbol::intern(base),\n-                        }\n-                    } else {\n-                        ResolutionFailure::NoAssocItem(res, Symbol::intern(base))\n-                    });\n+                    return Ok(res);\n                 }\n             }\n-            Err(ResolutionFailure::NotInScope { module_id, name: path_str.into() })\n+            Err(ResolutionFailure::NotResolved {\n+                module_id,\n+                partial_res: None,\n+                unresolved: path_str.into(),\n+            })\n         })\n     }\n \n@@ -347,7 +302,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // Try looking for methods and associated items.\n         let mut split = path_str.rsplitn(2, \"::\");\n         // this can be an `unwrap()` because we ensure the link is never empty\n-        let item_name = Symbol::intern(split.next().unwrap());\n+        let (item_str, item_name) = split.next().map(|i| (i, Symbol::intern(i))).unwrap();\n         let path_root = split\n             .next()\n             .map(|f| {\n@@ -362,7 +317,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n             .ok_or_else(|| {\n                 debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n-                ResolutionFailure::NotInScope { module_id, name: item_name.to_string().into() }\n+                ResolutionFailure::NotResolved {\n+                    module_id,\n+                    partial_res: None,\n+                    unresolved: item_str.into(),\n+                }\n             })?;\n \n         if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n@@ -383,7 +342,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::AssocKind::Const => \"associatedconstant\",\n                         ty::AssocKind::Type => \"associatedtype\",\n                     })\n-                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))));\n+                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_str))));\n                 if let Some(link) = link {\n                     return Ok(link);\n                 }\n@@ -411,25 +370,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let ty_res = match ty_res {\n             Err(()) | Ok(Res::Err) => {\n                 return if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                    self.variant_field(path_str, current_item, module_id)\n                 } else {\n-                    // See if it only broke because of the namespace.\n-                    let kind = cx.enter_resolver(|resolver| {\n-                        // NOTE: this doesn't use `check_full_res` because we explicitly want to ignore `TypeNS` (we already checked it)\n-                        for &ns in &[MacroNS, ValueNS] {\n-                            match resolver\n-                                .resolve_str_path_error(DUMMY_SP, &path_root, ns, module_id)\n-                            {\n-                                Ok((_, Res::Err)) | Err(()) => {}\n-                                Ok((_, res)) => {\n-                                    let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n-                                    return ResolutionFailure::CannotHaveAssociatedItems(res, ns);\n-                                }\n-                            }\n-                        }\n-                        ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n-                    });\n-                    Err(kind.into())\n+                    Err(ResolutionFailure::NotResolved {\n+                        module_id,\n+                        partial_res: None,\n+                        unresolved: path_root.into(),\n+                    }\n+                    .into())\n                 };\n             }\n             Ok(res) => res,\n@@ -479,7 +427,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         // but the disambiguator logic expects the associated item.\n                         // Store the kind in a side channel so that only the disambiguator logic looks at it.\n                         self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n-                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n+                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_str))))\n                     })\n                 } else if ns == Namespace::ValueNS {\n                     debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n@@ -522,7 +470,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     }\n                 } else {\n                     // We already know this isn't in ValueNS, so no need to check variant_field\n-                    return Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into());\n+                    return Err(ResolutionFailure::NotResolved {\n+                        module_id,\n+                        partial_res: Some(ty_res),\n+                        unresolved: item_str.into(),\n+                    }\n+                    .into());\n                 }\n             }\n             Res::Def(DefKind::Trait, did) => cx\n@@ -546,16 +499,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n                     } else {\n                         let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                        Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n+                        Ok((res, Some(format!(\"{}.{}\", kind, item_str))))\n                     }\n                 }),\n             _ => None,\n         };\n         res.unwrap_or_else(|| {\n             if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, current_item, module_id, extra_fragment)\n+                self.variant_field(path_str, current_item, module_id)\n             } else {\n-                Err(ResolutionFailure::NoAssocItem(ty_res, item_name).into())\n+                Err(ResolutionFailure::NotResolved {\n+                    module_id,\n+                    partial_res: Some(ty_res),\n+                    unresolved: item_str.into(),\n+                }\n+                .into())\n             }\n         })\n     }\n@@ -1133,6 +1091,8 @@ impl LinkCollector<'_, '_> {\n                         // We only looked in one namespace. Try to give a better error if possible.\n                         if kind.full_res().is_none() {\n                             let other_ns = if ns == ValueNS { TypeNS } else { ValueNS };\n+                            // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n+                            // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for &new_ns in &[other_ns, MacroNS] {\n                                 if let Some(res) = self.check_full_res(\n                                     new_ns,\n@@ -1535,7 +1495,6 @@ fn resolution_failure(\n         dox,\n         &link_range,\n         |diag, sp| {\n-            let in_scope = kinds.iter().any(|kind| kind.res().is_some());\n             let item = |res: Res| {\n                 format!(\n                     \"the {} `{}`\",\n@@ -1556,53 +1515,142 @@ fn resolution_failure(\n             // ignore duplicates\n             let mut variants_seen = SmallVec::<[_; 3]>::new();\n             for mut failure in kinds {\n-                // Check if _any_ parent of the path gets resolved.\n-                // If so, report it and say the first which failed; if not, say the first path segment didn't resolve.\n-                if let ResolutionFailure::NotInScope { module_id, name } = &mut failure {\n-                    let mut current = name.as_ref();\n-                    loop {\n-                        current = match current.rsplitn(2, \"::\").nth(1) {\n-                            Some(p) => p,\n-                            None => {\n-                                *name = current.to_owned().into();\n-                                break;\n-                            }\n-                        };\n-                        if let Some(res) =\n-                            collector.check_full_res(TypeNS, &current, *module_id, &None, &None)\n-                        {\n-                            failure = ResolutionFailure::NoAssocItem(res, Symbol::intern(current));\n-                            break;\n-                        }\n-                    }\n-                }\n                 let variant = std::mem::discriminant(&failure);\n                 if variants_seen.contains(&variant) {\n                     continue;\n                 }\n                 variants_seen.push(variant);\n-                let note = match failure {\n-                    ResolutionFailure::NotInScope { module_id, name, .. } => {\n-                        if in_scope {\n-                            continue;\n+\n+                if let ResolutionFailure::NotResolved { module_id, partial_res, unresolved } =\n+                    &mut failure\n+                {\n+                    use DefKind::*;\n+\n+                    let module_id = *module_id;\n+                    // FIXME(jynelson): this might conflict with my `Self` fix in #76467\n+                    fn split(path: &str) -> Option<(&str, &str)> {\n+                        let mut splitter = path.rsplitn(2, \"::\");\n+                        splitter.next().and_then(|right| splitter.next().map(|left| (left, right)))\n+                    }\n+\n+                    // Check if _any_ parent of the path gets resolved.\n+                    // If so, report it and say the first which failed; if not, say the first path segment didn't resolve.\n+                    let mut name = path_str;\n+                    'outer: loop {\n+                        let (start, end) = if let Some(x) = split(name) {\n+                            x\n+                        } else {\n+                            // avoid bug that marked [Quux::Z] as missing Z, not Quux\n+                            if partial_res.is_none() {\n+                                *unresolved = name.into();\n+                            }\n+                            break;\n+                        };\n+                        name = start;\n+                        for &ns in &[TypeNS, ValueNS, MacroNS] {\n+                            if let Some(res) =\n+                                collector.check_full_res(ns, &start, module_id, &None, &None)\n+                            {\n+                                debug!(\"found partial_res={:?}\", res);\n+                                *partial_res = Some(res);\n+                                *unresolved = end.into();\n+                                break 'outer;\n+                            }\n                         }\n+                        *unresolved = end.into();\n+                    }\n+\n+                    let last_found_module = match *partial_res {\n+                        Some(Res::Def(DefKind::Mod, id)) => Some(id),\n+                        None => Some(module_id),\n+                        _ => None,\n+                    };\n+                    // See if this was a module: `[path]` or `[std::io::nope]`\n+                    if let Some(module) = last_found_module {\n                         // NOTE: uses an explicit `continue` so the `note:` will come before the `help:`\n-                        let module_name = collector.cx.tcx.item_name(module_id);\n-                        let note = format!(\"no item named `{}` in `{}`\", name, module_name);\n+                        let module_name = collector.cx.tcx.item_name(module);\n+                        let note = format!(\n+                            \"the module `{}` contains no item named `{}`\",\n+                            module_name, unresolved\n+                        );\n                         if let Some(span) = sp {\n                             diag.span_label(span, &note);\n                         } else {\n                             diag.note(&note);\n                         }\n-                        // If the link has `::` in the path, assume it's meant to be an intra-doc link\n+                        // If the link has `::` in it, assume it was meant to be an intra-doc link.\n+                        // Otherwise, the `[]` might be unrelated.\n+                        // FIXME: don't show this for autolinks (`<>`), `()` style links, or reference links\n                         if !path_str.contains(\"::\") {\n-                            // Otherwise, the `[]` might be unrelated.\n-                            // FIXME(https://github.com/raphlinus/pulldown-cmark/issues/373):\n-                            // don't show this for autolinks (`<>`), `()` style links, or reference links\n                             diag.help(r#\"to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\"#);\n                         }\n                         continue;\n                     }\n+\n+                    // Otherwise, it must be an associated item or variant\n+                    let res = partial_res.expect(\"None case was handled by `last_found_module`\");\n+                    let diagnostic_name;\n+                    let (kind, name) = match res {\n+                        Res::Def(kind, def_id) => {\n+                            diagnostic_name = collector.cx.tcx.item_name(def_id).as_str();\n+                            (Some(kind), &*diagnostic_name)\n+                        }\n+                        Res::PrimTy(_) => (None, name),\n+                        _ => unreachable!(\"only ADTs and primitives are in scope at module level\"),\n+                    };\n+                    let path_description = if let Some(kind) = kind {\n+                        match kind {\n+                            Mod | ForeignMod => \"inner item\",\n+                            Struct => \"field or associated item\",\n+                            Enum | Union => \"variant or associated item\",\n+                            Variant\n+                            | Field\n+                            | Closure\n+                            | Generator\n+                            | AssocTy\n+                            | AssocConst\n+                            | AssocFn\n+                            | Fn\n+                            | Macro(_)\n+                            | Const\n+                            | ConstParam\n+                            | ExternCrate\n+                            | Use\n+                            | LifetimeParam\n+                            | Ctor(_, _)\n+                            | AnonConst => {\n+                                let note = assoc_item_not_allowed(res);\n+                                if let Some(span) = sp {\n+                                    diag.span_label(span, &note);\n+                                } else {\n+                                    diag.note(&note);\n+                                }\n+                                return;\n+                            }\n+                            Trait | TyAlias | ForeignTy | OpaqueTy | TraitAlias | TyParam\n+                            | Static => \"associated item\",\n+                            Impl | GlobalAsm => unreachable!(\"not a path\"),\n+                        }\n+                    } else {\n+                        res.descr()\n+                    };\n+                    let note = format!(\n+                        \"the {} `{}` has no {} named `{}`\",\n+                        res.descr(),\n+                        name,\n+                        disambiguator.map_or(path_description, |d| d.descr()),\n+                        unresolved,\n+                    );\n+                    if let Some(span) = sp {\n+                        diag.span_label(span, &note);\n+                    } else {\n+                        diag.note(&note);\n+                    }\n+\n+                    continue;\n+                }\n+                let note = match failure {\n+                    ResolutionFailure::NotResolved { .. } => unreachable!(\"handled above\"),\n                     ResolutionFailure::Dummy => continue,\n                     ResolutionFailure::WrongNamespace(res, expected_ns) => {\n                         if let Res::Def(kind, _) = res {\n@@ -1637,69 +1685,6 @@ fn resolution_failure(\n                             prim_name, assoc_item\n                         )\n                     }\n-                    ResolutionFailure::NoAssocItem(res, assoc_item) => {\n-                        use DefKind::*;\n-\n-                        let (kind, def_id) = match res {\n-                            Res::Def(kind, def_id) => (kind, def_id),\n-                            x => unreachable!(\n-                                \"primitives are covered above and other `Res` variants aren't possible at module scope: {:?}\",\n-                                x,\n-                            ),\n-                        };\n-                        let name = collector.cx.tcx.item_name(def_id);\n-                        let path_description = if let Some(disambiguator) = disambiguator {\n-                            disambiguator.descr()\n-                        } else {\n-                            match kind {\n-                                Mod | ForeignMod => \"inner item\",\n-                                Struct => \"field or associated item\",\n-                                Enum | Union => \"variant or associated item\",\n-                                Variant\n-                                | Field\n-                                | Closure\n-                                | Generator\n-                                | AssocTy\n-                                | AssocConst\n-                                | AssocFn\n-                                | Fn\n-                                | Macro(_)\n-                                | Const\n-                                | ConstParam\n-                                | ExternCrate\n-                                | Use\n-                                | LifetimeParam\n-                                | Ctor(_, _)\n-                                | AnonConst => {\n-                                    let note = assoc_item_not_allowed(res);\n-                                    if let Some(span) = sp {\n-                                        diag.span_label(span, &note);\n-                                    } else {\n-                                        diag.note(&note);\n-                                    }\n-                                    return;\n-                                }\n-                                Trait | TyAlias | ForeignTy | OpaqueTy | TraitAlias | TyParam\n-                                | Static => \"associated item\",\n-                                Impl | GlobalAsm => unreachable!(\"not a path\"),\n-                            }\n-                        };\n-                        format!(\n-                            \"the {} `{}` has no {} named `{}`\",\n-                            res.descr(),\n-                            name,\n-                            path_description,\n-                            assoc_item\n-                        )\n-                    }\n-                    ResolutionFailure::CannotHaveAssociatedItems(res, _) => {\n-                        assoc_item_not_allowed(res)\n-                    }\n-                    ResolutionFailure::NotAVariant(res, variant) => format!(\n-                        \"this link partially resolves to {}, but there is no variant named {}\",\n-                        item(res),\n-                        variant\n-                    ),\n                 };\n                 if let Some(span) = sp {\n                     diag.span_label(span, &note);"}, {"sha": "33260fa0e1e6608fb5bf4a2f5b27c9aae891c526", "filename": "src/test/rustdoc-ui/deny-intra-link-resolution-failure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -2,7 +2,7 @@ error: unresolved link to `v2`\n   --> $DIR/deny-intra-link-resolution-failure.rs:3:6\n    |\n LL | /// [v2]\n-   |      ^^ no item named `v2` in `deny_intra_link_resolution_failure`\n+   |      ^^ the module `deny_intra_link_resolution_failure` contains no item named `v2`\n    |\n note: the lint level is defined here\n   --> $DIR/deny-intra-link-resolution-failure.rs:1:9"}, {"sha": "8c250fbc58b272832ea656c7cc6d8716845795ee", "filename": "src/test/rustdoc-ui/intra-link-errors.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -6,19 +6,23 @@\n \n /// [path::to::nonexistent::module]\n //~^ ERROR unresolved link\n-//~| NOTE no item named `path` in `intra_link_errors`\n+//~| NOTE `intra_link_errors` contains no item named `path`\n \n /// [path::to::nonexistent::macro!]\n //~^ ERROR unresolved link\n-//~| NOTE no item named `path` in `intra_link_errors`\n+//~| NOTE `intra_link_errors` contains no item named `path`\n \n /// [type@path::to::nonexistent::type]\n //~^ ERROR unresolved link\n-//~| NOTE no item named `path` in `intra_link_errors`\n+//~| NOTE `intra_link_errors` contains no item named `path`\n \n /// [std::io::not::here]\n //~^ ERROR unresolved link\n-//~| NOTE the module `io` has no inner item\n+//~| NOTE `io` contains no item named `not`\n+\n+/// [type@std::io::not::here]\n+//~^ ERROR unresolved link\n+//~| NOTE `io` contains no item named `not`\n \n /// [std::io::Error::x]\n //~^ ERROR unresolved link\n@@ -32,6 +36,10 @@\n //~^ ERROR unresolved link\n //~| NOTE `f` is a function, not a module\n \n+/// [f::A!]\n+//~^ ERROR unresolved link\n+//~| NOTE `f` is a function, not a module\n+\n /// [S::A]\n //~^ ERROR unresolved link\n //~| NOTE struct `S` has no field or associated item"}, {"sha": "cd06ee6f798dccec1ad77a8b458dfcd898256b4a", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -2,7 +2,7 @@ error: unresolved link to `path::to::nonexistent::module`\n   --> $DIR/intra-link-errors.rs:7:6\n    |\n LL | /// [path::to::nonexistent::module]\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the module `intra_link_errors` contains no item named `path`\n    |\n note: the lint level is defined here\n   --> $DIR/intra-link-errors.rs:1:9\n@@ -14,64 +14,79 @@ error: unresolved link to `path::to::nonexistent::macro`\n   --> $DIR/intra-link-errors.rs:11:6\n    |\n LL | /// [path::to::nonexistent::macro!]\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the module `intra_link_errors` contains no item named `path`\n \n error: unresolved link to `path::to::nonexistent::type`\n   --> $DIR/intra-link-errors.rs:15:6\n    |\n LL | /// [type@path::to::nonexistent::type]\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no item named `path` in `intra_link_errors`\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the module `intra_link_errors` contains no item named `path`\n \n error: unresolved link to `std::io::not::here`\n   --> $DIR/intra-link-errors.rs:19:6\n    |\n LL | /// [std::io::not::here]\n-   |      ^^^^^^^^^^^^^^^^^^ the module `io` has no inner item named `not`\n+   |      ^^^^^^^^^^^^^^^^^^ the module `io` contains no item named `not`\n \n-error: unresolved link to `std::io::Error::x`\n+error: unresolved link to `std::io::not::here`\n   --> $DIR/intra-link-errors.rs:23:6\n    |\n+LL | /// [type@std::io::not::here]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^ the module `io` contains no item named `not`\n+\n+error: unresolved link to `std::io::Error::x`\n+  --> $DIR/intra-link-errors.rs:27:6\n+   |\n LL | /// [std::io::Error::x]\n    |      ^^^^^^^^^^^^^^^^^ the struct `Error` has no field or associated item named `x`\n \n error: unresolved link to `std::io::ErrorKind::x`\n-  --> $DIR/intra-link-errors.rs:27:6\n+  --> $DIR/intra-link-errors.rs:31:6\n    |\n LL | /// [std::io::ErrorKind::x]\n    |      ^^^^^^^^^^^^^^^^^^^^^ the enum `ErrorKind` has no variant or associated item named `x`\n \n error: unresolved link to `f::A`\n-  --> $DIR/intra-link-errors.rs:31:6\n+  --> $DIR/intra-link-errors.rs:35:6\n    |\n LL | /// [f::A]\n    |      ^^^^ `f` is a function, not a module or type, and cannot have associated items\n \n+error: unresolved link to `f::A`\n+  --> $DIR/intra-link-errors.rs:39:6\n+   |\n+LL | /// [f::A!]\n+   |      ^^^^^ `f` is a function, not a module or type, and cannot have associated items\n+\n error: unresolved link to `S::A`\n-  --> $DIR/intra-link-errors.rs:35:6\n+  --> $DIR/intra-link-errors.rs:43:6\n    |\n LL | /// [S::A]\n    |      ^^^^ the struct `S` has no field or associated item named `A`\n \n error: unresolved link to `S::fmt`\n-  --> $DIR/intra-link-errors.rs:39:6\n+  --> $DIR/intra-link-errors.rs:47:6\n    |\n LL | /// [S::fmt]\n    |      ^^^^^^ the struct `S` has no field or associated item named `fmt`\n \n error: unresolved link to `E::D`\n-  --> $DIR/intra-link-errors.rs:43:6\n+  --> $DIR/intra-link-errors.rs:51:6\n    |\n LL | /// [E::D]\n    |      ^^^^ the enum `E` has no variant or associated item named `D`\n \n error: unresolved link to `u8::not_found`\n-  --> $DIR/intra-link-errors.rs:47:6\n+  --> $DIR/intra-link-errors.rs:55:6\n    |\n LL | /// [u8::not_found]\n-   |      ^^^^^^^^^^^^^ the builtin type `u8` does not have an associated item named `not_found`\n+   |      ^^^^^^^^^^^^^\n+   |      |\n+   |      the builtin type `u8` does not have an associated item named `not_found`\n+   |      the builtin type `u8` has no builtin type named `not_found`\n \n error: unresolved link to `S`\n-  --> $DIR/intra-link-errors.rs:51:6\n+  --> $DIR/intra-link-errors.rs:59:6\n    |\n LL | /// [S!]\n    |      ^^\n@@ -80,7 +95,7 @@ LL | /// [S!]\n    |      help: to link to the struct, prefix with `struct@`: `struct@S`\n \n error: unresolved link to `T::g`\n-  --> $DIR/intra-link-errors.rs:69:6\n+  --> $DIR/intra-link-errors.rs:77:6\n    |\n LL | /// [type@T::g]\n    |      ^^^^^^^^^\n@@ -89,13 +104,13 @@ LL | /// [type@T::g]\n    |      help: to link to the associated function, add parentheses: `T::g()`\n \n error: unresolved link to `T::h`\n-  --> $DIR/intra-link-errors.rs:74:6\n+  --> $DIR/intra-link-errors.rs:82:6\n    |\n LL | /// [T::h!]\n    |      ^^^^^ the trait `T` has no macro named `h`\n \n error: unresolved link to `S::h`\n-  --> $DIR/intra-link-errors.rs:61:6\n+  --> $DIR/intra-link-errors.rs:69:6\n    |\n LL | /// [type@S::h]\n    |      ^^^^^^^^^\n@@ -104,13 +119,13 @@ LL | /// [type@S::h]\n    |      help: to link to the associated function, add parentheses: `S::h()`\n \n error: unresolved link to `m`\n-  --> $DIR/intra-link-errors.rs:81:6\n+  --> $DIR/intra-link-errors.rs:89:6\n    |\n LL | /// [m()]\n    |      ^^^\n    |      |\n    |      this link resolves to the macro `m`, which is not in the value namespace\n    |      help: to link to the macro, add an exclamation mark: `m!`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 18 previous errors\n "}, {"sha": "d946aa939800c61aa20e19b03fb5a0f9af29db55", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -2,7 +2,7 @@ error: unresolved link to `i`\n   --> $DIR/intra-link-span-ice-55723.rs:9:10\n    |\n LL | /// \uff08arr[i]\uff09\n-   |           ^ no item named `i` in `intra_link_span_ice_55723`\n+   |           ^ the module `intra_link_span_ice_55723` contains no item named `i`\n    |\n note: the lint level is defined here\n   --> $DIR/intra-link-span-ice-55723.rs:1:9"}, {"sha": "76a2ac0c8cf02848d1e3fa299c231032874cb070", "filename": "src/test/rustdoc-ui/intra-links-warning-crlf.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning-crlf.stderr?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -2,7 +2,7 @@ warning: unresolved link to `error`\n   --> $DIR/intra-links-warning-crlf.rs:7:6\n    |\n LL | /// [error]\n-   |      ^^^^^ no item named `error` in `intra_links_warning_crlf`\n+   |      ^^^^^ the module `intra_links_warning_crlf` contains no item named `error`\n    |\n    = note: `#[warn(broken_intra_doc_links)]` on by default\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n@@ -11,23 +11,23 @@ warning: unresolved link to `error1`\n   --> $DIR/intra-links-warning-crlf.rs:12:11\n    |\n LL | /// docs [error1]\n-   |           ^^^^^^ no item named `error1` in `intra_links_warning_crlf`\n+   |           ^^^^^^ the module `intra_links_warning_crlf` contains no item named `error1`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error2`\n   --> $DIR/intra-links-warning-crlf.rs:15:11\n    |\n LL | /// docs [error2]\n-   |           ^^^^^^ no item named `error2` in `intra_links_warning_crlf`\n+   |           ^^^^^^ the module `intra_links_warning_crlf` contains no item named `error2`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning-crlf.rs:23:20\n    |\n LL |  * It also has an [error].\n-   |                    ^^^^^ no item named `error` in `intra_links_warning_crlf`\n+   |                    ^^^^^ the module `intra_links_warning_crlf` contains no item named `error`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n "}, {"sha": "09db465df59fb96025917218e33afa7c0d659851", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -10,53 +10,53 @@ warning: unresolved link to `Bar::foo`\n   --> $DIR/intra-links-warning.rs:3:35\n    |\n LL |        //! Test with [Foo::baz], [Bar::foo], ...\n-   |                                   ^^^^^^^^ no item named `Bar` in `intra_links_warning`\n+   |                                   ^^^^^^^^ the module `intra_links_warning` contains no item named `Bar`\n \n warning: unresolved link to `Uniooon::X`\n   --> $DIR/intra-links-warning.rs:6:13\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n-   |             ^^^^^^^^^^ no item named `Uniooon` in `intra_links_warning`\n+   |             ^^^^^^^^^^ the module `intra_links_warning` contains no item named `Uniooon`\n \n warning: unresolved link to `Qux::Z`\n   --> $DIR/intra-links-warning.rs:6:30\n    |\n LL |      //! , [Uniooon::X] and [Qux::Z].\n-   |                              ^^^^^^ no item named `Qux` in `intra_links_warning`\n+   |                              ^^^^^^ the module `intra_links_warning` contains no item named `Qux`\n \n warning: unresolved link to `Uniooon::X`\n   --> $DIR/intra-links-warning.rs:10:14\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n-   |              ^^^^^^^^^^ no item named `Uniooon` in `intra_links_warning`\n+   |              ^^^^^^^^^^ the module `intra_links_warning` contains no item named `Uniooon`\n \n warning: unresolved link to `Qux::Z`\n   --> $DIR/intra-links-warning.rs:10:31\n    |\n LL |       //! , [Uniooon::X] and [Qux::Z].\n-   |                               ^^^^^^ no item named `Qux` in `intra_links_warning`\n+   |                               ^^^^^^ the module `intra_links_warning` contains no item named `Qux`\n \n warning: unresolved link to `Qux:Y`\n   --> $DIR/intra-links-warning.rs:14:13\n    |\n LL |        /// [Qux:Y]\n-   |             ^^^^^ no item named `Qux:Y` in `intra_links_warning`\n+   |             ^^^^^ the module `intra_links_warning` contains no item named `Qux:Y`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:58:30\n    |\n LL |  * time to introduce a link [error]*/\n-   |                              ^^^^^ no item named `error` in `intra_links_warning`\n+   |                              ^^^^^ the module `intra_links_warning` contains no item named `error`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n   --> $DIR/intra-links-warning.rs:64:30\n    |\n LL |  * time to introduce a link [error]\n-   |                              ^^^^^ no item named `error` in `intra_links_warning`\n+   |                              ^^^^^ the module `intra_links_warning` contains no item named `error`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n@@ -70,7 +70,7 @@ LL | #[doc = \"single line [error]\"]\n            \n            single line [error]\n                         ^^^^^\n-   = note: no item named `error` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `error`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -83,7 +83,7 @@ LL | #[doc = \"single line with \\\"escaping\\\" [error]\"]\n            \n            single line with \"escaping\" [error]\n                                         ^^^^^\n-   = note: no item named `error` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `error`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error`\n@@ -98,46 +98,46 @@ LL | | /// [error]\n            \n            [error]\n             ^^^^^\n-   = note: no item named `error` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `error`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error1`\n   --> $DIR/intra-links-warning.rs:80:11\n    |\n LL | /// docs [error1]\n-   |           ^^^^^^ no item named `error1` in `intra_links_warning`\n+   |           ^^^^^^ the module `intra_links_warning` contains no item named `error1`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `error2`\n   --> $DIR/intra-links-warning.rs:82:11\n    |\n LL | /// docs [error2]\n-   |           ^^^^^^ no item named `error2` in `intra_links_warning`\n+   |           ^^^^^^ the module `intra_links_warning` contains no item named `error2`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarA`\n   --> $DIR/intra-links-warning.rs:21:10\n    |\n LL | /// bar [BarA] bar\n-   |          ^^^^ no item named `BarA` in `intra_links_warning`\n+   |          ^^^^ the module `intra_links_warning` contains no item named `BarA`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarB`\n   --> $DIR/intra-links-warning.rs:27:9\n    |\n LL |  * bar [BarB] bar\n-   |         ^^^^ no item named `BarB` in `intra_links_warning`\n+   |         ^^^^ the module `intra_links_warning` contains no item named `BarB`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarC`\n   --> $DIR/intra-links-warning.rs:34:6\n    |\n LL | bar [BarC] bar\n-   |      ^^^^ no item named `BarC` in `intra_links_warning`\n+   |      ^^^^ the module `intra_links_warning` contains no item named `BarC`\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n@@ -151,7 +151,7 @@ LL | #[doc = \"Foo\\nbar [BarD] bar\\nbaz\"]\n            \n            bar [BarD] bar\n                 ^^^^\n-   = note: no item named `BarD` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `BarD`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n warning: unresolved link to `BarF`\n@@ -167,7 +167,7 @@ LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n            \n            bar [BarF] bar\n                 ^^^^\n-   = note: no item named `BarF` in `intra_links_warning`\n+   = note: the module `intra_links_warning` contains no item named `BarF`\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "4e9134ea469bd80d68531aa33735e289ad29f226", "filename": "src/test/rustdoc-ui/lint-group.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -32,7 +32,7 @@ error: unresolved link to `error`\n   --> $DIR/lint-group.rs:9:29\n    |\n LL | /// what up, let's make an [error]\n-   |                             ^^^^^ no item named `error` in `lint_group`\n+   |                             ^^^^^ the module `lint_group` contains no item named `error`\n    |\n note: the lint level is defined here\n   --> $DIR/lint-group.rs:7:9"}, {"sha": "dec0deae5df7ca6f2a5f40f692cabd14489d744a", "filename": "src/test/rustdoc/intra-link-associated-items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs?ref=dd7b8c85a6a2bffb2cce1c40ba72680a1d7be93b", "patch": "@@ -3,8 +3,10 @@\n \n /// [`std::collections::BTreeMap::into_iter`]\n /// [`String::from`] is ambiguous as to which `From` impl\n+/// [type@Vec::into_iter] uses a disambiguator\n // @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html#method.into_iter\"]' 'std::collections::BTreeMap::into_iter'\n // @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/string/struct.String.html#method.from\"]' 'String::from'\n+// @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html#method.into_iter\"]' 'Vec::into_iter'\n pub fn foo() {}\n \n /// Link to [MyStruct], [link from struct][MyStruct::method], [MyStruct::clone], [MyStruct::Input]"}]}