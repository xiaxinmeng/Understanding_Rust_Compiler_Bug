{"sha": "cbf91532a7bfb2f2ce23067b13cc44659f7883d2", "node_id": "C_kwDOAAsO6NoAKGNiZjkxNTMyYTdiZmIyZjJjZTIzMDY3YjEzY2M0NDY1OWY3ODgzZDI", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-10-07T23:32:03Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2021-10-08T08:55:44Z"}, "message": "dont normalize return type during candidate assembly in method probing", "tree": {"sha": "77463330536d1b6f4ae0c2a70e3a9585bfb0202c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77463330536d1b6f4ae0c2a70e3a9585bfb0202c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbf91532a7bfb2f2ce23067b13cc44659f7883d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbf91532a7bfb2f2ce23067b13cc44659f7883d2", "html_url": "https://github.com/rust-lang/rust/commit/cbf91532a7bfb2f2ce23067b13cc44659f7883d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbf91532a7bfb2f2ce23067b13cc44659f7883d2/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5641481ad735c742cc669bb1e47f10116b789ee7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5641481ad735c742cc669bb1e47f10116b789ee7", "html_url": "https://github.com/rust-lang/rust/commit/5641481ad735c742cc669bb1e47f10116b789ee7"}], "stats": {"total": 45, "additions": 35, "deletions": 10}, "files": [{"sha": "6eeb28e32f1e996b99432b3b2016d8e9881d0c25", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cbf91532a7bfb2f2ce23067b13cc44659f7883d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf91532a7bfb2f2ce23067b13cc44659f7883d2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=cbf91532a7bfb2f2ce23067b13cc44659f7883d2", "patch": "@@ -753,17 +753,27 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n             let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n+            debug!(\"impl_ty: {:?}\", impl_ty);\n+\n             // Determine the receiver type that the method itself expects.\n-            let xform_tys = self.xform_self_ty(&item, impl_ty, impl_substs);\n+            let (xform_self_ty, xform_ret_ty) = self.xform_self_ty(&item, impl_ty, impl_substs);\n+            debug!(\"xform_self_ty: {:?}, xform_ret_ty: {:?}\", xform_self_ty, xform_ret_ty);\n \n             // We can't use normalize_associated_types_in as it will pollute the\n             // fcx's fulfillment context after this probe is over.\n+            // Note: we only normalize `xform_self_ty` here since the normalization\n+            // of the return type can lead to inference results that prohibit\n+            // valid canidates from being found, see issue #85671\n+            // FIXME Postponing the normalization of the return type likely only hides a deeper bug,\n+            // which might be caused by the `param_env` itself. The clauses of the `param_env`\n+            // maybe shouldn't include `Param`s, but rather fresh variables or be canonicalized,\n+            // see isssue #89650\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let selcx = &mut traits::SelectionContext::new(self.fcx);\n-            let traits::Normalized { value: (xform_self_ty, xform_ret_ty), obligations } =\n-                traits::normalize(selcx, self.param_env, cause, xform_tys);\n+            let traits::Normalized { value: xform_self_ty, obligations } =\n+                traits::normalize(selcx, self.param_env, cause, xform_self_ty);\n             debug!(\n-                \"assemble_inherent_impl_probe: xform_self_ty = {:?}/{:?}\",\n+                \"assemble_inherent_impl_probe after normalization: xform_self_ty = {:?}/{:?}\",\n                 xform_self_ty, xform_ret_ty\n             );\n \n@@ -1420,6 +1430,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             };\n \n             let mut result = ProbeResult::Match;\n+            let mut xform_ret_ty = probe.xform_ret_ty;\n+            debug!(?xform_ret_ty);\n+\n             let selcx = &mut traits::SelectionContext::new(self);\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n@@ -1428,7 +1441,17 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n             match probe.kind {\n-                InherentImplCandidate(substs, ref ref_obligations) => {\n+                InherentImplCandidate(ref substs, ref ref_obligations) => {\n+                    // `xform_ret_ty` hasn't been normalized yet, only `xform_self_ty`,\n+                    // see the reasons mentioned in the comments in `assemble_inherent_impl_probe`\n+                    // for why this is necessary\n+                    let traits::Normalized {\n+                        value: normalized_xform_ret_ty,\n+                        obligations: normalization_obligations,\n+                    } = traits::normalize(selcx, self.param_env, cause.clone(), probe.xform_ret_ty);\n+                    xform_ret_ty = normalized_xform_ret_ty;\n+                    debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n+\n                     // Check whether the impl imposes obligations we have to worry about.\n                     let impl_def_id = probe.item.container.id();\n                     let impl_bounds = self.tcx.predicates_of(impl_def_id);\n@@ -1442,7 +1465,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     let candidate_obligations = impl_obligations\n                         .chain(norm_obligations.into_iter())\n-                        .chain(ref_obligations.iter().cloned());\n+                        .chain(ref_obligations.iter().cloned())\n+                        .chain(normalization_obligations.into_iter());\n+\n                     // Evaluate those obligations to see if they might possibly hold.\n                     for o in candidate_obligations {\n                         let o = self.resolve_vars_if_possible(o);\n@@ -1527,9 +1552,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             }\n \n             if let ProbeResult::Match = result {\n-                if let (Some(return_ty), Some(xform_ret_ty)) =\n-                    (self.return_type, probe.xform_ret_ty)\n-                {\n+                if let (Some(return_ty), Some(xform_ret_ty)) = (self.return_type, xform_ret_ty) {\n                     let xform_ret_ty = self.resolve_vars_if_possible(xform_ret_ty);\n                     debug!(\n                         \"comparing return_ty {:?} with xform ret ty {:?}\",\n@@ -1669,6 +1692,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         self.static_candidates.push(source);\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn xform_self_ty(\n         &self,\n         item: &ty::AssocItem,\n@@ -1683,9 +1707,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn xform_method_sig(&self, method: DefId, substs: SubstsRef<'tcx>) -> ty::FnSig<'tcx> {\n         let fn_sig = self.tcx.fn_sig(method);\n-        debug!(\"xform_self_ty(fn_sig={:?}, substs={:?})\", fn_sig, substs);\n+        debug!(?fn_sig);\n \n         assert!(!substs.has_escaping_bound_vars());\n "}]}