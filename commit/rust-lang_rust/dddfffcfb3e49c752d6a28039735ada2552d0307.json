{"sha": "dddfffcfb3e49c752d6a28039735ada2552d0307", "node_id": "C_kwDOAAsO6NoAKGRkZGZmZmNmYjNlNDljNzUyZDZhMjgwMzk3MzVhZGEyNTUyZDAzMDc", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-11-05T01:42:29Z"}, "committer": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2022-02-10T00:15:01Z"}, "message": "Add some safety comments", "tree": {"sha": "113137708aade33f964ee1bd17d92402e25c24e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/113137708aade33f964ee1bd17d92402e25c24e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dddfffcfb3e49c752d6a28039735ada2552d0307", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dddfffcfb3e49c752d6a28039735ada2552d0307", "html_url": "https://github.com/rust-lang/rust/commit/dddfffcfb3e49c752d6a28039735ada2552d0307", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dddfffcfb3e49c752d6a28039735ada2552d0307/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6143bdef6dc6c93c75104e514d9e851060eac6b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6143bdef6dc6c93c75104e514d9e851060eac6b1", "html_url": "https://github.com/rust-lang/rust/commit/6143bdef6dc6c93c75104e514d9e851060eac6b1"}], "stats": {"total": 62, "additions": 57, "deletions": 5}, "files": [{"sha": "d024cf4ddbe30b04211e4460e2e0d831a1b6746d", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -10,13 +10,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n     }\n \n     /// Test if each lane is not equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n     }\n }\n@@ -30,27 +34,35 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n     }\n \n     /// Test if each lane is greater than the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n     }\n \n     /// Test if each lane is less than or equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n     }\n \n     /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n     }\n }"}, {"sha": "b1f98d9eb4e67cad020f0ba7165e134569a408c3", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -42,6 +42,9 @@ mod sealed {\n use sealed::Sealed;\n \n /// Marker trait for types that may be used as SIMD mask elements.\n+///\n+/// # Safety\n+/// Type must be a signed integer.\n pub unsafe trait MaskElement: SimdElement + Sealed {}\n \n macro_rules! impl_element {\n@@ -149,6 +152,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n+        // Safety: the caller must confirm this invariant\n         unsafe { Self(mask_impl::Mask::from_int_unchecked(value)) }\n     }\n \n@@ -161,6 +165,7 @@ where\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_int(value: Simd<T, LANES>) -> Self {\n         assert!(T::valid(value), \"all values must be either 0 or -1\",);\n+        // Safety: the validity has been checked\n         unsafe { Self::from_int_unchecked(value) }\n     }\n \n@@ -179,6 +184,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        // Safety: the caller must confirm this invariant\n         unsafe { self.0.test_unchecked(lane) }\n     }\n \n@@ -190,6 +196,7 @@ where\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn test(&self, lane: usize) -> bool {\n         assert!(lane < LANES, \"lane index out of range\");\n+        // Safety: the lane index has been checked\n         unsafe { self.test_unchecked(lane) }\n     }\n \n@@ -199,6 +206,7 @@ where\n     /// `lane` must be less than `LANES`.\n     #[inline]\n     pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        // Safety: the caller must confirm this invariant\n         unsafe {\n             self.0.set_unchecked(lane, value);\n         }\n@@ -211,6 +219,7 @@ where\n     #[inline]\n     pub fn set(&mut self, lane: usize, value: bool) {\n         assert!(lane < LANES, \"lane index out of range\");\n+        // Safety: the lane index has been checked\n         unsafe {\n             self.set_unchecked(lane, value);\n         }"}, {"sha": "b7f8b2c236effaa145c93b8733e9fc9c642aa1cb", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -137,6 +137,7 @@ where\n     where\n         U: MaskElement,\n     {\n+        // Safety: bitmask layout does not depend on the element width\n         unsafe { core::mem::transmute_copy(&self) }\n     }\n "}, {"sha": "02b5593c8f4651668426f78efb0b40d2c94e4d4b", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -106,6 +106,7 @@ where\n     where\n         U: MaskElement,\n     {\n+        // Safety: masks are simply integer vectors of 0 and -1, and we can cast the element type.\n         unsafe { Mask(intrinsics::simd_cast(self.0)) }\n     }\n \n@@ -155,12 +156,14 @@ where\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n+        // Safety: use `self` as an integer vector\n         unsafe { intrinsics::simd_reduce_any(self.to_int()) }\n     }\n \n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n+        // Safety: use `self` as an integer vector\n         unsafe { intrinsics::simd_reduce_all(self.to_int()) }\n     }\n }\n@@ -184,6 +187,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_and(self.0, rhs.0)) }\n     }\n }\n@@ -197,6 +201,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_or(self.0, rhs.0)) }\n     }\n }\n@@ -210,6 +215,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_xor(self.0, rhs.0)) }\n     }\n }"}, {"sha": "0b4e40983af53e8a54eb11d902850aef0fb53fb1", "filename": "crates/core_simd/src/math.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -22,6 +22,7 @@ macro_rules! impl_uint_arith {\n             /// ```\n             #[inline]\n             pub fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_add(self, second) }\n             }\n \n@@ -41,6 +42,7 @@ macro_rules! impl_uint_arith {\n             /// assert_eq!(sat, Simd::splat(0));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_sub(self, second) }\n             }\n         })+\n@@ -68,6 +70,7 @@ macro_rules! impl_int_arith {\n             /// ```\n             #[inline]\n             pub fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_add(self, second) }\n             }\n \n@@ -87,6 +90,7 @@ macro_rules! impl_int_arith {\n             /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_sub(self, second) }\n             }\n "}, {"sha": "e1cd743e44247d55c4c9f49f6f004a60d981a7cb", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -14,24 +14,28 @@ macro_rules! impl_integer_reductions {\n             /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n             pub fn horizontal_sum(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_add_ordered(self, 0) }\n             }\n \n             /// Horizontal wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n             #[inline]\n             pub fn horizontal_product(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_mul_ordered(self, 1) }\n             }\n \n             /// Horizontal maximum.  Returns the maximum lane in the vector.\n             #[inline]\n             pub fn horizontal_max(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n             /// Horizontal minimum.  Returns the minimum lane in the vector.\n             #[inline]\n             pub fn horizontal_min(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_min(self) }\n             }\n         }\n@@ -63,6 +67,7 @@ macro_rules! impl_float_reductions {\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().sum()\n                 } else {\n+                    // Safety: `self` is a float vector\n                     unsafe { simd_reduce_add_ordered(self, 0.) }\n                 }\n             }\n@@ -74,6 +79,7 @@ macro_rules! impl_float_reductions {\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().product()\n                 } else {\n+                    // Safety: `self` is a float vector\n                     unsafe { simd_reduce_mul_ordered(self, 1.) }\n                 }\n             }\n@@ -84,6 +90,7 @@ macro_rules! impl_float_reductions {\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n             pub fn horizontal_max(self) -> $scalar {\n+                // Safety: `self` is a float vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n@@ -93,6 +100,7 @@ macro_rules! impl_float_reductions {\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n             pub fn horizontal_min(self) -> $scalar {\n+                // Safety: `self` is a float vector\n                 unsafe { simd_reduce_min(self) }\n             }\n         }"}, {"sha": "08b2add11667a77e94444459bb37c06effa67e33", "filename": "crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -95,6 +95,7 @@ pub trait Swizzle<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n         LaneCount<INPUT_LANES>: SupportedLaneCount,\n         LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n     {\n+        // Safety: `vector` is a vector, and `INDEX_IMPL` is a const array of u32.\n         unsafe { intrinsics::simd_shuffle(vector, vector, Self::INDEX_IMPL) }\n     }\n }\n@@ -119,6 +120,7 @@ pub trait Swizzle2<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n         LaneCount<INPUT_LANES>: SupportedLaneCount,\n         LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n     {\n+        // Safety: `first` and `second` are vectors, and `INDEX_IMPL` is a const array of u32.\n         unsafe { intrinsics::simd_shuffle(first, second, Self::INDEX_IMPL) }\n     }\n }"}, {"sha": "b36b1a347b226866431060589d157a5d6bfee197", "filename": "crates/core_simd/src/to_bytes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -8,12 +8,14 @@ macro_rules! impl_to_bytes {\n             /// Return the memory representation of this integer as a byte array in native byte\n             /// order.\n             pub fn to_ne_bytes(self) -> crate::simd::Simd<u8, {{ $size * LANES }}> {\n+                // Safety: transmuting between vectors is safe\n                 unsafe { core::mem::transmute_copy(&self) }\n             }\n \n             /// Create a native endian integer value from its memory representation as a byte array\n             /// in native endianness.\n             pub fn from_ne_bytes(bytes: crate::simd::Simd<u8, {{ $size * LANES }}>) -> Self {\n+                // Safety: transmuting between vectors is safe\n                 unsafe { core::mem::transmute_copy(&bytes) }\n             }\n         }"}, {"sha": "e452fa8bfc8293d718bab6014308bf864ed5bc25", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -206,7 +206,7 @@ where\n         or: Self,\n     ) -> Self {\n         let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n-        // SAFETY: We have masked-off out-of-bounds lanes.\n+        // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n \n@@ -247,7 +247,7 @@ where\n         let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n-        // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n+        // Safety: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n         unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n     }\n \n@@ -299,7 +299,7 @@ where\n         idxs: Simd<usize, LANES>,\n     ) {\n         let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n-        // SAFETY: We have masked-off out-of-bounds lanes.\n+        // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n \n@@ -338,7 +338,7 @@ where\n         enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n-        // SAFETY: This block works with *mut T derived from &mut 'a [T],\n+        // Safety: This block works with *mut T derived from &mut 'a [T],\n         // which means it is delicate in Rust's borrowing model, circa 2021:\n         // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n         // Even though this block is largely safe methods, it must be exactly this way\n@@ -518,7 +518,9 @@ mod sealed {\n use sealed::Sealed;\n \n /// Marker trait for types that may be used as SIMD vector elements.\n-/// SAFETY: This trait, when implemented, asserts the compiler can monomorphize\n+///\n+/// # Safety\n+/// This trait, when implemented, asserts the compiler can monomorphize\n /// `#[repr(simd)]` structs with the marked type as an element.\n /// Strictly, it is valid to impl if the vector will not be miscompiled.\n /// Practically, it is user-unfriendly to impl it if the vector won't compile,"}, {"sha": "417d255c28d63b26db02107d73a650d2566aebf2", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -21,6 +21,8 @@ where\n     #[inline]\n     #[must_use]\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        // Safety: converting pointers to usize and vice-versa is safe\n+        // (even if using that pointer is not)\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n@@ -47,6 +49,8 @@ where\n     #[inline]\n     #[must_use]\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        // Safety: converting pointers to usize and vice-versa is safe\n+        // (even if using that pointer is not)\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })"}, {"sha": "9fb70218c954374b71caa1a34e8c76871d48963f", "filename": "crates/core_simd/src/vendor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fvendor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dddfffcfb3e49c752d6a28039735ada2552d0307/crates%2Fcore_simd%2Fsrc%2Fvendor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvendor.rs?ref=dddfffcfb3e49c752d6a28039735ada2552d0307", "patch": "@@ -9,6 +9,8 @@ macro_rules! from_transmute {\n         impl core::convert::From<$from> for $to {\n             #[inline]\n             fn from(value: $from) -> $to {\n+                // Safety: transmuting between vectors is safe, but the caller of this macro\n+                // checks the invariants\n                 unsafe { core::mem::transmute(value) }\n             }\n         }"}]}