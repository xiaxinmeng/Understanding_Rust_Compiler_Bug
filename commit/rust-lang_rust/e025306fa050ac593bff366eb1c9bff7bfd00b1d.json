{"sha": "e025306fa050ac593bff366eb1c9bff7bfd00b1d", "node_id": "C_kwDOAAsO6NoAKGUwMjUzMDZmYTA1MGFjNTkzYmZmMzY2ZWIxYzliZmY3YmZkMDBiMWQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-22T02:48:36Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-22T03:00:58Z"}, "message": "Don't ICE on regions from anonymous_lifetime_in_impl_trait", "tree": {"sha": "fe2e5f5e3a57dbd6c09e4b493ab976b203886302", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe2e5f5e3a57dbd6c09e4b493ab976b203886302"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e025306fa050ac593bff366eb1c9bff7bfd00b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e025306fa050ac593bff366eb1c9bff7bfd00b1d", "html_url": "https://github.com/rust-lang/rust/commit/e025306fa050ac593bff366eb1c9bff7bfd00b1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e025306fa050ac593bff366eb1c9bff7bfd00b1d/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0940040c0486a536be4f8685c7dd9a078f9e87c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0940040c0486a536be4f8685c7dd9a078f9e87c2", "html_url": "https://github.com/rust-lang/rust/commit/0940040c0486a536be4f8685c7dd9a078f9e87c2"}], "stats": {"total": 128, "additions": 120, "deletions": 8}, "files": [{"sha": "c044dbaba47e2faab5170228d73bd7c571302c0d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 92, "deletions": 8, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e025306fa050ac593bff366eb1c9bff7bfd00b1d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e025306fa050ac593bff366eb1c9bff7bfd00b1d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=e025306fa050ac593bff366eb1c9bff7bfd00b1d", "patch": "@@ -251,7 +251,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_output(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(fr))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr));\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arg_position_impl_trait(fr));\n \n         if let Some(ref value) = value {\n             self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n@@ -869,13 +870,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             return None;\n         }\n \n-        let mut found = false;\n-        tcx.fold_regions(tcx.type_of(region_parent), |r: ty::Region<'tcx>, _| {\n-            if *r == ty::ReEarlyBound(region) {\n-                found = true;\n-            }\n-            r\n-        });\n+        let found = tcx\n+            .any_free_region_meets(&tcx.type_of(region_parent), |r| *r == ty::ReEarlyBound(region));\n \n         Some(RegionName {\n             name: self.synthesize_region_name(),\n@@ -888,4 +884,92 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             ),\n         })\n     }\n+\n+    fn give_name_if_anonymous_region_appears_in_arg_position_impl_trait(\n+        &self,\n+        fr: RegionVid,\n+    ) -> Option<RegionName> {\n+        let ty::ReEarlyBound(region) = *self.to_error_region(fr)? else {\n+            return None;\n+        };\n+        if region.has_name() {\n+            return None;\n+        };\n+\n+        let predicates = self\n+            .infcx\n+            .tcx\n+            .predicates_of(self.body.source.def_id())\n+            .instantiate_identity(self.infcx.tcx)\n+            .predicates;\n+\n+        if let Some(upvar_index) = self\n+            .regioncx\n+            .universal_regions()\n+            .defining_ty\n+            .upvar_tys()\n+            .position(|ty| self.any_param_predicate_mentions(&predicates, ty, region))\n+        {\n+            let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n+                self.infcx.tcx,\n+                &self.upvars,\n+                upvar_index,\n+            );\n+            let region_name = self.synthesize_region_name();\n+\n+            Some(RegionName {\n+                name: region_name,\n+                source: RegionNameSource::AnonRegionFromUpvar(upvar_span, upvar_name),\n+            })\n+        } else if let Some(arg_index) = self\n+            .regioncx\n+            .universal_regions()\n+            .unnormalized_input_tys\n+            .iter()\n+            .position(|ty| self.any_param_predicate_mentions(&predicates, *ty, region))\n+        {\n+            let (arg_name, arg_span) = self.regioncx.get_argument_name_and_span_for_region(\n+                self.body,\n+                &self.local_names,\n+                arg_index,\n+            );\n+            let region_name = self.synthesize_region_name();\n+\n+            Some(RegionName {\n+                name: region_name,\n+                source: RegionNameSource::AnonRegionFromArgument(\n+                    RegionNameHighlight::CannotMatchHirTy(arg_span, arg_name?.to_string()),\n+                ),\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn any_param_predicate_mentions(\n+        &self,\n+        predicates: &[ty::Predicate<'tcx>],\n+        ty: Ty<'tcx>,\n+        region: ty::EarlyBoundRegion,\n+    ) -> bool {\n+        let tcx = self.infcx.tcx;\n+        ty.walk().any(|arg| {\n+            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                && let ty::Param(_) = ty.kind()\n+            {\n+                predicates.iter().any(|pred| {\n+                    match pred.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(data) if data.self_ty() == ty => {}\n+                        ty::PredicateKind::Projection(data) if data.projection_ty.self_ty() == ty => {}\n+                        _ => return false,\n+                    }\n+                    tcx.any_free_region_meets(pred, |r| {\n+                        *r == ty::ReEarlyBound(region)\n+                    })\n+                })\n+            } else {\n+                false\n+            }\n+        })\n+    }\n }"}, {"sha": "7799a7cb151de5d629ee74d65aafd3f2ee69119f", "filename": "src/test/ui/borrowck/anonymous-region-in-apit.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e025306fa050ac593bff366eb1c9bff7bfd00b1d/src%2Ftest%2Fui%2Fborrowck%2Fanonymous-region-in-apit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e025306fa050ac593bff366eb1c9bff7bfd00b1d/src%2Ftest%2Fui%2Fborrowck%2Fanonymous-region-in-apit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fanonymous-region-in-apit.rs?ref=e025306fa050ac593bff366eb1c9bff7bfd00b1d", "patch": "@@ -0,0 +1,12 @@\n+#![feature(anonymous_lifetime_in_impl_trait)]\n+\n+trait Foo<T> {\n+    fn bar(self, baz: T);\n+}\n+\n+fn qux(foo: impl Foo<&str>) {\n+    |baz: &str| foo.bar(baz);\n+    //~^ ERROR borrowed data escapes outside of closure\n+}\n+\n+fn main() {}"}, {"sha": "9e100f8ac3c5033bdced0d4b65259340e73ec23d", "filename": "src/test/ui/borrowck/anonymous-region-in-apit.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e025306fa050ac593bff366eb1c9bff7bfd00b1d/src%2Ftest%2Fui%2Fborrowck%2Fanonymous-region-in-apit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e025306fa050ac593bff366eb1c9bff7bfd00b1d/src%2Ftest%2Fui%2Fborrowck%2Fanonymous-region-in-apit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fanonymous-region-in-apit.stderr?ref=e025306fa050ac593bff366eb1c9bff7bfd00b1d", "patch": "@@ -0,0 +1,16 @@\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/anonymous-region-in-apit.rs:8:17\n+   |\n+LL | fn qux(foo: impl Foo<&str>) {\n+   |        --- lifetime `'2` appears in the type of `foo`\n+LL |     |baz: &str| foo.bar(baz);\n+   |      ---  -     ^^^^^^^^^^^^\n+   |      |    |     |\n+   |      |    |     `baz` escapes the closure body here\n+   |      |    |     argument requires that `'1` must outlive `'2`\n+   |      |    let's call the lifetime of this reference `'1`\n+   |      `baz` is a reference that is only valid in the closure body\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0521`."}]}