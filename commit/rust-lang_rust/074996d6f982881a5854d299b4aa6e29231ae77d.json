{"sha": "074996d6f982881a5854d299b4aa6e29231ae77d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3NDk5NmQ2Zjk4Mjg4MWE1ODU0ZDI5OWI0YWE2ZTI5MjMxYWU3N2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T17:16:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-02T17:16:26Z"}, "message": "rollup merge of #20377: alexcrichton/issue-20352", "tree": {"sha": "4e05eb22c710477c1b8bbf6fc166f795c8240206", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e05eb22c710477c1b8bbf6fc166f795c8240206"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/074996d6f982881a5854d299b4aa6e29231ae77d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/074996d6f982881a5854d299b4aa6e29231ae77d", "html_url": "https://github.com/rust-lang/rust/commit/074996d6f982881a5854d299b4aa6e29231ae77d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/074996d6f982881a5854d299b4aa6e29231ae77d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b7d032014ccbc9256abdc56e633e7c0a3b8342c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b7d032014ccbc9256abdc56e633e7c0a3b8342c", "html_url": "https://github.com/rust-lang/rust/commit/8b7d032014ccbc9256abdc56e633e7c0a3b8342c"}, {"sha": "e423fcf0e0166da55f88233e0be5eacba55bc0bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e423fcf0e0166da55f88233e0be5eacba55bc0bc", "html_url": "https://github.com/rust-lang/rust/commit/e423fcf0e0166da55f88233e0be5eacba55bc0bc"}], "stats": {"total": 677, "additions": 319, "deletions": 358}, "files": [{"sha": "900f23bb9d17270c6507b8d9d264cff0e779916a", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -997,9 +997,11 @@ pub trait ToString {\n \n impl<T: fmt::Show> ToString for T {\n     fn to_string(&self) -> String {\n-        let mut buf = Vec::<u8>::new();\n-        let _ = fmt::write(&mut buf, format_args!(\"{}\", *self));\n-        String::from_utf8(buf).unwrap()\n+        use core::fmt::Writer;\n+        let mut buf = String::new();\n+        let _ = buf.write_fmt(format_args!(\"{}\", self));\n+        buf.shrink_to_fit();\n+        buf\n     }\n }\n \n@@ -1075,6 +1077,13 @@ impl<'a> Str for CowString<'a> {\n     }\n }\n \n+impl fmt::Writer for String {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.push_str(s);\n+        Ok(())\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "ce591daff8cc987646298e0fa37ddeef9078ad9f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -1490,9 +1490,9 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n     }\n }\n \n-impl<'a> fmt::FormatWriter for Vec<u8> {\n-    fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-        self.push_all(buf);\n+impl<'a> fmt::Writer for Vec<u8> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.push_all(s.as_bytes());\n         Ok(())\n     }\n }"}, {"sha": "a39168ec1ec82bd0a33eb5dc060c9db1f9ee3e72", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -23,7 +23,7 @@ use num::FpCategory as Fp;\n use ops::FnOnce;\n use result::Result::Ok;\n use slice::{mod, SliceExt};\n-use str::StrExt;\n+use str::{mod, StrExt};\n \n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {\n@@ -95,7 +95,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     exp_upper: bool,\n     f: F\n ) -> U where\n-    F: FnOnce(&[u8]) -> U,\n+    F: FnOnce(&str) -> U,\n {\n     assert!(2 <= radix && radix <= 36);\n     match exp_format {\n@@ -109,12 +109,12 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     let _1: T = Float::one();\n \n     match num.classify() {\n-        Fp::Nan => return f(\"NaN\".as_bytes()),\n+        Fp::Nan => return f(\"NaN\"),\n         Fp::Infinite if num > _0 => {\n-            return f(\"inf\".as_bytes());\n+            return f(\"inf\");\n         }\n         Fp::Infinite if num < _0 => {\n-            return f(\"-inf\".as_bytes());\n+            return f(\"-inf\");\n         }\n         _ => {}\n     }\n@@ -314,11 +314,11 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n                 end: &'a mut uint,\n             }\n \n-            impl<'a> fmt::FormatWriter for Filler<'a> {\n-                fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+            impl<'a> fmt::Writer for Filler<'a> {\n+                fn write_str(&mut self, s: &str) -> fmt::Result {\n                     slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n-                                              bytes);\n-                    *self.end += bytes.len();\n+                                              s.as_bytes());\n+                    *self.end += s.len();\n                     Ok(())\n                 }\n             }\n@@ -332,5 +332,5 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         }\n     }\n \n-    f(buf[..end])\n+    f(unsafe { str::from_utf8_unchecked(buf[..end]) })\n }"}, {"sha": "f2439d515b457c284d7d85a7e753f7d691299bb5", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 33, "deletions": 38, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -24,7 +24,7 @@ use result::Result::{Ok, Err};\n use result;\n use slice::SliceExt;\n use slice;\n-use str::{StrExt, Utf8Error};\n+use str::{mod, StrExt, Utf8Error};\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -57,7 +57,7 @@ pub struct Error;\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n #[experimental = \"waiting for core and I/O reconciliation\"]\n-pub trait FormatWriter {\n+pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n     /// succeeded.\n     ///\n@@ -68,7 +68,7 @@ pub trait FormatWriter {\n     /// # Errors\n     ///\n     /// This function will return an instance of `FormatError` on error.\n-    fn write(&mut self, bytes: &[u8]) -> Result;\n+    fn write_str(&mut self, s: &str) -> Result;\n \n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n@@ -88,7 +88,7 @@ pub struct Formatter<'a> {\n     width: Option<uint>,\n     precision: Option<uint>,\n \n-    buf: &'a mut (FormatWriter+'a),\n+    buf: &'a mut (Writer+'a),\n     curarg: slice::Iter<'a, Argument<'a>>,\n     args: &'a [Argument<'a>],\n }\n@@ -258,17 +258,6 @@ pub trait UpperExp for Sized? {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n-    position: rt::ArgumentNext,\n-    format: rt::FormatSpec {\n-        fill: ' ',\n-        align: rt::AlignUnknown,\n-        flags: 0,\n-        precision: rt::CountImplied,\n-        width: rt::CountImplied,\n-    }\n-};\n-\n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n@@ -279,7 +268,7 @@ static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n ///   * args - the precompiled arguments generated by `format_args!`\n #[experimental = \"libcore and I/O have yet to be reconciled, and this is an \\\n                   implementation detail which should not otherwise be exported\"]\n-pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n+pub fn write(output: &mut Writer, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n         width: None,\n@@ -296,16 +285,16 @@ pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n     match args.fmt {\n         None => {\n             // We can use default formatting parameters for all arguments.\n-            for _ in range(0, args.args.len()) {\n-                try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n-                try!(formatter.run(&DEFAULT_ARGUMENT));\n+            for (arg, piece) in args.args.iter().zip(pieces.by_ref()) {\n+                try!(formatter.buf.write_str(*piece));\n+                try!((arg.formatter)(arg.value, &mut formatter));\n             }\n         }\n         Some(fmt) => {\n             // Every spec has a corresponding argument that is preceded by\n             // a string piece.\n             for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n-                try!(formatter.buf.write(piece.as_bytes()));\n+                try!(formatter.buf.write_str(*piece));\n                 try!(formatter.run(arg));\n             }\n         }\n@@ -314,7 +303,7 @@ pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n     // There can be only one trailing string piece left.\n     match pieces.next() {\n         Some(piece) => {\n-            try!(formatter.buf.write(piece.as_bytes()));\n+            try!(formatter.buf.write_str(*piece));\n         }\n         None => {}\n     }\n@@ -378,7 +367,7 @@ impl<'a> Formatter<'a> {\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n                         prefix: &str,\n-                        buf: &[u8])\n+                        buf: &str)\n                         -> Result {\n         use char::Char;\n         use fmt::rt::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n@@ -402,9 +391,10 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n-                try!(f.buf.write(b[..n]));\n+                let b = unsafe { str::from_utf8_unchecked(b[0..n]) };\n+                try!(f.buf.write_str(b));\n             }\n-            if prefixed { f.buf.write(prefix.as_bytes()) }\n+            if prefixed { f.buf.write_str(prefix) }\n             else { Ok(()) }\n         };\n \n@@ -413,24 +403,26 @@ impl<'a> Formatter<'a> {\n             // If there's no minimum length requirements then we can just\n             // write the bytes.\n             None => {\n-                try!(write_prefix(self)); self.buf.write(buf)\n+                try!(write_prefix(self)); self.buf.write_str(buf)\n             }\n             // Check if we're over the minimum width, if so then we can also\n             // just write the bytes.\n             Some(min) if width >= min => {\n-                try!(write_prefix(self)); self.buf.write(buf)\n+                try!(write_prefix(self)); self.buf.write_str(buf)\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n-                self.with_padding(min - width, rt::AlignRight, |f| f.buf.write(buf))\n+                self.with_padding(min - width, rt::AlignRight, |f| {\n+                    f.buf.write_str(buf)\n+                })\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n                 self.with_padding(min - width, rt::AlignRight, |f| {\n-                    try!(write_prefix(f)); f.buf.write(buf)\n+                    try!(write_prefix(f)); f.buf.write_str(buf)\n                 })\n             }\n         }\n@@ -451,7 +443,7 @@ impl<'a> Formatter<'a> {\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n-            return self.buf.write(s.as_bytes());\n+            return self.buf.write_str(s);\n         }\n         // The `precision` field can be interpreted as a `max-width` for the\n         // string being formatted\n@@ -463,7 +455,7 @@ impl<'a> Formatter<'a> {\n                 let char_len = s.char_len();\n                 if char_len >= max {\n                     let nchars = ::cmp::min(max, char_len);\n-                    return self.buf.write(s.slice_chars(0, nchars).as_bytes());\n+                    return self.buf.write_str(s.slice_chars(0, nchars));\n                 }\n             }\n             None => {}\n@@ -472,17 +464,17 @@ impl<'a> Formatter<'a> {\n         match self.width {\n             // If we're under the maximum length, and there's no minimum length\n             // requirements, then we can just emit the string\n-            None => self.buf.write(s.as_bytes()),\n+            None => self.buf.write_str(s),\n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n             Some(width) if s.char_len() >= width => {\n-                self.buf.write(s.as_bytes())\n+                self.buf.write_str(s)\n             }\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n                 self.with_padding(width - s.char_len(), rt::AlignLeft, |me| {\n-                    me.buf.write(s.as_bytes())\n+                    me.buf.write_str(s)\n                 })\n             }\n         }\n@@ -507,15 +499,16 @@ impl<'a> Formatter<'a> {\n \n         let mut fill = [0u8; 4];\n         let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n+        let fill = unsafe { str::from_utf8_unchecked(fill[..len]) };\n \n         for _ in range(0, pre_pad) {\n-            try!(self.buf.write(fill[..len]));\n+            try!(self.buf.write_str(fill));\n         }\n \n         try!(f(self));\n \n         for _ in range(0, post_pad) {\n-            try!(self.buf.write(fill[..len]));\n+            try!(self.buf.write_str(fill));\n         }\n \n         Ok(())\n@@ -524,8 +517,8 @@ impl<'a> Formatter<'a> {\n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n     #[unstable = \"reconciling core and I/O may alter this definition\"]\n-    pub fn write(&mut self, data: &[u8]) -> Result {\n-        self.buf.write(data)\n+    pub fn write_str(&mut self, data: &str) -> Result {\n+        self.buf.write_str(data)\n     }\n \n     /// Writes some formatted information into this instance\n@@ -616,7 +609,9 @@ impl Show for char {\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n-        LowerHex::fmt(&(*self as uint), f)\n+        let ret = LowerHex::fmt(&(*self as uint), f);\n+        f.flags &= !(1 << (rt::FlagAlternate as uint));\n+        ret\n     }\n }\n "}, {"sha": "4f0cecbb24353abc591c84fea56ef35fda598c25", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -18,6 +18,7 @@ use fmt;\n use iter::DoubleEndedIteratorExt;\n use num::{Int, cast};\n use slice::SliceExt;\n+use str;\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -60,7 +61,8 @@ trait GenericRadix {\n                 if x == zero { break };                   // No more digits left to accumulate.\n             }\n         }\n-        f.pad_integral(is_positive, self.prefix(), buf[curr..])\n+        let buf = unsafe { str::from_utf8_unchecked(buf[curr..]) };\n+        f.pad_integral(is_positive, self.prefix(), buf)\n     }\n }\n "}, {"sha": "a92c2fe2ccbd8105b0fc05b588d322081d31c164", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -28,7 +28,7 @@ use rustc_trans::save;\n use rustc_trans::trans;\n use rustc_typeck as typeck;\n \n-use serialize::{json, Encodable};\n+use serialize::json;\n \n use std::io;\n use std::io::fs;\n@@ -143,10 +143,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     });\n \n     if sess.opts.debugging_opts & config::AST_JSON_NOEXPAND != 0 {\n-        let mut stdout = io::BufferedWriter::new(io::stdout());\n-        let mut json = json::PrettyEncoder::new(&mut stdout);\n-        // unwrapping so IoError isn't ignored\n-        krate.encode(&mut json).unwrap();\n+        println!(\"{}\", json::as_json(&krate));\n     }\n \n     if sess.show_span() {\n@@ -338,10 +335,7 @@ pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n                    ast_map::map_crate(forest, NodeIdAssigner { sess: sess }));\n \n     if sess.opts.debugging_opts & config::AST_JSON != 0 {\n-        let mut stdout = io::BufferedWriter::new(io::stdout());\n-        let mut json = json::PrettyEncoder::new(&mut stdout);\n-        // unwrapping so IoError isn't ignored\n-        map.krate().encode(&mut json).unwrap();\n+        println!(\"{}\", json::as_json(map.krate()));\n     }\n \n     map"}, {"sha": "b4afb67170bbdb9df8854a2f6981bf2da1e6ace8", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -29,7 +29,7 @@ impl<'a> fmt::Show for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    try!(fmt.write(pile_o_bits.slice(last, i).as_bytes()));\n+                    try!(fmt.write_str(pile_o_bits.slice(last, i)));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -38,15 +38,15 @@ impl<'a> fmt::Show for Escape<'a> {\n                         '\"' => \"&quot;\",\n                         _ => unreachable!()\n                     };\n-                    try!(fmt.write(s.as_bytes()));\n+                    try!(fmt.write_str(s));\n                     last = i + 1;\n                 }\n                 _ => {}\n             }\n         }\n \n         if last < s.len() {\n-            try!(fmt.write(pile_o_bits.slice_from(last).as_bytes()));\n+            try!(fmt.write_str(pile_o_bits.slice_from(last)));\n         }\n         Ok(())\n     }"}, {"sha": "36619566f8c8af67be8f4572a6b4131543305146", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -69,7 +69,7 @@ impl<'a> fmt::Show for TyParamBounds<'a> {\n         let &TyParamBounds(bounds) = self;\n         for (i, bound) in bounds.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write(\" + \".as_bytes()));\n+                try!(f.write_str(\" + \"));\n             }\n             try!(write!(f, \"{}\", *bound));\n         }\n@@ -80,24 +80,24 @@ impl<'a> fmt::Show for TyParamBounds<'a> {\n impl fmt::Show for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n-        try!(f.write(\"&lt;\".as_bytes()));\n+        try!(f.write_str(\"&lt;\"));\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write(\", \".as_bytes()));\n+                try!(f.write_str(\", \"));\n             }\n             try!(write!(f, \"{}\", *life));\n         }\n \n         if self.type_params.len() > 0 {\n             if self.lifetimes.len() > 0 {\n-                try!(f.write(\", \".as_bytes()));\n+                try!(f.write_str(\", \"));\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    try!(f.write(\", \".as_bytes()))\n+                    try!(f.write_str(\", \"))\n                 }\n-                try!(f.write(tp.name.as_bytes()));\n+                try!(f.write_str(tp.name[]));\n \n                 if tp.bounds.len() > 0 {\n                     try!(write!(f, \": {}\", TyParamBounds(tp.bounds.as_slice())));\n@@ -109,7 +109,7 @@ impl fmt::Show for clean::Generics {\n                 };\n             }\n         }\n-        try!(f.write(\"&gt;\".as_bytes()));\n+        try!(f.write_str(\"&gt;\"));\n         Ok(())\n     }\n }\n@@ -120,10 +120,10 @@ impl<'a> fmt::Show for WhereClause<'a> {\n         if gens.where_predicates.len() == 0 {\n             return Ok(());\n         }\n-        try!(f.write(\" <span class='where'>where \".as_bytes()));\n+        try!(f.write_str(\" <span class='where'>where \"));\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write(\", \".as_bytes()));\n+                try!(f.write_str(\", \"));\n             }\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n@@ -135,7 +135,7 @@ impl<'a> fmt::Show for WhereClause<'a> {\n                     try!(write!(f, \"{}: \", lifetime));\n                     for (i, lifetime) in bounds.iter().enumerate() {\n                         if i > 0 {\n-                            try!(f.write(\" + \".as_bytes()));\n+                            try!(f.write_str(\" + \"));\n                         }\n \n                         try!(write!(f, \"{}\", lifetime));\n@@ -146,29 +146,29 @@ impl<'a> fmt::Show for WhereClause<'a> {\n                 }\n             }\n         }\n-        try!(f.write(\"</span>\".as_bytes()));\n+        try!(f.write_str(\"</span>\"));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.write(self.get_ref().as_bytes()));\n+        try!(f.write_str(self.get_ref()));\n         Ok(())\n     }\n }\n \n impl fmt::Show for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() > 0 {\n-            try!(f.write(\"for&lt;\".as_bytes()));\n+            try!(f.write_str(\"for&lt;\"));\n             for (i, lt) in self.lifetimes.iter().enumerate() {\n                 if i > 0 {\n-                    try!(f.write(\", \".as_bytes()));\n+                    try!(f.write_str(\", \"));\n                 }\n                 try!(write!(f, \"{}\", lt));\n             }\n-            try!(f.write(\"&gt; \".as_bytes()));\n+            try!(f.write_str(\"&gt; \"));\n         }\n         write!(f, \"{}\", self.trait_)\n     }\n@@ -196,38 +196,38 @@ impl fmt::Show for clean::PathParameters {\n         match *self {\n             clean::PathParameters::AngleBracketed { ref lifetimes, ref types } => {\n                 if lifetimes.len() > 0 || types.len() > 0 {\n-                    try!(f.write(\"&lt;\".as_bytes()));\n+                    try!(f.write_str(\"&lt;\"));\n                     let mut comma = false;\n                     for lifetime in lifetimes.iter() {\n                         if comma {\n-                            try!(f.write(\", \".as_bytes()));\n+                            try!(f.write_str(\", \"));\n                         }\n                         comma = true;\n                         try!(write!(f, \"{}\", *lifetime));\n                     }\n                     for ty in types.iter() {\n                         if comma {\n-                            try!(f.write(\", \".as_bytes()));\n+                            try!(f.write_str(\", \"));\n                         }\n                         comma = true;\n                         try!(write!(f, \"{}\", *ty));\n                     }\n-                    try!(f.write(\"&gt;\".as_bytes()));\n+                    try!(f.write_str(\"&gt;\"));\n                 }\n             }\n             clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n-                try!(f.write(\"(\".as_bytes()));\n+                try!(f.write_str(\"(\"));\n                 let mut comma = false;\n                 for ty in inputs.iter() {\n                     if comma {\n-                        try!(f.write(\", \".as_bytes()));\n+                        try!(f.write_str(\", \"));\n                     }\n                     comma = true;\n                     try!(write!(f, \"{}\", *ty));\n                 }\n-                try!(f.write(\")\".as_bytes()));\n+                try!(f.write_str(\")\"));\n                 if let Some(ref ty) = *output {\n-                    try!(f.write(\" -&gt; \".as_bytes()));\n+                    try!(f.write_str(\" -&gt; \"));\n                     try!(write!(f, \"{}\", ty));\n                 }\n             }\n@@ -238,20 +238,20 @@ impl fmt::Show for clean::PathParameters {\n \n impl fmt::Show for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.write(self.name.as_bytes()));\n+        try!(f.write_str(self.name.as_slice()));\n         write!(f, \"{}\", self.params)\n     }\n }\n \n impl fmt::Show for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n-            try!(f.write(\"::\".as_bytes()))\n+            try!(f.write_str(\"::\"))\n         }\n \n         for (i, seg) in self.segments.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write(\"::\".as_bytes()))\n+                try!(f.write_str(\"::\"))\n             }\n             try!(write!(f, \"{}\", seg));\n         }\n@@ -433,10 +433,10 @@ impl fmt::Show for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::TyParamBinder(id) => {\n-                f.write(cache().typarams[ast_util::local_def(id)].as_bytes())\n+                f.write_str(cache().typarams[ast_util::local_def(id)][])\n             }\n             clean::Generic(ref name) => {\n-                f.write(name.as_bytes())\n+                f.write_str(name.as_slice())\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path } => {\n                 try!(resolved_path(f, did, path, false));\n@@ -522,7 +522,7 @@ impl fmt::Show for clean::Type {\n                 primitive_link(f, clean::Slice,\n                                format!(\"[{}, ..{}]\", **t, *s).as_slice())\n             }\n-            clean::Bottom => f.write(\"!\".as_bytes()),\n+            clean::Bottom => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {\n                 write!(f, \"*{}{}\", RawMutableSpace(m), **t)\n             }"}, {"sha": "1fce5d5969819d8341a5141f83efd0db4bb4b8ec", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -303,7 +303,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         if ret.is_ok() {\n             let buf = slice::from_raw_buf(&(*ob).data, (*ob).size as uint);\n-            ret = w.write(buf);\n+            ret = w.write_str(str::from_utf8(buf).unwrap());\n         }\n         hoedown_buffer_free(ob);\n         ret"}, {"sha": "11ee16b044582896391436e45a824126c13b1920", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -50,7 +50,6 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json;\n-use serialize::Encodable;\n use serialize::json::ToJson;\n use syntax::ast;\n use syntax::ast_util;\n@@ -1096,7 +1095,7 @@ impl Context {\n         try!(self.recurse(stability.name.clone(), |this| {\n             let json_dst = &this.dst.join(\"stability.json\");\n             let mut json_out = BufferedWriter::new(try!(File::create(json_dst)));\n-            try!(stability.encode(&mut json::Encoder::new(&mut json_out)));\n+            try!(write!(&mut json_out, \"{}\", json::as_json(&stability)));\n \n             let mut title = stability.name.clone();\n             title.push_str(\" - Stability dashboard\");\n@@ -1312,7 +1311,8 @@ impl<'a> Item<'a> {\n         // has anchors for the line numbers that we're linking to.\n         if ast_util::is_local(self.item.def_id) {\n             let mut path = Vec::new();\n-            clean_srcpath(&cx.src_root, self.item.source.filename.as_bytes(), |component| {\n+            clean_srcpath(&cx.src_root, self.item.source.filename.as_bytes(),\n+                          |component| {\n                 path.push(component.to_string());\n             });\n             let href = if self.item.source.loline == self.item.source.hiline {\n@@ -1714,15 +1714,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             try!(write!(w, \";\\n\"));\n         }\n         if types.len() > 0 && required.len() > 0 {\n-            try!(w.write(\"\\n\".as_bytes()));\n+            try!(w.write_str(\"\\n\"));\n         }\n         for m in required.iter() {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m.item()));\n             try!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n-            try!(w.write(\"\\n\".as_bytes()));\n+            try!(w.write_str(\"\\n\"));\n         }\n         for m in provided.iter() {\n             try!(write!(w, \"    \"));\n@@ -2261,8 +2261,9 @@ impl<'a> fmt::Show for Source<'a> {\n \n fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    try!(w.write(highlight::highlight(t.source.as_slice(), Some(\"macro\"),\n-                                      None).as_bytes()));\n+    try!(w.write_str(highlight::highlight(t.source.as_slice(),\n+                                          Some(\"macro\"),\n+                                          None)[]));\n     document(w, it)\n }\n "}, {"sha": "8eb4448c649b1555bc62281e44b3704fa323c68e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -41,7 +41,7 @@ use std::io::File;\n use std::io;\n use std::rc::Rc;\n use externalfiles::ExternalHtml;\n-use serialize::{Decodable, Encodable};\n+use serialize::Decodable;\n use serialize::json::{mod, Json};\n use rustc::session::search_paths::SearchPaths;\n \n@@ -493,14 +493,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n-    let crate_json_str = {\n-        let mut w = Vec::new();\n-        {\n-            let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n-            krate.encode(&mut encoder).unwrap();\n-        }\n-        String::from_utf8(w).unwrap()\n-    };\n+    let crate_json_str = format!(\"{}\", json::as_json(&krate));\n     let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n         Err(e) => panic!(\"Rust generated JSON is invalid: {}\", e)\n@@ -510,5 +503,5 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     json.insert(\"plugins\".to_string(), Json::Object(plugins_json));\n \n     let mut file = try!(File::create(&dst));\n-    Json::Object(json).to_writer(&mut file)\n+    write!(&mut file, \"{}\", Json::Object(json))\n }"}, {"sha": "2c83807aa4f53ee9c18ee9cf34746d9877cddf28", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 147, "deletions": 134, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -227,6 +227,11 @@ pub enum Json {\n pub type Array = Vec<Json>;\n pub type Object = BTreeMap<string::String, Json>;\n \n+pub struct PrettyJson<'a> { inner: &'a Json }\n+\n+pub struct AsJson<'a, T: 'a> { inner: &'a T }\n+pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<uint> }\n+\n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, Copy, PartialEq)]\n pub enum ErrorCode {\n@@ -303,9 +308,15 @@ pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T>\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> string::String {\n-    let buff = Encoder::buffer_encode(object);\n-    string::String::from_utf8(buff).unwrap()\n+pub fn encode<T>(object: &T) -> string::String\n+                 where T: for<'a> Encodable<Encoder<'a>, fmt::Error>\n+{\n+    let mut s = String::new();\n+    {\n+        let mut encoder = Encoder::new(&mut s);\n+        let _ = object.encode(&mut encoder);\n+    }\n+    s\n }\n \n impl fmt::Show for ErrorCode {\n@@ -323,16 +334,16 @@ impl std::error::Error for DecoderError {\n     fn detail(&self) -> Option<std::string::String> { Some(self.to_string()) }\n }\n \n-pub type EncodeResult = io::IoResult<()>;\n+pub type EncodeResult = fmt::Result;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n-pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError> {\n+fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n     try!(wr.write_str(\"\\\"\"));\n \n     let mut start = 0;\n \n-    for (i, byte) in bytes.iter().enumerate() {\n-        let escaped = match *byte {\n+    for (i, byte) in v.bytes().enumerate() {\n+        let escaped = match byte {\n             b'\"' => \"\\\\\\\"\",\n             b'\\\\' => \"\\\\\\\\\",\n             b'\\x00' => \"\\\\u0000\",\n@@ -372,42 +383,38 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n         };\n \n         if start < i {\n-            try!(wr.write(bytes[start..i]));\n+            try!(wr.write_str(v[start..i]));\n         }\n \n         try!(wr.write_str(escaped));\n \n         start = i + 1;\n     }\n \n-    if start != bytes.len() {\n-        try!(wr.write(bytes[start..]));\n+    if start != v.len() {\n+        try!(wr.write_str(v[start..]));\n     }\n \n     wr.write_str(\"\\\"\")\n }\n \n-fn escape_str(writer: &mut io::Writer, v: &str) -> Result<(), io::IoError> {\n-    escape_bytes(writer, v.as_bytes())\n+fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n+    let mut buf = [0, .. 4];\n+    let n = v.encode_utf8(&mut buf).unwrap();\n+    let buf = unsafe { str::from_utf8_unchecked(buf[0..n]) };\n+    escape_str(writer, buf)\n }\n \n-fn escape_char(writer: &mut io::Writer, v: char) -> Result<(), io::IoError> {\n-    let mut buf = [0; 4];\n-    let len = v.encode_utf8(&mut buf).unwrap();\n-    escape_bytes(writer, buf[mut ..len])\n-}\n-\n-fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n-    const LEN: uint = 16;\n-    static BUF: [u8; LEN] = [b' '; LEN];\n+fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n+    const BUF: &'static str = \"                \";\n \n-    while n >= LEN {\n-        try!(wr.write(&BUF));\n-        n -= LEN;\n+    while n >= BUF.len() {\n+        try!(wr.write_str(BUF));\n+        n -= BUF.len();\n     }\n \n     if n > 0 {\n-        wr.write(BUF[..n])\n+        wr.write_str(BUF[..n])\n     } else {\n         Ok(())\n     }\n@@ -423,31 +430,18 @@ fn fmt_number_or_null(v: f64) -> string::String {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n-    writer: &'a mut (io::Writer+'a),\n+    writer: &'a mut (fmt::Writer+'a),\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n-    pub fn new(writer: &'a mut io::Writer) -> Encoder<'a> {\n+    pub fn new(writer: &'a mut fmt::Writer) -> Encoder<'a> {\n         Encoder { writer: writer }\n     }\n-\n-    /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> Vec<u8>  {\n-        //Serialize the object in a string using a writer\n-        let mut m = Vec::new();\n-        // FIXME(14302) remove the transmute and unsafe block.\n-        unsafe {\n-            let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n-            // Vec<u8> never Errs\n-            let _ = object.encode(transmute(&mut encoder));\n-        }\n-        m\n-    }\n }\n \n-impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n+impl<'a> ::Encoder<fmt::Error> for Encoder<'a> {\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n@@ -646,14 +640,14 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder<'a> {\n-    writer: &'a mut (io::Writer+'a),\n+    writer: &'a mut (fmt::Writer+'a),\n     curr_indent: uint,\n     indent: uint,\n }\n \n impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new(writer: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+    pub fn new(writer: &'a mut fmt::Writer) -> PrettyEncoder<'a> {\n         PrettyEncoder { writer: writer, curr_indent: 0, indent: 2, }\n     }\n \n@@ -667,7 +661,7 @@ impl<'a> PrettyEncoder<'a> {\n     }\n }\n \n-impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n+impl<'a> ::Encoder<fmt::Error> for PrettyEncoder<'a> {\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n@@ -927,25 +921,23 @@ impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n     }\n }\n \n-impl Json {\n-    /// Encodes a json value into an io::writer. Uses a single line.\n-    pub fn to_writer(&self, writer: &mut io::Writer) -> EncodeResult {\n-        let mut encoder = Encoder::new(writer);\n-        self.encode(&mut encoder)\n-    }\n+/// Create an `AsJson` wrapper which can be used to print a value as JSON\n+/// on-the-fly via `write!`\n+pub fn as_json<T>(t: &T) -> AsJson<T> {\n+    AsJson { inner: t }\n+}\n \n-    /// Encodes a json value into an io::writer.\n-    /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, writer: &mut io::Writer) -> EncodeResult {\n-        let mut encoder = PrettyEncoder::new(writer);\n-        self.encode(&mut encoder)\n-    }\n+/// Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\n+/// on-the-fly via `write!`\n+pub fn as_pretty_json<T>(t: &T) -> AsPrettyJson<T> {\n+    AsPrettyJson { inner: t, indent: None }\n+}\n \n-    /// Encodes a json value into a string\n-    pub fn to_pretty_str(&self) -> string::String {\n-        let mut s = Vec::new();\n-        self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        string::String::from_utf8(s).unwrap()\n+impl Json {\n+    /// Borrow this json object as a pretty object to generate a pretty\n+    /// representation for it via `Show`.\n+    pub fn pretty(&self) -> PrettyJson {\n+        PrettyJson { inner: self }\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -2424,10 +2416,65 @@ impl<A:ToJson> ToJson for Option<A> {\n     }\n }\n \n+struct FormatShim<'a, 'b: 'a> {\n+    inner: &'a mut fmt::Formatter<'b>,\n+}\n+\n+impl<'a, 'b> fmt::Writer for FormatShim<'a, 'b> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.inner.write_str(s)\n+    }\n+}\n+\n impl fmt::Show for Json {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.to_writer(f).map_err(|_| fmt::Error)\n+        let mut shim = FormatShim { inner: f };\n+        let mut encoder = Encoder::new(&mut shim);\n+        self.encode(&mut encoder)\n+    }\n+}\n+\n+impl<'a> fmt::Show for PrettyJson<'a> {\n+    /// Encodes a json value into a string\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut shim = FormatShim { inner: f };\n+        let mut encoder = PrettyEncoder::new(&mut shim);\n+        self.inner.encode(&mut encoder)\n+    }\n+}\n+\n+impl<'a, T> fmt::Show for AsJson<'a, T>\n+    where T: for<'b> Encodable<Encoder<'b>, fmt::Error>\n+{\n+    /// Encodes a json value into a string\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut shim = FormatShim { inner: f };\n+        let mut encoder = Encoder::new(&mut shim);\n+        self.inner.encode(&mut encoder)\n+    }\n+}\n+\n+impl<'a, T> AsPrettyJson<'a, T> {\n+    /// Set the indentation level for the emitted JSON\n+    pub fn indent(mut self, indent: uint) -> AsPrettyJson<'a, T> {\n+        self.indent = Some(indent);\n+        self\n+    }\n+}\n+\n+impl<'a, T> fmt::Show for AsPrettyJson<'a, T>\n+    where T: for<'b> Encodable<PrettyEncoder<'b>, fmt::Error>\n+{\n+    /// Encodes a json value into a string\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut shim = FormatShim { inner: f };\n+        let mut encoder = PrettyEncoder::new(&mut shim);\n+        match self.indent {\n+            Some(n) => encoder.set_indent(n),\n+            None => {}\n+        }\n+        self.inner.encode(&mut encoder)\n     }\n }\n \n@@ -2450,9 +2497,9 @@ mod tests {\n     use super::DecoderError::*;\n     use super::JsonEvent::*;\n     use super::StackElement::*;\n-    use super::{PrettyEncoder, Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n-                StackElement, Stack, Encoder, Decoder};\n-    use std::{i64, u64, f32, f64, io};\n+    use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n+                StackElement, Stack, Decoder};\n+    use std::{i64, u64, f32, f64};\n     use std::collections::BTreeMap;\n     use std::num::Float;\n     use std::string;\n@@ -2523,74 +2570,74 @@ mod tests {\n     #[test]\n     fn test_write_null() {\n         assert_eq!(Null.to_string(), \"null\");\n-        assert_eq!(Null.to_pretty_str(), \"null\");\n+        assert_eq!(Null.pretty().to_string(), \"null\");\n     }\n \n     #[test]\n     fn test_write_i64() {\n         assert_eq!(U64(0).to_string(), \"0\");\n-        assert_eq!(U64(0).to_pretty_str(), \"0\");\n+        assert_eq!(U64(0).pretty().to_string(), \"0\");\n \n         assert_eq!(U64(1234).to_string(), \"1234\");\n-        assert_eq!(U64(1234).to_pretty_str(), \"1234\");\n+        assert_eq!(U64(1234).pretty().to_string(), \"1234\");\n \n         assert_eq!(I64(-5678).to_string(), \"-5678\");\n-        assert_eq!(I64(-5678).to_pretty_str(), \"-5678\");\n+        assert_eq!(I64(-5678).pretty().to_string(), \"-5678\");\n \n         assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n-        assert_eq!(U64(7650007200025252000).to_pretty_str(), \"7650007200025252000\");\n+        assert_eq!(U64(7650007200025252000).pretty().to_string(), \"7650007200025252000\");\n     }\n \n     #[test]\n     fn test_write_f64() {\n         assert_eq!(F64(3.0).to_string(), \"3.0\");\n-        assert_eq!(F64(3.0).to_pretty_str(), \"3.0\");\n+        assert_eq!(F64(3.0).pretty().to_string(), \"3.0\");\n \n         assert_eq!(F64(3.1).to_string(), \"3.1\");\n-        assert_eq!(F64(3.1).to_pretty_str(), \"3.1\");\n+        assert_eq!(F64(3.1).pretty().to_string(), \"3.1\");\n \n         assert_eq!(F64(-1.5).to_string(), \"-1.5\");\n-        assert_eq!(F64(-1.5).to_pretty_str(), \"-1.5\");\n+        assert_eq!(F64(-1.5).pretty().to_string(), \"-1.5\");\n \n         assert_eq!(F64(0.5).to_string(), \"0.5\");\n-        assert_eq!(F64(0.5).to_pretty_str(), \"0.5\");\n+        assert_eq!(F64(0.5).pretty().to_string(), \"0.5\");\n \n         assert_eq!(F64(f64::NAN).to_string(), \"null\");\n-        assert_eq!(F64(f64::NAN).to_pretty_str(), \"null\");\n+        assert_eq!(F64(f64::NAN).pretty().to_string(), \"null\");\n \n         assert_eq!(F64(f64::INFINITY).to_string(), \"null\");\n-        assert_eq!(F64(f64::INFINITY).to_pretty_str(), \"null\");\n+        assert_eq!(F64(f64::INFINITY).pretty().to_string(), \"null\");\n \n         assert_eq!(F64(f64::NEG_INFINITY).to_string(), \"null\");\n-        assert_eq!(F64(f64::NEG_INFINITY).to_pretty_str(), \"null\");\n+        assert_eq!(F64(f64::NEG_INFINITY).pretty().to_string(), \"null\");\n     }\n \n     #[test]\n     fn test_write_str() {\n         assert_eq!(String(\"\".to_string()).to_string(), \"\\\"\\\"\");\n-        assert_eq!(String(\"\".to_string()).to_pretty_str(), \"\\\"\\\"\");\n+        assert_eq!(String(\"\".to_string()).pretty().to_string(), \"\\\"\\\"\");\n \n         assert_eq!(String(\"homura\".to_string()).to_string(), \"\\\"homura\\\"\");\n-        assert_eq!(String(\"madoka\".to_string()).to_pretty_str(), \"\\\"madoka\\\"\");\n+        assert_eq!(String(\"madoka\".to_string()).pretty().to_string(), \"\\\"madoka\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n         assert_eq!(Boolean(true).to_string(), \"true\");\n-        assert_eq!(Boolean(true).to_pretty_str(), \"true\");\n+        assert_eq!(Boolean(true).pretty().to_string(), \"true\");\n \n         assert_eq!(Boolean(false).to_string(), \"false\");\n-        assert_eq!(Boolean(false).to_pretty_str(), \"false\");\n+        assert_eq!(Boolean(false).pretty().to_string(), \"false\");\n     }\n \n     #[test]\n     fn test_write_array() {\n         assert_eq!(Array(vec![]).to_string(), \"[]\");\n-        assert_eq!(Array(vec![]).to_pretty_str(), \"[]\");\n+        assert_eq!(Array(vec![]).pretty().to_string(), \"[]\");\n \n         assert_eq!(Array(vec![Boolean(true)]).to_string(), \"[true]\");\n         assert_eq!(\n-            Array(vec![Boolean(true)]).to_pretty_str(),\n+            Array(vec![Boolean(true)]).pretty().to_string(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n@@ -2605,7 +2652,7 @@ mod tests {\n         assert_eq!(long_test_array.to_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n         assert_eq!(\n-            long_test_array.to_pretty_str(),\n+            long_test_array.pretty().to_string(),\n             \"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -2621,7 +2668,7 @@ mod tests {\n     #[test]\n     fn test_write_object() {\n         assert_eq!(mk_object(&[]).to_string(), \"{}\");\n-        assert_eq!(mk_object(&[]).to_pretty_str(), \"{}\");\n+        assert_eq!(mk_object(&[]).pretty().to_string(), \"{}\");\n \n         assert_eq!(\n             mk_object(&[\n@@ -2630,7 +2677,7 @@ mod tests {\n             \"{\\\"a\\\":true}\"\n         );\n         assert_eq!(\n-            mk_object(&[(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n+            mk_object(&[(\"a\".to_string(), Boolean(true))]).pretty().to_string(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n@@ -2654,7 +2701,7 @@ mod tests {\n             }\"\n         );\n         assert_eq!(\n-            complex_obj.to_pretty_str(),\n+            complex_obj.pretty().to_string(),\n             \"\\\n             {\\n  \\\n                 \\\"b\\\": [\\n    \\\n@@ -2678,48 +2725,29 @@ mod tests {\n \n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n-        assert_eq!(a.clone(), from_str(a.to_string().as_slice()).unwrap());\n-        assert_eq!(a.clone(),\n-                   from_str(a.to_pretty_str().as_slice()).unwrap());\n-    }\n-\n-    fn with_str_writer<F>(f: F) -> string::String where F: FnOnce(&mut io::Writer){\n-        let mut m = Vec::new();\n-        f(&mut m as &mut io::Writer);\n-        string::String::from_utf8(m).unwrap()\n+        assert_eq!(a.clone(), a.to_string().parse().unwrap());\n+        assert_eq!(a.clone(), a.pretty().to_string().parse().unwrap());\n     }\n \n     #[test]\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n-            with_str_writer(|writer| {\n-                let mut encoder = Encoder::new(writer);\n-                animal.encode(&mut encoder).unwrap();\n-            }),\n+            format!(\"{}\", super::as_json(&animal)),\n             \"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n-            with_str_writer(|writer| {\n-                let mut encoder = PrettyEncoder::new(writer);\n-                animal.encode(&mut encoder).unwrap();\n-            }),\n+            format!(\"{}\", super::as_pretty_json(&animal)),\n             \"\\\"Dog\\\"\"\n         );\n \n         let animal = Frog(\"Henry\".to_string(), 349);\n         assert_eq!(\n-            with_str_writer(|writer| {\n-                let mut encoder = Encoder::new(writer);\n-                animal.encode(&mut encoder).unwrap();\n-            }),\n+            format!(\"{}\", super::as_json(&animal)),\n             \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n-            with_str_writer(|writer| {\n-                let mut encoder = PrettyEncoder::new(writer);\n-                animal.encode(&mut encoder).unwrap();\n-            }),\n+            format!(\"{}\", super::as_pretty_json(&animal)),\n             \"{\\n  \\\n                \\\"variant\\\": \\\"Frog\\\",\\n  \\\n                \\\"fields\\\": [\\n    \\\n@@ -2732,16 +2760,10 @@ mod tests {\n \n     macro_rules! check_encoder_for_simple {\n         ($value:expr, $expected:expr) => ({\n-            let s = with_str_writer(|writer| {\n-                let mut encoder = Encoder::new(writer);\n-                $value.encode(&mut encoder).unwrap();\n-            });\n+            let s = format!(\"{}\", super::as_json(&$value));\n             assert_eq!(s, $expected);\n \n-            let s = with_str_writer(|writer| {\n-                let mut encoder = PrettyEncoder::new(writer);\n-                $value.encode(&mut encoder).unwrap();\n-            });\n+            let s = format!(\"{}\", super::as_pretty_json(&$value));\n             assert_eq!(s, $expected);\n         })\n     }\n@@ -3320,10 +3342,7 @@ mod tests {\n         let mut hm: HashMap<uint, bool> = HashMap::new();\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n-        {\n-            let mut encoder = Encoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder).unwrap();\n-        }\n+        write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n         let json_str = from_utf8(mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n@@ -3339,10 +3358,7 @@ mod tests {\n         let mut hm: HashMap<uint, bool> = HashMap::new();\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n-        {\n-            let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder).unwrap()\n-        }\n+        write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n         let json_str = from_utf8(mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n@@ -3373,18 +3389,15 @@ mod tests {\n \n         // Helper function for counting indents\n         fn indents(source: &str) -> uint {\n-            let trimmed = source.trim_left_chars(' ');\n+            let trimmed = source.trim_left_matches(' ');\n             source.len() - trimmed.len()\n         }\n \n         // Test up to 4 spaces of indents (more?)\n         for i in range(0, 4u) {\n             let mut writer = Vec::new();\n-            {\n-                let ref mut encoder = PrettyEncoder::new(&mut writer);\n-                encoder.set_indent(i);\n-                json.encode(encoder).unwrap();\n-            }\n+            write!(&mut writer, \"{}\",\n+                   super::as_pretty_json(&json).indent(i)).unwrap();\n \n             let printed = from_utf8(writer[]).unwrap();\n "}, {"sha": "d3bcdbf1a53e792c84bcff22662555c2efa32622", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -14,7 +14,6 @@ use prelude::v1::*;\n \n use any::{Any, AnyRefExt};\n use cell::RefCell;\n-use fmt;\n use io::IoResult;\n use rt::{backtrace, unwind};\n use rt::util::{Stderr, Stdio};\n@@ -29,10 +28,7 @@ thread_local! {\n \n impl Writer for Stdio {\n     fn write(&mut self, bytes: &[u8]) -> IoResult<()> {\n-        fn fmt_write<F: fmt::FormatWriter>(f: &mut F, bytes: &[u8]) {\n-            let _ = f.write(bytes);\n-        }\n-        fmt_write(self, bytes);\n+        let _ = self.write_bytes(bytes);\n         Ok(())\n     }\n }"}, {"sha": "32f5f2d45363fdee716e3350d2780c41fb9a7c21", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -201,7 +201,7 @@\n //!         // for details, and the function `pad` can be used to pad strings.\n //!         let decimals = f.precision().unwrap_or(3);\n //!         let string = f64::to_str_exact(magnitude, decimals);\n-//!         f.pad_integral(true, \"\", string.as_bytes())\n+//!         f.pad_integral(true, \"\", string.as_slice())\n //!     }\n //! }\n //!\n@@ -390,13 +390,9 @@\n \n #![experimental]\n \n-use io::Writer;\n-use io;\n-use result::Result::{Ok, Err};\n use string;\n-use vec::Vec;\n \n-pub use core::fmt::{Formatter, Result, FormatWriter, rt};\n+pub use core::fmt::{Formatter, Result, Writer, rt};\n pub use core::fmt::{Show, Octal, Binary};\n pub use core::fmt::{LowerHex, UpperHex, Pointer};\n pub use core::fmt::{LowerExp, UpperExp};\n@@ -424,16 +420,7 @@ pub use core::fmt::{argument, argumentuint};\n #[experimental = \"this is an implementation detail of format! and should not \\\n                   be called directly\"]\n pub fn format(args: Arguments) -> string::String {\n-    let mut output = Vec::new();\n-    let _ = write!(&mut output as &mut Writer, \"{}\", args);\n-    string::String::from_utf8(output).unwrap()\n-}\n-\n-impl<'a> Writer for Formatter<'a> {\n-    fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n-        match (*self).write(b) {\n-            Ok(()) => Ok(()),\n-            Err(Error) => Err(io::standard_error(io::OtherIoError))\n-        }\n-    }\n+    let mut output = string::String::new();\n+    let _ = write!(&mut output, \"{}\", args);\n+    output\n }"}, {"sha": "813edc3eb53b5eb11624dd502e9f354b93960a9d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -1028,16 +1028,16 @@ pub trait Writer {\n     ///\n     /// This function will return any I/O error reported while formatting.\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n-        // Create a shim which translates a Writer to a FormatWriter and saves\n+        // Create a shim which translates a Writer to a fmt::Writer and saves\n         // off I/O errors. instead of discarding them\n         struct Adaptor<'a, T:'a> {\n             inner: &'a mut T,\n             error: IoResult<()>,\n         }\n \n-        impl<'a, T: Writer> fmt::FormatWriter for Adaptor<'a, T> {\n-            fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                match self.inner.write(bytes) {\n+        impl<'a, T: Writer> fmt::Writer for Adaptor<'a, T> {\n+            fn write_str(&mut self, s: &str) -> fmt::Result {\n+                match self.inner.write(s.as_bytes()) {\n                     Ok(()) => Ok(()),\n                     Err(e) => {\n                         self.error = Err(e);"}, {"sha": "d5a7c9aba9d5d20374950d250e4c827b9d91324e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -493,27 +493,16 @@ pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n-    use fmt::FormatWriter;\n+    use fmt::Writer;\n \n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n     // panic + OOM properly anyway (see comment in begin_unwind\n     // below).\n \n-    struct VecWriter<'a> { v: &'a mut Vec<u8> }\n-\n-    impl<'a> fmt::FormatWriter for VecWriter<'a> {\n-        fn write(&mut self, buf: &[u8]) -> fmt::Result {\n-            self.v.push_all(buf);\n-            Ok(())\n-        }\n-    }\n-\n-    let mut v = Vec::new();\n-    let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n-\n-    let msg = box String::from_utf8_lossy(v.as_slice()).into_owned();\n-    begin_unwind_inner(msg, file_line)\n+    let mut s = String::new();\n+    let _ = write!(&mut s, \"{}\", msg);\n+    begin_unwind_inner(box s, file_line)\n }\n \n /// This is the entry point of unwinding for panic!() and assert!()."}, {"sha": "384783221df6bc70a45d00d56e18b31e661d5b9d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -95,8 +95,8 @@ pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n #[allow(non_upper_case_globals)]\n pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n \n-impl fmt::FormatWriter for Stdio {\n-    fn write(&mut self, data: &[u8]) -> fmt::Result {\n+impl Stdio {\n+    pub fn write_bytes(&mut self, data: &[u8]) {\n         #[cfg(unix)]\n         type WriteLen = libc::size_t;\n         #[cfg(windows)]\n@@ -107,6 +107,12 @@ impl fmt::FormatWriter for Stdio {\n                         data.as_ptr() as *const libc::c_void,\n                         data.len() as WriteLen);\n         }\n+    }\n+}\n+\n+impl fmt::Writer for Stdio {\n+    fn write_str(&mut self, data: &str) -> fmt::Result {\n+        self.write_bytes(data.as_bytes());\n         Ok(()) // yes, we're lying\n     }\n }\n@@ -116,16 +122,16 @@ pub fn dumb_print(args: fmt::Arguments) {\n }\n \n pub fn abort(args: fmt::Arguments) -> ! {\n-    use fmt::FormatWriter;\n+    use fmt::Writer;\n \n     struct BufWriter<'a> {\n         buf: &'a mut [u8],\n         pos: uint,\n     }\n-    impl<'a> FormatWriter for BufWriter<'a> {\n-        fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+    impl<'a> fmt::Writer for BufWriter<'a> {\n+        fn write_str(&mut self, bytes: &str) -> fmt::Result {\n             let left = self.buf.slice_from_mut(self.pos);\n-            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n+            let to_write = bytes.as_bytes()[..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())"}, {"sha": "4606e70d83bb54b8bc5ec1e7fe0d0ca89b0fde2c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -1662,6 +1662,7 @@ mod test {\n     use serialize;\n     use codemap::*;\n     use super::*;\n+    use std::fmt;\n \n     // are ASTs encodable?\n     #[test]\n@@ -1687,6 +1688,6 @@ mod test {\n             exported_macros: Vec::new(),\n         };\n         // doesn't matter which encoder we use....\n-        let _f = &e as &serialize::Encodable<json::Encoder, io::IoError>;\n+        let _f = &e as &serialize::Encodable<json::Encoder, fmt::Error>;\n     }\n }"}, {"sha": "2ea5ee3e16d1821c9b1306e9d7b79e54a2ce8847", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -171,14 +171,14 @@ impl TestFn {\n \n impl fmt::Show for TestFn {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write(match *self {\n+        f.write_str(match *self {\n             StaticTestFn(..) => \"StaticTestFn(..)\",\n             StaticBenchFn(..) => \"StaticBenchFn(..)\",\n             StaticMetricFn(..) => \"StaticMetricFn(..)\",\n             DynTestFn(..) => \"DynTestFn(..)\",\n             DynMetricFn(..) => \"DynMetricFn(..)\",\n             DynBenchFn(..) => \"DynBenchFn(..)\"\n-        }.as_bytes())\n+        })\n     }\n }\n \n@@ -1212,8 +1212,7 @@ impl MetricMap {\n     pub fn save(&self, p: &Path) -> io::IoResult<()> {\n         let mut file = try!(File::create(p));\n         let MetricMap(ref map) = *self;\n-        let mut enc = json::PrettyEncoder::new(&mut file);\n-        map.encode(&mut enc)\n+        write!(&mut file, \"{}\", json::as_json(map))\n     }\n \n     /// Compare against another MetricMap. Optionally compare all"}, {"sha": "cae7a4cefadb0c5635cc73a97bfa0ee9da3f1a30", "filename": "src/test/compile-fail/variance-trait-matching-2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -10,17 +10,17 @@\n \n extern crate serialize;\n \n-use std::io;\n+use std::fmt;\n use serialize::{Encodable, Encoder};\n \n pub fn buffer_encode<'a,\n-                     T:Encodable<serialize::json::Encoder<'a>,io::IoError>>(\n+                     T:Encodable<serialize::json::Encoder<'a>,fmt::Error>>(\n                      to_encode_object: &T)\n-                     -> Vec<u8> {\n-    let mut m = Vec::new();\n+                     -> String {\n+    let mut m = String::new();\n     {\n         let mut encoder =\n-            serialize::json::Encoder::new(&mut m as &mut io::Writer);\n+            serialize::json::Encoder::new(&mut m);\n         //~^ ERROR `m` does not live long enough\n         to_encode_object.encode(&mut encoder);\n     }"}, {"sha": "8b013199369a31789d69555c9d411ad4bbb12824", "filename": "src/test/run-fail/panic-non-utf8.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8b7d032014ccbc9256abdc56e633e7c0a3b8342c/src%2Ftest%2Frun-fail%2Fpanic-non-utf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7d032014ccbc9256abdc56e633e7c0a3b8342c/src%2Ftest%2Frun-fail%2Fpanic-non-utf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-non-utf8.rs?ref=8b7d032014ccbc9256abdc56e633e7c0a3b8342c", "patch": "@@ -1,26 +0,0 @@\n-\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Previously failed formating invalid utf8.\n-// cc #16877\n-\n-// error-pattern:panicked at 'hello\ufffd'\n-\n-struct Foo;\n-impl std::fmt::Show for Foo {\n-    fn fmt(&self, fmtr:&mut std::fmt::Formatter) -> std::fmt::Result {\n-        // Purge invalid utf8: 0xff\n-        fmtr.write(&[104, 101, 108, 108, 111, 0xff])\n-    }\n-}\n-fn main() {\n-    panic!(\"{}\", Foo)\n-}"}, {"sha": "d2caecdf05be2a31a8d81282b88c02182bc737c7", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -15,7 +15,6 @@\n \n use std::io::MemWriter;\n use std::fmt;\n-use std::fmt::FormatWriter;\n \n struct Foo<'a> {\n     writer: &'a mut (Writer+'a),\n@@ -24,8 +23,8 @@ struct Foo<'a> {\n \n struct Bar;\n \n-impl fmt::FormatWriter for Bar {\n-    fn write(&mut self, _: &[u8]) -> fmt::Result {\n+impl fmt::Writer for Bar {\n+    fn write_str(&mut self, _: &str) -> fmt::Result {\n         Ok(())\n     }\n }\n@@ -41,5 +40,8 @@ fn main() {\n     println!(\"ok\");\n \n     let mut s = Bar;\n-    write!(&mut s, \"test\");\n+    {\n+        use std::fmt::Writer;\n+        write!(&mut s, \"test\");\n+    }\n }"}, {"sha": "1efae89f665631ad0f0ac47a6b5422e69beb5573", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -16,25 +16,24 @@\n #![allow(unused_must_use)]\n \n use std::fmt;\n-use std::io;\n \n struct A;\n struct B;\n struct C;\n \n impl fmt::LowerHex for A {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write(\"aloha\".as_bytes())\n+        f.write_str(\"aloha\")\n     }\n }\n impl fmt::UpperHex for B {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write(\"adios\".as_bytes())\n+        f.write_str(\"adios\")\n     }\n }\n impl fmt::Show for C {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad_integral(true, \"\u2603\", \"123\".as_bytes())\n+        f.pad_integral(true, \"\u2603\", \"123\")\n     }\n }\n \n@@ -160,18 +159,18 @@ pub fn main() {\n // Basic test to make sure that we can invoke the `write!` macro with an\n // io::Writer instance.\n fn test_write() {\n-    let mut buf = Vec::new();\n-    write!(&mut buf as &mut io::Writer, \"{}\", 3i);\n+    use std::fmt::Writer;\n+    let mut buf = String::new();\n+    write!(&mut buf, \"{}\", 3i);\n     {\n-        let w = &mut buf as &mut io::Writer;\n+        let w = &mut buf;\n         write!(w, \"{foo}\", foo=4i);\n         write!(w, \"{}\", \"hello\");\n         writeln!(w, \"{}\", \"line\");\n         writeln!(w, \"{foo}\", foo=\"bar\");\n     }\n \n-    let s = String::from_utf8(buf).unwrap();\n-    t!(s, \"34helloline\\nbar\\n\");\n+    t!(buf, \"34helloline\\nbar\\n\");\n }\n \n // Just make sure that the macros are defined, there's not really a lot that we\n@@ -187,14 +186,15 @@ fn test_print() {\n // Just make sure that the macros are defined, there's not really a lot that we\n // can do with them just yet (to test the output)\n fn test_format_args() {\n-    let mut buf = Vec::new();\n+    use std::fmt::Writer;\n+    let mut buf = String::new();\n     {\n-        let w = &mut buf as &mut io::Writer;\n+        let w = &mut buf;\n         write!(w, \"{}\", format_args!(\"{}\", 1i));\n         write!(w, \"{}\", format_args!(\"test\"));\n         write!(w, \"{}\", format_args!(\"{test}\", test=3i));\n     }\n-    let s = String::from_utf8(buf).unwrap();\n+    let s = buf;\n     t!(s, \"1test3\");\n \n     let s = fmt::format(format_args!(\"hello {}\", \"world\"));"}, {"sha": "0e0aea081f634eb8ed08a66008d5a97109432959", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -12,7 +12,8 @@ extern crate rbml;\n extern crate serialize;\n \n use std::io;\n-use std::io::{IoError, IoResult, SeekStyle};\n+use std::fmt;\n+use std::io::{IoResult, SeekStyle};\n use std::slice;\n \n use serialize::{Encodable, Encoder};\n@@ -37,16 +38,15 @@ enum WireProtocol {\n     // ...\n }\n \n-fn encode_json<'a,\n-               T: Encodable<json::Encoder<'a>,\n-                            std::io::IoError>>(val: &T,\n-                                               wr: &'a mut SeekableMemWriter) {\n-    let mut encoder = json::Encoder::new(wr);\n-    val.encode(&mut encoder);\n+fn encode_json<\n+               T: for<'a> Encodable<json::Encoder<'a>,\n+                            fmt::Error>>(val: &T,\n+                                               wr: &mut SeekableMemWriter) {\n+    write!(wr, \"{}\", json::as_json(val));\n }\n fn encode_rbml<'a,\n                T: Encodable<writer::Encoder<'a, SeekableMemWriter>,\n-                            std::io::IoError>>(val: &T,\n+                            io::IoError>>(val: &T,\n                                                wr: &'a mut SeekableMemWriter) {\n     let mut encoder = writer::Encoder::new(wr);\n     val.encode(&mut encoder);"}, {"sha": "1ab8deda3830e035c91436617afe1d55d30bd1f0", "filename": "src/test/run-pass/issue-15924.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/074996d6f982881a5854d299b4aa6e29231ae77d/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15924.rs?ref=074996d6f982881a5854d299b4aa6e29231ae77d", "patch": "@@ -12,7 +12,7 @@\n \n extern crate serialize;\n \n-use std::io::IoError;\n+use std::fmt;\n use serialize::{Encoder, Encodable};\n use serialize::json;\n \n@@ -21,7 +21,7 @@ struct Foo<T> {\n }\n \n #[unsafe_destructor]\n-impl<'a, T: Encodable<json::Encoder<'a>, IoError>> Drop for Foo<T> {\n+impl<T: for<'a> Encodable<json::Encoder<'a>, fmt::Error>> Drop for Foo<T> {\n     fn drop(&mut self) {\n         json::encode(&self.v);\n     }"}]}