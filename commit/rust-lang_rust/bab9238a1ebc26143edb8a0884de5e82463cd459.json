{"sha": "bab9238a1ebc26143edb8a0884de5e82463cd459", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYjkyMzhhMWViYzI2MTQzZWRiOGEwODg0ZGU1ZTgyNDYzY2Q0NTk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-09-15T12:46:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-15T12:46:21Z"}, "message": "Rollup merge of #36438 - jseyfried:node_ids_in_expansion, r=nrc\n\nAssign node ids during macro expansion\n\nAfter this PR,\n - The `ExtCtxt` can access `resolve`'s `Resolver` through the trait object `ext::base::Resolver`.\n  - The `Resolver` trait object can load macros and replaces today's `MacroLoader` trait object.\n  - The macro expander uses the `Resolver` trait object to resolve macro invocations.\n - The macro expander assigns node ids and builds the `Resolver`'s `macros_at_scope` map.\n   - This is groundwork for merging import resolution and expansion.\n - Performance of expansion together with node id assignment improves by ~5%.\n\n**EDIT:** Since Github is reordering the commits, here is `git log`:\n - b54e1e399741579612f13e2df98a25ea9447989d: Differentiate between monotonic and non-monotonic expansion and only assign node ids during monotonic expansion.\n - 78c00398780db6f59ebf43e765fa9368dad436d2: Expand generated test harnesses and macro registries.\n - f3c2dca3539e6edc745f9c91898cb97d281865c1: Remove scope placeholders from the crate root.\n - c86c8d41a26b2037e80c9fd028a59313a78b3a66: Perform node id assignment and `macros_at_scope` construction during the `InvocationCollector` and `PlaceholderExpander` folds.\n - 72a636975fc5d0bb4af45af7bdd97987cc722a6a: Move macro resolution into `librustc_resolve`.\n - 20b43b23230ce063ccf99a4841d85790ad311bdf: Rewrite the unit tests in `ext/expand.rs` as a `compile-fail` test.\n - a9821e1658240bb2c056f260a4b6bc9789301fae: Refactor `ExtCtxt` to use a `Resolver` instead of a `MacroLoader`.\n - 60440b226d2f70bdae803443ff7ad2e2af2c9b10: Refactor `noop_fold_stmt_kind` out of `noop_fold_stmt`.\n - 50f94f6c95c944f08c4af264f48260e42efefd47: Avoid needless reexpansions.\n\nr? @nrc", "tree": {"sha": "e8465e843482f5df185590273c99a0994806366a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8465e843482f5df185590273c99a0994806366a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bab9238a1ebc26143edb8a0884de5e82463cd459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bab9238a1ebc26143edb8a0884de5e82463cd459", "html_url": "https://github.com/rust-lang/rust/commit/bab9238a1ebc26143edb8a0884de5e82463cd459", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bab9238a1ebc26143edb8a0884de5e82463cd459/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23e0c24cad4468327e6497750b9525289a4ba7d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/23e0c24cad4468327e6497750b9525289a4ba7d7", "html_url": "https://github.com/rust-lang/rust/commit/23e0c24cad4468327e6497750b9525289a4ba7d7"}, {"sha": "b54e1e399741579612f13e2df98a25ea9447989d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b54e1e399741579612f13e2df98a25ea9447989d", "html_url": "https://github.com/rust-lang/rust/commit/b54e1e399741579612f13e2df98a25ea9447989d"}], "stats": {"total": 1418, "additions": 696, "deletions": 722}, "files": [{"sha": "b2c293a290ab39238ee8dd7af21480b6d0eb9c16", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -39,6 +39,7 @@ use std::rc::Rc;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::base::LoadedMacro;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n@@ -492,6 +493,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n+pub trait MacroLoader {\n+     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+}\n \n /// Metadata encoding and decoding can make use of thread-local encoding and\n /// decoding contexts. These allow implementers of serialize::Encodable and"}, {"sha": "49686d63ee43b8d288275d48770cae3429d50467", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -21,7 +21,7 @@ use util::nodemap::{NodeMap, FnvHashMap};\n use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n-use syntax::ast::{NodeId, Name};\n+use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder};\n use errors::emitter::{Emitter, EmitterWriter};\n use syntax::json::JsonEmitter;\n@@ -39,7 +39,7 @@ use llvm;\n \n use std::path::{Path, PathBuf};\n use std::cell::{self, Cell, RefCell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::env;\n use std::ffi::CString;\n use std::rc::Rc;\n@@ -96,10 +96,6 @@ pub struct Session {\n     pub injected_allocator: Cell<Option<ast::CrateNum>>,\n     pub injected_panic_runtime: Cell<Option<ast::CrateNum>>,\n \n-    /// Names of all bang-style macros and syntax extensions\n-    /// available in this crate\n-    pub available_macros: RefCell<HashSet<Name>>,\n-\n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n     /// macro name and defintion span in the source crate.\n@@ -552,7 +548,6 @@ pub fn build_session_(sopts: config::Options,\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n         injected_panic_runtime: Cell::new(None),\n-        available_macros: RefCell::new(HashSet::new()),\n         imported_macro_spans: RefCell::new(HashMap::new()),\n         incr_comp_session: RefCell::new(IncrCompSession::NotInitialized),\n         perf_stats: PerfStats {"}, {"sha": "36e9fccdf5fd8d3783cb64792a0ec29644e1d97f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -50,6 +50,7 @@ use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n+use syntax::ext::base::ExtCtxt;\n use syntax::parse::{self, PResult, token};\n use syntax::util::node_count::NodeCounter;\n use syntax;\n@@ -638,6 +639,13 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     }\n     sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess))?;\n \n+    let mut macro_loader =\n+        macro_import::MacroLoader::new(sess, &cstore, crate_name, krate.config.clone());\n+\n+    let resolver_arenas = Resolver::arenas();\n+    let mut resolver = Resolver::new(sess, make_glob_map, &mut macro_loader, &resolver_arenas);\n+    syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n+\n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n@@ -672,25 +680,17 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n         };\n-        let mut loader = macro_import::MacroLoader::new(sess,\n-                                                        &cstore,\n-                                                        crate_name,\n-                                                        krate.config.clone());\n-        let mut ecx = syntax::ext::base::ExtCtxt::new(&sess.parse_sess,\n-                                                      krate.config.clone(),\n-                                                      cfg,\n-                                                      &mut loader);\n-        syntax_ext::register_builtins(&mut ecx.syntax_env);\n+        let mut ecx = ExtCtxt::new(&sess.parse_sess, krate.config.clone(), cfg, &mut resolver);\n         let ret = syntax::ext::expand::expand_crate(&mut ecx, syntax_exts, krate);\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n-        *sess.available_macros.borrow_mut() = ecx.syntax_env.names;\n         ret\n     });\n \n     krate = time(time_passes, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess,\n+                                         &mut resolver,\n                                          sess.opts.test,\n                                          krate,\n                                          sess.diagnostic())\n@@ -701,18 +701,14 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         let is_rustc_macro_crate = crate_types.contains(&config::CrateTypeRustcMacro);\n         let num_crate_types = crate_types.len();\n         syntax_ext::rustc_macro_registrar::modify(&sess.parse_sess,\n+                                                  &mut resolver,\n                                                   krate,\n                                                   is_rustc_macro_crate,\n                                                   num_crate_types,\n                                                   sess.diagnostic(),\n                                                   &sess.features.borrow())\n     });\n \n-    let resolver_arenas = Resolver::arenas();\n-    let mut resolver = Resolver::new(sess, make_glob_map, &resolver_arenas);\n-\n-    let krate = time(sess.time_passes(), \"assigning node ids\", || resolver.assign_node_ids(krate));\n-\n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }"}, {"sha": "e41f076d64a80bea5abc8e227509d937d3fe05b1", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -18,6 +18,7 @@ use creader::{CrateReader, Macros};\n use cstore::CStore;\n \n use rustc::hir::def_id::DefIndex;\n+use rustc::middle;\n use rustc::session::Session;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_back::dynamic_lib::DynamicLibrary;\n@@ -26,7 +27,6 @@ use rustc_macro::__internal::Registry;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::LoadedMacro;\n-use syntax::ext;\n use syntax::parse::token;\n use syntax_ext::deriving::custom::CustomDerive;\n use syntax_pos::Span;\n@@ -55,7 +55,7 @@ pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n \n pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n \n-impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n+impl<'a> middle::cstore::MacroLoader for MacroLoader<'a> {\n     fn load_crate(&mut self,\n                   extern_crate: &ast::Item,\n                   allows_macros: bool) -> Vec<LoadedMacro> {"}, {"sha": "a9e3c6ffe9ed887d028208dab5d64fa7e49d70e3", "filename": "src/librustc_resolve/assign_ids.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/23e0c24cad4468327e6497750b9525289a4ba7d7/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23e0c24cad4468327e6497750b9525289a4ba7d7/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=23e0c24cad4468327e6497750b9525289a4ba7d7", "patch": "@@ -1,92 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use Resolver;\n-use rustc::session::Session;\n-use rustc::util::nodemap::FnvHashMap;\n-use syntax::ast;\n-use syntax::ext::hygiene::Mark;\n-use syntax::fold::{self, Folder};\n-use syntax::ptr::P;\n-use syntax::util::move_map::MoveMap;\n-use syntax::util::small_vector::SmallVector;\n-\n-use std::mem;\n-\n-impl<'a> Resolver<'a> {\n-    pub fn assign_node_ids(&mut self, krate: ast::Crate) -> ast::Crate {\n-        NodeIdAssigner {\n-            sess: self.session,\n-            macros_at_scope: &mut self.macros_at_scope,\n-        }.fold_crate(krate)\n-    }\n-}\n-\n-struct NodeIdAssigner<'a> {\n-    sess: &'a Session,\n-    macros_at_scope: &'a mut FnvHashMap<ast::NodeId, Vec<Mark>>,\n-}\n-\n-impl<'a> Folder for NodeIdAssigner<'a> {\n-    fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n-        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-        self.sess.next_node_id()\n-    }\n-\n-    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n-        block.map(|mut block| {\n-            block.id = self.new_id(block.id);\n-\n-            let stmt = block.stmts.pop();\n-            let mut macros = Vec::new();\n-            block.stmts = block.stmts.move_flat_map(|stmt| {\n-                if let ast::StmtKind::Item(ref item) = stmt.node {\n-                    if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(item.ident.ctxt.data().outer_mark);\n-                        return None;\n-                    }\n-                }\n-\n-                let stmt = self.fold_stmt(stmt).pop().unwrap();\n-                if !macros.is_empty() {\n-                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n-                }\n-                Some(stmt)\n-            });\n-\n-            stmt.and_then(|mut stmt| {\n-                // Avoid wasting a node id on a trailing expression statement,\n-                // which shares a HIR node with the expression itself.\n-                if let ast::StmtKind::Expr(expr) = stmt.node {\n-                    let expr = self.fold_expr(expr);\n-                    stmt.id = expr.id;\n-                    stmt.node = ast::StmtKind::Expr(expr);\n-                    Some(stmt)\n-                } else {\n-                    self.fold_stmt(stmt).pop()\n-                }\n-            }).map(|stmt| {\n-                if !macros.is_empty() {\n-                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n-                }\n-                block.stmts.push(stmt);\n-            });\n-\n-            block\n-        })\n-    }\n-\n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        match item.node {\n-            ast::ItemKind::Mac(..) => SmallVector::zero(),\n-            _ => fold::noop_fold_item(item, self),\n-        }\n-    }\n-}"}, {"sha": "912b39cafff36505c790a3f16a15d664dfd8676c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -45,6 +45,7 @@ use self::ParentLink::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n+use rustc::middle::cstore::MacroLoader;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n@@ -79,10 +80,10 @@ use resolve_imports::{ImportDirective, NameResolution};\n // registered before they are used.\n mod diagnostics;\n \n+mod macros;\n mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n-mod assign_ids;\n \n enum SuggestionType {\n     Macro(String),\n@@ -1068,6 +1069,12 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n+\n+    macro_loader: &'a mut MacroLoader,\n+    macro_names: FnvHashSet<Name>,\n+\n+    // Maps the `Mark` of an expansion to its containing module or block.\n+    expansion_data: Vec<macros::ExpansionData>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1166,7 +1173,10 @@ impl Named for hir::PathSegment {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn new(session: &'a Session, make_glob_map: MakeGlobMap, arenas: &'a ResolverArenas<'a>)\n+    pub fn new(session: &'a Session,\n+               make_glob_map: MakeGlobMap,\n+               macro_loader: &'a mut MacroLoader,\n+               arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n         let graph_root =\n@@ -1227,6 +1237,10 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n             new_import_semantics: session.features.borrow().item_like_imports,\n+\n+            macro_loader: macro_loader,\n+            macro_names: FnvHashSet(),\n+            expansion_data: vec![macros::ExpansionData::default()],\n         }\n     }\n \n@@ -2768,8 +2782,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_best_match(&mut self, name: &str) -> SuggestionType {\n-        if let Some(macro_name) = self.session.available_macros\n-                                  .borrow().iter().find(|n| n.as_str() == name) {\n+        if let Some(macro_name) = self.macro_names.iter().find(|n| n.as_str() == name) {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n "}, {"sha": "67ee4c307d3c33a493182ad1577a907264e2fcd0", "filename": "src/librustc_resolve/macros.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Resolver;\n+use rustc::util::nodemap::FnvHashMap;\n+use std::cell::RefCell;\n+use std::mem;\n+use std::rc::Rc;\n+use syntax::ast::{self, Name};\n+use syntax::errors::DiagnosticBuilder;\n+use syntax::ext::base::{self, LoadedMacro, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{NormalTT, SyntaxExtension};\n+use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n+use syntax::ext::hygiene::Mark;\n+use syntax::parse::token::intern;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::visit::{self, Visitor};\n+\n+#[derive(Clone, Default)]\n+pub struct ExpansionData {\n+    module: Rc<ModuleData>,\n+}\n+\n+// FIXME(jseyfried): merge with `::ModuleS`.\n+#[derive(Default)]\n+struct ModuleData {\n+    parent: Option<Rc<ModuleData>>,\n+    macros: RefCell<FnvHashMap<Name, Rc<SyntaxExtension>>>,\n+    macros_escape: bool,\n+}\n+\n+impl<'a> base::Resolver for Resolver<'a> {\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n+        self.macro_loader.load_crate(extern_crate, allows_macros)\n+    }\n+\n+    fn next_node_id(&mut self) -> ast::NodeId {\n+        self.session.next_node_id()\n+    }\n+\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n+        expansion.visit_with(&mut ExpansionVisitor {\n+            current_module: self.expansion_data[mark.as_u32() as usize].module.clone(),\n+            resolver: self,\n+        });\n+    }\n+\n+    fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n+        if let NormalTT(..) = *ext {\n+            self.macro_names.insert(ident.name);\n+        }\n+\n+        let mut module = self.expansion_data[scope.as_u32() as usize].module.clone();\n+        while module.macros_escape {\n+            module = module.parent.clone().unwrap();\n+        }\n+        module.macros.borrow_mut().insert(ident.name, ext);\n+    }\n+\n+    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n+        self.macros_at_scope.insert(id, macros);\n+    }\n+\n+    fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+        for i in 0..attrs.len() {\n+            let name = intern(&attrs[i].name());\n+            match self.expansion_data[0].module.macros.borrow().get(&name) {\n+                Some(ext) => match **ext {\n+                    MultiModifier(..) | MultiDecorator(..) => return Some(attrs.remove(i)),\n+                    _ => {}\n+                },\n+                None => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    fn resolve_invoc(&mut self, invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n+        let (name, span) = match invoc.kind {\n+            InvocationKind::Bang { ref mac, .. } => {\n+                let path = &mac.node.path;\n+                if path.segments.len() > 1 || path.global ||\n+                   !path.segments[0].parameters.is_empty() {\n+                    self.session.span_err(path.span,\n+                                          \"expected macro name without module separators\");\n+                    return None;\n+                }\n+                (path.segments[0].identifier.name, path.span)\n+            }\n+            InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n+        };\n+\n+        let mut module = self.expansion_data[invoc.mark().as_u32() as usize].module.clone();\n+        loop {\n+            if let Some(ext) = module.macros.borrow().get(&name) {\n+                return Some(ext.clone());\n+            }\n+            match module.parent.clone() {\n+                Some(parent) => module = parent,\n+                None => break,\n+            }\n+        }\n+\n+        let mut err =\n+            self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n+        self.suggest_macro_name(&name.as_str(), &mut err);\n+        err.emit();\n+        None\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n+        if let Some(suggestion) = find_best_match_for_name(self.macro_names.iter(), name, None) {\n+            if suggestion != name {\n+                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n+            } else {\n+                err.help(&format!(\"have you added the `#[macro_use]` on the module/import?\"));\n+            }\n+        }\n+    }\n+}\n+\n+struct ExpansionVisitor<'b, 'a: 'b> {\n+    resolver: &'b mut Resolver<'a>,\n+    current_module: Rc<ModuleData>,\n+}\n+\n+impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) {\n+        assert_eq!(id, self.resolver.expansion_data.len() as u32);\n+        self.resolver.expansion_data.push(ExpansionData {\n+            module: self.current_module.clone(),\n+        });\n+    }\n+\n+    // does this attribute list contain \"macro_use\"?\n+    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for attr in attrs {\n+            if attr.check_name(\"macro_escape\") {\n+                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let mut err = self.resolver.session.struct_span_warn(attr.span, msg);\n+                if let ast::AttrStyle::Inner = attr.node.style {\n+                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n+                } else {\n+                    err.emit();\n+                }\n+            } else if !attr.check_name(\"macro_use\") {\n+                continue;\n+            }\n+\n+            if !attr.is_word() {\n+                self.resolver.session.span_err(attr.span,\n+                                               \"arguments to macro_use are not allowed here\");\n+            }\n+            return true;\n+        }\n+\n+        false\n+    }\n+}\n+\n+macro_rules! method {\n+    ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n+        fn $visit(&mut self, node: &$ty) {\n+            match node.node {\n+                $invoc(..) => self.visit_invoc(node.id),\n+                _ => visit::$walk(self, node),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> Visitor for ExpansionVisitor<'a, 'b>  {\n+    method!(visit_trait_item: ast::TraitItem, ast::TraitItemKind::Macro, walk_trait_item);\n+    method!(visit_impl_item:  ast::ImplItem,  ast::ImplItemKind::Macro,  walk_impl_item);\n+    method!(visit_stmt:       ast::Stmt,      ast::StmtKind::Mac,        walk_stmt);\n+    method!(visit_expr:       ast::Expr,      ast::ExprKind::Mac,        walk_expr);\n+    method!(visit_pat:        ast::Pat,       ast::PatKind::Mac,         walk_pat);\n+    method!(visit_ty:         ast::Ty,        ast::TyKind::Mac,          walk_ty);\n+\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => {} // Scope placeholder\n+            ast::ItemKind::Mac(..) => self.visit_invoc(item.id),\n+            ast::ItemKind::Mod(..) => {\n+                let module_data = ModuleData {\n+                    parent: Some(self.current_module.clone()),\n+                    macros: RefCell::new(FnvHashMap()),\n+                    macros_escape: self.contains_macro_use(&item.attrs),\n+                };\n+                let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n+                visit::walk_item(self, item);\n+                self.current_module = orig_module;\n+            }\n+            _ => visit::walk_item(self, item),\n+        }\n+    }\n+\n+    fn visit_block(&mut self, block: &ast::Block) {\n+        let module_data = ModuleData {\n+            parent: Some(self.current_module.clone()),\n+            macros: RefCell::new(FnvHashMap()),\n+            macros_escape: false,\n+        };\n+        let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n+        visit::walk_block(self, block);\n+        self.current_module = orig_module;\n+    }\n+}"}, {"sha": "fb4816d3847ed772a60ea54553d3f8826a194d44", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 87, "deletions": 249, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -10,27 +10,25 @@\n \n pub use self::SyntaxExtension::*;\n \n-use ast;\n-use ast::{Name, PatKind};\n+use ast::{self, Attribute, Name, PatKind};\n use attr::HasAttrs;\n-use codemap::{self, CodeMap, ExpnInfo};\n+use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n-use ext;\n-use ext::expand;\n+use ext::expand::{self, Invocation, Expansion};\n+use ext::hygiene::Mark;\n use ext::tt::macro_rules;\n use parse;\n use parse::parser;\n use parse::token;\n-use parse::token::{InternedString, intern, str_to_ident};\n+use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n use std_inject;\n use util::small_vector::SmallVector;\n-use util::lev_distance::find_best_match_for_name;\n use fold::Folder;\n use feature_gate;\n \n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n use tokenstream;\n@@ -44,15 +42,15 @@ pub enum Annotatable {\n }\n \n impl HasAttrs for Annotatable {\n-    fn attrs(&self) -> &[ast::Attribute] {\n+    fn attrs(&self) -> &[Attribute] {\n         match *self {\n             Annotatable::Item(ref item) => &item.attrs,\n             Annotatable::TraitItem(ref trait_item) => &trait_item.attrs,\n             Annotatable::ImplItem(ref impl_item) => &impl_item.attrs,\n         }\n     }\n \n-    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self {\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         match self {\n             Annotatable::Item(item) => Annotatable::Item(item.map_attrs(f)),\n             Annotatable::TraitItem(trait_item) => Annotatable::TraitItem(trait_item.map_attrs(f)),\n@@ -464,103 +462,52 @@ pub enum SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n-/// The base map of methods for expanding syntax extension\n-/// AST nodes into full ASTs\n-fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n-                                        -> SyntaxEnv {\n-    // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n-        NormalTT(Box::new(f), None, false)\n-    }\n-\n-    let mut syntax_expanders = SyntaxEnv::new();\n-    syntax_expanders.insert(intern(\"macro_rules\"), MacroRulesTT);\n-\n-    if ecfg.enable_quotes() {\n-        // Quasi-quoting expanders\n-        syntax_expanders.insert(intern(\"quote_tokens\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_tokens));\n-        syntax_expanders.insert(intern(\"quote_expr\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_expr));\n-        syntax_expanders.insert(intern(\"quote_ty\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_ty));\n-        syntax_expanders.insert(intern(\"quote_item\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_item));\n-        syntax_expanders.insert(intern(\"quote_pat\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_pat));\n-        syntax_expanders.insert(intern(\"quote_arm\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_arm));\n-        syntax_expanders.insert(intern(\"quote_stmt\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_stmt));\n-        syntax_expanders.insert(intern(\"quote_matcher\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_matcher));\n-        syntax_expanders.insert(intern(\"quote_attr\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_attr));\n-        syntax_expanders.insert(intern(\"quote_arg\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_arg));\n-        syntax_expanders.insert(intern(\"quote_block\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_block));\n-        syntax_expanders.insert(intern(\"quote_meta_item\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_meta_item));\n-        syntax_expanders.insert(intern(\"quote_path\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_path));\n-    }\n-\n-    syntax_expanders.insert(intern(\"line\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_line));\n-    syntax_expanders.insert(intern(\"column\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_column));\n-    syntax_expanders.insert(intern(\"file\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_file));\n-    syntax_expanders.insert(intern(\"stringify\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_stringify));\n-    syntax_expanders.insert(intern(\"include\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include));\n-    syntax_expanders.insert(intern(\"include_str\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include_str));\n-    syntax_expanders.insert(intern(\"include_bytes\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include_bytes));\n-    syntax_expanders.insert(intern(\"module_path\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_mod));\n-    syntax_expanders\n-}\n-\n-pub trait MacroLoader {\n-    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool)\n-                  -> Vec<LoadedMacro>;\n+pub trait Resolver {\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+    fn next_node_id(&mut self) -> ast::NodeId;\n+\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n+    fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n+    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n+\n+    fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n+    fn resolve_invoc(&mut self, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n }\n \n pub enum LoadedMacro {\n     Def(ast::MacroDef),\n     CustomDerive(String, Box<MultiItemModifier>),\n }\n \n-pub struct DummyMacroLoader;\n-impl MacroLoader for DummyMacroLoader {\n-    fn load_crate(&mut self, _: &ast::Item, _: bool) -> Vec<LoadedMacro> {\n+pub struct DummyResolver;\n+\n+impl Resolver for DummyResolver {\n+    fn load_crate(&mut self, _extern_crate: &ast::Item, _allows_macros: bool) -> Vec<LoadedMacro> {\n         Vec::new()\n     }\n+    fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n+\n+    fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n+    fn add_macro(&mut self, _scope: Mark, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n+    fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n+\n+    fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn resolve_invoc(&mut self, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> { None }\n+}\n+\n+#[derive(Clone)]\n+pub struct ModuleData {\n+    pub mod_path: Vec<ast::Ident>,\n+    pub directory: PathBuf,\n+}\n+\n+#[derive(Clone)]\n+pub struct ExpansionData {\n+    pub mark: Mark,\n+    pub depth: usize,\n+    pub backtrace: ExpnId,\n+    pub module: Rc<ModuleData>,\n+    pub in_block: bool,\n }\n \n /// One of these is made during expansion and incrementally updated as we go;\n@@ -569,63 +516,68 @@ impl MacroLoader for DummyMacroLoader {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n-    pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n-    pub loader: &'a mut MacroLoader,\n-\n+    pub resolver: &'a mut Resolver,\n     pub exported_macros: Vec<ast::MacroDef>,\n-\n-    pub syntax_env: SyntaxEnv,\n     pub derive_modes: HashMap<InternedString, Box<MultiItemModifier>>,\n-    pub recursion_count: usize,\n+    pub current_expansion: ExpansionData,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                ecfg: expand::ExpansionConfig<'a>,\n-               loader: &'a mut MacroLoader)\n+               resolver: &'a mut Resolver)\n                -> ExtCtxt<'a> {\n         ExtCtxt {\n-            syntax_env: initial_syntax_expander_table(&ecfg),\n             parse_sess: parse_sess,\n             cfg: cfg,\n-            backtrace: NO_EXPANSION,\n             ecfg: ecfg,\n             crate_root: None,\n             exported_macros: Vec::new(),\n-            loader: loader,\n+            resolver: resolver,\n             derive_modes: HashMap::new(),\n-            recursion_count: 0,\n+            current_expansion: ExpansionData {\n+                mark: Mark::root(),\n+                depth: 0,\n+                backtrace: NO_EXPANSION,\n+                module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n+                in_block: false,\n+            },\n         }\n     }\n \n     /// Returns a `Folder` for deeply expanding all macros in an AST node.\n     pub fn expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> {\n-        expand::MacroExpander::new(self, false, false)\n+        expand::MacroExpander::new(self, false)\n+    }\n+\n+    /// Returns a `Folder` that deeply expands all macros and assigns all node ids in an AST node.\n+    /// Once node ids are assigned, the node may not be expanded, removed, or otherwise modified.\n+    pub fn monotonic_expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> {\n+        expand::MacroExpander::new(self, true)\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree])\n         -> parser::Parser<'a> {\n         parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg())\n     }\n-\n     pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n-        self.codemap().with_expn_info(self.backtrace, |ei| match ei {\n+        self.codemap().with_expn_info(self.backtrace(), |ei| match ei {\n             Some(expn_info) => expn_info.call_site,\n             None => self.bug(\"missing top span\")\n         })\n     }\n-    pub fn backtrace(&self) -> ExpnId { self.backtrace }\n+    pub fn backtrace(&self) -> ExpnId { self.current_expansion.backtrace }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Span {\n-        let mut expn_id = self.backtrace;\n+        let mut expn_id = self.backtrace();\n         let mut last_macro = None;\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n@@ -646,15 +598,15 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn bt_push(&mut self, ei: ExpnInfo) {\n-        if self.recursion_count > self.ecfg.recursion_limit {\n+        if self.current_expansion.depth > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n                                     ei.callee.name()));\n         }\n \n         let mut call_site = ei.call_site;\n-        call_site.expn_id = self.backtrace;\n-        self.backtrace = self.codemap().record_expansion(ExpnInfo {\n+        call_site.expn_id = self.backtrace();\n+        self.current_expansion.backtrace = self.codemap().record_expansion(ExpnInfo {\n             call_site: call_site,\n             callee: ei.callee\n         });\n@@ -667,14 +619,11 @@ impl<'a> ExtCtxt<'a> {\n         }\n         if def.use_locally {\n             let ext = macro_rules::compile(self, &def);\n-            self.syntax_env.insert(def.ident.name, ext);\n+            self.resolver.add_macro(self.current_expansion.mark, def.ident, Rc::new(ext));\n         }\n     }\n \n-    pub fn insert_custom_derive(&mut self,\n-                                name: &str,\n-                                ext: Box<MultiItemModifier>,\n-                                sp: Span) {\n+    pub fn insert_custom_derive(&mut self, name: &str, ext: Box<MultiItemModifier>, sp: Span) {\n         if !self.ecfg.enable_rustc_macro() {\n             feature_gate::emit_feature_err(&self.parse_sess.span_diagnostic,\n                                            \"rustc_macro\",\n@@ -685,8 +634,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n         let name = token::intern_and_get_ident(name);\n         if self.derive_modes.insert(name.clone(), ext).is_some() {\n-            self.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\",\n-                                       name));\n+            self.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n         }\n     }\n \n@@ -765,20 +713,6 @@ impl<'a> ExtCtxt<'a> {\n         token::intern(st)\n     }\n \n-    pub fn suggest_macro_name(&mut self,\n-                              name: &str,\n-                              err: &mut DiagnosticBuilder<'a>) {\n-        let names = &self.syntax_env.names;\n-        if let Some(suggestion) = find_best_match_for_name(names.iter(), name, None) {\n-            if suggestion != name {\n-                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n-            } else {\n-                err.help(&format!(\"have you added the `#[macro_use]` on the \\\n-                                   module/import?\"));\n-            }\n-        }\n-    }\n-\n     pub fn initialize(&mut self, user_exts: Vec<NamedSyntaxExtension>, krate: &ast::Crate) {\n         if std_inject::no_core(&krate) {\n             self.crate_root = None;\n@@ -789,42 +723,47 @@ impl<'a> ExtCtxt<'a> {\n         }\n \n         for (name, extension) in user_exts {\n-            self.syntax_env.insert(name, extension);\n+            let ident = ast::Ident::with_empty_ctxt(name);\n+            self.resolver.add_macro(Mark::root(), ident, Rc::new(extension));\n         }\n \n-        self.syntax_env.current_module = Module(0);\n-        let mut paths = ModulePaths {\n+        let mut module = ModuleData {\n             mod_path: vec![token::str_to_ident(&self.ecfg.crate_name)],\n             directory: PathBuf::from(self.parse_sess.codemap().span_to_filename(krate.span)),\n         };\n-        paths.directory.pop();\n-        self.syntax_env.module_data[0].paths = Rc::new(paths);\n+        module.directory.pop();\n+        self.current_expansion.module = Rc::new(module);\n     }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n-pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                      -> Option<(InternedString, ast::StrStyle)> {\n+pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+                              -> Option<Spanned<(InternedString, ast::StrStyle)>> {\n     // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n-        expr.span.expn_id = cx.backtrace;\n+        expr.span.expn_id = cx.backtrace();\n         expr\n     });\n \n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n-            ast::LitKind::Str(ref s, style) => return Some(((*s).clone(), style)),\n+            ast::LitKind::Str(ref s, style) => return Some(respan(expr.span, (s.clone(), style))),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n     }\n     None\n }\n \n+pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+                      -> Option<(InternedString, ast::StrStyle)> {\n+    expr_to_spanned_string(cx, expr, err_msg).map(|s| s.node)\n+}\n+\n /// Non-fatally assert that `tts` is empty. Note that this function\n /// returns even when `tts` is non-empty, macros that *need* to stop\n /// compilation should call\n@@ -851,7 +790,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None\n     }\n-    let ret = cx.expander().fold_expr(panictry!(p.parse_expr()));\n+    let ret = panictry!(p.parse_expr());\n     if p.token != token::Eof {\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n     }\n@@ -879,104 +818,3 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     }\n     Some(es)\n }\n-\n-/// In order to have some notion of scoping for macros,\n-/// we want to implement the notion of a transformation\n-/// environment.\n-///\n-/// This environment maps Names to SyntaxExtensions.\n-pub struct SyntaxEnv {\n-    module_data: Vec<ModuleData>,\n-    pub current_module: Module,\n-\n-    /// All bang-style macro/extension names\n-    /// encountered so far; to be used for diagnostics in resolve\n-    pub names: HashSet<Name>,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub struct Module(u32);\n-\n-struct ModuleData {\n-    parent: Module,\n-    paths: Rc<ModulePaths>,\n-    macros: HashMap<Name, Rc<SyntaxExtension>>,\n-    macros_escape: bool,\n-    in_block: bool,\n-}\n-\n-#[derive(Clone)]\n-pub struct ModulePaths {\n-    pub mod_path: Vec<ast::Ident>,\n-    pub directory: PathBuf,\n-}\n-\n-impl SyntaxEnv {\n-    fn new() -> SyntaxEnv {\n-        let mut env = SyntaxEnv {\n-            current_module: Module(0),\n-            module_data: Vec::new(),\n-            names: HashSet::new(),\n-        };\n-        let paths = Rc::new(ModulePaths { mod_path: Vec::new(), directory: PathBuf::new() });\n-        env.add_module(false, false, paths);\n-        env\n-    }\n-\n-    fn data(&self, module: Module) -> &ModuleData {\n-        &self.module_data[module.0 as usize]\n-    }\n-\n-    pub fn paths(&self) -> Rc<ModulePaths> {\n-        self.data(self.current_module).paths.clone()\n-    }\n-\n-    pub fn in_block(&self) -> bool {\n-        self.data(self.current_module).in_block\n-    }\n-\n-    pub fn add_module(&mut self, macros_escape: bool, in_block: bool, paths: Rc<ModulePaths>)\n-                      -> Module {\n-        let data = ModuleData {\n-            parent: self.current_module,\n-            paths: paths,\n-            macros: HashMap::new(),\n-            macros_escape: macros_escape,\n-            in_block: in_block,\n-        };\n-\n-        self.module_data.push(data);\n-        Module(self.module_data.len() as u32 - 1)\n-    }\n-\n-    pub fn find(&self, name: Name) -> Option<Rc<SyntaxExtension>> {\n-        let mut module = self.current_module;\n-        let mut module_data;\n-        loop {\n-            module_data = self.data(module);\n-            if let Some(ext) = module_data.macros.get(&name) {\n-                return Some(ext.clone());\n-            }\n-            if module == module_data.parent {\n-                return None;\n-            }\n-            module = module_data.parent;\n-        }\n-    }\n-\n-    pub fn insert(&mut self, name: Name, ext: SyntaxExtension) {\n-        if let NormalTT(..) = ext {\n-            self.names.insert(name);\n-        }\n-\n-        let mut module = self.current_module;\n-        while self.data(module).macros_escape {\n-            module = self.data(module).parent;\n-        }\n-        self.module_data[module.0 as usize].macros.insert(name, Rc::new(ext));\n-    }\n-\n-    pub fn is_crate_root(&mut self) -> bool {\n-        self.current_module == Module(0)\n-    }\n-}"}, {"sha": "62e299684b7602929435a15d63f04bb4ee1f87f2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 122, "deletions": 226, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -25,14 +25,16 @@ use parse::token::{intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n+use visit::Visitor;\n \n use std::mem;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n macro_rules! expansions {\n     ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n-            $(.$fold:ident)*  $(lift .$fold_elt:ident)*;)*) => {\n+            $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n+            $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n         #[derive(Copy, Clone)]\n         pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n         pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n@@ -77,6 +79,17 @@ macro_rules! expansions {\n                     }, )*)*\n                 }\n             }\n+\n+            pub fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n+                match *self {\n+                    Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                    Expansion::OptExpr(None) => {}\n+                    $($( Expansion::$kind(ref ast) => visitor.$visit(ast), )*)*\n+                    $($( Expansion::$kind(ref ast) => for ast in ast.as_slice() {\n+                        visitor.$visit_elt(ast);\n+                    }, )*)*\n+                }\n+            }\n         }\n \n         impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n@@ -94,17 +107,17 @@ macro_rules! expansions {\n }\n \n expansions! {\n-    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr;\n-    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat;\n-    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty;\n+    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr, .visit_expr;\n+    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n+    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n     Stmts: SmallVector<ast::Stmt> [SmallVector, ast::Stmt],\n-        \"statement\",  .make_stmts,       lift .fold_stmt;\n+        \"statement\",  .make_stmts,       lift .fold_stmt, lift .visit_stmt;\n     Items: SmallVector<P<ast::Item>> [SmallVector, P<ast::Item>],\n-        \"item\",       .make_items,       lift .fold_item;\n+        \"item\",       .make_items,       lift .fold_item, lift .visit_item;\n     TraitItems: SmallVector<ast::TraitItem> [SmallVector, ast::TraitItem],\n-        \"trait item\", .make_trait_items, lift .fold_trait_item;\n+        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n     ImplItems: SmallVector<ast::ImplItem> [SmallVector, ast::ImplItem],\n-        \"impl item\",  .make_impl_items,  lift .fold_impl_item;\n+        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n }\n \n impl ExpansionKind {\n@@ -127,15 +140,12 @@ impl ExpansionKind {\n }\n \n pub struct Invocation {\n-    kind: InvocationKind,\n+    pub kind: InvocationKind,\n     expansion_kind: ExpansionKind,\n-    mark: Mark,\n-    module: Module,\n-    backtrace: ExpnId,\n-    depth: usize,\n+    expansion_data: ExpansionData,\n }\n \n-enum InvocationKind {\n+pub enum InvocationKind {\n     Bang {\n         attrs: Vec<ast::Attribute>,\n         mac: ast::Mac,\n@@ -148,29 +158,53 @@ enum InvocationKind {\n     },\n }\n \n+impl Invocation {\n+    fn span(&self) -> Span {\n+        match self.kind {\n+            InvocationKind::Bang { span, .. } => span,\n+            InvocationKind::Attr { ref attr, .. } => attr.span,\n+        }\n+    }\n+\n+    pub fn mark(&self) -> Mark {\n+        self.expansion_data.mark\n+    }\n+}\n+\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n     pub single_step: bool,\n     pub keep_macs: bool,\n+    monotonic: bool, // c.f. `cx.monotonic_expander()`\n }\n \n impl<'a, 'b> MacroExpander<'a, 'b> {\n-    pub fn new(cx: &'a mut ExtCtxt<'b>,\n-               single_step: bool,\n-               keep_macs: bool) -> MacroExpander<'a, 'b> {\n+    pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self {\n         MacroExpander {\n             cx: cx,\n-            single_step: single_step,\n-            keep_macs: keep_macs\n+            monotonic: monotonic,\n+            single_step: false,\n+            keep_macs: false,\n         }\n     }\n \n     fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n \n-        let items = Expansion::Items(SmallVector::many(krate.module.items));\n-        krate.module.items = self.expand(items).make_items().into();\n-        krate.exported_macros = self.cx.exported_macros.clone();\n+        let mut krate_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n+            .make_items().pop().unwrap().unwrap();\n+        krate_item.node = ast::ItemKind::Mod(krate.module);\n+        let krate_item = Expansion::Items(SmallVector::one(P(krate_item)));\n+\n+        krate.module = match self.expand(krate_item).make_items().pop().unwrap().unwrap().node {\n+            ast::ItemKind::Mod(module) => module,\n+            _ => unreachable!(),\n+        };\n+        krate.exported_macros = mem::replace(&mut self.cx.exported_macros, Vec::new());\n+\n+        for def in &mut krate.exported_macros {\n+            def.id = self.cx.resolver.next_node_id()\n+        }\n \n         if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n             self.cx.parse_sess.span_diagnostic.abort_if_errors();\n@@ -181,21 +215,23 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     // Fully expand all the invocations in `expansion`.\n     fn expand(&mut self, expansion: Expansion) -> Expansion {\n-        self.cx.recursion_count = 0;\n+        let orig_expansion_data = self.cx.current_expansion.clone();\n+        self.cx.current_expansion.depth = 0;\n+\n         let (expansion, mut invocations) = self.collect_invocations(expansion);\n         invocations.reverse();\n \n         let mut expansions = vec![vec![(0, expansion)]];\n         while let Some(invoc) = invocations.pop() {\n-            let Invocation { mark, module, depth, backtrace, .. } = invoc;\n-            self.cx.syntax_env.current_module = module;\n-            self.cx.recursion_count = depth;\n-            self.cx.backtrace = backtrace;\n+            let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n+            self.cx.current_expansion = invoc.expansion_data.clone();\n \n-            let expansion = self.expand_invoc(invoc);\n+            let expansion = match self.cx.resolver.resolve_invoc(&invoc) {\n+                Some(ext) => self.expand_invoc(invoc, ext),\n+                None => invoc.expansion_kind.dummy(invoc.span()),\n+            };\n \n-            self.cx.syntax_env.current_module = module;\n-            self.cx.recursion_count = depth + 1;\n+            self.cx.current_expansion.depth = depth + 1;\n             let (expansion, new_invocations) = self.collect_invocations(expansion);\n \n             if expansions.len() == depth {\n@@ -207,7 +243,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n         }\n \n-        let mut placeholder_expander = PlaceholderExpander::new();\n+        self.cx.current_expansion = orig_expansion_data;\n+\n+        let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n                 let expansion = expansion.fold_with(&mut placeholder_expander);\n@@ -230,33 +268,31 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 },\n                 cx: self.cx,\n                 invocations: Vec::new(),\n+                monotonic: self.monotonic,\n             };\n             (expansion.fold_with(&mut collector), collector.invocations)\n         };\n-\n         self.cx.cfg = crate_config;\n+\n+        let mark = self.cx.current_expansion.mark;\n+        self.cx.resolver.visit_expansion(mark, &result.0);\n         result\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation) -> Expansion {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         match invoc.kind {\n-            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc),\n-            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc),\n+            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n+            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n         }\n     }\n \n-    fn expand_attr_invoc(&mut self, invoc: Invocation) -> Expansion {\n+    fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (attr, item) = match invoc.kind {\n             InvocationKind::Attr { attr, item } => (attr, item),\n             _ => unreachable!(),\n         };\n \n-        let extension = match self.cx.syntax_env.find(intern(&attr.name())) {\n-            Some(extension) => extension,\n-            None => unreachable!(),\n-        };\n-\n         attr::mark_used(&attr);\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n@@ -267,7 +303,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n         });\n \n-        match *extension {\n+        match *ext {\n             MultiModifier(ref mac) => {\n                 let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n                 kind.expect_from_annotatables(item)\n@@ -284,8 +320,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     /// Expand a macro invocation. Returns the result of expansion.\n-    fn expand_bang_invoc(&mut self, invoc: Invocation) -> Expansion {\n-        let Invocation { mark, expansion_kind: kind, .. } = invoc;\n+    fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+        let (mark, kind) = (invoc.mark(), invoc.expansion_kind);\n         let (attrs, mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n             _ => unreachable!(),\n@@ -306,19 +342,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         let extname = path.segments[0].identifier.name;\n-        let extension = if let Some(extension) = self.cx.syntax_env.find(extname) {\n-            extension\n-        } else {\n-            let mut err =\n-                self.cx.struct_span_err(path.span, &format!(\"macro undefined: '{}!'\", &extname));\n-            self.cx.suggest_macro_name(&extname.as_str(), &mut err);\n-            err.emit();\n-            return kind.dummy(span);\n-        };\n-\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts = mark_tts(&tts, mark);\n-        let opt_expanded = match *extension {\n+        let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n@@ -425,6 +451,7 @@ struct InvocationCollector<'a, 'b: 'a> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n     invocations: Vec<Invocation>,\n+    monotonic: bool,\n }\n \n macro_rules! fully_configure {\n@@ -442,10 +469,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.invocations.push(Invocation {\n             kind: kind,\n             expansion_kind: expansion_kind,\n-            mark: mark,\n-            module: self.cx.syntax_env.current_module,\n-            backtrace: self.cx.backtrace,\n-            depth: self.cx.recursion_count,\n+            expansion_data: ExpansionData { mark: mark, ..self.cx.current_expansion.clone() },\n         });\n         placeholder(expansion_kind, mark.as_u32())\n     }\n@@ -462,50 +486,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n-    fn classify_item<T: HasAttrs>(&self, mut item: T) -> (T, Option<ast::Attribute>) {\n+    fn classify_item<T: HasAttrs>(&mut self, mut item: T) -> (T, Option<ast::Attribute>) {\n         let mut attr = None;\n         item = item.map_attrs(|mut attrs| {\n-            for i in 0..attrs.len() {\n-                if let Some(extension) = self.cx.syntax_env.find(intern(&attrs[i].name())) {\n-                    match *extension {\n-                        MultiModifier(..) | MultiDecorator(..) => {\n-                            attr = Some(attrs.remove(i));\n-                            break;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n+            attr = self.cx.resolver.find_attr_invoc(&mut attrs);\n             attrs\n         });\n         (item, attr)\n     }\n \n-    // does this attribute list contain \"macro_use\" ?\n-    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n-        for attr in attrs {\n-            let mut is_use = attr.check_name(\"macro_use\");\n-            if attr.check_name(\"macro_escape\") {\n-                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n-                let mut err = self.cx.struct_span_warn(attr.span, msg);\n-                is_use = true;\n-                if let ast::AttrStyle::Inner = attr.node.style {\n-                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n-                } else {\n-                    err.emit();\n-                }\n-            };\n-\n-            if is_use {\n-                if !attr.is_word() {\n-                    self.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n-                }\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n@@ -554,9 +543,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             None => return SmallVector::zero(),\n         };\n \n-        let (mac, style, attrs) = match stmt.node {\n-            StmtKind::Mac(mac) => mac.unwrap(),\n-            _ => return noop_fold_stmt(stmt, self),\n+        let (mac, style, attrs) = if let StmtKind::Mac(mac) = stmt.node {\n+            mac.unwrap()\n+        } else {\n+            // The placeholder expander gives ids to statements, so we avoid folding the id here.\n+            let ast::Stmt { id, node, span } = stmt;\n+            return noop_fold_stmt_kind(node, self).into_iter().map(|node| {\n+                ast::Stmt { id: id, node: node, span: span }\n+            }).collect()\n         };\n \n         let mut placeholder =\n@@ -574,11 +568,9 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let paths = self.cx.syntax_env.paths();\n-        let module = self.cx.syntax_env.add_module(false, true, paths);\n-        let orig_module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n+        let orig_in_block = mem::replace(&mut self.cx.current_expansion.in_block, true);\n         let result = noop_fold_block(block, self);\n-        self.cx.syntax_env.current_module = orig_module;\n+        self.cx.current_expansion.in_block = orig_in_block;\n         result\n     }\n \n@@ -613,46 +605,48 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n-                let mut paths = (*self.cx.syntax_env.paths()).clone();\n-                paths.mod_path.push(item.ident);\n+                if item.ident == keywords::Invalid.ident() {\n+                    return noop_fold_item(item, self);\n+                }\n+\n+                let mut module = (*self.cx.current_expansion.module).clone();\n+                module.mod_path.push(item.ident);\n \n                 // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n                 // In the non-inline case, `inner` is never the dummy span (c.f. `parse_item_mod`).\n                 // Thus, if `inner` is the dummy span, we know the module is inline.\n                 let inline_module = item.span.contains(inner) || inner == syntax_pos::DUMMY_SP;\n \n                 if inline_module {\n-                    paths.directory.push(&*{\n+                    module.directory.push(&*{\n                         ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n                             .unwrap_or(item.ident.name.as_str())\n                     });\n                 } else {\n-                    paths.directory =\n+                    module.directory =\n                         PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner));\n-                    paths.directory.pop();\n+                    module.directory.pop();\n                 }\n \n-                let macro_use = self.contains_macro_use(&item.attrs);\n-                let in_block = self.cx.syntax_env.in_block();\n-                let module = self.cx.syntax_env.add_module(macro_use, in_block, Rc::new(paths));\n-                let module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n+                let orig_module =\n+                    mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let result = noop_fold_item(item, self);\n-                self.cx.syntax_env.current_module = module;\n-                result\n-            },\n+                self.cx.current_expansion.module = orig_module;\n+                return result;\n+            }\n             ast::ItemKind::ExternCrate(..) => {\n                 // We need to error on `#[macro_use] extern crate` when it isn't at the\n                 // crate root, because `$crate` won't work properly.\n-                let is_crate_root = self.cx.syntax_env.is_crate_root();\n-                for def in self.cx.loader.load_crate(&*item, is_crate_root) {\n+                let is_crate_root = self.cx.current_expansion.module.mod_path.len() == 1;\n+                for def in self.cx.resolver.load_crate(&*item, is_crate_root) {\n                     match def {\n                         LoadedMacro::Def(def) => self.cx.insert_macro(def),\n                         LoadedMacro::CustomDerive(name, ext) => {\n                             self.cx.insert_custom_derive(&name, ext, item.span);\n                         }\n                     }\n                 }\n-                SmallVector::one(item)\n+                noop_fold_item(item, self)\n             },\n             _ => noop_fold_item(item, self),\n         }\n@@ -715,6 +709,15 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n         noop_fold_item_kind(self.cfg.configure_item_kind(item), self)\n     }\n+\n+    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n+        if self.monotonic {\n+            assert_eq!(id, ast::DUMMY_NODE_ID);\n+            self.cx.resolver.next_node_id()\n+        } else {\n+            id\n+        }\n+    }\n }\n \n pub struct ExpansionConfig<'feat> {\n@@ -766,7 +769,7 @@ pub fn expand_crate(cx: &mut ExtCtxt,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     cx.initialize(user_exts, &c);\n-    cx.expander().expand_crate(c)\n+    cx.monotonic_expander().expand_crate(c)\n }\n \n // Expands crate using supplied MacroExpander - allows for\n@@ -803,110 +806,3 @@ impl Folder for Marker {\n fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{expand_crate, ExpansionConfig};\n-    use ast;\n-    use ext::base::{ExtCtxt, DummyMacroLoader};\n-    use parse;\n-    use util::parser_testing::{string_to_parser};\n-    use visit;\n-    use visit::Visitor;\n-\n-    // a visitor that extracts the paths\n-    // from a given thingy and puts them in a mutable\n-    // array (passed in to the traversal)\n-    #[derive(Clone)]\n-    struct PathExprFinderContext {\n-        path_accumulator: Vec<ast::Path> ,\n-    }\n-\n-    impl Visitor for PathExprFinderContext {\n-        fn visit_expr(&mut self, expr: &ast::Expr) {\n-            if let ast::ExprKind::Path(None, ref p) = expr.node {\n-                self.path_accumulator.push(p.clone());\n-            }\n-            visit::walk_expr(self, expr);\n-        }\n-    }\n-\n-    // these following tests are quite fragile, in that they don't test what\n-    // *kind* of failure occurs.\n-\n-    fn test_ecfg() -> ExpansionConfig<'static> {\n-        ExpansionConfig::default(\"test\".to_string())\n-    }\n-\n-    // make sure that macros can't escape fns\n-    #[should_panic]\n-    #[test] fn macros_cant_escape_fns_test () {\n-        let src = \"fn bogus() {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> i32 { z!() }\".to_string();\n-        let sess = parse::ParseSess::new();\n-        let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_string(),\n-            src,\n-            Vec::new(), &sess).unwrap();\n-        // should fail:\n-        let mut loader = DummyMacroLoader;\n-        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(&mut ecx, vec![], crate_ast);\n-    }\n-\n-    // make sure that macros can't escape modules\n-    #[should_panic]\n-    #[test] fn macros_cant_escape_mods_test () {\n-        let src = \"mod foo {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> i32 { z!() }\".to_string();\n-        let sess = parse::ParseSess::new();\n-        let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_string(),\n-            src,\n-            Vec::new(), &sess).unwrap();\n-        let mut loader = DummyMacroLoader;\n-        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(&mut ecx, vec![], crate_ast);\n-    }\n-\n-    // macro_use modules should allow macros to escape\n-    #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = \"#[macro_use] mod foo {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> i32 { z!() }\".to_string();\n-        let sess = parse::ParseSess::new();\n-        let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_string(),\n-            src,\n-            Vec::new(), &sess).unwrap();\n-        let mut loader = DummyMacroLoader;\n-        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(&mut ecx, vec![], crate_ast);\n-    }\n-\n-    fn expand_crate_str(crate_str: String) -> ast::Crate {\n-        let ps = parse::ParseSess::new();\n-        let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n-        // the cfg argument actually does matter, here...\n-        let mut loader = DummyMacroLoader;\n-        let mut ecx = ExtCtxt::new(&ps, vec![], test_ecfg(), &mut loader);\n-        expand_crate(&mut ecx, vec![], crate_ast)\n-    }\n-\n-    #[test] fn macro_tokens_should_match(){\n-        expand_crate_str(\n-            \"macro_rules! m((a)=>(13)) ;fn main(){m!(a);}\".to_string());\n-    }\n-\n-    // should be able to use a bound identifier as a literal in a macro definition:\n-    #[test] fn self_macro_parsing(){\n-        expand_crate_str(\n-            \"macro_rules! foo ((zz) => (287;));\n-            fn f(zz: i32) {foo!(zz);}\".to_string()\n-            );\n-    }\n-\n-    // create a really evil test case where a $x appears inside a binding of $x\n-    // but *shouldn't* bind because it was inserted by a different macro....\n-    // can't write this test case until we have macro-generating macros.\n-}"}, {"sha": "34126fac4ac784c888a282a0e947ba8685998400", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -29,7 +29,7 @@ pub struct SyntaxContextData {\n     pub prev_ctxt: SyntaxContext,\n }\n \n-/// A mark represents a unique id associated with a macro expansion.\n+/// A mark is a unique id associated with a macro expansion.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default)]\n pub struct Mark(u32);\n \n@@ -41,6 +41,11 @@ impl Mark {\n         })\n     }\n \n+    /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    pub fn root() -> Self {\n+        Mark(0)\n+    }\n+\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n@@ -56,8 +61,8 @@ impl HygieneData {\n     fn new() -> Self {\n         HygieneData {\n             syntax_contexts: vec![SyntaxContextData {\n-                outer_mark: Mark(0), // the null mark\n-                prev_ctxt: SyntaxContext(0), // the empty context\n+                outer_mark: Mark::root(),\n+                prev_ctxt: SyntaxContext::empty(),\n             }],\n             markings: HashMap::new(),\n             next_mark: Mark(1),"}, {"sha": "47f366a88768ecc45565ef0ed2cab495da1c13a1", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 61, "deletions": 4, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -10,13 +10,16 @@\n \n use ast;\n use codemap::{DUMMY_SP, dummy_spanned};\n+use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n use fold::*;\n use parse::token::keywords;\n use ptr::P;\n+use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n+use std::mem;\n \n pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     fn mac_placeholder() -> ast::Mac {\n@@ -69,14 +72,18 @@ pub fn macro_scope_placeholder() -> Expansion {\n     placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n }\n \n-pub struct PlaceholderExpander {\n+pub struct PlaceholderExpander<'a, 'b: 'a> {\n     expansions: HashMap<ast::NodeId, Expansion>,\n+    cx: &'a mut ExtCtxt<'b>,\n+    monotonic: bool,\n }\n \n-impl PlaceholderExpander {\n-    pub fn new() -> Self {\n+impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n+    pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self {\n         PlaceholderExpander {\n+            cx: cx,\n             expansions: HashMap::new(),\n+            monotonic: monotonic,\n         }\n     }\n \n@@ -89,7 +96,7 @@ impl PlaceholderExpander {\n     }\n }\n \n-impl Folder for PlaceholderExpander {\n+impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         match item.node {\n             // Scope placeholder\n@@ -155,6 +162,56 @@ impl Folder for PlaceholderExpander {\n             _ => noop_fold_ty(ty, self),\n         }\n     }\n+\n+    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n+        noop_fold_block(block, self).map(|mut block| {\n+            let mut macros = Vec::new();\n+            let mut remaining_stmts = block.stmts.len();\n+\n+            block.stmts = block.stmts.move_flat_map(|mut stmt| {\n+                remaining_stmts -= 1;\n+\n+                // Scope placeholder\n+                if let ast::StmtKind::Item(ref item) = stmt.node {\n+                    if let ast::ItemKind::Mac(..) = item.node {\n+                        macros.push(item.ident.ctxt.data().outer_mark);\n+                        return None;\n+                    }\n+                }\n+\n+                match stmt.node {\n+                    // Avoid wasting a node id on a trailing expression statement,\n+                    // which shares a HIR node with the expression itself.\n+                    ast::StmtKind::Expr(ref expr) if remaining_stmts == 0 => stmt.id = expr.id,\n+\n+                    _ if self.monotonic => {\n+                        assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                        stmt.id = self.cx.resolver.next_node_id();\n+                    }\n+\n+                    _ => {}\n+                }\n+\n+                if self.monotonic && !macros.is_empty() {\n+                    let macros = mem::replace(&mut macros, Vec::new());\n+                    self.cx.resolver.add_expansions_at_stmt(stmt.id, macros);\n+                }\n+\n+                Some(stmt)\n+            });\n+\n+            block\n+        })\n+    }\n+\n+    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n+        let mut module = noop_fold_mod(module, self);\n+        module.items = module.items.move_flat_map(|item| match item.node {\n+            ast::ItemKind::Mac(_) => None, // remove scope placeholders from modules\n+            _ => Some(item),\n+        });\n+        module\n+    }\n }\n \n pub fn reconstructed_macro_rules(def: &ast::MacroDef, path: &ast::Path) -> Expansion {"}, {"sha": "e75e41d0c2d4bf61238d35b61ebe895d824fac8a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -74,8 +74,8 @@ pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTre\n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    let paths = cx.syntax_env.paths();\n-    let string = paths.mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n+    let mod_path = &cx.current_expansion.module.mod_path;\n+    let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n \n     base::MacEager::expr(cx.expr_str(\n             sp,"}, {"sha": "51ef45b97be6f336aef5e6e510b15d57b62f6887", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -211,8 +211,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            imported_from,\n                                            rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n-                p.directory = cx.syntax_env.paths().directory.clone();\n-                p.restrictions = match cx.syntax_env.in_block() {\n+                p.directory = cx.current_expansion.module.directory.clone();\n+                p.restrictions = match cx.current_expansion.in_block {\n                     true => Restrictions::NO_NONINLINE_MOD,\n                     false => Restrictions::empty(),\n                 };"}, {"sha": "9fb4d0203f41e28b3904b29878b11dfdf0f4b7ba", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 13, "deletions": 37, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -1320,51 +1320,27 @@ pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Exp\n     es.move_flat_map(|e| folder.fold_opt_expr(e))\n }\n \n-pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T)\n-                                 -> SmallVector<Stmt> {\n+pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T) -> SmallVector<Stmt> {\n     let id = folder.new_id(id);\n     let span = folder.new_span(span);\n+    noop_fold_stmt_kind(node, folder).into_iter().map(|node| {\n+        Stmt { id: id, node: node, span: span }\n+    }).collect()\n+}\n \n+pub fn noop_fold_stmt_kind<T: Folder>(node: StmtKind, folder: &mut T) -> SmallVector<StmtKind> {\n     match node {\n-        StmtKind::Local(local) => SmallVector::one(Stmt {\n-            id: id,\n-            node: StmtKind::Local(folder.fold_local(local)),\n-            span: span,\n-        }),\n-        StmtKind::Item(item) => folder.fold_item(item).into_iter().map(|item| Stmt {\n-            id: id,\n-            node: StmtKind::Item(item),\n-            span: span,\n-        }).collect(),\n+        StmtKind::Local(local) => SmallVector::one(StmtKind::Local(folder.fold_local(local))),\n+        StmtKind::Item(item) => folder.fold_item(item).into_iter().map(StmtKind::Item).collect(),\n         StmtKind::Expr(expr) => {\n-            if let Some(expr) = folder.fold_opt_expr(expr) {\n-                SmallVector::one(Stmt {\n-                    id: id,\n-                    node: StmtKind::Expr(expr),\n-                    span: span,\n-                })\n-            } else {\n-                SmallVector::zero()\n-            }\n+            folder.fold_opt_expr(expr).into_iter().map(StmtKind::Expr).collect()\n         }\n         StmtKind::Semi(expr) => {\n-            if let Some(expr) = folder.fold_opt_expr(expr) {\n-                SmallVector::one(Stmt {\n-                    id: id,\n-                    node: StmtKind::Semi(expr),\n-                    span: span,\n-                })\n-            } else {\n-                SmallVector::zero()\n-            }\n+            folder.fold_opt_expr(expr).into_iter().map(StmtKind::Semi).collect()\n         }\n-        StmtKind::Mac(mac) => SmallVector::one(Stmt {\n-            id: id,\n-            node: StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n-                (folder.fold_mac(mac), semi, fold_attrs(attrs.into(), folder).into())\n-            })),\n-            span: span,\n-        })\n+        StmtKind::Mac(mac) => SmallVector::one(StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n+            (folder.fold_mac(mac), semi, fold_attrs(attrs.into(), folder).into())\n+        }))),\n     }\n }\n "}, {"sha": "6327e8f71bcd5f211dff79f24754a3974ff1e3cd", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -28,7 +28,7 @@ use errors;\n use errors::snippet::{SnippetData};\n use config;\n use entry::{self, EntryPointType};\n-use ext::base::{ExtCtxt, DummyMacroLoader};\n+use ext::base::{ExtCtxt, Resolver};\n use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n use fold::Folder;\n@@ -70,6 +70,7 @@ struct TestCtxt<'a> {\n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n pub fn modify_for_testing(sess: &ParseSess,\n+                          resolver: &mut Resolver,\n                           should_test: bool,\n                           krate: ast::Crate,\n                           span_diagnostic: &errors::Handler) -> ast::Crate {\n@@ -82,7 +83,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n-        generate_test_harness(sess, reexport_test_harness_main, krate, span_diagnostic)\n+        generate_test_harness(sess, resolver, reexport_test_harness_main, krate, span_diagnostic)\n     } else {\n         krate\n     }\n@@ -248,41 +249,39 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n         cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Visibility::Public, r, path)\n-    }));\n+    })).collect();\n \n     let reexport_mod = ast::Mod {\n         inner: DUMMY_SP,\n-        items: items.collect(),\n+        items: items,\n     };\n \n     let sym = token::gensym_ident(\"__test_reexports\");\n-    let it = P(ast::Item {\n+    let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n         ident: sym.clone(),\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n-    });\n+    })).pop().unwrap();\n \n     (it, sym)\n }\n \n fn generate_test_harness(sess: &ParseSess,\n+                         resolver: &mut Resolver,\n                          reexport_test_harness_main: Option<InternedString>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n-    let mut loader = DummyMacroLoader;\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n-        ext_cx: ExtCtxt::new(sess, vec![],\n-                             ExpansionConfig::default(\"test\".to_string()),\n-                             &mut loader),\n+        ext_cx: ExtCtxt::new(sess, vec![], ExpansionConfig::default(\"test\".to_string()), resolver),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main: reexport_test_harness_main,\n@@ -511,16 +510,17 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         items: vec![import, mainfn, tests],\n     };\n     let item_ = ast::ItemKind::Mod(testmod);\n-\n     let mod_ident = token::gensym_ident(\"__test\");\n-    let item = P(ast::Item {\n+\n+    let mut expander = cx.ext_cx.monotonic_expander();\n+    let item = expander.fold_item(P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n         ident: mod_ident,\n         attrs: vec![],\n         node: item_,\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n-    });\n+    })).pop().unwrap();\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n         let reexport_ident = token::str_to_ident(&s);\n@@ -529,14 +529,14 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n             nospan(ast::ViewPathSimple(reexport_ident,\n                                        path_node(vec![mod_ident, token::str_to_ident(\"main\")])));\n \n-        P(ast::Item {\n+        expander.fold_item(P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n             ident: keywords::Invalid.ident(),\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n             vis: ast::Visibility::Inherited,\n             span: DUMMY_SP\n-        })\n+        })).pop().unwrap()\n     });\n \n     debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));"}, {"sha": "6162beb80eccc7d9eb53c92cabd9c8e7b5f9e251", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -11,8 +11,7 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use syntax::ast::{self, MetaItem};\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n-use syntax::ext::base::MultiModifier;\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::codemap;\n@@ -89,7 +88,7 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-fn expand_derive(cx: &mut ExtCtxt,\n+pub fn expand_derive(cx: &mut ExtCtxt,\n                  span: Span,\n                  mitem: &MetaItem,\n                  annotatable: Annotatable)\n@@ -243,10 +242,6 @@ fn expand_derive(cx: &mut ExtCtxt,\n \n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n-        pub fn register_all(env: &mut SyntaxEnv) {\n-            env.insert(intern(\"derive\"), MultiModifier(Box::new(expand_derive)));\n-        }\n-\n         pub fn is_builtin_trait(name: &str) -> bool {\n             match name {\n                 $( $name )|+ => true,"}, {"sha": "892ebcfa76129ee468188419c22db46ebf7b81ec", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -17,7 +17,6 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::fold::Folder;\n use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -702,10 +701,12 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let macsp = ecx.call_site();\n-    // Expand the format literal so that efmt.span will have a backtrace. This\n-    // is essential for locating a bug when the format literal is generated in\n-    // a macro. (e.g. println!(\"{}\"), which uses concat!($fmt, \"\\n\")).\n-    let efmt = ecx.expander().fold_expr(efmt);\n+    let msg = \"format argument must be a string literal.\";\n+    let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n+        Some(fmt) => fmt,\n+        None => return DummyResult::raw_expr(sp),\n+    };\n+\n     let mut cx = Context {\n         ecx: ecx,\n         args: args,\n@@ -723,14 +724,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         str_pieces: Vec::new(),\n         all_pieces_simple: true,\n         macsp: macsp,\n-        fmtsp: efmt.span,\n-    };\n-    let fmt = match expr_to_string(cx.ecx, efmt, \"format argument must be a string literal.\") {\n-        Some((fmt, _)) => fmt,\n-        None => return DummyResult::raw_expr(sp),\n+        fmtsp: fmt.span,\n     };\n \n-    let mut parser = parse::Parser::new(&fmt);\n+    let mut parser = parse::Parser::new(&fmt.node.0);\n     let mut pieces = vec![];\n \n     loop {"}, {"sha": "3a6212e5445ce6d687940e3e36a1ea37369d0be6", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 61, "deletions": 27, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -34,11 +34,6 @@ extern crate syntax_pos;\n extern crate rustc_macro;\n extern crate rustc_errors as errors;\n \n-use syntax::ext::base::{MacroExpanderFn, NormalTT};\n-use syntax::ext::base::{SyntaxEnv, SyntaxExtension};\n-use syntax::parse::token::intern;\n-\n-\n mod asm;\n mod cfg;\n mod concat;\n@@ -53,28 +48,67 @@ pub mod rustc_macro_registrar;\n // for custom_derive\n pub mod deriving;\n \n-pub fn register_builtins(env: &mut SyntaxEnv) {\n-    // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n-        NormalTT(Box::new(f), None, false)\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::ext::base::{MacroExpanderFn, MacroRulesTT, NormalTT, MultiModifier};\n+use syntax::ext::hygiene::Mark;\n+use syntax::parse::token::intern;\n+\n+pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quotes: bool) {\n+    let mut register = |name, ext| {\n+        resolver.add_macro(Mark::root(), ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n+    };\n+\n+    register(\"macro_rules\", MacroRulesTT);\n+\n+    macro_rules! register {\n+        ($( $name:ident: $f:expr, )*) => { $(\n+            register(stringify!($name), NormalTT(Box::new($f as MacroExpanderFn), None, false));\n+        )* }\n     }\n \n-    env.insert(intern(\"asm\"), builtin_normal_expander(asm::expand_asm));\n-    env.insert(intern(\"cfg\"), builtin_normal_expander(cfg::expand_cfg));\n-    env.insert(intern(\"concat\"),\n-               builtin_normal_expander(concat::expand_syntax_ext));\n-    env.insert(intern(\"concat_idents\"),\n-               builtin_normal_expander(concat_idents::expand_syntax_ext));\n-    env.insert(intern(\"env\"), builtin_normal_expander(env::expand_env));\n-    env.insert(intern(\"option_env\"),\n-               builtin_normal_expander(env::expand_option_env));\n-    env.insert(intern(\"format_args\"),\n-               // format_args uses `unstable` things internally.\n-               NormalTT(Box::new(format::expand_format_args), None, true));\n-    env.insert(intern(\"log_syntax\"),\n-               builtin_normal_expander(log_syntax::expand_syntax_ext));\n-    env.insert(intern(\"trace_macros\"),\n-               builtin_normal_expander(trace_macros::expand_trace_macros));\n-\n-    deriving::register_all(env);\n+    if enable_quotes {\n+        use syntax::ext::quote::*;\n+        register! {\n+            quote_tokens: expand_quote_tokens,\n+            quote_expr: expand_quote_expr,\n+            quote_ty: expand_quote_ty,\n+            quote_item: expand_quote_item,\n+            quote_pat: expand_quote_pat,\n+            quote_arm: expand_quote_arm,\n+            quote_stmt: expand_quote_stmt,\n+            quote_matcher: expand_quote_matcher,\n+            quote_attr: expand_quote_attr,\n+            quote_arg: expand_quote_arg,\n+            quote_block: expand_quote_block,\n+            quote_meta_item: expand_quote_meta_item,\n+            quote_path: expand_quote_path,\n+        }\n+    }\n+\n+    use syntax::ext::source_util::*;\n+    register! {\n+        line: expand_line,\n+        column: expand_column,\n+        file: expand_file,\n+        stringify: expand_stringify,\n+        include: expand_include,\n+        include_str: expand_include_str,\n+        include_bytes: expand_include_bytes,\n+        module_path: expand_mod,\n+\n+        asm: asm::expand_asm,\n+        cfg: cfg::expand_cfg,\n+        concat: concat::expand_syntax_ext,\n+        concat_idents: concat_idents::expand_syntax_ext,\n+        env: env::expand_env,\n+        option_env: env::expand_option_env,\n+        log_syntax: log_syntax::expand_syntax_ext,\n+        trace_macros: trace_macros::expand_trace_macros,\n+    }\n+\n+    // format_args uses `unstable` things internally.\n+    register(\"format_args\", NormalTT(Box::new(format::expand_format_args), None, true));\n+\n+    register(\"derive\", MultiModifier(Box::new(deriving::expand_derive)));\n }"}, {"sha": "ce3e53cdf97f4ec7382da1842b4cc037114b77bd", "filename": "src/libsyntax_ext/rustc_macro_registrar.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -13,12 +13,13 @@ use std::mem;\n use errors;\n use syntax::ast::{self, Ident, NodeId};\n use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n-use syntax::ext::base::{ExtCtxt, DummyMacroLoader};\n+use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::parse::ParseSess;\n use syntax::parse::token::{self, InternedString};\n use syntax::feature_gate::Features;\n+use syntax::fold::Folder;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n@@ -39,16 +40,14 @@ struct CollectCustomDerives<'a> {\n }\n \n pub fn modify(sess: &ParseSess,\n+              resolver: &mut ::syntax::ext::base::Resolver,\n               mut krate: ast::Crate,\n               is_rustc_macro_crate: bool,\n               num_crate_types: usize,\n               handler: &errors::Handler,\n               features: &Features) -> ast::Crate {\n-    let mut loader = DummyMacroLoader;\n-    let mut cx = ExtCtxt::new(sess,\n-                              Vec::new(),\n-                              ExpansionConfig::default(\"rustc_macro\".to_string()),\n-                              &mut loader);\n+    let ecfg = ExpansionConfig::default(\"rustc_macro\".to_string());\n+    let mut cx = ExtCtxt::new(sess, Vec::new(), ecfg, resolver);\n \n     let mut collect = CollectCustomDerives {\n         derives: Vec::new(),\n@@ -268,13 +267,11 @@ fn mk_registrar(cx: &mut ExtCtxt,\n         i.vis = ast::Visibility::Public;\n         i\n     });\n-    let module = cx.item_mod(span,\n-                             span,\n-                             ast::Ident::with_empty_ctxt(token::gensym(\"registrar\")),\n-                             Vec::new(),\n-                             vec![krate, func]);\n-    module.map(|mut i| {\n+    let ident = ast::Ident::with_empty_ctxt(token::gensym(\"registrar\"));\n+    let module = cx.item_mod(span, span, ident, Vec::new(), vec![krate, func]).map(|mut i| {\n         i.vis = ast::Visibility::Public;\n         i\n-    })\n+    });\n+\n+    cx.monotonic_expander().fold_item(module).pop().unwrap()\n }"}, {"sha": "3e5d17e2ffb17a582a96507019964331a7c4e6e3", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -22,11 +22,11 @@ use syntax_pos::DUMMY_SP;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let mut loader = syntax::ext::base::DummyMacroLoader;\n+    let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut loader);\n+        &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "a064e69bc6d59f3f661edc468b3b7ceb91a42e8d", "filename": "src/test/compile-fail/macro-expansion-tests.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod macros_cant_escape_fns {\n+    fn f() {\n+        macro_rules! m { () => { 3 + 4 } }\n+    }\n+    fn g() -> i32 { m!() } //~ ERROR macro undefined\n+}\n+\n+mod macros_cant_escape_mods {\n+    mod f {\n+        macro_rules! m { () => { 3 + 4 } }\n+    }\n+    fn g() -> i32 { m!() } //~ ERROR macro undefined\n+}\n+\n+mod macros_can_escape_flattened_mods_test {\n+    #[macro_use]\n+    mod f {\n+        macro_rules! m { () => { 3 + 4 } }\n+    }\n+    fn g() -> i32 { m!() }\n+}\n+\n+fn macro_tokens_should_match() {\n+    macro_rules! m { (a) => { 13 } }\n+    m!(a);\n+}\n+\n+// should be able to use a bound identifier as a literal in a macro definition:\n+fn self_macro_parsing() {\n+    macro_rules! foo { (zz) => { 287; } }\n+    fn f(zz: i32) {\n+        foo!(zz);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1458583ff58303a50dba9d82cf12122e54f8ce90", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -25,11 +25,11 @@ use syntax_pos::DUMMY_SP;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let mut loader = syntax::ext::base::DummyMacroLoader;\n+    let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut loader);\n+        &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "2a53a62a5ab60d5757b7da4c0b25f9ddfb2e732e", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab9238a1ebc26143edb8a0884de5e82463cd459/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=bab9238a1ebc26143edb8a0884de5e82463cd459", "patch": "@@ -21,11 +21,11 @@ use syntax_pos::DUMMY_SP;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let mut loader = syntax::ext::base::DummyMacroLoader;\n+    let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut loader);\n+        &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}]}