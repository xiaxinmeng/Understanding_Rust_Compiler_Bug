{"sha": "6fa64eeb20fad30ec327c0cd3931079e30696228", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYTY0ZWViMjBmYWQzMGVjMzI3YzBjZDM5MzEwNzllMzA2OTYyMjg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-07T23:49:51Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-07T23:49:51Z"}, "message": "tutorial: Pointer cleanup", "tree": {"sha": "3d744e24c9c7a19f52585cbca09582e74c64d250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d744e24c9c7a19f52585cbca09582e74c64d250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fa64eeb20fad30ec327c0cd3931079e30696228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa64eeb20fad30ec327c0cd3931079e30696228", "html_url": "https://github.com/rust-lang/rust/commit/6fa64eeb20fad30ec327c0cd3931079e30696228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fa64eeb20fad30ec327c0cd3931079e30696228/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04feb6e1ab50bfe819ecc383e9e8712efa2b93af", "url": "https://api.github.com/repos/rust-lang/rust/commits/04feb6e1ab50bfe819ecc383e9e8712efa2b93af", "html_url": "https://github.com/rust-lang/rust/commit/04feb6e1ab50bfe819ecc383e9e8712efa2b93af"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "5150b57b9cca2be9c0dbde9b330f8f3a00db87de", "filename": "doc/tutorial.md", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6fa64eeb20fad30ec327c0cd3931079e30696228/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/6fa64eeb20fad30ec327c0cd3931079e30696228/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=6fa64eeb20fad30ec327c0cd3931079e30696228", "patch": "@@ -1228,14 +1228,14 @@ and the unique pointer (`~T`). These three sigils will appear\n repeatedly as we explore the language. Learning the appropriate role\n of each is key to using Rust effectively.\n \n-# Pointers\n+# Boxes and pointers\n \n-In contrast to a lot of modern languages, record and enum types in\n-Rust are not represented as pointers to allocated memory. They are,\n-like in C and C++, represented directly. This means that if you `let x\n-= {x: 1f, y: 1f};`, you are creating a record on the stack. If you\n-then copy it into a data structure, the whole record is copied, not\n-just a pointer.\n+In contrast to a lot of modern languages, aggregate types like records\n+and enums are not represented as pointers to allocated memory. They\n+are, like in C and C++, represented directly. This means that if you\n+`let x = {x: 1f, y: 1f};`, you are creating a record on the stack. If\n+you then copy it into a data structure, the whole record is copied,\n+not just a pointer.\n \n For small records like `point`, this is usually more efficient than\n allocating memory and going through a pointer. But for big records, or\n@@ -1260,19 +1260,21 @@ Shared boxes are pointers to heap-allocated, reference counted memory.\n A cycle collector ensures that circular references do not result in\n memory leaks.\n \n+> ***Note:*** We will in the future switch to garbage collection,\n+> rather than reference counting, for shared boxes.\n+\n Creating a shared box is done by simply applying the unary `@`\n operator to an expression. The result of the expression will be boxed,\n-resulting in a box of the right type. For example:\n+resulting in a box of the right type. Copying a shared box, as happens\n+during assignment, only copies a pointer, never the contents of the\n+box.\n \n ~~~~\n-let x = @10; // New box, refcount of 1\n+let x: @int = @10; // New box, refcount of 1\n let y = x; // Copy the pointer, increase refcount\n // When x and y go out of scope, refcount goes to 0, box is freed\n ~~~~\n \n-> ***Note:*** We will in the future switch to garbage collection,\n-> rather than reference counting, for shared boxes.\n-\n Shared boxes never cross task boundaries.\n \n ## Unique boxes\n@@ -1309,6 +1311,11 @@ let x = ~10;\n let y <- x;\n ~~~~\n \n+> ***Note:*** this discussion of copying vs moving does not account\n+> for the \"last use\" rules that automatically promote copy operations\n+> to moves. This is an evolving area of the language that will\n+> continue to change.\n+\n Unique boxes, when they do not contain any shared boxes, can be sent\n to other tasks. The sending task will give up ownership of the box,\n and won't be able to access it afterwards. The receiving task will"}]}