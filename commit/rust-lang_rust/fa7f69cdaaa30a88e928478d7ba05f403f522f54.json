{"sha": "fa7f69cdaaa30a88e928478d7ba05f403f522f54", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhN2Y2OWNkYWFhMzBhODhlOTI4NDc4ZDdiYTA1ZjQwM2Y1MjJmNTQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-10-11T14:03:40Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-10-12T16:24:23Z"}, "message": "tests for `#[may_dangle]` attribute.", "tree": {"sha": "7c4d5be708d2097e1e647b586f98422dcb7ecdc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c4d5be708d2097e1e647b586f98422dcb7ecdc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa7f69cdaaa30a88e928478d7ba05f403f522f54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7f69cdaaa30a88e928478d7ba05f403f522f54", "html_url": "https://github.com/rust-lang/rust/commit/fa7f69cdaaa30a88e928478d7ba05f403f522f54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa7f69cdaaa30a88e928478d7ba05f403f522f54/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e185cd519058611eac883cde44442f0d48a22de0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e185cd519058611eac883cde44442f0d48a22de0", "html_url": "https://github.com/rust-lang/rust/commit/e185cd519058611eac883cde44442f0d48a22de0"}], "stats": {"total": 428, "additions": 428, "deletions": 0}, "files": [{"sha": "15983ada5ea85389898937c74e7e703185d6b2c7", "filename": "src/test/compile-fail/auxiliary/dropck_eyepatch_extern_crate.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs?ref=fa7f69cdaaa30a88e928478d7ba05f403f522f54", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself,\n+// and that this attributes effects are preserved when importing\n+// the type from another crate.\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::fmt;\n+\n+pub struct Dt<A: fmt::Debug>(pub &'static str, pub A);\n+pub struct Dr<'a, B:'a+fmt::Debug>(pub &'static str, pub &'a B);\n+pub struct Pt<A,B: fmt::Debug>(pub &'static str, pub A, pub B);\n+pub struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(pub &'static str, pub &'a B, pub &'b B);\n+pub struct St<A: fmt::Debug>(pub &'static str, pub A);\n+pub struct Sr<'a, B:'a+fmt::Debug>(pub &'static str, pub &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}"}, {"sha": "189340992e92030a04b92ae616db563a559c6bcb", "filename": "src/test/compile-fail/dropck-eyepatch-extern-crate.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch-extern-crate.rs?ref=fa7f69cdaaa30a88e928478d7ba05f403f522f54", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:dropck_eyepatch_extern_crate.rs\n+\n+extern crate dropck_eyepatch_extern_crate as other;\n+\n+use other::{Dt,Dr,Pt,Pr,St,Sr};\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "e442fade1973025d25f2d82ce9085e5b41dcf978", "filename": "src/test/compile-fail/dropck-eyepatch.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck-eyepatch.rs?ref=fa7f69cdaaa30a88e928478d7ba05f403f522f54", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself.\n+//\n+// Here we test that only the expected errors are issued.\n+//\n+// The illustration is made concrete by comparison with two variations\n+// on the type with `#[may_dangle]`:\n+//\n+//   1. an analogous type that does not implement `Drop` (and thus\n+//      should exhibit maximal flexibility with respect to dropck), and\n+//\n+//   2. an analogous type that does not use `#[may_dangle]` (and thus\n+//      should exhibit the standard limitations imposed by dropck.\n+//\n+// The types in this file follow a pattern, {D,P,S}{t,r}, where:\n+//\n+// - D means \"I implement Drop\"\n+//\n+// - P means \"I implement Drop but guarantee my (first) parameter is\n+//     pure, i.e. not accessed from the destructor\"; no other parameters\n+//     are pure.\n+//\n+// - S means \"I do not implement Drop\"\n+//\n+// - t suffix is used when the first generic is a type\n+//\n+// - r suffix is used when the first generic is a lifetime.\n+\n+use std::fmt;\n+\n+struct Dt<A: fmt::Debug>(&'static str, A);\n+struct Dr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+struct Pt<A,B: fmt::Debug>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+fmt::Debug>(&'static str, &'a B, &'b B);\n+struct St<A: fmt::Debug>(&'static str, A);\n+struct Sr<'a, B:'a+fmt::Debug>(&'static str, &'a B);\n+\n+impl<A: fmt::Debug> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+impl<'a, B: fmt::Debug> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.1); }\n+}\n+unsafe impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n+}\n+\n+fn main() {\n+    use std::cell::Cell;\n+    let c_long;\n+    let (c, mut dt, mut dr, mut pt, mut pr, st, sr)\n+        : (Cell<_>, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = Cell::new(1);\n+    c = Cell::new(1);\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long);\n+    dr = Dr(\"dr\", &c_long);\n+    // Error: destructor order imprecisely modelled\n+    dt = Dt(\"dt\", &c); //~ ERROR `c` does not live long enough\n+    dr = Dr(\"dr\", &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c, &c_long);\n+    pr = Pr(\"pr\", &c, &c_long);\n+\n+    // Error: Drop impl's assertion does not apply to `B` nor `&'b _`\n+    pt = Pt(\"pt\", &c_long, &c); //~ ERROR `c` does not live long enough\n+    pr = Pr(\"pr\", &c_long, &c); //~ ERROR `c` does not live long enough\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c);\n+    sr = Sr(\"sr\", &c);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+}"}, {"sha": "23f8ead0ca9dc497b37ceddaa5d1f6ccf3314611", "filename": "src/test/compile-fail/feature-gate-may-dangle.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-may-dangle.rs?ref=fa7f69cdaaa30a88e928478d7ba05f403f522f54", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that `may_dangle` is rejected if `dropck_eyepatch` feature gate is absent.\n+\n+#![feature(generic_param_attrs)]\n+\n+struct Pt<A>(A);\n+impl<#[may_dangle] A> Drop for Pt<A> {\n+    //~^ ERROR may_dangle has unstable semantics and may be removed in the future\n+    //~| HELP add #![feature(dropck_eyepatch)] to the crate attributes to enable\n+    fn drop(&mut self) { }\n+}"}, {"sha": "1266e589b127e54b62928fade13422c992ada1dd", "filename": "src/test/run-pass/auxiliary/dropck_eyepatch_extern_crate.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fdropck_eyepatch_extern_crate.rs?ref=fa7f69cdaaa30a88e928478d7ba05f403f522f54", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself,\n+// and that this attributes effects are preserved when importing\n+// the type from another crate.\n+//\n+// See also dropck-eyepatch.rs for more information about the general\n+// structure of the test.\n+\n+use std::cell::RefCell;\n+\n+pub trait Foo { fn foo(&self, _: &str); }\n+\n+pub struct Dt<A: Foo>(pub &'static str, pub A);\n+pub struct Dr<'a, B:'a+Foo>(pub &'static str, pub &'a B);\n+pub struct Pt<A,B: Foo>(pub &'static str, pub A, pub B);\n+pub struct Pr<'a, 'b, B:'a+'b+Foo>(pub &'static str, pub &'a B, pub &'b B);\n+pub struct St<A: Foo>(pub &'static str, pub A);\n+pub struct Sr<'a, B:'a+Foo>(pub &'static str, pub &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] A, B: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+impl Foo for RefCell<String> {\n+    fn foo(&self, s: &str) {\n+        let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+        *self.borrow_mut() = s2;\n+    }\n+}\n+\n+impl<'a, T:Foo> Foo for &'a T {\n+    fn foo(&self, s: &str) {\n+        (*self).foo(s);\n+    }\n+}"}, {"sha": "20f069f77ea1574648aaa5daed1b232eef465e4f", "filename": "src/test/run-pass/dropck-eyepatch-extern-crate.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch-extern-crate.rs?ref=fa7f69cdaaa30a88e928478d7ba05f403f522f54", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:dropck_eyepatch_extern_crate.rs\n+\n+extern crate dropck_eyepatch_extern_crate as other;\n+\n+use other::{Dt,Dr,Pt,Pr,St,Sr};\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}, {"sha": "4a09ba05dff5eec3af108c0cbc21d759d4655f34", "filename": "src/test/run-pass/dropck-eyepatch.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f69cdaaa30a88e928478d7ba05f403f522f54/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdropck-eyepatch.rs?ref=fa7f69cdaaa30a88e928478d7ba05f403f522f54", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+// The point of this test is to illustrate that the `#[may_dangle]`\n+// attribute specifically allows, in the context of a type\n+// implementing `Drop`, a generic parameter to be instantiated with a\n+// lifetime that does not strictly outlive the owning type itself.\n+//\n+// Here we test that a model use of `#[may_dangle]` will compile and run.\n+//\n+// The illustration is made concrete by comparison with two variations\n+// on the type with `#[may_dangle]`:\n+//\n+//   1. an analogous type that does not implement `Drop` (and thus\n+//      should exhibit maximal flexibility with respect to dropck), and\n+//\n+//   2. an analogous type that does not use `#[may_dangle]` (and thus\n+//      should exhibit the standard limitations imposed by dropck.\n+//\n+// The types in this file follow a pattern, {D,P,S}{t,r}, where:\n+//\n+// - D means \"I implement Drop\"\n+//\n+// - P means \"I implement Drop but guarantee my (first) parameter is\n+//     pure, i.e. not accessed from the destructor\"; no other parameters\n+//     are pure.\n+//\n+// - S means \"I do not implement Drop\"\n+//\n+// - t suffix is used when the first generic is a type\n+//\n+// - r suffix is used when the first generic is a lifetime.\n+\n+trait Foo { fn foo(&self, _: &str); }\n+\n+struct Dt<A: Foo>(&'static str, A);\n+struct Dr<'a, B:'a+Foo>(&'static str, &'a B);\n+struct Pt<A,B: Foo>(&'static str, A, B);\n+struct Pr<'a, 'b, B:'a+'b+Foo>(&'static str, &'a B, &'b B);\n+struct St<A: Foo>(&'static str, A);\n+struct Sr<'a, B:'a+Foo>(&'static str, &'a B);\n+\n+impl<A: Foo> Drop for Dt<A> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+impl<'a, B: Foo> Drop for Dr<'a, B> {\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.1.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] A, B: Foo> Drop for Pt<A, B> {\n+    // (unsafe to access self.1  due to #[may_dangle] on A)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+unsafe impl<#[may_dangle] 'a, 'b, B: Foo> Drop for Pr<'a, 'b, B> {\n+    // (unsafe to access self.1 due to #[may_dangle] on 'a)\n+    fn drop(&mut self) { println!(\"drop {}\", self.0); self.2.foo(self.0); }\n+}\n+\n+fn main() {\n+    use std::cell::RefCell;\n+\n+    impl Foo for RefCell<String> {\n+        fn foo(&self, s: &str) {\n+            let s2 = format!(\"{}|{}\", *self.borrow(), s);\n+            *self.borrow_mut() = s2;\n+        }\n+    }\n+\n+    impl<'a, T:Foo> Foo for &'a T {\n+        fn foo(&self, s: &str) {\n+            (*self).foo(s);\n+        }\n+    }\n+\n+    struct CheckOnDrop(RefCell<String>, &'static str);\n+    impl Drop for CheckOnDrop {\n+        fn drop(&mut self) { assert_eq!(*self.0.borrow(), self.1); }\n+    }\n+\n+    let c_long;\n+    let (c, dt, dr, pt, pr, st, sr)\n+        : (CheckOnDrop, Dt<_>, Dr<_>, Pt<_, _>, Pr<_>, St<_>, Sr<_>);\n+    c_long = CheckOnDrop(RefCell::new(\"c_long\".to_string()),\n+                         \"c_long|pr|pt|dr|dt\");\n+    c = CheckOnDrop(RefCell::new(\"c\".to_string()),\n+                    \"c\");\n+\n+    // No error: sufficiently long-lived state can be referenced in dtors\n+    dt = Dt(\"dt\", &c_long.0);\n+    dr = Dr(\"dr\", &c_long.0);\n+\n+    // No error: Drop impl asserts .1 (A and &'a _) are not accessed\n+    pt = Pt(\"pt\", &c.0, &c_long.0);\n+    pr = Pr(\"pr\", &c.0, &c_long.0);\n+\n+    // No error: St and Sr have no destructor.\n+    st = St(\"st\", &c.0);\n+    sr = Sr(\"sr\", &c.0);\n+\n+    println!(\"{:?}\", (dt.0, dr.0, pt.0, pr.0, st.0, sr.0));\n+    assert_eq!(*c_long.0.borrow(), \"c_long\");\n+    assert_eq!(*c.0.borrow(), \"c\");\n+}"}]}