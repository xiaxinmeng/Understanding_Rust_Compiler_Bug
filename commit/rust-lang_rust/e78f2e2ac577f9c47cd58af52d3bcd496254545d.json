{"sha": "e78f2e2ac577f9c47cd58af52d3bcd496254545d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3OGYyZTJhYzU3N2Y5YzQ3Y2Q1OGFmNTJkM2JjZDQ5NjI1NDU0NWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-16T18:11:31Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-19T00:21:16Z"}, "message": "librustc: Make the compiler ignore purity.\n\nFor bootstrapping purposes, this commit does not remove all uses of\nthe keyword \"pure\" -- doing so would cause the compiler to no longer\nbootstrap due to some syntax extensions (\"deriving\" in particular).\nInstead, it makes the compiler ignore \"pure\". Post-snapshot, we can\nremove \"pure\" from the language.\n\nThere are quite a few (~100) borrow check errors that were essentially\nall the result of mutable fields or partial borrows of `@mut`. Per\ndiscussions with Niko I think we want to allow partial borrows of\n`@mut` but detect obvious footguns. We should also improve the error\nmessage when `@mut` is erroneously reborrowed.", "tree": {"sha": "f05564837fe02f676458ea86b705709715c44017", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f05564837fe02f676458ea86b705709715c44017"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e78f2e2ac577f9c47cd58af52d3bcd496254545d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e78f2e2ac577f9c47cd58af52d3bcd496254545d", "html_url": "https://github.com/rust-lang/rust/commit/e78f2e2ac577f9c47cd58af52d3bcd496254545d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e78f2e2ac577f9c47cd58af52d3bcd496254545d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4db4faefaf13ac814f34c2a6cf105b7684de019", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4db4faefaf13ac814f34c2a6cf105b7684de019", "html_url": "https://github.com/rust-lang/rust/commit/c4db4faefaf13ac814f34c2a6cf105b7684de019"}], "stats": {"total": 913, "additions": 373, "deletions": 540}, "files": [{"sha": "6be428ef27908a94f420f01664e48e8a17ebfe94", "filename": "doc/rust.md", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -214,7 +214,7 @@ false fn for\n if impl\n let loop\n match mod mut\n-priv pub pure\n+priv pub\n ref return\n self static struct super\n true trait type\n@@ -936,7 +936,6 @@ Specifically, the following operations are considered unsafe:\n \n   - Dereferencing a [raw pointer](#pointer-types).\n   - Casting a [raw pointer](#pointer-types) to a safe pointer type.\n-  - Breaking the [purity-checking rules](#pure-functions) in a `pure` function.\n   - Calling an unsafe function.\n \n ##### Unsafe blocks\n@@ -946,42 +945,6 @@ This facility exists because the static semantics of Rust are a necessary approx\n When a programmer has sufficient conviction that a sequence of unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an `unsafe` block. The compiler will consider uses of such code \"safe\", to the surrounding context.\n \n \n-#### Pure functions\n-\n-A pure function declaration is identical to a function declaration, except that\n-it is declared with the additional keyword `pure`. In addition, the typechecker\n-checks the body of a pure function with a restricted set of typechecking rules.\n-A pure function may only modify data owned by its own stack frame.\n-So, a pure function may modify a local variable allocated on the stack, but not a mutable reference that it takes as an argument.\n-A pure function may only call other pure functions, not general functions.\n-\n-An example of a pure function:\n-\n-~~~~\n-pure fn lt_42(x: int) -> bool {\n-    return (x < 42);\n-}\n-~~~~\n-\n-Pure functions may call other pure functions:\n-\n-~~~~{.xfail-test}\n-pure fn pure_length<T>(ls: List<T>) -> uint { ... }\n-\n-pure fn nonempty_list<T>(ls: List<T>) -> bool { pure_length(ls) > 0u }\n-~~~~\n-\n-These purity-checking rules approximate the concept of referential transparency:\n-that a call-expression could be rewritten with the literal-expression of its return value, without changing the meaning of the program.\n-Since they are an approximation, sometimes these rules are *too* restrictive.\n-Rust allows programmers to violate these rules using [`unsafe` blocks](#unsafe-blocks), which we already saw.\n-As with any `unsafe` block, those that violate static purity carry transfer the burden of safety-proof from the compiler to the programmer.\n-Programmers should exercise caution when breaking such rules.\n-\n-For more details on purity, see [the borrowed pointer tutorial][borrow].\n-\n-[borrow]: tutorial-borrowed-ptr.html\n-\n #### Diverging functions\n \n A special kind of function can be declared with a `!` character where the\n@@ -1246,10 +1209,10 @@ For example:\n \n ~~~~\n trait Num {\n-    static pure fn from_int(n: int) -> Self;\n+    static fn from_int(n: int) -> Self;\n }\n impl Num for float {\n-    static pure fn from_int(n: int) -> float { n as float }\n+    static fn from_int(n: int) -> float { n as float }\n }\n let x: float = Num::from_int(42);\n ~~~~\n@@ -2643,7 +2606,7 @@ Raw pointers (`*`)\n ### Function types\n \n The function type-constructor `fn` forms new function types. A function type\n-consists of a set of function-type modifiers (`pure`, `unsafe`, `extern`, etc.),\n+consists of a set of function-type modifiers (`unsafe`, `extern`, etc.),\n a sequence of input slots and an output slot.\n \n An example of a `fn` type:"}, {"sha": "8e0ca297f657ceb54e418c783e2398de5eac1277", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -486,12 +486,12 @@ For example, we could write a subroutine like this:\n \n ~~~\n struct Point {x: float, y: float}\n-fn get_x(p: &r/Point) -> &r/float { &p.x }\n+fn get_x(p: &'r Point) -> &'r float { &p.x }\n ~~~\n \n Here, the function `get_x()` returns a pointer into the structure it\n-was given. The type of the parameter (`&r/Point`) and return type\n-(`&r/float`) both use a new syntactic form that we have not seen so\n+was given. The type of the parameter (`&'r Point`) and return type\n+(`&'r float`) both use a new syntactic form that we have not seen so\n far.  Here the identifier `r` names the lifetime of the pointer\n explicitly. So in effect, this function declares that it takes a\n pointer with lifetime `r` and returns a pointer with that same\n@@ -572,8 +572,8 @@ function:\n #     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n # fn compute_area(shape: &Shape) -> float { 0f }\n-fn select<T>(shape: &r/Shape, threshold: float,\n-             a: &r/T, b: &r/T) -> &r/T {\n+fn select<T>(shape: &'r Shape, threshold: float,\n+             a: &'r T, b: &'r T) -> &'r T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n ~~~\n@@ -593,17 +593,17 @@ example:\n # }\n # fn compute_area(shape: &Shape) -> float { 0f }\n # fn select<T>(shape: &Shape, threshold: float,\n-#              a: &r/T, b: &r/T) -> &r/T {\n+#              a: &'r T, b: &'r T) -> &'r T {\n #     if compute_area(shape) > threshold {a} else {b}\n # }\n-                                                  // -+ r\n-fn select_based_on_unit_circle<T>(                //  |-+ B\n-    threshold: float, a: &r/T, b: &r/T) -> &r/T { //  | |\n-                                                  //  | |\n-    let shape = Circle(Point {x: 0., y: 0.}, 1.); //  | |\n-    select(&shape, threshold, a, b)               //  | |\n-}                                                 //  |-+\n-                                                  // -+\n+                                                     // -+ r\n+fn select_based_on_unit_circle<T>(                   //  |-+ B\n+    threshold: float, a: &'r T, b: &'r T) -> &'r T { //  | |\n+                                                     //  | |\n+    let shape = Circle(Point {x: 0., y: 0.}, 1.);    //  | |\n+    select(&shape, threshold, a, b)                  //  | |\n+}                                                    //  |-+\n+                                                     // -+\n ~~~\n \n In this call to `select()`, the lifetime of the first parameter shape\n@@ -629,8 +629,8 @@ returned. Here is how the new `select()` might look:\n #     Rectangle(Point, Size)  // upper-left, dimensions\n # }\n # fn compute_area(shape: &Shape) -> float { 0f }\n-fn select<T>(shape: &tmp/Shape, threshold: float,\n-             a: &r/T, b: &r/T) -> &r/T {\n+fn select<T>(shape: &'tmp Shape, threshold: float,\n+             a: &'r T, b: &'r T) -> &'r T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n ~~~\n@@ -649,7 +649,7 @@ concise to just omit the named lifetime for `shape` altogether:\n # }\n # fn compute_area(shape: &Shape) -> float { 0f }\n fn select<T>(shape: &Shape, threshold: float,\n-             a: &r/T, b: &r/T) -> &r/T {\n+             a: &'r T, b: &'r T) -> &'r T {\n     if compute_area(shape) > threshold {a} else {b}\n }\n ~~~"}, {"sha": "cfd1b8dfef0009c6f6d1b113039775a40fbc4fb7", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -8,18 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cast::transmute;\n use option;\n use prelude::*;\n \n /// A dynamic, mutable location.\n ///\n /// Similar to a mutable option type, but friendlier.\n \n-#[deriving_eq]\n pub struct Cell<T> {\n     mut value: Option<T>\n }\n \n+impl<T:cmp::Eq> cmp::Eq for Cell<T> {\n+    pure fn eq(&self, other: &Cell<T>) -> bool {\n+        unsafe {\n+            let frozen_self: &Option<T> = transmute(&mut self.value);\n+            let frozen_other: &Option<T> = transmute(&mut other.value);\n+            frozen_self == frozen_other\n+        }\n+    }\n+    pure fn ne(&self, other: &Cell<T>) -> bool { !self.eq(other) }\n+}\n+\n /// Creates a new full cell with the given value.\n pub fn Cell<T>(value: T) -> Cell<T> {\n     Cell { value: Some(value) }"}, {"sha": "12dc2d7e34158219c23ec1b4a00d85dbc9b2b530", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cast;\n use either::{Either, Left, Right};\n use kinds::Owned;\n use option;\n use option::{Option, Some, None, unwrap};\n+use uint;\n use unstable;\n use vec;\n \n@@ -283,8 +285,12 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n pure fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n     // It'd be nice to use self.port.each, but that version isn't\n     // pure.\n-    for vec::each(self.ports) |p| {\n-        if p.peek() { return true }\n+    for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n+        // XXX: Botch pending demuting.\n+        unsafe {\n+            let port: &Port<T> = cast::transmute(&mut self.ports[i]);\n+            if port.peek() { return true }\n+        }\n     }\n     false\n }"}, {"sha": "5044b3a6c5de1a3721efd5b65f289462bf7d8a41", "filename": "src/libcore/container.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -14,10 +14,10 @@ use option::Option;\n \n pub trait Container {\n     /// Return the number of elements in the container\n-    pure fn len(&self) -> uint;\n+    pure fn len(&const self) -> uint;\n \n     /// Return true if the container contains no elements\n-    pure fn is_empty(&self) -> bool;\n+    pure fn is_empty(&const self) -> bool;\n }\n \n pub trait Mutable: Container {"}, {"sha": "68a55792077e9600f689b363224d47c7f3705e62", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -290,10 +290,10 @@ pub mod linear {\n \n     impl<K:Hash + IterBytes + Eq,V> Container for LinearMap<K, V> {\n         /// Return the number of elements in the map\n-        pure fn len(&self) -> uint { self.size }\n+        pure fn len(&const self) -> uint { self.size }\n \n         /// Return true if the map contains no elements\n-        pure fn is_empty(&self) -> bool { self.len() == 0 }\n+        pure fn is_empty(&const self) -> bool { self.len() == 0 }\n     }\n \n     impl<K:Hash + IterBytes + Eq,V> Mutable for LinearMap<K, V> {\n@@ -555,10 +555,10 @@ pub mod linear {\n \n     impl<T:Hash + IterBytes + Eq> Container for LinearSet<T> {\n         /// Return the number of elements in the set\n-        pure fn len(&self) -> uint { self.map.len() }\n+        pure fn len(&const self) -> uint { self.map.len() }\n \n         /// Return true if the set contains no elements\n-        pure fn is_empty(&self) -> bool { self.map.is_empty() }\n+        pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n     }\n \n     impl<T:Hash + IterBytes + Eq> Mutable for LinearSet<T> {"}, {"sha": "50e7a42b7b17c2c61bd3d1fa52e9d78ff600ef20", "filename": "src/libcore/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -1116,7 +1116,7 @@ pub struct BytesWriter {\n impl Writer for BytesWriter {\n     fn write(&self, v: &[const u8]) {\n         let v_len = v.len();\n-        let bytes_len = self.bytes.len();\n+        let bytes_len = vec::uniq_len(&const self.bytes);\n \n         let count = uint::max(bytes_len, self.pos + v_len);\n         vec::reserve(&mut self.bytes, count);\n@@ -1131,7 +1131,7 @@ impl Writer for BytesWriter {\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n-        let len = self.bytes.len();\n+        let len = vec::uniq_len(&const self.bytes);\n         self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell(&self) -> uint { self.pos }"}, {"sha": "d0aa6e050f53ced5417bfeb4a38c53bd9713a4bb", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -46,8 +46,7 @@ pub fn unwrap<T>(m: Mut<T>) -> T {\n pub impl<T> Data<T> {\n     fn borrow_mut<R>(&self, op: &fn(t: &mut T) -> R) -> R {\n         match self.mode {\n-            Immutable => fail!(fmt!(\"%? currently immutable\",\n-                                   self.value)),\n+            Immutable => fail!(~\"currently immutable\"),\n             ReadOnly | Mutable => {}\n         }\n \n@@ -62,8 +61,7 @@ pub impl<T> Data<T> {\n \n     fn borrow_imm<R>(&self, op: &fn(t: &T) -> R) -> R {\n         match self.mode {\n-          Mutable => fail!(fmt!(\"%? currently mutable\",\n-                               self.value)),\n+          Mutable => fail!(~\"currently mutable\"),\n           ReadOnly | Immutable => {}\n         }\n "}, {"sha": "5e5396ea121149cf88f7b8736aa918dffe0c344d", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -228,14 +228,14 @@ pub pure fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n }\n \n #[inline(always)]\n-pub pure fn is_none<T>(opt: &Option<T>) -> bool {\n+pub pure fn is_none<T>(opt: &const Option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n     match *opt { None => true, Some(_) => false }\n }\n \n #[inline(always)]\n-pub pure fn is_some<T>(opt: &Option<T>) -> bool {\n+pub pure fn is_some<T>(opt: &const Option<T>) -> bool {\n     //! Returns true if the option contains some value\n \n     !is_none(opt)\n@@ -333,11 +333,11 @@ impl<T> MutableIter<T> for Option<T> {\n pub impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n     #[inline(always)]\n-    pure fn is_none(&self) -> bool { is_none(self) }\n+    pure fn is_none(&const self) -> bool { is_none(self) }\n \n     /// Returns true if the option contains some value\n     #[inline(always)]\n-    pure fn is_some(&self) -> bool { is_some(self) }\n+    pure fn is_some(&const self) -> bool { is_some(self) }\n \n     /**\n      * Update an optional value by optionally running its content by reference"}, {"sha": "c1b6b26d86a3584402278553221ecf998664c49b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -223,20 +223,20 @@ pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n }\n \n pub trait Ptr<T> {\n-    pure fn is_null(&self) -> bool;\n-    pure fn is_not_null(&self) -> bool;\n+    pure fn is_null(&const self) -> bool;\n+    pure fn is_not_null(&const self) -> bool;\n     pure fn offset(&self, count: uint) -> Self;\n }\n \n /// Extension methods for immutable pointers\n impl<T> Ptr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_null(&self) -> bool { is_null(*self) }\n+    pure fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_not_null(&self) -> bool { is_not_null(*self) }\n+    pure fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     /// Calculates the offset from a pointer.\n     #[inline(always)]\n@@ -247,11 +247,11 @@ impl<T> Ptr<T> for *T {\n impl<T> Ptr<T> for *mut T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_null(&self) -> bool { is_null(*self) }\n+    pure fn is_null(&const self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_not_null(&self) -> bool { is_not_null(*self) }\n+    pure fn is_not_null(&const self) -> bool { is_not_null(*self) }\n \n     /// Calculates the offset from a mutable pointer.\n     #[inline(always)]"}, {"sha": "83df9b7c00fc3b0e3a4aad1a8050c8695ecfcf37", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -499,7 +499,7 @@ impl TyVisitor for ReprVisitor {\n     }\n \n     fn visit_enum_variant_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        match self.var_stk[self.var_stk.len() - 1] {\n+        match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n             Degenerate | TagMatch => {\n                 if i != 0 {\n                     self.writer.write_str(\", \");\n@@ -517,7 +517,7 @@ impl TyVisitor for ReprVisitor {\n                                 _disr_val: int,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n-        match self.var_stk[self.var_stk.len() - 1] {\n+        match self.var_stk[vec::uniq_len(&const self.var_stk) - 1] {\n             Degenerate | TagMatch => {\n                 if n_fields > 0 {\n                     self.writer.write_char(')');"}, {"sha": "40a6873ad67259bc178ec2731c4c8fc0df4f9f64", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -127,7 +127,7 @@ type TaskGroupInner = &'self mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n-    (&tg.members).is_empty()\n+    (&const tg.members).is_empty()\n }\n \n // A list-like structure by which taskgroups keep track of all ancestor groups"}, {"sha": "6b2f2bb6a7dbe2b8f54010bdef9f2f914336de8d", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -50,11 +50,11 @@ impl<T> ReverseIter<(uint, &'self T)> for TrieMap<T> {\n impl<T> Container for TrieMap<T> {\n     /// Return the number of elements in the map\n     #[inline(always)]\n-    pure fn len(&self) -> uint { self.length }\n+    pure fn len(&const self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for TrieMap<T> {\n@@ -178,11 +178,11 @@ impl ReverseIter<uint> for TrieSet {\n impl Container for TrieSet {\n     /// Return the number of elements in the set\n     #[inline(always)]\n-    pure fn len(&self) -> uint { self.map.len() }\n+    pure fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&self) -> bool { self.map.is_empty() }\n+    pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl Mutable for TrieSet {"}, {"sha": "dc220eaed1bee44bf2a7f3593da735e8c060416b", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -118,6 +118,14 @@ pub pure fn len<T>(v: &[const T]) -> uint {\n     as_const_buf(v, |_p, len| len)\n }\n \n+// A botch to tide us over until core and std are fully demuted.\n+pub pure fn uniq_len<T>(v: &const ~[T]) -> uint {\n+    unsafe {\n+        let v: &~[T] = ::cast::transmute(v);\n+        as_const_buf(*v, |_p, len| len)\n+    }\n+}\n+\n /**\n  * Creates and initializes an immutable vector.\n  *\n@@ -1691,11 +1699,11 @@ pub mod traits {\n impl<T> Container for &'self [const T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n-    pure fn is_empty(&self) -> bool { is_empty(*self) }\n+    pure fn is_empty(&const self) -> bool { is_empty(*self) }\n \n     /// Returns the length of a vector\n     #[inline]\n-    pure fn len(&self) -> uint { len(*self) }\n+    pure fn len(&const self) -> uint { len(*self) }\n }\n \n pub trait CopyableVector<T> {\n@@ -1707,7 +1715,14 @@ impl<T: Copy> CopyableVector<T> for &'self [const T] {\n     /// Returns a copy of the elements from [`start`..`end`) from `v`.\n     #[inline]\n     pure fn slice(&self, start: uint, end: uint) -> ~[T] {\n-        slice(*self, start, end).to_vec()\n+        // XXX: Purity workaround for stage0.\n+        unsafe {\n+            let mut result = ~[];\n+            for uint::range(start, end) |i| {\n+                result.push(copy self[i]);\n+            }\n+            result\n+        }\n     }\n }\n \n@@ -2484,7 +2499,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for &'self [A] {\n impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n     pure fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n-        while i < self.len() {\n+        while i < uniq_len(self) {\n             if !f(copy self[i]) { break; }\n             i += 1;\n         }"}, {"sha": "434d992f501979b9667443a176be7dcb8377f308", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -142,7 +142,7 @@ fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: @fold::ast_fold)\n           -> Option<@ast::item> {\n     cx.path.push(i.ident);\n     debug!(\"current path: %s\",\n-           ast_util::path_name_i(cx.path, cx.sess.parse_sess.interner));\n+           ast_util::path_name_i(copy cx.path, cx.sess.parse_sess.interner));\n \n     if is_test_fn(i) || is_bench_fn(i) {\n         match i.node {\n@@ -162,7 +162,7 @@ fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: @fold::ast_fold)\n                 should_fail: should_fail(i)\n             };\n             cx.testfns.push(test);\n-            debug!(\"have %u test/bench functions\", cx.testfns.len());\n+            // debug!(\"have %u test/bench functions\", cx.testfns.len());\n           }\n         }\n     }"}, {"sha": "92de7f3f5e6c7cfc9eea83aa27572b6951ea87e5", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -79,6 +79,8 @@ fn warn_if_multiple_versions(e: @mut Env,\n                              crate_cache: @mut ~[cache_entry]) {\n     use core::either::*;\n \n+    let crate_cache = &mut *crate_cache;\n+\n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(\n             *crate_cache[crate_cache.len() - 1].metas"}, {"sha": "ee52b48bc328b28ba60e3e4d6b9ca81af3d437ce", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -96,6 +96,7 @@ pub fn iter_crate_data(cstore: @mut CStore,\n }\n \n pub fn add_used_crate_file(cstore: @mut CStore, lib: &Path) {\n+    let cstore = &mut *cstore;\n     if !vec::contains(cstore.used_crate_files, lib) {\n         cstore.used_crate_files.push(copy *lib);\n     }\n@@ -108,6 +109,7 @@ pub fn get_used_crate_files(cstore: @mut CStore) -> ~[Path] {\n pub fn add_used_library(cstore: @mut CStore, lib: @~str) -> bool {\n     fail_unless!(*lib != ~\"\");\n \n+    let cstore = &mut *cstore;\n     if cstore.used_libraries.contains(&*lib) { return false; }\n     cstore.used_libraries.push(/*bad*/ copy *lib);\n     true"}, {"sha": "17bdf318e0708407793ba74a98b8a0a512a000e5", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -271,6 +271,7 @@ pub impl CheckLoanCtxt {\n             None => return,\n             Some(loans) => loans\n         };\n+        let new_loans: &mut ~[Loan] = new_loans;\n \n         debug!(\"new_loans has length %?\", new_loans.len());\n "}, {"sha": "e5f056619cc7ef6c09103c53657c69126191f08e", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -129,9 +129,12 @@ fn req_loans_in_expr(ex: @ast::expr,\n            ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     // If this expression is borrowed, have to ensure it remains valid:\n-    if !self.ignore_adjustments.contains(&ex.id) {\n-        for tcx.adjustments.find(&ex.id).each |adjustments| {\n-            self.guarantee_adjustments(ex, *adjustments);\n+    {\n+        let mut this = &mut *self;\n+        if !this.ignore_adjustments.contains(&ex.id) {\n+            for tcx.adjustments.find(&ex.id).each |adjustments| {\n+                this.guarantee_adjustments(ex, *adjustments);\n+            }\n         }\n     }\n \n@@ -288,9 +291,9 @@ fn req_loans_in_expr(ex: @ast::expr,\n }\n \n pub impl GatherLoanCtxt {\n-    fn tcx(@mut self) -> ty::ctxt { self.bccx.tcx }\n+    fn tcx(&mut self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn guarantee_adjustments(@mut self,\n+    fn guarantee_adjustments(&mut self,\n                              expr: @ast::expr,\n                              adjustment: &ty::AutoAdjustment) {\n         debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n@@ -348,7 +351,7 @@ pub impl GatherLoanCtxt {\n     // out loans, which will be added to the `req_loan_map`.  This can\n     // also entail \"rooting\" GC'd pointers, which means ensuring\n     // dynamically that they are not freed.\n-    fn guarantee_valid(@mut self,\n+    fn guarantee_valid(&mut self,\n                        cmt: cmt,\n                        req_mutbl: ast::mutability,\n                        scope_r: ty::Region)\n@@ -465,7 +468,7 @@ pub impl GatherLoanCtxt {\n     // has type `@mut{f:int}`, this check might fail because `&x.f`\n     // reqires an immutable pointer, but `f` lives in (aliased)\n     // mutable memory.\n-    fn check_mutbl(@mut self,\n+    fn check_mutbl(&mut self,\n                    loan_kind: LoanKind,\n                    cmt: cmt)\n                 -> bckres<PreserveCondition> {\n@@ -498,7 +501,7 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn add_loans(@mut self,\n+    fn add_loans(&mut self,\n                  cmt: cmt,\n                  loan_kind: LoanKind,\n                  scope_r: ty::Region,\n@@ -563,7 +566,7 @@ pub impl GatherLoanCtxt {\n         }\n     }\n \n-    fn add_loans_to_scope_id(@mut self,\n+    fn add_loans_to_scope_id(&mut self,\n                              scope_id: ast::node_id,\n                              +loans: ~[Loan]) {\n         debug!(\"adding %u loans to scope_id %?: %s\","}, {"sha": "a8af6a18c0057e468ee5a8ac2407abd4faf893b3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -849,21 +849,24 @@ pub impl Liveness {\n                     _ => self.tcx.sess.span_bug(sp, ~\"Label on break/loop \\\n                                                     doesn't refer to a loop\")\n                 },\n-            None =>\n+            None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                if self.loop_scope.len() == 0 {\n+                let loop_scope = &mut *self.loop_scope;\n+                if loop_scope.len() == 0 {\n                     self.tcx.sess.span_bug(sp, ~\"break outside loop\");\n                 }\n                 else {\n                     // FIXME(#5275): this shouldn't have to be a method...\n                     self.last_loop_scope()\n                 }\n+            }\n         }\n     }\n \n     fn last_loop_scope(&self) -> node_id {\n-        *self.loop_scope.last()\n+        let loop_scope = &mut *self.loop_scope;\n+        *loop_scope.last()\n     }\n \n     fn ln_str(&self, ln: LiveNode) -> ~str {"}, {"sha": "6dcf1ba812863e7bdfa178969f6ed3f022acc004", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -818,18 +818,21 @@ pub fn determine_rp_in_crate(sess: Session,\n     // C).  For each dependent item D, we combine the variance of C\n     // with the ambient variance where the reference occurred and then\n     // update the region-parameterization of D to reflect the result.\n-    while cx.worklist.len() != 0 {\n-        let c_id = cx.worklist.pop();\n-        let c_variance = cx.region_paramd_items.get(&c_id);\n-        debug!(\"popped %d from worklist\", c_id);\n-        match cx.dep_map.find(&c_id) {\n-          None => {}\n-          Some(deps) => {\n-            for deps.each |dep| {\n-                let v = add_variance(dep.ambient_variance, c_variance);\n-                cx.add_rp(dep.id, v);\n+    {\n+        let cx = &mut *cx;\n+        while cx.worklist.len() != 0 {\n+            let c_id = cx.worklist.pop();\n+            let c_variance = cx.region_paramd_items.get(&c_id);\n+            debug!(\"popped %d from worklist\", c_id);\n+            match cx.dep_map.find(&c_id) {\n+              None => {}\n+              Some(deps) => {\n+                for deps.each |dep| {\n+                    let v = add_variance(dep.ambient_variance, c_variance);\n+                    cx.add_rp(dep.id, v);\n+                }\n+              }\n             }\n-          }\n         }\n     }\n "}, {"sha": "6561da0862ae5cefb8bb822b526b39c0fba66d17", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 46, "deletions": 35, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -457,7 +457,7 @@ pub struct Module {\n     kind: ModuleKind,\n \n     children: @HashMap<ident,@mut NameBindings>,\n-    imports: ~[@ImportDirective],\n+    imports: @mut ~[@ImportDirective],\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -495,7 +495,7 @@ pub fn Module(parent_link: ParentLink,\n         def_id: def_id,\n         kind: kind,\n         children: @HashMap(),\n-        imports: ~[],\n+        imports: @mut ~[],\n         anonymous_children: @HashMap(),\n         import_resolutions: @HashMap(),\n         glob_count: 0,\n@@ -505,7 +505,8 @@ pub fn Module(parent_link: ParentLink,\n \n pub impl Module {\n     fn all_imports_resolved(&self) -> bool {\n-        return self.imports.len() == self.resolved_import_count;\n+        let imports = &mut *self.imports;\n+        return imports.len() == self.resolved_import_count;\n     }\n }\n \n@@ -647,6 +648,7 @@ pub impl NameBindings {\n                             None => {\n                                 match (*type_def).module_def {\n                                     Some(module_def) => {\n+                                        let module_def = &mut *module_def;\n                                         module_def.def_id.map(|def_id|\n                                             def_mod(*def_id))\n                                     }\n@@ -1978,10 +1980,11 @@ pub impl Resolver {\n             return;\n         }\n \n-        let import_count = module.imports.len();\n+        let imports = &mut *module.imports;\n+        let import_count = imports.len();\n         while module.resolved_import_count < import_count {\n             let import_index = module.resolved_import_count;\n-            let import_directive = module.imports[import_index];\n+            let import_directive = imports[import_index];\n             match self.resolve_import_for_module(module, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n@@ -2288,15 +2291,16 @@ pub impl Resolver {\n             (None, None) => { return Failed; }\n             // If it's private, it's also unresolved.\n             (Some(t), None) | (None, Some(t)) => {\n-                match t.bindings.type_def {\n+                let bindings = &mut *t.bindings;\n+                match bindings.type_def {\n                     Some(ref type_def) => {\n                         if type_def.privacy == Private {\n                             return Failed;\n                         }\n                     }\n                     _ => ()\n                 }\n-                match t.bindings.value_def {\n+                match bindings.value_def {\n                     Some(ref value_def) => {\n                         if value_def.privacy == Private {\n                             return Failed;\n@@ -2483,7 +2487,7 @@ pub impl Resolver {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n-                   is_none(&target_import_resolution.type_target),\n+                   is_none(&mut target_import_resolution.type_target),\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n@@ -2551,7 +2555,7 @@ pub impl Resolver {\n                    *self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n-                   dest_import_resolution.privacy);\n+                   copy dest_import_resolution.privacy);\n \n             // Merge the child item into the import resolution.\n             if (*name_bindings).defined_in_public_namespace(ValueNS) {\n@@ -2864,7 +2868,8 @@ pub impl Resolver {\n             module_, name, TypeNS, DontSearchThroughModules);\n         match resolve_result {\n             Success(target) => {\n-                match target.bindings.type_def {\n+                let bindings = &mut *target.bindings;\n+                match bindings.type_def {\n                     Some(ref type_def) => {\n                         match (*type_def).module_def {\n                             None => {\n@@ -3061,10 +3066,10 @@ pub impl Resolver {\n \n     fn report_unresolved_imports(@mut self, module_: @mut Module) {\n         let index = module_.resolved_import_count;\n-        let import_count = module_.imports.len();\n+        let imports: &mut ~[@ImportDirective] = &mut *module_.imports;\n+        let import_count = imports.len();\n         if index != import_count {\n-            self.session.span_err(module_.imports[index].span,\n-                                  ~\"unresolved import\");\n+            self.session.span_err(imports[index].span, ~\"unresolved import\");\n         }\n \n         // Descend into children and anonymous children.\n@@ -4253,10 +4258,10 @@ pub impl Resolver {\n \n                             match bindings_list {\n                                 Some(bindings_list)\n-                                if !bindings_list.contains_key(&ident)\n-                                    => {\n-                                    let last_rib = self.value_ribs[\n-                                            self.value_ribs.len() - 1];\n+                                if !bindings_list.contains_key(&ident) => {\n+                                    let this = &mut *self;\n+                                    let last_rib = this.value_ribs[\n+                                            this.value_ribs.len() - 1];\n                                     last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n                                     bindings_list.insert(ident, pat_id);\n@@ -4275,8 +4280,9 @@ pub impl Resolver {\n                                   // Not bound in the same pattern: do nothing\n                                 }\n                                 None => {\n-                                    let last_rib = self.value_ribs[\n-                                            self.value_ribs.len() - 1];\n+                                    let this = &mut *self;\n+                                    let last_rib = this.value_ribs[\n+                                            this.value_ribs.len() - 1];\n                                     last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n                                 }\n@@ -4723,14 +4729,16 @@ pub impl Resolver {\n     }\n \n     fn find_best_match_for_name(@mut self, name: &str) -> Option<~str> {\n+        let this = &mut *self;\n+\n         let mut maybes: ~[~str] = ~[];\n         let mut values: ~[uint] = ~[];\n \n-        let mut j = self.value_ribs.len();\n+        let mut j = this.value_ribs.len();\n         while j != 0 {\n             j -= 1;\n-            for self.value_ribs[j].bindings.each_entry |e| {\n-                vec::push(&mut maybes, copy *self.session.str_of(e.key));\n+            for this.value_ribs[j].bindings.each_entry |e| {\n+                vec::push(&mut maybes, copy *this.session.str_of(e.key));\n                 vec::push(&mut values, uint::max_value);\n             }\n         }\n@@ -4758,20 +4766,22 @@ pub impl Resolver {\n     }\n \n     fn name_exists_in_scope_struct(@mut self, name: &str) -> bool {\n-        let mut i = self.type_ribs.len();\n+        let this = &mut *self;\n+\n+        let mut i = this.type_ribs.len();\n         while i != 0 {\n           i -= 1;\n-          match self.type_ribs[i].kind {\n+          match this.type_ribs[i].kind {\n             MethodRibKind(node_id, _) =>\n-              for self.crate.node.module.items.each |item| {\n+              for this.crate.node.module.items.each |item| {\n                 if item.id == node_id {\n                   match item.node {\n                     item_struct(class_def, _) => {\n                       for vec::each(class_def.fields) |field| {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _, _) => {\n-                              if str::eq_slice(*self.session.str_of(ident),\n+                              if str::eq_slice(*this.session.str_of(ident),\n                                                name) {\n                                 return true\n                               }\n@@ -4877,8 +4887,9 @@ pub impl Resolver {\n \n             expr_loop(_, Some(label)) => {\n                 do self.with_label_rib {\n+                    let this = &mut *self;\n                     let def_like = dl_def(def_label(expr.id));\n-                    let rib = self.label_ribs[self.label_ribs.len() - 1];\n+                    let rib = this.label_ribs[this.label_ribs.len() - 1];\n                     rib.bindings.insert(label, def_like);\n \n                     visit_expr(expr, (), visitor);\n@@ -5144,21 +5155,21 @@ pub impl Resolver {\n     // be sure that there is only one main function\n     //\n     fn check_duplicate_main(@mut self) {\n-        if self.attr_main_fn.is_none() {\n-            if self.main_fns.len() >= 1u {\n+        let this = &mut *self;\n+        if this.attr_main_fn.is_none() {\n+            if this.main_fns.len() >= 1u {\n                 let mut i = 1u;\n-                while i < self.main_fns.len() {\n-                    let (_, dup_main_span) =\n-                            option::unwrap(self.main_fns[i]);\n-                    self.session.span_err(\n+                while i < this.main_fns.len() {\n+                    let (_, dup_main_span) = option::unwrap(this.main_fns[i]);\n+                    this.session.span_err(\n                         dup_main_span,\n                         ~\"multiple 'main' functions\");\n                     i += 1;\n                 }\n-                *self.session.main_fn = self.main_fns[0];\n+                *this.session.main_fn = this.main_fns[0];\n             }\n         } else {\n-            *self.session.main_fn = self.attr_main_fn;\n+            *this.session.main_fn = this.attr_main_fn;\n         }\n     }\n "}, {"sha": "4836ce062c9ca16e53bd9061d4a7109b705e0be6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -854,7 +854,9 @@ pub fn need_invoke(bcx: block) -> bool {\n     // Walk the scopes to look for cleanups\n     let mut cur = bcx;\n     loop {\n-        match *cur.kind {\n+        let current = &mut *cur;\n+        let kind = &mut *current.kind;\n+        match *kind {\n           block_scope(ref mut inf) => {\n             for vec::each((*inf).cleanups) |cleanup| {\n                 match *cleanup {\n@@ -868,7 +870,7 @@ pub fn need_invoke(bcx: block) -> bool {\n           }\n           _ => ()\n         }\n-        cur = match cur.parent {\n+        cur = match current.parent {\n           Some(next) => next,\n           None => return false\n         }"}, {"sha": "96c124d60de9fca1ac33083348dbc6da1f6fa1e6", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -50,7 +50,7 @@ pub fn count_insn(cx: block, category: &str) {\n     if cx.ccx().sess.count_llvm_insns() {\n \n         let h = cx.ccx().stats.llvm_insns;\n-        let v = cx.ccx().stats.llvm_insn_ctxt;\n+        let v = &*cx.ccx().stats.llvm_insn_ctxt;\n \n         // Build version of path with cycles removed.\n "}, {"sha": "616a5f994992bb16fe384ca7039610312221dd39", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -186,12 +186,14 @@ pub fn trans_log(log_ex: @ast::expr,\n        return expr::trans_into(bcx, lvl, expr::Ignore);\n     }\n \n-    let modpath = vec::append(\n-        ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name.to_owned()))],\n-        bcx.fcx.path.filtered(|e|\n-            match *e { path_mod(_) => true, _ => false }\n-        ));\n-    let modname = path_str(ccx.sess, modpath);\n+    let (modpath, modname) = {\n+        let path = &mut bcx.fcx.path;\n+        let modpath = vec::append(\n+            ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name.to_owned()))],\n+            path.filtered(|e| match *e { path_mod(_) => true, _ => false }));\n+        let modname = path_str(ccx.sess, modpath);\n+        (modpath, modname)\n+    };\n \n     let global = if ccx.module_data.contains_key(&modname) {\n         ccx.module_data.get(&modname)"}, {"sha": "e4b9d01c50982d4f0b25e6aa2bc0b5426532c062", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -845,7 +845,8 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     let dbg_cx = (/*bad*/copy cx.dbg_cx).get();\n \n     debug!(\"~~\");\n-    debug!(\"%?\", fcx.id);\n+\n+    let fcx = &mut *fcx;\n \n     let sp = fcx.span.get();\n     debug!(\"%s\", cx.sess.codemap.span_to_str(sp));"}, {"sha": "284a5eac39db84d8589f8ebbb459d7e413b08a67", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -234,18 +234,21 @@ pub fn lazily_emit_simplified_tydesc_glue(ccx: @CrateContext,\n     if simpl != ti.ty {\n         let simpl_ti = get_tydesc(ccx, simpl);\n         lazily_emit_tydesc_glue(ccx, field, simpl_ti);\n-        if field == abi::tydesc_field_take_glue {\n-            ti.take_glue =\n-                simpl_ti.take_glue.map(|v| cast_glue(ccx, ti, *v));\n-        } else if field == abi::tydesc_field_drop_glue {\n-            ti.drop_glue =\n-                simpl_ti.drop_glue.map(|v| cast_glue(ccx, ti, *v));\n-        } else if field == abi::tydesc_field_free_glue {\n-            ti.free_glue =\n-                simpl_ti.free_glue.map(|v| cast_glue(ccx, ti, *v));\n-        } else if field == abi::tydesc_field_visit_glue {\n-            ti.visit_glue =\n-                simpl_ti.visit_glue.map(|v| cast_glue(ccx, ti, *v));\n+        {\n+            let simpl_ti = &mut *simpl_ti;\n+            if field == abi::tydesc_field_take_glue {\n+                ti.take_glue =\n+                    simpl_ti.take_glue.map(|v| cast_glue(ccx, ti, *v));\n+            } else if field == abi::tydesc_field_drop_glue {\n+                ti.drop_glue =\n+                    simpl_ti.drop_glue.map(|v| cast_glue(ccx, ti, *v));\n+            } else if field == abi::tydesc_field_free_glue {\n+                ti.free_glue =\n+                    simpl_ti.free_glue.map(|v| cast_glue(ccx, ti, *v));\n+            } else if field == abi::tydesc_field_visit_glue {\n+                ti.visit_glue =\n+                    simpl_ti.visit_glue.map(|v| cast_glue(ccx, ti, *v));\n+            }\n         }\n         return true;\n     }"}, {"sha": "593919d108b875acea38189d23e84eb52b9fcd60", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -185,7 +185,11 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n \n pub fn type_needs(cx: Context, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n-    for uint::range(0, cx.uses.len()) |i| {\n+    let len = {\n+        let uses = &*cx.uses;\n+        uses.len()\n+    };\n+    for uint::range(0, len) |i| {\n         if cx.uses[i] & use_ != use_ {\n             type_needs_inner(cx, use_, ty, @Nil);\n             return;"}, {"sha": "599fa28e242246630e9de8e29cce21eeabdd5aa0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -2184,7 +2184,7 @@ pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n-    fn type_requires(cx: ctxt, seen: @mut ~[def_id],\n+    fn type_requires(cx: ctxt, seen: &mut ~[def_id],\n                      r_ty: t, ty: t) -> bool {\n         debug!(\"type_requires(%s, %s)?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2202,7 +2202,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n         return r;\n     }\n \n-    fn subtypes_require(cx: ctxt, seen: @mut ~[def_id],\n+    fn subtypes_require(cx: ctxt, seen: &mut ~[def_id],\n                         r_ty: t, ty: t) -> bool {\n         debug!(\"subtypes_require(%s, %s)?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),"}, {"sha": "752d9107d822aa6722eb0fd1ec4d656b21a5b163", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -1696,7 +1696,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(expr.id, fty);\n \n         let inherited_purity =\n-            ty::determine_inherited_purity(fcx.purity, purity,\n+            ty::determine_inherited_purity(copy fcx.purity, purity,\n                                            fn_ty.sigil);\n \n         // We inherit the same self info as the enclosing scope,"}, {"sha": "6e86bbca0d1c3618edcba2e482f9881617597e66", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use middle::resolve::Impl;\n use middle::ty::{param_ty, substs};\n use middle::ty;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n@@ -240,6 +241,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                     // Nothing found. Continue.\n                 }\n                 Some(implementations) => {\n+                    let implementations: &mut ~[@Impl] = implementations;\n                     // implementations is the list of all impls in scope for\n                     // trait_ty. (Usually, there's just one.)\n                     for uint::range(0, implementations.len()) |i| {"}, {"sha": "699b8ad74e4cec313f3082b017ff2210dfc586d0", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -466,14 +466,13 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn iter_impls_of_trait(&self, trait_def_id: def_id,\n-                           f: &fn(@Impl)) {\n-\n+    fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n         let coherence_info = &mut self.crate_context.coherence_info;\n         let extension_methods = &coherence_info.extension_methods;\n \n         match extension_methods.find(&trait_def_id) {\n             Some(impls) => {\n+                let impls: &mut ~[@Impl] = impls;\n                 for uint::range(0, impls.len()) |i| {\n                     f(impls[i]);\n                 }"}, {"sha": "11da6b60328ce4c3eed48bf421d61dd0331a0eb2", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -559,15 +559,16 @@ pub impl InferCtxt {\n     }\n \n     fn start_snapshot(@mut self) -> Snapshot {\n+        let this = &mut *self;\n         Snapshot {\n             ty_var_bindings_len:\n-                self.ty_var_bindings.bindings.len(),\n+                this.ty_var_bindings.bindings.len(),\n             int_var_bindings_len:\n-                self.int_var_bindings.bindings.len(),\n+                this.int_var_bindings.bindings.len(),\n             float_var_bindings_len:\n-                self.float_var_bindings.bindings.len(),\n+                this.float_var_bindings.bindings.len(),\n             region_vars_snapshot:\n-                self.region_vars.start_snapshot(),\n+                this.region_vars.start_snapshot(),\n         }\n     }\n "}, {"sha": "430a5eab64e0b343ca9244af44c768268e6c6920", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -700,8 +700,8 @@ impl cmp::Eq for BitvSet {\n }\n \n impl Container for BitvSet {\n-    pure fn len(&self) -> uint { self.size }\n-    pure fn is_empty(&self) -> bool { self.size == 0 }\n+    pure fn len(&const self) -> uint { self.size }\n+    pure fn is_empty(&const self) -> bool { self.size == 0 }\n }\n \n impl Mutable for BitvSet {"}, {"sha": "86304f48e7929a1aee8a7d248789bf2472c507b6", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -23,10 +23,10 @@ pub struct Deque<T> {\n \n impl<T> Container for Deque<T> {\n     /// Return the number of elements in the deque\n-    pure fn len(&self) -> uint { self.nelts }\n+    pure fn len(&const self) -> uint { self.nelts }\n \n     /// Return true if the deque contains no elements\n-    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for Deque<T> {"}, {"sha": "c5515c63b29a2048053a344a157d4275e1020721", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -569,12 +569,12 @@ pub mod bytepipes {\n \n     impl BytePort for PipeBytePort {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n-            if self.buf.len() >= count {\n+            if vec::uniq_len(&const self.buf) >= count {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n                 self.buf = bytes.slice(count, bytes.len());\n                 bytes.truncate(count);\n                 return Some(bytes);\n-            } else if self.buf.len() > 0 {\n+            } else if vec::uniq_len(&const self.buf) > 0 {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n                 fail_unless!(count > bytes.len());\n                 match self.try_recv(count - bytes.len()) {\n@@ -584,7 +584,7 @@ pub mod bytepipes {\n                     }\n                     None => return None\n                 }\n-            } else if self.buf.is_empty() {\n+            } else if vec::uniq_len(&const self.buf) == 0 {\n                 match self.port.try_recv() {\n                     Some(buf) => {\n                         fail_unless!(!buf.is_empty());"}, {"sha": "f2f37604fb5645c79a9d585d7dfae5e57d9b5e3b", "filename": "src/libstd/json.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -757,12 +757,16 @@ pub fn Decoder(json: Json) -> Decoder {\n \n priv impl Decoder/&self {\n     fn peek(&self) -> &'self Json {\n-        if self.stack.len() == 0 { self.stack.push(&self.json); }\n-        self.stack[self.stack.len() - 1]\n+        if vec::uniq_len(&const self.stack) == 0 {\n+            self.stack.push(&self.json);\n+        }\n+        self.stack[vec::uniq_len(&const self.stack) - 1]\n     }\n \n     fn pop(&self) -> &'self Json {\n-        if self.stack.len() == 0 { self.stack.push(&self.json); }\n+        if vec::uniq_len(&const self.stack) == 0 {\n+            self.stack.push(&self.json);\n+        }\n         self.stack.pop()\n     }\n }"}, {"sha": "a93e94e0d04309967dca528bde275c3235e94899", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -879,7 +879,8 @@ impl io::Reader for TcpSocketBuf {\n \n           // If possible, copy up to `len` bytes from the internal\n           // `data.buf` into `buf`\n-          let nbuffered = self.data.buf.len() - self.data.buf_off;\n+          let nbuffered = vec::uniq_len(&const self.data.buf) -\n+                self.data.buf_off;\n           let needed = len - count;\n             if nbuffered > 0 {\n                 unsafe {\n@@ -931,7 +932,7 @@ impl io::Reader for TcpSocketBuf {\n     }\n     fn read_byte(&self) -> int {\n         loop {\n-          if self.data.buf.len() > self.data.buf_off {\n+          if vec::uniq_len(&const self.data.buf) > self.data.buf_off {\n             let c = self.data.buf[self.data.buf_off];\n             self.data.buf_off += 1;\n             return c as int"}, {"sha": "0a07a24e8ee5c92d608b1b41f0e0ed9f88eb2e43", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -101,7 +101,7 @@ pub mod chained {\n         }\n \n         pure fn search_tbl(&self, k: &K, h: uint) -> SearchResult<K,V> {\n-            let idx = h % vec::len(self.chains);\n+            let idx = h % vec::uniq_len(&const self.chains);\n             match copy self.chains[idx] {\n               None => {\n                 debug!(\"search_tbl: none, comp %u, hash %u, idx %u\",\n@@ -121,7 +121,7 @@ pub mod chained {\n         }\n \n         fn rehash(@self) {\n-            let n_old_chains = self.chains.len();\n+            let n_old_chains = vec::uniq_len(&const self.chains);\n             let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n             let mut new_chains = chains(n_new_chains);\n             for self.each_entry |entry| {\n@@ -137,7 +137,7 @@ pub mod chained {\n         pure fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n             // n.b. we can't use vec::iter() here because self.chains\n             // is stored in a mutable location.\n-            let mut i = 0u, n = self.chains.len();\n+            let mut i = 0u, n = vec::uniq_len(&const self.chains);\n             while i < n {\n                 let mut chain = self.chains[i];\n                 loop {\n@@ -161,8 +161,8 @@ pub mod chained {\n     }\n \n     impl<K:Eq + IterBytes + Hash,V> Container for HashMap_<K, V> {\n-        pure fn len(&self) -> uint { self.count }\n-        pure fn is_empty(&self) -> bool { self.count == 0 }\n+        pure fn len(&const self) -> uint { self.count }\n+        pure fn is_empty(&const self) -> bool { self.count == 0 }\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n@@ -179,7 +179,7 @@ pub mod chained {\n             match self.search_tbl(&k, hash) {\n               NotFound => {\n                 self.count += 1u;\n-                let idx = hash % vec::len(self.chains);\n+                let idx = hash % vec::uniq_len(&const self.chains);\n                 let old_chain = self.chains[idx];\n                 self.chains[idx] = Some(@Entry {\n                     hash: hash,\n@@ -188,7 +188,7 @@ pub mod chained {\n                     next: old_chain});\n \n                 // consider rehashing if more 3/4 full\n-                let nchains = vec::len(self.chains);\n+                let nchains = vec::uniq_len(&const self.chains);\n                 let load = util::Rational {\n                     num: (self.count + 1u) as int,\n                     den: nchains as int,\n@@ -271,7 +271,7 @@ pub mod chained {\n             match self.search_tbl(&key, hash) {\n               NotFound => {\n                 self.count += 1u;\n-                let idx = hash % vec::len(self.chains);\n+                let idx = hash % vec::uniq_len(&const self.chains);\n                 let old_chain = self.chains[idx];\n                 self.chains[idx] = Some(@Entry {\n                     hash: hash,\n@@ -280,7 +280,7 @@ pub mod chained {\n                     next: old_chain});\n \n                 // consider rehashing if more 3/4 full\n-                let nchains = vec::len(self.chains);\n+                let nchains = vec::uniq_len(&const self.chains);\n                 let load = util::Rational {\n                     num: (self.count + 1u) as int,\n                     den: nchains as int,"}, {"sha": "a5a291c5b18f52d3a85395ff22b42268863370a4", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -37,10 +37,10 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n \n impl<T:Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n-    pure fn len(&self) -> uint { self.data.len() }\n+    pure fn len(&const self) -> uint { vec::uniq_len(&const self.data) }\n \n     /// Returns true if a queue contains no elements\n-    pure fn is_empty(&self) -> bool { self.data.is_empty() }\n+    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T:Ord> Mutable for PriorityQueue<T> {"}, {"sha": "f7e31bc7df758c746b1952359293aa817b2a2a27", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -91,7 +91,7 @@ pub fn sha1() -> @Sha1 {\n     }\n     fn process_msg_block(st: &mut Sha1State) {\n         fail_unless!((vec::len(st.h) == digest_buf_len));\n-        fail_unless!((vec::len(*st.work_buf) == work_buf_len));\n+        fail_unless!((vec::uniq_len(st.work_buf) == work_buf_len));\n         let mut t: int; // Loop counter\n         let mut w = st.work_buf;\n "}, {"sha": "dc2688a20e73d0dd4ba7b524fc70bc2457ff497b", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -50,18 +50,19 @@ impl<V> ReverseIter<(uint, &'self V)> for SmallIntMap<V> {\n \n impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n-    pure fn len(&self) -> uint {\n+    pure fn len(&const self) -> uint {\n         let mut sz = 0;\n-        for self.v.each |item| {\n-            if item.is_some() {\n-                sz += 1;\n+        for uint::range(0, vec::uniq_len(&const self.v)) |i| {\n+            match self.v[i] {\n+                Some(_) => sz += 1,\n+                None => {}\n             }\n         }\n         sz\n     }\n \n     /// Return true if the map contains no elements\n-    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<V> Mutable for SmallIntMap<V> {"}, {"sha": "40be303a147825c1327055512c3eac8c39cfd36b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -68,9 +68,14 @@ fn part<T>(arr: &mut [T], left: uint,\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n-        if compare_func(&arr[i], &arr[right]) {\n-            arr[i] <-> arr[storage_index];\n-            storage_index += 1;\n+        // XXX: Unsafe because borrow check doesn't handle this right\n+        unsafe {\n+            let a: &T = cast::transmute(&mut arr[i]);\n+            let b: &T = cast::transmute(&mut arr[right]);\n+            if compare_func(a, b) {\n+                arr[i] <-> arr[storage_index];\n+                storage_index += 1;\n+            }\n         }\n         i += 1;\n     }\n@@ -451,7 +456,10 @@ impl<T:Copy + Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         fail_unless!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n \n-        let mut tmp = vec::slice(array, base1, base1+len1).to_vec();\n+        let mut tmp = ~[];\n+        for uint::range(base1, base1+len1) |i| {\n+            tmp.push(array[i]);\n+        }\n \n         let mut c1 = 0;\n         let mut c2 = base2;\n@@ -554,7 +562,10 @@ impl<T:Copy + Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         fail_unless!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n \n-        let mut tmp = vec::slice(array, base2, base2+len2).to_vec();\n+        let mut tmp = ~[];\n+        for uint::range(base2, base2+len2) |i| {\n+            tmp.push(array[i]);\n+        }\n \n         let mut c1 = base1 + len1 - 1;\n         let mut c2 = len2 - 1;\n@@ -702,7 +713,11 @@ fn copy_vec<T:Copy>(dest: &mut [T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n     fail_unless!(s1+len <= dest.len() && s2+len <= from.len());\n \n-    let slice = vec::slice(from, s2, s2+len).to_vec();\n+    let mut slice = ~[];\n+    for uint::range(s2, s2+len) |i| {\n+        slice.push(from[i]);\n+    }\n+\n     for slice.eachi |i, v| {\n         dest[s1+i] = *v;\n     }\n@@ -721,7 +736,7 @@ mod test_qsort3 {\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n         while i < len {\n-            debug!(v2[i]);\n+            // debug!(v2[i]);\n             fail_unless!((v2[i] == v1[i]));\n             i += 1;\n         }\n@@ -768,7 +783,7 @@ mod test_qsort {\n         quick_sort::<int>(v1, leual);\n         let mut i = 0u;\n         while i < len {\n-            debug!(v2[i]);\n+            // debug!(v2[i]);\n             fail_unless!((v2[i] == v1[i]));\n             i += 1;\n         }\n@@ -919,7 +934,7 @@ mod test_tim_sort {\n         tim_sort::<int>(v1);\n         let mut i = 0u;\n         while i < len {\n-            debug!(v2[i]);\n+            // debug!(v2[i]);\n             fail_unless!((v2[i] == v1[i]));\n             i += 1u;\n         }"}, {"sha": "fcc60c8d978195879857e34371d32656a2551168", "filename": "src/libstd/test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -358,7 +358,11 @@ pub fn run_tests_console(opts: &TestOpts,\n \n fn print_failures(st: @ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n-    let mut failures = st.failures.map(|t| t.name.to_str());\n+    let mut failures = ~[];\n+    for uint::range(0, vec::uniq_len(&const st.failures)) |i| {\n+        let name = copy st.failures[i].name;\n+        failures.push(name.to_str());\n+    }\n     sort::tim_sort(failures);\n     for vec::each(failures) |name| {\n         st.out.write_line(fmt!(\"    %s\", name.to_str()));"}, {"sha": "f4d58568ae7d626d10746cfbd8cd594045377598", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -106,10 +106,10 @@ impl<'self, K: TotalOrd, V>\n \n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n-    pure fn len(&self) -> uint { self.length }\n+    pure fn len(&const self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n-    pure fn is_empty(&self) -> bool { self.root.is_none() }\n+    pure fn is_empty(&const self) -> bool { self.root.is_none() }\n }\n \n impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n@@ -276,11 +276,11 @@ impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     #[inline(always)]\n-    pure fn len(&self) -> uint { self.map.len() }\n+    pure fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&self) -> bool { self.map.is_empty() }\n+    pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {"}, {"sha": "538f0de8c842b49ec9bb9a76bf0bde13f1e63fbc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -252,8 +252,8 @@ pub impl FileMap {\n     // about what ends a line between this file and parse.rs\n     fn next_line(&self, +pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n-        fail_unless!((self.lines.len() == 0)\n-                || (self.lines[self.lines.len() - 1] < pos));\n+        let lines = &mut *self.lines;\n+        fail_unless!((lines.len() == 0) || (lines[lines.len() - 1] < pos));\n         self.lines.push(pos);\n     }\n \n@@ -302,11 +302,12 @@ pub impl CodeMap {\n         +substr: FileSubstr,\n         src: @~str\n     ) -> @FileMap {\n-        let start_pos = if self.files.len() == 0 {\n+        let files = &mut *self.files;\n+        let start_pos = if files.len() == 0 {\n             0\n         } else {\n-            let last_start = self.files.last().start_pos.to_uint();\n-            let last_len = self.files.last().src.len();\n+            let last_start = files.last().start_pos.to_uint();\n+            let last_len = files.last().src.len();\n             last_start + last_len\n         };\n \n@@ -364,7 +365,8 @@ pub impl CodeMap {\n     }\n \n     pub fn span_to_str(&self, sp: span) -> ~str {\n-        if self.files.len() == 0 && sp == dummy_sp() {\n+        let files = &mut *self.files;\n+        if files.len() == 0 && sp == dummy_sp() {\n             return ~\"no-location\";\n         }\n \n@@ -409,7 +411,8 @@ pub impl CodeMap {\n priv impl CodeMap {\n \n     fn lookup_filemap_idx(&self, +pos: BytePos) -> uint {\n-        let len = self.files.len();\n+        let files = &*self.files;\n+        let len = files.len();\n         let mut a = 0u;\n         let mut b = len;\n         while b - a > 1u {\n@@ -433,10 +436,11 @@ priv impl CodeMap {\n         let idx = self.lookup_filemap_idx(pos);\n         let f = self.files[idx];\n         let mut a = 0u;\n-        let mut b = f.lines.len();\n+        let lines = &*f.lines;\n+        let mut b = lines.len();\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if f.lines[m] > pos { b = m; } else { a = m; }\n+            if lines[m] > pos { b = m; } else { a = m; }\n         }\n         return FileMapAndLine {fm: f, line: a};\n     }"}, {"sha": "76ab21f403b3f64a302f274014bed5b331be406f", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -226,7 +226,7 @@ fn create_eq_method(cx: @ext_ctxt,\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n         self_ty: self_ty,\n-        purity: pure_fn,\n+        purity: impure_fn,\n         decl: fn_decl,\n         body: body_block,\n         id: cx.next_id(),\n@@ -405,7 +405,7 @@ fn create_iter_bytes_method(cx: @ext_ctxt,\n         attrs: ~[],\n         generics: ast_util::empty_generics(),\n         self_ty: self_ty,\n-        purity: pure_fn,\n+        purity: impure_fn,\n         decl: fn_decl,\n         body: body_block,\n         id: cx.next_id(),"}, {"sha": "29c9e86ec626a25e4421666913142592e24ae66c", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -41,7 +41,8 @@ impl proto::visitor<(), (), ()> for @ext_ctxt {\n     fn visit_proto(&self, _proto: protocol, _states: &[()]) { }\n \n     fn visit_state(&self, state: state, _m: &[()]) {\n-        if state.messages.len() == 0 {\n+        let messages = &*state.messages;\n+        if messages.len() == 0 {\n             self.span_warn(\n                 state.span, // use a real span!\n                 fmt!(\"state %s contains no messages, \\"}, {"sha": "c6fdf4d9c1b21426eacce1a4334f5dfec318e94c", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -91,7 +91,7 @@ pub fn analyze(proto: protocol, _cx: @ext_ctxt) {\n         let states = str::connect(self_live.map(|s| copy s.name), ~\" \");\n \n         debug!(\"protocol %s is unbounded due to loops involving: %s\",\n-               proto.name, states);\n+               copy proto.name, states);\n \n         // Someday this will be configurable with a warning\n         //cx.span_warn(empty_span(),\n@@ -103,7 +103,7 @@ pub fn analyze(proto: protocol, _cx: @ext_ctxt) {\n         proto.bounded = Some(false);\n     }\n     else {\n-        debug!(\"protocol %s is bounded. yay!\", proto.name);\n+        debug!(\"protocol %s is bounded. yay!\", copy proto.name);\n         proto.bounded = Some(true);\n     }\n }"}, {"sha": "a47b39a45c86402622307f900a4ddd07cfd2b41d", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -156,7 +156,10 @@ pub impl protocol_ {\n         ~\"proto://\" + self.name\n     }\n \n-    fn num_states(&mut self) -> uint { self.states.len() }\n+    fn num_states(&mut self) -> uint {\n+        let states = &mut *self.states;\n+        states.len()\n+    }\n \n     fn has_ty_params(&mut self) -> bool {\n         for self.states.each |s| {\n@@ -180,9 +183,10 @@ pub impl protocol_ {\n                       +generics: ast::Generics)\n                    -> state {\n         let messages = @mut ~[];\n+        let states = &*self.states;\n \n         let state = @state_ {\n-            id: self.states.len(),\n+            id: states.len(),\n             name: name,\n             ident: ident,\n             span: self.span,"}, {"sha": "0196ee6d1842699dab8d5af68bf35b8f96798c50", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -106,8 +106,9 @@ pub pure fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n }\n \n \n-pure fn lookup_cur_matched_by_matched(r: @mut TtReader,\n-                                      start: @named_match) -> @named_match {\n+pure fn lookup_cur_matched_by_matched(r: &mut TtReader,\n+                                      start: @named_match)\n+                                   -> @named_match {\n     pure fn red(+ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n           matched_nonterminal(_) => {\n@@ -117,18 +118,20 @@ pure fn lookup_cur_matched_by_matched(r: @mut TtReader,\n           matched_seq(ref ads, _) => ads[*idx]\n         }\n     }\n-    vec::foldl(start, r.repeat_idx, red)\n+    let r = &mut *r;\n+    let repeat_idx = &r.repeat_idx;\n+    vec::foldl(start, *repeat_idx, red)\n }\n \n-fn lookup_cur_matched(r: @mut TtReader, name: ident) -> @named_match {\n+fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n     lookup_cur_matched_by_matched(r, r.interpolations.get(&name))\n }\n enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)\n }\n \n-fn lockstep_iter_size(t: token_tree, r: @mut TtReader) -> lis {\n-    fn lis_merge(lhs: lis, rhs: lis, r: @mut TtReader) -> lis {\n+fn lockstep_iter_size(t: token_tree, r: &mut TtReader) -> lis {\n+    fn lis_merge(lhs: lis, rhs: lis, r: &mut TtReader) -> lis {\n         match lhs {\n           lis_unconstrained => copy rhs,\n           lis_contradiction(_) => copy lhs,\n@@ -148,8 +151,10 @@ fn lockstep_iter_size(t: token_tree, r: @mut TtReader) -> lis {\n     }\n     match t {\n       tt_delim(ref tts) | tt_seq(_, ref tts, _, _) => {\n-        vec::foldl(lis_unconstrained, (*tts), |lis, tt|\n-            lis_merge(lis, lockstep_iter_size(*tt, r), r))\n+        vec::foldl(lis_unconstrained, (*tts), |lis, tt| {\n+            let lis2 = lockstep_iter_size(*tt, r);\n+            lis_merge(lis, lis2, r)\n+        })\n       }\n       tt_tok(*) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {\n@@ -160,12 +165,20 @@ fn lockstep_iter_size(t: token_tree, r: @mut TtReader) -> lis {\n }\n \n \n-pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n+pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     let ret_val = TokenAndSpan {\n         tok: copy r.cur_tok,\n         sp: r.cur_span,\n     };\n-    while r.cur.idx >= r.cur.readme.len() {\n+    loop {\n+        {\n+            let cur = &mut *r.cur;\n+            let readme = &mut *cur.readme;\n+            if cur.idx < readme.len() {\n+                break;\n+            }\n+        }\n+\n         /* done with this set; pop or repeat? */\n         if ! r.cur.dotdotdoted\n             || { *r.repeat_idx.last() == *r.repeat_len.last() - 1 } {"}, {"sha": "90f51fe9b65af47c3983aeacb69153221900b5b7", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -811,15 +811,15 @@ pub mod test {\n             sp:span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n         check_equal (tok1,tok2);\n         // the 'main' id is already read:\n-        check_equal (string_reader.last_pos,BytePos(28));\n+        check_equal (copy string_reader.last_pos,BytePos(28));\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n             tok:token::IDENT(ident_interner.intern (@~\"main\"), false),\n             sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n         check_equal (tok3,tok4);\n         // the lparen is already read:\n-        check_equal (string_reader.last_pos,BytePos(29))\n+        check_equal (copy string_reader.last_pos,BytePos(29))\n     }\n \n     // check that the given reader produces the desired stream"}, {"sha": "8a883b73a64a3d5c7c6376d5a602620eeff5ed64", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -412,7 +412,8 @@ pub impl Parser {\n \n     fn parse_purity(&self) -> purity {\n         if self.eat_keyword(&~\"pure\") {\n-            return pure_fn;\n+            // NB: We parse this as impure for bootstrapping purposes.\n+            return impure_fn;\n         } else if self.eat_keyword(&~\"unsafe\") {\n             return unsafe_fn;\n         } else {\n@@ -2668,7 +2669,8 @@ pub impl Parser {\n \n     fn parse_optional_purity(&self) -> ast::purity {\n         if self.eat_keyword(&~\"pure\") {\n-            ast::pure_fn\n+            // NB: We parse this as impure for bootstrapping purposes.\n+            ast::impure_fn\n         } else if self.eat_keyword(&~\"unsafe\") {\n             ast::unsafe_fn\n         } else {\n@@ -3418,7 +3420,8 @@ pub impl Parser {\n \n         let prefix = Path(self.sess.cm.span_to_filename(*self.span));\n         let prefix = prefix.dir_path();\n-        let mod_path = Path(\".\").push_many(*self.mod_path_stack);\n+        let mod_path_stack = &*self.mod_path_stack;\n+        let mod_path = Path(\".\").push_many(*mod_path_stack);\n         let default_path = *self.sess.interner.get(id) + ~\".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             outer_attrs, ~\"path\") {\n@@ -3505,7 +3508,8 @@ pub impl Parser {\n         if self.eat_keyword(&~\"fn\") { impure_fn }\n         else if self.eat_keyword(&~\"pure\") {\n             self.expect_keyword(&~\"fn\");\n-            pure_fn\n+            // NB: We parse this as impure for bootstrapping purposes.\n+            impure_fn\n         } else if self.eat_keyword(&~\"unsafe\") {\n             self.expect_keyword(&~\"fn\");\n             unsafe_fn\n@@ -3894,8 +3898,9 @@ pub impl Parser {\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(&~\"pure\") {\n             // PURE FUNCTION ITEM\n+            // NB: We parse this as impure for bootstrapping purposes.\n             self.expect_keyword(&~\"fn\");\n-            let (ident, item_, extra_attrs) = self.parse_item_fn(pure_fn);\n+            let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));"}, {"sha": "492ecdb3f4de5037a173e6444cc396d73b63684c", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -452,9 +452,10 @@ pub impl Printer {\n         self.pending_indentation += amount;\n     }\n     fn get_top(&mut self) -> print_stack_elt {\n-        let n = self.print_stack.len();\n+        let print_stack = &mut *self.print_stack;\n+        let n = print_stack.len();\n         if n != 0u {\n-            self.print_stack[n - 1u]\n+            print_stack[n - 1u]\n         } else {\n             print_stack_elt {\n                 offset: 0,\n@@ -496,7 +497,8 @@ pub impl Printer {\n           }\n           END => {\n             debug!(\"print END -> pop END\");\n-            fail_unless!((self.print_stack.len() != 0u));\n+            let print_stack = &*self.print_stack;\n+            fail_unless!((print_stack.len() != 0u));\n             self.print_stack.pop();\n           }\n           BREAK(b) => {"}, {"sha": "71f3de174140c4f023ec16a4343b38731f4e392a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -279,9 +279,10 @@ pub fn is_bol(s: @ps) -> bool {\n }\n \n pub fn in_cbox(s: @ps) -> bool {\n-    let len = s.boxes.len();\n+    let boxes = &*s.boxes;\n+    let len = boxes.len();\n     if len == 0u { return false; }\n-    return s.boxes[len - 1u] == pp::consistent;\n+    return boxes[len - 1u] == pp::consistent;\n }\n \n pub fn hardbreak_if_not_bol(s: @ps) { if !is_bol(s) { hardbreak(s.s); } }"}, {"sha": "47f49ebadaabfff0ce399f7eb60bb644b2aefcbd", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -41,14 +41,18 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n             None => (),\n         }\n \n-        let new_idx = self.vect.len();\n+        let vect = &*self.vect;\n+        let new_idx = vect.len();\n         self.map.insert(val, new_idx);\n         self.vect.push(val);\n         new_idx\n     }\n \n     fn gensym(&self, val: T) -> uint {\n-        let new_idx = self.vect.len();\n+        let new_idx = {\n+            let vect = &*self.vect;\n+            vect.len()\n+        };\n         // leave out of .map to avoid colliding\n         self.vect.push(val);\n         new_idx\n@@ -59,7 +63,7 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n     pure fn get(&self, idx: uint) -> T { self.vect[idx] }\n \n-    fn len(&self) -> uint { self.vect.len() }\n+    fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n }\n \n #[test]"}, {"sha": "bd1001bf38cb704c0c2d9719ccf29da8071b4ded", "filename": "src/test/compile-fail/borrowck-pat-enum-in-box.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-enum-in-box.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -22,17 +22,6 @@ fn match_const_box(v: &const @const Option<int>) -> int {\n     }\n }\n \n-pure fn pure_process(_i: int) {}\n-\n-fn match_const_box_and_do_pure_things(v: &const @const Option<int>) {\n-    match *v {\n-      @Some(ref i) => {\n-        pure_process(*i)\n-      }\n-      @None => {}\n-    }\n-}\n-\n fn process(_i: int) {}\n \n fn match_const_box_and_do_bad_things(v: &const @const Option<int>) {"}, {"sha": "7ff13739ba7e67af9a02f3510b81ec3d450e0357", "filename": "src/test/compile-fail/borrowck-pure-scope-in-call.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs?ref=c4db4faefaf13ac814f34c2a6cf105b7684de019", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pure fn pure_borrow(_x: &int, _y: ()) {}\n-\n-fn test1(x: @mut ~int) {\n-    // Here, evaluating the second argument actually invalidates the\n-    // first borrow, even though it occurs outside of the scope of the\n-    // borrow!\n-    pure_borrow(*x, *x = ~5);  //~ ERROR illegal borrow unless pure\n-    //~^ NOTE impure due to assigning to dereference of mutable @ pointer\n-}\n-\n-fn test2() {\n-    let mut x = ~1;\n-\n-    // Same, but for loanable data:\n-\n-    pure_borrow(x, x = ~5);  //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n-    //~^ NOTE loan of mutable local variable granted here\n-\n-    copy x;\n-}\n-\n-fn main() {\n-}"}, {"sha": "c60eec6edd55588397939a81eb4f959e589ceb73", "filename": "src/test/compile-fail/nontrivial-fn-arg-pattern-in-pure-fn.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fnontrivial-fn-arg-pattern-in-pure-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fnontrivial-fn-arg-pattern-in-pure-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnontrivial-fn-arg-pattern-in-pure-fn.rs?ref=c4db4faefaf13ac814f34c2a6cf105b7684de019", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pure fn call_first((x, _y): (&fn(), &fn())) {\n-    x();    //~ ERROR access to impure function prohibited in pure context\n-}\n-\n-fn main() {}\n-"}, {"sha": "6d262bc04e1e482a77bf8ada93868dffc5e3a07a", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=c4db4faefaf13ac814f34c2a6cf105b7684de019", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[legacy_modes];\n-\n-// Test rules governing higher-order pure fns.\n-\n-struct S<'self> {\n-    f: &'self fn(uint)\n-}\n-\n-pure fn range(from: uint, to: uint, f: &fn(uint)) {\n-    let mut i = from;\n-    while i < to {\n-        f(i); // Note: legal to call argument, even if it is not pure.\n-        i += 1u;\n-    }\n-}\n-\n-pure fn range2(from: uint, to: uint, f: &fn(uint)) {\n-    do range(from, to) |i| {\n-        f(i*2u);\n-    }\n-}\n-\n-pure fn range3(from: uint, to: uint, f: &fn(uint)) {\n-    range(from, to, f)\n-}\n-\n-pure fn range4(from: uint, to: uint) {\n-    range(from, to, print) //~ ERROR access to impure function prohibited in pure context\n-}\n-\n-pure fn range5<'a>(from: uint, to: uint, x: S<'a>) {\n-    range(from, to, x.f) //~ ERROR access to impure function prohibited in pure context\n-}\n-\n-pure fn range6<'a>(from: uint, to: uint, x: @S<'a>) {\n-    range(from, to, x.f) //~ ERROR access to impure function prohibited in pure context\n-}\n-\n-pure fn range7(from: uint, to: uint) {\n-    do range(from, to) |i| {\n-        print(i); //~ ERROR access to impure function prohibited in pure context\n-    }\n-}\n-\n-pure fn range8(from: uint, to: uint) {\n-    range(from, to, noop);\n-}\n-\n-fn print(i: uint) { error!(\"i=%u\", i); }\n-\n-pure fn noop(_i: uint) {}\n-\n-fn main() {\n-}"}, {"sha": "43a54981dcb7126ee49e0d76968305cf0081f95c", "filename": "src/test/compile-fail/pure-loop-body.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-loop-body.rs?ref=c4db4faefaf13ac814f34c2a6cf105b7684de019", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct S<'self> {\n-    x: &'self fn(uint)\n-}\n-\n-pure fn range<'a>(from: uint, to: uint, f: &'a fn(uint) -> bool) {\n-    let mut i = from;\n-    while i < to {\n-        if !f(i) {return;} // Note: legal to call argument, even if it is not pure.\n-        i += 1u;\n-    }\n-}\n-\n-pure fn range2<'a>(from: uint, to: uint, f: &'a fn(uint)) {\n-    for range(from, to) |i| {\n-        f(i*2u);\n-    }\n-}\n-\n-pure fn range3<'a>(from: uint, to: uint, f: S<'a>) {\n-    for range(from, to) |i| {\n-        (f.x)(i*2u); //~ ERROR access to impure function prohibited\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "4bd56c6e78b01efbaa285d4f23e711ed01cbf611", "filename": "src/test/compile-fail/pure-modifies-aliased.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-modifies-aliased.rs?ref=c4db4faefaf13ac814f34c2a6cf105b7684de019", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check that pure functions cannot modify aliased state.\n-\n-struct S {\n-    f: int,\n-}\n-\n-pure fn modify_in_box(sum: @mut S) {\n-    sum.f = 3; //~ ERROR assigning to mutable field prohibited in pure context\n-}\n-\n-trait modify_in_box_rec {\n-    pure fn modify_in_box_rec(&self, sum: @mut S);\n-}\n-\n-impl modify_in_box_rec for int {\n-    pure fn modify_in_box_rec(&self, sum: @mut S) {\n-        sum.f = *self; //~ ERROR assigning to mutable field prohibited in pure context\n-    }\n-}\n-\n-fn main() {\n-}"}, {"sha": "2744afb113d5fc112fd6ede03fc7f1c56905b691", "filename": "src/test/compile-fail/pure-subtyping.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpure-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpure-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-subtyping.rs?ref=c4db4faefaf13ac814f34c2a6cf105b7684de019", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test rules governing higher-order pure fns.\n-\n-fn take<T>(_v: T) {}\n-\n-fn assign_to_pure(x: &pure fn(), y: &fn(), z: &unsafe fn()) {\n-    take::<&pure fn()>(x);\n-    take::<&pure fn()>(y); //~ ERROR expected pure fn but found impure fn\n-    take::<&pure fn()>(z); //~ ERROR expected pure fn but found unsafe fn\n-}\n-\n-fn assign_to_impure(x: &pure fn(), y: &fn(), z: &unsafe fn()) {\n-    take::<&fn()>(x);\n-    take::<&fn()>(y);\n-    take::<&fn()>(z); //~ ERROR expected impure fn but found unsafe fn\n-}\n-\n-fn assign_to_unsafe(x: &pure fn(), y: &fn(), z: &unsafe fn()) {\n-    take::<&unsafe fn()>(x);\n-    take::<&unsafe fn()>(y);\n-    take::<&unsafe fn()>(z);\n-}\n-\n-fn assign_to_pure2(x: @pure fn(), y: @fn(), z: @unsafe fn()) {\n-    take::<&pure fn()>(x);\n-    take::<&pure fn()>(y); //~ ERROR expected pure fn but found impure fn\n-    take::<&pure fn()>(z); //~ ERROR expected pure fn but found unsafe fn\n-\n-    take::<~pure fn()>(x); //~ ERROR expected ~ closure, found @ closure\n-    take::<~pure fn()>(y); //~ ERROR expected ~ closure, found @ closure\n-    take::<~pure fn()>(z); //~ ERROR expected ~ closure, found @ closure\n-\n-    take::<~unsafe fn()>(x); //~ ERROR expected ~ closure, found @ closure\n-    take::<~unsafe fn()>(y); //~ ERROR expected ~ closure, found @ closure\n-    take::<~unsafe fn()>(z); //~ ERROR expected ~ closure, found @ closure\n-}\n-\n-fn main() {\n-}"}, {"sha": "3e5296530fa35c11772c0cc6966793f3a36e29ba", "filename": "src/test/compile-fail/purity-infer-fail.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4db4faefaf13ac814f34c2a6cf105b7684de019/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs?ref=c4db4faefaf13ac814f34c2a6cf105b7684de019", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn something(f: &pure fn()) { f(); }\n-\n-fn main() {\n-    let mut x = ~[];\n-    something(|| x.push(0) ); //~ ERROR access to impure function prohibited in pure context\n-}"}, {"sha": "6676cde3c96a6055726539c948798ed5ea3e80e0", "filename": "src/test/compile-fail/trait-impl-method-mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -9,15 +9,15 @@\n // except according to those terms.\n \n trait Mumbo {\n-    pure fn jumbo(&self, x: @uint) -> uint;\n+    fn jumbo(&self, x: @uint) -> uint;\n     fn jambo(&self, x: @const uint) -> uint;\n     fn jbmbo(&self) -> @uint;\n }\n \n impl Mumbo for uint {\n     // Cannot have a larger effect than the trait:\n-    fn jumbo(&self, x: @uint) { *self + *x; }\n-    //~^ ERROR expected pure fn but found impure fn\n+    unsafe fn jumbo(&self, x: @uint) { *self + *x; }\n+    //~^ ERROR expected impure fn but found unsafe fn\n \n     // Cannot accept a narrower range of parameters:\n     fn jambo(&self, x: @uint) { *self + *x; }"}, {"sha": "39fe34bfe528658271be116ba3922394e7b2c278", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -39,7 +39,6 @@ pub fn main() {\n     (&\"test\").test_imm();\n \n     // XXX: Other types of mutable vecs don't currently exist\n-    (@mut [1]).test_imm();\n \n     ([1]).test_const();\n     (~[1]).test_const();\n@@ -50,8 +49,6 @@ pub fn main() {\n     (@\"test\").test_const();\n     (&\"test\").test_const();\n \n-    (@mut [1]).test_const();\n-\n     // NB: We don't do this double autoreffing for &mut self because that would\n     // allow creating a mutable pointer to a temporary, which would be a source\n     // of confusion"}, {"sha": "a0a4ea19964f7d7eab5adb17f818074cead14e3d", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -62,8 +62,8 @@ impl<T> BaseIter<(int, &'self T)> for cat<T> {\n }\n \n impl<T> Container for cat<T> {\n-    pure fn len(&self) -> uint { self.meows as uint }\n-    pure fn is_empty(&self) -> bool { self.meows == 0 }\n+    pure fn len(&const self) -> uint { self.meows as uint }\n+    pure fn is_empty(&const self) -> bool { self.meows == 0 }\n }\n \n impl<T> Mutable for cat<T> {"}, {"sha": "905046756f6ee9126fe7729d38f5f256067fd16b", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-arg.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-arg.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -10,8 +10,4 @@ fn negate_imm(y: &int) -> int {\n     negate(y)\n }\n \n-fn negate_const(y: &const int) -> int {\n-    negate(y)\n-}\n-\n pub fn main() {}"}, {"sha": "54d9758aa214546a583c780bd72f772b29284437", "filename": "src/test/run-pass/coerce-reborrow-imm-ptr-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-ptr-rcvr.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -3,7 +3,7 @@ struct SpeechMaker {\n }\n \n pub impl SpeechMaker {\n-    pure fn how_many(&self) -> uint { self.speeches }\n+    pure fn how_many(&const self) -> uint { self.speeches }\n }\n \n fn foo(speaker: &const SpeechMaker) -> uint {"}, {"sha": "a18b4a2b0c6919148258404712b0a182a2c13706", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n pure fn sum(x: &[int]) -> int {\n     let mut sum = 0;\n     for x.each |y| { sum += *y; }"}, {"sha": "bf86472d900d78ae6975c2ecdb54fb91603cf855", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n fn foo(v: &[const uint]) -> ~[uint] {\n     v.to_vec()\n }"}, {"sha": "2e70e900389719851cee7d4727f910da84a0671b", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78f2e2ac577f9c47cd58af52d3bcd496254545d/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=e78f2e2ac577f9c47cd58af52d3bcd496254545d", "patch": "@@ -16,6 +16,6 @@ struct Refs { refs: ~[int], n: int }\n \n pub fn main() {\n     let e = @mut Refs{refs: ~[], n: 0};\n-    let f: @fn() = || error!(e.n);\n+    let f: @fn() = || error!(copy e.n);\n     e.refs += ~[1];\n }"}]}