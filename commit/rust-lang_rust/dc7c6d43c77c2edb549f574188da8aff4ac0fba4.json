{"sha": "dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "node_id": "C_kwDOAAsO6NoAKGRjN2M2ZDQzYzc3YzJlZGI1NDlmNTc0MTg4ZGE4YWZmNGFjMGZiYTQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T12:46:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T12:46:36Z"}, "message": "Slightly shrink `DefMap`", "tree": {"sha": "68fbbee7c881b83b6cf0f9f4e00516689244b7fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68fbbee7c881b83b6cf0f9f4e00516689244b7fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "html_url": "https://github.com/rust-lang/rust/commit/dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "117f9b7752120a629283f9cdcc3f50b622aa070b", "url": "https://api.github.com/repos/rust-lang/rust/commits/117f9b7752120a629283f9cdcc3f50b622aa070b", "html_url": "https://github.com/rust-lang/rust/commit/117f9b7752120a629283f9cdcc3f50b622aa070b"}], "stats": {"total": 222, "additions": 130, "deletions": 92}, "files": [{"sha": "7055e3ca9e2b8ae2d9af1750481d909976d11dc4", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -1073,7 +1073,7 @@ impl ExprCollector<'_> {\n             match block_id.map(|block_id| (self.db.block_def_map(block_id), block_id)) {\n                 Some((def_map, block_id)) => {\n                     self.body.block_scopes.push(block_id);\n-                    (def_map.module_id(def_map.root()), def_map)\n+                    (def_map.module_id(DefMap::ROOT), def_map)\n                 }\n                 None => (self.expander.module, self.def_map.clone()),\n             };"}, {"sha": "bb79e28f2673a0d1e50f9f050d4d70759e1608dc", "filename": "crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -12,6 +12,7 @@ use crate::{\n     db::DefDatabase,\n     dyn_map::{keys, DynMap},\n     item_scope::ItemScope,\n+    nameres::DefMap,\n     src::{HasChildSource, HasSource},\n     AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, FieldId, ImplId, Lookup, MacroId,\n     ModuleDefId, ModuleId, TraitId, VariantId,\n@@ -205,7 +206,7 @@ impl ChildBySource for DefWithBodyId {\n         for (_, def_map) in body.blocks(db) {\n             // All block expressions are merged into the same map, because they logically all add\n             // inner items to the containing `DefWithBodyId`.\n-            def_map[def_map.root()].scope.child_by_source_to(db, res, file_id);\n+            def_map[DefMap::ROOT].scope.child_by_source_to(db, res, file_id);\n         }\n     }\n }"}, {"sha": "6d18e3f56cabc63215f52441a953eff1ccffda4a", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -198,15 +198,14 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n \n     // endregion:attrs\n \n-    #[salsa::invoke(LangItems::crate_lang_items_query)]\n-    fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n-\n     #[salsa::invoke(LangItems::lang_item_query)]\n     fn lang_item(&self, start_crate: CrateId, item: LangItem) -> Option<LangItemTarget>;\n \n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n \n+    // region:visibilities\n+\n     #[salsa::invoke(visibility::field_visibilities_query)]\n     fn field_visibilities(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Visibility>>;\n \n@@ -217,8 +216,14 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n     #[salsa::invoke(visibility::const_visibility_query)]\n     fn const_visibility(&self, def: ConstId) -> Visibility;\n \n+    // endregion:visibilities\n+\n+    #[salsa::invoke(LangItems::crate_lang_items_query)]\n+    fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n+\n     #[salsa::transparent]\n     fn crate_limits(&self, crate_id: CrateId) -> CrateLimits;\n+\n     #[salsa::transparent]\n     fn recursion_limit(&self, crate_id: CrateId) -> u32;\n "}, {"sha": "ec150dc0689c2fe8331c39bce0dc75c602d5682f", "filename": "crates/hir-def/src/import_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fimport_map.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -11,8 +11,8 @@ use rustc_hash::{FxHashSet, FxHasher};\n use triomphe::Arc;\n \n use crate::{\n-    db::DefDatabase, item_scope::ItemInNs, visibility::Visibility, AssocItemId, ModuleDefId,\n-    ModuleId, TraitId,\n+    db::DefDatabase, item_scope::ItemInNs, nameres::DefMap, visibility::Visibility, AssocItemId,\n+    ModuleDefId, ModuleId, TraitId,\n };\n \n type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n@@ -183,7 +183,7 @@ fn collect_import_map(db: &dyn DefDatabase, krate: CrateId) -> ImportMap {\n \n     // We look only into modules that are public(ly reexported), starting with the crate root.\n     let empty = ImportPath { segments: vec![] };\n-    let root = def_map.module_id(def_map.root());\n+    let root = def_map.module_id(DefMap::ROOT);\n     let mut worklist = vec![(root, empty)];\n     while let Some((module, mod_path)) = worklist.pop() {\n         let ext_def_map;"}, {"sha": "4a62696df0810a354ce69a47d32919a4da4a80d8", "filename": "crates/hir-def/src/macro_expansion_tests/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -35,7 +35,7 @@ use tt::token_id::{Subtree, TokenId};\n use crate::{\n     db::DefDatabase,\n     macro_id_to_def_id,\n-    nameres::{MacroSubNs, ModuleSource},\n+    nameres::{DefMap, MacroSubNs, ModuleSource},\n     resolver::HasResolver,\n     src::HasSource,\n     test_db::TestDB,\n@@ -61,7 +61,7 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n     let db = TestDB::with_files_extra_proc_macros(ra_fixture, extra_proc_macros);\n     let krate = db.crate_graph().iter().next().unwrap();\n     let def_map = db.crate_def_map(krate);\n-    let local_id = def_map.root();\n+    let local_id = DefMap::ROOT;\n     let module = def_map.module_id(local_id);\n     let resolver = module.resolver(&db);\n     let source = def_map[local_id].definition_source(&db);"}, {"sha": "053ab5890e4f6a7d6eb6d2e1668096e4932c5f52", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -94,7 +94,6 @@ use crate::{\n pub struct DefMap {\n     _c: Count<Self>,\n     block: Option<BlockInfo>,\n-    root: LocalModuleId,\n     modules: Arena<ModuleData>,\n     krate: CrateId,\n     /// The prelude module for this crate. This either comes from an import\n@@ -141,7 +140,19 @@ struct BlockInfo {\n     /// The `BlockId` this `DefMap` was created from.\n     block: BlockId,\n     /// The containing module.\n-    parent: ModuleId,\n+    parent: BlockRelativeModuleId,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+struct BlockRelativeModuleId {\n+    block: Option<BlockId>,\n+    local_id: LocalModuleId,\n+}\n+\n+impl BlockRelativeModuleId {\n+    fn def_map(self, db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {\n+        ModuleId { krate, block: self.block, local_id: self.local_id }.def_map(db)\n+    }\n }\n \n impl std::ops::Index<LocalModuleId> for DefMap {\n@@ -231,6 +242,8 @@ pub struct ModuleData {\n }\n \n impl DefMap {\n+    pub const ROOT: LocalModuleId = LocalModuleId::from_raw(la_arena::RawIdx::from_u32(0));\n+\n     pub(crate) fn crate_def_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {\n         let _p = profile::span(\"crate_def_map_query\").detail(|| {\n             db.crate_graph()[krate].display_name.as_deref().unwrap_or_default().to_string()\n@@ -266,7 +279,13 @@ impl DefMap {\n             ModuleData::new(ModuleOrigin::BlockExpr { block: block.ast_id }, visibility);\n \n         let mut def_map = DefMap::empty(krate, parent_map.edition, module_data);\n-        def_map.block = Some(BlockInfo { block: block_id, parent: block.module });\n+        def_map.block = Some(BlockInfo {\n+            block: block_id,\n+            parent: BlockRelativeModuleId {\n+                block: block.module.block,\n+                local_id: block.module.local_id,\n+            },\n+        });\n \n         let def_map = collector::collect_defs(db, def_map, tree_id);\n         Arc::new(def_map)\n@@ -275,6 +294,7 @@ impl DefMap {\n     fn empty(krate: CrateId, edition: Edition, module_data: ModuleData) -> DefMap {\n         let mut modules: Arena<ModuleData> = Arena::default();\n         let root = modules.alloc(module_data);\n+        assert_eq!(root, Self::ROOT);\n \n         DefMap {\n             _c: Count::new(),\n@@ -289,7 +309,6 @@ impl DefMap {\n             proc_macro_loading_error: None,\n             derive_helpers_in_scope: FxHashMap::default(),\n             prelude: None,\n-            root,\n             modules,\n             registered_attrs: Vec::new(),\n             registered_tools: Vec::new(),\n@@ -339,10 +358,6 @@ impl DefMap {\n         self.no_std || self.no_core\n     }\n \n-    pub fn root(&self) -> LocalModuleId {\n-        self.root\n-    }\n-\n     pub fn fn_as_proc_macro(&self, id: FunctionId) -> Option<ProcMacroId> {\n         self.fn_proc_macro_mapping.get(&id).copied()\n     }\n@@ -377,9 +392,9 @@ impl DefMap {\n     }\n \n     pub(crate) fn crate_root(&self, db: &dyn DefDatabase) -> ModuleId {\n-        self.with_ancestor_maps(db, self.root, &mut |def_map, _module| {\n+        self.with_ancestor_maps(db, Self::ROOT, &mut |def_map, _module| {\n             if def_map.block.is_none() {\n-                Some(def_map.module_id(def_map.root))\n+                Some(def_map.module_id(Self::ROOT))\n             } else {\n                 None\n             }\n@@ -439,7 +454,7 @@ impl DefMap {\n         }\n         let mut block = self.block;\n         while let Some(block_info) = block {\n-            let parent = block_info.parent.def_map(db);\n+            let parent = block_info.parent.def_map(db, self.krate);\n             if let Some(it) = f(&parent, block_info.parent.local_id) {\n                 return Some(it);\n             }\n@@ -452,15 +467,22 @@ impl DefMap {\n     /// If this `DefMap` is for a block expression, returns the module containing the block (which\n     /// might again be a block, or a module inside a block).\n     pub fn parent(&self) -> Option<ModuleId> {\n-        Some(self.block?.parent)\n+        let BlockRelativeModuleId { block, local_id } = self.block?.parent;\n+        Some(ModuleId { krate: self.krate, block, local_id })\n     }\n \n     /// Returns the module containing `local_mod`, either the parent `mod`, or the module (or block) containing\n     /// the block, if `self` corresponds to a block expression.\n     pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {\n         match self[local_mod].parent {\n             Some(parent) => Some(self.module_id(parent)),\n-            None => self.block.map(|block| block.parent),\n+            None => {\n+                self.block.map(\n+                    |BlockInfo { parent: BlockRelativeModuleId { block, local_id }, .. }| {\n+                        ModuleId { krate: self.krate, block, local_id }\n+                    },\n+                )\n+            }\n         }\n     }\n \n@@ -471,12 +493,12 @@ impl DefMap {\n         let mut arc;\n         let mut current_map = self;\n         while let Some(block) = current_map.block {\n-            go(&mut buf, db, current_map, \"block scope\", current_map.root);\n+            go(&mut buf, db, current_map, \"block scope\", Self::ROOT);\n             buf.push('\\n');\n-            arc = block.parent.def_map(db);\n+            arc = block.parent.def_map(db, self.krate);\n             current_map = &arc;\n         }\n-        go(&mut buf, db, current_map, \"crate\", current_map.root);\n+        go(&mut buf, db, current_map, \"crate\", Self::ROOT);\n         return buf;\n \n         fn go(\n@@ -506,7 +528,7 @@ impl DefMap {\n         let mut current_map = self;\n         while let Some(block) = current_map.block {\n             format_to!(buf, \"{:?} in {:?}\\n\", block.block, block.parent);\n-            arc = block.parent.def_map(db);\n+            arc = block.parent.def_map(db, self.krate);\n             current_map = &arc;\n         }\n \n@@ -534,7 +556,6 @@ impl DefMap {\n             recursion_limit: _,\n             krate: _,\n             prelude: _,\n-            root: _,\n             rustc_coherence_is_core: _,\n             no_core: _,\n             no_std: _,"}, {"sha": "b431b6f64739c8ee5ad90f2e18793d3f5323f9e7", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -71,7 +71,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n     for dep in &krate.dependencies {\n         tracing::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.crate_id);\n         let dep_def_map = db.crate_def_map(dep.crate_id);\n-        let dep_root = dep_def_map.module_id(dep_def_map.root);\n+        let dep_root = dep_def_map.module_id(DefMap::ROOT);\n \n         deps.insert(dep.as_name(), dep_root);\n \n@@ -287,7 +287,7 @@ impl DefCollector<'_> {\n \n         let file_id = self.db.crate_graph()[self.def_map.krate].root_file_id;\n         let item_tree = self.db.file_item_tree(file_id.into());\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n \n         let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);\n \n@@ -382,7 +382,7 @@ impl DefCollector<'_> {\n \n     fn seed_with_inner(&mut self, tree_id: TreeId) {\n         let item_tree = tree_id.item_tree(self.db);\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n \n         let is_cfg_enabled = item_tree\n             .top_level_attrs(self.db, self.def_map.krate)\n@@ -464,7 +464,7 @@ impl DefCollector<'_> {\n             // Additionally, while the proc macro entry points must be `pub`, they are not publicly\n             // exported in type/value namespace. This function reduces the visibility of all items\n             // in the crate root that aren't proc macros.\n-            let root = self.def_map.root;\n+            let root = DefMap::ROOT;\n             let module_id = self.def_map.module_id(root);\n             let root = &mut self.def_map.modules[root];\n             root.scope.censor_non_proc_macros(module_id);\n@@ -560,13 +560,8 @@ impl DefCollector<'_> {\n         };\n         let path = ModPath::from_segments(path_kind, [krate, name![prelude], edition]);\n \n-        let (per_ns, _) = self.def_map.resolve_path(\n-            self.db,\n-            self.def_map.root,\n-            &path,\n-            BuiltinShadowMode::Other,\n-            None,\n-        );\n+        let (per_ns, _) =\n+            self.def_map.resolve_path(self.db, DefMap::ROOT, &path, BuiltinShadowMode::Other, None);\n \n         match per_ns.types {\n             Some((ModuleDefId::ModuleId(m), _)) => {\n@@ -661,7 +656,7 @@ impl DefCollector<'_> {\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            let module_id = self.def_map.root;\n+            let module_id = DefMap::ROOT;\n             self.def_map.modules[module_id].scope.declare(macro_.into());\n             self.update(\n                 module_id,\n@@ -712,7 +707,7 @@ impl DefCollector<'_> {\n     /// A proc macro is similar to normal macro scope, but it would not visible in legacy textual scoped.\n     /// And unconditionally exported.\n     fn define_proc_macro(&mut self, name: Name, macro_: ProcMacroId) {\n-        let module_id = self.def_map.root;\n+        let module_id = DefMap::ROOT;\n         self.def_map.modules[module_id].scope.declare(macro_.into());\n         self.update(\n             module_id,\n@@ -732,7 +727,7 @@ impl DefCollector<'_> {\n         let def_map = self.db.crate_def_map(krate);\n         // `#[macro_use]` brings macros into macro_use prelude. Yes, even non-`macro_rules!`\n         // macros.\n-        let root_scope = &def_map[def_map.root].scope;\n+        let root_scope = &def_map[DefMap::ROOT].scope;\n         if let Some(names) = names {\n             for name in names {\n                 // FIXME: Report diagnostic on 404.\n@@ -834,9 +829,9 @@ impl DefCollector<'_> {\n             let root = match self.def_map.block {\n                 Some(_) => {\n                     let def_map = self.def_map.crate_root(self.db).def_map(self.db);\n-                    def_map.module_id(def_map.root())\n+                    def_map.module_id(DefMap::ROOT)\n                 }\n-                None => self.def_map.module_id(self.def_map.root()),\n+                None => self.def_map.module_id(DefMap::ROOT),\n             };\n             Some(root)\n         } else {\n@@ -879,7 +874,7 @@ impl DefCollector<'_> {\n                 // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n                 if import.is_extern_crate\n                     && self.def_map.block.is_none()\n-                    && module_id == self.def_map.root\n+                    && module_id == DefMap::ROOT\n                 {\n                     if let (Some(ModuleDefId::ModuleId(def)), Some(name)) = (def.take_types(), name)\n                     {\n@@ -1525,7 +1520,7 @@ impl ModCollector<'_, '_> {\n \n     fn collect(&mut self, items: &[ModItem], container: ItemContainerId) {\n         let krate = self.def_collector.def_map.krate;\n-        let is_crate_root = self.module_id == self.def_collector.def_map.root;\n+        let is_crate_root = self.module_id == DefMap::ROOT;\n \n         // Note: don't assert that inserted value is fresh: it's simply not true\n         // for macros.\n@@ -1641,9 +1636,9 @@ impl ModCollector<'_, '_> {\n                         FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n-                    if self.def_collector.is_proc_macro && self.module_id == def_map.root {\n+                    if self.def_collector.is_proc_macro && self.module_id == DefMap::ROOT {\n                         if let Some(proc_macro) = attrs.parse_proc_macro_decl(&it.name) {\n-                            let crate_root = def_map.module_id(def_map.root);\n+                            let crate_root = def_map.module_id(DefMap::ROOT);\n                             self.def_collector.export_proc_macro(\n                                 proc_macro,\n                                 ItemTreeId::new(self.tree_id, id),"}, {"sha": "751536db3848f7c2d76fc914099a42d9da1d653a", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -121,7 +121,7 @@ impl DefMap {\n             // ...unless we're resolving visibility for an associated item in an impl.\n             if self.block_id() != m.block && !within_impl {\n                 cov_mark::hit!(adjust_vis_in_block_def_map);\n-                vis = Visibility::Module(self.module_id(self.root()));\n+                vis = Visibility::Module(self.module_id(Self::ROOT));\n                 tracing::debug!(\"visibility {:?} points outside DefMap, adjusting to {:?}\", m, vis);\n             }\n         }\n@@ -173,7 +173,7 @@ impl DefMap {\n             match &current_map.block {\n                 Some(block) => {\n                     original_module = block.parent.local_id;\n-                    arc = block.parent.def_map(db);\n+                    arc = block.parent.def_map(db, current_map.krate);\n                     current_map = &*arc;\n                 }\n                 None => return result,\n@@ -207,7 +207,7 @@ impl DefMap {\n                     PerNs::types(self.crate_root(db).into(), Visibility::Public)\n                 } else {\n                     let def_map = db.crate_def_map(krate);\n-                    let module = def_map.module_id(def_map.root);\n+                    let module = def_map.module_id(Self::ROOT);\n                     cov_mark::hit!(macro_dollar_crate_other);\n                     PerNs::types(module.into(), Visibility::Public)\n                 }\n@@ -268,14 +268,17 @@ impl DefMap {\n                                     path.display(db.upcast()),\n                                     new_path.display(db.upcast())\n                                 );\n-                                return block.parent.def_map(db).resolve_path_fp_with_macro(\n-                                    db,\n-                                    mode,\n-                                    block.parent.local_id,\n-                                    &new_path,\n-                                    shadow,\n-                                    expected_macro_subns,\n-                                );\n+                                return block\n+                                    .parent\n+                                    .def_map(db, self.krate)\n+                                    .resolve_path_fp_with_macro(\n+                                        db,\n+                                        mode,\n+                                        block.parent.local_id,\n+                                        &new_path,\n+                                        shadow,\n+                                        expected_macro_subns,\n+                                    );\n                             }\n                             None => {\n                                 tracing::debug!(\"super path in root module\");\n@@ -476,9 +479,9 @@ impl DefMap {\n         let from_crate_root = match self.block {\n             Some(_) => {\n                 let def_map = self.crate_root(db).def_map(db);\n-                def_map[def_map.root].scope.get(name)\n+                def_map[Self::ROOT].scope.get(name)\n             }\n-            None => self[self.root].scope.get(name),\n+            None => self[Self::ROOT].scope.get(name),\n         };\n         let from_extern_prelude = || {\n             self.resolve_name_in_extern_prelude(db, name)"}, {"sha": "ae509de05633efdc41bbc20226e34f6f9ff2e28f", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -750,7 +750,7 @@ macro_rules! foo {\n pub use core::clone::Clone;\n \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n }\n \n #[test]\n@@ -772,7 +772,7 @@ pub macro Copy {}\n pub macro Clone {}\n \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 2);\n }\n \n #[test]\n@@ -815,7 +815,7 @@ pub macro derive($item:item) {}\n pub macro Clone {}\n \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n }\n \n #[test]\n@@ -1286,7 +1286,7 @@ fn proc_attr(a: TokenStream, b: TokenStream) -> TokenStream { a }\n     let krate = db.crate_graph().iter().next().unwrap();\n     let def_map = db.crate_def_map(krate);\n \n-    let root_module = &def_map[def_map.root()].scope;\n+    let root_module = &def_map[DefMap::ROOT].scope;\n     assert!(\n         root_module.legacy_macros().count() == 0,\n         \"`#[macro_use]` shouldn't bring macros into textual macro scope\",\n@@ -1392,7 +1392,7 @@ macro_rules! derive { () => {} }\n struct S;\n     \"#,\n     );\n-    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+    assert_eq!(map.modules[DefMap::ROOT].scope.impls().len(), 1);\n }\n \n #[test]"}, {"sha": "06f5b2526a459a1c701efdd3abc7e4a7b16eb31f", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -586,8 +586,9 @@ impl Resolver {\n             }));\n             if let Some(block) = expr_scopes.block(scope_id) {\n                 let def_map = db.block_def_map(block);\n-                let root = def_map.root();\n-                resolver.scopes.push(Scope::BlockScope(ModuleItemMap { def_map, module_id: root }));\n+                resolver\n+                    .scopes\n+                    .push(Scope::BlockScope(ModuleItemMap { def_map, module_id: DefMap::ROOT }));\n                 // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n                 // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n                 // innermost module scope instead?\n@@ -753,8 +754,7 @@ fn resolver_for_scope_(\n     for scope in scope_chain.into_iter().rev() {\n         if let Some(block) = scopes.block(scope) {\n             let def_map = db.block_def_map(block);\n-            let root = def_map.root();\n-            r = r.push_block_scope(def_map, root);\n+            r = r.push_block_scope(def_map, DefMap::ROOT);\n             // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n             // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n             // innermost module scope instead?"}, {"sha": "a6befc8a81a81bd59e1c8641b755ee46bba4ce23", "filename": "crates/hir-def/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -110,7 +110,7 @@ impl TestDB {\n                 }\n                 _ => {\n                     // FIXME: handle `mod` inside block expression\n-                    return def_map.module_id(def_map.root());\n+                    return def_map.module_id(DefMap::ROOT);\n                 }\n             }\n         }\n@@ -119,7 +119,7 @@ impl TestDB {\n     /// Finds the smallest/innermost module in `def_map` containing `position`.\n     fn mod_at_position(&self, def_map: &DefMap, position: FilePosition) -> LocalModuleId {\n         let mut size = None;\n-        let mut res = def_map.root();\n+        let mut res = DefMap::ROOT;\n         for (module, data) in def_map.modules() {\n             let src = data.definition_source(self);\n             if src.file_id != position.file_id.into() {"}, {"sha": "32f50cb051dbcecf513a883e393c0cf8acb0bec1", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_scope::ItemInNs,\n     lang_item::{LangItem, LangItemTarget},\n+    nameres::DefMap,\n     path::{Path, PathKind},\n     type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n@@ -1488,7 +1489,7 @@ pub fn write_visibility(\n         Visibility::Public => write!(f, \"pub \"),\n         Visibility::Module(vis_id) => {\n             let def_map = module_id.def_map(f.db.upcast());\n-            let root_module_id = def_map.module_id(def_map.root());\n+            let root_module_id = def_map.module_id(DefMap::ROOT);\n             if vis_id == module_id {\n                 // pub(self) or omitted\n                 Ok(())"}, {"sha": "9a2090ab79a2cf54b11cd2a13b7214860655905a", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -548,7 +548,7 @@ impl HirDisplay for Module {\n         // FIXME: Module doesn't have visibility saved in data.\n         match self.name(f.db) {\n             Some(name) => write!(f, \"mod {}\", name.display(f.db.upcast())),\n-            None if self.is_crate_root(f.db) => match self.krate(f.db).display_name(f.db) {\n+            None if self.is_crate_root() => match self.krate(f.db).display_name(f.db) {\n                 Some(name) => write!(f, \"extern crate {name}\"),\n                 None => f.write_str(\"extern crate {unknown}\"),\n             },"}, {"sha": "19709bb44ad458dfb4dfc13af7eab04f5f6b8c04", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -118,7 +118,7 @@ pub use {\n         find_path::PrefixKind,\n         import_map,\n         lang_item::LangItem,\n-        nameres::ModuleSource,\n+        nameres::{DefMap, ModuleSource},\n         path::{ModPath, PathKind},\n         type_ref::{Mutability, TypeRef},\n         visibility::Visibility,\n@@ -202,7 +202,7 @@ impl Crate {\n \n     pub fn root_module(self, db: &dyn HirDatabase) -> Module {\n         let def_map = db.crate_def_map(self.id);\n-        Module { id: def_map.module_id(def_map.root()) }\n+        Module { id: def_map.module_id(DefMap::ROOT) }\n     }\n \n     pub fn modules(self, db: &dyn HirDatabase) -> Vec<Module> {\n@@ -475,12 +475,11 @@ impl Module {\n     /// in the module tree of any target in `Cargo.toml`.\n     pub fn crate_root(self, db: &dyn HirDatabase) -> Module {\n         let def_map = db.crate_def_map(self.id.krate());\n-        Module { id: def_map.module_id(def_map.root()) }\n+        Module { id: def_map.module_id(DefMap::ROOT) }\n     }\n \n-    pub fn is_crate_root(self, db: &dyn HirDatabase) -> bool {\n-        let def_map = db.crate_def_map(self.id.krate());\n-        def_map.root() == self.id.local_id\n+    pub fn is_crate_root(self) -> bool {\n+        DefMap::ROOT == self.id.local_id\n     }\n \n     /// Iterates over all child modules."}, {"sha": "480cb77b4fd6a8020aa39680b638da3c17e52ca1", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -158,7 +158,7 @@ impl Completions {\n         path_ctx: &PathCompletionCtx,\n     ) {\n         ctx.process_all_names(&mut |name, res, doc_aliases| match res {\n-            ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n+            ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root() => {\n                 self.add_module(ctx, path_ctx, m, name, doc_aliases);\n             }\n             _ => (),"}, {"sha": "eba9d8afc40abf19412f7199080a5cf36f9c9976", "filename": "crates/ide-db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fhelpers.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -77,7 +77,7 @@ pub fn visit_file_defs(\n     }\n     module.impl_defs(db).into_iter().for_each(|impl_| cb(impl_.into()));\n \n-    let is_root = module.is_crate_root(db);\n+    let is_root = module.is_crate_root();\n     module\n         .legacy_macros(db)\n         .into_iter()"}, {"sha": "52a23b4b8f3d2452244ae7534873d93a1503d7f2", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -178,7 +178,7 @@ fn rename_mod(\n \n     let mut source_change = SourceChange::default();\n \n-    if module.is_crate_root(sema.db) {\n+    if module.is_crate_root() {\n         return Ok(source_change);\n     }\n "}, {"sha": "73cd5dcaf23fc84a33d5c4fd04af742ada022e1f", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -225,7 +225,7 @@ impl Definition {\n         // def is crate root\n         // FIXME: We don't do searches for crates currently, as a crate does not actually have a single name\n         if let &Definition::Module(module) = self {\n-            if module.is_crate_root(db) {\n+            if module.is_crate_root() {\n                 return SearchScope::reverse_dependencies(db, module.krate());\n             }\n         }\n@@ -392,7 +392,7 @@ impl<'a> FindUsages<'a> {\n \n         let name = match self.def {\n             // special case crate modules as these do not have a proper name\n-            Definition::Module(module) if module.is_crate_root(self.sema.db) => {\n+            Definition::Module(module) if module.is_crate_root() => {\n                 // FIXME: This assumes the crate name is always equal to its display name when it really isn't\n                 module\n                     .krate()\n@@ -500,7 +500,7 @@ impl<'a> FindUsages<'a> {\n             let scope =\n                 search_scope.intersection(&SearchScope::module_and_children(self.sema.db, module));\n \n-            let is_crate_root = module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n+            let is_crate_root = module.is_crate_root().then(|| Finder::new(\"crate\"));\n             let finder = &Finder::new(\"super\");\n \n             for (text, file_id, search_range) in scope_files(sema, &scope) {"}, {"sha": "271e7ce73bcdda3f84a3348dda11ed597a9d1a44", "filename": "crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use hir::{db::DefDatabase, InFile, ModuleSource};\n+use hir::{db::DefDatabase, DefMap, InFile, ModuleSource};\n use ide_db::{\n     base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n     source_change::SourceChange,\n@@ -74,7 +74,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n     'crates: for &krate in &*ctx.sema.db.relevant_crates(file_id) {\n         let crate_def_map = ctx.sema.db.crate_def_map(krate);\n \n-        let root_module = &crate_def_map[crate_def_map.root()];\n+        let root_module = &crate_def_map[DefMap::ROOT];\n         let Some(root_file_id) = root_module.origin.file_id() else { continue };\n         let Some(crate_root_path) = source_root.path_for_file(&root_file_id) else { continue };\n         let Some(rel) = parent.strip_prefix(&crate_root_path.parent()?) else { continue };"}, {"sha": "d2c77e2dc797504ed34453ce57cfcb11381439f7", "filename": "crates/ide/src/status.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatus.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -1,7 +1,7 @@\n use std::{fmt, marker::PhantomData};\n \n use hir::{\n-    db::{AstIdMapQuery, AttrsQuery, ParseMacroExpansionQuery},\n+    db::{AstIdMapQuery, AttrsQuery, BlockDefMapQuery, ParseMacroExpansionQuery},\n     Attr, Attrs, ExpandResult, MacroFile, Module,\n };\n use ide_db::{\n@@ -51,6 +51,7 @@ pub(crate) fn status(db: &RootDatabase, file_id: Option<FileId>) -> String {\n     format_to!(buf, \"\\nDebug info:\\n\");\n     format_to!(buf, \"{}\\n\", collect_query(AttrsQuery.in_db(db)));\n     format_to!(buf, \"{} ast id maps\\n\", collect_query_count(AstIdMapQuery.in_db(db)));\n+    format_to!(buf, \"{} block def maps\\n\", collect_query_count(BlockDefMapQuery.in_db(db)));\n \n     if let Some(file_id) = file_id {\n         format_to!(buf, \"\\nFile info:\\n\");"}, {"sha": "3c40246a69d37310e3282118f17bcf7e31c6043a", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -340,7 +340,7 @@ fn highlight_def(\n         Definition::Field(_) => Highlight::new(HlTag::Symbol(SymbolKind::Field)),\n         Definition::Module(module) => {\n             let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Module));\n-            if module.is_crate_root(db) {\n+            if module.is_crate_root() {\n                 h |= HlMod::CrateRoot;\n             }\n             h"}, {"sha": "5107f294394bc7573fb49878915bc45e28e00026", "filename": "lib/la-arena/src/lib.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc7c6d43c77c2edb549f574188da8aff4ac0fba4/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=dc7c6d43c77c2edb549f574188da8aff4ac0fba4", "patch": "@@ -18,6 +18,18 @@ pub use map::{ArenaMap, Entry, OccupiedEntry, VacantEntry};\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct RawIdx(u32);\n \n+impl RawIdx {\n+    /// Constructs a [`RawIdx`] from a u32.\n+    pub const fn from_u32(u32: u32) -> Self {\n+        RawIdx(u32)\n+    }\n+\n+    /// Deconstructs a [`RawIdx`] into the underlying u32.\n+    pub const fn into_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n impl From<RawIdx> for u32 {\n     #[inline]\n     fn from(raw: RawIdx) -> u32 {\n@@ -94,12 +106,12 @@ impl<T> fmt::Debug for Idx<T> {\n \n impl<T> Idx<T> {\n     /// Creates a new index from a [`RawIdx`].\n-    pub fn from_raw(raw: RawIdx) -> Self {\n+    pub const fn from_raw(raw: RawIdx) -> Self {\n         Idx { raw, _ty: PhantomData }\n     }\n \n     /// Converts this index into the underlying [`RawIdx`].\n-    pub fn into_raw(self) -> RawIdx {\n+    pub const fn into_raw(self) -> RawIdx {\n         self.raw\n     }\n }"}]}