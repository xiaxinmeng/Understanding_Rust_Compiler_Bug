{"sha": "24d76690997c12adc7cd196ab7edc75a1533458a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZDc2NjkwOTk3YzEyYWRjN2NkMTk2YWI3ZWRjNzVhMTUzMzQ1OGE=", "commit": {"author": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-10-05T19:19:22Z"}, "committer": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-10-05T19:19:22Z"}, "message": "Handle emitting debug info for unboxed closures\n\nThis fixes an ICE.  Closes issue #17021", "tree": {"sha": "058cdc46b28f8e62f38d4e25276ec5f6d80b1be8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/058cdc46b28f8e62f38d4e25276ec5f6d80b1be8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24d76690997c12adc7cd196ab7edc75a1533458a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24d76690997c12adc7cd196ab7edc75a1533458a", "html_url": "https://github.com/rust-lang/rust/commit/24d76690997c12adc7cd196ab7edc75a1533458a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24d76690997c12adc7cd196ab7edc75a1533458a/comments", "author": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c586490715a35d3c9dae17de7f8907c2f73168d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c586490715a35d3c9dae17de7f8907c2f73168d3", "html_url": "https://github.com/rust-lang/rust/commit/c586490715a35d3c9dae17de7f8907c2f73168d3"}], "stats": {"total": 130, "additions": 76, "deletions": 54}, "files": [{"sha": "e50b61a68e515433a3ed86f8af0c58218f87c746", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 76, "deletions": 54, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/24d76690997c12adc7cd196ab7edc75a1533458a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d76690997c12adc7cd196ab7edc75a1533458a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=24d76690997c12adc7cd196ab7edc75a1533458a", "patch": "@@ -456,60 +456,17 @@ impl TypeMap {\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n                 unique_type_id.push_str(return_type_id.as_slice());\n             },\n-            ty::ty_closure(box ty::ClosureTy { fn_style,\n-                                               onceness,\n-                                               store,\n-                                               ref bounds,\n-                                               ref sig,\n-                                               abi: _ }) => {\n-                if fn_style == ast::UnsafeFn {\n-                    unique_type_id.push_str(\"unsafe \");\n-                }\n-\n-                if onceness == ast::Once {\n-                    unique_type_id.push_str(\"once \");\n-                }\n-\n-                match store {\n-                    ty::UniqTraitStore => unique_type_id.push_str(\"~|\"),\n-                    ty::RegionTraitStore(_, ast::MutMutable) => {\n-                        unique_type_id.push_str(\"&mut|\")\n-                    }\n-                    ty::RegionTraitStore(_, ast::MutImmutable) => {\n-                        unique_type_id.push_str(\"&|\")\n-                    }\n-                };\n-\n-                for &parameter_type in sig.inputs.iter() {\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_of_type(cx, parameter_type);\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(parameter_type_id.as_slice());\n-                    unique_type_id.push_char(',');\n-                }\n-\n-                if sig.variadic {\n-                    unique_type_id.push_str(\"...\");\n-                }\n-\n-                unique_type_id.push_str(\"|->\");\n-\n-                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n-                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(return_type_id.as_slice());\n-\n-                unique_type_id.push_char(':');\n-\n-                for bound in bounds.builtin_bounds.iter() {\n-                    match bound {\n-                        ty::BoundSend => unique_type_id.push_str(\"Send\"),\n-                        ty::BoundSized => unique_type_id.push_str(\"Sized\"),\n-                        ty::BoundCopy => unique_type_id.push_str(\"Copy\"),\n-                        ty::BoundSync => unique_type_id.push_str(\"Sync\"),\n-                    };\n-                    unique_type_id.push_char('+');\n-                }\n+            ty::ty_closure(box ref closure_ty) => {\n+                self.get_unique_type_id_of_closure_type(cx,\n+                                                        closure_ty.clone(),\n+                                                        &mut unique_type_id);\n+            },\n+            ty::ty_unboxed_closure(ref def_id, _) => {\n+                let closure_ty = cx.tcx().unboxed_closures.borrow()\n+                                   .find(def_id).unwrap().closure_type.clone();\n+                self.get_unique_type_id_of_closure_type(cx,\n+                                                        closure_ty,\n+                                                        &mut unique_type_id);\n             },\n             _ => {\n                 cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n@@ -581,6 +538,66 @@ impl TypeMap {\n         }\n     }\n \n+    fn get_unique_type_id_of_closure_type(&mut self,\n+                                          cx: &CrateContext,\n+                                          closure_ty: ty::ClosureTy,\n+                                          unique_type_id: &mut String) {\n+        let ty::ClosureTy { fn_style,\n+                            onceness,\n+                            store,\n+                            ref bounds,\n+                            ref sig,\n+                            abi: _ } = closure_ty;\n+        if fn_style == ast::UnsafeFn {\n+            unique_type_id.push_str(\"unsafe \");\n+        }\n+\n+        if onceness == ast::Once {\n+            unique_type_id.push_str(\"once \");\n+        }\n+\n+        match store {\n+            ty::UniqTraitStore => unique_type_id.push_str(\"~|\"),\n+            ty::RegionTraitStore(_, ast::MutMutable) => {\n+                unique_type_id.push_str(\"&mut|\")\n+            }\n+            ty::RegionTraitStore(_, ast::MutImmutable) => {\n+                unique_type_id.push_str(\"&|\")\n+            }\n+        };\n+\n+        for &parameter_type in sig.inputs.iter() {\n+            let parameter_type_id =\n+                self.get_unique_type_id_of_type(cx, parameter_type);\n+            let parameter_type_id =\n+                self.get_unique_type_id_as_string(parameter_type_id);\n+            unique_type_id.push_str(parameter_type_id.as_slice());\n+            unique_type_id.push_char(',');\n+        }\n+\n+        if sig.variadic {\n+            unique_type_id.push_str(\"...\");\n+        }\n+\n+        unique_type_id.push_str(\"|->\");\n+\n+        let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n+        let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n+        unique_type_id.push_str(return_type_id.as_slice());\n+\n+        unique_type_id.push_char(':');\n+\n+        for bound in bounds.builtin_bounds.iter() {\n+            match bound {\n+                ty::BoundSend => unique_type_id.push_str(\"Send\"),\n+                ty::BoundSized => unique_type_id.push_str(\"Sized\"),\n+                ty::BoundCopy => unique_type_id.push_str(\"Copy\"),\n+                ty::BoundSync => unique_type_id.push_str(\"Sync\"),\n+            };\n+            unique_type_id.push_char('+');\n+        }\n+    }\n+\n     // Get the UniqueTypeId for an enum variant. Enum variants are not really\n     // types of their own, so they need special handling. We still need a\n     // UniqueTypeId for them, since to debuginfo they *are* real types.\n@@ -2903,6 +2920,11 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_closure(ref closurety) => {\n             subroutine_type_metadata(cx, unique_type_id, &closurety.sig, usage_site_span)\n         }\n+        ty::ty_unboxed_closure(ref def_id, _) => {\n+            let sig = cx.tcx().unboxed_closures.borrow()\n+                        .find(def_id).unwrap().closure_type.sig.clone();\n+            subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n+        }\n         ty::ty_struct(def_id, ref substs) => {\n             prepare_struct_metadata(cx,\n                                     t,"}]}