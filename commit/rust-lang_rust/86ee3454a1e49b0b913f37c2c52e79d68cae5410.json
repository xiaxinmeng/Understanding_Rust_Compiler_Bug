{"sha": "86ee3454a1e49b0b913f37c2c52e79d68cae5410", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZWUzNDU0YTFlNDliMGI5MTNmMzdjMmM1MmU3OWQ2OGNhZTU0MTA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-08T14:27:55Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-11T09:01:54Z"}, "message": "Implement or-patterns in case clauses\n\nYou can now say\n\n    expr_move(?dst, ?src) | expr_assign(?dst, ?src) { ... }\n\nto match both expr_move and expr_assign. The names, types, and number\nof bound names have to match in all the patterns.\n\nCloses #449.", "tree": {"sha": "fbb448de5295ab46b6894117597fdb51d2f28001", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbb448de5295ab46b6894117597fdb51d2f28001"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86ee3454a1e49b0b913f37c2c52e79d68cae5410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86ee3454a1e49b0b913f37c2c52e79d68cae5410", "html_url": "https://github.com/rust-lang/rust/commit/86ee3454a1e49b0b913f37c2c52e79d68cae5410", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86ee3454a1e49b0b913f37c2c52e79d68cae5410/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d325b1a15126c6aa9f97d510a11d93d4ac2ad53", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d325b1a15126c6aa9f97d510a11d93d4ac2ad53", "html_url": "https://github.com/rust-lang/rust/commit/4d325b1a15126c6aa9f97d510a11d93d4ac2ad53"}], "stats": {"total": 208, "additions": 168, "deletions": 40}, "files": [{"sha": "5dd8b28cbe101e059b43231e12ec62091ce78d7f", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -300,7 +300,7 @@ fn arm_defnums(&ast::arm arm) -> vec[node_id] {\n             case (_) { }\n         }\n     }\n-    walk_pat(dnums, arm.pat);\n+    walk_pat(dnums, arm.pats.(0));\n     ret dnums;\n }\n "}, {"sha": "e916fb8ebbb370969aa318af3b0bd73fe37694c6", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -288,7 +288,7 @@ fn resolve_names(&@env e, &@ast::crate c) {\n                                         c.node.path.node.idents, ns_value));\n     }\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n-        walk_pat(*e, sc, a.pat);\n+        for (@ast::pat p in a.pats) { walk_pat(*e, sc, p); }\n         visit_arm_with_scope(a, sc, v);\n     }\n     fn walk_pat(&env e, &scopes sc, &@ast::pat pat) {\n@@ -648,7 +648,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n             }\n             case (scope_block(?b)) { ret lookup_in_block(name, b.node, ns); }\n             case (scope_arm(?a)) {\n-                if (ns == ns_value) { ret lookup_in_pat(name, *a.pat); }\n+                if (ns == ns_value) { ret lookup_in_pat(name, *a.pats.(0)); }\n             }\n         }\n         ret none[def];\n@@ -1264,7 +1264,32 @@ fn check_arm(@env e, &ast::arm a, &() x, &vt[()] v) {\n             case (_) { }\n         }\n     }\n-    walk_pat(checker(*e, \"binding\"), a.pat);\n+    auto ch0 = checker(*e, \"binding\");\n+    walk_pat(ch0, a.pats.(0));\n+    auto seen0 = ch0.seen;\n+    auto i = ivec::len(a.pats);\n+    while (i > 1u) {\n+        i -= 1u;\n+        auto ch = checker(*e, \"binding\");\n+        walk_pat(ch, a.pats.(i));\n+        // Ensure the bindings introduced in this pattern are the same as in\n+        // the first pattern.\n+        if (vec::len(ch.seen) != vec::len(seen0)) {\n+            e.sess.span_err(a.pats.(i).span,\n+                            \"inconsistent number of bindings\");\n+        } else {\n+            for (ident name in ch.seen) {\n+                if (option::is_none(vec::find(bind str::eq(name, _),\n+                                              seen0))) {\n+                    // Fight the alias checker\n+                    auto name_ = name;\n+                    e.sess.span_err\n+                        (a.pats.(i).span, \"binding \" + name_ + \n+                         \" does not occur in first pattern\");\n+                }\n+            }\n+        }\n+    }\n }\n \n fn check_block(@env e, &ast::block b, &() x, &vt[()] v) {"}, {"sha": "061fe320a718d4da1368f11e9c1074e8138f0ef9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -4842,8 +4842,10 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n     }\n }\n \n+type bind_map = hashmap[ast::ident, result];\n+\n fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n-                     bool is_mem) -> result {\n+                     bool is_mem, &bind_map bound) -> result {\n     alt (pat.node) {\n         case (ast::pat_wild) { ret rslt(cx, llval); }\n         case (ast::pat_lit(_)) { ret rslt(cx, llval); }\n@@ -4853,8 +4855,9 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                 val = spill_if_immediate\n                     (cx, llval, node_id_type(cx.fcx.lcx.ccx, pat.id));\n             }\n-            cx.fcx.lllocals.insert(pat.id, val);\n-            ret rslt(cx, val);\n+            auto r = rslt(cx, val);\n+            bound.insert(name, r);\n+            ret r;\n         }\n         case (ast::pat_tag(_, ?subpats)) {\n             if (std::ivec::len[@ast::pat](subpats) == 0u) {\n@@ -4887,7 +4890,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                             ty_param_substs, i);\n                 this_cx = rslt.bcx;\n                 auto subpat_res =\n-                    trans_pat_binding(this_cx, subpat, rslt.val, true);\n+                    trans_pat_binding(this_cx, subpat, rslt.val, true, bound);\n                 this_cx = subpat_res.bcx;\n                 i += 1;\n             }\n@@ -4902,16 +4905,34 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &ast::arm[] arms,\n     auto this_cx = expr_res.bcx;\n     let result[] arm_results = ~[];\n     for (ast::arm arm in arms) {\n-        auto next_cx = new_sub_block_ctxt(expr_res.bcx, \"next\");\n-        auto match_res =\n-            trans_pat_match(this_cx, arm.pat, expr_res.val, next_cx);\n-        auto binding_res =\n-            trans_pat_binding(match_res.bcx, arm.pat, expr_res.val, false);\n-        auto block_cx = new_scope_block_ctxt(match_res.bcx, \"case block\");\n-        binding_res.bcx.build.Br(block_cx.llbb);\n+        auto bind_maps = ~[];\n+        auto block_cx = new_scope_block_ctxt(expr_res.bcx, \"case block\");\n+        for (@ast::pat pat in arm.pats) {\n+            auto next_cx = new_sub_block_ctxt(expr_res.bcx, \"next\");\n+            auto match_res =\n+                trans_pat_match(this_cx, pat, expr_res.val, next_cx);\n+            auto bind_map = new_str_hash[result]();\n+            auto binding_res = trans_pat_binding\n+                (match_res.bcx, pat, expr_res.val, false, bind_map);\n+            bind_maps += ~[bind_map];\n+            binding_res.bcx.build.Br(block_cx.llbb);\n+            this_cx = next_cx;\n+        }\n+        // Go over the names and node_ids of the bound variables, add a Phi\n+        // node for each and register the bindings.\n+        for each (@tup(ast::ident, ast::node_id) item in\n+                  ast::pat_id_map(arm.pats.(0)).items()) {\n+            auto vals = ~[]; auto llbbs = ~[];\n+            for (bind_map map in bind_maps) {\n+                auto rslt = map.get(item._0);\n+                vals += ~[rslt.val];\n+                llbbs += ~[rslt.bcx.llbb];\n+            }\n+            auto phi = block_cx.build.Phi(val_ty(vals.(0)), vals, llbbs);\n+            block_cx.fcx.lllocals.insert(item._1, phi);\n+        }\n         auto block_res = trans_block(block_cx, arm.block, output);\n         arm_results += ~[block_res];\n-        this_cx = next_cx;\n     }\n     auto default_cx = this_cx;\n     trans_fail(default_cx, some[span](expr.span),"}, {"sha": "3ad6a444680594cc2d1698e0ffc15e5521faaada", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -10,6 +10,7 @@ import driver::session;\n import util::common;\n import syntax::codemap::span;\n import std::map::new_int_hash;\n+import std::map::new_str_hash;\n import util::common::new_def_hash;\n import util::common::log_expr_err;\n import middle::ty;\n@@ -1286,10 +1287,10 @@ fn check_lit(@crate_ctxt ccx, &@ast::lit lit) -> ty::t {\n     }\n }\n \n-\n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n+fn check_pat(&@fn_ctxt fcx, &ast::pat_id_map map, &@ast::pat pat,\n+             ty::t expected) {\n     alt (pat.node) {\n         case (ast::pat_wild) {\n             write::ty_only_fixup(fcx, pat.id, expected);\n@@ -1303,6 +1304,12 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n             auto vid = lookup_local(fcx, pat.span, pat.id);\n             auto typ = ty::mk_var(fcx.ccx.tcx, vid);\n             typ = demand::simple(fcx, pat.span, expected, typ);\n+            auto canon_id = map.get(name);\n+            if (canon_id != pat.id) {\n+                auto ct = ty::mk_var(fcx.ccx.tcx,\n+                                     lookup_local(fcx, pat.span, canon_id));\n+                typ = demand::simple(fcx, pat.span, ct, typ);\n+            }\n             write::ty_only_fixup(fcx, pat.id, typ);\n         }\n         case (ast::pat_tag(?path, ?subpats)) {\n@@ -1358,7 +1365,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n \n                     auto i = 0u;\n                     for (@ast::pat subpat in subpats) {\n-                        check_pat(fcx, subpat, arg_types.(i));\n+                        check_pat(fcx, map, subpat, arg_types.(i));\n                         i += 1u;\n                     }\n                 } else if (subpats_len > 0u) {\n@@ -1884,10 +1891,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // bindings.\n \n             auto pattern_ty = ty::expr_ty(fcx.ccx.tcx, expr);\n-            let vec[@ast::pat] pats = [];\n             for (ast::arm arm in arms) {\n-                check_pat(fcx, arm.pat, pattern_ty);\n-                pats += [arm.pat];\n+                auto id_map = ast::pat_id_map(arm.pats.(0));\n+                for (@ast::pat p in arm.pats) {\n+                    check_pat(fcx, id_map, p, pattern_ty);\n+                }\n             }\n             // Now typecheck the blocks.\n "}, {"sha": "37d57dacf3c72f1d4006991bc57bbfe1aeb6011a", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -125,6 +125,25 @@ tag pat_ {\n     pat_tag(path, (@pat)[]);\n }\n \n+type pat_id_map = std::map::hashmap[str, ast::node_id];\n+\n+// This is used because same-named variables in alternative patterns need to\n+// use the node_id of their namesake in the first pattern.\n+fn pat_id_map(&@pat pat) -> pat_id_map {\n+    auto map = std::map::new_str_hash[node_id]();\n+    fn walk(&pat_id_map map, &@pat pat) {\n+        alt (pat.node) {\n+            pat_bind(?name) { map.insert(name, pat.id); }\n+            pat_tag(_, ?sub) {\n+                for (@pat p in sub) { walk(map, p); }\n+            }\n+            _ {}\n+        }\n+    }\n+    walk(map, pat);\n+    ret map;\n+}\n+\n tag mutability { mut; imm; maybe_mut; }\n \n tag layer { layer_value; layer_state; layer_gc; }\n@@ -227,7 +246,7 @@ type decl = spanned[decl_];\n \n tag decl_ { decl_local(@local); decl_item(@item); }\n \n-type arm = rec(@pat pat, block block);\n+type arm = rec((@pat)[] pats, block block);\n \n type elt = rec(mutability mut, @expr expr);\n "}, {"sha": "8529542bf442d9a9d2f9c43b669e17fa9da068fe", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -255,7 +255,8 @@ fn noop_fold_stmt(&stmt_ s, ast_fold fld) -> stmt_ {\n }\n \n fn noop_fold_arm(&arm a, ast_fold fld) -> arm {\n-    ret rec(pat=fld.fold_pat(a.pat), block=fld.fold_block(a.block));\n+    ret rec(pats=ivec::map(fld.fold_pat, a.pats),\n+            block=fld.fold_block(a.block));\n }\n \n fn noop_fold_pat(&pat_ p, ast_fold fld) -> pat_ {"}, {"sha": "567aa995fd67f4f1efc3d0fa778ac6bc1ddb224a", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -1359,10 +1359,10 @@ fn parse_alt_expr(&parser p) -> @ast::expr {\n         eat_word(p, \"case\");\n         auto parens = false;\n         if (p.peek() == token::LPAREN) { parens = true; p.bump(); }\n-        auto pat = parse_pat(p);\n+        auto pats = parse_pats(p);\n         if (parens) { expect(p, token::RPAREN); }\n         auto block = parse_block(p);\n-        arms += ~[rec(pat=pat, block=block)];\n+        arms += ~[rec(pats=pats, block=block)];\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n@@ -1405,20 +1405,32 @@ fn parse_initializer(&parser p) -> option::t[ast::initializer] {\n             p.bump();\n             ret some(rec(op=ast::init_move, expr=parse_expr(p)));\n         }\n-        case (\n-             // Now that the the channel is the first argument to receive,\n-             // combining it with an initializer doesn't really make sense.\n-             // case (token::RECV) {\n-             //     p.bump();\n-             //     ret some(rec(op = ast::init_recv,\n-             //                  expr = parse_expr(p)));\n-             // }\n-             _) {\n+        // Now that the the channel is the first argument to receive,\n+        // combining it with an initializer doesn't really make sense.\n+        // case (token::RECV) {\n+        //     p.bump();\n+        //     ret some(rec(op = ast::init_recv,\n+        //                  expr = parse_expr(p)));\n+        // }\n+        case (_) {\n             ret none;\n         }\n     }\n }\n \n+fn parse_pats(&parser p) -> (@ast::pat)[] {\n+    auto pats = ~[];\n+    while (true) {\n+        pats += ~[parse_pat(p)];\n+        if (p.peek() == token::BINOP(token::OR)) {\n+            p.bump();\n+        } else {\n+            break;\n+        }\n+    }\n+    ret pats;\n+}\n+\n fn parse_pat(&parser p) -> @ast::pat {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();"}, {"sha": "2bc4efb1e5901c5bef18b3d43fb372e0c89b2849", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -832,9 +832,12 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             for (ast::arm arm in arms) {\n                 space(s.s);\n                 head(s, \"case\");\n-                popen(s);\n-                print_pat(s, arm.pat);\n-                pclose(s);\n+                auto first = true;\n+                for (@ast::pat p in arm.pats) {\n+                    if (first) { first = false; }\n+                    else { space(s.s); word_space(s, \"|\"); }\n+                    print_pat(s, p);\n+                }\n                 space(s.s);\n                 print_block(s, arm.block);\n             }"}, {"sha": "984bb4f6d94e74d5e0635ea07905be4b70fe998b", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -394,7 +394,7 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n }\n \n fn visit_arm[E](&arm a, &E e, &vt[E] v) {\n-    vt(v).visit_pat(a.pat, e, v);\n+    for (@pat p in a.pats) { vt(v).visit_pat(p, e, v); }\n     vt(v).visit_block(a.block, e, v);\n }\n // Local Variables:"}, {"sha": "77b13f0c9b8bb50e978ac2129acadfda6441e730", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -334,7 +334,7 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n         case (ast::expr_alt(?x, ?arms)) {\n             walk_expr(v, x);\n             for (ast::arm a in arms) {\n-                walk_pat(v, a.pat);\n+                for (@ast::pat p in a.pats) { walk_pat(v, p); }\n                 v.visit_arm_pre(a);\n                 walk_block(v, a.block);\n                 v.visit_arm_post(a);"}, {"sha": "3c21b4767753aec46e5243fe86bc5d5c32791525", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -206,6 +206,15 @@ fn all[T](fn(&T)->bool f, &T[] v) -> bool {\n     ret true;\n }\n \n+fn member[T](&T x, &T[] v) -> bool {\n+    for (T elt in v) { if (x == elt) { ret true; } }\n+    ret false;\n+}\n+\n+fn find[T](fn(&T) -> bool  f, &T[] v) -> option::t[T] {\n+    for (T elt in v) { if (f(elt)) { ret some[T](elt); } }\n+    ret none[T];\n+}\n \n mod unsafe {\n     fn copy_from_buf[T](&mutable T[] v, *T ptr, uint count) {"}, {"sha": "b926e8d0aa5401ff13f7c264b3913ec38662a00e", "filename": "src/test/compile-fail/or-patter-mismatch.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2For-patter-mismatch.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: mismatched types\n+\n+tag blah {\n+    a(int, int, uint);\n+    b(int, int);\n+}\n+\n+fn main() {\n+    alt a(1, 1, 2u) {\n+        a(_, ?x, ?y) | b(?x, ?y) { }\n+    }\n+}"}, {"sha": "55f346feb809fd02cffd82d5a2accf5508bcc8f9", "filename": "src/test/run-pass/or-pattern.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Ftest%2Frun-pass%2For-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ee3454a1e49b0b913f37c2c52e79d68cae5410/src%2Ftest%2Frun-pass%2For-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2For-pattern.rs?ref=86ee3454a1e49b0b913f37c2c52e79d68cae5410", "patch": "@@ -0,0 +1,18 @@\n+tag blah {\n+    a(int, int, uint);\n+    b(int, int);\n+    c;\n+}\n+\n+fn or_alt(&blah q) -> int {\n+    alt q {\n+        a(?x, ?y, _) | b(?x, ?y) { ret x + y;}\n+        c { ret 0; }\n+    }\n+}\n+\n+fn main() {\n+    assert or_alt(c) == 0;\n+    assert or_alt(a(10, 100, 0u)) == 110;\n+    assert or_alt(b(20, 200)) == 220;\n+}"}]}