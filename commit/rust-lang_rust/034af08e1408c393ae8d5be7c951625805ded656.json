{"sha": "034af08e1408c393ae8d5be7c951625805ded656", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNGFmMDhlMTQwOGMzOTNhZThkNWJlN2M5NTE2MjU4MDVkZWQ2NTY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-09-15T23:30:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-15T23:30:34Z"}, "message": "Rollup merge of #75749 - ehuss:consolidate-sys, r=alexcrichton\n\nConsolidate some duplicate code in the sys modules.\n\nThis consolidates some modules which were duplicated throughout the sys module. The intent is to make it easier to update and maintain this code. This mainly affects the wasi, sgx, and \"unsupported\" targets.\n\nI explicitly skipped hermit, cloudabi, and vxworks. These tier-3 targets have copied large sections of the sys tree. I don't think they should have, but I don't want to put effort into changing them. It also doesn't help that there aren't any scripts or instructions for building them.\n\nThere are still sections of duplicate code here and there, but this PR covers the easy parts where entire modules are the same.", "tree": {"sha": "7c9c126ab59a76b951f57dc67f1a17258ebb33ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c9c126ab59a76b951f57dc67f1a17258ebb33ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/034af08e1408c393ae8d5be7c951625805ded656", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfYU6aCRBK7hj4Ov3rIwAAdHIIABlz9oso8bLwGSJgQvaSh2LN\nq9jaaVlL+kustJzpgMp/eDxpmgHCS2Ffat8URTvxo+TFJAJ8mjmOzZgNnY7ihZFb\nUhv/ivGStkbdSgO9Sb5Xyg+MOFNoY13IkeqcoQ2dqJcZH7/NRsZXuzvnDru2bqHn\nmCg6PKCvFoU0MrMazF7FdTAkXtFJjZwaskJe1qjkCyXnv42HzaVi3MQV8XHYu6x+\n8yzdzhBk6uPisrzcLP0JgSYZ8N9Q123vkGvd63o33+Iqyk1tQhOR3wFFMApDaVHP\nTIJK4AXMetN2AaRQJ62Tcr64z2OBjSbIwLA88AxC4yXli8uBeaBnqol6b9e6Q6Y=\n=xTRW\n-----END PGP SIGNATURE-----\n", "payload": "tree 7c9c126ab59a76b951f57dc67f1a17258ebb33ce\nparent fa4cfeb59720c95df00c1482f169a906e7c0726b\nparent 25cca07ea04d02a1a2d68cea63ee656b5194af03\nauthor Dylan DPC <dylan.dpc@gmail.com> 1600212634 +0200\ncommitter GitHub <noreply@github.com> 1600212634 +0200\n\nRollup merge of #75749 - ehuss:consolidate-sys, r=alexcrichton\n\nConsolidate some duplicate code in the sys modules.\n\nThis consolidates some modules which were duplicated throughout the sys module. The intent is to make it easier to update and maintain this code. This mainly affects the wasi, sgx, and \"unsupported\" targets.\n\nI explicitly skipped hermit, cloudabi, and vxworks. These tier-3 targets have copied large sections of the sys tree. I don't think they should have, but I don't want to put effort into changing them. It also doesn't help that there aren't any scripts or instructions for building them.\n\nThere are still sections of duplicate code here and there, but this PR covers the easy parts where entire modules are the same.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/034af08e1408c393ae8d5be7c951625805ded656", "html_url": "https://github.com/rust-lang/rust/commit/034af08e1408c393ae8d5be7c951625805ded656", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/034af08e1408c393ae8d5be7c951625805ded656/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa4cfeb59720c95df00c1482f169a906e7c0726b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa4cfeb59720c95df00c1482f169a906e7c0726b", "html_url": "https://github.com/rust-lang/rust/commit/fa4cfeb59720c95df00c1482f169a906e7c0726b"}, {"sha": "25cca07ea04d02a1a2d68cea63ee656b5194af03", "url": "https://api.github.com/repos/rust-lang/rust/commits/25cca07ea04d02a1a2d68cea63ee656b5194af03", "html_url": "https://github.com/rust-lang/rust/commit/25cca07ea04d02a1a2d68cea63ee656b5194af03"}], "stats": {"total": 945, "additions": 56, "deletions": 889}, "files": [{"sha": "ecb5b51cccdcd965d85e9ee8e22ecb878d876719", "filename": "library/std/src/sys/sgx/fs.rs", "status": "removed", "additions": 0, "deletions": 308, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ffs.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,308 +0,0 @@\n-use crate::ffi::OsString;\n-use crate::fmt;\n-use crate::hash::{Hash, Hasher};\n-use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n-use crate::path::{Path, PathBuf};\n-use crate::sys::time::SystemTime;\n-use crate::sys::{unsupported, Void};\n-\n-pub struct File(Void);\n-\n-pub struct FileAttr(Void);\n-\n-pub struct ReadDir(Void);\n-\n-pub struct DirEntry(Void);\n-\n-#[derive(Clone, Debug)]\n-pub struct OpenOptions {}\n-\n-pub struct FilePermissions(Void);\n-\n-pub struct FileType(Void);\n-\n-#[derive(Debug)]\n-pub struct DirBuilder {}\n-\n-impl FileAttr {\n-    pub fn size(&self) -> u64 {\n-        match self.0 {}\n-    }\n-\n-    pub fn perm(&self) -> FilePermissions {\n-        match self.0 {}\n-    }\n-\n-    pub fn file_type(&self) -> FileType {\n-        match self.0 {}\n-    }\n-\n-    pub fn modified(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n-    }\n-\n-    pub fn accessed(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n-    }\n-\n-    pub fn created(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for FileAttr {\n-    fn clone(&self) -> FileAttr {\n-        match self.0 {}\n-    }\n-}\n-\n-impl FilePermissions {\n-    pub fn readonly(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn set_readonly(&mut self, _readonly: bool) {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for FilePermissions {\n-    fn clone(&self) -> FilePermissions {\n-        match self.0 {}\n-    }\n-}\n-\n-impl PartialEq for FilePermissions {\n-    fn eq(&self, _other: &FilePermissions) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for FilePermissions {}\n-\n-impl fmt::Debug for FilePermissions {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl FileType {\n-    pub fn is_dir(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_file(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_symlink(&self) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for FileType {\n-    fn clone(&self) -> FileType {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for FileType {}\n-\n-impl PartialEq for FileType {\n-    fn eq(&self, _other: &FileType) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for FileType {}\n-\n-impl Hash for FileType {\n-    fn hash<H: Hasher>(&self, _h: &mut H) {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Debug for FileType {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Debug for ReadDir {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Iterator for ReadDir {\n-    type Item = io::Result<DirEntry>;\n-\n-    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl DirEntry {\n-    pub fn path(&self) -> PathBuf {\n-        match self.0 {}\n-    }\n-\n-    pub fn file_name(&self) -> OsString {\n-        match self.0 {}\n-    }\n-\n-    pub fn metadata(&self) -> io::Result<FileAttr> {\n-        match self.0 {}\n-    }\n-\n-    pub fn file_type(&self) -> io::Result<FileType> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl OpenOptions {\n-    pub fn new() -> OpenOptions {\n-        OpenOptions {}\n-    }\n-\n-    pub fn read(&mut self, _read: bool) {}\n-    pub fn write(&mut self, _write: bool) {}\n-    pub fn append(&mut self, _append: bool) {}\n-    pub fn truncate(&mut self, _truncate: bool) {}\n-    pub fn create(&mut self, _create: bool) {}\n-    pub fn create_new(&mut self, _create_new: bool) {}\n-}\n-\n-impl File {\n-    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n-        unsupported()\n-    }\n-\n-    pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        match self.0 {}\n-    }\n-\n-    pub fn fsync(&self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn datasync(&self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_read_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_write_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n-        match self.0 {}\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<File> {\n-        match self.0 {}\n-    }\n-\n-    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n-}\n-\n-impl DirBuilder {\n-    pub fn new() -> DirBuilder {\n-        DirBuilder {}\n-    }\n-\n-    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n-        unsupported()\n-    }\n-}\n-\n-impl fmt::Debug for File {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n-    unsupported()\n-}\n-\n-pub fn unlink(_p: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    match perm.0 {}\n-}\n-\n-pub fn rmdir(_p: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n-    unsupported()\n-}\n-\n-pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    unsupported()\n-}\n-\n-pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n-    unsupported()\n-}\n-\n-pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n-    unsupported()\n-}\n-\n-pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n-    unsupported()\n-}\n-\n-pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n-    unsupported()\n-}"}, {"sha": "d5f475b4310fde64b7f0f50154c14d345ce3788f", "filename": "library/std/src/sys/sgx/io.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fio.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,47 +0,0 @@\n-use crate::mem;\n-\n-#[derive(Copy, Clone)]\n-pub struct IoSlice<'a>(&'a [u8]);\n-\n-impl<'a> IoSlice<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n-        IoSlice(buf)\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        self.0 = &self.0[n..]\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        self.0\n-    }\n-}\n-\n-pub struct IoSliceMut<'a>(&'a mut [u8]);\n-\n-impl<'a> IoSliceMut<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n-        IoSliceMut(buf)\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        let slice = mem::replace(&mut self.0, &mut []);\n-        let (_, remaining) = slice.split_at_mut(n);\n-        self.0 = remaining;\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        self.0\n-    }\n-\n-    #[inline]\n-    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        self.0\n-    }\n-}"}, {"sha": "1abd91e75e8c40d9e3a472efce09e3e075b01367", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=034af08e1408c393ae8d5be7c951625805ded656", "patch": "@@ -17,14 +17,18 @@ pub mod condvar;\n pub mod env;\n pub mod ext;\n pub mod fd;\n+#[path = \"../unsupported/fs.rs\"]\n pub mod fs;\n+#[path = \"../unsupported/io.rs\"]\n pub mod io;\n pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod path;\n+#[path = \"../unsupported/pipe.rs\"]\n pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;"}, {"sha": "10d0925823eb94660278ce2390c892c093d7e3c6", "filename": "library/std/src/sys/sgx/pipe.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpipe.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,38 +0,0 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::sys::Void;\n-\n-pub struct AnonPipe(Void);\n-\n-impl AnonPipe {\n-    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_read_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_write_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n-}\n-\n-pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n-    match p1.0 {}\n-}"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "library/std/src/sys/sgx/process.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fprocess.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,149 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::fs::File;\n-use crate::sys::pipe::AnonPipe;\n-use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::CommandEnv;\n-\n-pub use crate::ffi::OsString as EnvKey;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    env: CommandEnv,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-}\n-\n-impl Command {\n-    pub fn new(_program: &OsStr) -> Command {\n-        Command { env: Default::default() }\n-    }\n-\n-    pub fn arg(&mut self, _arg: &OsStr) {}\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn cwd(&mut self, _dir: &OsStr) {}\n-\n-    pub fn stdin(&mut self, _stdin: Stdio) {}\n-\n-    pub fn stdout(&mut self, _stdout: Stdio) {}\n-\n-    pub fn stderr(&mut self, _stderr: Stdio) {}\n-\n-    pub fn spawn(\n-        &mut self,\n-        _default: Stdio,\n-        _needs_stdin: bool,\n-    ) -> io::Result<(Process, StdioPipes)> {\n-        unsupported()\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        pipe.diverge()\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        file.diverge()\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-pub struct ExitStatus(Void);\n-\n-impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for ExitStatus {\n-    fn clone(&self) -> ExitStatus {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for ExitStatus {}\n-\n-impl PartialEq for ExitStatus {\n-    fn eq(&self, _other: &ExitStatus) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for ExitStatus {}\n-\n-impl fmt::Debug for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(bool);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(false);\n-    pub const FAILURE: ExitCode = ExitCode(true);\n-\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}\n-\n-pub struct Process(Void);\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        match self.0 {}\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        match self.0 {}\n-    }\n-\n-    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        match self.0 {}\n-    }\n-}"}, {"sha": "964abe8b8c9ea86ffe714811e897110ab488c083", "filename": "library/std/src/sys/unix/alloc.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs?ref=034af08e1408c393ae8d5be7c951625805ded656", "patch": "@@ -52,46 +52,48 @@ unsafe impl GlobalAlloc for System {\n     }\n }\n \n-#[cfg(any(\n-    target_os = \"android\",\n-    target_os = \"illumos\",\n-    target_os = \"redox\",\n-    target_os = \"solaris\"\n-))]\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    // On android we currently target API level 9 which unfortunately\n-    // doesn't have the `posix_memalign` API used below. Instead we use\n-    // `memalign`, but this unfortunately has the property on some systems\n-    // where the memory returned cannot be deallocated by `free`!\n-    //\n-    // Upon closer inspection, however, this appears to work just fine with\n-    // Android, so for this platform we should be fine to call `memalign`\n-    // (which is present in API level 9). Some helpful references could\n-    // possibly be chromium using memalign [1], attempts at documenting that\n-    // memalign + free is ok [2] [3], or the current source of chromium\n-    // which still uses memalign on android [4].\n-    //\n-    // [1]: https://codereview.chromium.org/10796020/\n-    // [2]: https://code.google.com/p/android/issues/detail?id=35391\n-    // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n-    // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n-    //                                       /memory/aligned_memory.cc\n-    libc::memalign(layout.align(), layout.size()) as *mut u8\n-}\n-\n-#[cfg(not(any(\n-    target_os = \"android\",\n-    target_os = \"illumos\",\n-    target_os = \"redox\",\n-    target_os = \"solaris\"\n-)))]\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    let mut out = ptr::null_mut();\n-    // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n-    // Since these are all powers of 2, we can just use max.\n-    let align = layout.align().max(crate::mem::size_of::<usize>());\n-    let ret = libc::posix_memalign(&mut out, align, layout.size());\n-    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n+cfg_if::cfg_if! {\n+    if #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"illumos\",\n+        target_os = \"redox\",\n+        target_os = \"solaris\"\n+    ))] {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            // On android we currently target API level 9 which unfortunately\n+            // doesn't have the `posix_memalign` API used below. Instead we use\n+            // `memalign`, but this unfortunately has the property on some systems\n+            // where the memory returned cannot be deallocated by `free`!\n+            //\n+            // Upon closer inspection, however, this appears to work just fine with\n+            // Android, so for this platform we should be fine to call `memalign`\n+            // (which is present in API level 9). Some helpful references could\n+            // possibly be chromium using memalign [1], attempts at documenting that\n+            // memalign + free is ok [2] [3], or the current source of chromium\n+            // which still uses memalign on android [4].\n+            //\n+            // [1]: https://codereview.chromium.org/10796020/\n+            // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+            // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+            // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+            //                                       /memory/aligned_memory.cc\n+            libc::memalign(layout.align(), layout.size()) as *mut u8\n+        }\n+    } else if #[cfg(target_os = \"wasi\")] {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            libc::aligned_alloc(layout.align(), layout.size()) as *mut u8\n+        }\n+    } else {\n+        #[inline]\n+        unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+            let mut out = ptr::null_mut();\n+            // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n+            // Since these are all powers of 2, we can just use max.\n+            let align = layout.align().max(crate::mem::size_of::<usize>());\n+            let ret = libc::posix_memalign(&mut out, align, layout.size());\n+            if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n+        }\n+    }\n }"}, {"sha": "faa53b6a74422ddff884dec7a850c37252798d58", "filename": "library/std/src/sys/unsupported/fs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs?ref=034af08e1408c393ae8d5be7c951625805ded656", "patch": "@@ -233,10 +233,6 @@ impl File {\n     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n         match self.0 {}\n     }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n }\n \n impl DirBuilder {"}, {"sha": "8ba870c5dbc14cecba6f52158fae1d49a799ea8e", "filename": "library/std/src/sys/unsupported/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs?ref=034af08e1408c393ae8d5be7c951625805ded656", "patch": "@@ -8,6 +8,7 @@ pub mod io;\n pub mod mutex;\n pub mod net;\n pub mod os;\n+#[path = \"../unix/path.rs\"]\n pub mod path;\n pub mod pipe;\n pub mod process;"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "library/std/src/sys/unsupported/path.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fpath.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,19 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::path::Prefix;\n-\n-#[inline]\n-pub fn is_sep_byte(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-#[inline]\n-pub fn is_verbatim_sep(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n-    None\n-}\n-\n-pub const MAIN_SEP_STR: &str = \"/\";\n-pub const MAIN_SEP: char = '/';"}, {"sha": "7156c9ab92f2b6af3da9699a3618f76275280af1", "filename": "library/std/src/sys/unsupported/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs?ref=034af08e1408c393ae8d5be7c951625805ded656", "patch": "@@ -65,8 +65,8 @@ impl From<AnonPipe> for Stdio {\n }\n \n impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        file.diverge()\n+    fn from(_file: File) -> Stdio {\n+        panic!(\"unsupported\")\n     }\n }\n "}, {"sha": "4d0afe27bb8b2ed0943676ca253a180b92fae215", "filename": "library/std/src/sys/wasi/alloc.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Falloc.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,69 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n-use crate::alloc::{GlobalAlloc, Layout, System};\n-use crate::ptr;\n-use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n-\n-// SAFETY: All methods implemented follow the contract rules defined\n-// in `GlobalAlloc`.\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-unsafe impl GlobalAlloc for System {\n-    #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            // SAFETY: `libc::malloc` is guaranteed to be safe, it will allocate\n-            // `layout.size()` bytes of memory and return a pointer to it\n-            unsafe { libc::malloc(layout.size()) as *mut u8 }\n-        } else {\n-            // SAFETY: `libc::aligned_alloc` is guaranteed to be safe if\n-            // `layout.size()` is a multiple of `layout.align()`. This\n-            // constraint can be satisfied if `pad_to_align` is called,\n-            // which creates a layout by rounding the size of this layout up\n-            // to a multiple of the layout's alignment\n-            let aligned_layout = layout.pad_to_align();\n-            unsafe { libc::aligned_alloc(aligned_layout.align(), aligned_layout.size()) as *mut u8 }\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            // SAFETY: `libc::calloc` is safe as long that `layout.size() * 1`\n-            // would not result in integer overflow which cannot happen,\n-            // multiplying by one never overflows\n-            unsafe { libc::calloc(layout.size(), 1) as *mut u8 }\n-        } else {\n-            // SAFETY: The safety contract for `alloc` must be upheld by the caller\n-            let ptr = unsafe { self.alloc(layout.clone()) };\n-            if !ptr.is_null() {\n-                // SAFETY: in the case of the `ptr` being not null\n-                // it will be properly aligned and a valid ptr\n-                // which satisfies `ptr::write_bytes` safety constrains\n-                unsafe { ptr::write_bytes(ptr, 0, layout.size()) };\n-            }\n-            ptr\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-        // SAFETY: `libc::free` is guaranteed to be safe if `ptr` is allocated\n-        // by this allocator or if `ptr` is NULL\n-        unsafe { libc::free(ptr as *mut libc::c_void) }\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-            // SAFETY: `libc::realloc` is safe if `ptr` is allocated by this\n-            // allocator or NULL\n-            // - If `new_size` is 0 and `ptr` is not NULL, it will act as `libc::free`\n-            // - If `new_size` is not 0 and `ptr` is NULL, it will act as `libc::malloc`\n-            // - Else, it will resize the block accordingly\n-            unsafe { libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8 }\n-        } else {\n-            // SAFETY: The safety contract for `realloc_fallback` must be upheld by the caller\n-            unsafe { realloc_fallback(self, ptr, layout, new_size) }\n-        }\n-    }\n-}"}, {"sha": "a7a4407ac38e281fb4ac716d2f8e75679c0d26af", "filename": "library/std/src/sys/wasi/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs?ref=034af08e1408c393ae8d5be7c951625805ded656", "patch": "@@ -17,6 +17,7 @@\n use crate::io as std_io;\n use crate::mem;\n \n+#[path = \"../unix/alloc.rs\"]\n pub mod alloc;\n pub mod args;\n #[path = \"../unsupported/cmath.rs\"]\n@@ -33,8 +34,11 @@ pub mod net;\n pub mod os;\n pub use crate::sys_common::os_str_bytes as os_str;\n pub mod ext;\n+#[path = \"../unix/path.rs\"]\n pub mod path;\n+#[path = \"../unsupported/pipe.rs\"]\n pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n pub mod process;\n #[path = \"../unsupported/rwlock.rs\"]\n pub mod rwlock;"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "library/std/src/sys/wasi/path.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpath.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,19 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::path::Prefix;\n-\n-#[inline]\n-pub fn is_sep_byte(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-#[inline]\n-pub fn is_verbatim_sep(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n-    None\n-}\n-\n-pub const MAIN_SEP_STR: &str = \"/\";\n-pub const MAIN_SEP: char = '/';"}, {"sha": "180fc114d86db2753290503ae629f66e58976792", "filename": "library/std/src/sys/wasi/pipe.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fpipe.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,40 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::sys::Void;\n-\n-pub struct AnonPipe(Void);\n-\n-impl AnonPipe {\n-    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_read_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_write_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n-}\n-\n-pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n-    match p1.0 {}\n-}"}, {"sha": "c69d6376b0138d0a89b08143d47bcd1e0fe1f01b", "filename": "library/std/src/sys/wasi/process.rs", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa4cfeb59720c95df00c1482f169a906e7c0726b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fprocess.rs?ref=fa4cfeb59720c95df00c1482f169a906e7c0726b", "patch": "@@ -1,151 +0,0 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::fs::File;\n-use crate::sys::pipe::AnonPipe;\n-use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::CommandEnv;\n-\n-pub use crate::ffi::OsString as EnvKey;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    env: CommandEnv,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-}\n-\n-impl Command {\n-    pub fn new(_program: &OsStr) -> Command {\n-        Command { env: Default::default() }\n-    }\n-\n-    pub fn arg(&mut self, _arg: &OsStr) {}\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn cwd(&mut self, _dir: &OsStr) {}\n-\n-    pub fn stdin(&mut self, _stdin: Stdio) {}\n-\n-    pub fn stdout(&mut self, _stdout: Stdio) {}\n-\n-    pub fn stderr(&mut self, _stderr: Stdio) {}\n-\n-    pub fn spawn(\n-        &mut self,\n-        _default: Stdio,\n-        _needs_stdin: bool,\n-    ) -> io::Result<(Process, StdioPipes)> {\n-        unsupported()\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        pipe.diverge()\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(_file: File) -> Stdio {\n-        panic!(\"unsupported\")\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-pub struct ExitStatus(Void);\n-\n-impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for ExitStatus {\n-    fn clone(&self) -> ExitStatus {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for ExitStatus {}\n-\n-impl PartialEq for ExitStatus {\n-    fn eq(&self, _other: &ExitStatus) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for ExitStatus {}\n-\n-impl fmt::Debug for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(bool);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(false);\n-    pub const FAILURE: ExitCode = ExitCode(true);\n-\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}\n-\n-pub struct Process(Void);\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        match self.0 {}\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        match self.0 {}\n-    }\n-\n-    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        match self.0 {}\n-    }\n-}"}, {"sha": "2934ea59ab5ff687081f502df9e48417f7edea9d", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034af08e1408c393ae8d5be7c951625805ded656/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=034af08e1408c393ae8d5be7c951625805ded656", "patch": "@@ -27,7 +27,7 @@ pub mod io;\n pub mod net;\n #[path = \"../unsupported/os.rs\"]\n pub mod os;\n-#[path = \"../unsupported/path.rs\"]\n+#[path = \"../unix/path.rs\"]\n pub mod path;\n #[path = \"../unsupported/pipe.rs\"]\n pub mod pipe;"}]}