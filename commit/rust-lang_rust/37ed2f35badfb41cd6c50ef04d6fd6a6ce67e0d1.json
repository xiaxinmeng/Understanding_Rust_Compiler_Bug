{"sha": "37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZWQyZjM1YmFkZmI0MWNkNmM1MGVmMDRkNmZkNmE2Y2U2N2UwZDE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-01T20:21:16Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-01T21:09:54Z"}, "message": "rename MFileId -> HirFileId", "tree": {"sha": "8c20a12837045e81f2cec18535a6883f6619939e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c20a12837045e81f2cec18535a6883f6619939e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "html_url": "https://github.com/rust-lang/rust/commit/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c65e618498596a5dc75efe0814a5542c54d54d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c65e618498596a5dc75efe0814a5542c54d54d8", "html_url": "https://github.com/rust-lang/rust/commit/9c65e618498596a5dc75efe0814a5542c54d54d8"}], "stats": {"total": 234, "additions": 135, "deletions": 99}, "files": [{"sha": "4dead36896222533502a9aaa332c1346b88496a9", "filename": "crates/ra_analysis/src/completion/complete_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -27,7 +27,7 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) ->\n             match res.import {\n                 None => true,\n                 Some(import) => {\n-                    let range = import.range(ctx.db, module.source().file_id());\n+                    let range = import.range(ctx.db, module.file_id());\n                     !range.is_subrange(&ctx.leaf.range())\n                 }\n             }"}, {"sha": "d7740f0c4ed7173ded851f51390a3dbdb09b240e", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -91,7 +91,7 @@ salsa::database_storage! {\n             fn library_symbols() for symbol_index::LibrarySymbolsQuery;\n         }\n         impl hir::db::HirDatabase {\n-            fn m_source_file() for hir::db::MSourceFileQuery;\n+            fn hir_source_file() for hir::db::HirSourceFileQuery;\n             fn expand_macro_invocation() for hir::db::ExpandMacroCallQuery;\n             fn module_tree() for hir::db::ModuleTreeQuery;\n             fn fn_scopes() for hir::db::FnScopesQuery;"}, {"sha": "ec7da437a1c4aed49baa2bc20705981ac19710af", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -230,7 +230,7 @@ impl AnalysisImpl {\n             Some(it) => it,\n         };\n         let root = descr.crate_root();\n-        let file_id = root.source().file_id();\n+        let file_id = root.file_id();\n \n         let crate_graph = self.db.crate_graph();\n         let crate_id = crate_graph.crate_id_for_crate_root(file_id);\n@@ -283,7 +283,7 @@ impl AnalysisImpl {\n                     if let Some(child_module) =\n                         source_binder::module_from_declaration(&*self.db, position.file_id, module)?\n                     {\n-                        let file_id = child_module.source().file_id();\n+                        let file_id = child_module.file_id();\n                         let name = match child_module.name() {\n                             Some(name) => name.to_string().into(),\n                             None => \"\".into(),"}, {"sha": "c0b56f30a5a418f277c3126fb624a8321b1adb28", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{SyntaxNode, SourceFileNode};\n use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, Cancelable};\n \n use crate::{\n-    DefLoc, DefId, Name, MFileId,\n+    DefLoc, DefId, Name, HirFileId,\n     SourceFileItems, SourceItemId,\n     query_definitions,\n     FnScopes,\n@@ -21,9 +21,9 @@ pub trait HirDatabase: SyntaxDatabase\n     + AsRef<LocationIntener<DefLoc, DefId>>\n     + AsRef<LocationIntener<MacroCallLoc, MacroCallId>>\n {\n-    fn m_source_file(mfile_id: MFileId) -> SourceFileNode {\n-        type MSourceFileQuery;\n-        use fn crate::query_definitions::m_source_file;\n+    fn hir_source_file(file_id: HirFileId) -> SourceFileNode {\n+        type HirSourceFileQuery;\n+        use fn HirFileId::source_file_query;\n     }\n     fn expand_macro_invocation(invoc: MacroCallId) -> Option<Arc<MacroExpansion>> {\n         type ExpandMacroCallQuery;\n@@ -60,7 +60,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::ty::type_for_field;\n     }\n \n-    fn file_items(mfile_id: MFileId) -> Arc<SourceFileItems> {\n+    fn file_items(file_id: HirFileId) -> Arc<SourceFileItems> {\n         type SourceFileItemsQuery;\n         use fn query_definitions::file_items;\n     }"}, {"sha": "3eba35a2460c2d5cdd458b7c5e6c111daaae43ba", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -1,4 +1,6 @@\n-use crate::{FileId, MacroCallId};\n+use crate::{FileId, MacroCallId, HirDatabase};\n+\n+use ra_syntax::SourceFileNode;\n \n /// hir makes a heavy use of ids: integer (u32) handlers to various things. You\n /// can think of id as a pointer (but without a lifetime) or a file descriptor\n@@ -20,13 +22,53 @@ use crate::{FileId, MacroCallId};\n /// (because everything bottoms out at the real `FileId`) and small\n /// (`MacroCallId` uses location interner).\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum MFileId {\n+pub struct HirFileId(HirFileIdRepr);\n+\n+impl HirFileId {\n+    pub(crate) fn original_file_id(self, db: &impl HirDatabase) -> FileId {\n+        match self.0 {\n+            HirFileIdRepr::File(file_id) => file_id,\n+            HirFileIdRepr::Macro(macro_call_id) => {\n+                let loc = macro_call_id.loc(db);\n+                loc.source_item_id.file_id.original_file_id(db)\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn as_original_file(self) -> FileId {\n+        match self.0 {\n+            HirFileIdRepr::File(file_id) => file_id,\n+            HirFileIdRepr::Macro(_r) => panic!(\"macro generated file: {:?}\", self),\n+        }\n+    }\n+    pub(crate) fn source_file_query(db: &impl HirDatabase, file_id: HirFileId) -> SourceFileNode {\n+        match file_id.0 {\n+            HirFileIdRepr::File(file_id) => db.source_file(file_id),\n+            HirFileIdRepr::Macro(m) => {\n+                if let Some(exp) = db.expand_macro_invocation(m) {\n+                    return exp.file();\n+                }\n+                // returning an empty string looks fishy...\n+                SourceFileNode::parse(\"\")\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+enum HirFileIdRepr {\n     File(FileId),\n     Macro(MacroCallId),\n }\n \n-impl From<FileId> for MFileId {\n-    fn from(file_id: FileId) -> MFileId {\n-        MFileId::File(file_id)\n+impl From<FileId> for HirFileId {\n+    fn from(file_id: FileId) -> HirFileId {\n+        HirFileId(HirFileIdRepr::File(file_id))\n+    }\n+}\n+\n+impl From<MacroCallId> for HirFileId {\n+    fn from(macro_call_id: MacroCallId) -> HirFileId {\n+        HirFileId(HirFileIdRepr::Macro(macro_call_id))\n     }\n }"}, {"sha": "4d4f599497b27857d252b61073df4191c5960ad7", "filename": "crates/ra_hir/src/krate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fkrate.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -1,6 +1,6 @@\n pub use ra_db::CrateId;\n \n-use crate::{HirDatabase, Module, Cancelable, Name, AsName};\n+use crate::{HirDatabase, Module, Cancelable, Name, AsName, HirFileId};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -35,6 +35,7 @@ impl Crate {\n         let crate_graph = db.crate_graph();\n         let file_id = crate_graph.crate_root(self.crate_id);\n         let source_root_id = db.file_source_root(file_id);\n+        let file_id = HirFileId::from(file_id);\n         let module_tree = db.module_tree(source_root_id)?;\n         // FIXME: teach module tree about crate roots instead of guessing\n         let (module_id, _) = ctry!(module_tree"}, {"sha": "c1386601d39a4922a53147b77f2588a4dab00bd4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -47,7 +47,7 @@ pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n     krate::Crate,\n-    ids::MFileId,\n+    ids::HirFileId,\n     macros::{MacroDef, MacroInput, MacroExpansion, MacroCallId, MacroCallLoc},\n     module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n     function::{Function, FnScopes},\n@@ -158,22 +158,22 @@ pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct SourceItemId {\n-    mfile_id: MFileId,\n+    file_id: HirFileId,\n     /// None for the whole file.\n     item_id: Option<SourceFileItemId>,\n }\n \n /// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n #[derive(Debug, PartialEq, Eq)]\n pub struct SourceFileItems {\n-    mfile_id: MFileId,\n+    file_id: HirFileId,\n     arena: Arena<SyntaxNode>,\n }\n \n impl SourceFileItems {\n-    fn new(mfile_id: MFileId, source_file: SourceFile) -> SourceFileItems {\n+    fn new(file_id: HirFileId, source_file: SourceFile) -> SourceFileItems {\n         let mut res = SourceFileItems {\n-            mfile_id,\n+            file_id,\n             arena: Arena::default(),\n         };\n         res.init(source_file);\n@@ -193,11 +193,11 @@ impl SourceFileItems {\n     fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n         self.arena.alloc(item)\n     }\n-    pub fn id_of(&self, mfile_id: MFileId, item: SyntaxNodeRef) -> SourceFileItemId {\n+    pub fn id_of(&self, file_id: HirFileId, item: SyntaxNodeRef) -> SourceFileItemId {\n         assert_eq!(\n-            self.mfile_id, mfile_id,\n+            self.file_id, file_id,\n             \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.mfile_id, mfile_id\n+            self.file_id, file_id\n         );\n         self.id_of_unchecked(item)\n     }"}, {"sha": "89b18194ac0f8402b8cde1feaa0b1df1eff7d166", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -189,7 +189,7 @@ salsa::database_storage! {\n             fn file_lines() for ra_db::FileLinesQuery;\n         }\n         impl db::HirDatabase {\n-            fn m_source_file() for db::MSourceFileQuery;\n+            fn hir_source_file() for db::HirSourceFileQuery;\n             fn expand_macro_invocation() for db::ExpandMacroCallQuery;\n             fn module_tree() for db::ModuleTreeQuery;\n             fn fn_scopes() for db::FnScopesQuery;"}, {"sha": "26171d27c39b6a0e45c3db20380806091c6f2ebe", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -15,7 +15,7 @@ use relative_path::RelativePathBuf;\n use crate::{\n     Def, DefKind, DefLoc, DefId,\n     Name, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n-    MFileId,\n+    HirFileId,\n     arena::{Arena, Id},\n };\n \n@@ -49,13 +49,17 @@ impl Module {\n     /// Returns `None` for the root module\n     pub fn parent_link_source(&self, db: &impl HirDatabase) -> Option<(FileId, ast::ModuleNode)> {\n         let link = self.module_id.parent_link(&self.tree)?;\n-        let file_id = link.owner(&self.tree).source(&self.tree).file_id();\n+        let file_id = link\n+            .owner(&self.tree)\n+            .source(&self.tree)\n+            .file_id()\n+            .as_original_file();\n         let src = link.bind_source(&self.tree, db);\n         Some((file_id, src))\n     }\n \n-    pub fn source(&self) -> ModuleSource {\n-        self.module_id.source(&self.tree)\n+    pub fn file_id(&self) -> FileId {\n+        self.source().file_id().as_original_file()\n     }\n \n     /// Parent module. Returns `None` if this is a root module.\n@@ -70,7 +74,7 @@ impl Module {\n     /// Returns the crate this module is part of.\n     pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n         let root_id = self.module_id.crate_root(&self.tree);\n-        let file_id = root_id.source(&self.tree).file_id();\n+        let file_id = root_id.source(&self.tree).file_id().as_original_file();\n         let crate_graph = db.crate_graph();\n         let crate_id = crate_graph.crate_id_for_crate_root(file_id)?;\n         Some(Crate::new(crate_id))\n@@ -163,6 +167,10 @@ impl Module {\n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n         self.module_id.problems(&self.tree, db)\n     }\n+\n+    pub(crate) fn source(&self) -> ModuleSource {\n+        self.module_id.source(&self.tree)\n+    }\n }\n \n /// Physically, rust source is organized as a set of files, but logically it is\n@@ -292,34 +300,28 @@ pub struct ModuleData {\n \n impl ModuleSource {\n     // precondition: item_id **must** point to module\n-    fn new(file_id: FileId, item_id: Option<SourceFileItemId>) -> ModuleSource {\n-        let source_item_id = SourceItemId {\n-            mfile_id: file_id.into(),\n-            item_id,\n-        };\n+    fn new(file_id: HirFileId, item_id: Option<SourceFileItemId>) -> ModuleSource {\n+        let source_item_id = SourceItemId { file_id, item_id };\n         ModuleSource(source_item_id)\n     }\n \n-    pub(crate) fn new_file(file_id: FileId) -> ModuleSource {\n+    pub(crate) fn new_file(file_id: HirFileId) -> ModuleSource {\n         ModuleSource::new(file_id, None)\n     }\n \n     pub(crate) fn new_inline(\n         db: &impl HirDatabase,\n-        file_id: FileId,\n+        file_id: HirFileId,\n         m: ast::Module,\n     ) -> ModuleSource {\n         assert!(!m.has_semi());\n-        let file_items = db.file_items(file_id.into());\n-        let item_id = file_items.id_of(file_id.into(), m.syntax());\n+        let file_items = db.file_items(file_id);\n+        let item_id = file_items.id_of(file_id, m.syntax());\n         ModuleSource::new(file_id, Some(item_id))\n     }\n \n-    pub fn file_id(self) -> FileId {\n-        match self.0.mfile_id {\n-            MFileId::File(file_id) => file_id,\n-            MFileId::Macro(_) => unreachable!(),\n-        }\n+    pub(crate) fn file_id(self) -> HirFileId {\n+        self.0.file_id\n     }\n \n     pub(crate) fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {"}, {"sha": "d1498a64647d8f1e11198daaafa0e9ddf300d925", "filename": "crates/ra_hir/src/module/imp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -64,7 +64,7 @@ fn create_module_tree<'a>(\n \n     let source_root = db.source_root(source_root);\n     for &file_id in source_root.files.values() {\n-        let source = ModuleSource::new_file(file_id);\n+        let source = ModuleSource::new_file(file_id.into());\n         if visited.contains(&source) {\n             continue; // TODO: use explicit crate_roots here\n         }\n@@ -123,7 +123,7 @@ fn build_subtree(\n                             visited,\n                             roots,\n                             Some(link),\n-                            ModuleSource::new_file(file_id),\n+                            ModuleSource::new_file(file_id.into()),\n                         ),\n                     })\n                     .collect::<Cancelable<Vec<_>>>()?;\n@@ -155,7 +155,7 @@ fn resolve_submodule(\n     name: &Name,\n ) -> (Vec<FileId>, Option<Problem>) {\n     // FIXME: handle submodules of inline modules properly\n-    let file_id = source.file_id();\n+    let file_id = source.file_id().original_file_id(db);\n     let source_root_id = db.file_source_root(file_id);\n     let path = db.file_relative_path(file_id);\n     let root = RelativePathBuf::default();"}, {"sha": "cc60ba0778d03b31e347d213aabe783439e51b09", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -25,7 +25,7 @@ use ra_syntax::{\n use ra_db::SourceRootId;\n \n use crate::{\n-    Cancelable, MFileId, FileId,\n+    Cancelable, HirFileId, FileId,\n     DefId, DefLoc, DefKind,\n     SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,\n@@ -95,9 +95,11 @@ pub struct NamedImport {\n }\n \n impl NamedImport {\n+    // FIXME: this is only here for one use-case in completion. Seems like a\n+    // pretty gross special case.\n     pub fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n         let source_item_id = SourceItemId {\n-            mfile_id: file_id.into(),\n+            file_id: file_id.into(),\n             item_id: Some(self.file_item_id),\n         };\n         let syntax = db.file_item(source_item_id);\n@@ -211,25 +213,25 @@ impl<T> PerNs<T> {\n impl InputModuleItems {\n     pub(crate) fn add_item(\n         &mut self,\n-        mfile_id: MFileId,\n+        file_id: HirFileId,\n         file_items: &SourceFileItems,\n         item: ast::ModuleItem,\n     ) -> Option<()> {\n         match item {\n             ast::ModuleItem::StructDef(it) => {\n-                self.items.push(ModuleItem::new(mfile_id, file_items, it)?)\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n             ast::ModuleItem::EnumDef(it) => {\n-                self.items.push(ModuleItem::new(mfile_id, file_items, it)?)\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n             ast::ModuleItem::FnDef(it) => {\n-                self.items.push(ModuleItem::new(mfile_id, file_items, it)?)\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n             ast::ModuleItem::TraitDef(it) => {\n-                self.items.push(ModuleItem::new(mfile_id, file_items, it)?)\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n             ast::ModuleItem::TypeDef(it) => {\n-                self.items.push(ModuleItem::new(mfile_id, file_items, it)?)\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n             ast::ModuleItem::ImplItem(_) => {\n                 // impls don't define items\n@@ -239,13 +241,13 @@ impl InputModuleItems {\n                 // TODO\n             }\n             ast::ModuleItem::ConstDef(it) => {\n-                self.items.push(ModuleItem::new(mfile_id, file_items, it)?)\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n             ast::ModuleItem::StaticDef(it) => {\n-                self.items.push(ModuleItem::new(mfile_id, file_items, it)?)\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n             ast::ModuleItem::Module(it) => {\n-                self.items.push(ModuleItem::new(mfile_id, file_items, it)?)\n+                self.items.push(ModuleItem::new(file_id, file_items, it)?)\n             }\n         }\n         Some(())\n@@ -269,15 +271,15 @@ impl InputModuleItems {\n \n impl ModuleItem {\n     fn new<'a>(\n-        mfile_id: MFileId,\n+        file_id: HirFileId,\n         file_items: &SourceFileItems,\n         item: impl ast::NameOwner<'a>,\n     ) -> Option<ModuleItem> {\n         let name = item.name()?.as_name();\n         let kind = item.syntax().kind();\n         let vis = Vis::Other;\n         let item_id = Some(file_items.id_of_unchecked(item.syntax()));\n-        let id = SourceItemId { mfile_id, item_id };\n+        let id = SourceItemId { file_id, item_id };\n         let res = ModuleItem {\n             id,\n             name,\n@@ -339,7 +341,8 @@ where\n             let root_id = module_id.crate_root(&self.module_tree);\n             let file_id = root_id.source(&self.module_tree).file_id();\n             let crate_graph = self.db.crate_graph();\n-            if let Some(crate_id) = crate_graph.crate_id_for_crate_root(file_id) {\n+            if let Some(crate_id) = crate_graph.crate_id_for_crate_root(file_id.as_original_file())\n+            {\n                 let krate = Crate::new(crate_id);\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db)? {"}, {"sha": "bc1f919389a5d8f141b3553ab0a058fcf73d3dbb", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -5,13 +5,13 @@ use std::{\n \n use rustc_hash::FxHashMap;\n use ra_syntax::{\n-    AstNode, SyntaxNode, SourceFileNode,\n+    AstNode, SyntaxNode,\n     ast::{self, NameOwner, ModuleItemOwner}\n };\n-use ra_db::{SourceRootId, FileId, Cancelable,};\n+use ra_db::{SourceRootId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind, Function, DefId, Name, AsName, MFileId,\n+    SourceFileItems, SourceItemId, DefKind, Function, DefId, Name, AsName, HirFileId,\n     macros::MacroCallLoc,\n     db::HirDatabase,\n     function::FnScopes,\n@@ -48,29 +48,17 @@ pub(super) fn enum_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<\n     Ok(Arc::new(EnumData::new(enum_def.borrowed())))\n }\n \n-pub(super) fn m_source_file(db: &impl HirDatabase, mfile_id: MFileId) -> SourceFileNode {\n-    match mfile_id {\n-        MFileId::File(file_id) => db.source_file(file_id),\n-        MFileId::Macro(m) => {\n-            if let Some(exp) = db.expand_macro_invocation(m) {\n-                return exp.file();\n-            }\n-            SourceFileNode::parse(\"\")\n-        }\n-    }\n-}\n-\n-pub(super) fn file_items(db: &impl HirDatabase, mfile_id: MFileId) -> Arc<SourceFileItems> {\n-    let source_file = db.m_source_file(mfile_id);\n+pub(super) fn file_items(db: &impl HirDatabase, file_id: HirFileId) -> Arc<SourceFileItems> {\n+    let source_file = db.hir_source_file(file_id);\n     let source_file = source_file.borrowed();\n-    let res = SourceFileItems::new(mfile_id, source_file);\n+    let res = SourceFileItems::new(file_id, source_file);\n     Arc::new(res)\n }\n \n pub(super) fn file_item(db: &impl HirDatabase, source_item_id: SourceItemId) -> SyntaxNode {\n     match source_item_id.item_id {\n-        Some(id) => db.file_items(source_item_id.mfile_id)[id].clone(),\n-        None => db.m_source_file(source_item_id.mfile_id).syntax().owned(),\n+        Some(id) => db.file_items(source_item_id.file_id)[id].clone(),\n+        None => db.hir_source_file(source_item_id.file_id).syntax().owned(),\n     }\n }\n \n@@ -92,7 +80,7 @@ pub(crate) fn submodules(\n \n     fn collect_submodules<'a>(\n         db: &impl HirDatabase,\n-        file_id: FileId,\n+        file_id: HirFileId,\n         root: impl ast::ModuleItemOwner<'a>,\n     ) -> Vec<Submodule> {\n         modules(root)\n@@ -129,30 +117,30 @@ pub(super) fn input_module_items(\n ) -> Cancelable<Arc<InputModuleItems>> {\n     let module_tree = db.module_tree(source_root_id)?;\n     let source = module_id.source(&module_tree);\n-    let mfile_id = source.file_id().into();\n-    let file_items = db.file_items(mfile_id);\n+    let file_id = source.file_id();\n+    let file_items = db.file_items(file_id);\n     let fill = |acc: &mut InputModuleItems, items: &mut Iterator<Item = ast::ItemOrMacro>| {\n         for item in items {\n             match item {\n                 ast::ItemOrMacro::Item(it) => {\n-                    acc.add_item(mfile_id, &file_items, it);\n+                    acc.add_item(file_id, &file_items, it);\n                 }\n                 ast::ItemOrMacro::Macro(macro_call) => {\n                     let item_id = file_items.id_of_unchecked(macro_call.syntax());\n                     let loc = MacroCallLoc {\n                         source_root_id,\n                         module_id,\n                         source_item_id: SourceItemId {\n-                            mfile_id,\n+                            file_id,\n                             item_id: Some(item_id),\n                         },\n                     };\n                     let id = loc.id(db);\n-                    let mfile_id = MFileId::Macro(id);\n-                    let file_items = db.file_items(mfile_id);\n+                    let file_id = HirFileId::from(id);\n+                    let file_items = db.file_items(file_id);\n                     //FIXME: expand recursively\n-                    for item in db.m_source_file(mfile_id).borrowed().items() {\n-                        acc.add_item(mfile_id, &file_items, item);\n+                    for item in db.hir_source_file(file_id).borrowed().items() {\n+                        acc.add_item(file_id, &file_items, item);\n                     }\n                 }\n             }"}, {"sha": "24490d119c73e5e267eaa13a6418c6a445b797c4", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=37ed2f35badfb41cd6c50ef04d6fd6a6ce67e0d1", "patch": "@@ -20,7 +20,7 @@ use crate::{\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable<Option<Module>> {\n-    let module_source = ModuleSource::new_file(file_id);\n+    let module_source = ModuleSource::new_file(file_id.into());\n     module_from_source(db, module_source)\n }\n \n@@ -50,8 +50,8 @@ pub fn module_from_position(\n ) -> Cancelable<Option<Module>> {\n     let file = db.source_file(position.file_id);\n     let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset) {\n-        Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id, m),\n-        _ => ModuleSource::new_file(position.file_id),\n+        Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id.into(), m),\n+        _ => ModuleSource::new_file(position.file_id.into()),\n     };\n     module_from_source(db, module_source)\n }\n@@ -67,9 +67,9 @@ pub fn module_from_child_node(\n         .filter_map(ast::Module::cast)\n         .find(|it| !it.has_semi())\n     {\n-        ModuleSource::new_inline(db, file_id, m)\n+        ModuleSource::new_inline(db, file_id.into(), m)\n     } else {\n-        ModuleSource::new_file(file_id)\n+        ModuleSource::new_file(file_id.into())\n     };\n     module_from_source(db, module_source)\n }\n@@ -78,7 +78,7 @@ fn module_from_source(\n     db: &impl HirDatabase,\n     module_source: ModuleSource,\n ) -> Cancelable<Option<Module>> {\n-    let source_root_id = db.file_source_root(module_source.file_id());\n+    let source_root_id = db.file_source_root(module_source.file_id().as_original_file());\n     let module_tree = db.module_tree(source_root_id)?;\n     let m = module_tree\n         .modules_with_sources()\n@@ -102,11 +102,11 @@ pub fn function_from_module(\n     module: &Module,\n     fn_def: ast::FnDef,\n ) -> Function {\n-    let mfile_id = module.source().file_id().into();\n-    let file_items = db.file_items(mfile_id);\n-    let item_id = file_items.id_of(mfile_id, fn_def.syntax());\n+    let file_id = module.source().file_id();\n+    let file_items = db.file_items(file_id);\n+    let item_id = file_items.id_of(file_id, fn_def.syntax());\n     let source_item_id = SourceItemId {\n-        mfile_id,\n+        file_id,\n         item_id: Some(item_id),\n     };\n     let def_loc = DefLoc {"}]}