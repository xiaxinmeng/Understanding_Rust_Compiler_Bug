{"sha": "04b50e22bb978f10d90df78a377f23fd122a8d83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YjUwZTIyYmI5NzhmMTBkOTBkZjc4YTM3N2YyM2ZkMTIyYThkODM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-17T00:41:14Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-20T04:00:51Z"}, "message": "Convert `AllSets::on_entry_sets` to a `Vec<IdxSetBuf<E>>`.\n\nThis makes it more like `AllSets::{gen,kill}_set`, removes the need for\na bunch of bitset range computations, and removes the need for `Bits`.\n\nIt's marginally less efficient, because we have to allocate one bitset\nper basic block instead of one large shared bitset, but the difference\nis negligible in practice.", "tree": {"sha": "e6c7531c2c56c52d6d2e168158c8954778c51045", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6c7531c2c56c52d6d2e168158c8954778c51045"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04b50e22bb978f10d90df78a377f23fd122a8d83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04b50e22bb978f10d90df78a377f23fd122a8d83", "html_url": "https://github.com/rust-lang/rust/commit/04b50e22bb978f10d90df78a377f23fd122a8d83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04b50e22bb978f10d90df78a377f23fd122a8d83/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ac79c718475fd29b8be34dde667b683390c2aee", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac79c718475fd29b8be34dde667b683390c2aee", "html_url": "https://github.com/rust-lang/rust/commit/3ac79c718475fd29b8be34dde667b683390c2aee"}], "stats": {"total": 54, "additions": 14, "deletions": 40}, "files": [{"sha": "0881b66e5508b0b7045302ebf33c45d43384518d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 14, "deletions": 40, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/04b50e22bb978f10d90df78a377f23fd122a8d83/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b50e22bb978f10d90df78a377f23fd122a8d83/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=04b50e22bb978f10d90df78a377f23fd122a8d83", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast::{self, MetaItem};\n \n-use rustc_data_structures::bitslice::{bitwise, BitwiseOperator, Word};\n+use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n use rustc_data_structures::indexed_set::{HybridIdxSetBuf, IdxSet, IdxSetBuf};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;\n@@ -23,7 +23,6 @@ use rustc::session::Session;\n use std::borrow::Borrow;\n use std::fmt;\n use std::io;\n-use std::mem;\n use std::path::PathBuf;\n use std::usize;\n \n@@ -287,18 +286,6 @@ impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n     }\n }\n \n-/// Maps each block to a set of bits\n-#[derive(Clone, Debug)]\n-pub(crate) struct Bits<E:Idx> {\n-    bits: IdxSetBuf<E>,\n-}\n-\n-impl<E:Idx> Bits<E> {\n-    fn new(bits: IdxSetBuf<E>) -> Self {\n-        Bits { bits: bits }\n-    }\n-}\n-\n /// DataflowResultsConsumer abstracts over walking the MIR with some\n /// already constructed dataflow results.\n ///\n@@ -464,12 +451,8 @@ pub struct AllSets<E: Idx> {\n     /// Analysis bitwidth for each block.\n     bits_per_block: usize,\n \n-    /// Number of words associated with each block entry\n-    /// equal to bits_per_block / (mem::size_of::<Word> * 8), rounded up.\n-    words_per_block: usize,\n-\n     /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Bits<E>,\n+    on_entry_sets: Vec<IdxSetBuf<E>>,\n \n     /// For each block, bits generated by executing the statements in\n     /// the block. (For comparison, the Terminator for each block is\n@@ -559,19 +542,15 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n impl<E:Idx> AllSets<E> {\n     pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n     pub fn for_block(&mut self, block_idx: usize) -> BlockSets<E> {\n-        let offset = self.words_per_block * block_idx;\n-        let range = E::new(offset)..E::new(offset + self.words_per_block);\n         BlockSets {\n-            on_entry: self.on_entry_sets.bits.range_mut(&range),\n+            on_entry: &mut self.on_entry_sets[block_idx],\n             gen_set: &mut self.gen_sets[block_idx],\n             kill_set: &mut self.kill_sets[block_idx],\n         }\n     }\n \n-    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n-        let offset = self.words_per_block * block_idx;\n-        let range = E::new(offset)..E::new(offset + self.words_per_block);\n-        self.on_entry_sets.bits.range(&range)\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSetBuf<E> {\n+        &self.on_entry_sets[block_idx]\n     }\n     pub fn gen_set_for(&self, block_idx: usize) -> &HybridIdxSetBuf<E> {\n         &self.gen_sets[block_idx]\n@@ -731,29 +710,25 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n                denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();\n-        let bits_per_word = mem::size_of::<Word>() * 8;\n-        let words_per_block = (bits_per_block + bits_per_word - 1) / bits_per_word;\n-        let bits_per_block_rounded_up = words_per_block * bits_per_word; // a multiple of word size\n         let num_blocks = mir.basic_blocks().len();\n-        let num_overall = num_blocks * bits_per_block_rounded_up;\n \n-        let on_entry = Bits::new(if D::bottom_value() {\n-            IdxSetBuf::new_filled(num_overall)\n+        let on_entry_sets = if D::bottom_value() {\n+            vec![IdxSetBuf::new_filled(bits_per_block); num_blocks]\n         } else {\n-            IdxSetBuf::new_empty(num_overall)\n-        });\n-        let empties = vec![HybridIdxSetBuf::new_empty(bits_per_block); num_blocks];\n+            vec![IdxSetBuf::new_empty(bits_per_block); num_blocks]\n+        };\n+        let gen_sets = vec![HybridIdxSetBuf::new_empty(bits_per_block); num_blocks];\n+        let kill_sets = gen_sets.clone();\n \n         DataflowAnalysis {\n             mir,\n             dead_unwinds,\n             flow_state: DataflowState {\n                 sets: AllSets {\n                     bits_per_block,\n-                    words_per_block,\n-                    on_entry_sets: on_entry,\n-                    gen_sets: empties.clone(),\n-                    kill_sets: empties,\n+                    on_entry_sets,\n+                    gen_sets,\n+                    kill_sets,\n                 },\n                 operator: denotation,\n             }\n@@ -873,5 +848,4 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n             dirty_queue.insert(bb);\n         }\n     }\n-\n }"}]}