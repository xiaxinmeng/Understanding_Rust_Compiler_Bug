{"sha": "09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZWMwYTE1ZmEwNmIxNmE5YWRkY2EyZTNiZjhlNmYzMGZmMDI3ZDA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-03T16:53:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-03T16:53:12Z"}, "message": "Merge #9773\n\n9773: internal: Improve `extract_function` assist r=Veykril a=Veykril\n\n- fix: It doesn't try to overwrite parts of selected comments any longer\r\n- fix: It doesn't wrap tail expressions and return types in a result or option unnecessarily\r\n- feat?: It now adds a `const` modifier to the created function if extract somethings from a const context \r\n\r\nFixes #7840\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "d632d79744e173a5a05eb72a6be93369a936d3fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d632d79744e173a5a05eb72a6be93369a936d3fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhCXR4CRBK7hj4Ov3rIwAAankIAIevsgsaum0cGpETrRXOkibi\nO2FNBiZtM3QKJrJDxSU9CHShl54JyjWizvyAyHzFNWv8t7tTWhKt46VEdnESwsCc\n6q6WvKGjQNQmF/rrt1zRk291auZu7Ih1TTKiIbtIzUvMQq8nxIETCWwbbOVZYQ09\nTRWyaZEA9vgpLNAabRMhLzoH7KXWVKWKy3IlO4mi/rDkawMRcXwi5PsIx2uat+0I\ni0H3E1MVDr7DB8vmaGw8pLi/DFIz+fUb85dWMBzkPQwAh4Mwj6zk4UYMylnrXfhM\n9eImdUNMrNNgUXubvsfFwq+aUe0bd1dRqSrYhm482+ONKhqT2EeLrOdsadIzmUk=\n=vtWg\n-----END PGP SIGNATURE-----\n", "payload": "tree d632d79744e173a5a05eb72a6be93369a936d3fa\nparent 00c8cab20b057ebd75166936fffd649d29a9fd29\nparent 9edaf0cad864416d06cafc56ade27dd372430aed\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628009592 +0000\ncommitter GitHub <noreply@github.com> 1628009592 +0000\n\nMerge #9773\n\n9773: internal: Improve `extract_function` assist r=Veykril a=Veykril\n\n- fix: It doesn't try to overwrite parts of selected comments any longer\r\n- fix: It doesn't wrap tail expressions and return types in a result or option unnecessarily\r\n- feat?: It now adds a `const` modifier to the created function if extract somethings from a const context \r\n\r\nFixes #7840\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0", "html_url": "https://github.com/rust-lang/rust/commit/09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00c8cab20b057ebd75166936fffd649d29a9fd29", "url": "https://api.github.com/repos/rust-lang/rust/commits/00c8cab20b057ebd75166936fffd649d29a9fd29", "html_url": "https://github.com/rust-lang/rust/commit/00c8cab20b057ebd75166936fffd649d29a9fd29"}, {"sha": "9edaf0cad864416d06cafc56ade27dd372430aed", "url": "https://api.github.com/repos/rust-lang/rust/commits/9edaf0cad864416d06cafc56ade27dd372430aed", "html_url": "https://github.com/rust-lang/rust/commit/9edaf0cad864416d06cafc56ade27dd372430aed"}], "stats": {"total": 846, "additions": 512, "deletions": 334}, "files": [{"sha": "e6cac754fe0f409d2906b9cfcd4ce94b31f95f01", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 512, "deletions": 334, "changes": 846, "blob_url": "https://github.com/rust-lang/rust/blob/09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=09ec0a15fa06b16a9addca2e3bf8e6f30ff027d0", "patch": "@@ -8,6 +8,7 @@ use ide_db::{\n     search::{FileReference, ReferenceAccess, SearchScope},\n     RootDatabase,\n };\n+use itertools::Itertools;\n use rustc_hash::FxHasher;\n use stdx::format_to;\n use syntax::{\n@@ -16,7 +17,7 @@ use syntax::{\n         edit::{AstNodeEdit, IndentLevel},\n         AstNode,\n     },\n-    ted,\n+    match_ast, ted,\n     SyntaxKind::{self, COMMENT},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n@@ -70,17 +71,17 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n     let body = extraction_target(&node, range)?;\n+    let mods = body.analyze_container()?;\n \n-    let (locals_used, has_await, self_param) = analyze_body(&ctx.sema, &body);\n+    let (locals_used, self_param) = body.analyze(&ctx.sema);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n     let insert_after = node_to_insert_after(&body, anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n-    let ret_ty = body_return_ty(ctx, &body)?;\n-    let ret_values = ret_values(ctx, &body, node.parent().as_ref().unwrap_or(&node));\n-\n-    let control_flow = external_control_flow(ctx, &body)?;\n+    let ret_ty = body.return_ty(ctx)?;\n+    let control_flow = body.external_control_flow(ctx)?;\n+    let ret_values = body.ret_values(ctx, node.parent().as_ref().unwrap_or(&node));\n \n     let target_range = body.text_range();\n \n@@ -89,37 +90,32 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         \"Extract into function\",\n         target_range,\n         move |builder| {\n-            let ret_values: Vec<_> = ret_values.collect();\n-            if stdx::never!(!ret_values.is_empty() && !ret_ty.is_unit()) {\n+            let outliving_locals: Vec<_> = ret_values.collect();\n+            if stdx::never!(!outliving_locals.is_empty() && !ret_ty.is_unit()) {\n                 // We should not have variables that outlive body if we have expression block\n+                stdx::never!();\n                 return;\n             }\n \n-            let params = extracted_function_params(ctx, &body, locals_used.iter().copied());\n+            let params = body.extracted_function_params(ctx, locals_used.iter().copied());\n \n-            let insert_comma = body\n-                .parent()\n-                .and_then(ast::MatchArm::cast)\n-                .map_or(false, |it| it.comma_token().is_none());\n             let fun = Function {\n                 name: \"fun_name\".to_string(),\n                 self_param,\n                 params,\n                 control_flow,\n                 ret_ty,\n                 body,\n-                vars_defined_in_body_and_outlive: ret_values,\n+                outliving_locals,\n+                mods,\n             };\n \n             let new_indent = IndentLevel::from_node(&insert_after);\n             let old_indent = fun.body.indent_level();\n \n-            builder.replace(target_range, make_call(ctx, &fun, old_indent, has_await));\n-            if insert_comma {\n-                builder.insert(target_range.end(), \",\");\n-            }\n+            builder.replace(target_range, make_call(ctx, &fun, old_indent));\n \n-            let fn_def = format_function(ctx, module, &fun, old_indent, new_indent, has_await);\n+            let fn_def = format_function(ctx, module, &fun, old_indent, new_indent);\n             let insert_offset = insert_after.text_range().end();\n             match ctx.config.snippet_cap {\n                 Some(cap) => builder.insert_snippet(cap, insert_offset, fn_def),\n@@ -128,6 +124,50 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         },\n     )\n }\n+\n+/// Try to guess what user wants to extract\n+///\n+/// We have basically have two cases:\n+/// * We want whole node, like `loop {}`, `2 + 2`, `{ let n = 1; }` exprs.\n+///   Then we can use `ast::Expr`\n+/// * We want a few statements for a block. E.g.\n+///   ```rust,no_run\n+///   fn foo() -> i32 {\n+///     let m = 1;\n+///     $0\n+///     let n = 2;\n+///     let k = 3;\n+///     k + n\n+///     $0\n+///   }\n+///   ```\n+///\n+fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<FunctionBody> {\n+    if let Some(stmt) = ast::Stmt::cast(node.clone()) {\n+        return match stmt {\n+            ast::Stmt::Item(_) => None,\n+            ast::Stmt::ExprStmt(_) | ast::Stmt::LetStmt(_) => Some(FunctionBody::from_range(\n+                node.parent().and_then(ast::BlockExpr::cast)?,\n+                node.text_range(),\n+            )),\n+        };\n+    }\n+\n+    let expr = ast::Expr::cast(node.clone())?;\n+    // A node got selected fully\n+    if node.text_range() == selection_range {\n+        return FunctionBody::from_expr(expr.clone());\n+    }\n+\n+    // Covering element returned the parent block of one or multiple statements that have been selected\n+    if let ast::Expr::BlockExpr(block) = expr {\n+        // Extract the full statements.\n+        return Some(FunctionBody::from_range(block, selection_range));\n+    }\n+\n+    node.ancestors().find_map(ast::Expr::cast).and_then(FunctionBody::from_expr)\n+}\n+\n #[derive(Debug)]\n struct Function {\n     name: String,\n@@ -136,7 +176,8 @@ struct Function {\n     control_flow: ControlFlow,\n     ret_ty: RetType,\n     body: FunctionBody,\n-    vars_defined_in_body_and_outlive: Vec<OutlivedLocal>,\n+    outliving_locals: Vec<OutlivedLocal>,\n+    mods: Modifiers,\n }\n \n #[derive(Debug)]\n@@ -175,6 +216,13 @@ enum Anchor {\n #[derive(Debug)]\n struct ControlFlow {\n     kind: Option<FlowKind>,\n+    is_async: bool,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct Modifiers {\n+    is_const: bool,\n+    is_in_tail: bool,\n }\n \n /// Control flow that is exported from extracted function\n@@ -266,7 +314,7 @@ impl Function {\n         match &self.ret_ty {\n             RetType::Expr(ty) if ty.is_unit() => FunType::Unit,\n             RetType::Expr(ty) => FunType::Single(ty.clone()),\n-            RetType::Stmt => match self.vars_defined_in_body_and_outlive.as_slice() {\n+            RetType::Stmt => match self.outliving_locals.as_slice() {\n                 [] => FunType::Unit,\n                 [var] => FunType::Single(var.local.ty(ctx.db())),\n                 vars => {\n@@ -324,6 +372,24 @@ impl Param {\n     }\n }\n \n+impl TryKind {\n+    fn of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n+        if ty.is_unknown() {\n+            // We favour Result for `expr?`\n+            return Some(TryKind::Result { ty });\n+        }\n+        let adt = ty.as_adt()?;\n+        let name = adt.name(ctx.db());\n+        // FIXME: use lang items to determine if it is std type or user defined\n+        //        E.g. if user happens to define type named `Option`, we would have false positive\n+        match name.to_string().as_str() {\n+            \"Option\" => Some(TryKind::Option),\n+            \"Result\" => Some(TryKind::Result { ty }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl FlowKind {\n     fn make_result_handler(&self, expr: Option<ast::Expr>) -> ast::Expr {\n         match self {\n@@ -356,22 +422,6 @@ impl FlowKind {\n     }\n }\n \n-fn try_kind_of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n-    if ty.is_unknown() {\n-        // We favour Result for `expr?`\n-        return Some(TryKind::Result { ty });\n-    }\n-    let adt = ty.as_adt()?;\n-    let name = adt.name(ctx.db());\n-    // FIXME: use lang items to determine if it is std type or user defined\n-    //        E.g. if user happens to define type named `Option`, we would have false positive\n-    match name.to_string().as_str() {\n-        \"Option\" => Some(TryKind::Option),\n-        \"Result\" => Some(TryKind::Result { ty }),\n-        _ => None,\n-    }\n-}\n-\n impl FunctionBody {\n     fn parent(&self) -> Option<SyntaxNode> {\n         match self {\n@@ -389,8 +439,23 @@ impl FunctionBody {\n         }\n     }\n \n-    fn from_range(parent: ast::BlockExpr, text_range: TextRange) -> FunctionBody {\n-        Self::Span { parent, text_range }\n+    fn from_range(parent: ast::BlockExpr, selected: TextRange) -> FunctionBody {\n+        let mut text_range = parent\n+            .statements()\n+            .map(|stmt| stmt.syntax().text_range())\n+            .filter(|&stmt| selected.intersect(stmt).filter(|it| !it.is_empty()).is_some())\n+            .fold1(|acc, stmt| acc.cover(stmt));\n+        if let Some(tail_range) = parent\n+            .tail_expr()\n+            .map(|it| it.syntax().text_range())\n+            .filter(|&it| selected.intersect(it).is_some())\n+        {\n+            text_range = Some(match text_range {\n+                Some(text_range) => text_range.cover(tail_range),\n+                None => tail_range,\n+            });\n+        }\n+        Self::Span { parent, text_range: text_range.unwrap_or(selected) }\n     }\n \n     fn indent_level(&self) -> IndentLevel {\n@@ -509,140 +574,245 @@ impl FunctionBody {\n     }\n }\n \n-/// Try to guess what user wants to extract\n-///\n-/// We have basically have two cases:\n-/// * We want whole node, like `loop {}`, `2 + 2`, `{ let n = 1; }` exprs.\n-///   Then we can use `ast::Expr`\n-/// * We want a few statements for a block. E.g.\n-///   ```rust,no_run\n-///   fn foo() -> i32 {\n-///     let m = 1;\n-///     $0\n-///     let n = 2;\n-///     let k = 3;\n-///     k + n\n-///     $0\n-///   }\n-///   ```\n-///\n-fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<FunctionBody> {\n-    if let Some(stmt) = ast::Stmt::cast(node.clone()) {\n-        return match stmt {\n-            ast::Stmt::Item(_) => None,\n-            ast::Stmt::ExprStmt(_) | ast::Stmt::LetStmt(_) => Some(FunctionBody::from_range(\n-                node.parent().and_then(ast::BlockExpr::cast)?,\n-                node.text_range(),\n-            )),\n+impl FunctionBody {\n+    /// Analyzes a function body, returning the used local variables that are referenced in it as well as\n+    /// whether it contains an await expression.\n+    fn analyze(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> (FxIndexSet<Local>, Option<ast::SelfParam>) {\n+        // FIXME: currently usages inside macros are not found\n+        let mut self_param = None;\n+        let mut res = FxIndexSet::default();\n+        self.walk_expr(&mut |expr| {\n+            let name_ref = match expr {\n+                ast::Expr::PathExpr(path_expr) => {\n+                    path_expr.path().and_then(|it| it.as_single_name_ref())\n+                }\n+                _ => return,\n+            };\n+            if let Some(name_ref) = name_ref {\n+                if let Some(\n+                    NameRefClass::Definition(Definition::Local(local_ref))\n+                    | NameRefClass::FieldShorthand { local_ref, field_ref: _ },\n+                ) = NameRefClass::classify(sema, &name_ref)\n+                {\n+                    if local_ref.is_self(sema.db) {\n+                        match local_ref.source(sema.db).value {\n+                            Either::Right(it) => {\n+                                stdx::always!(\n+                                    self_param.replace(it).is_none(),\n+                                    \"body references two different self params\"\n+                                );\n+                            }\n+                            Either::Left(_) => {\n+                                stdx::never!(\n+                                    \"Local::is_self returned true, but source is IdentPat\"\n+                                );\n+                            }\n+                        }\n+                    } else {\n+                        res.insert(local_ref);\n+                    }\n+                }\n+            }\n+        });\n+        (res, self_param)\n+    }\n+\n+    fn analyze_container(&self) -> Option<Modifiers> {\n+        let mut is_const = false;\n+        let container_expr = self.parent()?.ancestors().find_map(|it| {\n+            // double Option as we want to short circuit\n+            let res = match_ast! {\n+                match it {\n+                    ast::ClosureExpr(closure) => closure.body(),\n+                    ast::EffectExpr(effect) => {\n+                        is_const = effect.const_token().is_some();\n+                        effect.block_expr().map(ast::Expr::BlockExpr)\n+                    },\n+                    ast::Fn(fn_) => {\n+                        is_const = fn_.const_token().is_some();\n+                        fn_.body().map(ast::Expr::BlockExpr)\n+                    },\n+                    ast::Static(statik) => {\n+                        is_const = true;\n+                        statik.body()\n+                    },\n+                    ast::ConstArg(ca) => {\n+                        is_const = true;\n+                        ca.expr()\n+                    },\n+                    ast::Const(konst) => {\n+                        is_const = true;\n+                        konst.body()\n+                    },\n+                    ast::ConstParam(cp) => {\n+                        is_const = true;\n+                        cp.default_val()\n+                    },\n+                    ast::ConstBlockPat(cbp) => {\n+                        is_const = true;\n+                        cbp.block_expr().map(ast::Expr::BlockExpr)\n+                    },\n+                    ast::Variant(__) => None,\n+                    ast::Meta(__) => None,\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        })??;\n+        let container_tail = match container_expr {\n+            ast::Expr::BlockExpr(block) => block.tail_expr(),\n+            expr => Some(expr),\n         };\n+        let is_in_tail =\n+            container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n+                container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n+            });\n+        Some(Modifiers { is_in_tail, is_const })\n     }\n \n-    let expr = ast::Expr::cast(node.clone())?;\n-    // A node got selected fully\n-    if node.text_range() == selection_range {\n-        return FunctionBody::from_expr(expr.clone());\n-    }\n-\n-    // Covering element returned the parent block of one or multiple statements that have been selected\n-    if let ast::Expr::BlockExpr(block) = expr {\n-        // Extract the full statements.\n-        let mut statements_range = block\n-            .statements()\n-            .filter(|stmt| selection_range.intersect(stmt.syntax().text_range()).is_some())\n-            .fold(selection_range, |acc, stmt| acc.cover(stmt.syntax().text_range()));\n-        if let Some(e) = block\n-            .tail_expr()\n-            .filter(|it| selection_range.intersect(it.syntax().text_range()).is_some())\n-        {\n-            statements_range = statements_range.cover(e.syntax().text_range());\n+    fn return_ty(&self, ctx: &AssistContext) -> Option<RetType> {\n+        match self.tail_expr() {\n+            Some(expr) => ctx.sema.type_of_expr(&expr).map(TypeInfo::original).map(RetType::Expr),\n+            None => Some(RetType::Stmt),\n         }\n-        return Some(FunctionBody::from_range(block, statements_range));\n     }\n \n-    node.ancestors().find_map(ast::Expr::cast).and_then(FunctionBody::from_expr)\n-}\n+    /// Local variables defined inside `body` that are accessed outside of it\n+    fn ret_values<'a>(\n+        &self,\n+        ctx: &'a AssistContext,\n+        parent: &SyntaxNode,\n+    ) -> impl Iterator<Item = OutlivedLocal> + 'a {\n+        let parent = parent.clone();\n+        let range = self.text_range();\n+        locals_defined_in_body(&ctx.sema, self)\n+            .into_iter()\n+            .filter_map(move |local| local_outlives_body(ctx, range, local, &parent))\n+    }\n+\n+    /// Analyses the function body for external control flow.\n+    fn external_control_flow(&self, ctx: &AssistContext) -> Option<ControlFlow> {\n+        let mut ret_expr = None;\n+        let mut try_expr = None;\n+        let mut break_expr = None;\n+        let mut continue_expr = None;\n+        let mut is_async = false;\n+\n+        let mut loop_depth = 0;\n+\n+        self.preorder_expr(&mut |expr| {\n+            let expr = match expr {\n+                WalkEvent::Enter(e) => e,\n+                WalkEvent::Leave(\n+                    ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n+                ) => {\n+                    loop_depth -= 1;\n+                    return false;\n+                }\n+                WalkEvent::Leave(_) => return false,\n+            };\n+            match expr {\n+                ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n+                    loop_depth += 1;\n+                }\n+                ast::Expr::ReturnExpr(it) => {\n+                    ret_expr = Some(it);\n+                }\n+                ast::Expr::TryExpr(it) => {\n+                    try_expr = Some(it);\n+                }\n+                ast::Expr::BreakExpr(it) if loop_depth == 0 => {\n+                    break_expr = Some(it);\n+                }\n+                ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n+                    continue_expr = Some(it);\n+                }\n+                ast::Expr::AwaitExpr(_) => is_async = true,\n+                _ => {}\n+            }\n+            false\n+        });\n \n-/// Analyzes a function body, returning the used local variables that are referenced in it as well as\n-/// whether it contains an await expression.\n-fn analyze_body(\n-    sema: &Semantics<RootDatabase>,\n-    body: &FunctionBody,\n-) -> (FxIndexSet<Local>, bool, Option<ast::SelfParam>) {\n-    // FIXME: currently usages inside macros are not found\n-    let mut has_await = false;\n-    let mut self_param = None;\n-    let mut res = FxIndexSet::default();\n-    body.walk_expr(&mut |expr| {\n-        has_await |= matches!(expr, ast::Expr::AwaitExpr(_));\n-        let name_ref = match expr {\n-            ast::Expr::PathExpr(path_expr) => {\n-                path_expr.path().and_then(|it| it.as_single_name_ref())\n+        let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n+            (Some(e), None, None, None) => {\n+                let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n+                let def = ctx.sema.to_def(&func)?;\n+                let ret_ty = def.ret_type(ctx.db());\n+                let kind = TryKind::of_ty(ret_ty, ctx)?;\n+\n+                Some(FlowKind::Try { kind })\n             }\n-            _ => return,\n-        };\n-        if let Some(name_ref) = name_ref {\n-            if let Some(\n-                NameRefClass::Definition(Definition::Local(local_ref))\n-                | NameRefClass::FieldShorthand { local_ref, field_ref: _ },\n-            ) = NameRefClass::classify(sema, &name_ref)\n-            {\n-                res.insert(local_ref);\n-                if local_ref.is_self(sema.db) {\n-                    match local_ref.source(sema.db).value {\n-                        Either::Right(it) => {\n-                            stdx::always!(\n-                                self_param.replace(it).is_none(),\n-                                \"body references two different self params\"\n-                            );\n-                        }\n-                        Either::Left(_) => {\n-                            stdx::never!(\"Local::is_self returned true, but source is IdentPat\");\n-                        }\n+            (Some(_), Some(r), None, None) => match r.expr() {\n+                Some(expr) => {\n+                    if let Some(kind) = expr_err_kind(&expr, ctx) {\n+                        Some(FlowKind::TryReturn { expr, kind })\n+                    } else {\n+                        cov_mark::hit!(external_control_flow_try_and_return_non_err);\n+                        return None;\n                     }\n                 }\n+                None => return None,\n+            },\n+            (Some(_), _, _, _) => {\n+                cov_mark::hit!(external_control_flow_try_and_bc);\n+                return None;\n             }\n-        }\n-    });\n-    (res, has_await, self_param)\n-}\n-\n-/// find variables that should be extracted as params\n-///\n-/// Computes additional info that affects param type and mutability\n-fn extracted_function_params(\n-    ctx: &AssistContext,\n-    body: &FunctionBody,\n-    locals: impl Iterator<Item = Local>,\n-) -> Vec<Param> {\n-    locals\n-        .filter(|local| !local.is_self(ctx.db()))\n-        .map(|local| (local, local.source(ctx.db())))\n-        .filter(|(_, src)| is_defined_outside_of_body(ctx, body, src))\n-        .filter_map(|(local, src)| {\n-            if src.value.is_left() {\n-                Some(local)\n-            } else {\n-                stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n-                None\n+            (None, Some(r), None, None) => Some(FlowKind::Return(r.expr())),\n+            (None, Some(_), _, _) => {\n+                cov_mark::hit!(external_control_flow_return_and_bc);\n+                return None;\n             }\n-        })\n-        .map(|var| {\n-            let usages = LocalUsages::find(ctx, var);\n-            let ty = var.ty(ctx.db());\n-            let is_copy = ty.is_copy(ctx.db());\n-            Param {\n-                var,\n-                ty,\n-                has_usages_afterwards: has_usages_after_body(&usages, body),\n-                has_mut_inside_body: has_exclusive_usages(ctx, &usages, body),\n-                is_copy,\n+            (None, None, Some(_), Some(_)) => {\n+                cov_mark::hit!(external_control_flow_break_and_continue);\n+                return None;\n             }\n-        })\n-        .collect()\n-}\n+            (None, None, Some(b), None) => Some(FlowKind::Break(b.expr())),\n+            (None, None, None, Some(_)) => Some(FlowKind::Continue),\n+            (None, None, None, None) => None,\n+        };\n+\n+        Some(ControlFlow { kind, is_async })\n+    }\n+    /// find variables that should be extracted as params\n+    ///\n+    /// Computes additional info that affects param type and mutability\n+    fn extracted_function_params(\n+        &self,\n+        ctx: &AssistContext,\n+        locals: impl Iterator<Item = Local>,\n+    ) -> Vec<Param> {\n+        locals\n+            .map(|local| (local, local.source(ctx.db())))\n+            .filter(|(_, src)| is_defined_outside_of_body(ctx, self, src))\n+            .filter_map(|(local, src)| {\n+                if src.value.is_left() {\n+                    Some(local)\n+                } else {\n+                    stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n+                    None\n+                }\n+            })\n+            .map(|var| {\n+                let usages = LocalUsages::find(ctx, var);\n+                let ty = var.ty(ctx.db());\n+                let is_copy = ty.is_copy(ctx.db());\n+                Param {\n+                    var,\n+                    ty,\n+                    has_usages_afterwards: self.has_usages_after_body(&usages),\n+                    has_mut_inside_body: has_exclusive_usages(ctx, &usages, self),\n+                    is_copy,\n+                }\n+            })\n+            .collect()\n+    }\n \n-fn has_usages_after_body(usages: &LocalUsages, body: &FunctionBody) -> bool {\n-    usages.iter().any(|reference| body.precedes_range(reference.range))\n+    fn has_usages_after_body(&self, usages: &LocalUsages) -> bool {\n+        usages.iter().any(|reference| self.precedes_range(reference.range))\n+    }\n }\n \n /// checks if relevant var is used with `&mut` access inside body\n@@ -795,19 +965,6 @@ fn locals_defined_in_body(\n     res\n }\n \n-/// Local variables defined inside `body` that are accessed outside of it\n-fn ret_values<'a>(\n-    ctx: &'a AssistContext,\n-    body: &FunctionBody,\n-    parent: &SyntaxNode,\n-) -> impl Iterator<Item = OutlivedLocal> + 'a {\n-    let parent = parent.clone();\n-    let range = body.text_range();\n-    locals_defined_in_body(&ctx.sema, body)\n-        .into_iter()\n-        .filter_map(move |local| local_outlives_body(ctx, range, local, &parent))\n-}\n-\n /// Returns usage details if local variable is used after(outside of) body\n fn local_outlives_body(\n     ctx: &AssistContext,\n@@ -850,95 +1007,6 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     }\n }\n \n-fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n-    match body.tail_expr() {\n-        Some(expr) => ctx.sema.type_of_expr(&expr).map(TypeInfo::original).map(RetType::Expr),\n-        None => Some(RetType::Stmt),\n-    }\n-}\n-\n-/// Analyses the function body for external control flow.\n-fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n-    let mut ret_expr = None;\n-    let mut try_expr = None;\n-    let mut break_expr = None;\n-    let mut continue_expr = None;\n-\n-    let mut loop_depth = 0;\n-\n-    body.preorder_expr(&mut |expr| {\n-        let expr = match expr {\n-            WalkEvent::Enter(e) => e,\n-            WalkEvent::Leave(\n-                ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n-            ) => {\n-                loop_depth -= 1;\n-                return false;\n-            }\n-            WalkEvent::Leave(_) => return false,\n-        };\n-        match expr {\n-            ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n-                loop_depth += 1;\n-            }\n-            ast::Expr::ReturnExpr(it) => {\n-                ret_expr = Some(it);\n-            }\n-            ast::Expr::TryExpr(it) => {\n-                try_expr = Some(it);\n-            }\n-            ast::Expr::BreakExpr(it) if loop_depth == 0 => {\n-                break_expr = Some(it);\n-            }\n-            ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n-                continue_expr = Some(it);\n-            }\n-            _ => {}\n-        }\n-        false\n-    });\n-\n-    let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n-        (Some(e), None, None, None) => {\n-            let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n-            let def = ctx.sema.to_def(&func)?;\n-            let ret_ty = def.ret_type(ctx.db());\n-            let kind = try_kind_of_ty(ret_ty, ctx)?;\n-\n-            Some(FlowKind::Try { kind })\n-        }\n-        (Some(_), Some(r), None, None) => match r.expr() {\n-            Some(expr) => {\n-                if let Some(kind) = expr_err_kind(&expr, ctx) {\n-                    Some(FlowKind::TryReturn { expr, kind })\n-                } else {\n-                    cov_mark::hit!(external_control_flow_try_and_return_non_err);\n-                    return None;\n-                }\n-            }\n-            None => return None,\n-        },\n-        (Some(_), _, _, _) => {\n-            cov_mark::hit!(external_control_flow_try_and_bc);\n-            return None;\n-        }\n-        (None, Some(r), None, None) => Some(FlowKind::Return(r.expr())),\n-        (None, Some(_), _, _) => {\n-            cov_mark::hit!(external_control_flow_return_and_bc);\n-            return None;\n-        }\n-        (None, None, Some(_), Some(_)) => {\n-            cov_mark::hit!(external_control_flow_break_and_continue);\n-            return None;\n-        }\n-        (None, None, Some(b), None) => Some(FlowKind::Break(b.expr())),\n-        (None, None, None, Some(_)) => Some(FlowKind::Continue),\n-        (None, None, None, None) => None,\n-    };\n-\n-    Some(ControlFlow { kind })\n-}\n-\n /// Checks is expr is `Err(_)` or `None`\n fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n     let func_name = match expr {\n@@ -991,12 +1059,7 @@ fn node_to_insert_after(body: &FunctionBody, anchor: Anchor) -> Option<SyntaxNod\n     last_ancestor\n }\n \n-fn make_call(\n-    ctx: &AssistContext,\n-    fun: &Function,\n-    indent: IndentLevel,\n-    body_contains_await: bool,\n-) -> String {\n+fn make_call(ctx: &AssistContext, fun: &Function, indent: IndentLevel) -> String {\n     let ret_ty = fun.return_type(ctx);\n \n     let args = fun.params.iter().map(|param| param.to_arg(ctx));\n@@ -1013,8 +1076,10 @@ fn make_call(\n \n     let expr = handler.make_call_expr(call_expr).indent(indent);\n \n+    let mut_modifier = |var: &OutlivedLocal| if var.mut_usage_outside_body { \"mut \" } else { \"\" };\n+\n     let mut buf = String::new();\n-    match fun.vars_defined_in_body_and_outlive.as_slice() {\n+    match fun.outliving_locals.as_slice() {\n         [] => {}\n         [var] => {\n             format_to!(buf, \"let {}{} = \", mut_modifier(var), var.local.name(ctx.db()).unwrap())\n@@ -1028,20 +1093,18 @@ fn make_call(\n             buf.push_str(\") = \");\n         }\n     }\n-    fn mut_modifier(var: &OutlivedLocal) -> &'static str {\n-        if var.mut_usage_outside_body {\n-            \"mut \"\n-        } else {\n-            \"\"\n-        }\n-    }\n     format_to!(buf, \"{}\", expr);\n-    if body_contains_await {\n+    if fun.control_flow.is_async {\n         buf.push_str(\".await\");\n     }\n-    if fun.ret_ty.is_unit()\n-        && (!fun.vars_defined_in_body_and_outlive.is_empty() || !expr.is_block_like())\n-    {\n+    let insert_comma = fun\n+        .body\n+        .parent()\n+        .and_then(ast::MatchArm::cast)\n+        .map_or(false, |it| it.comma_token().is_none());\n+    if insert_comma {\n+        buf.push(',');\n+    } else if fun.ret_ty.is_unit() && (!fun.outliving_locals.is_empty() || !expr.is_block_like()) {\n         buf.push(';');\n     }\n     buf\n@@ -1171,16 +1234,32 @@ fn format_function(\n     fun: &Function,\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n-    body_contains_await: bool,\n ) -> String {\n     let mut fn_def = String::new();\n-    let params = make_param_list(ctx, module, fun);\n-    let ret_ty = make_ret_ty(ctx, module, fun);\n+    let params = fun.make_param_list(ctx, module);\n+    let ret_ty = fun.make_ret_ty(ctx, module);\n     let body = make_body(ctx, old_indent, new_indent, fun);\n-    let async_kw = if body_contains_await { \"async \" } else { \"\" };\n+    let const_kw = if fun.mods.is_const { \"const \" } else { \"\" };\n+    let async_kw = if fun.control_flow.is_async { \"async \" } else { \"\" };\n     match ctx.config.snippet_cap {\n-        Some(_) => format_to!(fn_def, \"\\n\\n{}{}fn $0{}{}\", new_indent, async_kw, fun.name, params),\n-        None => format_to!(fn_def, \"\\n\\n{}{}fn {}{}\", new_indent, async_kw, fun.name, params),\n+        Some(_) => format_to!(\n+            fn_def,\n+            \"\\n\\n{}{}{}fn $0{}{}\",\n+            new_indent,\n+            const_kw,\n+            async_kw,\n+            fun.name,\n+            params\n+        ),\n+        None => format_to!(\n+            fn_def,\n+            \"\\n\\n{}{}{}fn {}{}\",\n+            new_indent,\n+            const_kw,\n+            async_kw,\n+            fun.name,\n+            params\n+        ),\n     }\n     if let Some(ret_ty) = ret_ty {\n         format_to!(fn_def, \" {}\", ret_ty);\n@@ -1190,10 +1269,57 @@ fn format_function(\n     fn_def\n }\n \n-fn make_param_list(ctx: &AssistContext, module: hir::Module, fun: &Function) -> ast::ParamList {\n-    let self_param = fun.self_param.clone();\n-    let params = fun.params.iter().map(|param| param.to_param(ctx, module));\n-    make::param_list(self_param, params)\n+impl Function {\n+    fn make_param_list(&self, ctx: &AssistContext, module: hir::Module) -> ast::ParamList {\n+        let self_param = self.self_param.clone();\n+        let params = self.params.iter().map(|param| param.to_param(ctx, module));\n+        make::param_list(self_param, params)\n+    }\n+\n+    fn make_ret_ty(&self, ctx: &AssistContext, module: hir::Module) -> Option<ast::RetType> {\n+        let fun_ty = self.return_type(ctx);\n+        let handler = if self.mods.is_in_tail {\n+            FlowHandler::None\n+        } else {\n+            FlowHandler::from_ret_ty(self, &fun_ty)\n+        };\n+        let ret_ty = match &handler {\n+            FlowHandler::None => {\n+                if matches!(fun_ty, FunType::Unit) {\n+                    return None;\n+                }\n+                fun_ty.make_ty(ctx, module)\n+            }\n+            FlowHandler::Try { kind: TryKind::Option } => {\n+                make::ext::ty_option(fun_ty.make_ty(ctx, module))\n+            }\n+            FlowHandler::Try { kind: TryKind::Result { ty: parent_ret_ty } } => {\n+                let handler_ty = parent_ret_ty\n+                    .type_arguments()\n+                    .nth(1)\n+                    .map(|ty| make_ty(&ty, ctx, module))\n+                    .unwrap_or_else(make::ty_unit);\n+                make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n+            }\n+            FlowHandler::If { .. } => make::ext::ty_bool(),\n+            FlowHandler::IfOption { action } => {\n+                let handler_ty = action\n+                    .expr_ty(ctx)\n+                    .map(|ty| make_ty(&ty, ctx, module))\n+                    .unwrap_or_else(make::ty_unit);\n+                make::ext::ty_option(handler_ty)\n+            }\n+            FlowHandler::MatchOption { .. } => make::ext::ty_option(fun_ty.make_ty(ctx, module)),\n+            FlowHandler::MatchResult { err } => {\n+                let handler_ty = err\n+                    .expr_ty(ctx)\n+                    .map(|ty| make_ty(&ty, ctx, module))\n+                    .unwrap_or_else(make::ty_unit);\n+                make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n+            }\n+        };\n+        Some(make::ret_type(ret_ty))\n+    }\n }\n \n impl FunType {\n@@ -1219,53 +1345,18 @@ impl FunType {\n     }\n }\n \n-fn make_ret_ty(ctx: &AssistContext, module: hir::Module, fun: &Function) -> Option<ast::RetType> {\n-    let fun_ty = fun.return_type(ctx);\n-    let handler = FlowHandler::from_ret_ty(fun, &fun_ty);\n-    let ret_ty = match &handler {\n-        FlowHandler::None => {\n-            if matches!(fun_ty, FunType::Unit) {\n-                return None;\n-            }\n-            fun_ty.make_ty(ctx, module)\n-        }\n-        FlowHandler::Try { kind: TryKind::Option } => {\n-            make::ext::ty_option(fun_ty.make_ty(ctx, module))\n-        }\n-        FlowHandler::Try { kind: TryKind::Result { ty: parent_ret_ty } } => {\n-            let handler_ty = parent_ret_ty\n-                .type_arguments()\n-                .nth(1)\n-                .map(|ty| make_ty(&ty, ctx, module))\n-                .unwrap_or_else(make::ty_unit);\n-            make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n-        }\n-        FlowHandler::If { .. } => make::ext::ty_bool(),\n-        FlowHandler::IfOption { action } => {\n-            let handler_ty = action\n-                .expr_ty(ctx)\n-                .map(|ty| make_ty(&ty, ctx, module))\n-                .unwrap_or_else(make::ty_unit);\n-            make::ext::ty_option(handler_ty)\n-        }\n-        FlowHandler::MatchOption { .. } => make::ext::ty_option(fun_ty.make_ty(ctx, module)),\n-        FlowHandler::MatchResult { err } => {\n-            let handler_ty =\n-                err.expr_ty(ctx).map(|ty| make_ty(&ty, ctx, module)).unwrap_or_else(make::ty_unit);\n-            make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n-        }\n-    };\n-    Some(make::ret_type(ret_ty))\n-}\n-\n fn make_body(\n     ctx: &AssistContext,\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n     fun: &Function,\n ) -> ast::BlockExpr {\n     let ret_ty = fun.return_type(ctx);\n-    let handler = FlowHandler::from_ret_ty(fun, &ret_ty);\n+    let handler = if fun.mods.is_in_tail {\n+        FlowHandler::None\n+    } else {\n+        FlowHandler::from_ret_ty(fun, &ret_ty)\n+    };\n     let block = match &fun.body {\n         FunctionBody::Expr(expr) => {\n             let expr = rewrite_body_segment(ctx, &fun.params, &handler, expr.syntax());\n@@ -1301,7 +1392,7 @@ fn make_body(\n             };\n \n             if tail_expr.is_none() {\n-                match fun.vars_defined_in_body_and_outlive.as_slice() {\n+                match fun.outliving_locals.as_slice() {\n                     [] => {}\n                     [var] => {\n                         tail_expr = Some(path_expr_from_local(ctx, var.local));\n@@ -3230,8 +3321,7 @@ fn $0fun_name(n: i32) -> bool {\n             r#\"\n fn foo() {\n     loop {\n-        let n = 1;\n-        $0\n+        let n = 1;$0\n         let k = 1;\n         loop {\n             return;\n@@ -3435,8 +3525,7 @@ fn $0fun_name() -> Option<i32> {\n             r#\"\n fn foo() -> i64 {\n     loop {\n-        let n = 1;\n-        $0\n+        let n = 1;$0\n         let k = 1;\n         if k == 42 {\n             break 3;\n@@ -3830,6 +3919,95 @@ fn main() {\n fn $0fun_name() -> i32 {\n     100\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_does_not_tear_comments_apart() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn foo() {\n+    /*$0*/\n+    foo();\n+    foo();\n+    /*$0*/\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    /**/\n+    fun_name();\n+    /**/\n+}\n+\n+fn $0fun_name() {\n+    foo();\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_does_not_wrap_res_in_res() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<(), i64> {\n+    $0Result::<i32, i64>::Ok(0)?;\n+    Ok(())$0\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<(), i64> {\n+    fun_name()?\n+}\n+\n+fn $0fun_name() -> Result<(), i64> {\n+    Result::<i32, i64>::Ok(0)?;\n+    Ok(())\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_knows_const() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+const fn foo() {\n+    $0()$0\n+}\n+\"#,\n+            r#\"\n+const fn foo() {\n+    fun_name();\n+}\n+\n+const fn $0fun_name() {\n+    ()\n+}\n+\"#,\n+        );\n+        check_assist(\n+            extract_function,\n+            r#\"\n+const FOO: () = {\n+    $0()$0\n+};\n+\"#,\n+            r#\"\n+const FOO: () = {\n+    fun_name();\n+};\n+\n+const fn $0fun_name() {\n+    ()\n+}\n \"#,\n         );\n     }"}]}