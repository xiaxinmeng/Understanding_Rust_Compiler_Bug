{"sha": "c3a6d2860cc0448dea8a9918d22b30839d2548c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYTZkMjg2MGNjMDQ0OGRlYThhOTkxOGQyMmIzMDgzOWQyNTQ4Yzg=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-01T17:23:56Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T01:15:38Z"}, "message": "Tell typeck which binops are by value", "tree": {"sha": "9f35bfa1b527c76f2641529b64aacc1d195a970d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f35bfa1b527c76f2641529b64aacc1d195a970d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3a6d2860cc0448dea8a9918d22b30839d2548c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a6d2860cc0448dea8a9918d22b30839d2548c8", "html_url": "https://github.com/rust-lang/rust/commit/c3a6d2860cc0448dea8a9918d22b30839d2548c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3a6d2860cc0448dea8a9918d22b30839d2548c8/comments", "author": null, "committer": null, "parents": [{"sha": "14c0a708cc33245d86d48b99d7dc93a6f5b9d20d", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c0a708cc33245d86d48b99d7dc93a6f5b9d20d", "html_url": "https://github.com/rust-lang/rust/commit/14c0a708cc33245d86d48b99d7dc93a6f5b9d20d"}], "stats": {"total": 48, "additions": 25, "deletions": 23}, "files": [{"sha": "2dcb07e0fb502c635f62e84b654e07bf37941819", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c3a6d2860cc0448dea8a9918d22b30839d2548c8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3a6d2860cc0448dea8a9918d22b30839d2548c8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c3a6d2860cc0448dea8a9918d22b30839d2548c8", "patch": "@@ -2904,6 +2904,7 @@ pub fn lookup_tup_field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n // Controls whether the arguments are automatically referenced. This is useful\n // for overloaded binary and unary operators.\n+#[deriving(PartialEq)]\n pub enum DerefArgs {\n     DontDerefArgs,\n     DoDerefArgs\n@@ -3130,7 +3131,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                      trait_did: Option<ast::DefId>,\n                                      lhs: &'a ast::Expr,\n                                      rhs: Option<&P<ast::Expr>>,\n-                                     unbound_method: F) -> Ty<'tcx> where\n+                                     unbound_method: F,\n+                                     deref_args: DerefArgs) -> Ty<'tcx> where\n         F: FnOnce(),\n     {\n         let method = match trait_did {\n@@ -3146,7 +3148,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 //   traits that don't force left and right to have same\n                 //   type.\n                 let (adj_ty, adjustment) = match lhs_ty.sty {\n-                    ty::ty_rptr(r_in, mt) => {\n+                    ty::ty_rptr(r_in, mt) if deref_args == DoDerefArgs => {\n                         let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n                         fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, r_in);\n                         let adjusted_ty = ty::mk_rptr(fcx.tcx(), r_adj, mt);\n@@ -3183,7 +3185,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             method_ty,\n                                             op_ex,\n                                             args.as_slice(),\n-                                            DoDerefArgs,\n+                                            deref_args,\n                                             DontTupleArguments) {\n                     ty::FnConverging(result_type) => result_type,\n                     ty::FnDiverging => ty::mk_err()\n@@ -3199,7 +3201,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             expected_ty,\n                                             op_ex,\n                                             args.as_slice(),\n-                                            DoDerefArgs,\n+                                            deref_args,\n                                             DontTupleArguments);\n                 ty::mk_err()\n             }\n@@ -3318,23 +3320,23 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                   rhs: &P<ast::Expr>) -> Ty<'tcx> {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n-        let (name, trait_did) = match op {\n-            ast::BiAdd => (\"add\", lang.add_trait()),\n-            ast::BiSub => (\"sub\", lang.sub_trait()),\n-            ast::BiMul => (\"mul\", lang.mul_trait()),\n-            ast::BiDiv => (\"div\", lang.div_trait()),\n-            ast::BiRem => (\"rem\", lang.rem_trait()),\n-            ast::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n-            ast::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n-            ast::BiBitOr => (\"bitor\", lang.bitor_trait()),\n-            ast::BiShl => (\"shl\", lang.shl_trait()),\n-            ast::BiShr => (\"shr\", lang.shr_trait()),\n-            ast::BiLt => (\"lt\", lang.ord_trait()),\n-            ast::BiLe => (\"le\", lang.ord_trait()),\n-            ast::BiGe => (\"ge\", lang.ord_trait()),\n-            ast::BiGt => (\"gt\", lang.ord_trait()),\n-            ast::BiEq => (\"eq\", lang.eq_trait()),\n-            ast::BiNe => (\"ne\", lang.eq_trait()),\n+        let (name, trait_did, deref_args) = match op {\n+            ast::BiAdd => (\"add\", lang.add_trait(), DontDerefArgs),\n+            ast::BiSub => (\"sub\", lang.sub_trait(), DontDerefArgs),\n+            ast::BiMul => (\"mul\", lang.mul_trait(), DontDerefArgs),\n+            ast::BiDiv => (\"div\", lang.div_trait(), DontDerefArgs),\n+            ast::BiRem => (\"rem\", lang.rem_trait(), DontDerefArgs),\n+            ast::BiBitXor => (\"bitxor\", lang.bitxor_trait(), DontDerefArgs),\n+            ast::BiBitAnd => (\"bitand\", lang.bitand_trait(), DontDerefArgs),\n+            ast::BiBitOr => (\"bitor\", lang.bitor_trait(), DontDerefArgs),\n+            ast::BiShl => (\"shl\", lang.shl_trait(), DontDerefArgs),\n+            ast::BiShr => (\"shr\", lang.shr_trait(), DontDerefArgs),\n+            ast::BiLt => (\"lt\", lang.ord_trait(), DoDerefArgs),\n+            ast::BiLe => (\"le\", lang.ord_trait(), DoDerefArgs),\n+            ast::BiGe => (\"ge\", lang.ord_trait(), DoDerefArgs),\n+            ast::BiGt => (\"gt\", lang.ord_trait(), DoDerefArgs),\n+            ast::BiEq => (\"eq\", lang.eq_trait(), DoDerefArgs),\n+            ast::BiNe => (\"ne\", lang.eq_trait(), DoDerefArgs),\n             ast::BiAnd | ast::BiOr => {\n                 check_expr(fcx, &**rhs);\n                 return ty::mk_err();\n@@ -3347,7 +3349,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         ast_util::binop_to_string(op),\n                         actual)\n             }, lhs_resolved_t, None)\n-        })\n+        }, deref_args)\n     }\n \n     fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -3363,7 +3365,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 format!(\"cannot apply unary operator `{}` to type `{}`\",\n                         op_str, actual)\n             }, rhs_t, None);\n-        })\n+        }, DontDerefArgs)\n     }\n \n     // Check field access expressions"}]}