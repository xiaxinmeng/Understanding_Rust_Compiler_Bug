{"sha": "9928baa786f645a22072fd2fb4b68173eced61f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MjhiYWE3ODZmNjQ1YTIyMDcyZmQyZmI0YjY4MTczZWNlZDYxZjk=", "commit": {"author": {"name": "F001", "email": "changchun.fan@qq.com", "date": "2018-05-07T07:24:45Z"}, "committer": {"name": "F001", "email": "changchun.fan@qq.com", "date": "2018-07-17T03:34:19Z"}, "message": "implement rfc 1789", "tree": {"sha": "7c64b98bc9012b37248b23f2f8ffd83df61ad1ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c64b98bc9012b37248b23f2f8ffd83df61ad1ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9928baa786f645a22072fd2fb4b68173eced61f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9928baa786f645a22072fd2fb4b68173eced61f9", "html_url": "https://github.com/rust-lang/rust/commit/9928baa786f645a22072fd2fb4b68173eced61f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9928baa786f645a22072fd2fb4b68173eced61f9/comments", "author": {"login": "F001", "id": 3314340, "node_id": "MDQ6VXNlcjMzMTQzNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/3314340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/F001", "html_url": "https://github.com/F001", "followers_url": "https://api.github.com/users/F001/followers", "following_url": "https://api.github.com/users/F001/following{/other_user}", "gists_url": "https://api.github.com/users/F001/gists{/gist_id}", "starred_url": "https://api.github.com/users/F001/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/F001/subscriptions", "organizations_url": "https://api.github.com/users/F001/orgs", "repos_url": "https://api.github.com/users/F001/repos", "events_url": "https://api.github.com/users/F001/events{/privacy}", "received_events_url": "https://api.github.com/users/F001/received_events", "type": "User", "site_admin": false}, "committer": {"login": "F001", "id": 3314340, "node_id": "MDQ6VXNlcjMzMTQzNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/3314340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/F001", "html_url": "https://github.com/F001", "followers_url": "https://api.github.com/users/F001/followers", "following_url": "https://api.github.com/users/F001/following{/other_user}", "gists_url": "https://api.github.com/users/F001/gists{/gist_id}", "starred_url": "https://api.github.com/users/F001/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/F001/subscriptions", "organizations_url": "https://api.github.com/users/F001/orgs", "repos_url": "https://api.github.com/users/F001/repos", "events_url": "https://api.github.com/users/F001/events{/privacy}", "received_events_url": "https://api.github.com/users/F001/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55c04babb88beb20331b80ad9e4a51f860fb2392", "url": "https://api.github.com/repos/rust-lang/rust/commits/55c04babb88beb20331b80ad9e4a51f860fb2392", "html_url": "https://github.com/rust-lang/rust/commit/55c04babb88beb20331b80ad9e4a51f860fb2392"}], "stats": {"total": 169, "additions": 125, "deletions": 44}, "files": [{"sha": "3536588f9dfaab30f95562088c0a37aecbc1a320", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 103, "deletions": 44, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/9928baa786f645a22072fd2fb4b68173eced61f9/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9928baa786f645a22072fd2fb4b68173eced61f9/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=9928baa786f645a22072fd2fb4b68173eced61f9", "patch": "@@ -200,8 +200,9 @@ use cmp::Ordering;\n use fmt::{self, Debug, Display};\n use marker::Unsize;\n use mem;\n-use ops::{Deref, DerefMut, CoerceUnsized};\n+use ops::{Deref, DerefMut, CoerceUnsized, Index};\n use ptr;\n+use slice::SliceIndex;\n \n /// A mutable memory location.\n ///\n@@ -236,7 +237,7 @@ use ptr;\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(transparent)]\n-pub struct Cell<T> {\n+pub struct Cell<T: ?Sized> {\n     value: UnsafeCell<T>,\n }\n \n@@ -287,10 +288,10 @@ impl<T:Copy> Cell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T> Send for Cell<T> where T: Send {}\n+unsafe impl<T: ?Sized> Send for Cell<T> where T: Send {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> !Sync for Cell<T> {}\n+impl<T: ?Sized> !Sync for Cell<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Copy> Clone for Cell<T> {\n@@ -381,46 +382,6 @@ impl<T> Cell<T> {\n         }\n     }\n \n-    /// Returns a raw pointer to the underlying data in this cell.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    ///\n-    /// let ptr = c.as_ptr();\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"cell_as_ptr\", since = \"1.12.0\")]\n-    pub fn as_ptr(&self) -> *mut T {\n-        self.value.get()\n-    }\n-\n-    /// Returns a mutable reference to the underlying data.\n-    ///\n-    /// This call borrows `Cell` mutably (at compile-time) which guarantees\n-    /// that we possess the only reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let mut c = Cell::new(5);\n-    /// *c.get_mut() += 1;\n-    ///\n-    /// assert_eq!(c.get(), 6);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n-    pub fn get_mut(&mut self) -> &mut T {\n-        unsafe {\n-            &mut *self.value.get()\n-        }\n-    }\n-\n     /// Sets the contained value.\n     ///\n     /// # Examples\n@@ -499,6 +460,90 @@ impl<T> Cell<T> {\n     }\n }\n \n+impl<T: ?Sized> Cell<T> {\n+    /// Returns a raw pointer to the underlying data in this cell.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// let ptr = c.as_ptr();\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"cell_as_ptr\", since = \"1.12.0\")]\n+    pub fn as_ptr(&self) -> *mut T {\n+        self.value.get()\n+    }\n+\n+    /// Returns a mutable reference to the underlying data.\n+    ///\n+    /// This call borrows `Cell` mutably (at compile-time) which guarantees\n+    /// that we possess the only reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let mut c = Cell::new(5);\n+    /// *c.get_mut() += 1;\n+    ///\n+    /// assert_eq!(c.get(), 6);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        unsafe {\n+            &mut *self.value.get()\n+        }\n+    }\n+\n+    /// Returns a `&Cell<T>` from a `&mut T`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(as_cell)]\n+    /// use std::cell::Cell;\n+    /// let slice: &mut [i32] = &mut [1,2,3];\n+    /// let cell_slice: &Cell<[i32]> = Cell::from_mut(slice);\n+    ///\n+    /// assert_eq!(cell_slice.get_with(|v|v.len()), 3)\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"as_cell\", issue=\"43038\")]\n+    pub fn from_mut<'a>(t: &'a mut T) -> &'a Cell<T> {\n+        unsafe {\n+            &*(t as *mut T as *const Cell<T>)\n+        }\n+    }\n+\n+    /// Returns a value by applying a function on contained value\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(as_cell)]\n+    /// use std::cell::Cell;\n+    /// let c : Cell<Vec<i32>> = Cell::new(vec![1,2,3]);\n+    /// let sum : i32 = c.get_with(|v|v.iter().sum());\n+    /// assert_eq!(sum, 6_i32);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"as_cell\", issue=\"43038\")]\n+    pub fn get_with<U, F>(&self, f: F) -> U\n+    where\n+        F: Fn(&T) -> U, U: 'static\n+    {\n+        unsafe {\n+            f(&*self.value.get())\n+        }\n+    }\n+}\n+\n impl<T: Default> Cell<T> {\n     /// Takes the value of the cell, leaving `Default::default()` in its place.\n     ///\n@@ -522,6 +567,20 @@ impl<T: Default> Cell<T> {\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<Cell<U>> for Cell<T> {}\n \n+#[unstable(feature = \"as_cell\", issue=\"43038\")]\n+impl<T, I> Index<I> for Cell<[T]>\n+where\n+    I: SliceIndex<[Cell<T>]>\n+{\n+    type Output = I::Output;\n+\n+    fn index(&self, index: I) -> &Self::Output {\n+        unsafe {\n+            Index::index(&*(self as *const Cell<[T]> as *const [Cell<T>]), index)\n+        }\n+    }\n+}\n+\n /// A mutable memory location with dynamically checked borrow rules\n ///\n /// See the [module-level documentation](index.html) for more."}, {"sha": "33257124f57aeb9fd6c8d028b8c88643a2a7dd8b", "filename": "src/test/run-pass/rfc-1789-as-cell/from-mut.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9928baa786f645a22072fd2fb4b68173eced61f9/src%2Ftest%2Frun-pass%2Frfc-1789-as-cell%2Ffrom-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9928baa786f645a22072fd2fb4b68173eced61f9/src%2Ftest%2Frun-pass%2Frfc-1789-as-cell%2Ffrom-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1789-as-cell%2Ffrom-mut.rs?ref=9928baa786f645a22072fd2fb4b68173eced61f9", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(as_cell)]\n+\n+use std::cell::Cell;\n+\n+fn main() {\n+    let slice: &mut [i32] = &mut [1,2,3];\n+    let cell_slice: &Cell<[i32]> = Cell::from_mut(slice);\n+    assert_eq!(cell_slice.get_with(|v|v.len()), 3);\n+\n+    let sub_slice : &[Cell<i32>] = &cell_slice[1..];\n+    assert_eq!(sub_slice.len(), 2);\n+}"}]}