{"sha": "4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNjM4MjYwNTBkZmM1NzliOWFjNjVhNmI3MmFkMGNhNmY2YjUxZmM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-15T14:42:35Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-15T14:47:42Z"}, "message": "Replace some explicit fails with 'alt check' invocations", "tree": {"sha": "1f67b0fcf68193e107bb5d7135bd191786eea47f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f67b0fcf68193e107bb5d7135bd191786eea47f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "html_url": "https://github.com/rust-lang/rust/commit/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b6eb6712861bd2437b92a5974a4fb3f498e31e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b6eb6712861bd2437b92a5974a4fb3f498e31e8", "html_url": "https://github.com/rust-lang/rust/commit/5b6eb6712861bd2437b92a5974a4fb3f498e31e8"}], "stats": {"total": 167, "additions": 52, "deletions": 115}, "files": [{"sha": "bc1b04c9e8408fdaef1b69e4f40b4feccde49f52", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -203,12 +203,11 @@ mod write {\n             let LLVMOptAggressive = 3 as c_int; // -O3\n \n             let CodeGenOptLevel;\n-            alt opts.optimize {\n+            alt check opts.optimize {\n               0u { CodeGenOptLevel = LLVMOptNone; }\n               1u { CodeGenOptLevel = LLVMOptLess; }\n               2u { CodeGenOptLevel = LLVMOptDefault; }\n               3u { CodeGenOptLevel = LLVMOptAggressive; }\n-              _ { fail; }\n             }\n \n             let FileType;"}, {"sha": "ab760815227a49df67d2f7a3f99c9c293cd36dea", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -39,9 +39,8 @@ fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n fn lookup_method_purity(cstore: cstore::cstore, did: ast::def_id)\n     -> ast::purity {\n     let cdata = cstore::get_crate_data(cstore, did.crate).data;\n-    alt decoder::lookup_def(did.crate, cdata, did) {\n+    alt check decoder::lookup_def(did.crate, cdata, did) {\n       ast::def_fn(_, p) { p }\n-      _ { fail; }\n     }\n }\n "}, {"sha": "d23fa4f5e8ce800901e72141d9f2afff57c91c49", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -284,7 +284,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n       option::none {}\n     }\n \n-    let (name, (size, align), encoding) = alt ty {\n+    let (name, (size, align), encoding) = alt check ty {\n       ast::ty_bool {(\"bool\", size_and_align_of::<bool>(), DW_ATE_boolean)}\n       ast::ty_int(m) { alt m {\n         ast::ty_char {(\"char\", size_and_align_of::<char>(), DW_ATE_unsigned)}\n@@ -306,7 +306,6 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n         ast::ty_f32 {(\"f32\", size_and_align_of::<f32>(), DW_ATE_float)}\n         ast::ty_f64 {(\"f64\", size_and_align_of::<f64>(), DW_ATE_float)}\n       }}\n-      _ { fail; }\n     };\n \n     let fname = filename_from_span(cx, span);\n@@ -511,9 +510,9 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n fn member_size_and_align(tcx: ty::ctxt, ty: @ast::ty) -> (int, int) {\n     alt ty.node {\n       ast::ty_path(_, id) {\n-        alt tcx.def_map.get(id) {\n+        alt check tcx.def_map.get(id) {\n           ast::def_prim_ty(nty) {\n-            alt nty {\n+            alt check nty {\n               ast::ty_bool { size_and_align_of::<bool>() }\n               ast::ty_int(m) { alt m {\n                 ast::ty_char { size_and_align_of::<char>() }\n@@ -535,10 +534,8 @@ fn member_size_and_align(tcx: ty::ctxt, ty: @ast::ty) -> (int, int) {\n                 ast::ty_f32 { size_and_align_of::<f32>() }\n                 ast::ty_f64 { size_and_align_of::<f64>() }\n               }}\n-              _ { fail; }\n             }\n           }\n-          _ { fail; }\n         }\n       }\n       ast::ty_box(_) | ast::ty_uniq(_) {"}, {"sha": "1f68bb4a25e6b3fcea19b38b64749b7c9b36bae4", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -1965,12 +1965,8 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n           todo(node_id, name, path, span, scopes) {\n             resolve_import(e, local_def(node_id), name, *path, span,\n                            scopes);\n-            alt e.imports.get(id) {\n+            alt check e.imports.get(id) {\n               resolved(_, _, _, is, _, _) { act(is); }\n-              _ {\n-                  e.sess.bug(\"Undocumented invariant in \\\n-                    lookup_imported_impls\");\n-              }\n             }\n           }\n           _ {}\n@@ -2003,16 +1999,14 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n         }\n       }\n       ast::view_item_import_glob(ids, id) {\n-          alt e.imports.get(id) {\n-            is_glob(path, sc, sp) {\n-              alt follow_import(e, sc, *path, sp) {\n-                some(def) { find_impls_in_mod(e, def, impls, none); }\n-                _ {}\n-              }\n+        alt check e.imports.get(id) {\n+          is_glob(path, sc, sp) {\n+            alt follow_import(e, sc, *path, sp) {\n+              some(def) { find_impls_in_mod(e, def, impls, none); }\n+              _ {}\n             }\n-            _ { e.sess.span_bug(vi.span, \"Undocumented invariant in \\\n-                  find_impls_in_view_item\"); }\n           }\n+        }\n       }\n       _ {}\n     }"}, {"sha": "799eadcf69a63e110e322fce6504e445d92eb980", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -2264,7 +2264,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     ccx.monomorphized.insert(hash_id, {llfn: lldecl, fty: mono_ty});\n \n     let psubsts = some({tys: substs, dicts: dicts, bounds: tpt.bounds});\n-    alt map_node {\n+    alt check map_node {\n       ast_map::node_item(@{node: ast::item_fn(decl, _, body), _}, _) {\n         trans_fn(ccx, pt, decl, body, lldecl, no_self, [],\n                  psubsts, fn_id.node);\n@@ -2285,7 +2285,6 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n                  impl_self(selfty), [], psubsts, fn_id.node);\n       }\n-      _ { fail; }\n     }\n     some({llfn: lldecl, fty: mono_ty})\n }\n@@ -2622,15 +2621,14 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n         add_clean_temp(bcx, space.val, ty);\n         {bcx: bcx, val: space.val, kind: temporary}\n     } else {\n-        alt c.env {\n+        alt check c.env {\n           is_closure { {bcx: c.bcx, val: c.val, kind: c.kind} }\n           null_env {\n             let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n             let llfn = create_real_fn_pair(c.bcx, llfnty, c.val,\n                                            null_env_ptr(c.bcx));\n             {bcx: c.bcx, val: llfn, kind: temporary}\n           }\n-          _ { fail; }\n         }\n     }\n }\n@@ -4462,9 +4460,8 @@ fn trans_const(cx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n }\n \n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n-    let path = alt ccx.tcx.items.get(item.id) {\n+    let path = alt check ccx.tcx.items.get(item.id) {\n       ast_map::node_item(_, p) { p }\n-      _ { fail; }\n     };\n     alt item.node {\n       ast::item_fn(decl, tps, body) {\n@@ -4717,8 +4714,8 @@ fn collect_native_item(ccx: @crate_ctxt,\n             // For true external functions: create a rust wrapper\n             // and link to that.  The rust wrapper will handle\n             // switching to the C stack.\n-            let path = *alt ccx.tcx.items.get(i.id) {\n-              ast_map::node_native_item(_, p) { p } _ { fail; }\n+            let path = *alt check ccx.tcx.items.get(i.id) {\n+              ast_map::node_native_item(_, p) { p }\n             } + [path_name(i.ident)];\n             register_fn(ccx, i.span, path, \"native fn\", tps, i.id);\n           }\n@@ -4729,8 +4726,8 @@ fn collect_native_item(ccx: @crate_ctxt,\n }\n \n fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n-    *alt ccx.tcx.items.get(i.id) {\n-      ast_map::node_item(_, p) { p } _ { fail; }\n+    *alt check ccx.tcx.items.get(i.id) {\n+      ast_map::node_item(_, p) { p }\n     } + [path_name(i.ident)]\n }\n "}, {"sha": "f7832eeefaa8b3e7351d66119b0a416a403b908c", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -154,11 +154,10 @@ fn trans_monomorphized_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                                    n_method, n_param, n_bound);\n         }\n         let mname = ty::iface_methods(tcx, iface_id)[n_method].ident;\n-        let mth = alt tcx.items.get(impl_did.node) {\n+        let mth = alt check tcx.items.get(impl_did.node) {\n           ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) {\n             option::get(vec::find(ms, {|m| m.ident == mname}))\n           }\n-          _ { fail; }\n         };\n         ret trans_static_callee(bcx, callee_id, base,\n                                 ast_util::local_def(mth.id),"}, {"sha": "4094b6eddbdc823ae7934278cb1b0c600a3f28a2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 19, "deletions": 47, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -337,7 +337,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             ty::mk_param(tcx, n, id)\n           }\n           ast::def_self(iface_id) {\n-            alt tcx.items.get(iface_id.node) {\n+            alt check tcx.items.get(iface_id.node) {\n               ast_map::node_item(@{node: ast::item_iface(tps, _), _}, _) {\n                 if vec::len(tps) != vec::len(path.node.types) {\n                     tcx.sess.span_err(ast_ty.span, \"incorrect number of type \\\n@@ -347,7 +347,6 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                     ast_ty_to_ty(tcx, mode, ast_ty)\n                 }))\n               }\n-              _ { fail; }\n             }\n           }\n           _ {\n@@ -780,13 +779,12 @@ mod collect {\n         }\n     }\n     fn ensure_iface_methods(tcx: ty::ctxt, id: ast::node_id) {\n-        alt tcx.items.get(id) {\n+        alt check tcx.items.get(id) {\n           ast_map::node_item(@{node: ast::item_iface(_, ms), _}, _) {\n             ty::store_iface_methods(tcx, id, @vec::map(ms, {|m|\n                 ty_of_ty_method(tcx, m_collect, m)\n             }));\n           }\n-          _ { fail; }\n         }\n     }\n     fn convert_class_item(_cx: @ctxt, _parent_ty: ty::t,\n@@ -1564,9 +1562,8 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n         alt ccx.method_map.find(callee.id) {\n           some(method_static(did)) {\n             if did.crate == ast::local_crate {\n-                alt ccx.tcx.items.get(did.node) {\n+                alt check ccx.tcx.items.get(did.node) {\n                   ast_map::node_method(m, _, _) { m.decl.purity }\n-                  _ { fail; }\n                 }\n             } else {\n                 csearch::lookup_method_purity(ccx.tcx.sess.cstore, did)\n@@ -1608,14 +1605,11 @@ fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n \n fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n     if did.crate == ast::local_crate {\n-        alt tcx.items.get(did.node) {\n+        alt check tcx.items.get(did.node) {\n           ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                _}, _) {\n             {n_tps: vec::len(ts), ty: ast_ty_to_ty(tcx, m_check, st)}\n           }\n-          an_item {\n-              tcx.sess.bug(\"Undocumented invariant in impl_self_ty\");\n-          }\n         }\n     } else {\n         let tpt = csearch::get_type(tcx, did);\n@@ -1678,9 +1672,8 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n         for bound in *tcx.ty_param_bounds.get(did.node) {\n             alt bound {\n               ty::bound_iface(t) {\n-                let (iid, tps) = alt ty::get(t).struct {\n+                let (iid, tps) = alt check ty::get(t).struct {\n                   ty::ty_iface(i, tps) { (i, tps) }\n-                  _ { fail; }\n                 };\n                 let ifce_methods = ty::iface_methods(tcx, iid);\n                 alt vec::position(*ifce_methods, {|m| m.ident == name}) {\n@@ -1727,21 +1720,17 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n \n     fn ty_from_did(tcx: ty::ctxt, did: ast::def_id) -> ty::t {\n         if did.crate == ast::local_crate {\n-            alt tcx.items.get(did.node) {\n+            alt check tcx.items.get(did.node) {\n               ast_map::node_method(m, _, _) {\n                 let mt = ty_of_method(tcx, m_check, m);\n                 ty::mk_fn(tcx, {proto: ast::proto_box with mt.fty})\n               }\n-              _ {\n-                  tcx.sess.bug(\"Undocumented invariant in ty_from_did\");\n-              }\n             }\n         } else {\n-            alt ty::get(csearch::get_type(tcx, did).ty).struct {\n+            alt check ty::get(csearch::get_type(tcx, did).ty).struct {\n               ty::ty_fn(fty) {\n                 ty::mk_fn(tcx, {proto: ast::proto_box with fty})\n               }\n-              _ { fail; }\n             }\n         }\n     }\n@@ -2550,22 +2539,16 @@ fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let bot = false;\n \n-    alt fcx.locals.find(local.node.id) {\n-      some(i) {\n-        let t = ty::mk_var(fcx.ccx.tcx, i);\n-        write_ty(fcx.ccx.tcx, local.node.id, t);\n-        alt local.node.init {\n-          some(init) {\n-            bot = check_decl_initializer(fcx, local.node.id, init);\n-          }\n-          _ {/* fall through */ }\n-        }\n-        let id_map = pat_util::pat_id_map(fcx.ccx.tcx, local.node.pat);\n-        check_pat(fcx, id_map, local.node.pat, t);\n+    let t = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(local.node.id));\n+    write_ty(fcx.ccx.tcx, local.node.id, t);\n+    alt local.node.init {\n+      some(init) {\n+        bot = check_decl_initializer(fcx, local.node.id, init);\n       }\n-      _ { fcx.ccx.tcx.sess.span_bug(local.span, \"Undocumented invariant \\\n-            in check_decl_local\");  }\n+      _ {/* fall through */ }\n     }\n+    let id_map = pat_util::pat_id_map(fcx.ccx.tcx, local.node.pat);\n+    check_pat(fcx, id_map, local.node.pat, t);\n     ret bot;\n }\n \n@@ -2985,10 +2968,8 @@ mod dict {\n     fn lookup_dict(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                    ty: ty::t, iface_ty: ty::t) -> dict_origin {\n         let tcx = fcx.ccx.tcx;\n-        let (iface_id, iface_tps) = alt ty::get(iface_ty).struct {\n+        let (iface_id, iface_tps) = alt check ty::get(iface_ty).struct {\n             ty::ty_iface(did, tps) { (did, tps) }\n-            _ { tcx.sess.span_bug(sp, \"Undocumented invariant in lookup\\\n-                 _dict\"); }\n         };\n         let ty = fixup_ty(fcx, sp, ty);\n         alt ty::get(ty).struct {\n@@ -2997,12 +2978,10 @@ mod dict {\n             for bound in *tcx.ty_param_bounds.get(did.node) {\n                 alt bound {\n                   ty::bound_iface(ity) {\n-                    alt ty::get(ity).struct {\n+                    alt check ty::get(ity).struct {\n                       ty::ty_iface(idid, _) {\n                         if iface_id == idid { ret dict_param(n, n_bound); }\n                       }\n-                      _ { tcx.sess.span_bug(sp, \"Undocumented invariant in \\\n-                           lookup_dict\"); }\n                     }\n                     n_bound += 1u;\n                   }\n@@ -3020,11 +2999,8 @@ mod dict {\n                 for im in *impls {\n                     let match = alt ty::impl_iface(tcx, im.did) {\n                       some(ity) {\n-                        alt ty::get(ity).struct {\n+                        alt check ty::get(ity).struct {\n                           ty::ty_iface(id, _) { id == iface_id }\n-                          // Bleah, abstract this\n-                          _ { tcx.sess.span_bug(sp, \"Undocumented invariant \\\n-                               in lookup_dict\"); }\n                         }\n                       }\n                       _ { false }\n@@ -3086,15 +3062,11 @@ mod dict {\n         let tcx = fcx.ccx.tcx;\n         let ity = option::get(ty::impl_iface(tcx, impl_did));\n         let iface_ty = ty::substitute_type_params(tcx, impl_tys, ity);\n-        alt ty::get(iface_ty).struct {\n+        alt check ty::get(iface_ty).struct {\n           ty::ty_iface(_, tps) {\n             vec::iter2(tps, iface_tys,\n                        {|a, b| demand::simple(fcx, sp, a, b);});\n           }\n-          _ {\n-              tcx.sess.span_bug(sp, \"Undocumented invariant in \\\n-                 connect_iface_tps\");\n-          }\n         }\n     }\n "}, {"sha": "dba406c889ecddf3597b32c36db891c6c609e0f4", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -395,7 +395,6 @@ mod tests {\n           option_missing(_) { assert (ft == option_missing_); }\n           option_duplicated(_) { assert (ft == option_duplicated_); }\n           unexpected_argument(_) { assert (ft == unexpected_argument_); }\n-          _ { fail; }\n         }\n     }\n \n@@ -406,12 +405,11 @@ mod tests {\n         let args = [\"--test=20\"];\n         let opts = [reqopt(\"test\")];\n         let rs = getopts(args, opts);\n-        alt rs {\n+        alt check rs {\n           ok(m) {\n             assert (opt_present(m, \"test\"));\n             assert (opt_str(m, \"test\") == \"20\");\n           }\n-          _ { fail; }\n         }\n     }\n "}, {"sha": "5c8949dc7b9ee67e3d833edd4bef7f2f56f39d4e", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -243,7 +243,7 @@ fn fold_enum(\n         desc: attrs.desc,\n         variants: vec::map(doc.variants) {|variant|\n             let attrs = astsrv::exec(srv) {|ctxt|\n-                alt ctxt.ast_map.get(doc.id) {\n+                alt check ctxt.ast_map.get(doc.id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _), _\n                   }, _) {\n@@ -254,7 +254,6 @@ fn fold_enum(\n \n                     attr_parser::parse_variant(ast_variant.node.attrs)\n                   }\n-                  _ { fail \"fold_enum: undocumented invariant\"; }\n                 }\n             };\n "}, {"sha": "37b3185987ab2eec00448d9a9e8cbc1f7b34a7a8", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "patch": "@@ -45,16 +45,13 @@ fn fold_fn(\n \n fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n     astsrv::exec(srv) {|ctxt|\n-        alt ctxt.ast_map.get(fn_id) {\n+        alt check ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n             ident: ident,\n             node: ast::item_fn(decl, _, blk), _\n           }, _) {\n             some(pprust::fun_to_str(decl, ident, []))\n           }\n-          _ {\n-            fail \"get_fn_sig: undocumented invariant\";\n-          }\n         }\n     }\n }\n@@ -83,13 +80,12 @@ fn merge_ret_ty(\n \n fn get_ret_ty(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n     astsrv::exec(srv) {|ctxt|\n-        alt ctxt.ast_map.get(fn_id) {\n+        alt check ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n             node: ast::item_fn(decl, _, _), _\n           }, _) {\n             ret_ty_to_str(decl)\n           }\n-          _ { fail \"get_ret_ty: undocumented invariant\"; }\n         }\n     }\n }\n@@ -133,7 +129,7 @@ fn merge_arg_tys(\n \n fn get_arg_tys(srv: astsrv::srv, fn_id: doc::ast_id) -> [(str, str)] {\n     astsrv::exec(srv) {|ctxt|\n-        alt ctxt.ast_map.get(fn_id) {\n+        alt check ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n             node: ast::item_fn(decl, _, _), _\n           }, _) |\n@@ -142,9 +138,6 @@ fn get_arg_tys(srv: astsrv::srv, fn_id: doc::ast_id) -> [(str, str)] {\n           }, _) {\n             decl_arg_tys(decl)\n           }\n-          _ {\n-            fail \"get_arg_tys: undocumented invariant\";\n-          }\n         }\n     }\n }\n@@ -171,15 +164,12 @@ fn fold_const(\n \n     {\n         ty: some(astsrv::exec(srv) {|ctxt|\n-            alt ctxt.ast_map.get(doc.id) {\n+            alt check ctxt.ast_map.get(doc.id) {\n               ast_map::node_item(@{\n                 node: ast::item_const(ty, _), _\n               }, _) {\n                 pprust::ty_to_str(ty)\n               }\n-              _ {\n-                fail \"fold_const: undocumented invariant\";\n-              }\n             }\n         })\n         with doc\n@@ -201,7 +191,7 @@ fn fold_enum(\n     {\n         variants: vec::map(doc.variants) {|variant|\n             let sig = astsrv::exec(srv) {|ctxt|\n-                alt ctxt.ast_map.get(doc.id) {\n+                alt check ctxt.ast_map.get(doc.id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _), _\n                   }, _) {\n@@ -212,7 +202,6 @@ fn fold_enum(\n \n                     pprust::variant_to_str(ast_variant)\n                   }\n-                  _ { fail \"fold_enum: undocumented invariant\"; }\n                 }\n             };\n \n@@ -240,13 +229,12 @@ fn fold_res(\n     {\n         args: merge_arg_tys(srv, doc.id, doc.args),\n         sig: some(astsrv::exec(srv) {|ctxt|\n-            alt ctxt.ast_map.get(doc.id) {\n+            alt check ctxt.ast_map.get(doc.id) {\n               ast_map::node_item(@{\n                 node: ast::item_res(decl, _, _, _, _), _\n               }, _) {\n                 pprust::res_to_str(decl, doc.name, [])\n               }\n-              _ { fail \"fold_res: undocumented invariant\"; }\n             }\n         })\n         with doc\n@@ -325,25 +313,23 @@ fn get_method_ret_ty(\n           ast_map::node_item(@{\n             node: ast::item_iface(_, methods), _\n           }, _) {\n-            alt vec::find(methods) {|method|\n+            alt check vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n                 some(method) {\n                     ret_ty_to_str(method.decl)\n                 }\n-                _ { fail \"get_method_ret_ty: undocumented invariant\"; }\n             }\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, methods), _\n           }, _) {\n-            alt vec::find(methods) {|method|\n+            alt check vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n                 some(method) {\n                     ret_ty_to_str(method.decl)\n                 }\n-                _ { fail \"get_method_ret_ty: undocumented invariant\"; }\n             }\n           }\n           _ { fail }\n@@ -357,32 +343,29 @@ fn get_method_sig(\n     method_name: str\n ) -> option<str> {\n     astsrv::exec(srv) {|ctxt|\n-        alt ctxt.ast_map.get(item_id) {\n+        alt check ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, methods), _\n           }, _) {\n-            alt vec::find(methods) {|method|\n+            alt check vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n                 some(method) {\n                     some(pprust::fun_to_str(method.decl, method.ident, []))\n                 }\n-                _ { fail \"get_method_sig: undocumented invariant\"; }\n             }\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, methods), _\n           }, _) {\n-            alt vec::find(methods) {|method|\n+            alt check vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n                 some(method) {\n                     some(pprust::fun_to_str(method.decl, method.ident, []))\n                 }\n-                _ { fail \"get_method_sig: undocumented invariant\"; }\n             }\n           }\n-          _ { fail \"get_method_sig: undocumented invariant\"; }\n         }\n     }\n }"}]}