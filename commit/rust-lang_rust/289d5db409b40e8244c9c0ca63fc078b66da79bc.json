{"sha": "289d5db409b40e8244c9c0ca63fc078b66da79bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4OWQ1ZGI0MDliNDBlODI0NGM5YzBjYTYzZmMwNzhiNjZkYTc5YmM=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-06-06T12:26:39Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "root@localhost", "date": "2015-06-06T12:26:39Z"}, "message": "linked_list: Use unsafe properly for Rawlink methods", "tree": {"sha": "929a48ac3b2d373950c23da61384d3b15be21d51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/929a48ac3b2d373950c23da61384d3b15be21d51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/289d5db409b40e8244c9c0ca63fc078b66da79bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/289d5db409b40e8244c9c0ca63fc078b66da79bc", "html_url": "https://github.com/rust-lang/rust/commit/289d5db409b40e8244c9c0ca63fc078b66da79bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/289d5db409b40e8244c9c0ca63fc078b66da79bc/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a090e1f411b65236b5ca8aad3e9375426fcd075e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a090e1f411b65236b5ca8aad3e9375426fcd075e", "html_url": "https://github.com/rust-lang/rust/commit/a090e1f411b65236b5ca8aad3e9375426fcd075e"}], "stats": {"total": 118, "additions": 70, "deletions": 48}, "files": [{"sha": "8fbd45ea770dd209f8c3992c0c98d734ed2db800", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/289d5db409b40e8244c9c0ca63fc078b66da79bc/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/289d5db409b40e8244c9c0ca63fc078b66da79bc/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=289d5db409b40e8244c9c0ca63fc078b66da79bc", "patch": "@@ -104,17 +104,23 @@ impl<T> Rawlink<T> {\n     }\n \n     /// Convert the `Rawlink` into an Option value\n-    fn resolve_immut<'a>(&self) -> Option<&'a T> {\n-        unsafe {\n-            self.p.as_ref()\n-        }\n+    ///\n+    /// **unsafe** because:\n+    ///\n+    /// - Dereference of raw pointer.\n+    /// - Returns reference of arbitrary lifetime.\n+    unsafe fn resolve<'a>(&self) -> Option<&'a T> {\n+        self.p.as_ref()\n     }\n \n     /// Convert the `Rawlink` into an Option value\n-    fn resolve<'a>(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            self.p.as_mut()\n-        }\n+    ///\n+    /// **unsafe** because:\n+    ///\n+    /// - Dereference of raw pointer.\n+    /// - Returns reference of arbitrary lifetime.\n+    unsafe fn resolve_mut<'a>(&mut self) -> Option<&'a mut T> {\n+        self.p.as_mut()\n     }\n \n     /// Return the `Rawlink` and replace with `Rawlink::none()`\n@@ -179,7 +185,7 @@ impl<T> LinkedList<T> {\n     /// Add a Node last in the list\n     #[inline]\n     fn push_back_node(&mut self, mut new_tail: Box<Node<T>>) {\n-        match self.list_tail.resolve() {\n+        match unsafe { self.list_tail.resolve_mut() } {\n             None => return self.push_front_node(new_tail),\n             Some(tail) => {\n                 self.list_tail = Rawlink::some(&mut *new_tail);\n@@ -192,14 +198,16 @@ impl<T> LinkedList<T> {\n     /// Remove the last Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n-        self.list_tail.resolve().map_or(None, |tail| {\n-            self.length -= 1;\n-            self.list_tail = tail.prev;\n-            match tail.prev.resolve() {\n-                None => self.list_head.take(),\n-                Some(tail_prev) => tail_prev.next.take()\n-            }\n-        })\n+        unsafe {\n+            self.list_tail.resolve_mut().and_then(|tail| {\n+                self.length -= 1;\n+                self.list_tail = tail.prev;\n+                match tail.prev.resolve_mut() {\n+                    None => self.list_head.take(),\n+                    Some(tail_prev) => tail_prev.next.take()\n+                }\n+            })\n+        }\n     }\n }\n \n@@ -246,7 +254,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, other: &mut LinkedList<T>) {\n-        match self.list_tail.resolve() {\n+        match unsafe { self.list_tail.resolve_mut() } {\n             None => {\n                 self.length = other.length;\n                 self.list_head = other.list_head.take();\n@@ -433,7 +441,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n+        unsafe {\n+            self.list_tail.resolve().map(|tail| &tail.value)\n+        }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -460,7 +470,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        self.list_tail.resolve().map(|tail| &mut tail.value)\n+        unsafe {\n+            self.list_tail.resolve_mut().map(|tail| &mut tail.value)\n+        }\n     }\n \n     /// Adds an element first in the list.\n@@ -609,12 +621,14 @@ impl<T> LinkedList<T> {\n             length: len - at\n         };\n \n-        // Swap split_node.next with list_head (which is None), nulling out split_node.next,\n-        // as it is the new tail.\n-        mem::swap(&mut split_node.resolve().unwrap().next, &mut splitted_list.list_head);\n-        // Null out list_head.prev. Note this `unwrap` won't fail because if at == len\n-        // we already branched out at the top of the fn to return the empty list.\n-        splitted_list.list_head.as_mut().unwrap().prev = Rawlink::none();\n+        unsafe {\n+            // Swap split_node.next with list_head (which is None), nulling out split_node.next,\n+            // as it is the new tail.\n+            mem::swap(&mut split_node.resolve_mut().unwrap().next, &mut splitted_list.list_head);\n+            // Null out list_head.prev. Note this `unwrap` won't fail because if at == len\n+            // we already branched out at the top of the fn to return the empty list.\n+            splitted_list.list_head.as_mut().unwrap().prev = Rawlink::none();\n+        }\n         // Fix the tail ptr\n         self.list_tail = split_node;\n         self.length = at;\n@@ -666,11 +680,13 @@ impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        self.tail.resolve_immut().as_ref().map(|prev| {\n-            self.nelem -= 1;\n-            self.tail = prev.prev;\n-            &prev.value\n-        })\n+        unsafe {\n+            self.tail.resolve().map(|prev| {\n+                self.nelem -= 1;\n+                self.tail = prev.prev;\n+                &prev.value\n+            })\n+        }\n     }\n }\n \n@@ -685,14 +701,16 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        self.head.resolve().map(|next| {\n-            self.nelem -= 1;\n-            self.head = match next.next {\n-                Some(ref mut node) => Rawlink::some(&mut **node),\n-                None => Rawlink::none(),\n-            };\n-            &mut next.value\n-        })\n+        unsafe {\n+            self.head.resolve_mut().map(|next| {\n+                self.nelem -= 1;\n+                self.head = match next.next {\n+                    Some(ref mut node) => Rawlink::some(&mut **node),\n+                    None => Rawlink::none(),\n+                };\n+                &mut next.value\n+            })\n+        }\n     }\n \n     #[inline]\n@@ -708,11 +726,13 @@ impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        self.tail.resolve().map(|prev| {\n-            self.nelem -= 1;\n-            self.tail = prev.prev;\n-            &mut prev.value\n-        })\n+        unsafe {\n+            self.tail.resolve_mut().map(|prev| {\n+                self.nelem -= 1;\n+                self.tail = prev.prev;\n+                &mut prev.value\n+            })\n+        }\n     }\n }\n \n@@ -726,10 +746,10 @@ impl<'a, A> IterMut<'a, A> {\n         // previously yielded element and self.head.\n         //\n         // The inserted node will not appear in further iteration.\n-        match self.head.resolve() {\n+        match unsafe { self.head.resolve_mut() } {\n             None => { self.list.push_back_node(ins_node); }\n             Some(node) => {\n-                let prev_node = match node.prev.resolve() {\n+                let prev_node = match unsafe { node.prev.resolve_mut() } {\n                     None => return self.list.push_front_node(ins_node),\n                     Some(prev) => prev,\n                 };\n@@ -795,7 +815,9 @@ impl<'a, A> IterMut<'a, A> {\n         if self.nelem == 0 {\n             return None\n         }\n-        self.head.resolve().map(|head| &mut head.value)\n+        unsafe {\n+            self.head.resolve_mut().map(|head| &mut head.value)\n+        }\n     }\n }\n \n@@ -947,7 +969,7 @@ mod tests {\n             Some(ref node) => node_ptr = &**node,\n         }\n         loop {\n-            match (last_ptr, node_ptr.prev.resolve_immut()) {\n+            match unsafe { (last_ptr, node_ptr.prev.resolve()) } {\n                 (None   , None      ) => {}\n                 (None   , _         ) => panic!(\"prev link for list_head\"),\n                 (Some(p), Some(pptr)) => {"}]}