{"sha": "b1c699815ddf22bf17b58a8c3d317af33745e28d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYzY5OTgxNWRkZjIyYmYxN2I1OGE4YzNkMzE3YWYzMzc0NWUyOGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-12T20:00:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-14T03:07:09Z"}, "message": "librustc: Don't accept `as Trait` anymore; fix all occurrences of it.", "tree": {"sha": "164b9b4cb10ca38a8908c2b3d84f56f2a0cb78fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/164b9b4cb10ca38a8908c2b3d84f56f2a0cb78fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1c699815ddf22bf17b58a8c3d317af33745e28d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c699815ddf22bf17b58a8c3d317af33745e28d", "html_url": "https://github.com/rust-lang/rust/commit/b1c699815ddf22bf17b58a8c3d317af33745e28d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1c699815ddf22bf17b58a8c3d317af33745e28d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24a0de4e7f26d5bbd071fbec5b3958b650cd3f56", "url": "https://api.github.com/repos/rust-lang/rust/commits/24a0de4e7f26d5bbd071fbec5b3958b650cd3f56", "html_url": "https://github.com/rust-lang/rust/commit/24a0de4e7f26d5bbd071fbec5b3958b650cd3f56"}], "stats": {"total": 1214, "additions": 676, "deletions": 538}, "files": [{"sha": "aaf49c5ca9839888b16ec1f56d282da6c377f54c", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -1227,7 +1227,7 @@ to pointers to the trait name, used as a type.\n # impl Shape for int { }\n # let mycircle = 0;\n \n-let myshape: Shape = @mycircle as @Shape;\n+let myshape: @Shape = @mycircle as @Shape;\n ~~~~\n \n The resulting value is a managed box containing the value that was cast,"}, {"sha": "c830648e9dffef6f13888392f1a7f2f9221b2394", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -17,6 +17,7 @@ Simple compression\n use libc;\n use libc::{c_void, size_t, c_int};\n use ptr;\n+use rand::RngUtil;\n use vec;\n \n #[cfg(test)] use rand;"}, {"sha": "931866999c408a44bb1bbce84e7547bd0dae6fce", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -20,6 +20,7 @@ pub mod linear {\n     use hash::Hash;\n     use iter;\n     use option::{None, Option, Some};\n+    use rand::RngUtil;\n     use rand;\n     use uint;\n     use vec;"}, {"sha": "4942b0587851b4422fdfab370d42666f1c43c4a7", "filename": "src/libcore/io.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -785,8 +785,7 @@ pub fn fd_writer(fd: fd_t, cleanup: bool) -> @Writer {\n \n \n pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-    -> Result<Writer, ~str> {\n-\n+                   -> Result<@Writer, ~str> {\n     #[cfg(windows)]\n     fn wb() -> c_int {\n       (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n@@ -1079,22 +1078,24 @@ impl<T:Writer> WriterUtil for T {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<Writer, ~str> {\n+pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n     mk_file_writer(path, flags).chain(|w| result::Ok(w))\n }\n \n \n // FIXME: fileflags // #2004\n-pub fn buffered_file_writer(path: &Path) -> Result<Writer, ~str> {\n+pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n     unsafe {\n         let f = do os::as_c_charp(path.to_str()) |pathbuf| {\n             do os::as_c_charp(\"w\") |modebuf| {\n                 libc::fopen(pathbuf, modebuf)\n             }\n         };\n-        return if f as uint == 0u { result::Err(~\"error opening \"\n-                                                + path.to_str()) }\n-        else { result::Ok(FILE_writer(f, true)) }\n+        return if f as uint == 0u {\n+            result::Err(~\"error opening \" + path.to_str())\n+        } else {\n+            result::Ok(FILE_writer(f, true))\n+        }\n     }\n }\n \n@@ -1142,14 +1143,14 @@ pub pure fn BytesWriter() -> BytesWriter {\n     BytesWriter { bytes: ~[], mut pos: 0u }\n }\n \n-pub pure fn with_bytes_writer(f: &fn(Writer)) -> ~[u8] {\n+pub pure fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n-    f(wr as Writer);\n+    f(wr as @Writer);\n     let @BytesWriter{bytes, _} = wr;\n     return bytes;\n }\n \n-pub pure fn with_str_writer(f: &fn(Writer)) -> ~str {\n+pub pure fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n     // FIXME (#3758): This should not be needed.\n@@ -1277,8 +1278,8 @@ pub mod fsync {\n     pub trait FSyncable { fn fsync(&self, l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n-    pub fn obj_sync(o: FSyncable, opt_level: Option<Level>,\n-                    blk: &fn(v: Res<FSyncable>)) {\n+    pub fn obj_sync(o: @FSyncable, opt_level: Option<Level>,\n+                    blk: &fn(v: Res<@FSyncable>)) {\n         blk(Res(Arg {\n             val: o, opt_level: opt_level,\n             fsync_fn: |o, l| o.fsync(l)\n@@ -1305,12 +1306,12 @@ mod tests {\n             ~\"A hoopy frood who really knows where his towel is.\";\n         debug!(copy frood);\n         {\n-            let out: io::Writer =\n+            let out: @io::Writer =\n                 result::get(\n                     &io::file_writer(tmpfile, ~[io::Create, io::Truncate]));\n             out.write_str(frood);\n         }\n-        let inp: io::Reader = result::get(&io::file_reader(tmpfile));\n+        let inp: @io::Reader = result::get(&io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n         debug!(copy frood2);\n         fail_unless!(frood == frood2);"}, {"sha": "746c403c7bfbaded1129c02e35b5c4dc0faeca81", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -1265,6 +1265,7 @@ mod tests {\n     use os::{remove_file, setenv};\n     use os;\n     use path::Path;\n+    use rand::RngUtil;\n     use rand;\n     use run;\n     use str;\n@@ -1282,7 +1283,7 @@ mod tests {\n     }\n \n     fn make_rand_name() -> ~str {\n-        let rng: rand::Rng = rand::Rng();\n+        let rng: @rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         fail_unless!(getenv(n).is_none());\n         n"}, {"sha": "4cb5e58b73331855e22e44002f2db3b03429ba01", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 100, "deletions": 22, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -22,97 +22,100 @@ use libc::size_t;\n \n /// A type that can be randomly generated using an RNG\n pub trait Rand {\n-    static fn rand(rng: rand::Rng) -> Self;\n+    static fn rand(rng: @rand::Rng) -> Self;\n }\n \n impl Rand for int {\n-    static fn rand(rng: rand::Rng) -> int {\n+    static fn rand(rng: @rand::Rng) -> int {\n         rng.gen_int()\n     }\n }\n \n impl Rand for i8 {\n-    static fn rand(rng: rand::Rng) -> i8 {\n+    static fn rand(rng: @rand::Rng) -> i8 {\n         rng.gen_i8()\n     }\n }\n \n impl Rand for i16 {\n-    static fn rand(rng: rand::Rng) -> i16 {\n+    static fn rand(rng: @rand::Rng) -> i16 {\n         rng.gen_i16()\n     }\n }\n \n impl Rand for i32 {\n-    static fn rand(rng: rand::Rng) -> i32 {\n+    static fn rand(rng: @rand::Rng) -> i32 {\n         rng.gen_i32()\n     }\n }\n \n impl Rand for i64 {\n-    static fn rand(rng: rand::Rng) -> i64 {\n+    static fn rand(rng: @rand::Rng) -> i64 {\n         rng.gen_i64()\n     }\n }\n \n impl Rand for u8 {\n-    static fn rand(rng: rand::Rng) -> u8 {\n+    static fn rand(rng: @rand::Rng) -> u8 {\n         rng.gen_u8()\n     }\n }\n \n impl Rand for u16 {\n-    static fn rand(rng: rand::Rng) -> u16 {\n+    static fn rand(rng: @rand::Rng) -> u16 {\n         rng.gen_u16()\n     }\n }\n \n impl Rand for u32 {\n-    static fn rand(rng: rand::Rng) -> u32 {\n+    static fn rand(rng: @rand::Rng) -> u32 {\n         rng.gen_u32()\n     }\n }\n \n impl Rand for u64 {\n-    static fn rand(rng: rand::Rng) -> u64 {\n+    static fn rand(rng: @rand::Rng) -> u64 {\n         rng.gen_u64()\n     }\n }\n \n impl Rand for float {\n-    static fn rand(rng: rand::Rng) -> float {\n+    static fn rand(rng: @rand::Rng) -> float {\n         rng.gen_float()\n     }\n }\n \n impl Rand for f32 {\n-    static fn rand(rng: rand::Rng) -> f32 {\n+    static fn rand(rng: @rand::Rng) -> f32 {\n         rng.gen_f32()\n     }\n }\n \n impl Rand for f64 {\n-    static fn rand(rng: rand::Rng) -> f64 {\n+    static fn rand(rng: @rand::Rng) -> f64 {\n         rng.gen_f64()\n     }\n }\n \n impl Rand for char {\n-    static fn rand(rng: rand::Rng) -> char {\n+    static fn rand(rng: @rand::Rng) -> char {\n         rng.gen_char()\n     }\n }\n \n impl Rand for bool {\n-    static fn rand(rng: rand::Rng) -> bool {\n+    static fn rand(rng: @rand::Rng) -> bool {\n         rng.gen_bool()\n     }\n }\n \n impl<T:Rand> Rand for Option<T> {\n-    static fn rand(rng: rand::Rng) -> Option<T> {\n-        if rng.gen_bool() { Some(Rand::rand(rng)) }\n-        else { None }\n+    static fn rand(rng: @rand::Rng) -> Option<T> {\n+        if rng.gen_bool() {\n+            Some(Rand::rand(rng))\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -145,8 +148,83 @@ pub struct Weighted<T> {\n     item: T,\n }\n \n+pub trait RngUtil {\n+    fn gen<T:Rand>(&self) -> T;\n+    /// Return a random int\n+    fn gen_int(&self) -> int;\n+    fn gen_int_range(&self, start: int, end: int) -> int;\n+    /// Return a random i8\n+    fn gen_i8(&self) -> i8;\n+    /// Return a random i16\n+    fn gen_i16(&self) -> i16;\n+    /// Return a random i32\n+    fn gen_i32(&self) -> i32;\n+    /// Return a random i64\n+    fn gen_i64(&self) -> i64;\n+    /// Return a random uint\n+    fn gen_uint(&self) -> uint;\n+    /**\n+     * Return a uint randomly chosen from the range [start, end),\n+     * failing if start >= end\n+     */\n+    fn gen_uint_range(&self, start: uint, end: uint) -> uint;\n+    /// Return a random u8\n+    fn gen_u8(&self) -> u8;\n+    /// Return a random u16\n+    fn gen_u16(&self) -> u16;\n+    /// Return a random u32\n+    fn gen_u32(&self) -> u32;\n+    /// Return a random u64\n+    fn gen_u64(&self) -> u64;\n+    /// Return a random float in the interval [0,1]\n+    fn gen_float(&self) -> float;\n+    /// Return a random f32 in the interval [0,1]\n+    fn gen_f32(&self) -> f32;\n+    /// Return a random f64 in the interval [0,1]\n+    fn gen_f64(&self) -> f64;\n+    /// Return a random char\n+    fn gen_char(&self) -> char;\n+    /**\n+     * Return a char randomly chosen from chars, failing if chars is empty\n+     */\n+    fn gen_char_from(&self, chars: &str) -> char;\n+    /// Return a random bool\n+    fn gen_bool(&self) -> bool;\n+    /// Return a bool with a 1 in n chance of true\n+    fn gen_weighted_bool(&self, n: uint) -> bool;\n+    /**\n+     * Return a random string of the specified length composed of A-Z,a-z,0-9\n+     */\n+    fn gen_str(&self, len: uint) -> ~str;\n+    /// Return a random byte string of the specified length\n+    fn gen_bytes(&self, len: uint) -> ~[u8];\n+    /// Choose an item randomly, failing if values is empty\n+    fn choose<T:Copy>(&self, values: &[T]) -> T;\n+    /// Choose Some(item) randomly, returning None if values is empty\n+    fn choose_option<T:Copy>(&self, values: &[T]) -> Option<T>;\n+    /**\n+     * Choose an item respecting the relative weights, failing if the sum of\n+     * the weights is 0\n+     */\n+    fn choose_weighted<T:Copy>(&self, v : &[Weighted<T>]) -> T;\n+    /**\n+     * Choose Some(item) respecting the relative weights, returning none if\n+     * the sum of the weights is 0\n+     */\n+    fn choose_weighted_option<T:Copy>(&self, v: &[Weighted<T>]) -> Option<T>;\n+    /**\n+     * Return a vec containing copies of the items, in order, where\n+     * the weight of the item determines how many copies there are\n+     */\n+    fn weighted_vec<T:Copy>(&self, v: &[Weighted<T>]) -> ~[T];\n+    /// Shuffle a vec\n+    fn shuffle<T:Copy>(&self, values: &[T]) -> ~[T];\n+    /// Shuffle a mutable vec in place\n+    fn shuffle_mut<T>(&self, values: &mut [T]);\n+}\n+\n /// Extension methods for random number generators\n-pub impl Rng {\n+impl RngUtil for @Rng {\n     /// Return a random value for a Rand type\n     fn gen<T:Rand>(&self) -> T {\n         Rand::rand(*self)\n@@ -407,7 +485,7 @@ pub fn seed() -> ~[u8] {\n }\n \n /// Create a random number generator with a system specified seed\n-pub fn Rng() -> Rng {\n+pub fn Rng() -> @Rng {\n     seeded_rng(seed())\n }\n \n@@ -449,7 +527,7 @@ impl Rng for XorShiftState {\n     }\n }\n \n-pub pure fn xorshift() -> Rng {\n+pub pure fn xorshift() -> @Rng {\n     // constants taken from http://en.wikipedia.org/wiki/Xorshift\n     seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n }\n@@ -467,7 +545,7 @@ fn tls_rng_state(_v: @RandRes) {}\n  * seeded by the system. Intended to be used in method chaining style, ie\n  * task_rng().gen_int().\n  */\n-pub fn task_rng() -> Rng {\n+pub fn task_rng() -> @Rng {\n     let r : Option<@RandRes>;\n     unsafe {\n         r = task::local_data::local_data_get(tls_rng_state);"}, {"sha": "e6a4a99df4419b2ed97f3edf46673e95acad0489", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -41,7 +41,7 @@ trait EscapedCharWriter {\n     fn write_escaped_char(&self, ch: char);\n }\n \n-impl EscapedCharWriter for Writer {\n+impl EscapedCharWriter for @Writer {\n     fn write_escaped_char(&self, ch: char) {\n         match ch {\n             '\\t' => self.write_str(\"\\\\t\"),"}, {"sha": "d3affbc69fe910b30eb550f72c62d9bb9faa1b4c", "filename": "src/libcore/run.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -45,13 +45,13 @@ pub trait Program {\n     fn get_id(&mut self) -> pid_t;\n \n     /// Returns an io::writer that can be used to write to stdin\n-    fn input(&mut self) -> io::Writer;\n+    fn input(&mut self) -> @io::Writer;\n \n     /// Returns an io::reader that can be used to read from stdout\n-    fn output(&mut self) -> io::Reader;\n+    fn output(&mut self) -> @io::Reader;\n \n     /// Returns an io::reader that can be used to read from stderr\n-    fn err(&mut self) -> io::Reader;\n+    fn err(&mut self) -> @io::Reader;\n \n     /// Closes the handle to the child processes standard input\n     fn close_input(&mut self);\n@@ -207,7 +207,7 @@ pub fn run_program(prog: &str, args: &[~str]) -> int {\n  *\n  * A class with a <program> field\n  */\n-pub fn start_program(prog: &str, args: &[~str]) -> Program {\n+pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n@@ -274,13 +274,13 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n \n     impl Program for ProgRes {\n         fn get_id(&mut self) -> pid_t { return self.r.pid; }\n-        fn input(&mut self) -> io::Writer {\n+        fn input(&mut self) -> @io::Writer {\n             io::fd_writer(self.r.in_fd, false)\n         }\n-        fn output(&mut self) -> io::Reader {\n+        fn output(&mut self) -> @io::Reader {\n             io::FILE_reader(self.r.out_file, false)\n         }\n-        fn err(&mut self) -> io::Reader {\n+        fn err(&mut self) -> @io::Reader {\n             io::FILE_reader(self.r.err_file, false)\n         }\n         fn close_input(&mut self) { close_repr_input(&mut self.r); }"}, {"sha": "6a933ef515f1fb48af2bdc877a1824b4a40e6986", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -23,7 +23,7 @@ use super::rt::rust_task;\n pub trait LocalData { }\n impl<T:Durable> LocalData for @T { }\n \n-impl Eq for LocalData {\n+impl Eq for @LocalData {\n     pure fn eq(&self, other: &@LocalData) -> bool {\n         unsafe {\n             let ptr_a: (uint, uint) = cast::reinterpret_cast(&(*self));\n@@ -36,7 +36,7 @@ impl Eq for LocalData {\n \n // If TLS is used heavily in future, this could be made more efficient with a\n // proper map.\n-type TaskLocalElement = (*libc::c_void, *libc::c_void, LocalData);\n+type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n // Has to be a pointer at outermost layer; the foreign call returns void *.\n type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n "}, {"sha": "99ba5030f83b0cca6a93ed99418218d2bf85e94f", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use sys;\n use cast;\n+use libc::{c_void, size_t};\n+use rand::RngUtil;\n+use rand;\n+use sys;\n use task;\n use vec;\n-use rand;\n-use libc::{c_void, size_t};\n \n #[cfg(test)] use uint;\n "}, {"sha": "ce554f3473163ab22859526e22a1a7cd74efc915", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -202,10 +202,13 @@ pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n                              newexpr: ast::expr, tm: test_mode) ->\n    ast::crate {\n     let j: @mut uint = @mut 0u;\n-    fn fold_expr_rep(j_: @mut uint, i_: uint, newexpr_: ast::expr_,\n-                     original: &ast::expr_, fld: fold::ast_fold,\n-                     tm_: test_mode) ->\n-       ast::expr_ {\n+    fn fold_expr_rep(j_: @mut uint,\n+                     i_: uint,\n+                     newexpr_: ast::expr_,\n+                     original: &ast::expr_,\n+                     fld: @fold::ast_fold,\n+                     tm_: test_mode)\n+                  -> ast::expr_ {\n         *j_ += 1u;\n         if i_ + 1u == *j_ && safe_to_replace_expr(original, tm_) {\n             newexpr_\n@@ -229,10 +232,13 @@ pub fn replace_expr_in_crate(crate: ast::crate, i: uint,\n pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n                            tm: test_mode) -> ast::crate {\n     let j: @mut uint = @mut 0u;\n-    fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n-                   original: &ast::ty_, fld: fold::ast_fold,\n-                   tm_: test_mode) ->\n-       ast::ty_ {\n+    fn fold_ty_rep(j_: @mut uint,\n+                   i_: uint,\n+                   newty_: ast::ty_,\n+                   original: &ast::ty_,\n+                   fld: @fold::ast_fold,\n+                   tm_: test_mode)\n+                -> ast::ty_ {\n         *j_ += 1u;\n         if i_ + 1u == *j_ && safe_to_replace_ty(original, tm_) {\n             newty_\n@@ -252,7 +258,7 @@ pub fn under(n: uint, it: &fn(uint)) {\n     while i < n { it(i); i += 1u; }\n }\n \n-pub fn as_str(f: @fn(+x: io::Writer)) -> ~str {\n+pub fn as_str(f: @fn(+x: @io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n \n@@ -304,7 +310,8 @@ pub fn check_variants_T<T: Copy>(\n                         diagnostic::mk_span_handler(handler, codemap),\n                         crate2,\n                         fname,\n-                        rdr, a,\n+                        rdr,\n+                        a,\n                         pprust::no_ann(),\n                         false))\n                 };"}, {"sha": "509ef704b070abe9cf537de9ccb52a507de8c7d0", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -681,7 +681,7 @@ pub fn build_session(sopts: @session::options,\n pub fn build_session_(sopts: @session::options,\n                       cm: @codemap::CodeMap,\n                       demitter: diagnostic::Emitter,\n-                      span_diagnostic_handler: diagnostic::span_handler)\n+                      span_diagnostic_handler: @diagnostic::span_handler)\n                    -> Session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n@@ -870,7 +870,7 @@ pub fn early_error(emitter: diagnostic::Emitter, msg: ~str) -> ! {\n     fail!();\n }\n \n-pub fn list_metadata(sess: Session, path: &Path, out: io::Writer) {\n+pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n     metadata::loader::list_file_metadata(\n         sess.parse_sess.interner,\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);"}, {"sha": "22b4fd36154290fdb4cf0093f1ecdcb6816ce080", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -154,8 +154,8 @@ pub struct Session_ {\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n     main_fn: @mut Option<(node_id, codemap::span)>,\n-    span_diagnostic: diagnostic::span_handler,\n-    filesearch: filesearch::FileSearch,\n+    span_diagnostic: @diagnostic::span_handler,\n+    filesearch: @filesearch::FileSearch,\n     building_library: @mut bool,\n     working_dir: Path,\n     lint_settings: lint::LintSettings\n@@ -227,7 +227,7 @@ pub impl Session {\n     fn next_node_id(&self) -> ast::node_id {\n         return syntax::parse::next_node_id(self.parse_sess);\n     }\n-    fn diagnostic(&self) -> diagnostic::span_handler {\n+    fn diagnostic(&self) -> @diagnostic::span_handler {\n         self.span_diagnostic\n     }\n     fn debugging_opt(&self, opt: uint) -> bool {"}, {"sha": "bb0080ba5357073fd50962f2850746328a5f8223", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -63,7 +63,7 @@ fn filter_view_item(cx: @Context, &&view_item: @ast::view_item\n     }\n }\n \n-fn fold_mod(cx: @Context, m: &ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n+fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n     let filtered_items =\n         m.items.filter_mapped(|a| filter_item(cx, *a));\n     let filtered_view_items =\n@@ -84,7 +84,7 @@ fn filter_foreign_item(cx: @Context, &&item: @ast::foreign_item) ->\n fn fold_foreign_mod(\n     cx: @Context,\n     nm: &ast::foreign_mod,\n-    fld: fold::ast_fold\n+    fld: @fold::ast_fold\n ) -> ast::foreign_mod {\n     let filtered_items =\n         nm.items.filter_mapped(|a| filter_foreign_item(cx, *a));\n@@ -99,7 +99,7 @@ fn fold_foreign_mod(\n }\n \n fn fold_item_underscore(cx: @Context, item: &ast::item_,\n-                        fld: fold::ast_fold) -> ast::item_ {\n+                        fld: @fold::ast_fold) -> ast::item_ {\n     let item = match *item {\n         ast::item_impl(ref a, b, c, ref methods) => {\n             let methods = methods.filtered(|m| method_in_cfg(cx, *m) );\n@@ -135,7 +135,7 @@ fn filter_stmt(cx: @Context, &&stmt: @ast::stmt) ->\n fn fold_block(\n     cx: @Context,\n     b: &ast::blk_,\n-    fld: fold::ast_fold\n+    fld: @fold::ast_fold\n ) -> ast::blk_ {\n     let filtered_stmts =\n         b.stmts.filter_mapped(|a| filter_stmt(cx, *a));"}, {"sha": "6cfcac3e85a28996be313d58df5f13362d79a4f0", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -128,7 +128,7 @@ pub mod intrinsic {\n         #[abi = \"rust-intrinsic\"]\n         pub extern {\n             pub fn get_tydesc<T>() -> *();\n-            pub fn visit_tydesc(++td: *TyDesc, &&tv: TyVisitor);\n+            pub fn visit_tydesc(++td: *TyDesc, &&tv: @TyVisitor);\n         }\n     }\n }"}, {"sha": "48db758ef42ed002074969a8653ef71745fe81b7", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -39,7 +39,7 @@ struct TestCtxt {\n     sess: session::Session,\n     crate: @ast::crate,\n     path: ~[ast::ident],\n-    ext_cx: ext_ctxt,\n+    ext_cx: @ext_ctxt,\n     testfns: ~[Test]\n }\n \n@@ -102,7 +102,7 @@ fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n \n fn fold_mod(cx: @mut TestCtxt,\n             m: &ast::_mod,\n-            fld: fold::ast_fold)\n+            fld: @fold::ast_fold)\n          -> ast::_mod {\n     // Remove any #[main] from the AST so it doesn't clash with\n     // the one we're going to add. Only if compiling an executable.\n@@ -125,7 +125,7 @@ fn fold_mod(cx: @mut TestCtxt,\n \n fn fold_crate(cx: @mut TestCtxt,\n               c: &ast::crate_,\n-              fld: fold::ast_fold)\n+              fld: @fold::ast_fold)\n            -> ast::crate_ {\n     let folded = fold::noop_fold_crate(c, fld);\n \n@@ -138,7 +138,7 @@ fn fold_crate(cx: @mut TestCtxt,\n }\n \n \n-fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: fold::ast_fold)\n+fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: @fold::ast_fold)\n           -> Option<@ast::item> {\n     cx.path.push(i.ident);\n     debug!(\"current path: %s\","}, {"sha": "a9aa5491631aa16c546b33d62598b952809746f0", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -30,10 +30,10 @@ use std::oldmap::HashMap;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n-pub fn read_crates(diag: span_handler,\n+pub fn read_crates(diag: @span_handler,\n                    crate: ast::crate,\n                    cstore: @mut cstore::CStore,\n-                   filesearch: FileSearch,\n+                   filesearch: @FileSearch,\n                    os: loader::os,\n                    statik: bool,\n                    intr: @ident_interner) {\n@@ -75,7 +75,7 @@ fn dump_crates(crate_cache: @mut ~[cache_entry]) {\n }\n \n fn warn_if_multiple_versions(e: @mut Env,\n-                             diag: span_handler,\n+                             diag: @span_handler,\n                              crate_cache: @mut ~[cache_entry]) {\n     use core::either::*;\n \n@@ -115,8 +115,8 @@ fn warn_if_multiple_versions(e: @mut Env,\n }\n \n struct Env {\n-    diag: span_handler,\n-    filesearch: FileSearch,\n+    diag: @span_handler,\n+    filesearch: @FileSearch,\n     cstore: @mut cstore::CStore,\n     os: loader::os,\n     statik: bool,"}, {"sha": "658b32edf21639547434d6aba32f32c06647f7d1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -1017,14 +1017,15 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n }\n \n fn list_meta_items(intr: @ident_interner,\n-                   meta_items: ebml::Doc, out: io::Writer) {\n+                   meta_items: ebml::Doc,\n+                   out: @io::Writer) {\n     for get_meta_items(meta_items).each |mi| {\n         out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n \n fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n-                         out: io::Writer) {\n+                         out: @io::Writer) {\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n     for get_attributes(md).each |attr| {\n@@ -1063,7 +1064,7 @@ pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     return deps;\n }\n \n-fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: io::Writer) {\n+fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: @io::Writer) {\n     out.write_str(~\"=External Dependencies=\\n\");\n \n     for get_crate_deps(intr, data).each |dep| {\n@@ -1106,7 +1107,7 @@ fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n }\n \n pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n-                           out: io::Writer) {\n+                           out: @io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n     list_crate_attributes(intr, md, *hash, out);"}, {"sha": "4b1260e76d0d4cc93ec7a16a607ca32f61ae1a1a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -57,7 +57,7 @@ pub type encode_inlined_item = @fn(ecx: @EncodeContext,\n                                    ii: ast::inlined_item);\n \n pub struct EncodeParams {\n-    diag: span_handler,\n+    diag: @span_handler,\n     tcx: ty::ctxt,\n     reachable: HashMap<ast::node_id, ()>,\n     reexports2: middle::resolve::ExportMap2,\n@@ -83,7 +83,7 @@ struct Stats {\n }\n \n pub struct EncodeContext {\n-    diag: span_handler,\n+    diag: @span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reachable: HashMap<ast::node_id, ()>,\n@@ -1054,7 +1054,7 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n }\n \n fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n-                   write_fn: &fn(io::Writer, T)) {\n+                   write_fn: &fn(@io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n@@ -1081,9 +1081,9 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: io::Writer, &&s: ~str) { writer.write_str(s); }\n+fn write_str(writer: @io::Writer, &&s: ~str) { writer.write_str(s); }\n \n-fn write_int(writer: io::Writer, &&n: int) {\n+fn write_int(writer: @io::Writer, &&n: int) {\n     fail_unless!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n@@ -1326,7 +1326,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         type_abbrevs: ty::new_ty_hash()\n      };\n \n-    let ebml_w = writer::Encoder(wr as io::Writer);\n+    let ebml_w = writer::Encoder(wr as @io::Writer);\n \n     encode_hash(ebml_w, ecx.link_meta.extras_hash);\n "}, {"sha": "02203222e057e77d64748b4de0bc30ebe0e8d3e9", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -37,7 +37,8 @@ pub trait FileSearch {\n \n pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n                      target_triple: &str,\n-                     +addl_lib_search_paths: ~[Path]) -> FileSearch {\n+                     +addl_lib_search_paths: ~[Path])\n+                  -> @FileSearch {\n     struct FileSearchImpl {\n         sysroot: Path,\n         addl_lib_search_paths: ~[Path],\n@@ -78,7 +79,7 @@ pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n     } as @FileSearch\n }\n \n-pub fn search<T:Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {\n+pub fn search<T:Copy>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n     let mut rslt = None;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n         debug!(\"searching %s\", lib_search_path.to_str());"}, {"sha": "9c61205667750ee459e2bb768037a7fd9c306875", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -44,8 +44,8 @@ pub enum os {\n }\n \n pub struct Context {\n-    diag: span_handler,\n-    filesearch: FileSearch,\n+    diag: @span_handler,\n+    filesearch: @FileSearch,\n     span: span,\n     ident: ast::ident,\n     metas: ~[@ast::meta_item],\n@@ -87,7 +87,7 @@ fn libname(cx: Context) -> (~str, ~str) {\n fn find_library_crate_aux(\n     cx: Context,\n     (prefix, suffix): (~str, ~str),\n-    filesearch: filesearch::FileSearch\n+    filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n     let prefix: ~str = prefix + *crate_name + ~\"-\";\n@@ -156,7 +156,8 @@ pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @~str {\n     }\n }\n \n-pub fn note_linkage_attrs(intr: @ident_interner, diag: span_handler,\n+pub fn note_linkage_attrs(intr: @ident_interner,\n+                          diag: @span_handler,\n                           attrs: ~[ast::attribute]) {\n     for attr::find_linkage_metas(attrs).each |mi| {\n         diag.handler().note(fmt!(\"meta: %s\",\n@@ -252,7 +253,9 @@ pub fn meta_section_name(os: os) -> ~str {\n \n // A diagnostic function for dumping crate metadata to an output stream\n pub fn list_file_metadata(intr: @ident_interner,\n-                          os: os, path: &Path, out: io::Writer) {\n+                          os: os,\n+                          path: &Path,\n+                          out: @io::Writer) {\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {"}, {"sha": "56a9683762343b5fd3ccc96cdc84eb9ef997d449", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -27,7 +27,7 @@ use syntax::print::pprust::*;\n use middle::ty::Vid;\n \n pub struct ctxt {\n-    diag: span_handler,\n+    diag: @span_handler,\n     // Def -> str Callback:\n     ds: @fn(def_id) -> ~str,\n     // The type context.\n@@ -57,7 +57,7 @@ fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     }\n }\n \n-pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n+pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(&t) {\n@@ -113,7 +113,7 @@ pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n       }\n     }\n }\n-fn enc_mt(w: io::Writer, cx: @ctxt, mt: ty::mt) {\n+fn enc_mt(w: @io::Writer, cx: @ctxt, mt: ty::mt) {\n     match mt.mutbl {\n       m_imm => (),\n       m_mutbl => w.write_char('m'),\n@@ -122,7 +122,7 @@ fn enc_mt(w: io::Writer, cx: @ctxt, mt: ty::mt) {\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: io::Writer, t: Option<T>, enc_f: &fn(T)) {\n+fn enc_opt<T>(w: @io::Writer, t: Option<T>, enc_f: &fn(T)) {\n     match &t {\n       &None => w.write_char('n'),\n       &Some(ref v) => {\n@@ -132,15 +132,15 @@ fn enc_opt<T>(w: io::Writer, t: Option<T>, enc_f: &fn(T)) {\n     }\n }\n \n-fn enc_substs(w: io::Writer, cx: @ctxt, substs: ty::substs) {\n+fn enc_substs(w: @io::Writer, cx: @ctxt, substs: ty::substs) {\n     do enc_opt(w, substs.self_r) |r| { enc_region(w, cx, r) }\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n     for substs.tps.each |t| { enc_ty(w, cx, *t); }\n     w.write_char(']');\n }\n \n-fn enc_region(w: io::Writer, cx: @ctxt, r: ty::Region) {\n+fn enc_region(w: @io::Writer, cx: @ctxt, r: ty::Region) {\n     match r {\n       ty::re_bound(br) => {\n         w.write_char('b');\n@@ -169,7 +169,7 @@ fn enc_region(w: io::Writer, cx: @ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_bound_region(w: io::Writer, cx: @ctxt, br: ty::bound_region) {\n+fn enc_bound_region(w: @io::Writer, cx: @ctxt, br: ty::bound_region) {\n     match br {\n       ty::br_self => w.write_char('s'),\n       ty::br_anon(idx) => {\n@@ -194,7 +194,7 @@ fn enc_bound_region(w: io::Writer, cx: @ctxt, br: ty::bound_region) {\n     }\n }\n \n-pub fn enc_vstore(w: io::Writer, cx: @ctxt, v: ty::vstore) {\n+pub fn enc_vstore(w: @io::Writer, cx: @ctxt, v: ty::vstore) {\n     w.write_char('/');\n     match v {\n       ty::vstore_fixed(u) => {\n@@ -214,7 +214,7 @@ pub fn enc_vstore(w: io::Writer, cx: @ctxt, v: ty::vstore) {\n     }\n }\n \n-pub fn enc_trait_store(w: io::Writer, cx: @ctxt, s: ty::TraitStore) {\n+pub fn enc_trait_store(w: @io::Writer, cx: @ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => w.write_char('~'),\n         ty::BoxTraitStore => w.write_char('@'),\n@@ -226,7 +226,7 @@ pub fn enc_trait_store(w: io::Writer, cx: @ctxt, s: ty::TraitStore) {\n     }\n }\n \n-fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n+fn enc_sty(w: @io::Writer, cx: @ctxt, +st: ty::sty) {\n     match st {\n       ty::ty_nil => w.write_char('n'),\n       ty::ty_bot => w.write_char('z'),\n@@ -337,27 +337,27 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n     }\n }\n \n-fn enc_sigil(w: io::Writer, sigil: Sigil) {\n+fn enc_sigil(w: @io::Writer, sigil: Sigil) {\n     match sigil {\n         ManagedSigil => w.write_str(\"@\"),\n         OwnedSigil => w.write_str(\"~\"),\n         BorrowedSigil => w.write_str(\"&\"),\n     }\n }\n \n-pub fn enc_arg(w: io::Writer, cx: @ctxt, arg: ty::arg) {\n+pub fn enc_arg(w: @io::Writer, cx: @ctxt, arg: ty::arg) {\n     enc_mode(w, cx, arg.mode);\n     enc_ty(w, cx, arg.ty);\n }\n \n-pub fn enc_mode(w: io::Writer, cx: @ctxt, m: mode) {\n+pub fn enc_mode(w: @io::Writer, cx: @ctxt, m: mode) {\n     match ty::resolved_mode(cx.tcx, m) {\n       by_copy => w.write_char('+'),\n       by_ref => w.write_char('='),\n     }\n }\n \n-fn enc_purity(w: io::Writer, p: purity) {\n+fn enc_purity(w: @io::Writer, p: purity) {\n     match p {\n       pure_fn => w.write_char('p'),\n       impure_fn => w.write_char('i'),\n@@ -366,34 +366,34 @@ fn enc_purity(w: io::Writer, p: purity) {\n     }\n }\n \n-fn enc_abi(w: io::Writer, a: Abi) {\n+fn enc_abi(w: @io::Writer, a: Abi) {\n     match a {\n         RustAbi => w.write_char('r'),\n     }\n }\n \n-fn enc_onceness(w: io::Writer, o: Onceness) {\n+fn enc_onceness(w: @io::Writer, o: Onceness) {\n     match o {\n         Once => w.write_char('o'),\n         Many => w.write_char('m')\n     }\n }\n \n-fn enc_bare_fn_ty(w: io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n+fn enc_bare_fn_ty(w: @io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_closure_ty(w: io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n+fn enc_closure_ty(w: @io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_sigil(w, ft.sigil);\n     enc_purity(w, ft.purity);\n     enc_onceness(w, ft.onceness);\n     enc_region(w, cx, ft.region);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_fn_sig(w: io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n+fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     w.write_char('[');\n     for fsig.inputs.each |arg| {\n         enc_arg(w, cx, *arg);\n@@ -402,7 +402,7 @@ fn enc_fn_sig(w: io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     enc_ty(w, cx, fsig.output);\n }\n \n-pub fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n+pub fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n         match *bound {\n           ty::bound_owned => w.write_char('S'),"}, {"sha": "0e98bbe8ffa57244cea431b20d4ae514d09a774c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -292,7 +292,7 @@ fn encode_ast(ebml_w: writer::Encoder, item: ast::inlined_item) {\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n-    fn drop_nested_items(blk: &ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n+    fn drop_nested_items(blk: &ast::blk_, fld: @fold::ast_fold) -> ast::blk_ {\n         let stmts_sans_items = do blk.stmts.filtered |stmt| {\n             match stmt.node {\n               ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |"}, {"sha": "27561e619af57f7d7bb614d0e5a0775ce0c2ecfe", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -825,7 +825,8 @@ pub impl Liveness {\n         }\n     }\n \n-    fn write_vars(&self, wr: io::Writer,\n+    fn write_vars(&self,\n+                  wr: @io::Writer,\n                   ln: LiveNode,\n                   test: &fn(uint) -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));"}, {"sha": "f7226812b967a0628d47dbb76ce3a7cf4ab588c3", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -406,6 +406,6 @@ impl ABIInfo for X86_64_ABIInfo {\n     }\n }\n \n-pub fn x86_64_abi_info() -> ABIInfo {\n+pub fn x86_64_abi_info() -> @ABIInfo {\n     return @X86_64_ABIInfo as @ABIInfo;\n }"}, {"sha": "03806e71ac53747f82094127e33ba12e78ab607d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -1035,7 +1035,7 @@ pub fn T_captured_tydescs(cx: @CrateContext, n: uint) -> TypeRef {\n \n pub fn T_opaque_trait(cx: @CrateContext, store: ty::TraitStore) -> TypeRef {\n     match store {\n-        ty::BoxTraitStore | ty::BareTraitStore => {\n+        ty::BoxTraitStore => {\n             T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n         }\n         ty::UniqTraitStore => {\n@@ -1046,6 +1046,9 @@ pub fn T_opaque_trait(cx: @CrateContext, store: ty::TraitStore) -> TypeRef {\n         ty::RegionTraitStore(_) => {\n             T_struct(~[T_ptr(cx.tydesc_type), T_ptr(T_i8())])\n         }\n+        ty::BareTraitStore => {\n+            cx.sess.bug(~\"can't make T_opaque_trait with bare trait store\")\n+        }\n     }\n }\n "}, {"sha": "f6b8e4af6d57f090e7c7292f395b5fab88dbfa84", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -42,7 +42,7 @@ use syntax::{ast, ast_util};\n use syntax::{attr, ast_map};\n use syntax::parse::token::special_idents;\n \n-fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n+fn abi_info(arch: session::arch) -> @cabi::ABIInfo {\n     return match arch {\n         arch_x86_64 => x86_64_abi_info(),\n         arch_arm => cabi_arm::abi_info(),"}, {"sha": "69e06117785cb6181c098c31ffaf21eed35d750f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -244,7 +244,7 @@ pub struct InstantiatedTraitRef {\n pub type ctxt = @ctxt_;\n \n struct ctxt_ {\n-    diag: syntax::diagnostic::span_handler,\n+    diag: @syntax::diagnostic::span_handler,\n     interner: HashMap<intern_key, t_box>,\n     next_id: @mut uint,\n     vecs_implicitly_copyable: bool,\n@@ -3600,11 +3600,7 @@ pub fn impl_traits(cx: ctxt, id: ast::def_id, store: TraitStore) -> ~[t] {\n     fn storeify(cx: ctxt, ty: t, store: TraitStore) -> t {\n         match ty::get(ty).sty {\n             ty::ty_trait(did, ref substs, trait_store) => {\n-                if store == trait_store ||\n-                        (store == BareTraitStore &&\n-                         trait_store == BoxTraitStore) ||\n-                        (store == BoxTraitStore &&\n-                         trait_store == BareTraitStore) {\n+                if store == trait_store {\n                     ty\n                 } else {\n                     mk_trait(cx, did, (/*bad*/copy *substs), store)"}, {"sha": "61603f7b57824392585887cd139f21411d37f19e", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -218,7 +218,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n \n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n-    // Also handle function sigils and first-class trait types.\n+    // Also handle first-class trait types.\n     fn mk_pointer<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: &AC,\n         rscope: &RS,"}, {"sha": "39d769f30f5d81ec739651af9dcb646666ff7f53", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -3204,6 +3204,19 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n           fail_unless!(ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n           let (_, tydesc_ty) = tcx.intrinsic_defs.get(&tydesc_name);\n           let (_, visitor_trait) = tcx.intrinsic_defs.get(&ty_visitor_name);\n+\n+          let visitor_trait = match ty::get(visitor_trait).sty {\n+            ty::ty_trait(trait_def_id, ref trait_substs, _) => {\n+                ty::mk_trait(tcx,\n+                             trait_def_id,\n+                             copy *trait_substs,\n+                             ty::BoxTraitStore)\n+            }\n+            _ => {\n+                tcx.sess.span_bug(it.span, ~\"TyVisitor wasn't a trait?!\")\n+            }\n+          };\n+\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n                                                    mutbl: ast::m_imm});\n           (0u, ~[arg(ast::by_copy, td_ptr),"}, {"sha": "48a37c9e72ad0c7e75fda613b13f39e1ee26f5c8", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -198,12 +198,19 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                        vcx.infcx.ty_to_str(ity));\n \n                 match ty::get(ity).sty {\n-                    ty::ty_trait(idid, _, _) => {\n+                    ty::ty_trait(idid, ref isubsts, _) => {\n                         if trait_id == idid {\n                             debug!(\"(checking vtable) @0 \\\n                                     relating ty to trait \\\n                                     ty with did %?\",\n                                    idid);\n+\n+                            // Convert `ity` so that it has the right vstore.\n+                            let ity = ty::mk_trait(vcx.tcx(),\n+                                                   idid,\n+                                                   copy *isubsts,\n+                                                   trait_store);\n+\n                             relate_trait_tys(vcx, location_info,\n                                              trait_ty, ity);\n                             let vtable = vtable_param(n, n_bound);\n@@ -570,7 +577,6 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                   match (&ty::get(ty).sty, store) {\n                       (&ty::ty_box(mt), ty::BoxTraitStore) |\n                       // XXX: Bare trait store is deprecated.\n-                      (&ty::ty_box(mt), ty::BareTraitStore) |\n                       (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n                       (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*)) => {\n                           let location_info =\n@@ -622,8 +628,14 @@ pub fn early_resolve_expr(ex: @ast::expr,\n                           }\n                       }\n \n-                      // XXX: Remove bare below.\n-                      (_, ty::BoxTraitStore) | (_, ty::BareTraitStore) => {\n+                      (_, ty::BareTraitStore) => {\n+                          fcx.ccx.tcx.sess.span_err(\n+                              ex.span,\n+                              ~\"a sigil (`@`, `~`, or `&`) must be specified \\\n+                                when casting to a trait\");\n+                      }\n+\n+                      (_, ty::BoxTraitStore) => {\n                           fcx.ccx.tcx.sess.span_err(\n                               ex.span,\n                               fmt!(\"can only cast an @-pointer \\"}, {"sha": "3ec4fcb6d2e815cd5d8d9a335f605d98749a9cc4", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -369,12 +369,6 @@ pub fn super_trait_stores<C:Combine>(self: &C,\n         }\n       }\n \n-      // XXX: This should go away soon.\n-      (ty::BareTraitStore, ty::BoxTraitStore) |\n-      (ty::BoxTraitStore, ty::BareTraitStore) => {\n-        Ok(ty::BoxTraitStore)\n-      }\n-\n       _ if a == b => {\n         Ok(a)\n       }"}, {"sha": "e29e63c41ecca52653dfd88103496b5bdbbbb402", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -125,7 +125,8 @@ pub struct binding_rscope {\n \n pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: &RS)\n     -> binding_rscope {\n-    let base = @(copy *self) as @region_scope;\n+    let base = @copy *self;\n+    let base = base as @region_scope;\n     binding_rscope { base: base, anon_bindings: @mut 0 }\n }\n impl region_scope for binding_rscope {"}, {"sha": "182cfc43ade9ea3299f7097524deddb41f69497a", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -59,7 +59,7 @@ enum CmdAction {\n \n /// A utility function that hands off a pretty printer to a callback.\n fn with_pp(intr: @token::ident_interner,\n-           cb: &fn(@pprust::ps, io::Writer)) -> ~str {\n+           cb: &fn(@pprust::ps, @io::Writer)) -> ~str {\n     do io::with_str_writer |writer| {\n         let pp = pprust::rust_printer(writer, intr);\n \n@@ -257,7 +257,7 @@ fn get_line(prompt: ~str) -> Option<~str> {\n }\n \n /// Run a command, e.g. :clear, :exit, etc.\n-fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n+fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n            cmd: ~str, args: ~[~str]) -> CmdAction {\n     let mut action = action_none;\n     match cmd {\n@@ -334,7 +334,7 @@ fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n \n /// Executes a line of input, which may either be rust code or a\n /// :command. Returns a new Repl if it has changed.\n-fn run_line(repl: &mut Repl, in: io::Reader, out: io::Writer, line: ~str)\n+fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str)\n     -> Option<Repl> {\n     if line.starts_with(~\":\") {\n         let full = line.substr(1, line.len() - 1);"}, {"sha": "0572cf771dbed4f26a8120e95ea97026dad6e694", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -70,13 +70,14 @@ struct ListenerFn {\n struct ReadyCtx {\n     sess: session::Session,\n     crate: @ast::crate,\n-    ext_cx: ext_ctxt,\n+    ext_cx: @ext_ctxt,\n     path: ~[ast::ident],\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod,\n-            fold: fold::ast_fold) -> ast::_mod {\n+fn fold_mod(_ctx: @mut ReadyCtx,\n+            m: &ast::_mod,\n+            fold: @fold::ast_fold) -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: do item.attrs.filtered |attr| {\n@@ -94,9 +95,9 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod,\n     }, fold)\n }\n \n-fn fold_item(ctx: @mut ReadyCtx, item: @ast::item,\n-             fold: fold::ast_fold) -> Option<@ast::item> {\n-\n+fn fold_item(ctx: @mut ReadyCtx,\n+             item: @ast::item,\n+             fold: @fold::ast_fold) -> Option<@ast::item> {\n     ctx.path.push(item.ident);\n \n     let attrs = attr::find_attrs_by_name(item.attrs, ~\"pkg_do\");"}, {"sha": "9cf2d145eacb46730694853a922e75f94b339413", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -1424,7 +1424,7 @@ mod tests {\n         fail_unless!(a.capacity() == uint::bits);\n     }\n \n-    fn rng() -> rand::Rng {\n+    fn rng() -> @rand::Rng {\n         let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::seeded_rng(seed)\n     }"}, {"sha": "4ab119abf1c94b093459f7816d6c4ce1fc65acdb", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -415,11 +415,11 @@ pub mod writer {\n \n     // ebml writing\n     pub struct Encoder {\n-        writer: io::Writer,\n+        writer: @io::Writer,\n         priv mut size_positions: ~[uint],\n     }\n \n-    fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n+    fn write_sized_vuint(w: @io::Writer, n: uint, size: uint) {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),\n             2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n@@ -431,15 +431,15 @@ pub mod writer {\n         };\n     }\n \n-    fn write_vuint(w: io::Writer, n: uint) {\n+    fn write_vuint(w: @io::Writer, n: uint) {\n         if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n         if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n         if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n         if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n         fail!(fmt!(\"vint to write too big: %?\", n));\n     }\n \n-    pub fn Encoder(w: io::Writer) -> Encoder {\n+    pub fn Encoder(w: @io::Writer) -> Encoder {\n         let size_positions: ~[uint] = ~[];\n         Encoder { writer: w, mut size_positions: size_positions }\n     }"}, {"sha": "e2e09f1d6750a273015ff80b6de62b344103a022", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -459,15 +459,15 @@ pub mod flatteners {\n     }\n \n     pub trait FromReader {\n-        static fn from_reader(r: Reader) -> Self;\n+        static fn from_reader(r: @Reader) -> Self;\n     }\n \n     pub trait FromWriter {\n-        static fn from_writer(w: Writer) -> Self;\n+        static fn from_writer(w: @Writer) -> Self;\n     }\n \n     impl FromReader for json::Decoder/&self {\n-        static fn from_reader(r: Reader) -> json::Decoder/&self {\n+        static fn from_reader(r: @Reader) -> json::Decoder/&self {\n             match json::from_reader(r) {\n                 Ok(json) => {\n                     json::Decoder(json)\n@@ -478,21 +478,21 @@ pub mod flatteners {\n     }\n \n     impl FromWriter for json::Encoder {\n-        static fn from_writer(w: Writer) -> json::Encoder {\n+        static fn from_writer(w: @Writer) -> json::Encoder {\n             json::Encoder(w)\n         }\n     }\n \n     impl FromReader for ebml::reader::Decoder {\n-        static fn from_reader(r: Reader) -> ebml::reader::Decoder {\n+        static fn from_reader(r: @Reader) -> ebml::reader::Decoder {\n             let buf = @r.read_whole_stream();\n             let doc = ebml::reader::Doc(buf);\n             ebml::reader::Decoder(doc)\n         }\n     }\n \n     impl FromWriter for ebml::writer::Encoder {\n-        static fn from_writer(w: Writer) -> ebml::writer::Encoder {\n+        static fn from_writer(w: @Writer) -> ebml::writer::Encoder {\n             ebml::writer::Encoder(w)\n         }\n     }"}, {"sha": "56f2611c914471ee2bf362705a0fa12dc0350e06", "filename": "src/libstd/json.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -74,10 +74,10 @@ fn spaces(n: uint) -> ~str {\n }\n \n pub struct Encoder {\n-    priv wr: io::Writer,\n+    priv wr: @io::Writer,\n }\n \n-pub fn Encoder(wr: io::Writer) -> Encoder {\n+pub fn Encoder(wr: @io::Writer) -> Encoder {\n     Encoder { wr: wr }\n }\n \n@@ -208,11 +208,11 @@ impl serialize::Encoder for Encoder {\n }\n \n pub struct PrettyEncoder {\n-    priv wr: io::Writer,\n+    priv wr: @io::Writer,\n     priv mut indent: uint,\n }\n \n-pub fn PrettyEncoder(wr: io::Writer) -> PrettyEncoder {\n+pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n     PrettyEncoder { wr: wr, indent: 0 }\n }\n \n@@ -346,7 +346,7 @@ impl<S:serialize::Encoder> serialize::Encodable<S> for Json {\n }\n \n /// Encodes a json value into a io::writer\n-pub fn to_writer(wr: io::Writer, json: &Json) {\n+pub fn to_writer(wr: @io::Writer, json: &Json) {\n     json.encode(&Encoder(wr))\n }\n \n@@ -359,7 +359,7 @@ pub pure fn to_str(json: &Json) -> ~str {\n }\n \n /// Encodes a json value into a io::writer\n-pub fn to_pretty_writer(wr: io::Writer, json: &Json) {\n+pub fn to_pretty_writer(wr: @io::Writer, json: &Json) {\n     json.encode(&PrettyEncoder(wr))\n }\n \n@@ -369,14 +369,14 @@ pub fn to_pretty_str(json: &Json) -> ~str {\n }\n \n pub struct Parser {\n-    priv rdr: io::Reader,\n+    priv rdr: @io::Reader,\n     priv mut ch: char,\n     priv mut line: uint,\n     priv mut col: uint,\n }\n \n /// Decode a json value from an io::reader\n-pub fn Parser(rdr: io::Reader) -> Parser {\n+pub fn Parser(rdr: @io::Reader) -> Parser {\n     Parser {\n         rdr: rdr,\n         ch: rdr.read_char(),\n@@ -734,8 +734,8 @@ priv impl Parser {\n     }\n }\n \n-/// Decodes a json value from an io::reader\n-pub fn from_reader(rdr: io::Reader) -> Result<Json, Error> {\n+/// Decodes a json value from an @io::Reader\n+pub fn from_reader(rdr: @io::Reader) -> Result<Json, Error> {\n     Parser(rdr).parse()\n }\n "}, {"sha": "54fbae956ce5c01f893e1d726c021363bac71da6", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -1799,7 +1799,7 @@ pub mod test {\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n \n-        let buf_reader = sock_buf as Reader;\n+        let buf_reader = sock_buf as @Reader;\n         let actual_response = str::from_bytes(buf_reader.read_whole_stream());\n         debug!(\"Actual response: %s\", actual_response);\n         fail_unless!(expected_resp == actual_response);"}, {"sha": "6a234b9dc9bea514728d29562ed9c40532b6a6dc", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -326,7 +326,7 @@ pub mod chained {\n     }\n \n     pub impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> T<K, V> {\n-        fn to_writer(&self, wr: io::Writer) {\n+        fn to_writer(&self, wr: @io::Writer) {\n             if self.count == 0u {\n                 wr.write_str(~\"{}\");\n                 return;"}, {"sha": "f823d73cf0bfffed435a4b296d7747ff6da600cf", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -14,10 +14,10 @@ use core::io::WriterUtil;\n use core::io;\n \n pub struct Serializer {\n-    wr: io::Writer,\n+    wr: @io::Writer,\n }\n \n-pub fn Serializer(wr: io::Writer) -> Serializer {\n+pub fn Serializer(wr: @io::Writer) -> Serializer {\n     Serializer { wr: wr }\n }\n "}, {"sha": "85996c8ac4ad46852785c511796579135209a38d", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -138,7 +138,7 @@ condition! {\n     bad_parse: () -> ();\n }\n \n-fn take_nonempty_prefix(rdr: io::Reader,\n+fn take_nonempty_prefix(rdr: @io::Reader,\n                         ch: char,\n                         pred: &fn(char) -> bool) -> (~str, char) {\n     let mut buf = ~\"\";\n@@ -154,15 +154,15 @@ fn take_nonempty_prefix(rdr: io::Reader,\n     (buf, ch)\n }\n \n-fn take_num(rdr: io::Reader, ch: char) -> (uint, char) {\n+fn take_num(rdr: @io::Reader, ch: char) -> (uint, char) {\n     let (s, ch) = take_nonempty_prefix(rdr, ch, char::is_digit);\n     match uint::from_str(s) {\n         None => { bad_parse::cond.raise(()); (0, ch) },\n         Some(i) => (i, ch)\n     }\n }\n \n-fn take_ident(rdr: io::Reader, ch: char) -> (Identifier, char) {\n+fn take_ident(rdr: @io::Reader, ch: char) -> (Identifier, char) {\n     let (s,ch) = take_nonempty_prefix(rdr, ch, char::is_alphanumeric);\n     if s.all(char::is_digit) {\n         match uint::from_str(s) {\n@@ -180,8 +180,7 @@ fn expect(ch: char, c: char) {\n     }\n }\n \n-fn parse_reader(rdr: io::Reader) -> Version {\n-\n+fn parse_reader(rdr: @io::Reader) -> Version {\n     let (major, ch) = take_num(rdr, rdr.read_char());\n     expect(ch, '.');\n     let (minor, ch) = take_num(rdr, rdr.read_char());"}, {"sha": "e0828d981d7254dc01ce81d4935f341b59fad48e", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -893,6 +893,7 @@ mod test_tim_sort {\n \n     use sort::tim_sort;\n \n+    use core::rand::RngUtil;\n     use core::rand;\n     use core::vec;\n \n@@ -990,6 +991,7 @@ mod big_tests {\n \n     use sort::*;\n \n+    use core::rand::RngUtil;\n     use core::rand;\n     use core::task;\n     use core::uint;"}, {"sha": "7704ec158e56545b91b7926d0b7fca9d4090b08d", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -12,6 +12,7 @@\n \n use core::os;\n use core::prelude::*;\n+use core::rand::RngUtil;\n use core::rand;\n \n pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {"}, {"sha": "2a8c8b3b06bbdf676ce3a06418bd7b4c093377f7", "filename": "src/libstd/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -36,10 +36,10 @@ pub const color_bright_magenta: u8 = 13u8;\n pub const color_bright_cyan: u8 = 14u8;\n pub const color_bright_white: u8 = 15u8;\n \n-pub fn esc(writer: io::Writer) { writer.write(~[0x1bu8, '[' as u8]); }\n+pub fn esc(writer: @io::Writer) { writer.write(~[0x1bu8, '[' as u8]); }\n \n /// Reset the foreground and background colors to default\n-pub fn reset(writer: io::Writer) {\n+pub fn reset(writer: @io::Writer) {\n     esc(writer);\n     writer.write(~['0' as u8, 'm' as u8]);\n }\n@@ -59,7 +59,7 @@ pub fn color_supported() -> bool {\n         };\n }\n \n-pub fn set_color(writer: io::Writer, first_char: u8, color: u8) {\n+pub fn set_color(writer: @io::Writer, first_char: u8, color: u8) {\n     fail_unless!((color < 16u8));\n     esc(writer);\n     let mut color = color;\n@@ -68,12 +68,12 @@ pub fn set_color(writer: io::Writer, first_char: u8, color: u8) {\n }\n \n /// Set the foreground color\n-pub fn fg(writer: io::Writer, color: u8) {\n+pub fn fg(writer: @io::Writer, color: u8) {\n     return set_color(writer, '3' as u8, color);\n }\n \n /// Set the background color\n-pub fn bg(writer: io::Writer, color: u8) {\n+pub fn bg(writer: @io::Writer, color: u8) {\n     return set_color(writer, '4' as u8, color);\n }\n "}, {"sha": "cec9f56708f3483ea1b0c828a04b5a6b1810690b", "filename": "src/libstd/test.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -198,8 +198,8 @@ pub struct BenchSamples {\n pub enum TestResult { TrOk, TrFailed, TrIgnored, TrBench(BenchSamples) }\n \n struct ConsoleTestState {\n-    out: io::Writer,\n-    log_out: Option<io::Writer>,\n+    out: @io::Writer,\n+    log_out: Option<@io::Writer>,\n     use_color: bool,\n     mut total: uint,\n     mut passed: uint,\n@@ -316,7 +316,7 @@ pub fn run_tests_console(opts: &TestOpts,\n         }\n     }\n \n-    fn write_log(out: io::Writer, result: TestResult, test: &TestDesc) {\n+    fn write_log(out: @io::Writer, result: TestResult, test: &TestDesc) {\n         out.write_line(fmt!(\"%s %s\",\n                     match result {\n                         TrOk => ~\"ok\",\n@@ -326,23 +326,26 @@ pub fn run_tests_console(opts: &TestOpts,\n                     }, test.name.to_str()));\n     }\n \n-    fn write_ok(out: io::Writer, use_color: bool) {\n+    fn write_ok(out: @io::Writer, use_color: bool) {\n         write_pretty(out, ~\"ok\", term::color_green, use_color);\n     }\n \n-    fn write_failed(out: io::Writer, use_color: bool) {\n+    fn write_failed(out: @io::Writer, use_color: bool) {\n         write_pretty(out, ~\"FAILED\", term::color_red, use_color);\n     }\n \n-    fn write_ignored(out: io::Writer, use_color: bool) {\n+    fn write_ignored(out: @io::Writer, use_color: bool) {\n         write_pretty(out, ~\"ignored\", term::color_yellow, use_color);\n     }\n \n-    fn write_bench(out: io::Writer, use_color: bool) {\n+    fn write_bench(out: @io::Writer, use_color: bool) {\n         write_pretty(out, ~\"bench\", term::color_cyan, use_color);\n     }\n \n-    fn write_pretty(out: io::Writer, word: &str, color: u8, use_color: bool) {\n+    fn write_pretty(out: @io::Writer,\n+                    word: &str,\n+                    color: u8,\n+                    use_color: bool) {\n         if use_color && term::color_supported() {\n             term::fg(out, color);\n         }\n@@ -601,6 +604,7 @@ pub mod bench {\n     use stats::Stats;\n \n     use core::num;\n+    use core::rand::RngUtil;\n     use core::rand;\n     use core::u64;\n     use core::vec;\n@@ -700,7 +704,6 @@ pub mod bench {\n             let mut prev_madp = 0.0;\n \n             loop {\n-\n                 let n_samples = rng.gen_uint_range(50, 60);\n                 let n_iter = rng.gen_uint_range(magnitude,\n                                                 magnitude * 2);"}, {"sha": "d72bfe73dd6660f659c7b9aafc7db73f0c1d84da", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -179,6 +179,7 @@ mod test {\n     use uv;\n \n     use core::iter;\n+    use core::rand::RngUtil;\n     use core::rand;\n     use core::task;\n     use core::pipes::{stream, SharedChan};"}, {"sha": "56ee3bd5893da1a38bd632e543e996f794e08499", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -706,6 +706,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n mod test_treemap {\n     use core::prelude::*;\n     use super::*;\n+    use core::rand::RngUtil;\n     use core::rand;\n \n     #[test]"}, {"sha": "5266d1b049a27fc223ffc1cbe2a3cf9020ee3f44", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -110,7 +110,7 @@ pub struct Ctx {\n     map: @map,\n     path: path,\n     local_id: uint,\n-    diag: span_handler,\n+    diag: @span_handler,\n }\n \n pub type vt = visit::vt<@mut Ctx>;\n@@ -132,7 +132,7 @@ pub fn mk_ast_map_visitor() -> vt {\n     });\n }\n \n-pub fn map_crate(diag: span_handler, c: crate) -> map {\n+pub fn map_crate(diag: @span_handler, c: crate) -> map {\n     let cx = @mut Ctx {\n         map: @std::oldmap::HashMap(),\n         path: ~[],\n@@ -146,7 +146,7 @@ pub fn map_crate(diag: span_handler, c: crate) -> map {\n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-pub fn map_decoded_item(diag: span_handler,\n+pub fn map_decoded_item(diag: @span_handler,\n                         map: map,\n                         +path: path,\n                         ii: inlined_item) {"}, {"sha": "a410d6cf8e3a241cf0eb383092067b0354f645f1", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -360,7 +360,7 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n }\n \n \n-pub fn require_unique_names(diagnostic: span_handler,\n+pub fn require_unique_names(diagnostic: @span_handler,\n                             metas: &[@ast::meta_item]) {\n     let mut set = LinearSet::new();\n     for metas.each |meta| {"}, {"sha": "93d28f31c8db424f78bf7e059adf37aea27fe598", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -55,7 +55,7 @@ pub trait span_handler {\n     fn span_note(@mut self, sp: span, msg: &str);\n     fn span_bug(@mut self, sp: span, msg: &str) -> !;\n     fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n-    fn handler(@mut self) -> handler;\n+    fn handler(@mut self) -> @handler;\n }\n \n struct HandlerT {\n@@ -64,7 +64,7 @@ struct HandlerT {\n }\n \n struct CodemapT {\n-    handler: handler,\n+    handler: @handler,\n     cm: @codemap::CodeMap,\n }\n \n@@ -89,7 +89,7 @@ impl span_handler for CodemapT {\n     fn span_unimpl(@mut self, sp: span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    fn handler(@mut self) -> handler {\n+    fn handler(@mut self) -> @handler {\n         self.handler\n     }\n }\n@@ -143,8 +143,8 @@ pub fn ice_msg(msg: &str) -> ~str {\n     fmt!(\"internal compiler error: %s\", msg)\n }\n \n-pub fn mk_span_handler(handler: handler, cm: @codemap::CodeMap)\n-                    -> span_handler {\n+pub fn mk_span_handler(handler: @handler, cm: @codemap::CodeMap)\n+                    -> @span_handler {\n     @mut CodemapT { handler: handler, cm: cm } as @span_handler\n }\n \n@@ -304,7 +304,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     }\n }\n \n-pub fn expect<T:Copy>(diag: span_handler,\n+pub fn expect<T:Copy>(diag: @span_handler,\n                        opt: Option<T>,\n                        msg: &fn() -> ~str) -> T {\n     match opt {"}, {"sha": "4f2fd68ff95679a428fd4e4fb0d15a9cfa2b0c7d", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -41,10 +41,10 @@ fn next_state(s: State) -> Option<State> {\n     }\n }\n \n-pub fn expand_asm(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n-    -> base::MacResult {\n-\n-    let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(),\n+pub fn expand_asm(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+               -> base::MacResult {\n+    let p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                       cx.cfg(),\n                                        vec::from_slice(tts));\n \n     let mut asm = ~\"\";"}, {"sha": "8c02b4323715d40b062f316acedeae1d6edd70fc", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -110,7 +110,7 @@ mod syntax {\n }\n \n pub fn expand_auto_encode(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]\n@@ -165,7 +165,7 @@ pub fn expand_auto_encode(\n }\n \n pub fn expand_auto_decode(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]\n@@ -219,7 +219,7 @@ pub fn expand_auto_decode(\n     }\n }\n \n-priv impl ext_ctxt {\n+priv impl @ext_ctxt {\n     fn bind_path(\n         &self,\n         span: span,\n@@ -426,7 +426,7 @@ priv impl ext_ctxt {\n }\n \n fn mk_impl(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     ty_param: ast::TyParam,\n@@ -499,7 +499,7 @@ fn mk_impl(\n }\n \n fn mk_ser_impl(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     generics: &ast::Generics,\n@@ -543,7 +543,7 @@ fn mk_ser_impl(\n }\n \n fn mk_deser_impl(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     generics: &ast::Generics,\n@@ -587,7 +587,7 @@ fn mk_deser_impl(\n }\n \n fn mk_ser_method(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     +ser_body: ast::blk\n ) -> @ast::method {\n@@ -647,7 +647,7 @@ fn mk_ser_method(\n }\n \n fn mk_deser_method(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     ty: @ast::Ty,\n     +deser_body: ast::blk\n@@ -701,7 +701,7 @@ fn mk_deser_method(\n }\n \n fn mk_struct_ser_impl(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     fields: &[@ast::struct_field],\n@@ -762,7 +762,7 @@ fn mk_struct_ser_impl(\n }\n \n fn mk_struct_deser_impl(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     fields: ~[@ast::struct_field],\n@@ -866,7 +866,7 @@ fn mk_struct_fields(fields: &[@ast::struct_field]) -> ~[field] {\n }\n \n fn mk_enum_ser_impl(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     +enum_def: ast::enum_def,\n@@ -883,7 +883,7 @@ fn mk_enum_ser_impl(\n }\n \n fn mk_enum_deser_impl(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n     +enum_def: ast::enum_def,\n@@ -900,7 +900,7 @@ fn mk_enum_deser_impl(\n }\n \n fn ser_variant(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     v_name: ast::ident,\n     v_idx: uint,\n@@ -982,7 +982,7 @@ fn ser_variant(\n }\n \n fn mk_enum_ser_body(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     name: ast::ident,\n     +variants: ~[ast::variant]\n@@ -1032,7 +1032,7 @@ fn mk_enum_ser_body(\n }\n \n fn mk_enum_deser_variant_nary(\n-    cx: ext_ctxt,\n+    cx: @ext_ctxt,\n     span: span,\n     name: ast::ident,\n     args: ~[ast::variant_arg]\n@@ -1069,7 +1069,7 @@ fn mk_enum_deser_variant_nary(\n }\n \n fn mk_enum_deser_body(\n-    ext_cx: ext_ctxt,\n+    ext_cx: @ext_ctxt,\n     span: span,\n     name: ast::ident,\n     variants: ~[ast::variant]"}, {"sha": "f0822ea4d256a6225bff857074b417c85c527184", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -36,7 +36,7 @@ pub struct MacroDef {\n     ext: SyntaxExtension\n }\n \n-pub type ItemDecorator = @fn(ext_ctxt,\n+pub type ItemDecorator = @fn(@ext_ctxt,\n                              span,\n                              @ast::meta_item,\n                              ~[@ast::item])\n@@ -47,7 +47,7 @@ pub struct SyntaxExpanderTT {\n     span: Option<span>\n }\n \n-pub type SyntaxExpanderTTFun = @fn(ext_ctxt,\n+pub type SyntaxExpanderTTFun = @fn(@ext_ctxt,\n                                    span,\n                                    &[ast::token_tree])\n                                 -> MacResult;\n@@ -57,7 +57,7 @@ pub struct SyntaxExpanderTTItem {\n     span: Option<span>\n }\n \n-pub type SyntaxExpanderTTItemFun = @fn(ext_ctxt,\n+pub type SyntaxExpanderTTItemFun = @fn(@ext_ctxt,\n                                        span,\n                                        ast::ident,\n                                        ~[ast::token_tree])\n@@ -238,8 +238,8 @@ pub trait ext_ctxt {\n     fn ident_of(@mut self, st: ~str) -> ast::ident;\n }\n \n-pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n-               +cfg: ast::crate_cfg) -> ext_ctxt {\n+pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, +cfg: ast::crate_cfg)\n+            -> @ext_ctxt {\n     struct CtxtRepr {\n         parse_sess: @mut parse::ParseSess,\n         cfg: ast::crate_cfg,\n@@ -333,7 +333,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess,\n     ((imp) as @ext_ctxt)\n }\n \n-pub fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n+pub fn expr_to_str(cx: @ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n         ast::lit_str(s) => copy *s,\n@@ -343,7 +343,7 @@ pub fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     }\n }\n \n-pub fn expr_to_ident(cx: ext_ctxt,\n+pub fn expr_to_ident(cx: @ext_ctxt,\n                      expr: @ast::expr,\n                      err_msg: ~str) -> ast::ident {\n     match expr.node {\n@@ -357,14 +357,14 @@ pub fn expr_to_ident(cx: ext_ctxt,\n     }\n }\n \n-pub fn check_zero_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree],\n+pub fn check_zero_tts(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree],\n                       name: &str) {\n     if tts.len() != 0 {\n         cx.span_fatal(sp, fmt!(\"%s takes no arguments\", name));\n     }\n }\n \n-pub fn get_single_str_from_tts(cx: ext_ctxt,\n+pub fn get_single_str_from_tts(cx: @ext_ctxt,\n                                sp: span,\n                                tts: &[ast::token_tree],\n                                name: &str) -> ~str {\n@@ -379,7 +379,7 @@ pub fn get_single_str_from_tts(cx: ext_ctxt,\n     }\n }\n \n-pub fn get_exprs_from_tts(cx: ext_ctxt, tts: &[ast::token_tree])\n+pub fn get_exprs_from_tts(cx: @ext_ctxt, tts: &[ast::token_tree])\n                        -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),"}, {"sha": "18c7cd3f86138033dbac207e74db1a09741b0aad", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -25,7 +25,7 @@ pub struct Field {\n     ex: @ast::expr\n }\n \n-pub fn mk_expr(cx: ext_ctxt,\n+pub fn mk_expr(cx: @ext_ctxt,\n                sp: codemap::span,\n                +expr: ast::expr_)\n             -> @ast::expr {\n@@ -37,28 +37,28 @@ pub fn mk_expr(cx: ext_ctxt,\n     }\n }\n \n-pub fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n+pub fn mk_lit(cx: @ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n     let sp_lit = @codemap::spanned { node: lit, span: sp };\n     mk_expr(cx, sp, ast::expr_lit(sp_lit))\n }\n-pub fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n+pub fn mk_int(cx: @ext_ctxt, sp: span, i: int) -> @ast::expr {\n     let lit = ast::lit_int(i as i64, ast::ty_i);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n+pub fn mk_uint(cx: @ext_ctxt, sp: span, u: uint) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_u8(cx: ext_ctxt, sp: span, u: u8) -> @ast::expr {\n+pub fn mk_u8(cx: @ext_ctxt, sp: span, u: u8) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u8);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_binary(cx: ext_ctxt, sp: span, op: ast::binop,\n+pub fn mk_binary(cx: @ext_ctxt, sp: span, op: ast::binop,\n                  lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_binary(op, lhs, rhs))\n }\n-pub fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n+pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n              -> @ast::expr {\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n@@ -88,69 +88,70 @@ pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::path {\n                  rp: None,\n                  types: ~[] }\n }\n-pub fn mk_path(cx: ext_ctxt, sp: span, +idents: ~[ast::ident]) -> @ast::expr {\n+pub fn mk_path(cx: @ext_ctxt, sp: span, +idents: ~[ast::ident])\n+            -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path(sp, idents)))\n }\n-pub fn mk_path_global(cx: ext_ctxt, sp: span, +idents: ~[ast::ident])\n+pub fn mk_path_global(cx: @ext_ctxt, sp: span, +idents: ~[ast::ident])\n                    -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(mk_raw_path_global(sp, idents)))\n }\n-pub fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n+pub fn mk_access_(cx: @ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n                -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n }\n-pub fn mk_access(cx: ext_ctxt, sp: span, +p: ~[ast::ident], m: ast::ident)\n+pub fn mk_access(cx: @ext_ctxt, sp: span, +p: ~[ast::ident], m: ast::ident)\n               -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n     return mk_access_(cx, sp, pathexpr, m);\n }\n-pub fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n }\n-pub fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n+pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n                 +args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n }\n-pub fn mk_call(cx: ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n+pub fn mk_call(cx: @ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n                +args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n-pub fn mk_call_global(cx: ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n+pub fn mk_call_global(cx: @ext_ctxt, sp: span, +fn_path: ~[ast::ident],\n                       +args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path_global(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n-pub fn mk_base_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_base_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     mk_expr(cx, sp, vecexpr)\n }\n-pub fn mk_vstore_e(cx: ext_ctxt, sp: span, expr: @ast::expr,\n+pub fn mk_vstore_e(cx: @ext_ctxt, sp: span, expr: @ast::expr,\n                    vst: ast::expr_vstore) ->\n    @ast::expr {\n     mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n }\n-pub fn mk_uniq_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_uniq_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n }\n-pub fn mk_slice_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_slice_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_slice)\n }\n-pub fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n+pub fn mk_fixed_vec_e(cx: @ext_ctxt, sp: span, +exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_fixed(None))\n }\n-pub fn mk_base_str(cx: ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n+pub fn mk_base_str(cx: @ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_uniq_str(cx: ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n+pub fn mk_uniq_str(cx: @ext_ctxt, sp: span, +s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n pub fn mk_field(sp: span, f: &Field) -> ast::field {\n@@ -162,7 +163,7 @@ pub fn mk_field(sp: span, f: &Field) -> ast::field {\n pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n     fields.map(|f| mk_field(sp, f))\n }\n-pub fn mk_struct_e(cx: ext_ctxt,\n+pub fn mk_struct_e(cx: @ext_ctxt,\n                    sp: span,\n                    +ctor_path: ~[ast::ident],\n                    +fields: ~[Field])\n@@ -172,7 +173,7 @@ pub fn mk_struct_e(cx: ext_ctxt,\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_global_struct_e(cx: ext_ctxt,\n+pub fn mk_global_struct_e(cx: @ext_ctxt,\n                           sp: span,\n                           +ctor_path: ~[ast::ident],\n                           +fields: ~[Field])\n@@ -182,7 +183,7 @@ pub fn mk_global_struct_e(cx: ext_ctxt,\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_glob_use(cx: ext_ctxt,\n+pub fn mk_glob_use(cx: @ext_ctxt,\n                    sp: span,\n                    +path: ~[ast::ident]) -> @ast::view_item {\n     let glob = @codemap::spanned {\n@@ -194,7 +195,7 @@ pub fn mk_glob_use(cx: ext_ctxt,\n                       vis: ast::private,\n                       span: sp }\n }\n-pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n+pub fn mk_local(cx: @ext_ctxt, sp: span, mutbl: bool,\n                 ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n \n     let pat = @ast::pat {\n@@ -219,7 +220,7 @@ pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n     let decl = codemap::spanned {node: ast::decl_local(~[local]), span: sp};\n     @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n-pub fn mk_block(cx: ext_ctxt, span: span,\n+pub fn mk_block(cx: @ext_ctxt, span: span,\n                 +view_items: ~[@ast::view_item],\n                 +stmts: ~[@ast::stmt],\n                 expr: Option<@ast::expr>) -> @ast::expr {\n@@ -235,7 +236,7 @@ pub fn mk_block(cx: ext_ctxt, span: span,\n     };\n     mk_expr(cx, span, ast::expr_block(blk))\n }\n-pub fn mk_block_(cx: ext_ctxt,\n+pub fn mk_block_(cx: @ext_ctxt,\n                  span: span,\n                  +stmts: ~[@ast::stmt])\n               -> ast::blk {\n@@ -250,7 +251,7 @@ pub fn mk_block_(cx: ext_ctxt,\n         span: span,\n     }\n }\n-pub fn mk_simple_block(cx: ext_ctxt,\n+pub fn mk_simple_block(cx: @ext_ctxt,\n                        span: span,\n                        expr: @ast::expr)\n                     -> ast::blk {\n@@ -265,55 +266,55 @@ pub fn mk_simple_block(cx: ext_ctxt,\n         span: span,\n     }\n }\n-pub fn mk_copy(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_copy(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n }\n-pub fn mk_managed(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_managed(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n-pub fn mk_pat(cx: ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n+pub fn mk_pat(cx: @ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n     @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n-pub fn mk_pat_ident(cx: ext_ctxt,\n+pub fn mk_pat_ident(cx: @ext_ctxt,\n                     span: span,\n                     ident: ast::ident) -> @ast::pat {\n     mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_copy)\n }\n-pub fn mk_pat_ident_with_binding_mode(cx: ext_ctxt,\n+pub fn mk_pat_ident_with_binding_mode(cx: @ext_ctxt,\n                                       span: span,\n                                       ident: ast::ident,\n                                       bm: ast::binding_mode) -> @ast::pat {\n     let path = mk_raw_path(span, ~[ ident ]);\n     let pat = ast::pat_ident(bm, path, None);\n     mk_pat(cx, span, pat)\n }\n-pub fn mk_pat_enum(cx: ext_ctxt,\n+pub fn mk_pat_enum(cx: @ext_ctxt,\n                    span: span,\n                    path: @ast::path,\n                    +subpats: ~[@ast::pat])\n                 -> @ast::pat {\n     let pat = ast::pat_enum(path, Some(subpats));\n     mk_pat(cx, span, pat)\n }\n-pub fn mk_pat_struct(cx: ext_ctxt,\n+pub fn mk_pat_struct(cx: @ext_ctxt,\n                      span: span,\n                      path: @ast::path,\n                      +field_pats: ~[ast::field_pat])\n                   -> @ast::pat {\n     let pat = ast::pat_struct(path, field_pats, false);\n     mk_pat(cx, span, pat)\n }\n-pub fn mk_bool(cx: ext_ctxt, span: span, value: bool) -> @ast::expr {\n+pub fn mk_bool(cx: @ext_ctxt, span: span, value: bool) -> @ast::expr {\n     let lit_expr = ast::expr_lit(@codemap::spanned {\n         node: ast::lit_bool(value),\n         span: span });\n     build::mk_expr(cx, span, lit_expr)\n }\n-pub fn mk_stmt(cx: ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n+pub fn mk_stmt(cx: @ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n     @codemap::spanned { node: stmt_, span: span }\n }\n-pub fn mk_ty_path(cx: ext_ctxt,\n+pub fn mk_ty_path(cx: @ext_ctxt,\n                   span: span,\n                   +idents: ~[ ast::ident ])\n                -> @ast::Ty {\n@@ -322,7 +323,7 @@ pub fn mk_ty_path(cx: ext_ctxt,\n     let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n-pub fn mk_ty_path_global(cx: ext_ctxt,\n+pub fn mk_ty_path_global(cx: @ext_ctxt,\n                          span: span,\n                          +idents: ~[ ast::ident ])\n                       -> @ast::Ty {\n@@ -331,13 +332,13 @@ pub fn mk_ty_path_global(cx: ext_ctxt,\n     let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n-pub fn mk_simple_ty_path(cx: ext_ctxt,\n+pub fn mk_simple_ty_path(cx: @ext_ctxt,\n                          span: span,\n                          ident: ast::ident)\n                       -> @ast::Ty {\n     mk_ty_path(cx, span, ~[ ident ])\n }\n-pub fn mk_arg(cx: ext_ctxt,\n+pub fn mk_arg(cx: @ext_ctxt,\n               span: span,\n               ident: ast::ident,\n               ty: @ast::Ty)\n@@ -354,13 +355,13 @@ pub fn mk_arg(cx: ext_ctxt,\n pub fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n     ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n }\n-pub fn mk_ty_param(cx: ext_ctxt,\n+pub fn mk_ty_param(cx: @ext_ctxt,\n                    ident: ast::ident,\n                    bounds: @OptVec<ast::TyParamBound>)\n                 -> ast::TyParam {\n     ast::TyParam { ident: ident, id: cx.next_id(), bounds: bounds }\n }\n-pub fn mk_lifetime(cx: ext_ctxt,\n+pub fn mk_lifetime(cx: @ext_ctxt,\n                    span: span,\n                    ident: ast::ident) -> ast::Lifetime\n {"}, {"sha": "0c3bef56459b52ed2fe36834560981744dbf8a93", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -16,7 +16,7 @@ use ext::base::*;\n use ext::base;\n use parse::token;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for tts.eachi |i, e| {"}, {"sha": "26b5b4566b7f7494f62e0349c2639f35b87cd30d", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -45,18 +45,18 @@ pub impl Junction {\n     }\n }\n \n-type ExpandDerivingStructDefFn = &self/fn(ext_ctxt,\n+type ExpandDerivingStructDefFn = &self/fn(@ext_ctxt,\n                                           span,\n                                           x: &struct_def,\n                                           ident,\n                                           y: &Generics) -> @item;\n-type ExpandDerivingEnumDefFn = &self/fn(ext_ctxt,\n+type ExpandDerivingEnumDefFn = &self/fn(@ext_ctxt,\n                                         span,\n                                         x: &enum_def,\n                                         ident,\n                                         y: &Generics) -> @item;\n \n-pub fn expand_meta_deriving(cx: ext_ctxt,\n+pub fn expand_meta_deriving(cx: @ext_ctxt,\n                             _span: span,\n                             mitem: @meta_item,\n                             in_items: ~[@item])\n@@ -98,7 +98,7 @@ pub fn expand_meta_deriving(cx: ext_ctxt,\n     }\n }\n \n-pub fn expand_deriving_eq(cx: ext_ctxt,\n+pub fn expand_deriving_eq(cx: @ext_ctxt,\n                           span: span,\n                           _mitem: @meta_item,\n                           in_items: ~[@item])\n@@ -110,7 +110,7 @@ pub fn expand_deriving_eq(cx: ext_ctxt,\n                     expand_deriving_eq_enum_def)\n }\n \n-pub fn expand_deriving_iter_bytes(cx: ext_ctxt,\n+pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n                                   span: span,\n                                   _mitem: @meta_item,\n                                   in_items: ~[@item])\n@@ -122,7 +122,7 @@ pub fn expand_deriving_iter_bytes(cx: ext_ctxt,\n                     expand_deriving_iter_bytes_enum_def)\n }\n \n-pub fn expand_deriving_clone(cx: ext_ctxt,\n+pub fn expand_deriving_clone(cx: @ext_ctxt,\n                              span: span,\n                              _: @meta_item,\n                              in_items: ~[@item])\n@@ -134,7 +134,7 @@ pub fn expand_deriving_clone(cx: ext_ctxt,\n                     expand_deriving_clone_enum_def)\n }\n \n-fn expand_deriving(cx: ext_ctxt,\n+fn expand_deriving(cx: @ext_ctxt,\n                    span: span,\n                    in_items: ~[@item],\n                    expand_deriving_struct_def: ExpandDerivingStructDefFn,\n@@ -164,7 +164,7 @@ fn expand_deriving(cx: ext_ctxt,\n     result\n }\n \n-fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n+fn create_impl_item(cx: @ext_ctxt, span: span, +item: item_) -> @item {\n     @ast::item {\n         ident: clownshoes_extensions,\n         attrs: ~[],\n@@ -177,7 +177,7 @@ fn create_impl_item(cx: ext_ctxt, span: span, +item: item_) -> @item {\n \n /// Creates a method from the given expression, the signature of which\n /// conforms to the `eq` or `ne` method.\n-fn create_eq_method(cx: ext_ctxt,\n+fn create_eq_method(cx: @ext_ctxt,\n                     span: span,\n                     method_ident: ident,\n                     type_ident: ident,\n@@ -236,7 +236,7 @@ fn create_eq_method(cx: ext_ctxt,\n     }\n }\n \n-fn create_self_type_with_params(cx: ext_ctxt,\n+fn create_self_type_with_params(cx: @ext_ctxt,\n                                 span: span,\n                                 type_ident: ident,\n                                 generics: &Generics)\n@@ -258,7 +258,7 @@ fn create_self_type_with_params(cx: ext_ctxt,\n     @ast::Ty { id: cx.next_id(), node: self_type, span: span }\n }\n \n-fn create_derived_impl(cx: ext_ctxt,\n+fn create_derived_impl(cx: @ext_ctxt,\n                        span: span,\n                        type_ident: ident,\n                        generics: &Generics,\n@@ -320,7 +320,7 @@ fn create_derived_impl(cx: ext_ctxt,\n     return create_impl_item(cx, span, impl_item);\n }\n \n-fn create_derived_eq_impl(cx: ext_ctxt,\n+fn create_derived_eq_impl(cx: @ext_ctxt,\n                           span: span,\n                           type_ident: ident,\n                           generics: &Generics,\n@@ -336,7 +336,7 @@ fn create_derived_eq_impl(cx: ext_ctxt,\n     create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n }\n \n-fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n+fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n                                   span: span,\n                                   type_ident: ident,\n                                   generics: &Generics,\n@@ -351,7 +351,7 @@ fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n     create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n }\n \n-fn create_derived_clone_impl(cx: ext_ctxt,\n+fn create_derived_clone_impl(cx: @ext_ctxt,\n                              span: span,\n                              type_ident: ident,\n                              generics: &Generics,\n@@ -368,7 +368,7 @@ fn create_derived_clone_impl(cx: ext_ctxt,\n \n // Creates a method from the given set of statements conforming to the\n // signature of the `iter_bytes` method.\n-fn create_iter_bytes_method(cx: ext_ctxt,\n+fn create_iter_bytes_method(cx: @ext_ctxt,\n                             span: span,\n                             +statements: ~[@stmt])\n                          -> @method {\n@@ -417,7 +417,7 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n \n // Creates a method from the given expression conforming to the signature of\n // the `clone` method.\n-fn create_clone_method(cx: ext_ctxt,\n+fn create_clone_method(cx: @ext_ctxt,\n                        span: span,\n                        +type_ident: ast::ident,\n                        generics: &Generics,\n@@ -467,7 +467,7 @@ fn create_clone_method(cx: ext_ctxt,\n     }\n }\n \n-fn create_subpatterns(cx: ext_ctxt,\n+fn create_subpatterns(cx: @ext_ctxt,\n                       span: span,\n                       prefix: ~str,\n                       n: uint)\n@@ -496,7 +496,7 @@ fn is_struct_tuple(struct_def: &struct_def) -> bool {\n     })\n }\n \n-fn create_enum_variant_pattern(cx: ext_ctxt,\n+fn create_enum_variant_pattern(cx: @ext_ctxt,\n                                span: span,\n                                variant: &variant,\n                                prefix: ~str)\n@@ -542,7 +542,7 @@ fn create_enum_variant_pattern(cx: ext_ctxt,\n     }\n }\n \n-fn call_substructure_eq_method(cx: ext_ctxt,\n+fn call_substructure_eq_method(cx: @ext_ctxt,\n                                span: span,\n                                self_field: @expr,\n                                other_field_ref: @expr,\n@@ -571,7 +571,7 @@ fn call_substructure_eq_method(cx: ext_ctxt,\n     };\n }\n \n-fn finish_eq_chain_expr(cx: ext_ctxt,\n+fn finish_eq_chain_expr(cx: @ext_ctxt,\n                         span: span,\n                         chain_expr: Option<@expr>,\n                         junction: Junction)\n@@ -587,7 +587,7 @@ fn finish_eq_chain_expr(cx: ext_ctxt,\n     }\n }\n \n-fn call_substructure_iter_bytes_method(cx: ext_ctxt,\n+fn call_substructure_iter_bytes_method(cx: @ext_ctxt,\n                                        span: span,\n                                        self_field: @expr)\n                                     -> @stmt {\n@@ -612,7 +612,7 @@ fn call_substructure_iter_bytes_method(cx: ext_ctxt,\n     build::mk_stmt(cx, span, self_call)\n }\n \n-fn call_substructure_clone_method(cx: ext_ctxt,\n+fn call_substructure_clone_method(cx: @ext_ctxt,\n                                   span: span,\n                                   self_field: @expr)\n                                -> @expr {\n@@ -622,7 +622,7 @@ fn call_substructure_clone_method(cx: ext_ctxt,\n     build::mk_call_(cx, span, self_method, ~[])\n }\n \n-fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n+fn variant_arg_count(cx: @ext_ctxt, span: span, variant: &variant) -> uint {\n     match variant.node.kind {\n         tuple_variant_kind(ref args) => args.len(),\n         struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n@@ -632,7 +632,7 @@ fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n     }\n }\n \n-fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n+fn expand_deriving_eq_struct_def(cx: @ext_ctxt,\n                                  span: span,\n                                  struct_def: &struct_def,\n                                  type_ident: ident,\n@@ -672,7 +672,7 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n                                   ne_method);\n }\n \n-fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n+fn expand_deriving_eq_enum_def(cx: @ext_ctxt,\n                                span: span,\n                                enum_definition: &enum_def,\n                                type_ident: ident,\n@@ -705,7 +705,7 @@ fn expand_deriving_eq_enum_def(cx: ext_ctxt,\n                                   ne_method);\n }\n \n-fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n+fn expand_deriving_iter_bytes_struct_def(cx: @ext_ctxt,\n                                          span: span,\n                                          struct_def: &struct_def,\n                                          type_ident: ident,\n@@ -724,7 +724,7 @@ fn expand_deriving_iter_bytes_struct_def(cx: ext_ctxt,\n                                           method);\n }\n \n-fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n+fn expand_deriving_iter_bytes_enum_def(cx: @ext_ctxt,\n                                        span: span,\n                                        enum_definition: &enum_def,\n                                        type_ident: ident,\n@@ -743,7 +743,7 @@ fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n                                           method);\n }\n \n-fn expand_deriving_clone_struct_def(cx: ext_ctxt,\n+fn expand_deriving_clone_struct_def(cx: @ext_ctxt,\n                                     span: span,\n                                     struct_def: &struct_def,\n                                     type_ident: ident,\n@@ -768,7 +768,7 @@ fn expand_deriving_clone_struct_def(cx: ext_ctxt,\n     create_derived_clone_impl(cx, span, type_ident, generics, method)\n }\n \n-fn expand_deriving_clone_enum_def(cx: ext_ctxt,\n+fn expand_deriving_clone_enum_def(cx: @ext_ctxt,\n                                   span: span,\n                                   enum_definition: &enum_def,\n                                   type_ident: ident,\n@@ -785,7 +785,7 @@ fn expand_deriving_clone_enum_def(cx: ext_ctxt,\n     create_derived_clone_impl(cx, span, type_ident, generics, method)\n }\n \n-fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n+fn expand_deriving_eq_struct_method(cx: @ext_ctxt,\n                                     span: span,\n                                     struct_def: &struct_def,\n                                     method_ident: ident,\n@@ -841,7 +841,7 @@ fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n                             body);\n }\n \n-fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n+fn expand_deriving_iter_bytes_struct_method(cx: @ext_ctxt,\n                                             span: span,\n                                             struct_def: &struct_def)\n                                          -> @method {\n@@ -875,7 +875,7 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     return create_iter_bytes_method(cx, span, statements);\n }\n \n-fn expand_deriving_clone_struct_method(cx: ext_ctxt,\n+fn expand_deriving_clone_struct_method(cx: @ext_ctxt,\n                                        span: span,\n                                        struct_def: &struct_def,\n                                        type_ident: ident,\n@@ -918,7 +918,7 @@ fn expand_deriving_clone_struct_method(cx: ext_ctxt,\n     create_clone_method(cx, span, type_ident, generics, struct_literal)\n }\n \n-fn expand_deriving_clone_tuple_struct_method(cx: ext_ctxt,\n+fn expand_deriving_clone_tuple_struct_method(cx: @ext_ctxt,\n                                              span: span,\n                                              struct_def: &struct_def,\n                                              type_ident: ident,\n@@ -962,7 +962,7 @@ fn expand_deriving_clone_tuple_struct_method(cx: ext_ctxt,\n     create_clone_method(cx, span, type_ident, generics, self_match_expr)\n }\n \n-fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n+fn expand_deriving_eq_enum_method(cx: @ext_ctxt,\n                                   span: span,\n                                   enum_definition: &enum_def,\n                                   method_ident: ident,\n@@ -1096,7 +1096,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                             self_match_expr);\n }\n \n-fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n+fn expand_deriving_eq_struct_tuple_method(cx: @ext_ctxt,\n                                           span: span,\n                                           struct_def: &struct_def,\n                                           method_ident: ident,\n@@ -1155,7 +1155,7 @@ fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n         type_ident, generics, self_match_expr)\n }\n \n-fn expand_enum_or_struct_match(cx: ext_ctxt,\n+fn expand_enum_or_struct_match(cx: @ext_ctxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {\n@@ -1166,7 +1166,7 @@ fn expand_enum_or_struct_match(cx: ext_ctxt,\n     build::mk_expr(cx, span, self_match_expr)\n }\n \n-fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n+fn expand_deriving_iter_bytes_enum_method(cx: @ext_ctxt,\n                                           span: span,\n                                           enum_definition: &enum_def)\n                                        -> @method {\n@@ -1221,7 +1221,7 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n     create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n }\n \n-fn expand_deriving_clone_enum_method(cx: ext_ctxt,\n+fn expand_deriving_clone_enum_method(cx: @ext_ctxt,\n                                      span: span,\n                                      enum_definition: &enum_def,\n                                      type_ident: ident,"}, {"sha": "c21a9fa8739ff11197f456024f1eb489527509d4", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -23,7 +23,7 @@ use ext::base::*;\n use ext::base;\n use ext::build::mk_uniq_str;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n \n     let var = get_single_str_from_tts(cx, sp, tts, \"env!\");"}, {"sha": "ec693fa1f087b536ccc7d7e03dabffe9e552b42b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -26,11 +26,11 @@ use core::option;\n use core::vec;\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n-                   cx: ext_ctxt,\n+                   cx: @ext_ctxt,\n                    e: &expr_,\n                    s: span,\n-                   fld: ast_fold,\n-                   orig: @fn(&expr_, span, ast_fold) -> (expr_, span))\n+                   fld: @ast_fold,\n+                   orig: @fn(&expr_, span, @ast_fold) -> (expr_, span))\n                 -> (expr_, span) {\n     match *e {\n         // expr_mac should really be expr_ext or something; it's the\n@@ -112,10 +112,10 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n-                        cx: ext_ctxt,\n+                        cx: @ext_ctxt,\n                         module_: &ast::_mod,\n-                        fld: ast_fold,\n-                        orig: @fn(&ast::_mod, ast_fold) -> ast::_mod)\n+                        fld: @ast_fold,\n+                        orig: @fn(&ast::_mod, @ast_fold) -> ast::_mod)\n                      -> ast::_mod {\n     // Fold the contents first:\n     let module_ = orig(module_, fld);\n@@ -163,10 +163,10 @@ macro_rules! with_exts_frame (\n \n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(extsbox: @mut SyntaxEnv,\n-                   cx: ext_ctxt,\n+                   cx: @ext_ctxt,\n                    it: @ast::item,\n-                   fld: ast_fold,\n-                   orig: @fn(@ast::item, ast_fold) -> Option<@ast::item>)\n+                   fld: @ast_fold,\n+                   orig: @fn(@ast::item, @ast_fold) -> Option<@ast::item>)\n                 -> Option<@ast::item> {\n     // need to do expansion first... it might turn out to be a module.\n     let maybe_it = match it.node {\n@@ -239,9 +239,9 @@ macro_rules! without_macro_scoping(\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n-                       cx: ext_ctxt, &&it: @ast::item,\n-                       fld: ast_fold) -> Option<@ast::item> {\n-\n+                       cx: @ext_ctxt, &&it: @ast::item,\n+                       fld: @ast_fold)\n+                    -> Option<@ast::item> {\n     let (pth, tts) = match it.node {\n         item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n             (pth, copy *tts)\n@@ -307,11 +307,11 @@ pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n \n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n-                   cx: ext_ctxt,\n+                   cx: @ext_ctxt,\n                    s: &stmt_,\n                    sp: span,\n-                   fld: ast_fold,\n-                   orig: @fn(&stmt_, span, ast_fold) -> (stmt_, span))\n+                   fld: @ast_fold,\n+                   orig: @fn(&stmt_, span, @ast_fold) -> (stmt_, span))\n                 -> (stmt_, span) {\n     let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n@@ -373,11 +373,11 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n \n pub fn expand_block(extsbox: @mut SyntaxEnv,\n-                    cx: ext_ctxt,\n+                    cx: @ext_ctxt,\n                     blk: &blk_,\n                     sp: span,\n-                    fld: ast_fold,\n-                    orig: @fn(&blk_, span, ast_fold) -> (blk_, span))\n+                    fld: @ast_fold,\n+                    orig: @fn(&blk_, span, @ast_fold) -> (blk_, span))\n                  -> (blk_, span) {\n     match (*extsbox).find(&@~\" block\") {\n         // no scope limit on macros in this block, no need\n@@ -395,7 +395,7 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n     }\n }\n \n-pub fn new_span(cx: ext_ctxt, sp: span) -> span {\n+pub fn new_span(cx: @ext_ctxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n@@ -488,7 +488,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // every method/element of AstFoldFns in fold.rs.\n     let extsbox = @mut syntax_expander_table();\n     let afp = default_ast_fold();\n-    let cx: ext_ctxt = mk_ctxt(parse_sess, copy cfg);\n+    let cx: @ext_ctxt = mk_ctxt(parse_sess, copy cfg);\n     let f_pre = @AstFoldFns {\n         fold_expr: |expr,span,recur|\n             expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),"}, {"sha": "f6a6ddefb7efc4663e313eee694f0eeccab6e886", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -27,7 +27,7 @@ use ext::build::*;\n \n use core::unstable::extfmt::ct::*;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let args = get_exprs_from_tts(cx, tts);\n     if args.len() == 0 {\n@@ -38,7 +38,7 @@ pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n                     ~\"first argument to fmt! must be a string literal.\");\n     let fmtspan = args[0].span;\n     debug!(\"Format string: %s\", fmt);\n-    fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: &str) -> ! {\n+    fn parse_fmt_err_(cx: @ext_ctxt, sp: span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n     let parse_fmt_err: @fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n@@ -50,23 +50,23 @@ pub fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n // probably be factored out in common with other code that builds\n // expressions.  Also: Cleanup the naming of these functions.\n // Note: Moved many of the common ones to build.rs --kevina\n-fn pieces_to_expr(cx: ext_ctxt, sp: span,\n+fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n-    fn make_path_vec(cx: ext_ctxt, ident: @~str) -> ~[ast::ident] {\n+    fn make_path_vec(cx: @ext_ctxt, ident: @~str) -> ~[ast::ident] {\n         let intr = cx.parse_sess().interner;\n         return ~[intr.intern(@~\"unstable\"), intr.intern(@~\"extfmt\"),\n                  intr.intern(@~\"rt\"), intr.intern(ident)];\n     }\n-    fn make_rt_path_expr(cx: ext_ctxt, sp: span, nm: @~str) -> @ast::expr {\n+    fn make_rt_path_expr(cx: @ext_ctxt, sp: span, nm: @~str) -> @ast::expr {\n         let path = make_path_vec(cx, nm);\n         return mk_path_global(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: Conv) -> @ast::expr {\n-        fn make_flags(cx: ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: Conv) -> @ast::expr {\n+        fn make_flags(cx: @ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n             for flags.each |f| {\n                 let fstr = match *f {\n@@ -81,7 +81,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             }\n             return tmp_expr;\n         }\n-        fn make_count(cx: ext_ctxt, sp: span, cnt: Count) -> @ast::expr {\n+        fn make_count(cx: @ext_ctxt, sp: span, cnt: Count) -> @ast::expr {\n             match cnt {\n               CountImplied => {\n                 return make_rt_path_expr(cx, sp, @~\"CountImplied\");\n@@ -95,7 +95,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n               _ => cx.span_unimpl(sp, ~\"unimplemented fmt! conversion\")\n             }\n         }\n-        fn make_ty(cx: ext_ctxt, sp: span, t: Ty) -> @ast::expr {\n+        fn make_ty(cx: @ext_ctxt, sp: span, t: Ty) -> @ast::expr {\n             let mut rt_type;\n             match t {\n               TyHex(c) => match c {\n@@ -108,7 +108,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             }\n             return make_rt_path_expr(cx, sp, @rt_type);\n         }\n-        fn make_conv_struct(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n+        fn make_conv_struct(cx: @ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             let intr = cx.parse_sess().interner;\n@@ -139,7 +139,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n                          rt_conv_precision, rt_conv_ty)\n     }\n-    fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: ~str, cnv: Conv,\n+    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: ~str, cnv: Conv,\n                       arg: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, @fname);\n@@ -148,7 +148,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         return mk_call_global(cx, arg.span, path, args);\n     }\n \n-    fn make_new_conv(cx: ext_ctxt, sp: span, cnv: Conv, arg: @ast::expr) ->\n+    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: Conv, arg: @ast::expr) ->\n        @ast::expr {\n         // FIXME: Move validation code into core::extfmt (Issue #2249)\n "}, {"sha": "bf4a997bc171f201110b914d2c4cb609925da64e", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -17,7 +17,7 @@ use ext::base::*;\n use ext::base;\n use print;\n \n-pub fn expand_syntax_ext(cx: ext_ctxt,\n+pub fn expand_syntax_ext(cx: @ext_ctxt,\n                          sp: codemap::span,\n                          tt: &[ast::token_tree])\n                       -> base::MacResult {"}, {"sha": "76b70225c6c84d0cad46ffa726db3713a2ceeaac", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -138,7 +138,7 @@ pub trait ext_ctxt_ast_builder {\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n }\n \n-impl ext_ctxt_ast_builder for ext_ctxt {\n+impl ext_ctxt_ast_builder for @ext_ctxt {\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path_global(~[\n             self.ident_of(~\"core\"),"}, {"sha": "30e7e832db197fd129e23dd6363aa844ccd25761", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -37,9 +37,8 @@ use ext::base::ext_ctxt;\n use ext::pipes::proto::{state, protocol, next_state};\n use ext::pipes::proto;\n \n-impl proto::visitor<(), (), ()> for ext_ctxt {\n-    fn visit_proto(&self, _proto: protocol,\n-                   _states: &[()]) { }\n+impl proto::visitor<(), (), ()> for @ext_ctxt {\n+    fn visit_proto(&self, _proto: protocol, _states: &[()]) { }\n \n     fn visit_state(&self, state: state, _m: &[()]) {\n         if state.messages.len() == 0 {"}, {"sha": "97f2e516603beb7e040c246653f131f6ee455b73", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -45,7 +45,7 @@ use ext::pipes::proto::protocol;\n use core::str;\n use std::bitv::Bitv;\n \n-pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n+pub fn analyze(proto: protocol, _cx: @ext_ctxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let mut colive = do (copy proto.states).map_to_vec |state| {"}, {"sha": "327cb0ae517e23fe8a8666452aef3392d048b7d7", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -63,13 +63,15 @@ pub mod check;\n pub mod liveness;\n \n \n-pub fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n+pub fn expand_proto(cx: @ext_ctxt, _sp: span, id: ast::ident,\n                     tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner, None, copy tt);\n-    let rdr = tt_rdr as reader;\n+                               cx.parse_sess().interner,\n+                               None,\n+                               copy tt);\n+    let rdr = tt_rdr as @reader;\n     let rust_parser = Parser(sess, cfg, rdr.dup());\n \n     let mut proto = rust_parser.parse_proto(cx.str_of(id));"}, {"sha": "a7725eab695ed1d8c6c8d7c80806e2295d36d260", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -26,27 +26,27 @@ use core::to_str::ToStr;\n use core::vec;\n \n pub trait gen_send {\n-    fn gen_send(&mut self, cx: ext_ctxt, try: bool) -> @ast::item;\n-    fn to_ty(&mut self, cx: ext_ctxt) -> @ast::Ty;\n+    fn gen_send(&mut self, cx: @ext_ctxt, try: bool) -> @ast::item;\n+    fn to_ty(&mut self, cx: @ext_ctxt) -> @ast::Ty;\n }\n \n pub trait to_type_decls {\n-    fn to_type_decls(&self, cx: ext_ctxt) -> ~[@ast::item];\n-    fn to_endpoint_decls(&self, cx: ext_ctxt,\n+    fn to_type_decls(&self, cx: @ext_ctxt) -> ~[@ast::item];\n+    fn to_endpoint_decls(&self, cx: @ext_ctxt,\n                          dir: direction) -> ~[@ast::item];\n }\n \n pub trait gen_init {\n-    fn gen_init(&self, cx: ext_ctxt) -> @ast::item;\n-    fn compile(&self, cx: ext_ctxt) -> @ast::item;\n-    fn buffer_ty_path(&self, cx: ext_ctxt) -> @ast::Ty;\n-    fn gen_buffer_type(&self, cx: ext_ctxt) -> @ast::item;\n-    fn gen_buffer_init(&self, ext_cx: ext_ctxt) -> @ast::expr;\n-    fn gen_init_bounded(&self, ext_cx: ext_ctxt) -> @ast::expr;\n+    fn gen_init(&self, cx: @ext_ctxt) -> @ast::item;\n+    fn compile(&self, cx: @ext_ctxt) -> @ast::item;\n+    fn buffer_ty_path(&self, cx: @ext_ctxt) -> @ast::Ty;\n+    fn gen_buffer_type(&self, cx: @ext_ctxt) -> @ast::item;\n+    fn gen_buffer_init(&self, ext_cx: @ext_ctxt) -> @ast::expr;\n+    fn gen_init_bounded(&self, ext_cx: @ext_ctxt) -> @ast::expr;\n }\n \n impl gen_send for message {\n-    fn gen_send(&mut self, cx: ext_ctxt, try: bool) -> @ast::item {\n+    fn gen_send(&mut self, cx: @ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         let name = self.name();\n \n@@ -188,14 +188,14 @@ impl gen_send for message {\n           }\n         }\n \n-    fn to_ty(&mut self, cx: ext_ctxt) -> @ast::Ty {\n+    fn to_ty(&mut self, cx: @ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n           .add_tys(cx.ty_vars_global(&self.get_generics().ty_params)))\n     }\n }\n \n impl to_type_decls for state {\n-    fn to_type_decls(&self, cx: ext_ctxt) -> ~[@ast::item] {\n+    fn to_type_decls(&self, cx: @ext_ctxt) -> ~[@ast::item] {\n         debug!(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n         // state is called ping. This will generate both `ping` and\n@@ -244,7 +244,7 @@ impl to_type_decls for state {\n         ]\n     }\n \n-    fn to_endpoint_decls(&self, cx: ext_ctxt,\n+    fn to_endpoint_decls(&self, cx: @ext_ctxt,\n                          dir: direction) -> ~[@ast::item] {\n         debug!(\"pipec: to_endpoint_decls\");\n         let dir = match dir {\n@@ -306,7 +306,7 @@ impl to_type_decls for state {\n }\n \n impl gen_init for protocol {\n-    fn gen_init(&self, cx: ext_ctxt) -> @ast::item {\n+    fn gen_init(&self, cx: @ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n \n         debug!(\"gen_init\");\n@@ -344,7 +344,7 @@ impl gen_init for protocol {\n                            body.to_source(cx)))\n     }\n \n-    fn gen_buffer_init(&self, ext_cx: ext_ctxt) -> @ast::expr {\n+    fn gen_buffer_init(&self, ext_cx: @ext_ctxt) -> @ast::expr {\n         ext_cx.struct_expr(path(~[ext_cx.ident_of(~\"__Buffer\")],\n                                 dummy_sp()),\n                       self.states.map_to_vec(|s| {\n@@ -356,7 +356,7 @@ impl gen_init for protocol {\n         }))\n     }\n \n-    fn gen_init_bounded(&self, ext_cx: ext_ctxt) -> @ast::expr {\n+    fn gen_init_bounded(&self, ext_cx: @ext_ctxt) -> @ast::expr {\n         debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n         let buffer = quote_expr!(~::core::pipes::Buffer {\n@@ -382,7 +382,7 @@ impl gen_init for protocol {\n         })\n     }\n \n-    fn buffer_ty_path(&self, cx: ext_ctxt) -> @ast::Ty {\n+    fn buffer_ty_path(&self, cx: @ext_ctxt) -> @ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         for (copy self.states).each |s| {\n             for s.generics.ty_params.each |tp| {\n@@ -399,7 +399,7 @@ impl gen_init for protocol {\n                                .add_tys(cx.ty_vars_global(&params)))\n     }\n \n-    fn gen_buffer_type(&self, cx: ext_ctxt) -> @ast::item {\n+    fn gen_buffer_type(&self, cx: @ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         let fields = do (copy self.states).map_to_vec |s| {\n@@ -442,7 +442,7 @@ impl gen_init for protocol {\n             cx.strip_bounds(&generics))\n     }\n \n-    fn compile(&self, cx: ext_ctxt) -> @ast::item {\n+    fn compile(&self, cx: @ext_ctxt) -> @ast::item {\n         let mut items = ~[self.gen_init(cx)];\n         let mut client_states = ~[];\n         let mut server_states = ~[];"}, {"sha": "60df7623e40f07327e6120355dd9acc555cc4c59", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -96,7 +96,7 @@ pub impl state_ {\n     }\n \n     /// Returns the type that is used for the messages.\n-    fn to_ty(&self, cx: ext_ctxt) -> @ast::Ty {\n+    fn to_ty(&self, cx: @ext_ctxt) -> @ast::Ty {\n         cx.ty_path_ast_builder\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n                 cx.ty_vars(&self.generics.ty_params)))"}, {"sha": "6deffbe0ae14670ef3c0dff9f58b0d4d3862e374", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -49,11 +49,11 @@ pub mod rt {\n     use print::pprust::{item_to_str, ty_to_str};\n \n     pub trait ToTokens {\n-        pub fn to_tokens(&self, _cx: ext_ctxt) -> ~[token_tree];\n+        pub fn to_tokens(&self, _cx: @ext_ctxt) -> ~[token_tree];\n     }\n \n     impl ToTokens for ~[token_tree] {\n-        pub fn to_tokens(&self, _cx: ext_ctxt) -> ~[token_tree] {\n+        pub fn to_tokens(&self, _cx: @ext_ctxt) -> ~[token_tree] {\n             copy *self\n         }\n     }\n@@ -62,10 +62,10 @@ pub mod rt {\n \n     trait ToSource : ToTokens {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(cx: ext_ctxt) -> ~str;\n+        pub fn to_source(cx: @ext_ctxt) -> ~str;\n \n         // If you can make source, you can definitely make tokens.\n-        pub fn to_tokens(cx: ext_ctxt) -> ~[token_tree] {\n+        pub fn to_tokens(cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n@@ -74,91 +74,91 @@ pub mod rt {\n \n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(&self, cx: ext_ctxt) -> ~str;\n+        pub fn to_source(&self, cx: @ext_ctxt) -> ~str;\n     }\n \n     impl ToSource for ast::ident {\n-        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             copy *cx.parse_sess().interner.get(*self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n-        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             item_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for ~[@ast::item] {\n-        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), ~\"\\n\\n\")\n         }\n     }\n \n     impl ToSource for @ast::Ty {\n-        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             ty_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for ~[@ast::Ty] {\n-        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), ~\", \")\n         }\n     }\n \n     impl ToSource for Generics {\n-        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             pprust::generics_to_str(self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for @ast::expr {\n-        fn to_source(&self, cx: ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n             pprust::expr_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     // Alas ... we write these out instead. All redundant.\n \n     impl ToTokens for ast::ident {\n-        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::item {\n-        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for ~[@ast::item] {\n-        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::Ty {\n-        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for ~[@ast::Ty] {\n-        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for Generics {\n-        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::expr {\n-        fn to_tokens(&self, cx: ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n@@ -170,7 +170,7 @@ pub mod rt {\n         fn parse_tts(&self, s: ~str) -> ~[ast::token_tree];\n     }\n \n-    impl ExtParseUtils for ext_ctxt {\n+    impl ExtParseUtils for @ext_ctxt {\n \n         fn parse_item(&self, s: ~str) -> @ast::item {\n             let res = parse::parse_item_from_source_str(\n@@ -216,74 +216,74 @@ pub mod rt {\n \n }\n \n-pub fn expand_quote_tokens(cx: ext_ctxt,\n+pub fn expand_quote_tokens(cx: @ext_ctxt,\n                            sp: span,\n                            tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_tts(cx, sp, tts))\n }\n \n-pub fn expand_quote_expr(cx: ext_ctxt,\n+pub fn expand_quote_expr(cx: @ext_ctxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_expr\", ~[], tts))\n }\n \n-pub fn expand_quote_item(cx: ext_ctxt,\n+pub fn expand_quote_item(cx: @ext_ctxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n-pub fn expand_quote_pat(cx: ext_ctxt,\n+pub fn expand_quote_pat(cx: @ext_ctxt,\n                         sp: span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = build::mk_lit(cx, sp, ast::lit_bool(true));\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n-pub fn expand_quote_ty(cx: ext_ctxt,\n+pub fn expand_quote_ty(cx: @ext_ctxt,\n                        sp: span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = build::mk_lit(cx, sp, ast::lit_bool(false));\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n-pub fn expand_quote_stmt(cx: ext_ctxt,\n+pub fn expand_quote_stmt(cx: @ext_ctxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, ~\"parse_stmt\",\n                                     ~[e_attrs], tts))\n }\n \n-fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n+fn ids_ext(cx: @ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n     strs.map(|str| cx.parse_sess().interner.intern(@copy *str))\n }\n \n-fn id_ext(cx: ext_ctxt, +str: ~str) -> ast::ident {\n+fn id_ext(cx: @ext_ctxt, +str: ~str) -> ast::ident {\n     cx.parse_sess().interner.intern(@str)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n+fn mk_ident(cx: @ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n     let e_meth = build::mk_access(cx, sp,\n                                   ids_ext(cx, ~[~\"ext_cx\"]),\n                                   id_ext(cx, ~\"ident_of\"));\n     let e_str = build::mk_uniq_str(cx, sp, cx.str_of(ident));\n     build::mk_call_(cx, sp, e_meth, ~[e_str])\n }\n \n-fn mk_bytepos(cx: ext_ctxt, sp: span, bpos: BytePos) -> @ast::expr {\n+fn mk_bytepos(cx: @ext_ctxt, sp: span, bpos: BytePos) -> @ast::expr {\n     let path = ids_ext(cx, ~[~\"BytePos\"]);\n     let arg = build::mk_uint(cx, sp, bpos.to_uint());\n     build::mk_call(cx, sp, path, ~[arg])\n }\n \n-fn mk_binop(cx: ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n+fn mk_binop(cx: @ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -300,7 +300,7 @@ fn mk_binop(cx: ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n                    ids_ext(cx, ~[name.to_owned()]))\n }\n \n-fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n+fn mk_token(cx: @ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n \n     match tok {\n         BINOP(binop) => {\n@@ -443,7 +443,7 @@ fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n }\n \n \n-fn mk_tt(cx: ext_ctxt, sp: span, tt: &ast::token_tree)\n+fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n     -> ~[@ast::stmt] {\n \n     match *tt {\n@@ -494,7 +494,7 @@ fn mk_tt(cx: ext_ctxt, sp: span, tt: &ast::token_tree)\n     }\n }\n \n-fn mk_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+fn mk_tts(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> ~[@ast::stmt] {\n     let mut ss = ~[];\n     for tts.each |tt| {\n@@ -503,7 +503,7 @@ fn mk_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     ss\n }\n \n-fn expand_tts(cx: ext_ctxt,\n+fn expand_tts(cx: @ext_ctxt,\n               sp: span,\n               tts: &[ast::token_tree]) -> @ast::expr {\n \n@@ -577,7 +577,7 @@ fn expand_tts(cx: ext_ctxt,\n                                         ids_ext(cx, ~[~\"tt\"]))))\n }\n \n-fn expand_parse_call(cx: ext_ctxt,\n+fn expand_parse_call(cx: @ext_ctxt,\n                      sp: span,\n                      +parse_method: ~str,\n                      +arg_exprs: ~[@ast::expr],"}, {"sha": "b2de322be5531ec8e408de817f4a0d2d492d34f1", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -29,7 +29,7 @@ use core::vec;\n // a given file into the current one.\n \n /* line!(): expands to the current line number */\n-pub fn expand_line(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_line(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -40,7 +40,7 @@ pub fn expand_line(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n }\n \n /* col!(): expands to the current column number */\n-pub fn expand_col(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_col(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n@@ -52,7 +52,7 @@ pub fn expand_col(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-pub fn expand_file(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_file(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -62,13 +62,13 @@ pub fn expand_file(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, topmost.call_site, filename))\n }\n \n-pub fn expand_stringify(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_stringify(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n     base::MRExpr(mk_base_str(cx, sp, s))\n }\n \n-pub fn expand_mod(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_mod(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(mk_base_str(cx, sp,\n@@ -79,7 +79,7 @@ pub fn expand_mod(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n // include! : parse the given file as an expr\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n-pub fn expand_include(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n@@ -89,7 +89,7 @@ pub fn expand_include(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include_str(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n@@ -103,7 +103,7 @@ pub fn expand_include_str(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, sp, result::unwrap(res)))\n }\n \n-pub fn expand_include_bin(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include_bin(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n@@ -147,7 +147,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n+fn res_rel_file(cx: @ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute {\n         let cu = Path(cx.codemap().span_to_filename(sp));"}, {"sha": "29a959013f258bb16d72ed1c6817832165f7ce6f", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -17,8 +17,10 @@ use ext::base;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n \n-pub fn expand_trace_macros(cx: ext_ctxt, sp: span,\n-                           tt: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_trace_macros(cx: @ext_ctxt,\n+                           sp: span,\n+                           tt: &[ast::token_tree])\n+                        -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(\n@@ -27,7 +29,7 @@ pub fn expand_trace_macros(cx: ext_ctxt, sp: span,\n         None,\n         vec::from_slice(tt)\n     );\n-    let rdr = tt_rdr as reader;\n+    let rdr = tt_rdr as @reader;\n     let rust_parser = Parser(\n         sess,\n         copy cfg,"}, {"sha": "b0628437bb0ff462fd4c8df3fc05dfd95881cbcc", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -224,7 +224,7 @@ pub enum parse_result {\n pub fn parse_or_else(\n     sess: @mut ParseSess,\n     +cfg: ast::crate_cfg,\n-    rdr: reader,\n+    rdr: @reader,\n     ms: ~[matcher]\n ) -> HashMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n@@ -237,7 +237,7 @@ pub fn parse_or_else(\n pub fn parse(\n     sess: @mut ParseSess,\n     cfg: ast::crate_cfg,\n-    rdr: reader,\n+    rdr: @reader,\n     ms: ~[matcher]\n ) -> parse_result {\n     let mut cur_eis = ~[];"}, {"sha": "dcc84ce46fe05197415b7b14530ca3844dedc869", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -27,8 +27,11 @@ use print;\n \n use core::io;\n \n-pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n-                         arg: ~[ast::token_tree]) -> base::MacResult {\n+pub fn add_new_extension(cx: @ext_ctxt,\n+                         sp: span,\n+                         name: ident,\n+                         arg: ~[ast::token_tree])\n+                      -> base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n         spanned { node: copy m, span: dummy_sp() }\n@@ -54,8 +57,10 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n                                    cx.parse_sess().interner, None, copy arg);\n-    let argument_map = parse_or_else(cx.parse_sess(), cx.cfg(),\n-                                     arg_reader as reader, argument_gram);\n+    let argument_map = parse_or_else(cx.parse_sess(),\n+                                     cx.cfg(),\n+                                     arg_reader as @reader,\n+                                     argument_gram);\n \n     // Extract the arguments:\n     let lhses = match argument_map.get(&lhs_nm) {\n@@ -69,7 +74,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: ext_ctxt, sp: span, name: ident,\n+    fn generic_extension(cx: @ext_ctxt, sp: span, name: ident,\n                          arg: &[ast::token_tree],\n                          lhses: ~[@named_match], rhses: ~[@named_match])\n     -> MacResult {\n@@ -98,7 +103,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                     itr,\n                     None,\n                     vec::from_slice(arg)\n-                ) as reader;\n+                ) as @reader;\n                 match parse(cx.parse_sess(), cx.cfg(), arg_rdr, (*mtcs)) {\n                   success(named_matches) => {\n                     let rhs = match rhses[i] {\n@@ -118,8 +123,9 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                     // rhs has holes ( `$id` and `$(...)` that need filled)\n                     let trncbr = new_tt_reader(s_d, itr, Some(named_matches),\n                                                rhs);\n-                    let p = @Parser(cx.parse_sess(), cx.cfg(),\n-                                    trncbr as reader);\n+                    let p = @Parser(cx.parse_sess(),\n+                                    cx.cfg(),\n+                                    trncbr as @reader);\n \n                     // Let the context choose how to interpret the result.\n                     // Weird, but useful for X-macros.\n@@ -140,7 +146,7 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(ext_ctxt, span, &[ast::token_tree]) -> MacResult =\n+    let exp: @fn(@ext_ctxt, span, &[ast::token_tree]) -> MacResult =\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, lhses, rhses);\n \n     return MRDef(MacroDef{"}, {"sha": "908fbd44825106ab58bbbe65bb3ce620db70da33", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -34,7 +34,7 @@ struct TtFrame {\n }\n \n pub struct TtReader {\n-    sp_diag: span_handler,\n+    sp_diag: @span_handler,\n     interner: @ident_interner,\n     // the unzipped tree:\n     cur: @mut TtFrame,\n@@ -50,7 +50,7 @@ pub struct TtReader {\n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n-pub fn new_tt_reader(sp_diag: span_handler,\n+pub fn new_tt_reader(sp_diag: @span_handler,\n                      itr: @ident_interner,\n                      interp: Option<std::oldmap::HashMap<ident,@named_match>>,\n                      +src: ~[ast::token_tree])"}, {"sha": "1626c55e7211ea9b6ab0fb07b7ad276d02071452", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -48,26 +48,26 @@ pub trait ast_fold {\n \n pub struct AstFoldFns {\n     //unlike the others, item_ is non-trivial\n-    fold_crate: @fn(&crate_, span, ast_fold) -> (crate_, span),\n-    fold_view_item: @fn(view_item_, ast_fold) -> view_item_,\n-    fold_foreign_item: @fn(@foreign_item, ast_fold) -> @foreign_item,\n-    fold_item: @fn(@item, ast_fold) -> Option<@item>,\n-    fold_struct_field: @fn(@struct_field, ast_fold) -> @struct_field,\n-    fold_item_underscore: @fn(&item_, ast_fold) -> item_,\n-    fold_method: @fn(@method, ast_fold) -> @method,\n-    fold_block: @fn(&blk_, span, ast_fold) -> (blk_, span),\n-    fold_stmt: @fn(&stmt_, span, ast_fold) -> (stmt_, span),\n-    fold_arm: @fn(&arm, ast_fold) -> arm,\n-    fold_pat: @fn(&pat_, span, ast_fold) -> (pat_, span),\n-    fold_decl: @fn(&decl_, span, ast_fold) -> (decl_, span),\n-    fold_expr: @fn(&expr_, span, ast_fold) -> (expr_, span),\n-    fold_ty: @fn(&ty_, span, ast_fold) -> (ty_, span),\n-    fold_mod: @fn(&_mod, ast_fold) -> _mod,\n-    fold_foreign_mod: @fn(&foreign_mod, ast_fold) -> foreign_mod,\n-    fold_variant: @fn(&variant_, span, ast_fold) -> (variant_, span),\n-    fold_ident: @fn(ident, ast_fold) -> ident,\n-    fold_path: @fn(@path, ast_fold) -> path,\n-    fold_local: @fn(&local_, span, ast_fold) -> (local_, span),\n+    fold_crate: @fn(&crate_, span, @ast_fold) -> (crate_, span),\n+    fold_view_item: @fn(view_item_, @ast_fold) -> view_item_,\n+    fold_foreign_item: @fn(@foreign_item, @ast_fold) -> @foreign_item,\n+    fold_item: @fn(@item, @ast_fold) -> Option<@item>,\n+    fold_struct_field: @fn(@struct_field, @ast_fold) -> @struct_field,\n+    fold_item_underscore: @fn(&item_, @ast_fold) -> item_,\n+    fold_method: @fn(@method, @ast_fold) -> @method,\n+    fold_block: @fn(&blk_, span, @ast_fold) -> (blk_, span),\n+    fold_stmt: @fn(&stmt_, span, @ast_fold) -> (stmt_, span),\n+    fold_arm: @fn(&arm, @ast_fold) -> arm,\n+    fold_pat: @fn(&pat_, span, @ast_fold) -> (pat_, span),\n+    fold_decl: @fn(&decl_, span, @ast_fold) -> (decl_, span),\n+    fold_expr: @fn(&expr_, span, @ast_fold) -> (expr_, span),\n+    fold_ty: @fn(&ty_, span, @ast_fold) -> (ty_, span),\n+    fold_mod: @fn(&_mod, @ast_fold) -> _mod,\n+    fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n+    fold_variant: @fn(&variant_, span, @ast_fold) -> (variant_, span),\n+    fold_ident: @fn(ident, @ast_fold) -> ident,\n+    fold_path: @fn(@path, @ast_fold) -> path,\n+    fold_local: @fn(&local_, span, @ast_fold) -> (local_, span),\n     map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n     new_id: @fn(node_id) -> node_id,\n     new_span: @fn(span) -> span\n@@ -436,8 +436,8 @@ fn noop_fold_decl(d: &decl_, fld: @ast_fold) -> decl_ {\n     }\n }\n \n-pub fn wrap<T>(f: @fn(&T, ast_fold) -> T)\n-            -> @fn(&T, span, ast_fold) -> (T, span) {\n+pub fn wrap<T>(f: @fn(&T, @ast_fold) -> T)\n+            -> @fn(&T, span, @ast_fold) -> (T, span) {\n     let result: @fn(&T, span, @ast_fold) -> (T, span) = |x, s, fld| {\n         (f(x, fld), s)\n     };\n@@ -879,13 +879,13 @@ impl ast_fold for AstFoldFns {\n     }\n }\n \n-pub impl ast_fold {\n+pub impl @ast_fold {\n     fn fold_attributes(&self, attrs: ~[attribute]) -> ~[attribute] {\n         attrs.map(|x| fold_attribute_(*x, *self))\n     }\n }\n \n-pub fn make_fold(afp: ast_fold_fns) -> ast_fold {\n+pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n     afp as @ast_fold\n }\n "}, {"sha": "b6ec3aff44d1d750368ef20a1204f18afe247ef4", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -256,7 +256,7 @@ fn read_block_comment(rdr: @mut StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level %d\", level);\n             if is_eof(rdr) {\n-                (rdr as reader).fatal(~\"unterminated block comment\");\n+                (rdr as @reader).fatal(~\"unterminated block comment\");\n             }\n             if rdr.curr == '\\n' {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n@@ -319,9 +319,11 @@ pub struct lit {\n     pos: BytePos\n }\n \n-pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n+pub fn gather_comments_and_literals(span_diagnostic:\n+                                    @diagnostic::span_handler,\n                                     +path: ~str,\n-                                    srdr: io::Reader) -> (~[cmnt], ~[lit]) {\n+                                    srdr: @io::Reader)\n+                                 -> (~[cmnt], ~[lit]) {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = parse::token::mk_fake_ident_interner();\n     let cm = CodeMap::new();"}, {"sha": "1b64a9a6275c1be564b4065cfcc1e29fa06eb784", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -47,7 +47,7 @@ pub fn seq_sep_none() -> SeqSep {\n     }\n }\n \n-pub fn token_to_str(reader: reader, token: &token::Token) -> ~str {\n+pub fn token_to_str(reader: @reader, token: &token::Token) -> ~str {\n     token::to_str(reader.interner(), token)\n }\n "}, {"sha": "09ffd79c246e3ae54bc99c330ecca9075ae8a61a", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -31,17 +31,17 @@ pub trait reader {\n     fn is_eof(@mut self) -> bool;\n     fn next_token(@mut self) -> TokenAndSpan;\n     fn fatal(@mut self, ~str) -> !;\n-    fn span_diag(@mut self) -> span_handler;\n+    fn span_diag(@mut self) -> @span_handler;\n     pure fn interner(@mut self) -> @token::ident_interner;\n     fn peek(@mut self) -> TokenAndSpan;\n-    fn dup(@mut self) -> reader;\n+    fn dup(@mut self) -> @reader;\n }\n \n #[deriving_eq]\n pub struct TokenAndSpan {tok: token::Token, sp: span}\n \n pub struct StringReader {\n-    span_diagnostic: span_handler,\n+    span_diagnostic: @span_handler,\n     src: @~str,\n     // The absolute offset within the codemap of the next character to read\n     pos: BytePos,\n@@ -58,7 +58,7 @@ pub struct StringReader {\n     peek_span: span\n }\n \n-pub fn new_string_reader(span_diagnostic: span_handler,\n+pub fn new_string_reader(span_diagnostic: @span_handler,\n                          filemap: @codemap::FileMap,\n                          itr: @token::ident_interner)\n                       -> @mut StringReader {\n@@ -68,7 +68,7 @@ pub fn new_string_reader(span_diagnostic: span_handler,\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n-pub fn new_low_level_string_reader(span_diagnostic: span_handler,\n+pub fn new_low_level_string_reader(span_diagnostic: @span_handler,\n                                    filemap: @codemap::FileMap,\n                                    itr: @token::ident_interner)\n                                 -> @mut StringReader {\n@@ -121,15 +121,15 @@ impl reader for StringReader {\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n-    fn span_diag(@mut self) -> span_handler { self.span_diagnostic }\n+    fn span_diag(@mut self) -> @span_handler { self.span_diagnostic }\n     pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.peek_tok,\n             sp: copy self.peek_span,\n         }\n     }\n-    fn dup(@mut self) -> reader { dup_string_reader(self) as reader }\n+    fn dup(@mut self) -> @reader { dup_string_reader(self) as @reader }\n }\n \n impl reader for TtReader {\n@@ -138,15 +138,15 @@ impl reader for TtReader {\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n-    fn span_diag(@mut self) -> span_handler { self.sp_diag }\n+    fn span_diag(@mut self) -> @span_handler { self.sp_diag }\n     pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.cur_tok,\n             sp: copy self.cur_span,\n         }\n     }\n-    fn dup(@mut self) -> reader { dup_tt_reader(self) as reader }\n+    fn dup(@mut self) -> @reader { dup_tt_reader(self) as @reader }\n }\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token."}, {"sha": "8272ebfb6d8e8b63b5ea17f593d20fe6a6f14c5f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -48,7 +48,7 @@ pub mod obsolete;\n pub struct ParseSess {\n     cm: @codemap::CodeMap,\n     next_id: node_id,\n-    span_diagnostic: span_handler,\n+    span_diagnostic: @span_handler,\n     interner: @ident_interner,\n }\n \n@@ -62,8 +62,9 @@ pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n     }\n }\n \n-pub fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n-    -> @mut ParseSess {\n+pub fn new_parse_sess_special_handler(sh: @span_handler,\n+                                      cm: @codemap::CodeMap)\n+                                   -> @mut ParseSess {\n     @mut ParseSess {\n         cm: cm,\n         next_id: 1,\n@@ -201,20 +202,19 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n     return rv;\n }\n \n-pub fn new_parser_from_source_str(\n-    sess: @mut ParseSess,\n-    +cfg: ast::crate_cfg,\n-    +name: ~str,\n-    +ss: codemap::FileSubstr,\n-    source: @~str\n-) -> Parser {\n+pub fn new_parser_from_source_str(sess: @mut ParseSess,\n+                                  +cfg: ast::crate_cfg,\n+                                  +name: ~str,\n+                                  +ss: codemap::FileSubstr,\n+                                  source: @~str)\n+                               -> Parser {\n     let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n     let srdr = lexer::new_string_reader(\n         copy sess.span_diagnostic,\n         filemap,\n         sess.interner\n     );\n-    Parser(sess, cfg, srdr as reader)\n+    Parser(sess, cfg, srdr as @reader)\n }\n \n /// Read the entire source file, return a parser\n@@ -227,12 +227,10 @@ pub fn new_parser_result_from_file(\n     match io::read_whole_file_str(path) {\n         Ok(src) => {\n             let filemap = sess.cm.new_filemap(path.to_str(), @src);\n-            let srdr = lexer::new_string_reader(\n-                copy sess.span_diagnostic,\n-                filemap,\n-                sess.interner\n-            );\n-            Ok(Parser(sess, cfg, srdr as reader))\n+            let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n+                                                filemap,\n+                                                sess.interner);\n+            Ok(Parser(sess, cfg, srdr as @reader))\n \n         }\n         Err(e) => Err(e)\n@@ -281,7 +279,7 @@ pub fn new_parser_from_tts(\n         None,\n         tts\n     );\n-    Parser(sess, cfg, trdr as reader)\n+    Parser(sess, cfg, trdr as @reader)\n }\n \n // abort if necessary"}, {"sha": "170a1a3240ee0e1193ad171c806b9e3383560e46", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -215,8 +215,8 @@ struct ParsedItemsAndViewItems {\n \n pub fn Parser(sess: @mut ParseSess,\n               +cfg: ast::crate_cfg,\n-              +rdr: reader) -> Parser {\n-\n+              +rdr: @reader)\n+           -> Parser {\n     let tok0 = copy rdr.next_token();\n     let interner = rdr.interner();\n \n@@ -254,7 +254,7 @@ pub struct Parser {\n     tokens_consumed: @mut uint,\n     restriction: @mut restriction,\n     quote_depth: @mut uint, // not (yet) related to the quasiquoter\n-    reader: reader,\n+    reader: @reader,\n     interner: @token::ident_interner,\n     keywords: HashMap<~str, ()>,\n     strict_keywords: HashMap<~str, ()>,"}, {"sha": "724e61daea7e74611e841662b73021a6e7170246", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -76,7 +76,7 @@ pub fn end(s: @ps) {\n     pp::end(s.s);\n }\n \n-pub fn rust_printer(writer: io::Writer, intr: @ident_interner) -> @ps {\n+pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n     return @ps {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None::<@CodeMap>,\n@@ -100,10 +100,15 @@ pub const default_columns: uint = 78u;\n // Requires you to pass an input filename and reader so that\n // it can scan the input text for comments and literals to\n // copy forward.\n-pub fn print_crate(cm: @CodeMap, intr: @ident_interner,\n-                   span_diagnostic: diagnostic::span_handler,\n-                   crate: @ast::crate, filename: ~str, in: io::Reader,\n-                   out: io::Writer, ann: pp_ann, is_expanded: bool) {\n+pub fn print_crate(cm: @CodeMap,\n+                   intr: @ident_interner,\n+                   span_diagnostic: @diagnostic::span_handler,\n+                   crate: @ast::crate,\n+                   filename: ~str,\n+                   in: @io::Reader,\n+                   out: @io::Writer,\n+                   ann: pp_ann,\n+                   is_expanded: bool) {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n         span_diagnostic,\n         copy filename,"}, {"sha": "bd1b9d84e077499ad1a02512a4d2319c37029d26", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -13,7 +13,7 @@\n \n pub trait i<T> { }\n \n-pub fn f<T>() -> i<T> {\n+pub fn f<T>() -> @i<T> {\n     impl<T> i<T> for () { }\n \n     @() as @i<T>"}, {"sha": "9133b80aa1e2b46d4fbd0891f6a5b2b342cf2112", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -58,6 +58,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n fn main() {\n-  let nyan : noisy  = @cat(0, 2, ~\"nyan\") as @noisy;\n+  let nyan : @noisy  = @cat(0, 2, ~\"nyan\") as @noisy;\n   nyan.eat(); //~ ERROR type `@noisy` does not implement any method in scope named `eat`\n }"}, {"sha": "4f8269bb11b42bb334ce961cd8fb5b36b8ea2770", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -14,14 +14,14 @@ impl<A:Copy> repeat<A> for @A {\n     fn get() -> A { *self }\n }\n \n-fn repeater<A:Copy>(v: @A) -> repeat<A> {\n+fn repeater<A:Copy>(v: @A) -> @repeat<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n-    @v as repeat::<A> // No\n+    @v as @repeat::<A> // No\n }\n \n fn main() {\n     // Error results because the type of is inferred to be\n-    // repeat<&blk/int> where blk is the lifetime of the block below.\n+    // @repeat<&blk/int> where blk is the lifetime of the block below.\n \n     let y = { //~ ERROR reference is not valid\n         let x: &blk/int = &3;"}, {"sha": "391b65e3c818aa5622b6b8390ef78d556954470a", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -26,22 +26,22 @@ fn to_foo<T:Copy>(t: T) {\n     // the fn body itself.\n     let v = &3;\n     struct F<T> { f: T }\n-    let x = @F {f:t} as foo;\n+    let x = @F {f:t} as @foo;\n     fail_unless!(x.foo(v) == 3);\n }\n \n-fn to_foo_2<T:Copy>(t: T) -> foo {\n+fn to_foo_2<T:Copy>(t: T) -> @foo {\n     // Not OK---T may contain borrowed ptrs and it is going to escape\n     // as part of the returned foo value\n     struct F<T> { f: T }\n-    @F {f:t} as foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n+    @F {f:t} as @foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n }\n \n-fn to_foo_3<T:Copy + &static>(t: T) -> foo {\n+fn to_foo_3<T:Copy + &static>(t: T) -> @foo {\n     // OK---T may escape as part of the returned foo value, but it is\n     // owned and hence does not contain borrowed ptrs\n     struct F<T> { f: T }\n-    @F {f:t} as foo\n+    @F {f:t} as @foo\n }\n \n fn main() {"}, {"sha": "a92a764afe746c241aa9013789f059a157caa3e3", "filename": "src/test/compile-fail/kindck-owned-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -10,11 +10,11 @@\n \n trait foo { fn foo(); }\n \n-fn to_foo<T:Copy + foo>(t: T) -> foo {\n+fn to_foo<T:Copy + foo>(t: T) -> @foo {\n     @t as @foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n }\n \n-fn to_foo2<T:Copy + foo + &static>(t: T) -> foo {\n+fn to_foo2<T:Copy + foo + &static>(t: T) -> @foo {\n     @t as @foo\n }\n "}, {"sha": "8b6c6b8410ac0e76ceef5115d7c41118c6f4881f", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -15,7 +15,7 @@ use core::hashmap::linear::LinearMap;\n \n fn main() {\n     let x: @Map<~str, ~str> = @LinearMap::new::<~str, ~str>() as\n-        Map::<~str, ~str>;\n+        @Map::<~str, ~str>;\n     let y: @Map<uint, ~str> = @x;\n     //~^ ERROR mismatched types: expected `@core::container::Map<uint,~str>`\n }"}, {"sha": "92d1aab781c4b18137a80b5fb2f973ae054a3fca", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -22,7 +22,7 @@ fn a_fn1(e: an_enum<'a>) -> an_enum<'b> {\n     return e; //~ ERROR mismatched types: expected `an_enum/&b` but found `an_enum/&a`\n }\n \n-fn a_fn2(e: a_trait<'a>) -> a_trait<'b> {\n+fn a_fn2(e: @a_trait<'a>) -> @a_trait<'b> {\n     return e; //~ ERROR mismatched types: expected `@a_trait/&b` but found `@a_trait/&a`\n }\n "}, {"sha": "93d493314fdcee6b6f2eec72f4ff1ccc6141b7b4", "filename": "src/test/compile-fail/regions-infer-paramd-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -18,7 +18,7 @@ trait foo<'self> {\n }\n \n struct with_foo<'self> {\n-    f: foo<'self>\n+    f: @foo<'self>\n }\n \n trait set_foo_foo {"}, {"sha": "8104f62595cb9dec3b7062c455f53294c1bb1fdd", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -27,12 +27,12 @@ impl get_ctxt for has_ctxt<'self> {\n \n }\n \n-fn get_v(gc: get_ctxt) -> uint {\n+fn get_v(gc: @get_ctxt) -> uint {\n     gc.get_ctxt().v\n }\n \n fn main() {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n-    fail_unless!(get_v(@hc as get_ctxt) == 22u);\n+    fail_unless!(get_v(@hc as @get_ctxt) == 22u);\n }"}, {"sha": "d76bc798705fe34b9aba07c5c181afe3594fcd6e", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -20,10 +20,10 @@ impl<'self> get_ctxt<'self> for has_ctxt<'self> {\n     fn get_ctxt() -> &self/ctxt { self.c }\n }\n \n-fn make_gc() -> get_ctxt  {\n+fn make_gc() -> @get_ctxt  {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt }; //~ ERROR illegal borrow\n-    return @hc as get_ctxt;\n+    return @hc as @get_ctxt;\n }\n \n fn main() {"}, {"sha": "414d848a96680cb36b2596e205ceec50538234fd", "filename": "src/test/compile-fail/regions-trait-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -12,7 +12,7 @@ trait get_ctxt {\n     fn get_ctxt() -> &self/uint;\n }\n \n-fn make_gc1(gc: get_ctxt/&a) -> get_ctxt/&b  {\n+fn make_gc1(gc: @get_ctxt/&a) -> @get_ctxt/&b  {\n     return gc; //~ ERROR mismatched types: expected `@get_ctxt/&b` but found `@get_ctxt/&a`\n }\n \n@@ -24,8 +24,8 @@ impl get_ctxt/&self for Foo/&self {\n     fn get_ctxt() -> &self/uint { self.r }\n }\n \n-fn make_gc2(foo: Foo/&a) -> get_ctxt/&b  {\n-    return @foo as get_ctxt; //~ ERROR cannot infer an appropriate lifetime\n+fn make_gc2(foo: Foo/&a) -> @get_ctxt/&b  {\n+    return @foo as @get_ctxt; //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "1699534216eb941ec96ec6f1ea315d1b4bd21b97", "filename": "src/test/compile-fail/tps-invariant-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -24,7 +24,7 @@ impl<T:Copy> box_trait<T> for box_impl<T> {\n     fn set(t: T) { self.f = t; }\n }\n \n-fn set_box_trait<T>(b: box_trait<@const T>, v: @const T) {\n+fn set_box_trait<T>(b: @box_trait<@const T>, v: @const T) {\n     b.set(v);\n }\n \n@@ -34,7 +34,7 @@ fn set_box_impl<T>(b: box_impl<@const T>, v: @const T) {\n \n fn main() {\n     let b = box_impl::<@int>(box::<@int> {f: @3});\n-    set_box_trait(@b as box_trait::<@int>, @mut 5);\n+    set_box_trait(@b as @box_trait::<@int>, @mut 5);\n     //~^ ERROR values differ in mutability\n     set_box_impl(b, @mut 5);\n     //~^ ERROR values differ in mutability"}, {"sha": "e63a1dc3563d5e6b492c66bf566cffc83d37d787", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -15,5 +15,5 @@ impl bar for uint { fn dup() -> uint { self } fn blah<X>() {} }\n fn main() {\n     10i.dup::<int>(); //~ ERROR does not take type parameters\n     10i.blah::<int, int>(); //~ ERROR incorrect number of type parameters\n-    (@10 as bar).dup(); //~ ERROR contains a self-type\n+    (@10 as @bar).dup(); //~ ERROR contains a self-type\n }"}, {"sha": "514448c9644fc54c3ca40936f6e7c380bb8d80db", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -24,7 +24,7 @@ impl TraitB for int {\n \n fn call_it<B:TraitB>(b: B)  -> int {\n     let y = 4u;\n-    b.gimme_an_a(y) //~ ERROR failed to find an implementation of trait @TraitA\n+    b.gimme_an_a(y) //~ ERROR failed to find an implementation of trait TraitA\n }\n \n fn main() {"}, {"sha": "fe32af7b15f6f3b8d49ef76d9b66a44fa3aeb492", "filename": "src/test/run-pass/issue-2288.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2288.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait clam<A:Copy> {\n+trait c lam<A:Copy> {\n   fn chowder(y: A);\n }\n struct foo<A> {\n@@ -26,13 +26,13 @@ fn foo<A:Copy>(b: A) -> foo<A> {\n     }\n }\n \n-fn f<A:Copy>(x: clam<A>, a: A) {\n+fn f<A:Copy>(x: @clam<A>, a: A) {\n   x.chowder(a);\n }\n \n pub fn main() {\n \n   let c = foo(42);\n-  let d: clam<int> = @c as clam::<int>;\n+  let d: @clam<int> = @c as @clam::<int>;\n   f(d, c.x);\n }"}, {"sha": "ef6363043eed4207076cab3619e83a270139c9f3", "filename": "src/test/run-pass/issue-2735.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -11,7 +11,7 @@\n trait hax { }\n impl<A> hax for A { }\n \n-fn perform_hax<T:&static>(x: @T) -> hax {\n+fn perform_hax<T:&static>(x: @T) -> @hax {\n     @x as @hax\n }\n "}, {"sha": "323b5d8ed5ae94ae08d1da0879afb22891dd10da", "filename": "src/test/run-pass/issue-2935.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fissue-2935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fissue-2935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2935.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n   //   let y = @({a: 4i});\n   //    let z = @({a: 4i} as it);\n   //    let z = @({a: true} as it);\n-    let z = @(@true as it);\n+    let z = @(@true as @it);\n     //  x.f();\n     // y.f();\n     // (*z).f();"}, {"sha": "75b0a6335528a3562ee7110fa6e5f422bb7dd00e", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -14,9 +14,9 @@ impl<A:Copy> repeat<A> for @A {\n     fn get() -> A { *self }\n }\n \n-fn repeater<A:Copy>(v: @A) -> repeat<A> {\n+fn repeater<A:Copy>(v: @A) -> @repeat<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n-    @v as repeat::<A> // No\n+    @v as @repeat::<A> // No\n }\n \n pub fn main() {"}, {"sha": "ecf30b206c58582a7737a2c3e7c0c53296612abc", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -29,7 +29,7 @@ impl<A:Copy + Serializable> Serializable for F<A> {\n     }\n }\n \n-impl Serializer for io::Writer {\n+impl Serializer for @io::Writer {\n }\n \n pub fn main() {"}, {"sha": "cc12c1b7dd9f171459a7f3dd3a90add9a4e18f00", "filename": "src/test/run-pass/regions-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c699815ddf22bf17b58a8c3d317af33745e28d/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-trait.rs?ref=b1c699815ddf22bf17b58a8c3d317af33745e28d", "patch": "@@ -22,7 +22,7 @@ impl get_ctxt<'self> for HasCtxt<'self> {\n     }\n }\n \n-fn get_v(gc: get_ctxt) -> uint {\n+fn get_v(gc: @get_ctxt) -> uint {\n     gc.get_ctxt().v\n }\n "}]}