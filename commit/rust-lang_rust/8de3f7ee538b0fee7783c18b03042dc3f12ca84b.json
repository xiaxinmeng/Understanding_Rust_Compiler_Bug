{"sha": "8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZTNmN2VlNTM4YjBmZWU3NzgzYzE4YjAzMDQyZGMzZjEyY2E4NGI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-23T14:37:19Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-23T14:37:19Z"}, "message": "Move out unqualified_path completion tests", "tree": {"sha": "c831536e6dce7bbe68ed42098834df7f3517b06f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c831536e6dce7bbe68ed42098834df7f3517b06f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "html_url": "https://github.com/rust-lang/rust/commit/8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea72a5136cc9d2bf3b83425569723e9e37bab403", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea72a5136cc9d2bf3b83425569723e9e37bab403", "html_url": "https://github.com/rust-lang/rust/commit/ea72a5136cc9d2bf3b83425569723e9e37bab403"}], "stats": {"total": 575, "additions": 251, "deletions": 324}, "files": [{"sha": "151297042b8c9b96eb37d22c2536e499c65eec66", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "patch": "@@ -47,7 +47,6 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n \n #[cfg(test)]\n mod tests {\n-\n     use crate::tests::check_edit;\n \n     #[test]"}, {"sha": "a896a759abfaf897e1b1550035e4a9ffceeb4a88", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "patch": "@@ -86,26 +86,3 @@ fn ${1:feature}() {\n     let item = snippet(ctx, cap, \"macro_rules\", \"macro_rules! $1 {\\n\\t($2) => {\\n\\t\\t$0\\n\\t};\\n}\");\n     item.add_to(acc);\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-\n-    use crate::{tests::filtered_completion_list, CompletionKind};\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::Snippet);\n-        expect.assert_eq(&actual)\n-    }\n-\n-    #[test]\n-    fn completes_snippets_in_expressions() {\n-        check(\n-            r#\"fn foo(x: i32) { $0 }\"#,\n-            expect![[r#\"\n-                sn pd\n-                sn ppd\n-            \"#]],\n-        );\n-    }\n-}"}, {"sha": "8258026182b8b261414b60b8d525fb6fd78f4282", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 300, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "patch": "@@ -87,7 +87,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         if let ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) | ScopeDef::Label(_) =\n             res\n         {\n-            cov_mark::hit!(skip_lifetime_completion);\n+            cov_mark::hit!(unqualified_skip_lifetime_completion);\n             return;\n         }\n         let add_resolution = match res {\n@@ -155,51 +155,6 @@ fn main() {\n         )\n     }\n \n-    #[test]\n-    fn completes_generic_params() {\n-        check(\n-            r#\"fn quux<T>() { $0 }\"#,\n-            expect![[r#\"\n-                tp T\n-                fn quux() fn()\n-            \"#]],\n-        );\n-        check(\n-            r#\"fn quux<const C: usize>() { $0 }\"#,\n-            expect![[r#\"\n-                cp C\n-                fn quux() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn does_not_complete_lifetimes() {\n-        cov_mark::check!(skip_lifetime_completion);\n-        check(\n-            r#\"fn quux<'a>() { $0 }\"#,\n-            expect![[r#\"\n-                fn quux() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_module_items() {\n-        check(\n-            r#\"\n-struct S;\n-enum E {}\n-fn quux() { $0 }\n-\"#,\n-            expect![[r#\"\n-                st S\n-                fn quux() fn()\n-                en E\n-            \"#]],\n-        );\n-    }\n-\n     /// Regression test for issue #6091.\n     #[test]\n     fn correctly_completes_module_items_prefixed_with_underscore() {\n@@ -220,55 +175,6 @@ fn _alpha() {}\n         )\n     }\n \n-    #[test]\n-    fn completes_module_items_in_nested_modules() {\n-        check(\n-            r#\"\n-struct Foo;\n-mod m {\n-    struct Bar;\n-    fn quux() { $0 }\n-}\n-\"#,\n-            expect![[r#\"\n-                fn quux() fn()\n-                st Bar\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_show_both_completions_for_shadowing() {\n-        check(\n-            r#\"\n-fn foo() {\n-    let bar = 92;\n-    {\n-        let bar = 62;\n-        drop($0)\n-    }\n-}\n-\"#,\n-            // FIXME: should be only one bar here\n-            expect![[r#\"\n-                lc bar   i32\n-                lc bar   i32\n-                fn foo() fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_self_in_methods() {\n-        check(\n-            r#\"impl S { fn foo(&self) { $0 } }\"#,\n-            expect![[r#\"\n-                lc self &{unknown}\n-                sp Self\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_prelude() {\n         check(\n@@ -318,32 +224,6 @@ mod macros {\n         );\n     }\n \n-    #[test]\n-    fn does_not_complete_non_fn_macros() {\n-        check(\n-            r#\"\n-#[rustc_builtin_macro]\n-pub macro Clone {}\n-\n-fn f() {$0}\n-\"#,\n-            expect![[r#\"\n-                fn f() fn()\n-            \"#]],\n-        );\n-        check(\n-            r#\"\n-#[rustc_builtin_macro]\n-pub macro bench {}\n-\n-fn f() {$0}\n-\"#,\n-            expect![[r#\"\n-                fn f() fn()\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_std_prelude_if_core_is_defined() {\n         check(\n@@ -372,183 +252,4 @@ pub mod prelude {\n             \"#]],\n         );\n     }\n-\n-    #[test]\n-    fn completes_macros_as_value() {\n-        check(\n-            r#\"\n-macro_rules! foo { () => {} }\n-\n-#[macro_use]\n-mod m1 {\n-    macro_rules! bar { () => {} }\n-}\n-\n-mod m2 {\n-    macro_rules! nope { () => {} }\n-\n-    #[macro_export]\n-    macro_rules! baz { () => {} }\n-}\n-\n-fn main() { let v = $0 }\n-\"#,\n-            expect![[r##\"\n-                md m1\n-                ma baz!(\u2026) #[macro_export] macro_rules! baz\n-                fn main()  fn()\n-                md m2\n-                ma bar!(\u2026) macro_rules! bar\n-                ma foo!(\u2026) macro_rules! foo\n-            \"##]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_both_macro_and_value() {\n-        check(\n-            r#\"\n-macro_rules! foo { () => {} }\n-fn foo() { $0 }\n-\"#,\n-            expect![[r#\"\n-                fn foo()   fn()\n-                ma foo!(\u2026) macro_rules! foo\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_macros_as_stmt() {\n-        check(\n-            r#\"\n-macro_rules! foo { () => {} }\n-fn main() { $0 }\n-\"#,\n-            expect![[r#\"\n-                fn main()  fn()\n-                ma foo!(\u2026) macro_rules! foo\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_local_item() {\n-        check(\n-            r#\"\n-fn main() {\n-    return f$0;\n-    fn frobnicate() {}\n-}\n-\"#,\n-            expect![[r#\"\n-                fn frobnicate() fn()\n-                fn main()       fn()\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_1() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-fn quux(x: i32) {\n-    let y = 92;\n-    m!($0);\n-}\n-\"#,\n-            expect![[r#\"\n-                lc y       i32\n-                lc x       i32\n-                fn quux(\u2026) fn(i32)\n-                ma m!(\u2026)   macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_2() {\n-        check(\n-            r\"\n-macro_rules! m { ($e:expr) => { $e } }\n-fn quux(x: i32) {\n-    let y = 92;\n-    m!(x$0);\n-}\n-\",\n-            expect![[r#\"\n-                lc y       i32\n-                lc x       i32\n-                fn quux(\u2026) fn(i32)\n-                ma m!(\u2026)   macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_in_simple_macro_without_closing_parens() {\n-        check(\n-            r#\"\n-macro_rules! m { ($e:expr) => { $e } }\n-fn quux(x: i32) {\n-    let y = 92;\n-    m!(x$0\n-}\n-\"#,\n-            expect![[r#\"\n-                lc y       i32\n-                lc x       i32\n-                fn quux(\u2026) fn(i32)\n-                ma m!(\u2026)   macro_rules! m\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_unresolved_uses() {\n-        check(\n-            r#\"\n-use spam::Quux;\n-\n-fn main() { $0 }\n-\"#,\n-            expect![[r#\"\n-                fn main() fn()\n-                ?? Quux\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_basic_expr() {\n-        check(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-fn main() { let foo: Foo = Q$0 }\n-\"#,\n-            expect![[r#\"\n-                ev Foo::Bar  ()\n-                ev Foo::Baz  ()\n-                ev Foo::Quux ()\n-                en Foo\n-                fn main()    fn()\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant_from_module() {\n-        check(\n-            r#\"\n-mod m { pub enum E { V } }\n-fn f() -> m::E { V$0 }\n-\"#,\n-            expect![[r#\"\n-                ev m::E::V ()\n-                md m\n-                fn f()     fn() -> E\n-            \"#]],\n-        )\n-    }\n }"}, {"sha": "8575914509891589146aa208355e519c19bc39d1", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "patch": "@@ -8,6 +8,7 @@\n //! completed where, not how.\n \n mod attribute;\n+mod expression;\n mod fn_param;\n mod item_list;\n mod item;"}, {"sha": "fb9f7a5a3bfc8e2136a05c53db01ed07301d86d0", "filename": "crates/ide_completion/src/tests/expression.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8de3f7ee538b0fee7783c18b03042dc3f12ca84b/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs?ref=8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "patch": "@@ -0,0 +1,249 @@\n+//! Completion tests for expressions.\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(&format!(\"{}{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n+    expect.assert_eq(&actual)\n+}\n+\n+fn check_empty(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual);\n+}\n+\n+#[test]\n+fn completes_various_bindings() {\n+    check_empty(\n+        r#\"\n+fn func(param0 @ (param1, param2): (i32, i32)) {\n+    let letlocal = 92;\n+    if let ifletlocal = 100 {\n+        match 0 {\n+            matcharm => 1 + $0,\n+            otherwise => (),\n+        }\n+    }\n+    let letlocal2 = 44;\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            lc matcharm   i32\n+            lc ifletlocal i32\n+            lc letlocal   i32\n+            lc param0     (i32, i32)\n+            lc param1     i32\n+            lc param2     i32\n+            fn func(\u2026)    fn((i32, i32))\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_all_the_things() {\n+    cov_mark::check!(unqualified_skip_lifetime_completion);\n+    check(\n+        r#\"\n+use non_existant::Unresolved;\n+mod qualified { pub enum Enum { Variant } }\n+\n+impl Unit {\n+    fn foo<'lifetime, TypeParam, const CONST_PARAM: usize>(self) {\n+        fn local_func() {}\n+        $0\n+    }\n+}\n+\"#,\n+        expect![[r##\"\n+            kw unsafe\n+            kw fn\n+            kw const\n+            kw type\n+            kw impl\n+            kw extern\n+            kw use\n+            kw trait\n+            kw static\n+            kw mod\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw let\n+            kw return\n+            sn pd\n+            sn ppd\n+            kw self\n+            kw super\n+            kw crate\n+            fn local_func() fn()\n+            bt u32\n+            lc self         Unit\n+            tp TypeParam\n+            cp CONST_PARAM\n+            sp Self\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Unit\n+            md qualified\n+            ma makro!(\u2026)    #[macro_export] macro_rules! makro\n+            ?? Unresolved\n+            fn function()   fn()\n+            sc STATIC\n+            ev TupleV(\u2026)    (u32)\n+            ct CONST\n+            ma makro!(\u2026)    #[macro_export] macro_rules! makro\n+            me self.foo()   fn(self)\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn shadowing_shows_single_completion() {\n+    check_empty(\n+        r#\"\n+fn foo() {\n+    let bar = 92;\n+    {\n+        let bar = 62;\n+        drop($0)\n+    }\n+}\n+\"#,\n+        // FIXME: should be only one bar here\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            lc bar       i32\n+            lc bar       i32\n+            fn foo()     fn()\n+            bt u32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_macro_expr_frag() {\n+    check_empty(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+fn quux(x: i32) {\n+    m!($0);\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            bt u32\n+            lc x         i32\n+            fn quux(\u2026)   fn(i32)\n+            ma m!(\u2026)     macro_rules! m\n+        \"#]],\n+    );\n+    check_empty(\n+        r\"\n+macro_rules! m { ($e:expr) => { $e } }\n+fn quux(x: i32) {\n+    m!(x$0);\n+}\n+\",\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            bt u32\n+            lc x         i32\n+            fn quux(\u2026)   fn(i32)\n+            ma m!(\u2026)     macro_rules! m\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+fn quux(x: i32) {\n+    let y = 92;\n+    m!(x$0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw unsafe\n+            kw match\n+            kw while\n+            kw while let\n+            kw loop\n+            kw if\n+            kw if let\n+            kw for\n+            kw true\n+            kw false\n+            kw return\n+            kw self\n+            kw super\n+            kw crate\n+            lc y         i32\n+            bt u32\n+            lc x         i32\n+            fn quux(\u2026)   fn(i32)\n+            ma m!(\u2026)     macro_rules! m\n+        \"#]],\n+    );\n+}"}]}