{"sha": "1ac6f4e9ae77296abe4d46aec33fa76108442d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYzZmNGU5YWU3NzI5NmFiZTRkNDZhZWMzM2ZhNzYxMDg0NDJkN2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-25T12:30:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-25T12:30:35Z"}, "message": "Auto merge of #3772 - flip1995:ice-3719, r=Manishearth\n\nFix ICE #3719+#3718 in lint match_ref_pats\n\nFixes #3719\nThis conveniently also fixes #3718\n\nThe ICE occurs when the match expression was a macro call, where the macro was defined in another file. Since we don't have the ability to reproduce this behavior with our UI tests (AFAIK), I couldn't add a test reproducing this ICE.. However, I added a test which is related to the ICE, to show the new behavior of the lint.\n\nI tested it with the mscheme repo locally and the ICE didn't happen anymore.\n\nr? @matthiaskrgr", "tree": {"sha": "33f27a0822088588448195968fcf39f9562a621c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33f27a0822088588448195968fcf39f9562a621c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ac6f4e9ae77296abe4d46aec33fa76108442d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac6f4e9ae77296abe4d46aec33fa76108442d7f", "html_url": "https://github.com/rust-lang/rust/commit/1ac6f4e9ae77296abe4d46aec33fa76108442d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd29740e6ece9bc5a99a72b987e8e6e39e67fc72", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd29740e6ece9bc5a99a72b987e8e6e39e67fc72", "html_url": "https://github.com/rust-lang/rust/commit/cd29740e6ece9bc5a99a72b987e8e6e39e67fc72"}, {"sha": "75f39881d4ad76a2aa2bfacdfbd8d49e5d92a0e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/75f39881d4ad76a2aa2bfacdfbd8d49e5d92a0e8", "html_url": "https://github.com/rust-lang/rust/commit/75f39881d4ad76a2aa2bfacdfbd8d49e5d92a0e8"}], "stats": {"total": 128, "additions": 91, "deletions": 37}, "files": [{"sha": "bb337c067bae3ac160886ee447a676d642ab677a", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=1ac6f4e9ae77296abe4d46aec33fa76108442d7f", "patch": "@@ -570,13 +570,15 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr:\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n         let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-            suggs.push((ex.span, Sugg::hir(cx, inner, \"..\").to_string()));\n+            let span = ex.span.source_callsite();\n+            suggs.push((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n             (\n                 \"you don't need to add `&` to both the expression and the patterns\",\n                 \"try\",\n             )\n         } else {\n-            suggs.push((ex.span, Sugg::hir(cx, ex, \"..\").deref().to_string()));\n+            let span = ex.span.source_callsite();\n+            suggs.push((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n             (\n                 \"you don't need to add `&` to all patterns\",\n                 \"instead of prefixing all patterns with `&`, you can dereference the expression\","}, {"sha": "7ff7b71ffa41ade026e5ecbb0f45b8f2b72e4118", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=1ac6f4e9ae77296abe4d46aec33fa76108442d7f", "patch": "@@ -1,7 +1,7 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::utils::{higher, in_macro, snippet, snippet_opt};\n+use crate::utils::{higher, in_macro, snippet, snippet_opt, snippet_with_macro_callsite};\n use matches::matches;\n use rustc::hir;\n use rustc::lint::{EarlyContext, LateContext, LintContext};\n@@ -46,38 +46,7 @@ impl<'a> Sugg<'a> {\n     pub fn hir_opt(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n-            match expr.node {\n-                hir::ExprKind::AddrOf(..)\n-                | hir::ExprKind::Box(..)\n-                | hir::ExprKind::Closure(.., _)\n-                | hir::ExprKind::If(..)\n-                | hir::ExprKind::Unary(..)\n-                | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n-                hir::ExprKind::Continue(..)\n-                | hir::ExprKind::Yield(..)\n-                | hir::ExprKind::Array(..)\n-                | hir::ExprKind::Block(..)\n-                | hir::ExprKind::Break(..)\n-                | hir::ExprKind::Call(..)\n-                | hir::ExprKind::Field(..)\n-                | hir::ExprKind::Index(..)\n-                | hir::ExprKind::InlineAsm(..)\n-                | hir::ExprKind::Lit(..)\n-                | hir::ExprKind::Loop(..)\n-                | hir::ExprKind::MethodCall(..)\n-                | hir::ExprKind::Path(..)\n-                | hir::ExprKind::Repeat(..)\n-                | hir::ExprKind::Ret(..)\n-                | hir::ExprKind::Struct(..)\n-                | hir::ExprKind::Tup(..)\n-                | hir::ExprKind::While(..)\n-                | hir::ExprKind::Err => Sugg::NonParen(snippet),\n-                hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-                hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n-                hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n-                hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-                hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n-            }\n+            Self::hir_from_snippet(expr, snippet)\n         })\n     }\n \n@@ -111,6 +80,50 @@ impl<'a> Sugg<'a> {\n         })\n     }\n \n+    /// Same as `hir`, but will use the pre expansion span if the `expr` was in a macro.\n+    pub fn hir_with_macro_callsite(cx: &LateContext<'_, '_>, expr: &hir::Expr, default: &'a str) -> Self {\n+        let snippet = snippet_with_macro_callsite(cx, expr.span, default);\n+\n+        Self::hir_from_snippet(expr, snippet)\n+    }\n+\n+    /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n+    /// function variants of `Sugg`, since these use different snippet functions.\n+    fn hir_from_snippet(expr: &hir::Expr, snippet: Cow<'a, str>) -> Self {\n+        match expr.node {\n+            hir::ExprKind::AddrOf(..)\n+            | hir::ExprKind::Box(..)\n+            | hir::ExprKind::Closure(.., _)\n+            | hir::ExprKind::If(..)\n+            | hir::ExprKind::Unary(..)\n+            | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            hir::ExprKind::Continue(..)\n+            | hir::ExprKind::Yield(..)\n+            | hir::ExprKind::Array(..)\n+            | hir::ExprKind::Block(..)\n+            | hir::ExprKind::Break(..)\n+            | hir::ExprKind::Call(..)\n+            | hir::ExprKind::Field(..)\n+            | hir::ExprKind::Index(..)\n+            | hir::ExprKind::InlineAsm(..)\n+            | hir::ExprKind::Lit(..)\n+            | hir::ExprKind::Loop(..)\n+            | hir::ExprKind::MethodCall(..)\n+            | hir::ExprKind::Path(..)\n+            | hir::ExprKind::Repeat(..)\n+            | hir::ExprKind::Ret(..)\n+            | hir::ExprKind::Struct(..)\n+            | hir::ExprKind::Tup(..)\n+            | hir::ExprKind::While(..)\n+            | hir::ExprKind::Err => Sugg::NonParen(snippet),\n+            hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+            hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n+            hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n+            hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+            hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+        }\n+    }\n+\n     /// Prepare a suggestion from an expression.\n     pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use syntax::ast::RangeLimits;"}, {"sha": "c7c84b5d9c0a24487a5ce3fa0f092266a2c65c07", "filename": "tests/ui/matches.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/tests%2Fui%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/tests%2Fui%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.rs?ref=1ac6f4e9ae77296abe4d46aec33fa76108442d7f", "patch": "@@ -150,4 +150,29 @@ fn match_as_ref() {\n     };\n }\n \n-fn main() {}\n+macro_rules! foo_variant(\n+    ($idx:expr) => (Foo::get($idx).unwrap())\n+);\n+\n+enum Foo {\n+    A,\n+    B,\n+}\n+\n+impl Foo {\n+    fn get(idx: u8) -> Option<&'static Self> {\n+        match idx {\n+            0 => Some(&Foo::A),\n+            1 => Some(&Foo::B),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    // ICE #3719\n+    match foo_variant!(0) {\n+        &Foo::A => println!(\"A\"),\n+        _ => println!(\"Wild\"),\n+    }\n+}"}, {"sha": "b4159f7a68d08b28309fdd8e7715e8242b778b7b", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ac6f4e9ae77296abe4d46aec33fa76108442d7f/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=1ac6f4e9ae77296abe4d46aec33fa76108442d7f", "patch": "@@ -278,5 +278,19 @@ LL | |         Some(ref mut v) => Some(v),\n LL | |     };\n    | |_____^ help: try this: `mut_owned.as_mut()`\n \n-error: aborting due to 19 previous errors\n+error: you don't need to add `&` to all patterns\n+  --> $DIR/matches.rs:174:5\n+   |\n+LL | /     match foo_variant!(0) {\n+LL | |         &Foo::A => println!(\"A\"),\n+LL | |         _ => println!(\"Wild\"),\n+LL | |     }\n+   | |_____^\n+help: instead of prefixing all patterns with `&`, you can dereference the expression\n+   |\n+LL |     match *foo_variant!(0) {\n+LL |         Foo::A => println!(\"A\"),\n+   |\n+\n+error: aborting due to 20 previous errors\n "}]}