{"sha": "eaf553dade9a28b41631387d7c88b09fd0ba64e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZjU1M2RhZGU5YTI4YjQxNjMxMzg3ZDdjODhiMDlmZDBiYTY0ZTI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-06T13:45:22Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-06T13:45:22Z"}, "message": "Merge #441\n\n441: hir::Expr r=matklad a=flodiebold\n\nStill a bit to do, but I already adapted `FnScopes` and thought I'd get feedback already.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "f5043da62c6cf4e2f082f68746843de7dfe53d03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5043da62c6cf4e2f082f68746843de7dfe53d03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaf553dade9a28b41631387d7c88b09fd0ba64e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf553dade9a28b41631387d7c88b09fd0ba64e2", "html_url": "https://github.com/rust-lang/rust/commit/eaf553dade9a28b41631387d7c88b09fd0ba64e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaf553dade9a28b41631387d7c88b09fd0ba64e2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "cbac31cbdb2168b18fc6fb89f5cf069238cc6ccb", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbac31cbdb2168b18fc6fb89f5cf069238cc6ccb", "html_url": "https://github.com/rust-lang/rust/commit/cbac31cbdb2168b18fc6fb89f5cf069238cc6ccb"}, {"sha": "98957f4e6f66469310072dff5dfc3e521a7cd555", "url": "https://api.github.com/repos/rust-lang/rust/commits/98957f4e6f66469310072dff5dfc3e521a7cd555", "html_url": "https://github.com/rust-lang/rust/commit/98957f4e6f66469310072dff5dfc3e521a7cd555"}], "stats": {"total": 1404, "additions": 1150, "deletions": 254}, "files": [{"sha": "21d77aa97801532dd00b0b18b7c363051d789afa", "filename": "crates/ra_analysis/src/completion/complete_scope.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -15,7 +15,7 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) ->\n         None => return Ok(()),\n     };\n     if let Some(function) = &ctx.function {\n-        let scopes = function.scopes(ctx.db);\n+        let scopes = function.scopes(ctx.db)?;\n         complete_fn(acc, &scopes, ctx.offset);\n     }\n \n@@ -40,20 +40,17 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) ->\n     Ok(())\n }\n \n-fn complete_fn(acc: &mut Completions, scopes: &hir::FnScopes, offset: TextUnit) {\n+fn complete_fn(acc: &mut Completions, scopes: &hir::ScopesWithSyntaxMapping, offset: TextUnit) {\n     let mut shadowed = FxHashSet::default();\n     scopes\n         .scope_chain_for_offset(offset)\n-        .flat_map(|scope| scopes.entries(scope).iter())\n+        .flat_map(|scope| scopes.scopes.entries(scope).iter())\n         .filter(|entry| shadowed.insert(entry.name()))\n         .for_each(|entry| {\n             CompletionItem::new(CompletionKind::Reference, entry.name().to_string())\n                 .kind(CompletionItemKind::Binding)\n                 .add_to(acc)\n         });\n-    if scopes.self_param.is_some() {\n-        CompletionItem::new(CompletionKind::Reference, \"self\").add_to(acc);\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "1709be5cf4b085c6aa9656bfeed712ae15a36d5c", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -106,6 +106,9 @@ salsa::database_storage! {\n             fn struct_data() for hir::db::StructDataQuery;\n             fn enum_data() for hir::db::EnumDataQuery;\n             fn impls_in_module() for hir::db::ImplsInModuleQuery;\n+            fn body_hir() for hir::db::BodyHirQuery;\n+            fn body_syntax_mapping() for hir::db::BodySyntaxMappingQuery;\n+            fn fn_signature() for hir::db::FnSignatureQuery;\n         }\n     }\n }"}, {"sha": "68b6ac3ba4930205e3e58332a5b66abe7f1c6342", "filename": "crates/ra_analysis/src/goto_defenition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -28,7 +28,7 @@ pub(crate) fn reference_defenition(\n     if let Some(fn_descr) =\n         hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())?\n     {\n-        let scope = fn_descr.scopes(db);\n+        let scope = fn_descr.scopes(db)?;\n         // First try to resolve the symbol locally\n         if let Some(entry) = scope.resolve_local_name(name_ref) {\n             let nav = NavigationTarget {"}, {"sha": "5988fb7794e32981c403569b7d7d0e8fa6f213cf", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -157,7 +157,7 @@ impl db::RootDatabase {\n             .collect::<Vec<_>>();\n         ret.extend(\n             descr\n-                .scopes(self)\n+                .scopes(self)?\n                 .find_all_refs(binding)\n                 .into_iter()\n                 .map(|ref_desc| (position.file_id, ref_desc.range)),\n@@ -185,7 +185,7 @@ impl db::RootDatabase {\n                 position.file_id,\n                 name_ref.syntax(),\n             )?);\n-            let scope = descr.scopes(db);\n+            let scope = descr.scopes(db)?;\n             let resolved = ctry!(scope.resolve_local_name(name_ref));\n             let resolved = resolved.ptr().resolve(source_file);\n             let binding = ctry!(find_node_at_offset::<ast::BindPat>("}, {"sha": "5bfcedf2bb5825c26fea4106a9771d0311d2c51d", "filename": "crates/ra_db/src/syntax_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, TextRange};\n \n-/// A pionter to a syntax node inside a file.\n+/// A pointer to a syntax node inside a file.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct LocalSyntaxPtr {\n     range: TextRange,"}, {"sha": "96a3c60b9e85b0f86941e552b54fd63510c7578f", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -7,7 +7,7 @@ use crate::{\n     DefLoc, DefId, MacroCallLoc, MacroCallId, Name, HirFileId,\n     SourceFileItems, SourceItemId,\n     query_definitions,\n-    FnScopes,\n+    FnSignature, FnScopes,\n     macros::MacroExpansion,\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n@@ -31,7 +31,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn crate::macros::expand_macro_invocation;\n     }\n \n-    fn fn_scopes(def_id: DefId) -> Arc<FnScopes> {\n+    fn fn_scopes(def_id: DefId) -> Cancelable<Arc<FnScopes>> {\n         type FnScopesQuery;\n         use fn query_definitions::fn_scopes;\n     }\n@@ -93,6 +93,21 @@ pub trait HirDatabase: SyntaxDatabase\n         type ImplsInModuleQuery;\n         use fn crate::impl_block::impls_in_module;\n     }\n+\n+    fn body_hir(def_id: DefId) -> Cancelable<Arc<crate::expr::Body>> {\n+        type BodyHirQuery;\n+        use fn crate::expr::body_hir;\n+    }\n+\n+    fn body_syntax_mapping(def_id: DefId) -> Cancelable<Arc<crate::expr::BodySyntaxMapping>> {\n+        type BodySyntaxMappingQuery;\n+        use fn crate::expr::body_syntax_mapping;\n+    }\n+\n+    fn fn_signature(def_id: DefId) -> Arc<FnSignature> {\n+        type FnSignatureQuery;\n+        use fn crate::function::fn_signature;\n+    }\n }\n \n }"}, {"sha": "6866fc2acfe8e15e1b213c6158b0a8533d05817f", "filename": "crates/ra_hir/src/expr.rs", "status": "added", "additions": 745, "deletions": 0, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -0,0 +1,745 @@\n+use std::ops::Index;\n+use std::sync::Arc;\n+\n+use rustc_hash::FxHashMap;\n+\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_db::{LocalSyntaxPtr, Cancelable};\n+use ra_syntax::ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner};\n+\n+use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ExprId(RawId);\n+impl_arena_id!(ExprId);\n+\n+/// The body of an item (function, const etc.).\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct Body {\n+    exprs: Arena<ExprId, Expr>,\n+    pats: Arena<PatId, Pat>,\n+    /// The patterns for the function's arguments. While the argument types are\n+    /// part of the function signature, the patterns are not (they don't change\n+    /// the external type of the function).\n+    ///\n+    /// If this `Body` is for the body of a constant, this will just be\n+    /// empty.\n+    args: Vec<PatId>,\n+    /// The `ExprId` of the actual body expression.\n+    body_expr: ExprId,\n+}\n+\n+/// An item body together with the mapping from syntax nodes to HIR expression\n+/// IDs. This is needed to go from e.g. a position in a file to the HIR\n+/// expression containing it; but for type inference etc., we want to operate on\n+/// a structure that is agnostic to the actual positions of expressions in the\n+/// file, so that we don't recompute the type inference whenever some whitespace\n+/// is typed.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct BodySyntaxMapping {\n+    body: Arc<Body>,\n+    expr_syntax_mapping: FxHashMap<LocalSyntaxPtr, ExprId>,\n+    expr_syntax_mapping_back: FxHashMap<ExprId, LocalSyntaxPtr>,\n+    pat_syntax_mapping: FxHashMap<LocalSyntaxPtr, PatId>,\n+    pat_syntax_mapping_back: FxHashMap<PatId, LocalSyntaxPtr>,\n+}\n+\n+impl Body {\n+    pub fn args(&self) -> &[PatId] {\n+        &self.args\n+    }\n+\n+    pub fn body_expr(&self) -> ExprId {\n+        self.body_expr\n+    }\n+}\n+\n+impl Index<ExprId> for Body {\n+    type Output = Expr;\n+\n+    fn index(&self, expr: ExprId) -> &Expr {\n+        &self.exprs[expr]\n+    }\n+}\n+\n+impl Index<PatId> for Body {\n+    type Output = Pat;\n+\n+    fn index(&self, pat: PatId) -> &Pat {\n+        &self.pats[pat]\n+    }\n+}\n+\n+impl BodySyntaxMapping {\n+    pub fn expr_syntax(&self, expr: ExprId) -> Option<LocalSyntaxPtr> {\n+        self.expr_syntax_mapping_back.get(&expr).cloned()\n+    }\n+    pub fn syntax_expr(&self, ptr: LocalSyntaxPtr) -> Option<ExprId> {\n+        self.expr_syntax_mapping.get(&ptr).cloned()\n+    }\n+    pub fn pat_syntax(&self, pat: PatId) -> Option<LocalSyntaxPtr> {\n+        self.pat_syntax_mapping_back.get(&pat).cloned()\n+    }\n+    pub fn syntax_pat(&self, ptr: LocalSyntaxPtr) -> Option<PatId> {\n+        self.pat_syntax_mapping.get(&ptr).cloned()\n+    }\n+\n+    pub fn body(&self) -> &Arc<Body> {\n+        &self.body\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Expr {\n+    /// This is produced if syntax tree does not have a required expression piece.\n+    Missing,\n+    Path(Path),\n+    If {\n+        condition: ExprId,\n+        then_branch: ExprId,\n+        else_branch: Option<ExprId>,\n+    },\n+    Block {\n+        statements: Vec<Statement>,\n+        tail: Option<ExprId>,\n+    },\n+    Loop {\n+        body: ExprId,\n+    },\n+    While {\n+        condition: ExprId,\n+        body: ExprId,\n+    },\n+    For {\n+        iterable: ExprId,\n+        pat: PatId,\n+        body: ExprId,\n+    },\n+    Call {\n+        callee: ExprId,\n+        args: Vec<ExprId>,\n+    },\n+    MethodCall {\n+        receiver: ExprId,\n+        method_name: Name,\n+        args: Vec<ExprId>,\n+    },\n+    Match {\n+        expr: ExprId,\n+        arms: Vec<MatchArm>,\n+    },\n+    Continue,\n+    Break {\n+        expr: Option<ExprId>,\n+    },\n+    Return {\n+        expr: Option<ExprId>,\n+    },\n+    StructLit {\n+        path: Option<Path>,\n+        fields: Vec<StructLitField>,\n+        spread: Option<ExprId>,\n+    },\n+    Field {\n+        expr: ExprId,\n+        name: Name,\n+    },\n+    Try {\n+        expr: ExprId,\n+    },\n+    Cast {\n+        expr: ExprId,\n+        type_ref: TypeRef,\n+    },\n+    Ref {\n+        expr: ExprId,\n+        mutability: Mutability,\n+    },\n+    UnaryOp {\n+        expr: ExprId,\n+        op: Option<UnaryOp>,\n+    },\n+    Lambda {\n+        args: Vec<PatId>,\n+        arg_types: Vec<Option<TypeRef>>,\n+        body: ExprId,\n+    },\n+}\n+\n+pub type UnaryOp = ast::PrefixOp;\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MatchArm {\n+    pub pats: Vec<PatId>,\n+    // guard: Option<ExprId>, // TODO\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct StructLitField {\n+    pub name: Name,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Statement {\n+    Let {\n+        pat: PatId,\n+        type_ref: Option<TypeRef>,\n+        initializer: Option<ExprId>,\n+    },\n+    Expr(ExprId),\n+}\n+\n+impl Expr {\n+    pub fn walk_child_exprs(&self, mut f: impl FnMut(ExprId)) {\n+        match self {\n+            Expr::Missing => {}\n+            Expr::Path(_) => {}\n+            Expr::If {\n+                condition,\n+                then_branch,\n+                else_branch,\n+            } => {\n+                f(*condition);\n+                f(*then_branch);\n+                if let Some(else_branch) = else_branch {\n+                    f(*else_branch);\n+                }\n+            }\n+            Expr::Block { statements, tail } => {\n+                for stmt in statements {\n+                    match stmt {\n+                        Statement::Let { initializer, .. } => {\n+                            if let Some(expr) = initializer {\n+                                f(*expr);\n+                            }\n+                        }\n+                        Statement::Expr(e) => f(*e),\n+                    }\n+                }\n+                if let Some(expr) = tail {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::Loop { body } => f(*body),\n+            Expr::While { condition, body } => {\n+                f(*condition);\n+                f(*body);\n+            }\n+            Expr::For { iterable, body, .. } => {\n+                f(*iterable);\n+                f(*body);\n+            }\n+            Expr::Call { callee, args } => {\n+                f(*callee);\n+                for arg in args {\n+                    f(*arg);\n+                }\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                f(*receiver);\n+                for arg in args {\n+                    f(*arg);\n+                }\n+            }\n+            Expr::Match { expr, arms } => {\n+                f(*expr);\n+                for arm in arms {\n+                    f(arm.expr);\n+                }\n+            }\n+            Expr::Continue => {}\n+            Expr::Break { expr } | Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::StructLit { fields, spread, .. } => {\n+                for field in fields {\n+                    f(field.expr);\n+                }\n+                if let Some(expr) = spread {\n+                    f(*expr);\n+                }\n+            }\n+            Expr::Lambda { body, .. } => {\n+                f(*body);\n+            }\n+            Expr::Field { expr, .. }\n+            | Expr::Try { expr }\n+            | Expr::Cast { expr, .. }\n+            | Expr::Ref { expr, .. }\n+            | Expr::UnaryOp { expr, .. } => {\n+                f(*expr);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct PatId(RawId);\n+impl_arena_id!(PatId);\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Pat {\n+    Missing,\n+    Bind {\n+        name: Name,\n+    },\n+    TupleStruct {\n+        path: Option<Path>,\n+        args: Vec<PatId>,\n+    },\n+}\n+\n+impl Pat {\n+    pub fn walk_child_pats(&self, f: impl FnMut(PatId)) {\n+        match self {\n+            Pat::Missing | Pat::Bind { .. } => {}\n+            Pat::TupleStruct { args, .. } => {\n+                args.iter().map(|pat| *pat).for_each(f);\n+            }\n+        }\n+    }\n+}\n+\n+// Queries\n+\n+pub(crate) fn body_hir(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<Body>> {\n+    Ok(Arc::clone(&body_syntax_mapping(db, def_id)?.body))\n+}\n+\n+struct ExprCollector {\n+    exprs: Arena<ExprId, Expr>,\n+    pats: Arena<PatId, Pat>,\n+    expr_syntax_mapping: FxHashMap<LocalSyntaxPtr, ExprId>,\n+    expr_syntax_mapping_back: FxHashMap<ExprId, LocalSyntaxPtr>,\n+    pat_syntax_mapping: FxHashMap<LocalSyntaxPtr, PatId>,\n+    pat_syntax_mapping_back: FxHashMap<PatId, LocalSyntaxPtr>,\n+}\n+\n+impl ExprCollector {\n+    fn new() -> Self {\n+        ExprCollector {\n+            exprs: Arena::default(),\n+            pats: Arena::default(),\n+            expr_syntax_mapping: FxHashMap::default(),\n+            expr_syntax_mapping_back: FxHashMap::default(),\n+            pat_syntax_mapping: FxHashMap::default(),\n+            pat_syntax_mapping_back: FxHashMap::default(),\n+        }\n+    }\n+\n+    fn alloc_expr(&mut self, expr: Expr, syntax_ptr: LocalSyntaxPtr) -> ExprId {\n+        let id = self.exprs.alloc(expr);\n+        self.expr_syntax_mapping.insert(syntax_ptr, id);\n+        self.expr_syntax_mapping_back.insert(id, syntax_ptr);\n+        id\n+    }\n+\n+    fn alloc_pat(&mut self, pat: Pat, syntax_ptr: LocalSyntaxPtr) -> PatId {\n+        let id = self.pats.alloc(pat);\n+        self.pat_syntax_mapping.insert(syntax_ptr, id);\n+        self.pat_syntax_mapping_back.insert(id, syntax_ptr);\n+        id\n+    }\n+\n+    fn empty_block(&mut self) -> ExprId {\n+        let block = Expr::Block {\n+            statements: Vec::new(),\n+            tail: None,\n+        };\n+        self.exprs.alloc(block)\n+    }\n+\n+    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n+        let syntax_ptr = LocalSyntaxPtr::new(expr.syntax());\n+        match expr {\n+            ast::Expr::IfExpr(e) => {\n+                if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n+                    // if let -- desugar to match\n+                    let pat = self.collect_pat(pat);\n+                    let match_expr =\n+                        self.collect_expr_opt(e.condition().expect(\"checked above\").expr());\n+                    let then_branch = self.collect_block_opt(e.then_branch());\n+                    let else_branch = e\n+                        .else_branch()\n+                        .map(|e| self.collect_block(e))\n+                        .unwrap_or_else(|| self.empty_block());\n+                    let placeholder_pat = self.pats.alloc(Pat::Missing);\n+                    let arms = vec![\n+                        MatchArm {\n+                            pats: vec![pat],\n+                            expr: then_branch,\n+                        },\n+                        MatchArm {\n+                            pats: vec![placeholder_pat],\n+                            expr: else_branch,\n+                        },\n+                    ];\n+                    self.alloc_expr(\n+                        Expr::Match {\n+                            expr: match_expr,\n+                            arms,\n+                        },\n+                        syntax_ptr,\n+                    )\n+                } else {\n+                    let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()));\n+                    let then_branch = self.collect_block_opt(e.then_branch());\n+                    let else_branch = e.else_branch().map(|e| self.collect_block(e));\n+                    self.alloc_expr(\n+                        Expr::If {\n+                            condition,\n+                            then_branch,\n+                            else_branch,\n+                        },\n+                        syntax_ptr,\n+                    )\n+                }\n+            }\n+            ast::Expr::BlockExpr(e) => self.collect_block_opt(e.block()),\n+            ast::Expr::LoopExpr(e) => {\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n+            }\n+            ast::Expr::WhileExpr(e) => {\n+                let condition = if let Some(condition) = e.condition() {\n+                    if condition.pat().is_none() {\n+                        self.collect_expr_opt(condition.expr())\n+                    } else {\n+                        // TODO handle while let\n+                        return self.alloc_expr(Expr::Missing, syntax_ptr);\n+                    }\n+                } else {\n+                    self.exprs.alloc(Expr::Missing)\n+                };\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n+            }\n+            ast::Expr::ForExpr(e) => {\n+                let iterable = self.collect_expr_opt(e.iterable());\n+                let pat = self.collect_pat_opt(e.pat());\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(\n+                    Expr::For {\n+                        iterable,\n+                        pat,\n+                        body,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::CallExpr(e) => {\n+                let callee = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n+            }\n+            ast::Expr::MethodCallExpr(e) => {\n+                let receiver = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().map(|e| self.collect_expr(e)).collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                let method_name = e\n+                    .name_ref()\n+                    .map(|nr| nr.as_name())\n+                    .unwrap_or_else(Name::missing);\n+                self.alloc_expr(\n+                    Expr::MethodCall {\n+                        receiver,\n+                        method_name,\n+                        args,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::MatchExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n+                    match_arm_list\n+                        .arms()\n+                        .map(|arm| MatchArm {\n+                            pats: arm.pats().map(|p| self.collect_pat(p)).collect(),\n+                            expr: self.collect_expr_opt(arm.expr()),\n+                        })\n+                        .collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+            }\n+            ast::Expr::PathExpr(e) => {\n+                let path = e\n+                    .path()\n+                    .and_then(Path::from_ast)\n+                    .map(Expr::Path)\n+                    .unwrap_or(Expr::Missing);\n+                self.alloc_expr(path, syntax_ptr)\n+            }\n+            ast::Expr::ContinueExpr(_e) => {\n+                // TODO: labels\n+                self.alloc_expr(Expr::Continue, syntax_ptr)\n+            }\n+            ast::Expr::BreakExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n+            }\n+            ast::Expr::ParenExpr(e) => {\n+                let inner = self.collect_expr_opt(e.expr());\n+                // make the paren expr point to the inner expression as well\n+                self.expr_syntax_mapping.insert(syntax_ptr, inner);\n+                inner\n+            }\n+            ast::Expr::ReturnExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n+            }\n+            ast::Expr::StructLit(e) => {\n+                let path = e.path().and_then(Path::from_ast);\n+                let fields = if let Some(nfl) = e.named_field_list() {\n+                    nfl.fields()\n+                        .map(|field| StructLitField {\n+                            name: field\n+                                .name_ref()\n+                                .map(|nr| nr.as_name())\n+                                .unwrap_or_else(Name::missing),\n+                            expr: if let Some(e) = field.expr() {\n+                                self.collect_expr(e)\n+                            } else if let Some(nr) = field.name_ref() {\n+                                // field shorthand\n+                                let id = self.exprs.alloc(Expr::Path(Path::from_name_ref(nr)));\n+                                self.expr_syntax_mapping\n+                                    .insert(LocalSyntaxPtr::new(nr.syntax()), id);\n+                                self.expr_syntax_mapping_back\n+                                    .insert(id, LocalSyntaxPtr::new(nr.syntax()));\n+                                id\n+                            } else {\n+                                self.exprs.alloc(Expr::Missing)\n+                            },\n+                        })\n+                        .collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                let spread = e.spread().map(|s| self.collect_expr(s));\n+                self.alloc_expr(\n+                    Expr::StructLit {\n+                        path,\n+                        fields,\n+                        spread,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::FieldExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let name = e\n+                    .name_ref()\n+                    .map(|nr| nr.as_name())\n+                    .unwrap_or_else(Name::missing);\n+                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n+            }\n+            ast::Expr::TryExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n+            }\n+            ast::Expr::CastExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let type_ref = TypeRef::from_ast_opt(e.type_ref());\n+                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n+            }\n+            ast::Expr::RefExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let mutability = Mutability::from_mutable(e.is_mut());\n+                self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n+            }\n+            ast::Expr::PrefixExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let op = e.op();\n+                self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n+            }\n+            ast::Expr::LambdaExpr(e) => {\n+                let mut args = Vec::new();\n+                let mut arg_types = Vec::new();\n+                if let Some(pl) = e.param_list() {\n+                    for param in pl.params() {\n+                        let pat = self.collect_pat_opt(param.pat());\n+                        let type_ref = param.type_ref().map(TypeRef::from_ast);\n+                        args.push(pat);\n+                        arg_types.push(type_ref);\n+                    }\n+                }\n+                let body = self.collect_expr_opt(e.body());\n+                self.alloc_expr(\n+                    Expr::Lambda {\n+                        args,\n+                        arg_types,\n+                        body,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+\n+            // TODO implement HIR for these:\n+            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::TupleExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::BinExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+        }\n+    }\n+\n+    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n+        if let Some(expr) = expr {\n+            self.collect_expr(expr)\n+        } else {\n+            self.exprs.alloc(Expr::Missing)\n+        }\n+    }\n+\n+    fn collect_block(&mut self, block: ast::Block) -> ExprId {\n+        let statements = block\n+            .statements()\n+            .map(|s| match s {\n+                ast::Stmt::LetStmt(stmt) => {\n+                    let pat = self.collect_pat_opt(stmt.pat());\n+                    let type_ref = stmt.type_ref().map(TypeRef::from_ast);\n+                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                    Statement::Let {\n+                        pat,\n+                        type_ref,\n+                        initializer,\n+                    }\n+                }\n+                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n+            })\n+            .collect();\n+        let tail = block.expr().map(|e| self.collect_expr(e));\n+        self.alloc_expr(\n+            Expr::Block { statements, tail },\n+            LocalSyntaxPtr::new(block.syntax()),\n+        )\n+    }\n+\n+    fn collect_block_opt(&mut self, block: Option<ast::Block>) -> ExprId {\n+        if let Some(block) = block {\n+            self.collect_block(block)\n+        } else {\n+            self.exprs.alloc(Expr::Missing)\n+        }\n+    }\n+\n+    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+        let syntax_ptr = LocalSyntaxPtr::new(pat.syntax());\n+        match pat {\n+            ast::Pat::BindPat(bp) => {\n+                let name = bp\n+                    .name()\n+                    .map(|nr| nr.as_name())\n+                    .unwrap_or_else(Name::missing);\n+                self.alloc_pat(Pat::Bind { name }, syntax_ptr)\n+            }\n+            ast::Pat::TupleStructPat(p) => {\n+                let path = p.path().and_then(Path::from_ast);\n+                let args = p.args().map(|p| self.collect_pat(p)).collect();\n+                self.alloc_pat(Pat::TupleStruct { path, args }, syntax_ptr)\n+            }\n+            _ => {\n+                // TODO\n+                self.alloc_pat(Pat::Missing, syntax_ptr)\n+            }\n+        }\n+    }\n+\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+        if let Some(pat) = pat {\n+            self.collect_pat(pat)\n+        } else {\n+            self.pats.alloc(Pat::Missing)\n+        }\n+    }\n+\n+    fn into_body_syntax_mapping(self, args: Vec<PatId>, body_expr: ExprId) -> BodySyntaxMapping {\n+        let body = Body {\n+            exprs: self.exprs,\n+            pats: self.pats,\n+            args,\n+            body_expr,\n+        };\n+        BodySyntaxMapping {\n+            body: Arc::new(body),\n+            expr_syntax_mapping: self.expr_syntax_mapping,\n+            expr_syntax_mapping_back: self.expr_syntax_mapping_back,\n+            pat_syntax_mapping: self.pat_syntax_mapping,\n+            pat_syntax_mapping_back: self.pat_syntax_mapping_back,\n+        }\n+    }\n+}\n+\n+pub(crate) fn collect_fn_body_syntax(node: ast::FnDef) -> BodySyntaxMapping {\n+    let mut collector = ExprCollector::new();\n+\n+    let args = if let Some(param_list) = node.param_list() {\n+        let mut args = Vec::new();\n+\n+        if let Some(self_param) = param_list.self_param() {\n+            let self_param = LocalSyntaxPtr::new(\n+                self_param\n+                    .self_kw()\n+                    .expect(\"self param without self keyword\")\n+                    .syntax(),\n+            );\n+            let arg = collector.alloc_pat(\n+                Pat::Bind {\n+                    name: Name::self_param(),\n+                },\n+                self_param,\n+            );\n+            args.push(arg);\n+        }\n+\n+        for param in param_list.params() {\n+            let pat = if let Some(pat) = param.pat() {\n+                pat\n+            } else {\n+                continue;\n+            };\n+            args.push(collector.collect_pat(pat));\n+        }\n+        args\n+    } else {\n+        Vec::new()\n+    };\n+\n+    let body = collector.collect_block_opt(node.body());\n+    collector.into_body_syntax_mapping(args, body)\n+}\n+\n+pub(crate) fn body_syntax_mapping(\n+    db: &impl HirDatabase,\n+    def_id: DefId,\n+) -> Cancelable<Arc<BodySyntaxMapping>> {\n+    let def = def_id.resolve(db)?;\n+\n+    let body_syntax_mapping = match def {\n+        Def::Function(f) => {\n+            let node = f.syntax(db);\n+            let node = node.borrowed();\n+\n+            collect_fn_body_syntax(node)\n+        }\n+        // TODO: consts, etc.\n+        _ => panic!(\"Trying to get body for item type without body\"),\n+    };\n+\n+    Ok(Arc::new(body_syntax_mapping))\n+}"}, {"sha": "4627be071f12efac54f46a4443a70a6fe6f4af91", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -11,9 +11,9 @@ use ra_syntax::{\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n };\n \n-use crate::{DefId, DefKind, HirDatabase, ty::InferenceResult, Module, Crate, impl_block::ImplBlock};\n+use crate::{DefId, DefKind, HirDatabase, ty::InferenceResult, Module, Crate, impl_block::ImplBlock, expr::{Body, BodySyntaxMapping}, type_ref::{TypeRef, Mutability}, Name};\n \n-pub use self::scope::FnScopes;\n+pub use self::scope::{FnScopes, ScopesWithSyntaxMapping};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Function {\n@@ -36,8 +36,25 @@ impl Function {\n         ast::FnDef::cast(syntax.borrowed()).unwrap().owned()\n     }\n \n-    pub fn scopes(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n-        db.fn_scopes(self.def_id)\n+    pub fn body(&self, db: &impl HirDatabase) -> Cancelable<Arc<Body>> {\n+        db.body_hir(self.def_id)\n+    }\n+\n+    pub fn body_syntax_mapping(&self, db: &impl HirDatabase) -> Cancelable<Arc<BodySyntaxMapping>> {\n+        db.body_syntax_mapping(self.def_id)\n+    }\n+\n+    pub fn scopes(&self, db: &impl HirDatabase) -> Cancelable<ScopesWithSyntaxMapping> {\n+        let scopes = db.fn_scopes(self.def_id)?;\n+        let syntax_mapping = db.body_syntax_mapping(self.def_id)?;\n+        Ok(ScopesWithSyntaxMapping {\n+            scopes,\n+            syntax_mapping,\n+        })\n+    }\n+\n+    pub fn signature(&self, db: &impl HirDatabase) -> Arc<FnSignature> {\n+        db.fn_signature(self.def_id)\n     }\n \n     pub fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n@@ -63,6 +80,60 @@ impl Function {\n     }\n }\n \n+/// The declared signature of a function.\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct FnSignature {\n+    args: Vec<TypeRef>,\n+    ret_type: TypeRef,\n+}\n+\n+impl FnSignature {\n+    pub fn args(&self) -> &[TypeRef] {\n+        &self.args\n+    }\n+\n+    pub fn ret_type(&self) -> &TypeRef {\n+        &self.ret_type\n+    }\n+}\n+\n+pub(crate) fn fn_signature(db: &impl HirDatabase, def_id: DefId) -> Arc<FnSignature> {\n+    let func = Function::new(def_id);\n+    let syntax = func.syntax(db);\n+    let node = syntax.borrowed();\n+    let mut args = Vec::new();\n+    if let Some(param_list) = node.param_list() {\n+        if let Some(self_param) = param_list.self_param() {\n+            let self_type = if let Some(type_ref) = self_param.type_ref() {\n+                TypeRef::from_ast(type_ref)\n+            } else {\n+                let self_type = TypeRef::Path(Name::self_type().into());\n+                match self_param.flavor() {\n+                    ast::SelfParamFlavor::Owned => self_type,\n+                    ast::SelfParamFlavor::Ref => {\n+                        TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n+                    }\n+                    ast::SelfParamFlavor::MutRef => {\n+                        TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n+                    }\n+                }\n+            };\n+            args.push(self_type);\n+        }\n+        for param in param_list.params() {\n+            let type_ref = TypeRef::from_ast_opt(param.type_ref());\n+            args.push(type_ref);\n+        }\n+    }\n+    let ret_type = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n+        TypeRef::from_ast(type_ref)\n+    } else {\n+        TypeRef::unit()\n+    };\n+    let sig = FnSignature { args, ret_type };\n+    Arc::new(sig)\n+}\n+\n #[derive(Debug, Clone)]\n pub struct FnSignatureInfo {\n     pub name: String,"}, {"sha": "0a12f0b35b66108cf8bd799cf8ff00aa368164bd", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 177, "deletions": 191, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -1,30 +1,32 @@\n+use std::sync::Arc;\n+\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n     AstNode, SyntaxNodeRef, TextUnit, TextRange,\n     algo::generate,\n-    ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n+    ast,\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::LocalSyntaxPtr;\n \n-use crate::{Name, AsName};\n+use crate::{Name, AsName, expr::{PatId, ExprId, Pat, Expr, Body, Statement, BodySyntaxMapping}};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ScopeId(RawId);\n impl_arena_id!(ScopeId);\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct FnScopes {\n-    pub self_param: Option<LocalSyntaxPtr>,\n+    body: Arc<Body>,\n     scopes: Arena<ScopeId, ScopeData>,\n-    scope_for: FxHashMap<LocalSyntaxPtr, ScopeId>,\n+    scope_for: FxHashMap<ExprId, ScopeId>,\n }\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct ScopeEntry {\n     name: Name,\n-    ptr: LocalSyntaxPtr,\n+    pat: PatId,\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -34,55 +36,131 @@ pub struct ScopeData {\n }\n \n impl FnScopes {\n-    pub(crate) fn new(fn_def: ast::FnDef) -> FnScopes {\n+    pub(crate) fn new(body: Arc<Body>) -> FnScopes {\n         let mut scopes = FnScopes {\n-            self_param: fn_def\n-                .param_list()\n-                .and_then(|it| it.self_param())\n-                .map(|it| LocalSyntaxPtr::new(it.syntax())),\n+            body: body.clone(),\n             scopes: Arena::default(),\n             scope_for: FxHashMap::default(),\n         };\n         let root = scopes.root_scope();\n-        scopes.add_params_bindings(root, fn_def.param_list());\n-        if let Some(body) = fn_def.body() {\n-            compute_block_scopes(body, &mut scopes, root)\n-        }\n+        scopes.add_params_bindings(root, body.args());\n+        compute_expr_scopes(body.body_expr(), &body, &mut scopes, root);\n         scopes\n     }\n     pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n         &self.scopes[scope].entries\n     }\n+    pub fn scope_chain_for<'a>(&'a self, expr: ExprId) -> impl Iterator<Item = ScopeId> + 'a {\n+        generate(self.scope_for(expr), move |&scope| {\n+            self.scopes[scope].parent\n+        })\n+    }\n+\n+    pub fn resolve_local_name<'a>(\n+        &'a self,\n+        context_expr: ExprId,\n+        name: Name,\n+    ) -> Option<&'a ScopeEntry> {\n+        let mut shadowed = FxHashSet::default();\n+        let ret = self\n+            .scope_chain_for(context_expr)\n+            .flat_map(|scope| self.entries(scope).iter())\n+            .filter(|entry| shadowed.insert(entry.name()))\n+            .find(|entry| entry.name() == &name);\n+        ret\n+    }\n+\n+    fn root_scope(&mut self) -> ScopeId {\n+        self.scopes.alloc(ScopeData {\n+            parent: None,\n+            entries: vec![],\n+        })\n+    }\n+    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            entries: vec![],\n+        })\n+    }\n+    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n+        match &body[pat] {\n+            Pat::Bind { name } => self.scopes[scope].entries.push(ScopeEntry {\n+                name: name.clone(),\n+                pat,\n+            }),\n+            p => p.walk_child_pats(|pat| self.add_bindings(body, scope, pat)),\n+        }\n+    }\n+    fn add_params_bindings(&mut self, scope: ScopeId, params: &[PatId]) {\n+        let body = Arc::clone(&self.body);\n+        params\n+            .into_iter()\n+            .for_each(|pat| self.add_bindings(&body, scope, *pat));\n+    }\n+    fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n+        self.scope_for.insert(node, scope);\n+    }\n+    fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n+        self.scope_for.get(&expr).map(|&scope| scope)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ScopesWithSyntaxMapping {\n+    pub syntax_mapping: Arc<BodySyntaxMapping>,\n+    pub scopes: Arc<FnScopes>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ScopeEntryWithSyntax {\n+    name: Name,\n+    ptr: LocalSyntaxPtr,\n+}\n+\n+impl ScopeEntryWithSyntax {\n+    pub fn name(&self) -> &Name {\n+        &self.name\n+    }\n+    pub fn ptr(&self) -> LocalSyntaxPtr {\n+        self.ptr\n+    }\n+}\n+\n+impl ScopesWithSyntaxMapping {\n     pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n         generate(self.scope_for(node), move |&scope| {\n-            self.scopes[scope].parent\n+            self.scopes.scopes[scope].parent\n         })\n     }\n     pub fn scope_chain_for_offset<'a>(\n         &'a self,\n         offset: TextUnit,\n     ) -> impl Iterator<Item = ScopeId> + 'a {\n         let scope = self\n+            .scopes\n             .scope_for\n             .iter()\n-            // find containin scope\n+            .filter_map(|(id, scope)| Some((self.syntax_mapping.expr_syntax(*id)?, scope)))\n+            // find containing scope\n             .min_by_key(|(ptr, _scope)| {\n                 (\n                     !(ptr.range().start() <= offset && offset <= ptr.range().end()),\n                     ptr.range().len(),\n                 )\n             })\n-            .map(|(ptr, scope)| self.adjust(*ptr, *scope, offset));\n+            .map(|(ptr, scope)| self.adjust(ptr, *scope, offset));\n \n-        generate(scope, move |&scope| self.scopes[scope].parent)\n+        generate(scope, move |&scope| self.scopes.scopes[scope].parent)\n     }\n     // XXX: during completion, cursor might be outside of any particular\n     // expression. Try to figure out the correct scope...\n     fn adjust(&self, ptr: LocalSyntaxPtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n         let r = ptr.range();\n         let child_scopes = self\n+            .scopes\n             .scope_for\n             .iter()\n+            .filter_map(|(id, scope)| Some((self.syntax_mapping.expr_syntax(*id)?, scope)))\n             .map(|(ptr, scope)| (ptr.range(), scope))\n             .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);\n \n@@ -100,22 +178,27 @@ impl FnScopes {\n             .unwrap_or(original_scope)\n     }\n \n-    pub fn resolve_local_name<'a>(&'a self, name_ref: ast::NameRef) -> Option<&'a ScopeEntry> {\n+    pub fn resolve_local_name(&self, name_ref: ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n         let mut shadowed = FxHashSet::default();\n         let name = name_ref.as_name();\n         let ret = self\n             .scope_chain(name_ref.syntax())\n-            .flat_map(|scope| self.entries(scope).iter())\n+            .flat_map(|scope| self.scopes.entries(scope).iter())\n             .filter(|entry| shadowed.insert(entry.name()))\n             .filter(|entry| entry.name() == &name)\n             .nth(0);\n-        ret\n+        ret.and_then(|entry| {\n+            Some(ScopeEntryWithSyntax {\n+                name: entry.name().clone(),\n+                ptr: self.syntax_mapping.pat_syntax(entry.pat())?,\n+            })\n+        })\n     }\n \n     pub fn find_all_refs(&self, pat: ast::BindPat) -> Vec<ReferenceDescriptor> {\n         let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n         let name_ptr = LocalSyntaxPtr::new(pat.syntax());\n-        let refs: Vec<_> = fn_def\n+        fn_def\n             .syntax()\n             .descendants()\n             .filter_map(ast::NameRef::cast)\n@@ -127,203 +210,94 @@ impl FnScopes {\n                 name: name_ref.syntax().text().to_string(),\n                 range: name_ref.syntax().range(),\n             })\n-            .collect();\n-\n-        refs\n+            .collect()\n     }\n \n-    fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData {\n-            parent: None,\n-            entries: vec![],\n-        })\n-    }\n-    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        self.scopes.alloc(ScopeData {\n-            parent: Some(parent),\n-            entries: vec![],\n-        })\n-    }\n-    fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n-        let entries = pat\n-            .syntax()\n-            .descendants()\n-            .filter_map(ast::BindPat::cast)\n-            .filter_map(ScopeEntry::new);\n-        self.scopes[scope].entries.extend(entries);\n-    }\n-    fn add_params_bindings(&mut self, scope: ScopeId, params: Option<ast::ParamList>) {\n-        params\n-            .into_iter()\n-            .flat_map(|it| it.params())\n-            .filter_map(|it| it.pat())\n-            .for_each(|it| self.add_bindings(scope, it));\n-    }\n-    fn set_scope(&mut self, node: SyntaxNodeRef, scope: ScopeId) {\n-        self.scope_for.insert(LocalSyntaxPtr::new(node), scope);\n-    }\n     fn scope_for(&self, node: SyntaxNodeRef) -> Option<ScopeId> {\n         node.ancestors()\n             .map(LocalSyntaxPtr::new)\n-            .filter_map(|it| self.scope_for.get(&it).map(|&scope| scope))\n-            .next()\n+            .filter_map(|ptr| self.syntax_mapping.syntax_expr(ptr))\n+            .find_map(|it| self.scopes.scope_for(it))\n     }\n }\n \n impl ScopeEntry {\n-    fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n-        let name = pat.name()?.as_name();\n-        let res = ScopeEntry {\n-            name,\n-            ptr: LocalSyntaxPtr::new(pat.syntax()),\n-        };\n-        Some(res)\n-    }\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n-    pub fn ptr(&self) -> LocalSyntaxPtr {\n-        self.ptr\n+    pub fn pat(&self) -> PatId {\n+        self.pat\n     }\n }\n \n-fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n-    // A hack for completion :(\n-    scopes.set_scope(block.syntax(), scope);\n-    for stmt in block.statements() {\n+fn compute_block_scopes(\n+    statements: &[Statement],\n+    tail: Option<ExprId>,\n+    body: &Body,\n+    scopes: &mut FnScopes,\n+    mut scope: ScopeId,\n+) {\n+    for stmt in statements {\n         match stmt {\n-            ast::Stmt::LetStmt(stmt) => {\n-                if let Some(expr) = stmt.initializer() {\n-                    scopes.set_scope(expr.syntax(), scope);\n-                    compute_expr_scopes(expr, scopes, scope);\n+            Statement::Let {\n+                pat, initializer, ..\n+            } => {\n+                if let Some(expr) = initializer {\n+                    scopes.set_scope(*expr, scope);\n+                    compute_expr_scopes(*expr, body, scopes, scope);\n                 }\n                 scope = scopes.new_scope(scope);\n-                if let Some(pat) = stmt.pat() {\n-                    scopes.add_bindings(scope, pat);\n-                }\n+                scopes.add_bindings(body, scope, *pat);\n             }\n-            ast::Stmt::ExprStmt(expr_stmt) => {\n-                if let Some(expr) = expr_stmt.expr() {\n-                    scopes.set_scope(expr.syntax(), scope);\n-                    compute_expr_scopes(expr, scopes, scope);\n-                }\n+            Statement::Expr(expr) => {\n+                scopes.set_scope(*expr, scope);\n+                compute_expr_scopes(*expr, body, scopes, scope);\n             }\n         }\n     }\n-    if let Some(expr) = block.expr() {\n-        scopes.set_scope(expr.syntax(), scope);\n-        compute_expr_scopes(expr, scopes, scope);\n+    if let Some(expr) = tail {\n+        compute_expr_scopes(expr, body, scopes, scope);\n     }\n }\n \n-fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n-    match expr {\n-        ast::Expr::IfExpr(e) => {\n-            let cond_scope = e\n-                .condition()\n-                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n-            if let Some(block) = e.then_branch() {\n-                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n-            }\n-            if let Some(block) = e.else_branch() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::BlockExpr(e) => {\n-            if let Some(block) = e.block() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::LoopExpr(e) => {\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::WhileExpr(e) => {\n-            let cond_scope = e\n-                .condition()\n-                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n-            }\n+fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut FnScopes, scope: ScopeId) {\n+    scopes.set_scope(expr, scope);\n+    match &body[expr] {\n+        Expr::Block { statements, tail } => {\n+            compute_block_scopes(&statements, *tail, body, scopes, scope);\n         }\n-        ast::Expr::ForExpr(e) => {\n-            if let Some(expr) = e.iterable() {\n-                compute_expr_scopes(expr, scopes, scope);\n-            }\n-            let mut scope = scope;\n-            if let Some(pat) = e.pat() {\n-                scope = scopes.new_scope(scope);\n-                scopes.add_bindings(scope, pat);\n-            }\n-            if let Some(block) = e.loop_body() {\n-                compute_block_scopes(block, scopes, scope);\n-            }\n-        }\n-        ast::Expr::LambdaExpr(e) => {\n+        Expr::For {\n+            iterable,\n+            pat,\n+            body: body_expr,\n+        } => {\n+            compute_expr_scopes(*iterable, body, scopes, scope);\n             let scope = scopes.new_scope(scope);\n-            scopes.add_params_bindings(scope, e.param_list());\n-            if let Some(body) = e.body() {\n-                scopes.set_scope(body.syntax(), scope);\n-                compute_expr_scopes(body, scopes, scope);\n-            }\n+            scopes.add_bindings(body, scope, *pat);\n+            compute_expr_scopes(*body_expr, body, scopes, scope);\n         }\n-        ast::Expr::CallExpr(e) => {\n-            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n-        }\n-        ast::Expr::MethodCallExpr(e) => {\n-            compute_call_scopes(e.expr(), e.arg_list(), scopes, scope);\n+        Expr::Lambda {\n+            args,\n+            body: body_expr,\n+            ..\n+        } => {\n+            let scope = scopes.new_scope(scope);\n+            scopes.add_params_bindings(scope, &args);\n+            compute_expr_scopes(*body_expr, body, scopes, scope);\n         }\n-        ast::Expr::MatchExpr(e) => {\n-            if let Some(expr) = e.expr() {\n-                compute_expr_scopes(expr, scopes, scope);\n-            }\n-            for arm in e.match_arm_list().into_iter().flat_map(|it| it.arms()) {\n+        Expr::Match { expr, arms } => {\n+            compute_expr_scopes(*expr, body, scopes, scope);\n+            for arm in arms {\n                 let scope = scopes.new_scope(scope);\n-                for pat in arm.pats() {\n-                    scopes.add_bindings(scope, pat);\n-                }\n-                if let Some(expr) = arm.expr() {\n-                    compute_expr_scopes(expr, scopes, scope);\n+                for pat in &arm.pats {\n+                    scopes.add_bindings(body, scope, *pat);\n                 }\n+                scopes.set_scope(arm.expr, scope);\n+                compute_expr_scopes(arm.expr, body, scopes, scope);\n             }\n         }\n-        _ => expr\n-            .syntax()\n-            .children()\n-            .filter_map(ast::Expr::cast)\n-            .for_each(|expr| compute_expr_scopes(expr, scopes, scope)),\n+        e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n     };\n-\n-    fn compute_call_scopes(\n-        receiver: Option<ast::Expr>,\n-        arg_list: Option<ast::ArgList>,\n-        scopes: &mut FnScopes,\n-        scope: ScopeId,\n-    ) {\n-        arg_list\n-            .into_iter()\n-            .flat_map(|it| it.args())\n-            .chain(receiver)\n-            .for_each(|expr| compute_expr_scopes(expr, scopes, scope));\n-    }\n-\n-    fn compute_cond_scopes(\n-        cond: ast::Condition,\n-        scopes: &mut FnScopes,\n-        scope: ScopeId,\n-    ) -> Option<ScopeId> {\n-        if let Some(expr) = cond.expr() {\n-            compute_expr_scopes(expr, scopes, scope);\n-        }\n-        if let Some(pat) = cond.pat() {\n-            let s = scopes.new_scope(scope);\n-            scopes.add_bindings(s, pat);\n-            Some(s)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n #[derive(Debug)]\n@@ -338,6 +312,8 @@ mod tests {\n     use ra_syntax::SourceFileNode;\n     use test_utils::{extract_offset, assert_eq_text};\n \n+    use crate::expr;\n+\n     use super::*;\n \n     fn do_check(code: &str, expected: &[&str]) {\n@@ -353,15 +329,20 @@ mod tests {\n         let file = SourceFileNode::parse(&code);\n         let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let scopes = FnScopes::new(fn_def);\n+        let body_hir = expr::collect_fn_body_syntax(fn_def);\n+        let scopes = FnScopes::new(Arc::clone(body_hir.body()));\n+        let scopes = ScopesWithSyntaxMapping {\n+            scopes: Arc::new(scopes),\n+            syntax_mapping: Arc::new(body_hir),\n+        };\n         let actual = scopes\n             .scope_chain(marker.syntax())\n-            .flat_map(|scope| scopes.entries(scope))\n+            .flat_map(|scope| scopes.scopes.entries(scope))\n             .map(|it| it.name().to_string())\n             .collect::<Vec<_>>()\n             .join(\"\\n\");\n         let expected = expected.join(\"\\n\");\n-        assert_eq_text!(&actual, &expected);\n+        assert_eq_text!(&expected, &actual);\n     }\n \n     #[test]\n@@ -389,7 +370,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_metod_call_scope() {\n+    fn test_method_call_scope() {\n         do_check(\n             r\"\n             fn quux() {\n@@ -445,10 +426,15 @@ mod tests {\n         let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n \n-        let scopes = FnScopes::new(fn_def);\n+        let body_hir = expr::collect_fn_body_syntax(fn_def);\n+        let scopes = FnScopes::new(Arc::clone(body_hir.body()));\n+        let scopes = ScopesWithSyntaxMapping {\n+            scopes: Arc::new(scopes),\n+            syntax_mapping: Arc::new(body_hir),\n+        };\n \n         let local_name_entry = scopes.resolve_local_name(name_ref).unwrap();\n-        let local_name = local_name_entry.ptr().resolve(&file);\n+        let local_name = local_name_entry.ptr();\n         let expected_name =\n             find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();\n         assert_eq!(local_name.range(), expected_name.syntax().range());"}, {"sha": "d600b91df3184a1974fb4a9414d25b519b0ec9b6", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -32,6 +32,7 @@ mod adt;\n mod type_ref;\n mod ty;\n mod impl_block;\n+mod expr;\n \n use crate::{\n     db::HirDatabase,\n@@ -46,7 +47,7 @@ pub use self::{\n     ids::{HirFileId, DefId, DefLoc, MacroCallId, MacroCallLoc},\n     macros::{MacroDef, MacroInput, MacroExpansion},\n     module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n-    function::{Function, FnScopes},\n+    function::{Function, FnSignature, FnScopes, ScopesWithSyntaxMapping},\n     adt::{Struct, Enum},\n     ty::Ty,\n     impl_block::{ImplBlock, ImplItem},"}, {"sha": "8d176662cd13e27786f019333dfed4e4b04fc86a", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -208,6 +208,9 @@ salsa::database_storage! {\n             fn struct_data() for db::StructDataQuery;\n             fn enum_data() for db::EnumDataQuery;\n             fn impls_in_module() for db::ImplsInModuleQuery;\n+            fn body_hir() for db::BodyHirQuery;\n+            fn body_syntax_mapping() for db::BodySyntaxMappingQuery;\n+            fn fn_signature() for db::FnSignatureQuery;\n         }\n     }\n }"}, {"sha": "90229bc5404e072000d2492efe45ea8ac6c50d76", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -31,6 +31,14 @@ impl Name {\n         Name::new(\"[missing name]\".into())\n     }\n \n+    pub(crate) fn self_param() -> Name {\n+        Name::new(\"self\".into())\n+    }\n+\n+    pub(crate) fn self_type() -> Name {\n+        Name::new(\"Self\".into())\n+    }\n+\n     pub(crate) fn tuple_field_name(idx: usize) -> Name {\n         Name::new(idx.to_string().into())\n     }\n@@ -51,7 +59,8 @@ impl Name {\n             \"u128\" => KnownName::U128,\n             \"f32\" => KnownName::F32,\n             \"f64\" => KnownName::F64,\n-            \"Self\" => KnownName::Self_,\n+            \"Self\" => KnownName::SelfType,\n+            \"self\" => KnownName::SelfParam,\n             _ => return None,\n         };\n         Some(name)\n@@ -104,5 +113,6 @@ pub(crate) enum KnownName {\n     F32,\n     F64,\n \n-    Self_,\n+    SelfType,\n+    SelfParam,\n }"}, {"sha": "dcf4cf8b651e89f943c30b3245b166e1a7583639", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -65,6 +65,11 @@ impl Path {\n         }\n     }\n \n+    /// Converts an `ast::NameRef` into a single-identifier `Path`.\n+    pub fn from_name_ref(name_ref: ast::NameRef) -> Path {\n+        name_ref.as_name().into()\n+    }\n+\n     /// `true` is this path is a single identifier, like `foo`\n     pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n@@ -84,6 +89,15 @@ impl Path {\n     }\n }\n \n+impl From<Name> for Path {\n+    fn from(name: Name) -> Path {\n+        Path {\n+            kind: PathKind::Plain,\n+            segments: vec![name],\n+        }\n+    }\n+}\n+\n fn expand_use_tree(\n     prefix: Option<Path>,\n     tree: ast::UseTree,"}, {"sha": "d9ee9d37f09c24fdbd44f69beef34b26b63bcc42", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n use ra_db::{SourceRootId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind, Function, DefId, Name, AsName, HirFileId,\n+    SourceFileItems, SourceItemId, DefKind, DefId, Name, AsName, HirFileId,\n     MacroCallLoc,\n     db::HirDatabase,\n     function::FnScopes,\n@@ -23,11 +23,10 @@ use crate::{\n     adt::{StructData, EnumData},\n };\n \n-pub(super) fn fn_scopes(db: &impl HirDatabase, def_id: DefId) -> Arc<FnScopes> {\n-    let function = Function::new(def_id);\n-    let syntax = function.syntax(db);\n-    let res = FnScopes::new(syntax.borrowed());\n-    Arc::new(res)\n+pub(super) fn fn_scopes(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<FnScopes>> {\n+    let body = db.body_hir(def_id)?;\n+    let res = FnScopes::new(body);\n+    Ok(Arc::new(res))\n }\n \n pub(super) fn struct_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<StructData>> {"}, {"sha": "29a3960e9190b0919f0c812c2465ad7f54a8523e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -87,6 +87,18 @@ fn module_from_source(\n     Ok(Some(Module::new(db, source_root_id, module_id)?))\n }\n \n+pub fn function_from_position(\n+    db: &impl HirDatabase,\n+    position: FilePosition,\n+) -> Cancelable<Option<Function>> {\n+    let file = db.source_file(position.file_id);\n+    let fn_def = ctry!(find_node_at_offset::<ast::FnDef>(\n+        file.syntax(),\n+        position.offset\n+    ));\n+    function_from_source(db, position.file_id, fn_def)\n+}\n+\n pub fn function_from_source(\n     db: &impl HirDatabase,\n     file_id: FileId,"}, {"sha": "8c320a7053afdc2e8944fcf4a751ac7cc8b32b6f", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -31,10 +31,11 @@ use ra_syntax::{\n };\n \n use crate::{\n-    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path, Name, AsName, ImplBlock,\n+    Def, DefId, Module, Function, Struct, Enum, Path, Name, AsName, ImplBlock,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n+    ScopesWithSyntaxMapping,\n };\n \n /// The ID of a type variable.\n@@ -305,7 +306,7 @@ impl Ty {\n                 return Ok(Ty::Uint(uint_ty));\n             } else if let Some(float_ty) = primitive::FloatTy::from_name(name) {\n                 return Ok(Ty::Float(float_ty));\n-            } else if name.as_known_name() == Some(KnownName::Self_) {\n+            } else if name.as_known_name() == Some(KnownName::SelfType) {\n                 return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n             }\n         }\n@@ -515,7 +516,7 @@ impl InferenceResult {\n #[derive(Clone, Debug)]\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n-    scopes: Arc<FnScopes>,\n+    scopes: ScopesWithSyntaxMapping,\n     /// The self param for the current method, if it exists.\n     self_param: Option<LocalSyntaxPtr>,\n     module: Module,\n@@ -529,7 +530,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(\n         db: &'a D,\n-        scopes: Arc<FnScopes>,\n+        scopes: ScopesWithSyntaxMapping,\n         module: Module,\n         impl_block: Option<ImplBlock>,\n     ) -> Self {\n@@ -826,10 +827,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.infer_expr_opt(e.expr(), &Expectation::none())?;\n                 Ty::Never\n             }\n-            ast::Expr::MatchArmList(_) | ast::Expr::MatchArm(_) | ast::Expr::MatchGuard(_) => {\n-                // Can this even occur outside of a match expression?\n-                Ty::Unknown\n-            }\n             ast::Expr::StructLit(e) => {\n                 let (ty, def_id) = self.resolve_variant(e.path())?;\n                 if let Some(nfl) = e.named_field_list() {\n@@ -845,10 +842,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n                 ty\n             }\n-            ast::Expr::NamedFieldList(_) | ast::Expr::NamedField(_) => {\n-                // Can this even occur outside of a struct literal?\n-                Ty::Unknown\n-            }\n             ast::Expr::IndexExpr(_e) => Ty::Unknown,\n             ast::Expr::FieldExpr(e) => {\n                 let receiver_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n@@ -1016,7 +1009,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n     let function = Function::new(def_id); // TODO: consts also need inference\n-    let scopes = function.scopes(db);\n+    let scopes = function.scopes(db)?;\n     let module = function.module(db)?;\n     let impl_block = function.impl_block(db)?;\n     let mut ctx = InferenceContext::new(db, scopes, module, impl_block);"}, {"sha": "515c66e851905d2e8a299cb3d0566e4569c2757e", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -1,7 +1,10 @@\n+use std::sync::Arc;\n use std::fmt::Write;\n use std::path::{PathBuf, Path};\n use std::fs;\n \n+use salsa::Database;\n+\n use ra_db::{SyntaxDatabase};\n use ra_syntax::ast::{self, AstNode};\n use test_utils::{project_dir, assert_eq_text, read_text};\n@@ -217,3 +220,44 @@ fn ellipsize(mut text: String, max_len: usize) -> String {\n fn test_data_dir() -> PathBuf {\n     project_dir().join(\"crates/ra_hir/src/ty/tests/data\")\n }\n+\n+#[test]\n+#[should_panic] // TODO this should work once hir::Expr is used\n+fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n+    let (mut db, pos) = MockDatabase::with_position(\n+        \"\n+        //- /lib.rs\n+        fn foo() -> i32 {\n+            <|>1 + 1\n+        }\n+    \",\n+    );\n+    let func = source_binder::function_from_position(&db, pos)\n+        .unwrap()\n+        .unwrap();\n+    {\n+        let events = db.log_executed(|| {\n+            func.infer(&db).unwrap();\n+        });\n+        assert!(format!(\"{:?}\", events).contains(\"infer\"))\n+    }\n+\n+    let new_text = \"\n+        fn foo() -> i32 {\n+            1\n+            +\n+            1\n+        }\n+    \"\n+    .to_string();\n+\n+    db.query_mut(ra_db::FileTextQuery)\n+        .set(pos.file_id, Arc::new(new_text));\n+\n+    {\n+        let events = db.log_executed(|| {\n+            func.infer(&db).unwrap();\n+        });\n+        assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n+    }\n+}"}, {"sha": "859f330c246c6ae81bf66fa8472cf6230482ecab", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -107,4 +107,8 @@ impl TypeRef {\n             TypeRef::Error\n         }\n     }\n+\n+    pub fn unit() -> TypeRef {\n+        TypeRef::Tuple(Vec::new())\n+    }\n }"}, {"sha": "24f72393a31b859f29eb081e8aa8f1a259027b0c", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -378,7 +378,11 @@ impl<R: TreeRoot<RaTypes>> BreakExprNode<R> {\n }\n \n \n-impl<'a> BreakExpr<'a> {}\n+impl<'a> BreakExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // Byte\n #[derive(Debug, Clone, Copy,)]\n@@ -923,12 +927,7 @@ pub enum Expr<'a> {\n     BlockExpr(BlockExpr<'a>),\n     ReturnExpr(ReturnExpr<'a>),\n     MatchExpr(MatchExpr<'a>),\n-    MatchArmList(MatchArmList<'a>),\n-    MatchArm(MatchArm<'a>),\n-    MatchGuard(MatchGuard<'a>),\n     StructLit(StructLit<'a>),\n-    NamedFieldList(NamedFieldList<'a>),\n-    NamedField(NamedField<'a>),\n     CallExpr(CallExpr<'a>),\n     IndexExpr(IndexExpr<'a>),\n     MethodCallExpr(MethodCallExpr<'a>),\n@@ -960,12 +959,7 @@ impl<'a> AstNode<'a> for Expr<'a> {\n             BLOCK_EXPR => Some(Expr::BlockExpr(BlockExpr { syntax })),\n             RETURN_EXPR => Some(Expr::ReturnExpr(ReturnExpr { syntax })),\n             MATCH_EXPR => Some(Expr::MatchExpr(MatchExpr { syntax })),\n-            MATCH_ARM_LIST => Some(Expr::MatchArmList(MatchArmList { syntax })),\n-            MATCH_ARM => Some(Expr::MatchArm(MatchArm { syntax })),\n-            MATCH_GUARD => Some(Expr::MatchGuard(MatchGuard { syntax })),\n             STRUCT_LIT => Some(Expr::StructLit(StructLit { syntax })),\n-            NAMED_FIELD_LIST => Some(Expr::NamedFieldList(NamedFieldList { syntax })),\n-            NAMED_FIELD => Some(Expr::NamedField(NamedField { syntax })),\n             CALL_EXPR => Some(Expr::CallExpr(CallExpr { syntax })),\n             INDEX_EXPR => Some(Expr::IndexExpr(IndexExpr { syntax })),\n             METHOD_CALL_EXPR => Some(Expr::MethodCallExpr(MethodCallExpr { syntax })),\n@@ -997,12 +991,7 @@ impl<'a> AstNode<'a> for Expr<'a> {\n             Expr::BlockExpr(inner) => inner.syntax(),\n             Expr::ReturnExpr(inner) => inner.syntax(),\n             Expr::MatchExpr(inner) => inner.syntax(),\n-            Expr::MatchArmList(inner) => inner.syntax(),\n-            Expr::MatchArm(inner) => inner.syntax(),\n-            Expr::MatchGuard(inner) => inner.syntax(),\n             Expr::StructLit(inner) => inner.syntax(),\n-            Expr::NamedFieldList(inner) => inner.syntax(),\n-            Expr::NamedField(inner) => inner.syntax(),\n             Expr::CallExpr(inner) => inner.syntax(),\n             Expr::IndexExpr(inner) => inner.syntax(),\n             Expr::MethodCallExpr(inner) => inner.syntax(),\n@@ -3880,6 +3869,10 @@ impl<'a> StructLit<'a> {\n     pub fn named_field_list(self) -> Option<NamedFieldList<'a>> {\n         super::child_opt(self)\n     }\n+\n+    pub fn spread(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n }\n \n // StructPat\n@@ -4147,7 +4140,15 @@ impl<R: TreeRoot<RaTypes>> TupleStructPatNode<R> {\n }\n \n \n-impl<'a> TupleStructPat<'a> {}\n+impl<'a> TupleStructPat<'a> {\n+    pub fn args(self) -> impl Iterator<Item = Pat<'a>> + 'a {\n+        super::children(self)\n+    }\n+\n+    pub fn path(self) -> Option<Path<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // TupleType\n #[derive(Debug, Clone, Copy,)]"}, {"sha": "3c640ed47e0518e6722cabf24669e6d07ff7c1fd", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/eaf553dade9a28b41631387d7c88b09fd0ba64e2/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=eaf553dade9a28b41631387d7c88b09fd0ba64e2", "patch": "@@ -384,7 +384,7 @@ Grammar(\n             options: [ \"Condition\" ]\n         ),\n         \"ContinueExpr\": (),\n-        \"BreakExpr\": (),\n+        \"BreakExpr\": (options: [\"Expr\"]),\n         \"Label\": (),\n         \"BlockExpr\": (\n             options: [ \"Block\" ]\n@@ -404,7 +404,7 @@ Grammar(\n             collections: [ [ \"pats\", \"Pat\" ] ]\n         ),\n         \"MatchGuard\": (),\n-        \"StructLit\": (options: [\"Path\", \"NamedFieldList\"]),\n+        \"StructLit\": (options: [\"Path\", \"NamedFieldList\", [\"spread\", \"Expr\"]]),\n         \"NamedFieldList\": (collections: [ [\"fields\", \"NamedField\"] ]),\n         \"NamedField\": (options: [\"NameRef\", \"Expr\"]),\n         \"CallExpr\": (\n@@ -446,12 +446,7 @@ Grammar(\n                 \"BlockExpr\",\n                 \"ReturnExpr\",\n                 \"MatchExpr\",\n-                \"MatchArmList\",\n-                \"MatchArm\",\n-                \"MatchGuard\",\n                 \"StructLit\",\n-                \"NamedFieldList\",\n-                \"NamedField\",\n                 \"CallExpr\",\n                 \"IndexExpr\",\n                 \"MethodCallExpr\",\n@@ -472,7 +467,10 @@ Grammar(\n         \"PathPat\": (),\n         \"StructPat\": (),\n         \"FieldPatList\": (),\n-        \"TupleStructPat\": (),\n+        \"TupleStructPat\": (\n+            options: [\"Path\"],\n+            collections: [[\"args\", \"Pat\"]],\n+        ),\n         \"TuplePat\": (),\n         \"SlicePat\": (),\n         \"RangePat\": (),"}]}