{"sha": "28ba4302ccc8e00b2469f92a4e68229d5981e553", "node_id": "C_kwDOAAsO6NoAKDI4YmE0MzAyY2NjOGUwMGIyNDY5ZjkyYTRlNjgyMjlkNTk4MWU1NTM", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-01T16:49:41Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-01T16:49:41Z"}, "message": "Sync from rust a00e130dae74a213338e2b095ec855156d8f3d8a", "tree": {"sha": "1602bcb4c2d8e22f7d2a3f299088a5753b7242d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1602bcb4c2d8e22f7d2a3f299088a5753b7242d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28ba4302ccc8e00b2469f92a4e68229d5981e553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28ba4302ccc8e00b2469f92a4e68229d5981e553", "html_url": "https://github.com/rust-lang/rust/commit/28ba4302ccc8e00b2469f92a4e68229d5981e553", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28ba4302ccc8e00b2469f92a4e68229d5981e553/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72d89b0c85a2a4e773061c4b850121dea153c00f", "url": "https://api.github.com/repos/rust-lang/rust/commits/72d89b0c85a2a4e773061c4b850121dea153c00f", "html_url": "https://github.com/rust-lang/rust/commit/72d89b0c85a2a4e773061c4b850121dea153c00f"}, {"sha": "4bdc78436b2c323be505d2a15ab6c592c5a9c9c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bdc78436b2c323be505d2a15ab6c592c5a9c9c8", "html_url": "https://github.com/rust-lang/rust/commit/4bdc78436b2c323be505d2a15ab6c592c5a9c9c8"}], "stats": {"total": 56, "additions": 22, "deletions": 34}, "files": [{"sha": "a932c1c8372b488dc479bbba4d8fd85f864d14f5", "filename": "config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ba4302ccc8e00b2469f92a4e68229d5981e553/config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/28ba4302ccc8e00b2469f92a4e68229d5981e553/config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.sh?ref=28ba4302ccc8e00b2469f92a4e68229d5981e553", "patch": "@@ -38,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$linker -Cpanic=abort -Zsymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "8a74c4c07e0cf2ba331aec30a9839942b7ce0d99", "filename": "src/asm.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28ba4302ccc8e00b2469f92a4e68229d5981e553/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ba4302ccc8e00b2469f92a4e68229d5981e553/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=28ba4302ccc8e00b2469f92a4e68229d5981e553", "patch": "@@ -4,9 +4,8 @@ use rustc_codegen_ssa::mir::operand::OperandValue;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{AsmBuilderMethods, AsmMethods, BaseTypeMethods, BuilderMethods, GlobalAsmOperandRef, InlineAsmOperandRef};\n \n-use rustc_hir::LlvmInlineAsmInner;\n use rustc_middle::{bug, ty::Instance};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use rustc_target::asm::*;\n \n use std::borrow::Cow;\n@@ -106,17 +105,6 @@ enum ConstraintOrRegister {\n \n \n impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn codegen_llvm_inline_asm(&mut self, _ia: &LlvmInlineAsmInner, _outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, _inputs: Vec<RValue<'gcc>>, span: Span) -> bool {\n-        self.sess().struct_span_err(span, \"GCC backend does not support `llvm_asm!`\")\n-            .help(\"consider using the `asm!` macro instead\")\n-            .emit();\n-\n-        // We return `true` even if we've failed to generate the asm\n-        // because we want to suppress the \"malformed inline assembly\" error\n-        // generated by the frontend.\n-        true\n-    }\n-\n     fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, span: &[Span], _instance: Instance<'_>, _dest_catch_funclet: Option<(Self::BasicBlock, Self::BasicBlock, Option<&Self::Funclet>)>) {\n         if options.contains(InlineAsmOptions::MAY_UNWIND) {\n             self.sess()\n@@ -184,7 +172,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                             let is_target_supported = reg.reg_class().supported_types(asm_arch).iter()\n                                 .any(|&(_, feature)| {\n                                     if let Some(feature) = feature {\n-                                        self.tcx.sess.target_features.contains(&Symbol::intern(feature))\n+                                        self.tcx.sess.target_features.contains(&feature)\n                                     } else {\n                                         true // Register class is unconditionally supported\n                                     }\n@@ -572,6 +560,7 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::Msp430(_) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => unimplemented!(),\n@@ -634,6 +623,7 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => cx.type_f32(),\n+        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n@@ -741,6 +731,7 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         InlineAsmRegClass::Bpf(_) => unimplemented!(),\n         InlineAsmRegClass::Hexagon(_) => unimplemented!(),\n         InlineAsmRegClass::Mips(_) => unimplemented!(),\n+        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n         InlineAsmRegClass::Nvptx(_) => unimplemented!(),\n         InlineAsmRegClass::PowerPC(_) => unimplemented!(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)"}, {"sha": "f047417d1445c0f190189292908b4d602facd609", "filename": "src/builder.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/28ba4302ccc8e00b2469f92a4e68229d5981e553/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ba4302ccc8e00b2469f92a4e68229d5981e553/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=28ba4302ccc8e00b2469f92a4e68229d5981e553", "patch": "@@ -1110,7 +1110,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         aggregate_value\n     }\n \n-    fn landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>, _num_clauses: usize) -> RValue<'gcc> {\n+    fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn cleanup_landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>) -> RValue<'gcc> {\n         let field1 = self.context.new_field(None, self.u8_type, \"landing_pad_field_1\");\n         let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n         let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n@@ -1121,38 +1125,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // rustc_codegen_ssa now calls the unwinding builder methods even on panic=abort.\n     }\n \n-    fn set_cleanup(&mut self, _landing_pad: RValue<'gcc>) {\n-        // TODO(antoyo)\n-    }\n-\n-    fn resume(&mut self, _exn: RValue<'gcc>) -> RValue<'gcc> {\n+    fn resume(&mut self, _exn: RValue<'gcc>) {\n         unimplemented!();\n     }\n \n     fn cleanup_pad(&mut self, _parent: Option<RValue<'gcc>>, _args: &[RValue<'gcc>]) -> Funclet {\n         unimplemented!();\n     }\n \n-    fn cleanup_ret(&mut self, _funclet: &Funclet, _unwind: Option<Block<'gcc>>) -> RValue<'gcc> {\n+    fn cleanup_ret(&mut self, _funclet: &Funclet, _unwind: Option<Block<'gcc>>) {\n         unimplemented!();\n     }\n \n     fn catch_pad(&mut self, _parent: RValue<'gcc>, _args: &[RValue<'gcc>]) -> Funclet {\n         unimplemented!();\n     }\n \n-    fn catch_switch(&mut self, _parent: Option<RValue<'gcc>>, _unwind: Option<Block<'gcc>>, _num_handlers: usize) -> RValue<'gcc> {\n+    fn catch_switch(\n+        &mut self,\n+        _parent: Option<RValue<'gcc>>,\n+        _unwind: Option<Block<'gcc>>,\n+        _handlers: &[Block<'gcc>],\n+    ) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n-    fn add_handler(&mut self, _catch_switch: RValue<'gcc>, _handler: Block<'gcc>) {\n-        unimplemented!();\n-    }\n-\n-    fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n-        // TODO(antoyo)\n-    }\n-\n     // Atomic Operations\n     fn atomic_cmpxchg(&mut self, dst: RValue<'gcc>, cmp: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering, failure_order: AtomicOrdering, weak: bool) -> RValue<'gcc> {\n         let expected = self.current_func().new_local(None, cmp.get_type(), \"expected\");\n@@ -1257,7 +1254,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.cx\n     }\n \n-    fn do_not_inline(&mut self, _llret: RValue<'gcc>) {\n+    fn apply_attrs_to_cleanup_callsite(&mut self, _llret: RValue<'gcc>) {\n         unimplemented!();\n     }\n "}, {"sha": "281e49fa8a35ed4b6344c58688b792236b42fa3d", "filename": "src/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ba4302ccc8e00b2469f92a4e68229d5981e553/src%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ba4302ccc8e00b2469f92a4e68229d5981e553/src%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftype_of.rs?ref=28ba4302ccc8e00b2469f92a4e68229d5981e553", "patch": "@@ -57,7 +57,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n                 (layout.ty.kind(), &layout.variants)\n             {\n                 if def.is_enum() && !def.variants.is_empty() {\n-                    write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n+                    write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n                 }\n             }\n             if let (&ty::Generator(_, _, _), &Variants::Single { index }) ="}, {"sha": "ebe663a0b742613bda0f35f9887a5c8686fcdba4", "filename": "test.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ba4302ccc8e00b2469f92a4e68229d5981e553/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/28ba4302ccc8e00b2469f92a4e68229d5981e553/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=28ba4302ccc8e00b2469f92a4e68229d5981e553", "patch": "@@ -195,7 +195,7 @@ EOF\n     git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n     rm src/test/ui/llvm-asm/llvm-asm-in-out-operand.rs || true # TODO(antoyo): Enable back this test if I ever implement the llvm_asm! macro.\n \n-    RUSTC_ARGS=\"-Zpanic-abort-tests -Zsymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+    RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n \n     echo \"[TEST] rustc test suite\"\n     COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 src/test/ui/ --rustc-args \"$RUSTC_ARGS\""}]}