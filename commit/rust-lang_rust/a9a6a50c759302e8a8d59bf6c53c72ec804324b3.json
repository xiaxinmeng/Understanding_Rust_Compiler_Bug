{"sha": "a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YTZhNTBjNzU5MzAyZThhOGQ1OWJmNmM1M2M3MmVjODA0MzI0YjM=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-14T18:30:21Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-14T18:30:21Z"}, "message": "Fixup tests", "tree": {"sha": "ecd22d01bca8bfb2419732621140c3271277973d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecd22d01bca8bfb2419732621140c3271277973d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "html_url": "https://github.com/rust-lang/rust/commit/a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "606d66a714bb8fe07f35a6af83d04ab576b9a0e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/606d66a714bb8fe07f35a6af83d04ab576b9a0e1", "html_url": "https://github.com/rust-lang/rust/commit/606d66a714bb8fe07f35a6af83d04ab576b9a0e1"}], "stats": {"total": 494, "additions": 283, "deletions": 211}, "files": [{"sha": "2f3432870dd671b51e9d1a9ea8a88ef3746910a7", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 53, "deletions": 88, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -6,12 +6,11 @@ use rustc_hash::FxHashMap;\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_db::{LocalSyntaxPtr, Cancelable};\n use ra_syntax::{\n-    SyntaxKind,\n-    ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner}\n+    ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor}\n };\n \n use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n-use crate::ty::primitive::{UintTy, IntTy, FloatTy, UncertainIntTy, UncertainFloatTy};\n+use crate::ty::primitive::{UintTy, UncertainIntTy, UncertainFloatTy};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ExprId(RawId);\n@@ -649,93 +648,59 @@ impl ExprCollector {\n                 let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n-            ast::ExprKind::LiteralExpr(e) => {\n-                if let Some(child) = e.literal() {\n-                    let c = child.syntax();\n-                    let lit = match c.kind() {\n-                        SyntaxKind::INT_NUMBER => {\n-                            let text = c.text().to_string();\n-\n-                            // FIXME: don't do it like this. maybe use something like\n-                            // the IntTy::from_name functions\n-                            let ty = if text.ends_with(\"isize\") {\n-                                UncertainIntTy::Signed(IntTy::Isize)\n-                            } else if text.ends_with(\"i128\") {\n-                                UncertainIntTy::Signed(IntTy::I128)\n-                            } else if text.ends_with(\"i64\") {\n-                                UncertainIntTy::Signed(IntTy::I64)\n-                            } else if text.ends_with(\"i32\") {\n-                                UncertainIntTy::Signed(IntTy::I32)\n-                            } else if text.ends_with(\"i16\") {\n-                                UncertainIntTy::Signed(IntTy::I16)\n-                            } else if text.ends_with(\"i8\") {\n-                                UncertainIntTy::Signed(IntTy::I8)\n-                            } else if text.ends_with(\"usize\") {\n-                                UncertainIntTy::Unsigned(UintTy::Usize)\n-                            } else if text.ends_with(\"u128\") {\n-                                UncertainIntTy::Unsigned(UintTy::U128)\n-                            } else if text.ends_with(\"u64\") {\n-                                UncertainIntTy::Unsigned(UintTy::U64)\n-                            } else if text.ends_with(\"u32\") {\n-                                UncertainIntTy::Unsigned(UintTy::U32)\n-                            } else if text.ends_with(\"u16\") {\n-                                UncertainIntTy::Unsigned(UintTy::U16)\n-                            } else if text.ends_with(\"u8\") {\n-                                UncertainIntTy::Unsigned(UintTy::U8)\n-                            } else {\n-                                UncertainIntTy::Unknown\n-                            };\n-\n-                            // TODO: actually parse integer\n-                            Literal::Int(0u64, ty)\n-                        }\n-                        SyntaxKind::FLOAT_NUMBER => {\n-                            let text = c.text().to_string();\n-\n-                            // FIXME: don't do it like this. maybe use something like\n-                            // the IntTy::from_name functions\n-                            let ty = if text.ends_with(\"f64\") {\n-                                UncertainFloatTy::Known(FloatTy::F64)\n-                            } else if text.ends_with(\"f32\") {\n-                                UncertainFloatTy::Known(FloatTy::F32)\n-                            } else {\n-                                UncertainFloatTy::Unknown\n-                            };\n-\n-                            // TODO: actually parse value\n-                            Literal::Float(0, ty)\n-                        }\n-                        SyntaxKind::STRING => {\n-                            // FIXME: this likely includes the \" characters\n-                            let text = c.text().to_string();\n-                            Literal::String(text)\n-                        }\n-                        SyntaxKind::TRUE_KW => Literal::Bool(true),\n-                        SyntaxKind::FALSE_KW => Literal::Bool(false),\n-                        SyntaxKind::BYTE_STRING => {\n-                            // FIXME: this is completely incorrect for a variety\n-                            // of reasons, but at least it gives the right type\n-                            let bytes = c.text().to_string().into_bytes();\n-                            Literal::ByteString(bytes)\n-                        }\n-                        SyntaxKind::CHAR => {\n-                            let character = c.text().char_at(1).unwrap_or('X');\n-                            Literal::Char(character)\n+            ast::ExprKind::Literal(e) => {\n+                let child = if let Some(child) = e.literal_expr() {\n+                    child\n+                } else {\n+                    return self.alloc_expr(Expr::Missing, syntax_ptr);\n+                };\n+                let c = child.syntax();\n+\n+                let lit = match child.flavor() {\n+                    LiteralFlavor::IntNumber { suffix } => {\n+                        let known_name = suffix\n+                            .map(|s| Name::new(s))\n+                            .and_then(|name| UncertainIntTy::from_name(&name));\n+\n+                        if let Some(kn) = known_name {\n+                            Literal::Int(0u64, kn)\n+                        } else {\n+                            Literal::Int(0u64, UncertainIntTy::Unknown)\n                         }\n-                        SyntaxKind::BYTE => {\n-                            let character = c.text().char_at(1).unwrap_or('X');\n-                            Literal::Int(\n-                                character as u8 as u64,\n-                                UncertainIntTy::Unsigned(UintTy::U8),\n-                            )\n+                    }\n+                    LiteralFlavor::FloatNumber { suffix } => {\n+                        let known_name = suffix\n+                            .map(|s| Name::new(s))\n+                            .and_then(|name| UncertainFloatTy::from_name(&name));\n+\n+                        if let Some(kn) = known_name {\n+                            Literal::Float(0u64, kn)\n+                        } else {\n+                            Literal::Float(0u64, UncertainFloatTy::Unknown)\n                         }\n-                        _ => return self.alloc_expr(Expr::Missing, syntax_ptr),\n-                    };\n-\n-                    self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n-                } else {\n-                    self.alloc_expr(Expr::Missing, syntax_ptr)\n-                }\n+                    }\n+                    LiteralFlavor::ByteString => {\n+                        // FIXME: this is completely incorrect for a variety\n+                        // of reasons, but at least it gives the right type\n+                        let bytes = c.text().to_string().into_bytes();\n+                        Literal::ByteString(bytes)\n+                    }\n+                    LiteralFlavor::String => {\n+                        // FIXME: this likely includes the \" characters\n+                        let text = c.text().to_string();\n+                        Literal::String(text)\n+                    }\n+                    LiteralFlavor::Byte => {\n+                        let character = c.text().char_at(1).unwrap_or('X');\n+                        Literal::Int(character as u8 as u64, UncertainIntTy::Unsigned(UintTy::U8))\n+                    }\n+                    LiteralFlavor::Bool => Literal::Bool(true),\n+                    LiteralFlavor::Char => {\n+                        let character = c.text().char_at(1).unwrap_or('X');\n+                        Literal::Char(character)\n+                    }\n+                };\n+                self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n             }\n \n             // TODO implement HIR for these:"}, {"sha": "8d786d2ac57a7dbd2e2161d3f5fc4e4c733ecd45", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -23,7 +23,7 @@ impl fmt::Debug for Name {\n }\n \n impl Name {\n-    fn new(text: SmolStr) -> Name {\n+    pub(crate) fn new(text: SmolStr) -> Name {\n         Name { text }\n     }\n "}, {"sha": "b6577ee5eccfa20b47283fa3bffc0ce0d4abefaf", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -111,14 +111,20 @@ impl UnifyValue for TypeVarValue {\n /// values for general types, and for integer and float variables. The latter\n /// two are used for inference of literal values (e.g. `100` could be one of\n /// several integer types).\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InferTy {\n     TypeVar(TypeVarId),\n     IntVar(TypeVarId),\n     FloatVar(TypeVarId),\n }\n \n impl InferTy {\n+    fn to_inner(self) -> TypeVarId {\n+        match self {\n+            InferTy::TypeVar(ty) | InferTy::IntVar(ty) | InferTy::FloatVar(ty) => ty,\n+        }\n+    }\n+\n     fn fallback_value(self) -> Ty {\n         match self {\n             InferTy::TypeVar(..) => Ty::Unknown,\n@@ -326,18 +332,19 @@ impl Ty {\n         path: &Path,\n     ) -> Cancelable<Self> {\n         if let Some(name) = path.as_ident() {\n-            if let Some(KnownName::Bool) = name.as_known_name() {\n-                return Ok(Ty::Bool);\n-            } else if let Some(KnownName::Char) = name.as_known_name() {\n-                return Ok(Ty::Char);\n-            } else if let Some(KnownName::Str) = name.as_known_name() {\n-                return Ok(Ty::Str);\n-            } else if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n+            if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n                 return Ok(Ty::Int(int_ty));\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n                 return Ok(Ty::Float(float_ty));\n             } else if name.as_known_name() == Some(KnownName::SelfType) {\n                 return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n+            } else if let Some(known) = name.as_known_name() {\n+                match known {\n+                    KnownName::Bool => return Ok(Ty::Bool),\n+                    KnownName::Char => return Ok(Ty::Char),\n+                    KnownName::Str => return Ok(Ty::Str),\n+                    _ => {}\n+                }\n             }\n         }\n \n@@ -793,10 +800,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// known type.\n     fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n-            Ty::Infer(InferTy::TypeVar(tv))\n-            | Ty::Infer(InferTy::IntVar(tv))\n-            | Ty::Infer(InferTy::FloatVar(tv)) => {\n-                if let Some(known_ty) = self.var_unification_table.probe_value(tv).known() {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n                     // known_ty may contain other variables that are known by now\n                     self.resolve_ty_as_possible(known_ty.clone())\n                 } else {\n@@ -811,8 +817,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// otherwise, return ty.\n     fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n         match ty {\n-            Ty::Infer(InferTy::TypeVar(tv)) => {\n-                match self.var_unification_table.probe_value(*tv).known() {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                match self.var_unification_table.probe_value(inner).known() {\n                     Some(known_ty) => {\n                         // The known_ty can't be a type var itself\n                         Cow::Owned(known_ty.clone())\n@@ -828,16 +835,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// replaced by Ty::Unknown.\n     fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n-            Ty::Infer(i) => {\n-                let tv = match i {\n-                    InferTy::TypeVar(tv) | InferTy::IntVar(tv) | InferTy::FloatVar(tv) => tv,\n-                };\n-\n-                if let Some(known_ty) = self.var_unification_table.probe_value(tv).known() {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n                     // known_ty may contain other variables that are known by now\n                     self.resolve_ty_completely(known_ty.clone())\n                 } else {\n-                    i.fallback_value()\n+                    tv.fallback_value()\n                 }\n             }\n             _ => ty,"}, {"sha": "cbdb2a4b7d19f3535faf10e0194fbc8d52e91745", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -145,6 +145,7 @@ fn test() {\n     3.14;\n     5000;\n     false;\n+    true;\n }\n \"#,\n         \"literals.txt\",\n@@ -199,7 +200,7 @@ fn f(x: bool) -> i32 {\n     0i32\n }\n \n-fn test() {\n+fn test() -> bool {\n     let x = a && b;\n     let y = true || false;\n     let z = x == y;\n@@ -296,8 +297,6 @@ fn test(x: &str, y: isize) {\n     let b = (a, x);\n     let c = (y, x);\n     let d = (c, x);\n-\n-    // we have not infered these case yet.\n     let e = (1, \"e\");\n     let f = (e, \"d\");\n }"}, {"sha": "58a7276916f249b4c524bad06c621fa979dc50e5", "filename": "crates/ra_hir/src/ty/tests/data/binary_op.txt", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -1,46 +1,46 @@\n [6; 7) 'x': bool\n [22; 34) '{     0i32 }': i32\n [28; 32) '0i32': i32\n-[46; 342) '{     ... < 3 }': bool\n-[56; 57) 'x': bool\n-[60; 61) 'a': bool\n-[60; 66) 'a && b': bool\n-[65; 66) 'b': bool\n-[76; 77) 'y': bool\n-[80; 84) 'true': bool\n-[80; 93) 'true || false': bool\n-[88; 93) 'false': bool\n-[103; 104) 'z': bool\n-[107; 108) 'x': bool\n-[107; 113) 'x == y': bool\n-[112; 113) 'y': bool\n-[123; 134) 'minus_forty': isize\n-[144; 152) '-40isize': isize\n-[145; 152) '40isize': isize\n-[162; 163) 'h': bool\n-[166; 177) 'minus_forty': isize\n-[166; 188) 'minus_...ONST_2': bool\n-[181; 188) 'CONST_2': isize\n-[198; 199) 'c': i32\n-[202; 203) 'f': fn(bool) -> i32\n-[202; 211) 'f(z || y)': i32\n-[202; 215) 'f(z || y) + 5': i32\n-[204; 205) 'z': bool\n-[204; 210) 'z || y': bool\n-[209; 210) 'y': bool\n-[214; 215) '5': i32\n-[225; 226) 'd': [unknown]\n-[229; 230) 'b': [unknown]\n-[240; 241) 'g': ()\n-[244; 255) 'minus_forty': isize\n-[244; 260) 'minus_...y ^= i': ()\n-[259; 260) 'i': isize\n-[270; 273) 'ten': usize\n-[283; 285) '10': usize\n-[295; 308) 'ten_is_eleven': bool\n-[311; 314) 'ten': usize\n-[311; 326) 'ten == some_num': bool\n-[318; 326) 'some_num': usize\n-[333; 336) 'ten': usize\n-[333; 340) 'ten < 3': bool\n-[339; 340) '3': usize\n+[54; 350) '{     ... < 3 }': bool\n+[64; 65) 'x': bool\n+[68; 69) 'a': bool\n+[68; 74) 'a && b': bool\n+[73; 74) 'b': bool\n+[84; 85) 'y': bool\n+[88; 92) 'true': bool\n+[88; 101) 'true || false': bool\n+[96; 101) 'false': bool\n+[111; 112) 'z': bool\n+[115; 116) 'x': bool\n+[115; 121) 'x == y': bool\n+[120; 121) 'y': bool\n+[131; 142) 'minus_forty': isize\n+[152; 160) '-40isize': isize\n+[153; 160) '40isize': isize\n+[170; 171) 'h': bool\n+[174; 185) 'minus_forty': isize\n+[174; 196) 'minus_...ONST_2': bool\n+[189; 196) 'CONST_2': isize\n+[206; 207) 'c': i32\n+[210; 211) 'f': fn(bool) -> i32\n+[210; 219) 'f(z || y)': i32\n+[210; 223) 'f(z || y) + 5': i32\n+[212; 213) 'z': bool\n+[212; 218) 'z || y': bool\n+[217; 218) 'y': bool\n+[222; 223) '5': i32\n+[233; 234) 'd': [unknown]\n+[237; 238) 'b': [unknown]\n+[248; 249) 'g': ()\n+[252; 263) 'minus_forty': isize\n+[252; 268) 'minus_...y ^= i': ()\n+[267; 268) 'i': isize\n+[278; 281) 'ten': usize\n+[291; 293) '10': usize\n+[303; 316) 'ten_is_eleven': bool\n+[319; 322) 'ten': usize\n+[319; 334) 'ten == some_num': bool\n+[326; 334) 'some_num': usize\n+[341; 344) 'ten': usize\n+[341; 348) 'ten < 3': bool\n+[347; 348) '3': usize"}, {"sha": "6e82f458f4989bdb87f114ba29e977c553853b63", "filename": "crates/ra_hir/src/ty/tests/data/literals.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -1,4 +1,4 @@\n-[11; 101) '{     ...lse; }': ()\n+[11; 111) '{     ...rue; }': ()\n [17; 21) '5i32': i32\n [27; 34) '\"hello\"': &str\n [40; 48) 'b\"bytes\"': &[u8]\n@@ -7,3 +7,4 @@\n [73; 77) '3.14': f64\n [83; 87) '5000': i32\n [93; 98) 'false': bool\n+[104; 108) 'true': bool"}, {"sha": "a95d3c286e8e508f721b6eed9912850583288d0d", "filename": "crates/ra_hir/src/ty/tests/data/tuple.txt", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ftuple.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ftuple.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ftuple.txt?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -1,6 +1,6 @@\n [9; 10) 'x': &str\n [18; 19) 'y': isize\n-[28; 214) '{     ...d\"); }': ()\n+[28; 170) '{     ...d\"); }': ()\n [38; 39) 'a': (u32, &str)\n [55; 63) '(1, \"a\")': (u32, &str)\n [56; 57) '1': u32\n@@ -17,11 +17,11 @@\n [117; 123) '(c, x)': ((isize, &str), &str)\n [118; 119) 'c': (isize, &str)\n [121; 122) 'x': &str\n-[177; 178) 'e': ([unknown], [unknown])\n-[181; 189) '(1, \"e\")': ([unknown], [unknown])\n-[182; 183) '1': [unknown]\n-[185; 188) '\"e\"': [unknown]\n-[199; 200) 'f': (([unknown], [unknown]), [unknown])\n-[203; 211) '(e, \"d\")': (([unknown], [unknown]), [unknown])\n-[204; 205) 'e': ([unknown], [unknown])\n-[207; 210) '\"d\"': [unknown]\n+[133; 134) 'e': (i32, &str)\n+[137; 145) '(1, \"e\")': (i32, &str)\n+[138; 139) '1': i32\n+[141; 144) '\"e\"': &str\n+[155; 156) 'f': ((i32, &str), &str)\n+[159; 167) '(e, \"d\")': ((i32, &str), &str)\n+[160; 161) 'e': (i32, &str)\n+[163; 166) '\"d\"': &str"}, {"sha": "211ba31e573e580544fc10cc18e9b3f1a2f6789a", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -609,6 +609,52 @@ impl SelfParam {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum LiteralFlavor {\n+    String,\n+    ByteString,\n+    Char,\n+    Byte,\n+    IntNumber { suffix: Option<SmolStr> },\n+    FloatNumber { suffix: Option<SmolStr> },\n+    Bool,\n+}\n+\n+impl LiteralExpr {\n+    pub fn flavor(&self) -> LiteralFlavor {\n+        let syntax = self.syntax();\n+        match syntax.kind() {\n+            INT_NUMBER => {\n+                let allowed_suffix_list = [\n+                    \"isize\", \"i128\", \"i64\", \"i32\", \"i16\", \"i8\", \"usize\", \"u128\", \"u64\", \"u32\",\n+                    \"u16\", \"u8\",\n+                ];\n+                let text = syntax.text().to_string();\n+                let suffix = allowed_suffix_list\n+                    .iter()\n+                    .find(|&s| text.ends_with(s))\n+                    .map(|&suf| SmolStr::new(suf));\n+                LiteralFlavor::IntNumber { suffix: suffix }\n+            }\n+            FLOAT_NUMBER => {\n+                let allowed_suffix_list = [\"f64\", \"f32\"];\n+                let text = syntax.text().to_string();\n+                let suffix = allowed_suffix_list\n+                    .iter()\n+                    .find(|&s| text.ends_with(s))\n+                    .map(|&suf| SmolStr::new(suf));\n+                LiteralFlavor::FloatNumber { suffix: suffix }\n+            }\n+            STRING | RAW_STRING => LiteralFlavor::String,\n+            TRUE_KW | FALSE_KW => LiteralFlavor::Bool,\n+            BYTE_STRING | RAW_BYTE_STRING => LiteralFlavor::ByteString,\n+            CHAR => LiteralFlavor::Char,\n+            BYTE => LiteralFlavor::Byte,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n #[test]\n fn test_doc_comment_of_items() {\n     let file = SourceFile::parse("}, {"sha": "cad845ec0f480d7107f4c7df7c37d193c7cc1853", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 94, "deletions": 38, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -664,7 +664,7 @@ pub enum ExprKind<'a> {\n     PrefixExpr(&'a PrefixExpr),\n     RangeExpr(&'a RangeExpr),\n     BinExpr(&'a BinExpr),\n-    LiteralExpr(&'a LiteralExpr),\n+    Literal(&'a Literal),\n }\n \n impl AstNode for Expr {\n@@ -696,7 +696,7 @@ impl AstNode for Expr {\n             | PREFIX_EXPR\n             | RANGE_EXPR\n             | BIN_EXPR\n-            | LITERAL_EXPR => Some(Expr::from_repr(syntax.into_repr())),\n+            | LITERAL => Some(Expr::from_repr(syntax.into_repr())),\n             _ => None,\n         }\n     }\n@@ -733,7 +733,7 @@ impl Expr {\n             PREFIX_EXPR => ExprKind::PrefixExpr(PrefixExpr::cast(&self.syntax).unwrap()),\n             RANGE_EXPR => ExprKind::RangeExpr(RangeExpr::cast(&self.syntax).unwrap()),\n             BIN_EXPR => ExprKind::BinExpr(BinExpr::cast(&self.syntax).unwrap()),\n-            LITERAL_EXPR => ExprKind::LiteralExpr(LiteralExpr::cast(&self.syntax).unwrap()),\n+            LITERAL => ExprKind::Literal(Literal::cast(&self.syntax).unwrap()),\n             _ => unreachable!(),\n         }\n     }\n@@ -793,6 +793,31 @@ impl AstNode for ExternCrateItem {\n \n impl ExternCrateItem {}\n \n+// FalseKw\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct FalseKw {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for FalseKw {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for FalseKw {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            FALSE_KW => Some(FalseKw::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<FalseKw> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::AstToken for FalseKw {}\n+impl FalseKw {}\n+\n // FieldExpr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -867,7 +892,7 @@ impl AstNode for FloatNumber {\n         }\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-    fn to_owned(&self) -> TreePtr<FloatNumber> { TreePtr::cast(self.syntax.to_owned()) }\n+    fn to_owned(&self) -> TreeArc<FloatNumber> { TreeArc::cast(self.syntax.to_owned()) }\n }\n \n \n@@ -1173,7 +1198,7 @@ impl AstNode for IntNumber {\n         }\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-    fn to_owned(&self) -> TreePtr<IntNumber> { TreePtr::cast(self.syntax.to_owned()) }\n+    fn to_owned(&self) -> TreeArc<IntNumber> { TreeArc::cast(self.syntax.to_owned()) }\n }\n \n \n@@ -1365,48 +1390,24 @@ unsafe impl TransparentNewType for Literal {\n     type Repr = rowan::SyntaxNode<RaTypes>;\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum LiteralKind<'a> {\n-    String(&'a String),\n-    ByteString(&'a ByteString),\n-    Char(&'a Char),\n-    Byte(&'a Byte),\n-    IntNumber(&'a IntNumber),\n-    FloatNumber(&'a FloatNumber),\n-}\n-\n impl AstNode for Literal {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n         match syntax.kind() {\n-            | STRING\n-            | BYTE_STRING\n-            | CHAR\n-            | BYTE\n-            | INT_NUMBER\n-            | FLOAT_NUMBER => Some(Literal::from_repr(syntax.into_repr())),\n+            LITERAL => Some(Literal::from_repr(syntax.into_repr())),\n             _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n     fn to_owned(&self) -> TreeArc<Literal> { TreeArc::cast(self.syntax.to_owned()) }\n }\n \n+\n impl Literal {\n-    pub fn kind(&self) -> LiteralKind {\n-        match self.syntax.kind() {\n-            STRING => LiteralKind::String(String::cast(&self.syntax).unwrap()),\n-            BYTE_STRING => LiteralKind::ByteString(ByteString::cast(&self.syntax).unwrap()),\n-            CHAR => LiteralKind::Char(Char::cast(&self.syntax).unwrap()),\n-            BYTE => LiteralKind::Byte(Byte::cast(&self.syntax).unwrap()),\n-            INT_NUMBER => LiteralKind::IntNumber(IntNumber::cast(&self.syntax).unwrap()),\n-            FLOAT_NUMBER => LiteralKind::FloatNumber(FloatNumber::cast(&self.syntax).unwrap()),\n-            _ => unreachable!(),\n-        }\n+    pub fn literal_expr(&self) -> Option<&LiteralExpr> {\n+        super::child_opt(self)\n     }\n }\n \n-impl Literal {}\n-\n // LiteralExpr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -1417,24 +1418,54 @@ unsafe impl TransparentNewType for LiteralExpr {\n     type Repr = rowan::SyntaxNode<RaTypes>;\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum LiteralExprKind<'a> {\n+    String(&'a String),\n+    ByteString(&'a ByteString),\n+    Char(&'a Char),\n+    Byte(&'a Byte),\n+    IntNumber(&'a IntNumber),\n+    FloatNumber(&'a FloatNumber),\n+    TrueKw(&'a TrueKw),\n+    FalseKw(&'a FalseKw),\n+}\n+\n impl AstNode for LiteralExpr {\n     fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n         match syntax.kind() {\n-            LITERAL_EXPR => Some(LiteralExpr::from_repr(syntax.into_repr())),\n+            | STRING\n+            | BYTE_STRING\n+            | CHAR\n+            | BYTE\n+            | INT_NUMBER\n+            | FLOAT_NUMBER\n+            | TRUE_KW\n+            | FALSE_KW => Some(LiteralExpr::from_repr(syntax.into_repr())),\n             _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-    fn to_owned(&self) -> TreePtr<LiteralExpr> { TreePtr::cast(self.syntax.to_owned()) }\n+    fn to_owned(&self) -> TreeArc<LiteralExpr> { TreeArc::cast(self.syntax.to_owned()) }\n }\n \n-\n impl LiteralExpr {\n-    pub fn literal(&self) -> Option<&Literal> {\n-        super::child_opt(self)\n+    pub fn kind(&self) -> LiteralExprKind {\n+        match self.syntax.kind() {\n+            STRING => LiteralExprKind::String(String::cast(&self.syntax).unwrap()),\n+            BYTE_STRING => LiteralExprKind::ByteString(ByteString::cast(&self.syntax).unwrap()),\n+            CHAR => LiteralExprKind::Char(Char::cast(&self.syntax).unwrap()),\n+            BYTE => LiteralExprKind::Byte(Byte::cast(&self.syntax).unwrap()),\n+            INT_NUMBER => LiteralExprKind::IntNumber(IntNumber::cast(&self.syntax).unwrap()),\n+            FLOAT_NUMBER => LiteralExprKind::FloatNumber(FloatNumber::cast(&self.syntax).unwrap()),\n+            TRUE_KW => LiteralExprKind::TrueKw(TrueKw::cast(&self.syntax).unwrap()),\n+            FALSE_KW => LiteralExprKind::FalseKw(FalseKw::cast(&self.syntax).unwrap()),\n+            _ => unreachable!(),\n+        }\n     }\n }\n \n+impl LiteralExpr {}\n+\n // LoopExpr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -3025,6 +3056,31 @@ impl ast::AttrsOwner for TraitDef {}\n impl ast::DocCommentsOwner for TraitDef {}\n impl TraitDef {}\n \n+// TrueKw\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct TrueKw {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for TrueKw {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for TrueKw {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            TRUE_KW => Some(TrueKw::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<TrueKw> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::AstToken for TrueKw {}\n+impl TrueKw {}\n+\n // TryExpr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]"}, {"sha": "34d2a27d16a1a8a7f64ac4add8f9286b9c37f04f", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -215,7 +215,6 @@ Grammar(\n         \"PATH\",\n         \"PATH_SEGMENT\",\n         \"LITERAL\",\n-        \"LITERAL_EXPR\",\n         \"ALIAS\",\n         \"VISIBILITY\",\n         \"WHERE_CLAUSE\",\n@@ -434,17 +433,21 @@ Grammar(\n         \"Byte\": ( traits: [\"AstToken\"] ),\n         \"ByteString\": ( traits: [\"AstToken\"] ),\n         \"Char\": ( traits: [\"AstToken\"] ),\n-        \"Literal\": (\n+        \"TrueKw\": ( traits: [\"AstToken\"] ),\n+        \"FalseKw\": ( traits: [\"AstToken\"] ),\n+        \"LiteralExpr\": (\n             enum: [\n                 \"String\",\n                 \"ByteString\",\n                 \"Char\",\n                 \"Byte\",\n                 \"IntNumber\",\n                 \"FloatNumber\",\n+                \"TrueKw\",\n+                \"FalseKw\",\n             ]\n         ),\n-        \"LiteralExpr\": (options: [\"Literal\"]),\n+        \"Literal\": (options: [\"LiteralExpr\"]),\n \n         \"Expr\": (\n             enum: [\n@@ -474,7 +477,7 @@ Grammar(\n                 \"PrefixExpr\",\n                 \"RangeExpr\",\n                 \"BinExpr\",\n-                \"LiteralExpr\",\n+                \"Literal\",\n             ],\n         ),\n "}, {"sha": "bc311cbbcbc3e4235263d71cb9363bf4d9b48284", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -59,7 +59,7 @@ impl SourceFile {\n         assert_eq!(root.kind(), SyntaxKind::SOURCE_FILE);\n         TreeArc::cast(root)\n     }\n-    \n+\n     pub fn parse(text: &str) -> TreeArc<SourceFile> {\n         let tokens = tokenize(&text);\n         let (green, errors) ="}, {"sha": "830fac9f4baaafdff12a85f4ef560cbaf31b9138", "filename": "crates/ra_syntax/src/syntax_kinds/generated.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Fsyntax_kinds%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a6a50c759302e8a8d59bf6c53c72ec804324b3/crates%2Fra_syntax%2Fsrc%2Fsyntax_kinds%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_kinds%2Fgenerated.rs?ref=a9a6a50c759302e8a8d59bf6c53c72ec804324b3", "patch": "@@ -205,7 +205,6 @@ pub enum SyntaxKind {\n     PATH,\n     PATH_SEGMENT,\n     LITERAL,\n-    LITERAL_EXPR,\n     ALIAS,\n     VISIBILITY,\n     WHERE_CLAUSE,\n@@ -468,7 +467,6 @@ impl SyntaxKind {\n             PATH => &SyntaxInfo { name: \"PATH\" },\n             PATH_SEGMENT => &SyntaxInfo { name: \"PATH_SEGMENT\" },\n             LITERAL => &SyntaxInfo { name: \"LITERAL\" },\n-            LITERAL_EXPR => &SyntaxInfo { name: \"LITERAL_EXPR\" },\n             ALIAS => &SyntaxInfo { name: \"ALIAS\" },\n             VISIBILITY => &SyntaxInfo { name: \"VISIBILITY\" },\n             WHERE_CLAUSE => &SyntaxInfo { name: \"WHERE_CLAUSE\" },"}]}