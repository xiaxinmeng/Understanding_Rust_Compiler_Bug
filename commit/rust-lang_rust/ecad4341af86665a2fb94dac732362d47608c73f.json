{"sha": "ecad4341af86665a2fb94dac732362d47608c73f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYWQ0MzQxYWY4NjY2NWEyZmI5NGRhYzczMjM2MmQ0NzYwOGM3M2Y=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-18T18:31:01Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-27T18:54:05Z"}, "message": "Port `RequiresStorage` to new dataflow framework", "tree": {"sha": "ccc7bffd1107b992373f43462e971f78aa7bd0e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccc7bffd1107b992373f43462e971f78aa7bd0e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecad4341af86665a2fb94dac732362d47608c73f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecad4341af86665a2fb94dac732362d47608c73f", "html_url": "https://github.com/rust-lang/rust/commit/ecad4341af86665a2fb94dac732362d47608c73f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecad4341af86665a2fb94dac732362d47608c73f/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d7ce880aa213b631bf67cb54734e2e3ccd91336", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7ce880aa213b631bf67cb54734e2e3ccd91336", "html_url": "https://github.com/rust-lang/rust/commit/6d7ce880aa213b631bf67cb54734e2e3ccd91336"}], "stats": {"total": 197, "additions": 97, "deletions": 100}, "files": [{"sha": "87d8e9e411c6fba6f494d362441d8149be914955", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecad4341af86665a2fb94dac732362d47608c73f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecad4341af86665a2fb94dac732362d47608c73f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=ecad4341af86665a2fb94dac732362d47608c73f", "patch": "@@ -14,7 +14,7 @@ use crate::util::elaborate_drops::DropFlagState;\n \n use super::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n use super::move_paths::{HasMoveData, InitIndex, InitKind, LookupResult, MoveData, MovePathIndex};\n-use super::{BottomValue, GenKillSet};\n+use super::BottomValue;\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;"}, {"sha": "828321f7031eeddee30108677d7f809ccd492b97", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 69, "deletions": 50, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ecad4341af86665a2fb94dac732362d47608c73f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecad4341af86665a2fb94dac732362d47608c73f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=ecad4341af86665a2fb94dac732362d47608c73f", "patch": "@@ -76,7 +76,7 @@ pub struct RequiresStorage<'mir, 'tcx> {\n     borrowed_locals: RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n }\n \n-impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n+impl<'mir, 'tcx> RequiresStorage<'mir, 'tcx> {\n     pub fn new(\n         body: ReadOnlyBodyAndCache<'mir, 'tcx>,\n         borrowed_locals: &'mir Results<'tcx, MaybeBorrowedLocals>,\n@@ -86,45 +86,47 @@ impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n             borrowed_locals: RefCell::new(ResultsRefCursor::new(*body, borrowed_locals)),\n         }\n     }\n-\n-    pub fn body(&self) -> &Body<'tcx> {\n-        &self.body\n-    }\n }\n \n-impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n+impl<'mir, 'tcx> dataflow::AnalysisDomain<'tcx> for RequiresStorage<'mir, 'tcx> {\n     type Idx = Local;\n-    fn name() -> &'static str {\n-        \"requires_storage\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n-        self.body.local_decls.len()\n+\n+    const NAME: &'static str = \"requires_storage\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, on_entry: &mut BitSet<Local>) {\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, on_entry: &mut BitSet<Self::Idx>) {\n         // The resume argument is live on function entry (we don't care about\n         // the `self` argument)\n-        for arg in self.body.args_iter().skip(1) {\n+        for arg in body.args_iter().skip(1) {\n             on_entry.insert(arg);\n         }\n     }\n+}\n \n-    fn before_statement_effect(&self, sets: &mut GenKillSet<Self::Idx>, loc: Location) {\n-        let stmt = &self.body[loc.block].statements[loc.statement_index];\n-\n+impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for RequiresStorage<'mir, 'tcx> {\n+    fn before_statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        stmt: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n         // If a place is borrowed in a statement, it needs storage for that statement.\n-        self.borrowed_locals.borrow().analysis().statement_effect(sets, stmt, loc);\n+        self.borrowed_locals.borrow().analysis().statement_effect(trans, stmt, loc);\n \n-        // If a place is assigned to in a statement, it needs storage for that statement.\n         match &stmt.kind {\n-            StatementKind::StorageDead(l) => sets.kill(*l),\n+            StatementKind::StorageDead(l) => trans.kill(*l),\n+\n+            // If a place is assigned to in a statement, it needs storage for that statement.\n             StatementKind::Assign(box (place, _))\n             | StatementKind::SetDiscriminant { box place, .. } => {\n-                sets.gen(place.local);\n+                trans.gen(place.local);\n             }\n-            StatementKind::InlineAsm(box InlineAsm { outputs, .. }) => {\n-                for place in &**outputs {\n-                    sets.gen(place.local);\n+            StatementKind::InlineAsm(asm) => {\n+                for place in &*asm.outputs {\n+                    trans.gen(place.local);\n                 }\n             }\n \n@@ -138,22 +140,30 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         }\n     }\n \n-    fn statement_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n         // If we move from a place then only stops needing storage *after*\n         // that statement.\n-        self.check_for_move(sets, loc);\n+        self.check_for_move(trans, loc);\n     }\n \n-    fn before_terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n-        let terminator = self.body[loc.block].terminator();\n-\n+    fn before_terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n         // If a place is borrowed in a terminator, it needs storage for that terminator.\n-        self.borrowed_locals.borrow().analysis().terminator_effect(sets, terminator, loc);\n+        self.borrowed_locals.borrow().analysis().terminator_effect(trans, terminator, loc);\n \n         match &terminator.kind {\n-            TerminatorKind::Call { destination: Some((Place { local, .. }, _)), .. }\n-            | TerminatorKind::Yield { resume_arg: Place { local, .. }, .. } => {\n-                sets.gen(*local);\n+            TerminatorKind::Call { destination: Some((place, _)), .. }\n+            | TerminatorKind::Yield { resume_arg: place, .. } => {\n+                trans.gen(place.local);\n             }\n \n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n@@ -174,14 +184,19 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         }\n     }\n \n-    fn terminator_effect(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n-        match &self.body[loc.block].terminator().kind {\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        match &terminator.kind {\n             // For call terminators the destination requires storage for the call\n             // and after the call returns successfully, but not after a panic.\n             // Since `propagate_call_unwind` doesn't exist, we have to kill the\n-            // destination here, and then gen it again in `propagate_call_return`.\n-            TerminatorKind::Call { destination: Some((Place { local, .. }, _)), .. } => {\n-                sets.kill(*local);\n+            // destination here, and then gen it again in `call_return_effect`.\n+            TerminatorKind::Call { destination: Some((place, _)), .. } => {\n+                trans.kill(place.local);\n             }\n \n             // Nothing to do for these. Match exhaustively so this fails to compile when new\n@@ -202,24 +217,25 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n             | TerminatorKind::Unreachable => {}\n         }\n \n-        self.check_for_move(sets, loc);\n+        self.check_for_move(trans, loc);\n     }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        in_out: &mut BitSet<Local>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n-        dest_place: &mir::Place<'tcx>,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n     ) {\n-        in_out.insert(dest_place.local);\n+        trans.gen(return_place.local);\n     }\n }\n \n impl<'mir, 'tcx> RequiresStorage<'mir, 'tcx> {\n     /// Kill locals that are fully moved and have not been borrowed.\n-    fn check_for_move(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n-        let mut visitor = MoveVisitor { sets, borrowed_locals: &self.borrowed_locals };\n+    fn check_for_move(&self, trans: &mut impl GenKill<Local>, loc: Location) {\n+        let mut visitor = MoveVisitor { trans, borrowed_locals: &self.borrowed_locals };\n         visitor.visit_location(self.body, loc);\n     }\n }\n@@ -229,18 +245,21 @@ impl<'mir, 'tcx> BottomValue for RequiresStorage<'mir, 'tcx> {\n     const BOTTOM_VALUE: bool = false;\n }\n \n-struct MoveVisitor<'a, 'mir, 'tcx> {\n+struct MoveVisitor<'a, 'mir, 'tcx, T> {\n     borrowed_locals: &'a RefCell<BorrowedLocalsResults<'mir, 'tcx>>,\n-    sets: &'a mut GenKillSet<Local>,\n+    trans: &'a mut T,\n }\n \n-impl<'a, 'mir: 'a, 'tcx> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx> {\n+impl<'a, 'mir, 'tcx, T> Visitor<'tcx> for MoveVisitor<'a, 'mir, 'tcx, T>\n+where\n+    T: GenKill<Local>,\n+{\n     fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n         if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n             let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n             borrowed_locals.seek_before(loc);\n             if !borrowed_locals.contains(*local) {\n-                self.sets.kill(*local);\n+                self.trans.kill(*local);\n             }\n         }\n     }"}, {"sha": "b9d2a167d73c999faa080f478312fc58ad3b3b19", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ecad4341af86665a2fb94dac732362d47608c73f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecad4341af86665a2fb94dac732362d47608c73f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=ecad4341af86665a2fb94dac732362d47608c73f", "patch": "@@ -49,9 +49,7 @@\n //! For generators with state 1 (returned) and state 2 (poisoned) it does nothing.\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n-use crate::dataflow::generic::{Analysis, ResultsCursor};\n-use crate::dataflow::{do_dataflow, DataflowResultsCursor, DebugFormatted};\n-use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n+use crate::dataflow::generic::{self as dataflow, Analysis};\n use crate::dataflow::{MaybeBorrowedLocals, MaybeStorageLive, RequiresStorage};\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;\n@@ -467,7 +465,6 @@ fn locals_live_across_suspend_points(\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> LivenessInfo {\n-    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let def_id = source.def_id();\n     let body_ref: &Body<'_> = &body;\n \n@@ -488,22 +485,16 @@ fn locals_live_across_suspend_points(\n     let borrowed_locals_results =\n         MaybeBorrowedLocals::all_borrows().into_engine(tcx, body_ref, def_id).iterate_to_fixpoint();\n \n-    let mut borrowed_locals_cursor = ResultsCursor::new(body_ref, &borrowed_locals_results);\n+    let mut borrowed_locals_cursor =\n+        dataflow::ResultsCursor::new(body_ref, &borrowed_locals_results);\n \n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n-    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_results);\n-    let requires_storage_results = do_dataflow(\n-        tcx,\n-        body_ref,\n-        def_id,\n-        &[],\n-        &dead_unwinds,\n-        requires_storage_analysis,\n-        |bd, p| DebugFormatted::new(&bd.body().local_decls[p]),\n-    );\n+    let requires_storage_results = RequiresStorage::new(body, &borrowed_locals_results)\n+        .into_engine(tcx, body_ref, def_id)\n+        .iterate_to_fixpoint();\n     let mut requires_storage_cursor =\n-        DataflowResultsCursor::new(&requires_storage_results, body_ref);\n+        dataflow::ResultsCursor::new(body_ref, &requires_storage_results);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n@@ -539,7 +530,7 @@ fn locals_live_across_suspend_points(\n             // after a suspension point\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n-            requires_storage_cursor.seek(loc);\n+            requires_storage_cursor.seek_before(loc);\n             let storage_required = requires_storage_cursor.get().clone();\n \n             // Locals live are live at this point only if they are used across\n@@ -609,7 +600,7 @@ fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &liveness::LiveVarSet,\n     ignored: &StorageIgnored,\n-    requires_storage: DataflowResults<'tcx, RequiresStorage<'mir, 'tcx>>,\n+    requires_storage: dataflow::Results<'tcx, RequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n     assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n     assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n@@ -627,8 +618,10 @@ fn compute_storage_conflicts(\n         stored_locals: &stored_locals,\n         local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n     };\n-    let mut state = FlowAtLocation::new(requires_storage);\n-    visitor.analyze_results(&mut state);\n+\n+    // FIXME: Do we need to do this in RPO?\n+    requires_storage.visit_in_rpo_with(body, &mut visitor);\n+\n     let local_conflicts = visitor.local_conflicts;\n \n     // Compress the matrix using only stored locals (Local -> GeneratorSavedLocal).\n@@ -657,60 +650,45 @@ fn compute_storage_conflicts(\n     storage_conflicts\n }\n \n-struct StorageConflictVisitor<'body, 'tcx, 's> {\n-    body: &'body Body<'tcx>,\n+struct StorageConflictVisitor<'mir, 'tcx, 's> {\n+    body: &'mir Body<'tcx>,\n     stored_locals: &'s liveness::LiveVarSet,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n }\n \n-impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n-    for StorageConflictVisitor<'body, 'tcx, 's>\n-{\n-    type FlowState = FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx>>;\n-\n-    fn body(&self) -> &'body Body<'tcx> {\n-        self.body\n-    }\n-\n-    fn visit_block_entry(&mut self, block: BasicBlock, flow_state: &Self::FlowState) {\n-        // statement_index is only used for logging, so this is fine.\n-        self.apply_state(flow_state, Location { block, statement_index: 0 });\n-    }\n+impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx, '_> {\n+    type FlowState = BitSet<Local>;\n \n-    fn visit_statement_entry(\n+    fn visit_statement(\n         &mut self,\n+        state: &Self::FlowState,\n+        _statement: &'mir Statement<'tcx>,\n         loc: Location,\n-        _stmt: &Statement<'tcx>,\n-        flow_state: &Self::FlowState,\n     ) {\n-        self.apply_state(flow_state, loc);\n+        self.apply_state(state, loc);\n     }\n \n-    fn visit_terminator_entry(\n+    fn visit_terminator(\n         &mut self,\n+        state: &Self::FlowState,\n+        _terminator: &'mir Terminator<'tcx>,\n         loc: Location,\n-        _term: &Terminator<'tcx>,\n-        flow_state: &Self::FlowState,\n     ) {\n-        self.apply_state(flow_state, loc);\n+        self.apply_state(state, loc);\n     }\n }\n \n impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n-    fn apply_state(\n-        &mut self,\n-        flow_state: &FlowAtLocation<'tcx, RequiresStorage<'body, 'tcx>>,\n-        loc: Location,\n-    ) {\n+    fn apply_state(&mut self, flow_state: &BitSet<Local>, loc: Location) {\n         // Ignore unreachable blocks.\n         match self.body.basic_blocks()[loc.block].terminator().kind {\n             TerminatorKind::Unreachable => return,\n             _ => (),\n         };\n \n-        let mut eligible_storage_live = flow_state.as_dense().clone();\n+        let mut eligible_storage_live = flow_state.clone();\n         eligible_storage_live.intersect(&self.stored_locals);\n \n         for local in eligible_storage_live.iter() {"}]}