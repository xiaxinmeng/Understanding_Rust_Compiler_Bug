{"sha": "5759f2fc571f9531c675a5966b44d570b7dbe685", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NTlmMmZjNTcxZjk1MzFjNjc1YTU5NjZiNDRkNTcwYjdkYmU2ODU=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-16T21:26:15Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-23T05:19:53Z"}, "message": "Strip down Cell functionality", "tree": {"sha": "37158dccd917ca076e3c7f95cb3367db3d9ff03e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37158dccd917ca076e3c7f95cb3367db3d9ff03e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5759f2fc571f9531c675a5966b44d570b7dbe685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5759f2fc571f9531c675a5966b44d570b7dbe685", "html_url": "https://github.com/rust-lang/rust/commit/5759f2fc571f9531c675a5966b44d570b7dbe685", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5759f2fc571f9531c675a5966b44d570b7dbe685/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a26266f6586f765ebdfbc0304e4976bfff28895", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a26266f6586f765ebdfbc0304e4976bfff28895", "html_url": "https://github.com/rust-lang/rust/commit/8a26266f6586f765ebdfbc0304e4976bfff28895"}], "stats": {"total": 108, "additions": 24, "deletions": 84}, "files": [{"sha": "8af370792aee158f121c280ee56d4c64216e95da", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5759f2fc571f9531c675a5966b44d570b7dbe685/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5759f2fc571f9531c675a5966b44d570b7dbe685/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=5759f2fc571f9531c675a5966b44d570b7dbe685", "patch": "@@ -24,7 +24,6 @@ use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n-use std::cell::Cell;\n use std::hashmap::{HashMap, HashSet};\n use std::uint;\n use std::vec;\n@@ -106,16 +105,15 @@ pub struct RegionVarBindings {\n     undo_log: ~[UndoLogEntry],\n \n     // This contains the results of inference.  It begins as an empty\n-    // cell and only acquires a value after inference is complete.\n-    // We use a cell vs a mutable option to circumvent borrowck errors.\n-    values: Cell<~[VarValue]>,\n+    // option and only acquires a value after inference is complete.\n+    values: Option<~[VarValue]>,\n }\n \n pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     RegionVarBindings {\n         tcx: tcx,\n         var_origins: ~[],\n-        values: Cell::new_empty(),\n+        values: None,\n         constraints: HashMap::new(),\n         lubs: HashMap::new(),\n         glbs: HashMap::new(),\n@@ -226,7 +224,7 @@ impl RegionVarBindings {\n                           constraint: Constraint,\n                           origin: SubregionOrigin) {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_empty());\n+        assert!(self.values.is_none());\n \n         debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n@@ -242,7 +240,7 @@ impl RegionVarBindings {\n                           sub: Region,\n                           sup: Region) {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_empty());\n+        assert!(self.values.is_none());\n \n         debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n@@ -277,7 +275,7 @@ impl RegionVarBindings {\n                        b: Region)\n                        -> Region {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_empty());\n+        assert!(self.values.is_none());\n \n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -300,7 +298,7 @@ impl RegionVarBindings {\n                        b: Region)\n                        -> Region {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values.is_empty());\n+        assert!(self.values.is_none());\n \n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -319,14 +317,14 @@ impl RegionVarBindings {\n     }\n \n     pub fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n-        if self.values.is_empty() {\n-            self.tcx.sess.span_bug(\n+        let v = match self.values {\n+            None => self.tcx.sess.span_bug(\n                 self.var_origins[rid.to_uint()].span(),\n                 format!(\"Attempt to resolve region variable before values have \\\n-                      been computed!\"));\n-        }\n+                      been computed!\")),\n+            Some(ref values) => values[rid.to_uint()]\n+        };\n \n-        let v = self.values.with_ref(|values| values[rid.to_uint()]);\n         debug!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n                rid, rid.to_uint(), v);\n         match v {\n@@ -482,7 +480,7 @@ impl RegionVarBindings {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = opt_vec::Empty;\n         let v = self.infer_variable_values(&mut errors);\n-        self.values.put_back(v);\n+        self.values = Some(v);\n         errors\n     }\n }"}, {"sha": "b33a18ed95dd350a57ab3cbc023a9d80c02e8802", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 3, "deletions": 59, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5759f2fc571f9531c675a5966b44d570b7dbe685/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5759f2fc571f9531c675a5966b44d570b7dbe685/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=5759f2fc571f9531c675a5966b44d570b7dbe685", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A mutable, nullable memory location\n+//! Runtime move semantics\n \n #[missing_doc];\n \n use cast::transmute_mut;\n-use unstable::finally::Finally;\n use prelude::*;\n \n /*\n@@ -35,11 +34,6 @@ impl<T> Cell<T> {\n         Cell { value: Some(value) }\n     }\n \n-    /// Creates a new empty cell with no value inside.\n-    pub fn new_empty() -> Cell<T> {\n-        Cell { value: None }\n-    }\n-\n     /// Yields the value, failing if the cell is empty.\n     pub fn take(&self) -> T {\n         let this = unsafe { transmute_mut(self) };\n@@ -56,34 +50,10 @@ impl<T> Cell<T> {\n         this.value.take()\n     }\n \n-    /// Returns the value, failing if the cell is full.\n-    pub fn put_back(&self, value: T) {\n-        let this = unsafe { transmute_mut(self) };\n-        if !this.is_empty() {\n-            fail!(\"attempt to put a value back into a full cell\");\n-        }\n-        this.value = Some(value);\n-    }\n-\n     /// Returns true if the cell is empty and false if the cell is full.\n     pub fn is_empty(&self) -> bool {\n         self.value.is_none()\n     }\n-\n-    /// Calls a closure with a reference to the value.\n-    pub fn with_ref<R>(&self, op: |v: &T| -> R) -> R {\n-        do self.with_mut_ref |ptr| { op(ptr) }\n-    }\n-\n-    /// Calls a closure with a mutable reference to the value.\n-    pub fn with_mut_ref<R>(&self, op: |v: &mut T| -> R) -> R {\n-        let mut v = Some(self.take());\n-        do (|| {\n-            op(v.get_mut_ref())\n-        }).finally {\n-            self.put_back(v.take_unwrap());\n-        }\n-    }\n }\n \n #[test]\n@@ -93,38 +63,12 @@ fn test_basic() {\n     let value = value_cell.take();\n     assert!(value == ~10);\n     assert!(value_cell.is_empty());\n-    value_cell.put_back(value);\n-    assert!(!value_cell.is_empty());\n }\n \n #[test]\n #[should_fail]\n fn test_take_empty() {\n-    let value_cell: Cell<~int> = Cell::new_empty();\n+    let value_cell: Cell<~int> = Cell::new(~0);\n+    value_cell.take();\n     value_cell.take();\n-}\n-\n-#[test]\n-#[should_fail]\n-fn test_put_back_non_empty() {\n-    let value_cell = Cell::new(~10);\n-    value_cell.put_back(~20);\n-}\n-\n-#[test]\n-fn test_with_ref() {\n-    let good = 6;\n-    let c = Cell::new(~[1, 2, 3, 4, 5, 6]);\n-    let l = do c.with_ref() |v| { v.len() };\n-    assert_eq!(l, good);\n-}\n-\n-#[test]\n-fn test_with_mut_ref() {\n-    let good = ~[1, 2, 3];\n-    let v = ~[1, 2];\n-    let c = Cell::new(v);\n-    do c.with_mut_ref() |v| { v.push(3); }\n-    let v = c.take();\n-    assert_eq!(v, good);\n }"}, {"sha": "f3b78ecd30c676423317d46182a516008171a78a", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5759f2fc571f9531c675a5966b44d570b7dbe685/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5759f2fc571f9531c675a5966b44d570b7dbe685/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=5759f2fc571f9531c675a5966b44d570b7dbe685", "patch": "@@ -81,8 +81,7 @@ fn main() {\n     let num_tasks = from_str::<uint>(args[1]).unwrap();\n     let msg_per_task = from_str::<uint>(args[2]).unwrap();\n \n-    let (num_chan, num_port) = init();\n-    let num_chan = Cell::new(num_chan);\n+    let (mut num_chan, num_port) = init();\n \n     let start = time::precise_time_s();\n \n@@ -92,19 +91,19 @@ fn main() {\n     for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = Cell::new(num_chan.take());\n+        let num_chan2 = Cell::new(num_chan);\n         let num_port = Cell::new(num_port);\n         let new_future = do Future::spawn() {\n             let num_chan = num_chan2.take();\n             let num_port1 = num_port.take();\n             thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan.put_back(new_chan);\n+        num_chan = new_chan;\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n+    thread_ring(0, msg_per_task, num_chan, num_port);\n \n     // synchronize\n     for f in futures.mut_iter() {"}, {"sha": "47b1e5903280ee22324fb32e38ddf57bf5acc396", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5759f2fc571f9531c675a5966b44d570b7dbe685/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5759f2fc571f9531c675a5966b44d570b7dbe685/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=5759f2fc571f9531c675a5966b44d570b7dbe685", "patch": "@@ -77,8 +77,7 @@ fn main() {\n     let num_tasks = from_str::<uint>(args[1]).unwrap();\n     let msg_per_task = from_str::<uint>(args[2]).unwrap();\n \n-    let (num_chan, num_port) = init();\n-    let num_chan = Cell::new(num_chan);\n+    let (mut num_chan, num_port) = init();\n \n     let start = time::precise_time_s();\n \n@@ -88,19 +87,19 @@ fn main() {\n     for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = Cell::new(num_chan.take());\n+        let num_chan2 = Cell::new(num_chan);\n         let num_port = Cell::new(num_port);\n         let new_future = do Future::spawn {\n             let num_chan = num_chan2.take();\n             let num_port1 = num_port.take();\n             thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan.put_back(new_chan);\n+        num_chan = new_chan;\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n+    thread_ring(0, msg_per_task, num_chan, num_port);\n \n     // synchronize\n     for f in futures.mut_iter() {"}]}