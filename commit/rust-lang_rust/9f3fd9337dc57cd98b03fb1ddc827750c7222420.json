{"sha": "9f3fd9337dc57cd98b03fb1ddc827750c7222420", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmM2ZkOTMzN2RjNTdjZDk4YjAzZmIxZGRjODI3NzUwYzcyMjI0MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-17T02:11:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-17T02:11:26Z"}, "message": "auto merge of #13499 : brson/rust/resultdocs, r=brson\n\nThis adds some fairly extensive documentation for `Result`.\r\n\r\nI'm using manual links to other rustdoc html pages a bit.", "tree": {"sha": "c5eaab94be5f8db65defcf8aa63aa0c4229a6c3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5eaab94be5f8db65defcf8aa63aa0c4229a6c3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f3fd9337dc57cd98b03fb1ddc827750c7222420", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3fd9337dc57cd98b03fb1ddc827750c7222420", "html_url": "https://github.com/rust-lang/rust/commit/9f3fd9337dc57cd98b03fb1ddc827750c7222420", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f3fd9337dc57cd98b03fb1ddc827750c7222420/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88805e1e007e7a42857ca4cdaf65b538696e77fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/88805e1e007e7a42857ca4cdaf65b538696e77fd", "html_url": "https://github.com/rust-lang/rust/commit/88805e1e007e7a42857ca4cdaf65b538696e77fd"}, {"sha": "e69bd81deca29f9adbf175760dddbaec9be3163d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e69bd81deca29f9adbf175760dddbaec9be3163d", "html_url": "https://github.com/rust-lang/rust/commit/e69bd81deca29f9adbf175760dddbaec9be3163d"}], "stats": {"total": 330, "additions": 325, "deletions": 5}, "files": [{"sha": "0b6897ba2dc4f0c1429a603fc86d8f8eba6d2090", "filename": "src/libstd/result.rs", "status": "modified", "additions": 325, "deletions": 5, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/9f3fd9337dc57cd98b03fb1ddc827750c7222420/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3fd9337dc57cd98b03fb1ddc827750c7222420/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=9f3fd9337dc57cd98b03fb1ddc827750c7222420", "patch": "@@ -8,7 +8,263 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Signaling success or failure states (`Result` type)\n+//! Error handling with the `Result` type\n+//!\n+//! `Result<T>` is the type used for returning and propagating\n+//! errors. It is an enum with the variants, `Ok(T)`, representing\n+//! success and containing a value, and `Err(E)`, representing error\n+//! and containing an error value.\n+//!\n+//! ~~~\n+//! enum Result<T, E> {\n+//!    Ok(T),\n+//!    Err(E)\n+//! }\n+//! ~~~\n+//!\n+//! Functions return `Result` whenever errors are expected and\n+//! recoverable. In the `std` crate `Result` is most prominently used\n+//! for [I/O](../io/index.html).\n+//!\n+//! A simple function returning `Result` might be\n+//! defined and used like so:\n+//!\n+//! ~~~\n+//! #[deriving(Show)]\n+//! enum Version { Version1, Version2 }\n+//!\n+//! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n+//!     if header.len() < 1 {\n+//!         return Err(\"invalid header length\");\n+//!     }\n+//!     match header[0] {\n+//!         1 => Ok(Version1),\n+//!         2 => Ok(Version2),\n+//!         _ => Err(\"invalid version\")\n+//!     }\n+//! }\n+//!\n+//! let version = parse_version(&[1, 2, 3, 4]);\n+//! match version {\n+//!     Ok(v) => {\n+//!         println!(\"working with version: {}\", v);\n+//!     }\n+//!     Err(e) => {\n+//!         println!(\"error parsing header: {}\", e);\n+//!     }\n+//! }\n+//! ~~~\n+//!\n+//! Pattern matching on `Result`s is clear and straightforward for\n+//! simple cases, but `Result` comes with some convenience methods\n+//! that make working it more succinct.\n+//!\n+//! ~~~\n+//! let good_result: Result<int, int> = Ok(10);\n+//! let bad_result: Result<int, int> = Err(10);\n+//!\n+//! // The `is_ok` and `is_err` methods do what they say.\n+//! assert!(good_result.is_ok() && !good_result.is_err());\n+//! assert!(bad_result.is_err() && !bad_result.is_ok());\n+//!\n+//! // `map` consumes the `Result` and produces another.\n+//! let good_result: Result<int, int> = good_result.map(|i| i + 1);\n+//! let bad_result: Result<int, int> = bad_result.map(|i| i - 1);\n+//!\n+//! // Use `and_then` to continue the computation.\n+//! let good_result: Result<bool, int> = good_result.and_then(|i| Ok(i == 11));\n+//!\n+//! // Use `or_else` to handle the error.\n+//! let bad_result: Result<int, int> = bad_result.or_else(|i| Ok(11));\n+//!\n+//! // Consume the result and return the contents with `unwrap`.\n+//! let final_awesome_result = good_result.ok().unwrap();\n+//! ~~~\n+//!\n+//! # Results must be used\n+//!\n+//! A common problem with using return values to indicate errors is\n+//! that it is easy to ignore the return value, thus failing to handle\n+//! the error. Result is annotated with the #[must_use] attribute,\n+//! which will cause the compiler to issue a warning when a Result\n+//! value is ignored. This makes `Result` especially useful with\n+//! functions that may encounter errors but don't otherwise return a\n+//! useful value.\n+//!\n+//! Consider the `write_line` method defined for I/O types\n+//! by the [`Writer`](../io/trait.Writer.html) trait:\n+//!\n+//! ~~~\n+//! use std::io::IoError;\n+//!\n+//! trait Writer {\n+//!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n+//! }\n+//! ~~~\n+//!\n+//! *Note: The actual definition of `Writer` uses `IoResult`, which\n+//! is just a synonymn for `Result<T, IoError>`.*\n+//!\n+//! This method doesn`t produce a value, but the write may\n+//! fail. It's crucial to handle the error case, and *not* write\n+//! something like this:\n+//!\n+//! ~~~ignore\n+//! use std::io::{File, Open, Write};\n+//!\n+//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! // If `write_line` errors, then we'll never know, because the return\n+//! // value is ignored.\n+//! file.write_line(\"important message\");\n+//! drop(file);\n+//! ~~~\n+//!\n+//! If you *do* write that in Rust, the compiler will by give you a\n+//! warning (by default, controlled by the `unused_must_use` lint).\n+//!\n+//! You might instead, if you don't want to handle the error, simply\n+//! fail, by converting to an `Option` with `ok`, then asserting\n+//! success with `expect`. This will fail if the write fails, proving\n+//! a marginally useful message indicating why:\n+//!\n+//! ~~~no_run\n+//! use std::io::{File, Open, Write};\n+//!\n+//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n+//! drop(file);\n+//! ~~~\n+//!\n+//! You might also simply assert success:\n+//!\n+//! ~~~no_run\n+//! # use std::io::{File, Open, Write};\n+//!\n+//! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! assert!(file.write_line(\"important message\").is_ok());\n+//! # drop(file);\n+//! ~~~\n+//!\n+//! Or propagate the error up the call stack with `try!`:\n+//!\n+//! ~~~\n+//! # use std::io::{File, Open, Write, IoError};\n+//! fn write_message() -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//!     try!(file.write_line(\"important message\"));\n+//!     drop(file);\n+//!     return Ok(());\n+//! }\n+//! ~~~\n+//!\n+//! # The `try!` macro\n+//!\n+//! When writing code that calls many functions that return the\n+//! `Result` type, the error handling can be tedious.  The `try!`\n+//! macro hides some of the boilerplate of propagating errors up the\n+//! call stack.\n+//!\n+//! It replaces this:\n+//!\n+//! ~~~\n+//! use std::io::{File, Open, Write, IoError};\n+//!\n+//! struct Info { name: ~str, age: int, rating: int }\n+//!\n+//! fn write_info(info: &Info) -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//!     // Early return on error\n+//!     match file.write_line(format!(\"name: {}\", info.name)) {\n+//!         Ok(_) => (),\n+//!         Err(e) => return Err(e)\n+//!     }\n+//!     match file.write_line(format!(\"age: {}\", info.age)) {\n+//!         Ok(_) => (),\n+//!         Err(e) => return Err(e)\n+//!     }\n+//!     return file.write_line(format!(\"rating: {}\", info.rating));\n+//! }\n+//! ~~~\n+//!\n+//! With this:\n+//!\n+//! ~~~\n+//! use std::io::{File, Open, Write, IoError};\n+//!\n+//! struct Info { name: ~str, age: int, rating: int }\n+//!\n+//! fn write_info(info: &Info) -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//!     // Early return on error\n+//!     try!(file.write_line(format!(\"name: {}\", info.name)));\n+//!     try!(file.write_line(format!(\"age: {}\", info.age)));\n+//!     try!(file.write_line(format!(\"rating: {}\", info.rating)));\n+//!     return Ok(());\n+//! }\n+//! ~~~\n+//!\n+//! *It's much nicer!*\n+//!\n+//! Wrapping an expression in `try!` will result in the unwrapped\n+//! success (`Ok`) value, unless the result is `Err`, in which case\n+//! `Err` is returned early from the enclosing function. Its simple definition\n+//! makes it clear:\n+//!\n+//! ~~~\n+//! # #![feature(macro_rules)]\n+//! macro_rules! try(\n+//!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+//! )\n+//! # fn main() { }\n+//! ~~~\n+//!\n+//! `try!` is imported by the prelude, and is available everywhere.\n+//!\n+//! # `Result` and `Option`\n+//!\n+//! The `Result` and [`Option`](../option/index.html) types are\n+//! similar and complementary: they are often employed to indicate a\n+//! lack of a return value; and they are trivially converted between\n+//! each other, so `Result`s are often handled by first converting to\n+//! `Option` with the [`ok`](enum.Result.html#method.ok) and\n+//! [`err`](enum.Result.html#method.ok) methods.\n+//!\n+//! Whereas `Option` only indicates the lack of a value, `Result` is\n+//! specifically for error reporting, and carries with it an error\n+//! value.  Sometimes `Option` is used for indicating errors, but this\n+//! is only for simple cases and is generally discouraged. Even when\n+//! there is no useful error value to return, prefer `Result<T, ()>`.\n+//!\n+//! Converting to an `Option` with `ok()` to handle an error:\n+//!\n+//! ~~~\n+//! use std::io::Timer;\n+//! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n+//! ~~~\n+//!\n+//! # `Result` vs. `fail!`\n+//!\n+//! `Result` is for recoverable errors; `fail!` is for unrecoverable\n+//! errors. Callers should always be able to avoid failure if they\n+//! take the proper precautions, for example, calling `is_some()`\n+//! on an `Option` type before calling `unwrap`.\n+//!\n+//! The suitability of `fail!` as an error handling mechanism is\n+//! limited by Rust's lack of any way to \"catch\" and resume execution\n+//! from a thrown exception. Therefore using failure for error\n+//! handling requires encapsulating fallable code in a task. Calling\n+//! the `fail!` macro, or invoking `fail!` indirectly should be\n+//! avoided as an error reporting strategy. Failure is only for\n+//! unrecovereable errors and a failing task is typically the sign of\n+//! a bug.\n+//!\n+//! A module that instead returns `Results` is alerting the caller\n+//! that failure is possible, and providing precise control over how\n+//! it is handled.\n+//!\n+//! Furthermore, failure may not be recoverable at all, depending on\n+//! the context. The caller of `fail!` should assume that execution\n+//! will not resume after failure, that failure is catastrophic.\n \n use clone::Clone;\n use cmp::Eq;\n@@ -17,6 +273,8 @@ use iter::{Iterator, FromIterator};\n use option::{None, Option, Some};\n \n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n+///\n+/// See the [`std::result`](index.html) module documentation for details.\n #[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show)]\n #[must_use]\n pub enum Result<T, E> {\n@@ -37,6 +295,17 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns true if the result is `Ok`\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~\n+    /// use std::io::{File, Open, Write};\n+    ///\n+    /// # fn do_not_run_example() { // creates a file\n+    /// let mut file = File::open_mode(&Path::new(\"secret.txt\"), Open, Write);\n+    /// assert!(file.write_line(\"it's cold in here\").is_ok());\n+    /// # }\n+    /// ~~~\n     #[inline]\n     pub fn is_ok(&self) -> bool {\n         match *self {\n@@ -46,6 +315,17 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Returns true if the result is `Err`\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~\n+    /// use std::io::{File, Open, Read};\n+    ///\n+    /// // When opening with `Read` access, if the file does not exist\n+    /// // then `open_mode` returns an error.\n+    /// let bogus = File::open_mode(&Path::new(\"not_a_file.txt\"), Open, Read);\n+    /// assert!(bogus.is_err());\n+    /// ~~~\n     #[inline]\n     pub fn is_err(&self) -> bool {\n         !self.is_ok()\n@@ -57,6 +337,22 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Convert from `Result<T, E>` to `Option<T>`\n+    ///\n+    /// Converts `self` into an `Option<T>`, consuming `self`,\n+    /// and discarding the error, if any.\n+    ///\n+    /// To convert to an `Option` without discarding the error value,\n+    /// use `as_ref` to first convert the `Result<T, E>` into a\n+    /// `Result<&T, &E>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~{.should_fail}\n+    /// use std::io::{File, IoResult};\n+    ///\n+    /// let bdays: IoResult<File> = File::open(&Path::new(\"important_birthdays.txt\"));\n+    /// let bdays: File = bdays.ok().expect(\"unable to open birthday file\");\n+    /// ~~~\n     #[inline]\n     pub fn ok(self) -> Option<T> {\n         match self {\n@@ -66,6 +362,9 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Convert from `Result<T, E>` to `Option<E>`\n+    ///\n+    /// Converts `self` into an `Option<T>`, consuming `self`,\n+    /// and discarding the value, if any.\n     #[inline]\n     pub fn err(self) -> Option<E> {\n         match self {\n@@ -79,6 +378,9 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Convert from `Result<T, E>` to `Result<&T, &E>`\n+    ///\n+    /// Produces a new `Result`, containing a reference\n+    /// into the original, leaving the original in place.\n     #[inline]\n     pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n         match *self {\n@@ -105,11 +407,29 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used to compose the results of two functions.\n     ///\n-    /// Example:\n+    /// # Examples\n+    ///\n+    /// Sum the lines of a buffer by mapping strings to numbers,\n+    /// ignoring I/O and parse errors:\n+    ///\n+    /// ~~~\n+    /// use std::io::{BufReader, IoResult};\n+    ///\n+    /// let buffer = \"1\\n2\\n3\\n4\\n\";\n+    /// let mut reader = BufReader::new(buffer.as_bytes());\n+    ///\n+    /// let mut sum = 0;\n     ///\n-    ///     let res = read_file(file).map(|buf| {\n-    ///         parse_bytes(buf)\n-    ///     })\n+    /// while !reader.eof() {\n+    ///     let line: IoResult<~str> = reader.read_line();\n+    ///     // Convert the string line to a number using `map` and `from_str`\n+    ///     let val: IoResult<int> = line.map(|line| {\n+    ///         from_str::<int>(line).unwrap_or(0)\n+    ///     });\n+    ///     // Add the value if there were no errors, otherwise add 0\n+    ///     sum += val.ok().unwrap_or(0);\n+    /// }\n+    /// ~~~\n     #[inline]\n     pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n         match self {"}]}