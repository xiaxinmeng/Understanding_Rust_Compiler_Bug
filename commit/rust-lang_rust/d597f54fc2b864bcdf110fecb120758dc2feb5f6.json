{"sha": "d597f54fc2b864bcdf110fecb120758dc2feb5f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1OTdmNTRmYzJiODY0YmNkZjExMGZlY2IxMjA3NThkYzJmZWI1ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T13:52:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T13:52:03Z"}, "message": "auto merge of #8539 : pnkfelix/rust/fsk-visitor-vpar-defaults-step2, r=graydon,nikomatsakis\n\nr? @nikomatsakis\r\n\r\nFollow up to #8527 (which was step 1 of 5).  See that for overall description \r\n\r\nPart of #7081", "tree": {"sha": "0057844029534e30b244723bdebd67ef61ba71a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0057844029534e30b244723bdebd67ef61ba71a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d597f54fc2b864bcdf110fecb120758dc2feb5f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d597f54fc2b864bcdf110fecb120758dc2feb5f6", "html_url": "https://github.com/rust-lang/rust/commit/d597f54fc2b864bcdf110fecb120758dc2feb5f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d597f54fc2b864bcdf110fecb120758dc2feb5f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81a78161b5354c9cfecd8c659cc1dc3711d347d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/81a78161b5354c9cfecd8c659cc1dc3711d347d6", "html_url": "https://github.com/rust-lang/rust/commit/81a78161b5354c9cfecd8c659cc1dc3711d347d6"}, {"sha": "6c15f21bd76d0658866d2db431c4bb4bc6b2932e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c15f21bd76d0658866d2db431c4bb4bc6b2932e", "html_url": "https://github.com/rust-lang/rust/commit/6c15f21bd76d0658866d2db431c4bb4bc6b2932e"}], "stats": {"total": 1048, "additions": 602, "deletions": 446}, "files": [{"sha": "0530ffd30b4f0841f663f74faab5a4977560e626", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=d597f54fc2b864bcdf110fecb120758dc2feb5f6", "patch": "@@ -17,47 +17,71 @@ use util::ppaux;\n \n use syntax::ast::*;\n use syntax::codemap;\n-use syntax::{oldvisit, ast_util, ast_map};\n+use syntax::{ast_util, ast_map};\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+struct CheckCrateVisitor {\n+    sess: Session,\n+    ast_map: ast_map::map,\n+    def_map: resolve::DefMap,\n+    method_map: typeck::method_map,\n+    tcx: ty::ctxt,\n+}\n+\n+impl Visitor<bool> for CheckCrateVisitor {\n+    fn visit_item(&mut self, i:@item, env:bool) {\n+        check_item(self, self.sess, self.ast_map, self.def_map, i, env);\n+    }\n+    fn visit_pat(&mut self, p:@pat, env:bool) {\n+        check_pat(self, p, env);\n+    }\n+    fn visit_expr(&mut self, ex:@expr, env:bool) {\n+        check_expr(self, self.sess, self.def_map, self.method_map,\n+                   self.tcx, ex, env);\n+    }\n+}\n \n pub fn check_crate(sess: Session,\n                    crate: &Crate,\n                    ast_map: ast_map::map,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n                    tcx: ty::ctxt) {\n-    oldvisit::visit_crate(crate, (false, oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_item: |a,b| check_item(sess, ast_map, def_map, a, b),\n-        visit_pat: check_pat,\n-        visit_expr: |a,b|\n-            check_expr(sess, def_map, method_map, tcx, a, b),\n-        .. *oldvisit::default_visitor()\n-    })));\n+    let mut v = CheckCrateVisitor {\n+        sess: sess,\n+        ast_map: ast_map,\n+        def_map: def_map,\n+        method_map: method_map,\n+        tcx: tcx,\n+    };\n+    visit::walk_crate(&mut v, crate, false);\n     sess.abort_if_errors();\n }\n \n-pub fn check_item(sess: Session,\n+pub fn check_item(v: &mut CheckCrateVisitor,\n+                  sess: Session,\n                   ast_map: ast_map::map,\n                   def_map: resolve::DefMap,\n                   it: @item,\n-                  (_is_const, v): (bool,\n-                                   oldvisit::vt<bool>)) {\n+                  _is_const: bool) {\n     match it.node {\n       item_static(_, _, ex) => {\n-        (v.visit_expr)(ex, (true, v));\n+        v.visit_expr(ex, true);\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n       item_enum(ref enum_definition, _) => {\n         for var in (*enum_definition).variants.iter() {\n             for ex in var.node.disr_expr.iter() {\n-                (v.visit_expr)(*ex, (true, v));\n+                v.visit_expr(*ex, true);\n             }\n         }\n       }\n-      _ => oldvisit::visit_item(it, (false, v))\n+      _ => visit::walk_item(v, it, false)\n     }\n }\n \n-pub fn check_pat(p: @pat, (_is_const, v): (bool, oldvisit::vt<bool>)) {\n+pub fn check_pat(v: &mut CheckCrateVisitor, p: @pat, _is_const: bool) {\n     fn is_str(e: @expr) -> bool {\n         match e.node {\n             expr_vstore(\n@@ -72,22 +96,22 @@ pub fn check_pat(p: @pat, (_is_const, v): (bool, oldvisit::vt<bool>)) {\n     }\n     match p.node {\n       // Let through plain ~-string literals here\n-      pat_lit(a) => if !is_str(a) { (v.visit_expr)(a, (true, v)); },\n+      pat_lit(a) => if !is_str(a) { v.visit_expr(a, true); },\n       pat_range(a, b) => {\n-        if !is_str(a) { (v.visit_expr)(a, (true, v)); }\n-        if !is_str(b) { (v.visit_expr)(b, (true, v)); }\n+        if !is_str(a) { v.visit_expr(a, true); }\n+        if !is_str(b) { v.visit_expr(b, true); }\n       }\n-      _ => oldvisit::visit_pat(p, (false, v))\n+      _ => visit::walk_pat(v, p, false)\n     }\n }\n \n-pub fn check_expr(sess: Session,\n+pub fn check_expr(v: &mut CheckCrateVisitor,\n+                  sess: Session,\n                   def_map: resolve::DefMap,\n                   method_map: typeck::method_map,\n                   tcx: ty::ctxt,\n                   e: @expr,\n-                  (is_const, v): (bool,\n-                                  oldvisit::vt<bool>)) {\n+                  is_const: bool) {\n     if is_const {\n         match e.node {\n           expr_unary(_, deref, _) => { }\n@@ -152,8 +176,8 @@ pub fn check_expr(sess: Session,\n                 }\n             }\n           }\n-          expr_paren(e) => { check_expr(sess, def_map, method_map,\n-                                         tcx, e, (is_const, v)); }\n+          expr_paren(e) => { check_expr(v, sess, def_map, method_map,\n+                                        tcx, e, is_const); }\n           expr_vstore(_, expr_vstore_slice) |\n           expr_vec(_, m_imm) |\n           expr_addr_of(m_imm, _) |\n@@ -192,7 +216,7 @@ pub fn check_expr(sess: Session,\n       }\n       _ => ()\n     }\n-    oldvisit::visit_expr(e, (is_const, v));\n+    visit::walk_expr(v, e, is_const);\n }\n \n #[deriving(Clone)]\n@@ -204,6 +228,8 @@ struct env {\n     idstack: @mut ~[NodeId]\n }\n \n+struct CheckItemRecursionVisitor;\n+\n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion(sess: Session,\n@@ -218,36 +244,34 @@ pub fn check_item_recursion(sess: Session,\n         idstack: @mut ~[]\n     };\n \n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_item: visit_item,\n-        visit_expr: visit_expr,\n-        .. *oldvisit::default_visitor()\n-    });\n-    (visitor.visit_item)(it, (env, visitor));\n+    let mut visitor = CheckItemRecursionVisitor;\n+    visitor.visit_item(it, env);\n+}\n \n-    fn visit_item(it: @item, (env, v): (env, oldvisit::vt<env>)) {\n+impl Visitor<env> for CheckItemRecursionVisitor {\n+    fn visit_item(&mut self, it: @item, env: env) {\n         if env.idstack.iter().any(|x| x == &(it.id)) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);\n-        oldvisit::visit_item(it, (env, v));\n+        visit::walk_item(self, it, env);\n         env.idstack.pop();\n     }\n \n-    fn visit_expr(e: @expr, (env, v): (env, oldvisit::vt<env>)) {\n+    fn visit_expr(&mut self, e: @expr, env: env) {\n         match e.node {\n             expr_path(*) => match env.def_map.find(&e.id) {\n                 Some(&def_static(def_id, _)) if ast_util::is_local(def_id) =>\n                     match env.ast_map.get_copy(&def_id.node) {\n                         ast_map::node_item(it, _) => {\n-                            (v.visit_item)(it, (env, v));\n+                            self.visit_item(it, env);\n                         }\n                         _ => fail!(\"const not bound to an item\")\n                     },\n                 _ => ()\n             },\n             _ => ()\n         }\n-        oldvisit::visit_expr(e, (env, v));\n+        visit::walk_expr(self, e, env);\n     }\n }"}, {"sha": "35705dff6ef98118bb50b9f9ea0a59e00499dfeb", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=d597f54fc2b864bcdf110fecb120758dc2feb5f6", "patch": "@@ -12,58 +12,64 @@\n use middle::ty;\n \n use syntax::ast::*;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n \n #[deriving(Clone)]\n pub struct Context {\n     in_loop: bool,\n     can_ret: bool\n }\n \n+struct CheckLoopVisitor {\n+    tcx: ty::ctxt,\n+}\n+\n pub fn check_crate(tcx: ty::ctxt, crate: &Crate) {\n-    oldvisit::visit_crate(crate,\n-                          (Context { in_loop: false, can_ret: true },\n-                          oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_item: |i, (_cx, v)| {\n-            oldvisit::visit_item(i, (Context {\n+    visit::walk_crate(&mut CheckLoopVisitor { tcx: tcx },\n+                      crate,\n+                      Context { in_loop: false, can_ret: true });\n+}\n+\n+impl Visitor<Context> for CheckLoopVisitor {\n+    fn visit_item(&mut self, i:@item, _cx:Context) {\n+        visit::walk_item(self, i, Context {\n                                     in_loop: false,\n                                     can_ret: true\n-                                 }, v));\n-        },\n-        visit_expr: |e: @expr, (cx, v): (Context, oldvisit::vt<Context>)| {\n+                                  });\n+    }\n+\n+    fn visit_expr(&mut self, e:@expr, cx:Context) {\n+\n             match e.node {\n               expr_while(e, ref b) => {\n-                (v.visit_expr)(e, (cx, v));\n-                (v.visit_block)(b, (Context { in_loop: true,.. cx }, v));\n+                self.visit_expr(e, cx);\n+                self.visit_block(b, Context { in_loop: true,.. cx });\n               }\n               expr_loop(ref b, _) => {\n-                (v.visit_block)(b, (Context { in_loop: true,.. cx }, v));\n+                self.visit_block(b, Context { in_loop: true,.. cx });\n               }\n               expr_fn_block(_, ref b) => {\n-                (v.visit_block)(b, (Context {\n-                                         in_loop: false,\n-                                         can_ret: false\n-                                      }, v));\n+                self.visit_block(b, Context { in_loop: false, can_ret: false });\n               }\n               expr_break(_) => {\n                 if !cx.in_loop {\n-                    tcx.sess.span_err(e.span, \"`break` outside of loop\");\n+                    self.tcx.sess.span_err(e.span, \"`break` outside of loop\");\n                 }\n               }\n               expr_again(_) => {\n                 if !cx.in_loop {\n-                    tcx.sess.span_err(e.span, \"`loop` outside of loop\");\n+                    self.tcx.sess.span_err(e.span, \"`loop` outside of loop\");\n                 }\n               }\n               expr_ret(oe) => {\n                 if !cx.can_ret {\n-                    tcx.sess.span_err(e.span, \"`return` in block function\");\n+                    self.tcx.sess.span_err(e.span, \"`return` in block function\");\n                 }\n-                oldvisit::visit_expr_opt(oe, (cx, v));\n+                visit::walk_expr_opt(self, oe, cx);\n               }\n-              _ => oldvisit::visit_expr(e, (cx, v))\n+              _ => visit::walk_expr(self, e, cx)\n             }\n-        },\n-        .. *oldvisit::default_visitor()\n-    })));\n+\n+    }\n }"}, {"sha": "3f321fcfcd28f8d5bd4534589894a7df3f5c9672", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d597f54fc2b864bcdf110fecb120758dc2feb5f6", "patch": "@@ -25,35 +25,50 @@ use extra::sort;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n use syntax::codemap::{span, dummy_sp, spanned};\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::{Visitor,fn_kind};\n \n pub struct MatchCheckCtxt {\n     tcx: ty::ctxt,\n     method_map: method_map,\n     moves_map: moves::MovesMap\n }\n \n+struct CheckMatchVisitor {\n+    cx: @MatchCheckCtxt\n+}\n+\n+impl Visitor<()> for CheckMatchVisitor {\n+    fn visit_expr(&mut self, ex:@expr, e:()) {\n+        check_expr(self, self.cx, ex, e);\n+    }\n+    fn visit_local(&mut self, l:@Local, e:()) {\n+        check_local(self, self.cx, l, e);\n+    }\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:()) {\n+        check_fn(self, self.cx, fk, fd, b, s, n, e);\n+    }\n+}\n+\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: method_map,\n                    moves_map: moves::MovesMap,\n                    crate: &Crate) {\n     let cx = @MatchCheckCtxt {tcx: tcx,\n                               method_map: method_map,\n                               moves_map: moves_map};\n-    oldvisit::visit_crate(crate, ((), oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_expr: |a,b| check_expr(cx, a, b),\n-        visit_local: |a,b| check_local(cx, a, b),\n-        visit_fn: |kind, decl, body, sp, id, (e, v)|\n-            check_fn(cx, kind, decl, body, sp, id, (e, v)),\n-        .. *oldvisit::default_visitor::<()>()\n-    })));\n+    let mut v = CheckMatchVisitor { cx: cx };\n+\n+    visit::walk_crate(&mut v, crate, ());\n+\n     tcx.sess.abort_if_errors();\n }\n \n-pub fn check_expr(cx: @MatchCheckCtxt,\n+pub fn check_expr(v: &mut CheckMatchVisitor,\n+                  cx: @MatchCheckCtxt,\n                   ex: @expr,\n-                  (s, v): ((), oldvisit::vt<()>)) {\n-    oldvisit::visit_expr(ex, (s, v));\n+                  s: ()) {\n+    visit::walk_expr(v, ex, s);\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n@@ -787,10 +802,11 @@ pub fn default(cx: &MatchCheckCtxt, r: &[@pat]) -> Option<~[@pat]> {\n     else { None }\n }\n \n-pub fn check_local(cx: &MatchCheckCtxt,\n+pub fn check_local(v: &mut CheckMatchVisitor,\n+                   cx: &MatchCheckCtxt,\n                    loc: @Local,\n-                   (s, v): ((), oldvisit::vt<()>)) {\n-    oldvisit::visit_local(loc, (s, v));\n+                   s: ()) {\n+    visit::walk_local(v, loc, s);\n     if is_refutable(cx, loc.pat) {\n         cx.tcx.sess.span_err(loc.pat.span,\n                              \"refutable pattern in local binding\");\n@@ -800,15 +816,15 @@ pub fn check_local(cx: &MatchCheckCtxt,\n     check_legality_of_move_bindings(cx, false, [ loc.pat ]);\n }\n \n-pub fn check_fn(cx: &MatchCheckCtxt,\n-                kind: &oldvisit::fn_kind,\n+pub fn check_fn(v: &mut CheckMatchVisitor,\n+                cx: &MatchCheckCtxt,\n+                kind: &visit::fn_kind,\n                 decl: &fn_decl,\n                 body: &Block,\n                 sp: span,\n                 id: NodeId,\n-                (s, v): ((),\n-                         oldvisit::vt<()>)) {\n-    oldvisit::visit_fn(kind, decl, body, sp, id, (s, v));\n+                s: ()) {\n+    visit::walk_fn(v, kind, decl, body, sp, id, s);\n     for input in decl.inputs.iter() {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,"}, {"sha": "2e8d0d351d997c8b48e07b042dbe07e9c32cf120", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d597f54fc2b864bcdf110fecb120758dc2feb5f6", "patch": "@@ -14,7 +14,9 @@ use middle::astencode;\n use middle::ty;\n use middle;\n \n-use syntax::{ast, ast_map, ast_util, oldvisit};\n+use syntax::{ast, ast_map, ast_util};\n+use syntax::visit;\n+use syntax::visit::Visitor;\n use syntax::ast::*;\n \n use std::float;\n@@ -267,13 +269,18 @@ pub fn lookup_constness(tcx: ty::ctxt, e: &expr) -> constness {\n     }\n }\n \n+struct ConstEvalVisitor { tcx: ty::ctxt }\n+\n+impl Visitor<()> for ConstEvalVisitor {\n+    fn visit_expr_post(&mut self, e:@expr, _:()) {\n+        classify(e, self.tcx);\n+    }\n+}\n+\n pub fn process_crate(crate: &ast::Crate,\n                      tcx: ty::ctxt) {\n-    let v = oldvisit::mk_simple_visitor(@oldvisit::SimpleVisitor {\n-        visit_expr_post: |e| { classify(e, tcx); },\n-        .. *oldvisit::default_simple_visitor()\n-    });\n-    oldvisit::visit_crate(crate, ((), v));\n+    let mut v = ConstEvalVisitor { tcx: tcx };\n+    visit::walk_crate(&mut v, crate, ());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "de0be2a0bc510e2d513cb3cef1ce76627d1d7e19", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=d597f54fc2b864bcdf110fecb120758dc2feb5f6", "patch": "@@ -20,8 +20,10 @@ use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n use syntax::ast::{expr_unary, unsafe_fn, expr_path};\n use syntax::ast;\n use syntax::codemap::span;\n-use syntax::oldvisit::{fk_item_fn, fk_method};\n-use syntax::oldvisit;\n+use syntax::visit::{fk_item_fn, fk_method};\n+use syntax::visit;\n+use syntax::visit::{Visitor,fn_kind};\n+use syntax::ast::{fn_decl,Block,NodeId,expr};\n \n #[deriving(Eq)]\n enum UnsafeContext {\n@@ -45,120 +47,133 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n-                   method_map: method_map,\n-                   crate: &ast::Crate) {\n-    let context = @mut Context {\n-        method_map: method_map,\n-        unsafe_context: SafeContext,\n-    };\n+struct EffectCheckVisitor {\n+    tcx: ty::ctxt,\n+    context: @mut Context,\n+}\n \n-    let require_unsafe: @fn(span: span,\n-                            description: &str) = |span, description| {\n-        match context.unsafe_context {\n+impl EffectCheckVisitor {\n+    fn require_unsafe(&mut self, span: span, description: &str) {\n+        match self.context.unsafe_context {\n             SafeContext => {\n                 // Report an error.\n-                tcx.sess.span_err(span,\n+                self.tcx.sess.span_err(span,\n                                   fmt!(\"%s requires unsafe function or block\",\n                                        description))\n             }\n             UnsafeBlock(block_id) => {\n                 // OK, but record this.\n                 debug!(\"effect: recording unsafe block as used: %?\", block_id);\n-                let _ = tcx.used_unsafe.insert(block_id);\n+                let _ = self.tcx.used_unsafe.insert(block_id);\n             }\n             UnsafeFn => {}\n         }\n-    };\n+    }\n+}\n+\n+impl Visitor<()> for EffectCheckVisitor {\n+    fn visit_fn(&mut self, fn_kind:&fn_kind, fn_decl:&fn_decl,\n+                block:&Block, span:span, node_id:NodeId, _:()) {\n \n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_fn: |fn_kind, fn_decl, block, span, node_id, (_, visitor)| {\n             let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n                 fk_item_fn(_, _, purity, _) => (true, purity == unsafe_fn),\n                 fk_method(_, _, method) => (true, method.purity == unsafe_fn),\n                 _ => (false, false),\n             };\n \n-            let old_unsafe_context = context.unsafe_context;\n+            let old_unsafe_context = self.context.unsafe_context;\n             if is_unsafe_fn {\n-                context.unsafe_context = UnsafeFn\n+                self.context.unsafe_context = UnsafeFn\n             } else if is_item_fn {\n-                context.unsafe_context = SafeContext\n+                self.context.unsafe_context = SafeContext\n             }\n \n-            oldvisit::visit_fn(fn_kind,\n+            visit::walk_fn(self,\n+                           fn_kind,\n                             fn_decl,\n                             block,\n                             span,\n                             node_id,\n-                            ((),\n-                             visitor));\n+                            ());\n+\n+            self.context.unsafe_context = old_unsafe_context\n+    }\n \n-            context.unsafe_context = old_unsafe_context\n-        },\n+    fn visit_block(&mut self, block:&Block, _:()) {\n \n-        visit_block: |block, (_, visitor)| {\n-            let old_unsafe_context = context.unsafe_context;\n+            let old_unsafe_context = self.context.unsafe_context;\n             if block.rules == ast::UnsafeBlock &&\n-                    context.unsafe_context == SafeContext {\n-                context.unsafe_context = UnsafeBlock(block.id)\n+                    self.context.unsafe_context == SafeContext {\n+                self.context.unsafe_context = UnsafeBlock(block.id)\n             }\n \n-            oldvisit::visit_block(block, ((), visitor));\n+            visit::walk_block(self, block, ());\n \n-            context.unsafe_context = old_unsafe_context\n-        },\n+            self.context.unsafe_context = old_unsafe_context\n+    }\n+\n+    fn visit_expr(&mut self, expr:@expr, _:()) {\n \n-        visit_expr: |expr, (_, visitor)| {\n             match expr.node {\n                 expr_method_call(callee_id, _, _, _, _, _) => {\n-                    let base_type = ty::node_id_to_type(tcx, callee_id);\n+                    let base_type = ty::node_id_to_type(self.tcx, callee_id);\n                     debug!(\"effect: method call case, base type is %s\",\n-                           ppaux::ty_to_str(tcx, base_type));\n+                           ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n-                        require_unsafe(expr.span,\n+                        self.require_unsafe(expr.span,\n                                        \"invocation of unsafe method\")\n                     }\n                 }\n                 expr_call(base, _, _) => {\n-                    let base_type = ty::node_id_to_type(tcx, base.id);\n+                    let base_type = ty::node_id_to_type(self.tcx, base.id);\n                     debug!(\"effect: call case, base type is %s\",\n-                           ppaux::ty_to_str(tcx, base_type));\n+                           ppaux::ty_to_str(self.tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n-                        require_unsafe(expr.span, \"call to unsafe function\")\n+                        self.require_unsafe(expr.span, \"call to unsafe function\")\n                     }\n                 }\n                 expr_unary(_, deref, base) => {\n-                    let base_type = ty::node_id_to_type(tcx, base.id);\n+                    let base_type = ty::node_id_to_type(self.tcx, base.id);\n                     debug!(\"effect: unary case, base type is %s\",\n-                           ppaux::ty_to_str(tcx, base_type));\n+                           ppaux::ty_to_str(self.tcx, base_type));\n                     match ty::get(base_type).sty {\n                         ty_ptr(_) => {\n-                            require_unsafe(expr.span,\n+                            self.require_unsafe(expr.span,\n                                            \"dereference of unsafe pointer\")\n                         }\n                         _ => {}\n                     }\n                 }\n                 expr_inline_asm(*) => {\n-                    require_unsafe(expr.span, \"use of inline assembly\")\n+                    self.require_unsafe(expr.span, \"use of inline assembly\")\n                 }\n                 expr_path(*) => {\n-                    match ty::resolve_expr(tcx, expr) {\n+                    match ty::resolve_expr(self.tcx, expr) {\n                         ast::def_static(_, true) => {\n-                            require_unsafe(expr.span, \"use of mutable static\")\n+                            self.require_unsafe(expr.span, \"use of mutable static\")\n                         }\n                         _ => {}\n                     }\n                 }\n                 _ => {}\n             }\n \n-            oldvisit::visit_expr(expr, ((), visitor))\n-        },\n+            visit::walk_expr(self, expr, ());\n+    }\n+}\n \n-        .. *oldvisit::default_visitor()\n-    });\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: method_map,\n+                   crate: &ast::Crate) {\n+    let context = @mut Context {\n+        method_map: method_map,\n+        unsafe_context: SafeContext,\n+    };\n+\n+    let mut visitor = EffectCheckVisitor {\n+        tcx: tcx,\n+        context: context,\n+    };\n \n-    oldvisit::visit_crate(crate, ((), visitor))\n+    visit::walk_crate(&mut visitor, crate, ());\n }"}, {"sha": "6a566f10f1e60b0a4a669a9d7cdce8324f1fe0b9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 146, "deletions": 133, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=d597f54fc2b864bcdf110fecb120758dc2feb5f6", "patch": "@@ -34,54 +34,57 @@ use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::parse::token;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::ast::{_mod,expr,item,Block,pat};\n \n-pub fn check_crate<'mm>(tcx: ty::ctxt,\n-                   method_map: &'mm method_map,\n-                   crate: &ast::Crate) {\n-    let privileged_items = @mut ~[];\n+struct PrivacyVisitor {\n+    tcx: ty::ctxt,\n+    privileged_items: @mut ~[NodeId],\n+}\n \n+impl PrivacyVisitor {\n     // Adds an item to its scope.\n-    let add_privileged_item: @fn(@ast::item, &mut uint) = |item, count| {\n+    fn add_privileged_item(&mut self, item: @ast::item, count: &mut uint) {\n         match item.node {\n             item_struct(*) | item_trait(*) | item_enum(*) |\n             item_fn(*) => {\n-                privileged_items.push(item.id);\n+                self.privileged_items.push(item.id);\n                 *count += 1;\n             }\n             item_impl(_, _, _, ref methods) => {\n                 for method in methods.iter() {\n-                    privileged_items.push(method.id);\n+                    self.privileged_items.push(method.id);\n                     *count += 1;\n                 }\n-                privileged_items.push(item.id);\n+                self.privileged_items.push(item.id);\n                 *count += 1;\n             }\n             item_foreign_mod(ref foreign_mod) => {\n                 for foreign_item in foreign_mod.items.iter() {\n-                    privileged_items.push(foreign_item.id);\n+                    self.privileged_items.push(foreign_item.id);\n                     *count += 1;\n                 }\n             }\n             _ => {}\n         }\n-    };\n+    }\n \n     // Adds items that are privileged to this scope.\n-    let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n+    fn add_privileged_items(&mut self, items: &[@ast::item]) -> uint {\n         let mut count = 0;\n         for &item in items.iter() {\n-            add_privileged_item(item, &mut count);\n+            self.add_privileged_item(item, &mut count);\n         }\n         count\n-    };\n+    }\n \n     // Checks that an enum variant is in scope\n-    let check_variant: @fn(span: span, enum_id: ast::def_id) =\n-            |span, enum_id| {\n-        let variant_info = ty::enum_variants(tcx, enum_id)[0];\n+    fn check_variant(&mut self, span: span, enum_id: ast::def_id) {\n+        let variant_info = ty::enum_variants(self.tcx, enum_id)[0];\n         let parental_privacy = if is_local(enum_id) {\n-            let parent_vis = ast_map::node_item_query(tcx.items, enum_id.node,\n+            let parent_vis = ast_map::node_item_query(self.tcx.items,\n+                                                      enum_id.node,\n                                    |it| { it.vis },\n                                    ~\"unbound enum parent when checking \\\n                                     dereference of enum type\");\n@@ -99,15 +102,14 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n         if variant_visibility_to_privacy(variant_info.vis,\n                                          parental_privacy == Public)\n                                          == Private {\n-            tcx.sess.span_err(span,\n+            self.tcx.sess.span_err(span,\n                 \"can only dereference enums \\\n                  with a single, public variant\");\n         }\n-    };\n+    }\n \n     // Returns true if a crate-local method is private and false otherwise.\n-    let method_is_private: @fn(span: span, method_id: NodeId) -> bool =\n-            |span, method_id| {\n+    fn method_is_private(&mut self, span: span, method_id: NodeId) -> bool {\n         let check = |vis: visibility, container_id: def_id| {\n             let mut is_private = false;\n             if vis == private {\n@@ -117,12 +119,12 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             } else {\n                 // Look up the enclosing impl.\n                 if container_id.crate != LOCAL_CRATE {\n-                    tcx.sess.span_bug(span,\n+                    self.tcx.sess.span_bug(span,\n                                       \"local method isn't in local \\\n                                        impl?!\");\n                 }\n \n-                match tcx.items.find(&container_id.node) {\n+                match self.tcx.items.find(&container_id.node) {\n                     Some(&node_item(item, _)) => {\n                         match item.node {\n                             item_impl(_, None, _, _)\n@@ -133,18 +135,18 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                     }\n                     Some(_) => {\n-                        tcx.sess.span_bug(span, \"impl wasn't an item?!\");\n+                        self.tcx.sess.span_bug(span, \"impl wasn't an item?!\");\n                     }\n                     None => {\n-                        tcx.sess.span_bug(span, \"impl wasn't in AST map?!\");\n+                        self.tcx.sess.span_bug(span, \"impl wasn't in AST map?!\");\n                     }\n                 }\n             }\n \n             is_private\n         };\n \n-        match tcx.items.find(&method_id) {\n+        match self.tcx.items.find(&method_id) {\n             Some(&node_method(method, impl_id, _)) => {\n                 check(method.vis, impl_id)\n             }\n@@ -155,26 +157,25 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 }\n             }\n             Some(_) => {\n-                tcx.sess.span_bug(span,\n+                self.tcx.sess.span_bug(span,\n                                   fmt!(\"method_is_private: method was a %s?!\",\n                                        ast_map::node_id_to_str(\n-                                            tcx.items,\n+                                            self.tcx.items,\n                                             method_id,\n                                            token::get_ident_interner())));\n             }\n             None => {\n-                tcx.sess.span_bug(span, \"method not found in \\\n+                self.tcx.sess.span_bug(span, \"method not found in \\\n                                          AST map?!\");\n             }\n         }\n-    };\n+    }\n \n     // Returns true if the given local item is private and false otherwise.\n-    let local_item_is_private: @fn(span: span, item_id: NodeId) -> bool =\n-            |span, item_id| {\n+    fn local_item_is_private(&mut self, span: span, item_id: NodeId) -> bool {\n         let mut f: &fn(NodeId) -> bool = |_| false;\n         f = |item_id| {\n-            match tcx.items.find(&item_id) {\n+            match self.tcx.items.find(&item_id) {\n                 Some(&node_item(item, _)) => item.vis != public,\n                 Some(&node_foreign_item(*)) => false,\n                 Some(&node_method(method, impl_did, _)) => {\n@@ -186,104 +187,96 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 }\n                 Some(&node_trait_method(_, trait_did, _)) => f(trait_did.node),\n                 Some(_) => {\n-                    tcx.sess.span_bug(span,\n+                    self.tcx.sess.span_bug(span,\n                                       fmt!(\"local_item_is_private: item was \\\n                                             a %s?!\",\n                                            ast_map::node_id_to_str(\n-                                                tcx.items,\n+                                                self.tcx.items,\n                                                 item_id,\n                                                token::get_ident_interner())));\n                 }\n                 None => {\n-                    tcx.sess.span_bug(span, \"item not found in AST map?!\");\n+                    self.tcx.sess.span_bug(span, \"item not found in AST map?!\");\n                 }\n             }\n         };\n         f(item_id)\n-    };\n+    }\n \n     // Checks that a private field is in scope.\n-    let check_field: @fn(span: span, id: ast::def_id, ident: ast::ident) =\n-            |span, id, ident| {\n-        let fields = ty::lookup_struct_fields(tcx, id);\n+    fn check_field(&mut self, span: span, id: ast::def_id, ident: ast::ident) {\n+        let fields = ty::lookup_struct_fields(self.tcx, id);\n         for field in fields.iter() {\n             if field.ident != ident { loop; }\n             if field.vis == private {\n-                tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n+                self.tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n                                              token::ident_to_str(&ident)));\n             }\n             break;\n         }\n-    };\n+    }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n-    let check_method_common: @fn(span: span,\n-                                 method_id: def_id,\n-                                 name: &ident) =\n-            |span, method_id, name| {\n+    fn check_method_common(&mut self, span: span, method_id: def_id, name: &ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n-        let method_id = ty::method(tcx, method_id).provided_source\n+        let method_id = ty::method(self.tcx, method_id).provided_source\n             .unwrap_or_default(method_id);\n \n         if method_id.crate == LOCAL_CRATE {\n-            let is_private = method_is_private(span, method_id.node);\n-            let container_id = ty::method(tcx, method_id).container_id;\n+            let is_private = self.method_is_private(span, method_id.node);\n+            let container_id = ty::method(self.tcx, method_id).container_id;\n             if is_private &&\n                     (container_id.crate != LOCAL_CRATE ||\n-                     !privileged_items.iter().any(|x| x == &(container_id.node))) {\n-                tcx.sess.span_err(span,\n+                     !self.privileged_items.iter().any(|x| x == &(container_id.node))) {\n+                self.tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n                                        token::ident_to_str(name)));\n             }\n         } else {\n             let visibility =\n-                csearch::get_item_visibility(tcx.sess.cstore, method_id);\n+                csearch::get_item_visibility(self.tcx.sess.cstore, method_id);\n             if visibility != public {\n-                tcx.sess.span_err(span,\n+                self.tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n                                        token::ident_to_str(name)));\n             }\n         }\n-    };\n+    }\n \n     // Checks that a private path is in scope.\n-    let check_path: @fn(span: span, def: def, path: &Path) =\n-            |span, def, path| {\n+    fn check_path(&mut self, span: span, def: def, path: &Path) {\n         debug!(\"checking path\");\n         match def {\n             def_static_method(method_id, _, _) => {\n                 debug!(\"found static method def, checking it\");\n-                check_method_common(span, method_id, path.idents.last())\n+                self.check_method_common(span, method_id, path.idents.last())\n             }\n             def_fn(def_id, _) => {\n                 if def_id.crate == LOCAL_CRATE {\n-                    if local_item_is_private(span, def_id.node) &&\n-                            !privileged_items.iter().any(|x| x == &def_id.node) {\n-                        tcx.sess.span_err(span,\n+                    if self.local_item_is_private(span, def_id.node) &&\n+                            !self.privileged_items.iter().any(|x| x == &def_id.node) {\n+                        self.tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n                                                token::ident_to_str(path.idents.last())));\n                     }\n-                } else if csearch::get_item_visibility(tcx.sess.cstore,\n+                } else if csearch::get_item_visibility(self.tcx.sess.cstore,\n                                                        def_id) != public {\n-                    tcx.sess.span_err(span,\n+                    self.tcx.sess.span_err(span,\n                                       fmt!(\"function `%s` is private\",\n                                            token::ident_to_str(path.idents.last())));\n                 }\n             }\n             _ => {}\n         }\n-    };\n+    }\n \n     // Checks that a private method is in scope.\n-    let check_method: @fn(span: span,\n-                          origin: &method_origin,\n-                          ident: ast::ident) =\n-            |span, origin, ident| {\n+    fn check_method(&mut self, span: span, origin: &method_origin, ident: ast::ident) {\n         match *origin {\n             method_static(method_id) => {\n-                check_method_common(span, method_id, &ident)\n+                self.check_method_common(span, method_id, &ident)\n             }\n             method_param(method_param {\n                 trait_id: trait_id,\n@@ -292,19 +285,20 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             }) |\n             method_trait(trait_id, method_num) => {\n                 if trait_id.crate == LOCAL_CRATE {\n-                    match tcx.items.find(&trait_id.node) {\n+                    match self.tcx.items.find(&trait_id.node) {\n                         Some(&node_item(item, _)) => {\n                             match item.node {\n                                 item_trait(_, _, ref methods) => {\n                                     if method_num >= (*methods).len() {\n-                                        tcx.sess.span_bug(span, \"method number out of range?!\");\n+                                        self.tcx.sess.span_bug(span,\n+                                                               \"method number out of range?!\");\n                                     }\n                                     match (*methods)[method_num] {\n                                         provided(method)\n                                              if method.vis == private &&\n-                                             !privileged_items.iter()\n+                                             !self.privileged_items.iter()\n                                              .any(|x| x == &(trait_id.node)) => {\n-                                            tcx.sess.span_err(span,\n+                                            self.tcx.sess.span_err(span,\n                                                               fmt!(\"method `%s` is private\",\n                                                                    token::ident_to_str(&method\n                                                                                         .ident)));\n@@ -316,54 +310,60 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     }\n                                 }\n                                 _ => {\n-                                    tcx.sess.span_bug(span, \"trait wasn't actually a trait?!\");\n+                                    self.tcx.sess.span_bug(span, \"trait wasn't actually a trait?!\");\n                                 }\n                             }\n                         }\n                         Some(_) => {\n-                            tcx.sess.span_bug(span, \"trait wasn't an item?!\");\n+                            self.tcx.sess.span_bug(span, \"trait wasn't an item?!\");\n                         }\n                         None => {\n-                            tcx.sess.span_bug(span, \"trait item wasn't found in the AST map?!\");\n+                            self.tcx.sess.span_bug(span,\n+                                                   \"trait item wasn't found in the AST map?!\");\n                         }\n                     }\n                 } else {\n                     // FIXME #4732: External crates.\n                 }\n             }\n         }\n-    };\n+    }\n+}\n+\n+impl<'self> Visitor<&'self method_map> for PrivacyVisitor {\n \n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_mod: |the_module, span, node_id, (method_map, visitor)| {\n-            let n_added = add_privileged_items(the_module.items);\n+    fn visit_mod<'mm>(&mut self, the_module:&_mod, _:span, _:NodeId,\n+                      method_map:&'mm method_map) {\n \n-            oldvisit::visit_mod(the_module,\n-                                span,\n-                                node_id,\n-                                (method_map, visitor));\n+            let n_added = self.add_privileged_items(the_module.items);\n+\n+            visit::walk_mod(self, the_module, method_map);\n \n             do n_added.times {\n-                ignore(privileged_items.pop());\n+                ignore(self.privileged_items.pop());\n             }\n-        },\n-        visit_item: |item, (method_map, visitor)| {\n+    }\n+\n+    fn visit_item<'mm>(&mut self, item:@item, method_map:&'mm method_map) {\n+\n             // Do not check privacy inside items with the resolve_unexported\n             // attribute. This is used for the test runner.\n             if !attr::contains_name(item.attrs, \"!resolve_unexported\") {\n-                check_sane_privacy(tcx, item);\n-                oldvisit::visit_item(item, (method_map, visitor));\n+                check_sane_privacy(self.tcx, item);\n+                visit::walk_item(self, item, method_map);\n             }\n-        },\n-        visit_block: |block, (method_map, visitor)| {\n+    }\n+\n+    fn visit_block<'mm>(&mut self, block:&Block, method_map:&'mm method_map) {\n+\n             // Gather up all the privileged items.\n             let mut n_added = 0;\n             for stmt in block.stmts.iter() {\n                 match stmt.node {\n                     stmt_decl(decl, _) => {\n                         match decl.node {\n                             decl_item(item) => {\n-                                add_privileged_item(item, &mut n_added);\n+                                self.add_privileged_item(item, &mut n_added);\n                             }\n                             _ => {}\n                         }\n@@ -372,15 +372,16 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 }\n             }\n \n-            oldvisit::visit_block(block, (method_map, visitor));\n+            visit::walk_block(self, block, method_map);\n \n             do n_added.times {\n-                ignore(privileged_items.pop());\n+                ignore(self.privileged_items.pop());\n             }\n-        },\n-        visit_expr: |expr,\n-                     (method_map, visitor):\n-                        (&'mm method_map, oldvisit::vt<&'mm method_map>)| {\n+\n+    }\n+\n+    fn visit_expr<'mm>(&mut self, expr:@expr, method_map:&'mm method_map) {\n+\n             match expr.node {\n                 expr_field(base, ident, _) => {\n                     // Method calls are now a special syntactic form,\n@@ -389,71 +390,71 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n \n                     // With type_autoderef, make sure we don't\n                     // allow pointers to violate privacy\n-                    match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n+                    match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n                                                           base))).sty {\n                         ty_struct(id, _)\n-                        if id.crate != LOCAL_CRATE || !privileged_items.iter()\n+                        if id.crate != LOCAL_CRATE || !self.privileged_items.iter()\n                                 .any(|x| x == &(id.node)) => {\n                             debug!(\"(privacy checking) checking field access\");\n-                            check_field(expr.span, id, ident);\n+                            self.check_field(expr.span, id, ident);\n                         }\n                         _ => {}\n                     }\n                 }\n                 expr_method_call(_, base, ident, _, _, _) => {\n                     // Ditto\n-                    match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n+                    match ty::get(ty::type_autoderef(self.tcx, ty::expr_ty(self.tcx,\n                                                           base))).sty {\n                         ty_enum(id, _) |\n                         ty_struct(id, _)\n                         if id.crate != LOCAL_CRATE ||\n-                           !privileged_items.iter().any(|x| x == &(id.node)) => {\n+                           !self.privileged_items.iter().any(|x| x == &(id.node)) => {\n                             match method_map.find(&expr.id) {\n                                 None => {\n-                                    tcx.sess.span_bug(expr.span,\n+                                    self.tcx.sess.span_bug(expr.span,\n                                                       \"method call not in \\\n                                                        method map\");\n                                 }\n                                 Some(ref entry) => {\n                                     debug!(\"(privacy checking) checking \\\n                                             impl method\");\n-                                    check_method(expr.span, &entry.origin, ident);\n+                                    self.check_method(expr.span, &entry.origin, ident);\n                                 }\n                             }\n                         }\n                         _ => {}\n                     }\n                 }\n                 expr_path(ref path) => {\n-                    check_path(expr.span, tcx.def_map.get_copy(&expr.id), path);\n+                    self.check_path(expr.span, self.tcx.def_map.get_copy(&expr.id), path);\n                 }\n                 expr_struct(_, ref fields, _) => {\n-                    match ty::get(ty::expr_ty(tcx, expr)).sty {\n+                    match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n-                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n+                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for field in (*fields).iter() {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n-                                    check_field(expr.span, id, field.ident);\n+                                    self.check_field(expr.span, id, field.ident);\n                                 }\n                             }\n                         }\n                         ty_enum(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n-                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n-                                match tcx.def_map.get_copy(&expr.id) {\n+                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n+                                match self.tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for field in (*fields).iter() {\n                                                 debug!(\"(privacy checking) \\\n                                                         checking field in \\\n                                                         struct variant \\\n                                                         literal\");\n-                                            check_field(expr.span, variant_id, field.ident);\n+                                            self.check_field(expr.span, variant_id, field.ident);\n                                         }\n                                     }\n                                     _ => {\n-                                        tcx.sess.span_bug(expr.span,\n+                                        self.tcx.sess.span_bug(expr.span,\n                                                           \"resolve didn't \\\n                                                            map enum struct \\\n                                                            constructor to a \\\n@@ -463,7 +464,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                             }\n                         }\n                         _ => {\n-                            tcx.sess.span_bug(expr.span, \"struct expr \\\n+                            self.tcx.sess.span_bug(expr.span, \"struct expr \\\n                                                           didn't have \\\n                                                           struct type?!\");\n                         }\n@@ -474,11 +475,11 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     // enum type t, then t's first variant is public or\n                     // privileged. (We can assume it has only one variant\n                     // since typeck already happened.)\n-                    match ty::get(ty::expr_ty(tcx, operand)).sty {\n+                    match ty::get(ty::expr_ty(self.tcx, operand)).sty {\n                         ty_enum(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n-                                !privileged_items.iter().any(|x| x == &(id.node)) {\n-                                check_variant(expr.span, id);\n+                                !self.privileged_items.iter().any(|x| x == &(id.node)) {\n+                                self.check_variant(expr.span, id);\n                             }\n                         }\n                         _ => { /* No check needed */ }\n@@ -487,36 +488,39 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 _ => {}\n             }\n \n-            oldvisit::visit_expr(expr, (method_map, visitor));\n-        },\n-        visit_pat: |pattern, (method_map, visitor)| {\n+            visit::walk_expr(self, expr, method_map);\n+\n+    }\n+\n+    fn visit_pat<'mm>(&mut self, pattern:@pat, method_map:&'mm method_map) {\n+\n             match pattern.node {\n                 pat_struct(_, ref fields, _) => {\n-                    match ty::get(ty::pat_ty(tcx, pattern)).sty {\n+                    match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != LOCAL_CRATE ||\n-                                    !privileged_items.iter().any(|x| x == &(id.node)) {\n+                                    !self.privileged_items.iter().any(|x| x == &(id.node)) {\n                                 for field in fields.iter() {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n-                                    check_field(pattern.span, id, field.ident);\n+                                    self.check_field(pattern.span, id, field.ident);\n                                 }\n                             }\n                         }\n                         ty_enum(enum_id, _) => {\n                             if enum_id.crate != LOCAL_CRATE ||\n-                                    !privileged_items.iter().any(|x| x == &enum_id.node) {\n-                                match tcx.def_map.find(&pattern.id) {\n+                                    !self.privileged_items.iter().any(|x| x == &enum_id.node) {\n+                                match self.tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n                                         for field in fields.iter() {\n                                             debug!(\"(privacy checking) \\\n                                                     checking field in \\\n                                                     struct variant pattern\");\n-                                            check_field(pattern.span, variant_id, field.ident);\n+                                            self.check_field(pattern.span, variant_id, field.ident);\n                                         }\n                                     }\n                                     _ => {\n-                                        tcx.sess.span_bug(pattern.span,\n+                                        self.tcx.sess.span_bug(pattern.span,\n                                                           \"resolve didn't \\\n                                                            map enum struct \\\n                                                            pattern to a \\\n@@ -526,7 +530,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                             }\n                         }\n                         _ => {\n-                            tcx.sess.span_bug(pattern.span,\n+                            self.tcx.sess.span_bug(pattern.span,\n                                               \"struct pattern didn't have \\\n                                                struct type?!\");\n                         }\n@@ -535,11 +539,20 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                 _ => {}\n             }\n \n-            oldvisit::visit_pat(pattern, (method_map, visitor));\n-        },\n-        .. *oldvisit::default_visitor()\n-    });\n-    oldvisit::visit_crate(crate, (method_map, visitor));\n+            visit::walk_pat(self, pattern, method_map);\n+    }\n+}\n+\n+pub fn check_crate<'mm>(tcx: ty::ctxt,\n+                        method_map: &'mm method_map,\n+                        crate: &ast::Crate) {\n+    let privileged_items = @mut ~[];\n+\n+    let mut visitor = PrivacyVisitor {\n+        tcx: tcx,\n+        privileged_items: privileged_items,\n+    };\n+    visit::walk_crate(&mut visitor, crate, method_map);\n }\n \n /// Validates all of the visibility qualifers placed on the item given. This"}, {"sha": "b6a4ac49391a3b6902ded6efaf41724c08e84c5c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 118, "deletions": 89, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=d597f54fc2b864bcdf110fecb120758dc2feb5f6", "patch": "@@ -24,8 +24,8 @@ use syntax::ast_map;\n use syntax::ast_util::def_id_of_def;\n use syntax::attr;\n use syntax::parse::token;\n-use syntax::oldvisit::Visitor;\n-use syntax::oldvisit;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n \n // Returns true if the given set of attributes contains the `#[inline]`\n // attribute.\n@@ -94,48 +94,37 @@ struct ReachableContext {\n     worklist: @mut ~[NodeId],\n }\n \n-impl ReachableContext {\n-    // Creates a new reachability computation context.\n-    fn new(tcx: ty::ctxt, method_map: typeck::method_map)\n-           -> ReachableContext {\n-        ReachableContext {\n-            tcx: tcx,\n-            method_map: method_map,\n-            reachable_symbols: @mut HashSet::new(),\n-            worklist: @mut ~[],\n-        }\n-    }\n+struct ReachableVisitor {\n+    reachable_symbols: @mut HashSet<NodeId>,\n+    worklist: @mut ~[NodeId],\n+}\n+\n+impl Visitor<PrivacyContext> for ReachableVisitor {\n+\n+    fn visit_item(&mut self, item:@item, privacy_context:PrivacyContext) {\n \n-    // Step 1: Mark all public symbols, and add all public symbols that might\n-    // be inlined to a worklist.\n-    fn mark_public_symbols(&self, crate: @Crate) {\n-        let reachable_symbols = self.reachable_symbols;\n-        let worklist = self.worklist;\n-        let visitor = oldvisit::mk_vt(@Visitor {\n-            visit_item: |item, (privacy_context, visitor):\n-                    (PrivacyContext, oldvisit::vt<PrivacyContext>)| {\n                 match item.node {\n                     item_fn(*) => {\n                         if privacy_context == PublicContext {\n-                            reachable_symbols.insert(item.id);\n+                            self.reachable_symbols.insert(item.id);\n                         }\n                         if item_might_be_inlined(item) {\n-                            worklist.push(item.id)\n+                            self.worklist.push(item.id)\n                         }\n                     }\n                     item_struct(ref struct_def, _) => {\n                         match struct_def.ctor_id {\n                             Some(ctor_id) if\n                                     privacy_context == PublicContext => {\n-                                reachable_symbols.insert(ctor_id);\n+                                self.reachable_symbols.insert(ctor_id);\n                             }\n                             Some(_) | None => {}\n                         }\n                     }\n                     item_enum(ref enum_def, _) => {\n                         if privacy_context == PublicContext {\n                             for variant in enum_def.variants.iter() {\n-                                reachable_symbols.insert(variant.node.id);\n+                                self.reachable_symbols.insert(variant.node.id);\n                             }\n                         }\n                     }\n@@ -155,7 +144,7 @@ impl ReachableContext {\n                         // Mark all public methods as reachable.\n                         for &method in methods.iter() {\n                             if should_be_considered_public(method) {\n-                                reachable_symbols.insert(method.id);\n+                                self.reachable_symbols.insert(method.id);\n                             }\n                         }\n \n@@ -164,7 +153,7 @@ impl ReachableContext {\n                             // symbols to the worklist.\n                             for &method in methods.iter() {\n                                 if should_be_considered_public(method) {\n-                                    worklist.push(method.id)\n+                                    self.worklist.push(method.id)\n                                 }\n                             }\n                         } else {\n@@ -176,7 +165,7 @@ impl ReachableContext {\n                                 if generics_require_inlining(generics) ||\n                                         attributes_specify_inlining(*attrs) ||\n                                         should_be_considered_public(*method) {\n-                                    worklist.push(method.id)\n+                                    self.worklist.push(method.id)\n                                 }\n                             }\n                         }\n@@ -187,8 +176,8 @@ impl ReachableContext {\n                             for trait_method in trait_methods.iter() {\n                                 match *trait_method {\n                                     provided(method) => {\n-                                        reachable_symbols.insert(method.id);\n-                                        worklist.push(method.id)\n+                                        self.reachable_symbols.insert(method.id);\n+                                        self.worklist.push(method.id)\n                                     }\n                                     required(_) => {}\n                                 }\n@@ -199,15 +188,97 @@ impl ReachableContext {\n                 }\n \n                 if item.vis == public && privacy_context == PublicContext {\n-                    oldvisit::visit_item(item, (PublicContext, visitor))\n+                    visit::walk_item(self, item, PublicContext)\n                 } else {\n-                    oldvisit::visit_item(item, (PrivateContext, visitor))\n+                    visit::walk_item(self, item, PrivateContext)\n                 }\n-            },\n-            .. *oldvisit::default_visitor()\n-        });\n+    }\n+\n+}\n+\n+struct MarkSymbolVisitor {\n+    worklist: @mut ~[NodeId],\n+    method_map: typeck::method_map,\n+    tcx: ty::ctxt,\n+    reachable_symbols: @mut HashSet<NodeId>,\n+}\n+\n+impl Visitor<()> for MarkSymbolVisitor {\n \n-        oldvisit::visit_crate(crate, (PublicContext, visitor))\n+    fn visit_expr(&mut self, expr:@expr, _:()) {\n+\n+                match expr.node {\n+                    expr_path(_) => {\n+                        let def = match self.tcx.def_map.find(&expr.id) {\n+                            Some(&def) => def,\n+                            None => {\n+                                self.tcx.sess.span_bug(expr.span,\n+                                                  \"def ID not in def map?!\")\n+                            }\n+                        };\n+\n+                        let def_id = def_id_of_def(def);\n+                        if ReachableContext::\n+                                def_id_represents_local_inlined_item(self.tcx,\n+                                                                     def_id) {\n+                            self.worklist.push(def_id.node)\n+                        }\n+                        self.reachable_symbols.insert(def_id.node);\n+                    }\n+                    expr_method_call(*) => {\n+                        match self.method_map.find(&expr.id) {\n+                            Some(&typeck::method_map_entry {\n+                                origin: typeck::method_static(def_id),\n+                                _\n+                            }) => {\n+                                if ReachableContext::\n+                                    def_id_represents_local_inlined_item(\n+                                        self.tcx,\n+                                        def_id) {\n+                                    self.worklist.push(def_id.node)\n+                                }\n+                                self.reachable_symbols.insert(def_id.node);\n+                            }\n+                            Some(_) => {}\n+                            None => {\n+                                self.tcx.sess.span_bug(expr.span,\n+                                                  \"method call expression \\\n+                                                   not in method map?!\")\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                visit::walk_expr(self, expr, ())\n+    }\n+}\n+\n+impl ReachableContext {\n+    // Creates a new reachability computation context.\n+    fn new(tcx: ty::ctxt, method_map: typeck::method_map)\n+           -> ReachableContext {\n+        ReachableContext {\n+            tcx: tcx,\n+            method_map: method_map,\n+            reachable_symbols: @mut HashSet::new(),\n+            worklist: @mut ~[],\n+        }\n+    }\n+\n+    // Step 1: Mark all public symbols, and add all public symbols that might\n+    // be inlined to a worklist.\n+    fn mark_public_symbols(&self, crate: @Crate) {\n+        let reachable_symbols = self.reachable_symbols;\n+        let worklist = self.worklist;\n+\n+        let mut visitor = ReachableVisitor {\n+            reachable_symbols: reachable_symbols,\n+            worklist: worklist,\n+        };\n+\n+\n+        visit::walk_crate(&mut visitor, crate, PublicContext);\n     }\n \n     // Returns true if the given def ID represents a local item that is\n@@ -269,63 +340,21 @@ impl ReachableContext {\n     }\n \n     // Helper function to set up a visitor for `propagate()` below.\n-    fn init_visitor(&self) -> oldvisit::vt<()> {\n+    fn init_visitor(&self) -> MarkSymbolVisitor {\n         let (worklist, method_map) = (self.worklist, self.method_map);\n         let (tcx, reachable_symbols) = (self.tcx, self.reachable_symbols);\n-        oldvisit::mk_vt(@oldvisit::Visitor {\n-            visit_expr: |expr, (_, visitor)| {\n-                match expr.node {\n-                    expr_path(_) => {\n-                        let def = match tcx.def_map.find(&expr.id) {\n-                            Some(&def) => def,\n-                            None => {\n-                                tcx.sess.span_bug(expr.span,\n-                                                  \"def ID not in def map?!\")\n-                            }\n-                        };\n-\n-                        let def_id = def_id_of_def(def);\n-                        if ReachableContext::\n-                                def_id_represents_local_inlined_item(tcx,\n-                                                                     def_id) {\n-                            worklist.push(def_id.node)\n-                        }\n-                        reachable_symbols.insert(def_id.node);\n-                    }\n-                    expr_method_call(*) => {\n-                        match method_map.find(&expr.id) {\n-                            Some(&typeck::method_map_entry {\n-                                origin: typeck::method_static(def_id),\n-                                _\n-                            }) => {\n-                                if ReachableContext::\n-                                    def_id_represents_local_inlined_item(\n-                                        tcx,\n-                                        def_id) {\n-                                    worklist.push(def_id.node)\n-                                }\n-                                reachable_symbols.insert(def_id.node);\n-                            }\n-                            Some(_) => {}\n-                            None => {\n-                                tcx.sess.span_bug(expr.span,\n-                                                  \"method call expression \\\n-                                                   not in method map?!\")\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n \n-                oldvisit::visit_expr(expr, ((), visitor))\n-            },\n-            ..*oldvisit::default_visitor()\n-        })\n+        MarkSymbolVisitor {\n+            worklist: worklist,\n+            method_map: method_map,\n+            tcx: tcx,\n+            reachable_symbols: reachable_symbols,\n+        }\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&self) {\n-        let visitor = self.init_visitor();\n+        let mut visitor = self.init_visitor();\n         let mut scanned = HashSet::new();\n         while self.worklist.len() > 0 {\n             let search_item = self.worklist.pop();\n@@ -342,7 +371,7 @@ impl ReachableContext {\n                 Some(&ast_map::node_item(item, _)) => {\n                     match item.node {\n                         item_fn(_, _, _, _, ref search_block) => {\n-                            oldvisit::visit_block(search_block, ((), visitor))\n+                            visit::walk_block(&mut visitor, search_block, ())\n                         }\n                         _ => {\n                             self.tcx.sess.span_bug(item.span,\n@@ -359,12 +388,12 @@ impl ReachableContext {\n                                                     worklist?!\")\n                         }\n                         provided(ref method) => {\n-                            oldvisit::visit_block(&method.body, ((), visitor))\n+                            visit::walk_block(&mut visitor, &method.body, ())\n                         }\n                     }\n                 }\n                 Some(&ast_map::node_method(ref method, _, _)) => {\n-                    oldvisit::visit_block(&method.body, ((), visitor))\n+                    visit::walk_block(&mut visitor, &method.body, ())\n                 }\n                 Some(_) => {\n                     let ident_interner = token::get_ident_interner();"}, {"sha": "ddd22a0add4c66ac300fc935389e30f327740991", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 135, "deletions": 89, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d597f54fc2b864bcdf110fecb120758dc2feb5f6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d597f54fc2b864bcdf110fecb120758dc2feb5f6", "patch": "@@ -34,7 +34,10 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n-use syntax::{ast, oldvisit};\n+use syntax::{ast, visit};\n+use syntax::visit::{Visitor,fn_kind};\n+use syntax::ast::{Block,item,fn_decl,NodeId,arm,pat,stmt,expr,Local};\n+use syntax::ast::{Ty,TypeMethod,struct_field};\n \n /**\n The region maps encode information about region relationships.\n@@ -323,48 +326,53 @@ fn parent_to_expr(cx: Context, child_id: ast::NodeId, sp: span) {\n     }\n }\n \n-fn resolve_block(blk: &ast::Block,\n-                 (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_block(visitor: &mut RegionResolutionVisitor,\n+                 blk: &ast::Block,\n+                 cx: Context) {\n     // Record the parent of this block.\n     parent_to_expr(cx, blk.id, blk.span);\n \n     // Descend.\n     let new_cx = Context {var_parent: Some(blk.id),\n                           parent: Some(blk.id),\n                           ..cx};\n-    oldvisit::visit_block(blk, (new_cx, visitor));\n+    visit::walk_block(visitor, blk, new_cx);\n }\n \n-fn resolve_arm(arm: &ast::arm,\n-               (cx, visitor): (Context, oldvisit::vt<Context>)) {\n-    oldvisit::visit_arm(arm, (cx, visitor));\n+fn resolve_arm(visitor: &mut RegionResolutionVisitor,\n+               arm: &ast::arm,\n+               cx: Context) {\n+    visit::walk_arm(visitor, arm, cx);\n }\n \n-fn resolve_pat(pat: @ast::pat,\n-               (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_pat(visitor: &mut RegionResolutionVisitor,\n+               pat: @ast::pat,\n+               cx: Context) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, pat.id, pat.span);\n-    oldvisit::visit_pat(pat, (cx, visitor));\n+    visit::walk_pat(visitor, pat, cx);\n }\n \n-fn resolve_stmt(stmt: @ast::stmt,\n-                (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n+                stmt: @ast::stmt,\n+                cx: Context) {\n     match stmt.node {\n         ast::stmt_decl(*) => {\n-            oldvisit::visit_stmt(stmt, (cx, visitor));\n+            visit::walk_stmt(visitor, stmt, cx);\n         }\n         ast::stmt_expr(_, stmt_id) |\n         ast::stmt_semi(_, stmt_id) => {\n             parent_to_expr(cx, stmt_id, stmt.span);\n             let expr_cx = Context {parent: Some(stmt_id), ..cx};\n-            oldvisit::visit_stmt(stmt, (expr_cx, visitor));\n+            visit::walk_stmt(visitor, stmt, expr_cx);\n         }\n         ast::stmt_mac(*) => cx.sess.bug(\"unexpanded macro\")\n     }\n }\n \n-fn resolve_expr(expr: @ast::expr,\n-                (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n+                expr: @ast::expr,\n+                cx: Context) {\n     parent_to_expr(cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n@@ -400,30 +408,32 @@ fn resolve_expr(expr: @ast::expr,\n     };\n \n \n-    oldvisit::visit_expr(expr, (new_cx, visitor));\n+    visit::walk_expr(visitor, expr, new_cx);\n }\n \n-fn resolve_local(local: @ast::Local,\n-                 (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_local(visitor: &mut RegionResolutionVisitor,\n+                 local: @ast::Local,\n+                 cx: Context) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, local.id, local.span);\n-    oldvisit::visit_local(local, (cx, visitor));\n+    visit::walk_local(visitor, local, cx);\n }\n \n-fn resolve_item(item: @ast::item,\n-                (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_item(visitor: &mut RegionResolutionVisitor,\n+                item: @ast::item,\n+                cx: Context) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx = Context {var_parent: None, parent: None, ..cx};\n-    oldvisit::visit_item(item, (new_cx, visitor));\n+    visit::walk_item(visitor, item, new_cx);\n }\n \n-fn resolve_fn(fk: &oldvisit::fn_kind,\n+fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n+              fk: &visit::fn_kind,\n               decl: &ast::fn_decl,\n               body: &ast::Block,\n               sp: span,\n               id: ast::NodeId,\n-              (cx, visitor): (Context,\n-                              oldvisit::vt<Context>)) {\n+              cx: Context) {\n     debug!(\"region::resolve_fn(id=%?, \\\n                                span=%?, \\\n                                body.id=%?, \\\n@@ -438,26 +448,58 @@ fn resolve_fn(fk: &oldvisit::fn_kind,\n                            var_parent: Some(body.id),\n                            ..cx};\n     match *fk {\n-        oldvisit::fk_method(_, _, method) => {\n+        visit::fk_method(_, _, method) => {\n             cx.region_maps.record_parent(method.self_id, body.id);\n         }\n         _ => {}\n     }\n-    oldvisit::visit_fn_decl(decl, (decl_cx, visitor));\n+    visit::walk_fn_decl(visitor, decl, decl_cx);\n \n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n     let body_cx = match *fk {\n-        oldvisit::fk_item_fn(*) |\n-        oldvisit::fk_method(*) => {\n+        visit::fk_item_fn(*) |\n+        visit::fk_method(*) => {\n             Context {parent: None, var_parent: None, ..cx}\n         }\n-        oldvisit::fk_anon(*) |\n-        oldvisit::fk_fn_block(*) => {\n+        visit::fk_anon(*) |\n+        visit::fk_fn_block(*) => {\n             cx\n         }\n     };\n-    (visitor.visit_block)(body, (body_cx, visitor));\n+    visitor.visit_block(body, body_cx);\n+}\n+\n+struct RegionResolutionVisitor;\n+\n+impl Visitor<Context> for RegionResolutionVisitor {\n+\n+    fn visit_block(&mut self, b:&Block, cx:Context) {\n+        resolve_block(self, b, cx);\n+    }\n+\n+    fn visit_item(&mut self, i:@item, cx:Context) {\n+        resolve_item(self, i, cx);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, cx:Context) {\n+        resolve_fn(self, fk, fd, b, s, n, cx);\n+    }\n+    fn visit_arm(&mut self, a:&arm, cx:Context) {\n+        resolve_arm(self, a, cx);\n+    }\n+    fn visit_pat(&mut self, p:@pat, cx:Context) {\n+        resolve_pat(self, p, cx);\n+    }\n+    fn visit_stmt(&mut self, s:@stmt, cx:Context) {\n+        resolve_stmt(self, s, cx);\n+    }\n+    fn visit_expr(&mut self, ex:@expr, cx:Context) {\n+        resolve_expr(self, ex, cx);\n+    }\n+    fn visit_local(&mut self, l:@Local, cx:Context) {\n+        resolve_local(self, l, cx);\n+    }\n }\n \n pub fn resolve_crate(sess: Session,\n@@ -474,18 +516,8 @@ pub fn resolve_crate(sess: Session,\n                       region_maps: region_maps,\n                       parent: None,\n                       var_parent: None};\n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_block: resolve_block,\n-        visit_item: resolve_item,\n-        visit_fn: resolve_fn,\n-        visit_arm: resolve_arm,\n-        visit_pat: resolve_pat,\n-        visit_stmt: resolve_stmt,\n-        visit_expr: resolve_expr,\n-        visit_local: resolve_local,\n-        .. *oldvisit::default_visitor()\n-    });\n-    oldvisit::visit_crate(crate, (cx, visitor));\n+    let mut visitor = RegionResolutionVisitor;\n+    visit::walk_crate(&mut visitor, crate, cx);\n     return region_maps;\n }\n \n@@ -700,46 +732,45 @@ impl DetermineRpCtxt {\n     }\n }\n \n-fn determine_rp_in_item(item: @ast::item,\n-                        (cx, visitor): (@mut DetermineRpCtxt,\n-                                        oldvisit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_item(visitor: &mut DetermineRpVisitor,\n+                        item: @ast::item,\n+                        cx: @mut DetermineRpCtxt) {\n     do cx.with(item.id, true) {\n-        oldvisit::visit_item(item, (cx, visitor));\n+        visit::walk_item(visitor, item, cx);\n     }\n }\n \n-fn determine_rp_in_fn(fk: &oldvisit::fn_kind,\n+fn determine_rp_in_fn(visitor: &mut DetermineRpVisitor,\n+                      fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n                       _: span,\n                       _: ast::NodeId,\n-                      (cx, visitor): (@mut DetermineRpCtxt,\n-                                      oldvisit::vt<@mut DetermineRpCtxt>)) {\n+                      cx: @mut DetermineRpCtxt) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for a in decl.inputs.iter() {\n-                (visitor.visit_ty)(&a.ty, (cx, visitor));\n+                visitor.visit_ty(&a.ty, cx);\n             }\n         }\n-        (visitor.visit_ty)(&decl.output, (cx, visitor));\n-        let generics = oldvisit::generics_of_fn(fk);\n-        (visitor.visit_generics)(&generics, (cx, visitor));\n-        (visitor.visit_block)(body, (cx, visitor));\n+        visitor.visit_ty(&decl.output, cx);\n+        let generics = visit::generics_of_fn(fk);\n+        visitor.visit_generics(&generics, cx);\n+        visitor.visit_block(body, cx);\n     }\n }\n \n-fn determine_rp_in_ty_method(ty_m: &ast::TypeMethod,\n-                             (cx, visitor):\n-                             (@mut DetermineRpCtxt,\n-                              oldvisit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_ty_method(visitor: &mut DetermineRpVisitor,\n+                             ty_m: &ast::TypeMethod,\n+                             cx: @mut DetermineRpCtxt) {\n     do cx.with(cx.item_id, false) {\n-        oldvisit::visit_ty_method(ty_m, (cx, visitor));\n+        visit::walk_ty_method(visitor, ty_m, cx);\n     }\n }\n \n-fn determine_rp_in_ty(ty: &ast::Ty,\n-                      (cx, visitor): (@mut DetermineRpCtxt,\n-                                      oldvisit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n+                      ty: &ast::Ty,\n+                      cx: @mut DetermineRpCtxt) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n@@ -823,14 +854,14 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n     match ty.node {\n       ast::ty_box(ref mt) | ast::ty_uniq(ref mt) | ast::ty_vec(ref mt) |\n       ast::ty_rptr(_, ref mt) | ast::ty_ptr(ref mt) => {\n-        visit_mt(mt, (cx, visitor));\n+        visit_mt(visitor, mt, cx);\n       }\n \n       ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for tp in path.types.iter() {\n-                (visitor.visit_ty)(tp, (cx, visitor));\n+                visitor.visit_ty(tp, cx);\n             }\n         }\n       }\n@@ -843,37 +874,59 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for a in decl.inputs.iter() {\n-                    (visitor.visit_ty)(&a.ty, (cx, visitor));\n+                    visitor.visit_ty(&a.ty, cx);\n                 }\n             }\n-            (visitor.visit_ty)(&decl.output, (cx, visitor));\n+            visitor.visit_ty(&decl.output, cx);\n         }\n       }\n \n       _ => {\n-        oldvisit::visit_ty(ty, (cx, visitor));\n+        visit::walk_ty(visitor, ty, cx);\n       }\n     }\n \n-    fn visit_mt(mt: &ast::mt,\n-                (cx, visitor): (@mut DetermineRpCtxt,\n-                                oldvisit::vt<@mut DetermineRpCtxt>)) {\n+    fn visit_mt(visitor: &mut DetermineRpVisitor,\n+                mt: &ast::mt,\n+                cx: @mut DetermineRpCtxt) {\n         // mutability is invariant\n         if mt.mutbl == ast::m_mutbl {\n             do cx.with_ambient_variance(rv_invariant) {\n-                (visitor.visit_ty)(mt.ty, (cx, visitor));\n+                visitor.visit_ty(mt.ty, cx);\n             }\n         } else {\n-            (visitor.visit_ty)(mt.ty, (cx, visitor));\n+            visitor.visit_ty(mt.ty, cx);\n         }\n     }\n }\n \n-fn determine_rp_in_struct_field(\n-        cm: @ast::struct_field,\n-        (cx, visitor): (@mut DetermineRpCtxt,\n-                        oldvisit::vt<@mut DetermineRpCtxt>)) {\n-    oldvisit::visit_struct_field(cm, (cx, visitor));\n+fn determine_rp_in_struct_field(visitor: &mut DetermineRpVisitor,\n+                                cm: @ast::struct_field,\n+                                cx: @mut DetermineRpCtxt) {\n+    visit::walk_struct_field(visitor, cm, cx);\n+}\n+\n+struct DetermineRpVisitor;\n+\n+impl Visitor<@mut DetermineRpCtxt> for DetermineRpVisitor {\n+\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n+                b:&Block, s:span, n:NodeId, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_fn(self, fk, fd, b, s, n, e);\n+    }\n+    fn visit_item(&mut self, i:@item, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_item(self, i, e);\n+    }\n+    fn visit_ty(&mut self, t:&Ty, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_ty(self, t, e);\n+    }\n+    fn visit_ty_method(&mut self, t:&TypeMethod, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_ty_method(self, t, e);\n+    }\n+    fn visit_struct_field(&mut self, s:@struct_field, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_struct_field(self, s, e);\n+    }\n+\n }\n \n pub fn determine_rp_in_crate(sess: Session,\n@@ -894,15 +947,8 @@ pub fn determine_rp_in_crate(sess: Session,\n     };\n \n     // Gather up the base set, worklist and dep_map\n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_fn: determine_rp_in_fn,\n-        visit_item: determine_rp_in_item,\n-        visit_ty: determine_rp_in_ty,\n-        visit_ty_method: determine_rp_in_ty_method,\n-        visit_struct_field: determine_rp_in_struct_field,\n-        .. *oldvisit::default_visitor()\n-    });\n-    oldvisit::visit_crate(crate, (cx, visitor));\n+    let mut visitor = DetermineRpVisitor;\n+    visit::walk_crate(&mut visitor, crate, cx);\n \n     // Propagate indirect dependencies\n     //"}]}