{"sha": "8185ede1fad8312244e418b3c082f87386c40145", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxODVlZGUxZmFkODMxMjI0NGU0MThiM2MwODJmODczODZjNDAxNDU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-23T04:01:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-23T04:14:32Z"}, "message": "convert send_map to use explicit self", "tree": {"sha": "cc053b2308a4dbc3336f589421d013489a489b3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc053b2308a4dbc3336f589421d013489a489b3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8185ede1fad8312244e418b3c082f87386c40145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8185ede1fad8312244e418b3c082f87386c40145", "html_url": "https://github.com/rust-lang/rust/commit/8185ede1fad8312244e418b3c082f87386c40145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8185ede1fad8312244e418b3c082f87386c40145/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3", "html_url": "https://github.com/rust-lang/rust/commit/c8ce32e7f45a020eebcd7329fbe33e8b53f832a3"}], "stats": {"total": 141, "additions": 69, "deletions": 72}, "files": [{"sha": "05cd9f3f8220277f150de1eee15f83fed7aa1a77", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 69, "deletions": 72, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/8185ede1fad8312244e418b3c082f87386c40145/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8185ede1fad8312244e418b3c082f87386c40145/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=8185ede1fad8312244e418b3c082f87386c40145", "patch": "@@ -59,9 +59,10 @@ mod linear {\n             buckets: vec::from_fn(initial_capacity, |_i| none)})\n     }\n \n-    priv impl<K, V> &const LinearMap<K,V> {\n+    priv impl<K, V> LinearMap<K,V> {\n         #[inline(always)]\n-        pure fn to_bucket(h: uint) -> uint {\n+        pure fn to_bucket(&const self,\n+                          h: uint) -> uint {\n             // FIXME(#3041) borrow a more sophisticated technique here from\n             // Gecko, for example borrowing from Knuth, as Eich so\n             // colorfully argues for here:\n@@ -70,7 +71,9 @@ mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn next_bucket(idx: uint, len_buckets: uint) -> uint {\n+        pure fn next_bucket(&const self,\n+                            idx: uint,\n+                            len_buckets: uint) -> uint {\n             let n = (idx + 1) % len_buckets;\n             unsafe{ // argh. log not considered pure.\n                 debug!{\"next_bucket(%?, %?) = %?\", idx, len_buckets, n};\n@@ -79,7 +82,9 @@ mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn bucket_sequence(hash: uint, op: fn(uint) -> bool) -> uint {\n+        pure fn bucket_sequence(&const self,\n+                                hash: uint,\n+                                op: fn(uint) -> bool) -> uint {\n             let start_idx = self.to_bucket(hash);\n             let len_buckets = self.buckets.len();\n             let mut idx = start_idx;\n@@ -95,20 +100,18 @@ mod linear {\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key(\n-            buckets: &[option<Bucket<K,V>>],\n-            k: &K) -> SearchResult {\n-\n+        pure fn bucket_for_key(&const self,\n+                               buckets: &[option<Bucket<K,V>>],\n+                               k: &K) -> SearchResult {\n             let hash = self.hashfn(k);\n             self.bucket_for_key_with_hash(buckets, hash, k)\n         }\n \n         #[inline(always)]\n-        pure fn bucket_for_key_with_hash(\n-            buckets: &[option<Bucket<K,V>>],\n-            hash: uint,\n-            k: &K) -> SearchResult {\n-\n+        pure fn bucket_for_key_with_hash(&const self,\n+                                         buckets: &[option<Bucket<K,V>>],\n+                                         hash: uint,\n+                                         k: &K) -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n                 match buckets[i] {\n                   some(bkt) => if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n@@ -119,12 +122,10 @@ mod linear {\n             };\n             return TableFull;\n         }\n-    }\n \n-    priv impl<K,V> &mut LinearMap<K,V> {\n         /// Expands the capacity of the array and re-inserts each\n         /// of the existing buckets.\n-        fn expand() {\n+        fn expand(&mut self) {\n             let old_capacity = self.buckets.len();\n             let new_capacity = old_capacity * 2;\n             self.resize_at = ((new_capacity as float) * 3.0 / 4.0) as uint;\n@@ -141,15 +142,15 @@ mod linear {\n             }\n         }\n \n-        fn insert_bucket(+bucket: option<Bucket<K,V>>) {\n+        fn insert_bucket(&mut self, +bucket: option<Bucket<K,V>>) {\n             let {hash, key, value} <- option::unwrap(bucket);\n             let _ = self.insert_internal(hash, key, value);\n         }\n \n         /// Inserts the key value pair into the buckets.\n         /// Assumes that there will be a bucket.\n         /// True if there was no previous entry with that key\n-        fn insert_internal(hash: uint, +k: K, +v: V) -> bool {\n+        fn insert_internal(&mut self, hash: uint, +k: K, +v: V) -> bool {\n             match self.bucket_for_key_with_hash(self.buckets, hash, &k) {\n               TableFull => {fail ~\"Internal logic error\";}\n               FoundHole(idx) => {\n@@ -167,10 +168,16 @@ mod linear {\n               }\n             }\n         }\n+\n+        fn search(&self,\n+                  hash: uint,\n+                  op: fn(x: &option<Bucket<K,V>>) -> bool) {\n+            let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n+        }\n     }\n \n-    impl<K,V> &mut LinearMap<K,V> {\n-        fn insert(+k: K, +v: V) -> bool {\n+    impl<K,V> LinearMap<K,V> {\n+        fn insert(&mut self, +k: K, +v: V) -> bool {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n                 // that we do not resize if this call to insert is\n@@ -185,7 +192,7 @@ mod linear {\n             self.insert_internal(hash, k, v)\n         }\n \n-        fn remove(k: &K) -> bool {\n+        fn remove(&mut self, k: &K) -> bool {\n             // Removing from an open-addressed hashtable\n             // is, well, painful.  The problem is that\n             // the entry may lie on the probe path for other\n@@ -223,69 +230,33 @@ mod linear {\n             return true;\n         }\n \n-        fn clear() {\n+        fn clear(&mut self) {\n             for uint::range(0, self.buckets.len()) |idx| {\n                 self.buckets[idx] = none;\n             }\n             self.size = 0;\n         }\n-    }\n-\n-    priv impl<K,V> &LinearMap<K,V> {\n-        fn search(hash: uint, op: fn(x: &option<Bucket<K,V>>) -> bool) {\n-            let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n-        }\n-    }\n \n-    impl<K,V> &const LinearMap<K,V> {\n-        pure fn len() -> uint {\n+        pure fn len(&const self) -> uint {\n             self.size\n         }\n \n-        pure fn is_empty() -> bool {\n+        pure fn is_empty(&const self) -> bool {\n             self.len() == 0\n         }\n \n-        fn contains_key(k: &K) -> bool {\n+        fn contains_key(&const self,\n+                        k: &K) -> bool {\n             match self.bucket_for_key(self.buckets, k) {\n               FoundEntry(_) => {true}\n               TableFull | FoundHole(_) => {false}\n             }\n         }\n-    }\n-\n-    impl<K,V: copy> &const LinearMap<K,V> {\n-        fn find(k: &K) -> option<V> {\n-            match self.bucket_for_key(self.buckets, k) {\n-              FoundEntry(idx) => {\n-                match self.buckets[idx] {\n-                  some(bkt) => {some(copy bkt.value)}\n-                  // FIXME (#3148): Will be able to get rid of this when we\n-                  // redefine SearchResult\n-                  none      => fail ~\"LinearMap::find: internal logic error\"\n-                }\n-              }\n-              TableFull | FoundHole(_) => {\n-                none\n-              }\n-            }\n-        }\n \n-        fn get(k: &K) -> V {\n-            let value = self.find(k);\n-            if value.is_none() {\n-                fail fmt!{\"No entry found for key: %?\", k};\n-            }\n-            option::unwrap(value)\n-        }\n-\n-    }\n-\n-    impl<K,V> &LinearMap<K,V> {\n         /*\n         FIXME(#3148)--region inference fails to capture needed deps\n \n-        fn find_ref(k: &K) -> option<&self/V> {\n+        fn find_ref(&self, k: &K) -> option<&self/V> {\n             match self.bucket_for_key(self.buckets, k) {\n               FoundEntry(idx) => {\n                 match check self.buckets[idx] {\n@@ -299,7 +270,7 @@ mod linear {\n         }\n         */\n \n-        fn each_ref(blk: fn(k: &K, v: &V) -> bool) {\n+        fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool) {\n             for vec::each(self.buckets) |slot| {\n                 let mut broke = false;\n                 do slot.iter |bucket| {\n@@ -310,26 +281,52 @@ mod linear {\n                 if broke { break; }\n             }\n         }\n-        fn each_key_ref(blk: fn(k: &K) -> bool) {\n+\n+        fn each_key_ref(&self, blk: fn(k: &K) -> bool) {\n             self.each_ref(|k, _v| blk(k))\n         }\n-        fn each_value_ref(blk: fn(v: &V) -> bool) {\n+\n+        fn each_value_ref(&self, blk: fn(v: &V) -> bool) {\n             self.each_ref(|_k, v| blk(v))\n         }\n     }\n \n-    impl<K: copy, V: copy> &LinearMap<K,V> {\n-        fn each(blk: fn(+K,+V) -> bool) {\n+    impl<K,V: copy> LinearMap<K,V> {\n+        fn find(&const self, k: &K) -> option<V> {\n+            match self.bucket_for_key(self.buckets, k) {\n+              FoundEntry(idx) => {\n+                match check self.buckets[idx] {\n+                  some(bkt) => {some(copy bkt.value)}\n+                }\n+              }\n+              TableFull | FoundHole(_) => {\n+                none\n+              }\n+            }\n+        }\n+\n+        fn get(&const self, k: &K) -> V {\n+            let value = self.find(k);\n+            if value.is_none() {\n+                fail fmt!{\"No entry found for key: %?\", k};\n+            }\n+            option::unwrap(value)\n+        }\n+\n+    }\n+\n+    impl<K: copy, V: copy> LinearMap<K,V> {\n+        fn each(&self, blk: fn(+K,+V) -> bool) {\n             self.each_ref(|k,v| blk(copy *k, copy *v));\n         }\n     }\n-    impl<K: copy, V> &LinearMap<K,V> {\n-        fn each_key(blk: fn(+K) -> bool) {\n+    impl<K: copy, V> LinearMap<K,V> {\n+        fn each_key(&self, blk: fn(+K) -> bool) {\n             self.each_key_ref(|k| blk(copy *k));\n         }\n     }\n-    impl<K, V: copy> &LinearMap<K,V> {\n-        fn each_value(blk: fn(+V) -> bool) {\n+    impl<K, V: copy> LinearMap<K,V> {\n+        fn each_value(&self, blk: fn(+V) -> bool) {\n             self.each_value_ref(|v| blk(copy *v));\n         }\n     }"}]}