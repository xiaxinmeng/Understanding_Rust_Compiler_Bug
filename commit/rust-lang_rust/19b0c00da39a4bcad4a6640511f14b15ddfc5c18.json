{"sha": "19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YjBjMDBkYTM5YTRiY2FkNGE2NjQwNTExZjE0YjE1ZGRmYzVjMTg=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-02-12T09:55:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-12T09:55:37Z"}, "message": "Rollup merge of #68554 - cjgillot:lang_items, r=Zoxc\n\nSplit lang_items to crates `rustc_hir` and `rustc_passes`.\n\nAs discussed in comment https://github.com/rust-lang/rust/pull/67688#discussion_r368289946", "tree": {"sha": "c0a58cde88d8fbaba5cde1ad8e02e3fc178f7a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0a58cde88d8fbaba5cde1ad8e02e3fc178f7a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeQ8uZCRBK7hj4Ov3rIwAAdHIIAD5MuV2DwJtXY0ZPxAMo30sv\nibh6M+2SiGhkv9xrMPV4XxrxPU/P4/AaycWAqlYfNrZD1hzp6y+Ak5uJ0bd8mphc\nEjAcYo4QiXXndWvkzwd9krOxgfNuCoMtrN5C9b4v73xF+5eaWetX7buHXDO1l9v9\n1nqYEA0NVmV5bdFuq+7CcwPtk0oGkAbb+iAN9oouQAD2aAckk3KKraecvQYVPjWK\nSAOrkwUKzWyjXpCQVWvqksXEhwzkZYupHpf+TqENFmaGrJZVWPitQXu41Ik2Fsm/\n1NmDbFgFF5e6Tqo5/6xKQ8vmOlx9vgR1wW7i291X8Z2uAtZR5WmTDUJiMV3MGrg=\n=5qUO\n-----END PGP SIGNATURE-----\n", "payload": "tree c0a58cde88d8fbaba5cde1ad8e02e3fc178f7a6c\nparent 344f8d9e6237d2dc25d57dbc8448853084f63779\nparent fc73e196d9cf045c722aff27b9a2e595357384db\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1581501337 +0900\ncommitter GitHub <noreply@github.com> 1581501337 +0900\n\nRollup merge of #68554 - cjgillot:lang_items, r=Zoxc\n\nSplit lang_items to crates `rustc_hir` and `rustc_passes`.\n\nAs discussed in comment https://github.com/rust-lang/rust/pull/67688#discussion_r368289946\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "html_url": "https://github.com/rust-lang/rust/commit/19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "344f8d9e6237d2dc25d57dbc8448853084f63779", "url": "https://api.github.com/repos/rust-lang/rust/commits/344f8d9e6237d2dc25d57dbc8448853084f63779", "html_url": "https://github.com/rust-lang/rust/commit/344f8d9e6237d2dc25d57dbc8448853084f63779"}, {"sha": "fc73e196d9cf045c722aff27b9a2e595357384db", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc73e196d9cf045c722aff27b9a2e595357384db", "html_url": "https://github.com/rust-lang/rust/commit/fc73e196d9cf045c722aff27b9a2e595357384db"}], "stats": {"total": 1316, "additions": 688, "deletions": 628}, "files": [{"sha": "a37cd9148bf59c1ddeddc9a66b00c0bcd15f9406", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -3630,6 +3630,7 @@ version = \"0.0.0\"\n name = \"rustc_hir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"lazy_static 1.4.0\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_errors\","}, {"sha": "7d48280661a64232a6487687ab4dfc9b10c09eeb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -2,7 +2,6 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n-pub mod check_attr;\n pub mod exports;\n pub mod map;\n "}, {"sha": "1a763e43d557dea9520394b670096445794faeb1", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -251,12 +251,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for crate::middle::lang_items::LangItem {\n-    fn hash_stable(&self, _: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        ::std::hash::Hash::hash(self, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {"}, {"sha": "88ddd96eec8f5e66a61c1582bad4bd5b035d7ed0", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -1,40 +1,3 @@\n-macro_rules! enum_from_u32 {\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident = $e:expr,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant = $e),*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* pub enum $name:ident {\n-        $($variant:ident,)*\n-    }) => {\n-        $(#[$attr])*\n-        pub enum $name {\n-            $($variant,)*\n-        }\n-\n-        impl $name {\n-            pub fn from_u32(u: u32) -> Option<$name> {\n-                $(if u == $name::$variant as u32 {\n-                    return Some($name::$variant)\n-                })*\n-                None\n-            }\n-        }\n-    }\n-}\n-\n #[macro_export]\n macro_rules! bug {\n     () => ( bug!(\"impossible case reached\") );"}, {"sha": "c8e284be6fc09cf5cad7615b2d19fd125163d61e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 35, "deletions": 390, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -9,401 +9,14 @@\n \n pub use self::LangItem::*;\n \n-use crate::hir::check_attr::Target;\n-use crate::middle::cstore::ExternCrate;\n-use crate::middle::weak_lang_items;\n use crate::ty::{self, TyCtxt};\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_macros::HashStable;\n-use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n-use syntax::ast;\n+use rustc_target::spec::PanicStrategy;\n \n-// The actual lang items defined come at the end of this file in one handy table.\n-// So you probably just want to nip down to the end.\n-macro_rules! language_item_table {\n-    (\n-        $( $variant:ident, $name:expr, $method:ident, $target:path; )*\n-    ) => {\n-\n-enum_from_u32! {\n-    /// A representation of all the valid language items in Rust.\n-    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-    pub enum LangItem {\n-        $($variant,)*\n-    }\n-}\n-\n-impl LangItem {\n-    /// Returns the `name` in `#[lang = \"$name\"]`.\n-    /// For example, `LangItem::EqTraitLangItem`,\n-    /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n-    fn name(self) -> &'static str {\n-        match self {\n-            $( $variant => $name, )*\n-        }\n-    }\n-}\n-\n-#[derive(HashStable)]\n-pub struct LanguageItems {\n-    /// Mappings from lang items to their possibly found `DefId`s.\n-    /// The index corresponds to the order in `LangItem`.\n-    pub items: Vec<Option<DefId>>,\n-    /// Lang items that were not found during collection.\n-    pub missing: Vec<LangItem>,\n-}\n-\n-impl LanguageItems {\n-    /// Construct an empty collection of lang items and no missing ones.\n-    pub fn new() -> Self {\n-        fn init_none(_: LangItem) -> Option<DefId> { None }\n-\n-        Self {\n-            items: vec![$(init_none($variant)),*],\n-            missing: Vec::new(),\n-        }\n-    }\n-\n-    /// Returns the mappings to the possibly found `DefId`s for each lang item.\n-    pub fn items(&self) -> &[Option<DefId>] {\n-        &*self.items\n-    }\n-\n-    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n-    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-    /// returns an error message as a string.\n-    pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n-        self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n-    }\n-\n-    /// Returns the kind of closure that `id`, which is one of the `Fn*` traits, corresponds to.\n-    /// If `id` is not one of the `Fn*` traits, `None` is returned.\n-    pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n-        match Some(id) {\n-            x if x == self.fn_trait() => Some(ty::ClosureKind::Fn),\n-            x if x == self.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n-            x if x == self.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n-            _ => None\n-        }\n-    }\n-\n-    $(\n-        /// Returns the corresponding `DefId` for the lang item\n-        #[doc = $name]\n-        /// if it exists.\n-        #[allow(dead_code)]\n-        pub fn $method(&self) -> Option<DefId> {\n-            self.items[$variant as usize]\n-        }\n-    )*\n-}\n-\n-struct LanguageItemCollector<'tcx> {\n-    items: LanguageItems,\n-    tcx: TyCtxt<'tcx>,\n-    /// A mapping from the name of the lang item to its order and the form it must be of.\n-    item_refs: FxHashMap<&'static str, (usize, Target)>,\n-}\n-\n-impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if let Some((value, span)) = extract(&item.attrs) {\n-            let actual_target = Target::from_item(item);\n-            match self.item_refs.get(&*value.as_str()).cloned() {\n-                // Known lang item with attribute on correct target.\n-                Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                    self.collect_item(item_index, def_id);\n-                },\n-                // Known lang item with attribute on incorrect target.\n-                Some((_, expected_target)) => {\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0718,\n-                        \"`{}` language item must be applied to a {}\",\n-                        value, expected_target,\n-                    ).span_label(\n-                        span,\n-                        format!(\n-                            \"attribute should be applied to a {}, not a {}\",\n-                            expected_target, actual_target,\n-                        ),\n-                    ).emit();\n-                },\n-                // Unknown lang item.\n-                _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0522,\n-                        \"definition of an unknown language item: `{}`\",\n-                        value\n-                    ).span_label(\n-                        span,\n-                        format!(\"definition of unknown language item `{}`\", value)\n-                    ).emit();\n-                },\n-            }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n-        // At present, lang items are always items, not trait items.\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n-        // At present, lang items are always items, not impl items.\n-    }\n-}\n-\n-impl LanguageItemCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n-        let mut item_refs = FxHashMap::default();\n-\n-        $( item_refs.insert($name, ($variant as usize, $target)); )*\n-\n-        LanguageItemCollector {\n-            tcx,\n-            items: LanguageItems::new(),\n-            item_refs,\n-        }\n-    }\n-\n-    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n-        // Check for duplicates.\n-        if let Some(original_def_id) = self.items.items[item_index] {\n-            if original_def_id != item_def_id {\n-                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n-                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n-                    Some(span) => struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0152,\n-                        \"found duplicate lang item `{}`\",\n-                        name\n-                    ),\n-                    None => {\n-                        match self.tcx.extern_crate(item_def_id) {\n-                            Some(ExternCrate {dependency_of, ..}) => {\n-                                self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of),\n-                                name))\n-                            },\n-                            _ => {\n-                                self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}`: `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                name))\n-                            }\n-                        }\n-                    },\n-                };\n-                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n-                    err.span_note(span, \"the lang item is first defined here\");\n-                } else {\n-                    match self.tcx.extern_crate(original_def_id) {\n-                        Some(ExternCrate {dependency_of, ..}) => {\n-                            err.note(&format!(\n-                            \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n-                                      self.tcx.crate_name(original_def_id.krate),\n-                                      self.tcx.crate_name(*dependency_of)));\n-                        },\n-                        _ => {\n-                            err.note(&format!(\"the lang item is first defined in crate `{}`.\",\n-                                      self.tcx.crate_name(original_def_id.krate)));\n-                        }\n-                    }\n-                }\n-                err.emit();\n-            }\n-        }\n-\n-        // Matched.\n-        self.items.items[item_index] = Some(item_def_id);\n-    }\n-}\n-\n-/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n-/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n-/// are also extracted out when found.\n-pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n-    attrs.iter().find_map(|attr| Some(match attr {\n-        _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n-        _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-        _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n-        _ => return None,\n-    }))\n-}\n-\n-/// Traverses and collects all the lang items in all crates.\n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n-    // Initialize the collector.\n-    let mut collector = LanguageItemCollector::new(tcx);\n-\n-    // Collect lang items in other crates.\n-    for &cnum in tcx.crates().iter() {\n-        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n-            collector.collect_item(item_index, def_id);\n-        }\n-    }\n-\n-    // Collect lang items in this crate.\n-    tcx.hir().krate().visit_all_item_likes(&mut collector);\n-\n-    // Extract out the found lang items.\n-    let LanguageItemCollector { mut items, .. } = collector;\n-\n-    // Find all required but not-yet-defined lang items.\n-    weak_lang_items::check_crate(tcx, &mut items);\n-\n-    items\n-}\n-\n-// End of the macro\n-    }\n-}\n-\n-language_item_table! {\n-//  Variant name,                Name,                 Method name,             Target;\n-    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n-    CharImplItem,                \"char\",               char_impl,               Target::Impl;\n-    StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n-    SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n-    SliceU8ImplItem,             \"slice_u8\",           slice_u8_impl,           Target::Impl;\n-    StrAllocImplItem,            \"str_alloc\",          str_alloc_impl,          Target::Impl;\n-    SliceAllocImplItem,          \"slice_alloc\",        slice_alloc_impl,        Target::Impl;\n-    SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n-    ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n-    MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n-    I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n-    I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n-    I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;\n-    I64ImplItem,                 \"i64\",                i64_impl,                Target::Impl;\n-    I128ImplItem,                \"i128\",               i128_impl,               Target::Impl;\n-    IsizeImplItem,               \"isize\",              isize_impl,              Target::Impl;\n-    U8ImplItem,                  \"u8\",                 u8_impl,                 Target::Impl;\n-    U16ImplItem,                 \"u16\",                u16_impl,                Target::Impl;\n-    U32ImplItem,                 \"u32\",                u32_impl,                Target::Impl;\n-    U64ImplItem,                 \"u64\",                u64_impl,                Target::Impl;\n-    U128ImplItem,                \"u128\",               u128_impl,               Target::Impl;\n-    UsizeImplItem,               \"usize\",              usize_impl,              Target::Impl;\n-    F32ImplItem,                 \"f32\",                f32_impl,                Target::Impl;\n-    F64ImplItem,                 \"f64\",                f64_impl,                Target::Impl;\n-    F32RuntimeImplItem,          \"f32_runtime\",        f32_runtime_impl,        Target::Impl;\n-    F64RuntimeImplItem,          \"f64_runtime\",        f64_runtime_impl,        Target::Impl;\n-\n-    SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n-    UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n-    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n-    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n-    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n-    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n-    CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n-    CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n-    SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n-    FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n-\n-    DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n-\n-    CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n-    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n-\n-    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n-    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n-    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n-    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n-    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n-    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n-    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n-    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n-    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n-    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n-    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n-    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n-    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n-    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n-    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n-    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n-    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n-    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n-    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n-    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n-    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n-    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n-    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n-    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n-\n-    UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n-    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n-\n-    DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n-    DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n-    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n-\n-    FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n-    FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n-    FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n-\n-    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n-    GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n-    GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n-    UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n-    PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n-\n-    // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n-    EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n-    PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n-\n-    // A number of panic-related lang items. The `panic` item corresponds to\n-    // divide-by-zero and various panic cases with `match`. The\n-    // `panic_bounds_check` item is for indexing arrays.\n-    //\n-    // The `begin_unwind` lang item has a predefined symbol name and is sort of\n-    // a \"weak lang item\" in the sense that a crate is not required to have it\n-    // defined to use it, but a final product is required to define it\n-    // somewhere. Additionally, there are restrictions on crates that use a weak\n-    // lang item, but do not have it defined.\n-    PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n-    PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n-    PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n-    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n-    PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n-    // Libstd panic entry point. Necessary for const eval to be able to catch it\n-    BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;\n-\n-    ExchangeMallocFnLangItem,    \"exchange_malloc\",    exchange_malloc_fn,      Target::Fn;\n-    BoxFreeFnLangItem,           \"box_free\",           box_free_fn,             Target::Fn;\n-    DropInPlaceFnLangItem,       \"drop_in_place\",      drop_in_place_fn,        Target::Fn;\n-    OomLangItem,                 \"oom\",                oom,                     Target::Fn;\n-    AllocLayoutLangItem,         \"alloc_layout\",       alloc_layout,            Target::Struct;\n-\n-    StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n-\n-    EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n-    EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n-    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n-\n-    OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n-\n-    PhantomDataItem,             \"phantom_data\",       phantom_data,            Target::Struct;\n-\n-    ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n-\n-    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n-\n-    // Align offset for stride != 1; must not panic.\n-    AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n-\n-    TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n-\n-    Arc,                         \"arc\",                arc,                     Target::Struct;\n-    Rc,                          \"rc\",                 rc,                      Target::Struct;\n-}\n+pub use rustc_hir::weak_lang_items::link_name;\n+pub use rustc_hir::{LangItem, LanguageItems};\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n@@ -417,4 +30,36 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         })\n     }\n+\n+    pub fn fn_trait_kind_from_lang_item(&self, id: DefId) -> Option<ty::ClosureKind> {\n+        let items = self.lang_items();\n+        match Some(id) {\n+            x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),\n+            x if x == items.fn_mut_trait() => Some(ty::ClosureKind::FnMut),\n+            x if x == items.fn_once_trait() => Some(ty::ClosureKind::FnOnce),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n+        self.lang_items().is_weak_lang_item(item_def_id)\n+    }\n+}\n+\n+/// Returns `true` if the specified `lang_item` doesn't actually need to be\n+/// present for this compilation.\n+///\n+/// Not all lang items are always required for each compilation, particularly in\n+/// the case of panic=abort. In these situations some lang items are injected by\n+/// crates and don't actually need to be defined in libstd.\n+pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: LangItem) -> bool {\n+    // If we're not compiling with unwinding, we won't actually need these\n+    // symbols. Other panic runtimes ensure that the relevant symbols are\n+    // available to link things together, but they're never exercised.\n+    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n+        return lang_item == LangItem::EhPersonalityLangItem\n+            || lang_item == LangItem::EhUnwindResumeLangItem;\n+    }\n+\n+    false\n }"}, {"sha": "b20f2cf3a85c133f53bec53c9ea3b041aa21ff43", "filename": "src/librustc/middle/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmod.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -33,4 +33,3 @@ pub mod recursion_limit;\n pub mod region;\n pub mod resolve_lifetime;\n pub mod stability;\n-pub mod weak_lang_items;"}, {"sha": "5571f8f2313d56f0d8e0dae37ed41527bfa52847", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/344f8d9e6237d2dc25d57dbc8448853084f63779/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/344f8d9e6237d2dc25d57dbc8448853084f63779/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=344f8d9e6237d2dc25d57dbc8448853084f63779", "patch": "@@ -1,167 +0,0 @@\n-//! Validity checking for weak lang items\n-\n-use crate::middle::lang_items;\n-use crate::session::config;\n-\n-use crate::hir::map::Map;\n-use crate::ty::TyCtxt;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n-use rustc_target::spec::PanicStrategy;\n-use syntax::ast;\n-\n-macro_rules! weak_lang_items {\n-    ($($name:ident, $item:ident, $sym:ident;)*) => (\n-\n-struct Context<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    items: &'a mut lang_items::LanguageItems,\n-}\n-\n-/// Checks the crate for usage of weak lang items, returning a vector of all the\n-/// language items required by this crate, but not defined yet.\n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>,\n-                             items: &mut lang_items::LanguageItems) {\n-    // These are never called by user code, they're generated by the compiler.\n-    // They will never implicitly be added to the `missing` array unless we do\n-    // so here.\n-    if items.eh_personality().is_none() {\n-        items.missing.push(lang_items::EhPersonalityLangItem);\n-    }\n-    if tcx.sess.target.target.options.custom_unwind_resume &\n-       items.eh_unwind_resume().is_none() {\n-        items.missing.push(lang_items::EhUnwindResumeLangItem);\n-    }\n-\n-    {\n-        let mut cx = Context { tcx, items };\n-        tcx.hir().krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n-    }\n-    verify(tcx, items);\n-}\n-\n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n-    lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == sym::$name {\n-            Some(sym::$sym)\n-        } else)* {\n-            None\n-        }\n-    })\n-}\n-\n-/// Returns `true` if the specified `lang_item` doesn't actually need to be\n-/// present for this compilation.\n-///\n-/// Not all lang items are always required for each compilation, particularly in\n-/// the case of panic=abort. In these situations some lang items are injected by\n-/// crates and don't actually need to be defined in libstd.\n-pub fn whitelisted(tcx: TyCtxt<'_>, lang_item: lang_items::LangItem) -> bool {\n-    // If we're not compiling with unwinding, we won't actually need these\n-    // symbols. Other panic runtimes ensure that the relevant symbols are\n-    // available to link things together, but they're never exercised.\n-    if tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-        return lang_item == lang_items::EhPersonalityLangItem ||\n-            lang_item == lang_items::EhUnwindResumeLangItem\n-    }\n-\n-    false\n-}\n-\n-fn verify<'tcx>(tcx: TyCtxt<'tcx>,\n-                    items: &lang_items::LanguageItems) {\n-    // We only need to check for the presence of weak lang items if we're\n-    // emitting something that's not an rlib.\n-    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| {\n-        match *kind {\n-            config::CrateType::Dylib |\n-            config::CrateType::ProcMacro |\n-            config::CrateType::Cdylib |\n-            config::CrateType::Executable |\n-            config::CrateType::Staticlib => true,\n-            config::CrateType::Rlib => false,\n-        }\n-    });\n-    if !needs_check {\n-        return\n-    }\n-\n-    let mut missing = FxHashSet::default();\n-    for &cnum in tcx.crates().iter() {\n-        for &item in tcx.missing_lang_items(cnum).iter() {\n-            missing.insert(item);\n-        }\n-    }\n-\n-    $(\n-        if missing.contains(&lang_items::$item) &&\n-           !whitelisted(tcx, lang_items::$item) &&\n-           items.$name().is_none() {\n-            if lang_items::$item == lang_items::PanicImplLangItem {\n-                tcx.sess.err(&format!(\"`#[panic_handler]` function required, \\\n-                                       but not found\"));\n-            } else if lang_items::$item == lang_items::OomLangItem {\n-                tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, \\\n-                                       but not found\"));\n-            } else {\n-                tcx.sess.err(&format!(\"language item required, but not found: `{}`\",\n-                                      stringify!($name)));\n-            }\n-        }\n-    )*\n-}\n-\n-impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: Symbol, span: Span) {\n-        $(if name == sym::$name {\n-            if self.items.$name().is_none() {\n-                self.items.missing.push(lang_items::$item);\n-            }\n-        } else)* {\n-            struct_span_err!(\n-                self.tcx.sess, span, E0264,\n-                \"unknown external lang item: `{}`\",\n-                name\n-            )\n-            .emit();\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n-    type Map = Map<'v>;\n-\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, Map<'v>> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n-        if let Some((lang_item, _)) = lang_items::extract(&i.attrs) {\n-            self.register(lang_item, i.span);\n-        }\n-        intravisit::walk_foreign_item(self, i)\n-    }\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n-        let lang_items = self.lang_items();\n-        let did = Some(item_def_id);\n-\n-        $(lang_items.$name() == did)||*\n-    }\n-}\n-\n-) }\n-\n-weak_lang_items! {\n-    panic_impl,         PanicImplLangItem,          rust_begin_unwind;\n-    eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n-    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n-    oom,                OomLangItem,                rust_oom;\n-}"}, {"sha": "bf82d743c2b0466a5a7ccc8d5b4c010d2b656c58", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -1634,7 +1634,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()) {\n+        let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n             Some(k) => k,\n             None => {\n                 return Ok(());\n@@ -1677,7 +1677,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n         // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()).is_none() {\n+        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n \n@@ -2889,8 +2889,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let kind = self\n             .tcx()\n-            .lang_items()\n-            .fn_trait_kind(obligation.predicate.def_id())\n+            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n         // Okay to skip binder because the substs on closure types never"}, {"sha": "2adf708641798a86d08dc8307bb497f60048bf73", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -2716,10 +2716,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name\n     };\n-    providers.get_lang_items = |tcx, id| {\n-        assert_eq!(id, LOCAL_CRATE);\n-        tcx.arena.alloc(middle::lang_items::collect(tcx))\n-    };\n     providers.maybe_unused_trait_import = |tcx, id| tcx.maybe_unused_trait_imports.contains(&id);\n     providers.maybe_unused_extern_crates = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "b5e17661c5de1ed30c719bb23ea5765edc177e80", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -450,7 +450,7 @@ fn resolve_associated_item<'tcx>(\n             substs: generator_data.substs,\n         }),\n         traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.lang_items().fn_trait_kind(trait_id).unwrap();\n+            let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n             Some(Instance::resolve_closure(\n                 tcx,\n                 closure_data.closure_def_id,"}, {"sha": "274482cba64cc5d66c09ab21e40c503f0d734f1c", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -724,7 +724,7 @@ pub trait PrettyPrinter<'tcx>:\n             let mut resugared = false;\n \n             // Special-case `Fn(...) -> ...` and resugar it.\n-            let fn_trait_kind = self.tcx().lang_items().fn_trait_kind(principal.def_id);\n+            let fn_trait_kind = self.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n             if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n                 if let ty::Tuple(ref args) = principal.substs.type_at(0).kind {\n                     let mut projections = predicates.projection_bounds();"}, {"sha": "e9431d94863ef96a4eb87ff4ec1520cfccfa77cd", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -28,8 +28,8 @@ use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind}\n use rustc::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::{self, LinkagePreference};\n+use rustc::middle::lang_items;\n use rustc::middle::lang_items::StartFnLangItem;\n-use rustc::middle::weak_lang_items;\n use rustc::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, MonoItem};\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n@@ -847,11 +847,8 @@ impl CrateInfo {\n \n             // No need to look for lang items that are whitelisted and don't\n             // actually need to exist.\n-            let missing = missing\n-                .iter()\n-                .cloned()\n-                .filter(|&l| !weak_lang_items::whitelisted(tcx, l))\n-                .collect();\n+            let missing =\n+                missing.iter().cloned().filter(|&l| !lang_items::whitelisted(tcx, l)).collect();\n             info.missing_lang_items.insert(cnum, missing);\n         }\n "}, {"sha": "67fbe3058cdb981170ce653c9d22c0695f8f753c", "filename": "src/librustc_data_structures/macros.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -17,3 +17,41 @@ macro_rules! static_assert_size {\n         const _: [(); $size] = [(); ::std::mem::size_of::<$ty>()];\n     };\n }\n+\n+#[macro_export]\n+macro_rules! enum_from_u32 {\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident = $e:expr,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant = $e),*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* pub enum $name:ident {\n+        $($variant:ident,)*\n+    }) => {\n+        $(#[$attr])*\n+        pub enum $name {\n+            $($variant,)*\n+        }\n+\n+        impl $name {\n+            pub fn from_u32(u: u32) -> Option<$name> {\n+                $(if u == $name::$variant as u32 {\n+                    return Some($name::$variant)\n+                })*\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "cff6413253202dde7ea183f829048b5dc9033b19", "filename": "src/librustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2FCargo.toml?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -19,4 +19,5 @@ rustc_span = { path = \"../librustc_span\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n+lazy_static = \"1\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "cb5ebba463394c08353fdf1699da288c915f1b88", "filename": "src/librustc_hir/lang_items.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -0,0 +1,261 @@\n+//! Defines language items.\n+//!\n+//! Language items are items that represent concepts intrinsic to the language\n+//! itself. Examples are:\n+//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n+//! * Functions called by the compiler itself.\n+\n+pub use self::LangItem::*;\n+\n+use crate::def_id::DefId;\n+use crate::Target;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::Span;\n+use syntax::ast;\n+\n+use lazy_static::lazy_static;\n+\n+// The actual lang items defined come at the end of this file in one handy table.\n+// So you probably just want to nip down to the end.\n+macro_rules! language_item_table {\n+    (\n+        $( $variant:ident, $name:expr, $method:ident, $target:path; )*\n+    ) => {\n+\n+        enum_from_u32! {\n+            /// A representation of all the valid language items in Rust.\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+            pub enum LangItem {\n+                $($variant,)*\n+            }\n+        }\n+\n+        impl LangItem {\n+            /// Returns the `name` in `#[lang = \"$name\"]`.\n+            /// For example, `LangItem::EqTraitLangItem`,\n+            /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n+            pub fn name(self) -> &'static str {\n+                match self {\n+                    $( $variant => $name, )*\n+                }\n+            }\n+        }\n+\n+        #[derive(HashStable_Generic)]\n+        pub struct LanguageItems {\n+            /// Mappings from lang items to their possibly found `DefId`s.\n+            /// The index corresponds to the order in `LangItem`.\n+            pub items: Vec<Option<DefId>>,\n+            /// Lang items that were not found during collection.\n+            pub missing: Vec<LangItem>,\n+        }\n+\n+        impl LanguageItems {\n+            /// Construct an empty collection of lang items and no missing ones.\n+            pub fn new() -> Self {\n+                fn init_none(_: LangItem) -> Option<DefId> { None }\n+\n+                Self {\n+                    items: vec![$(init_none($variant)),*],\n+                    missing: Vec::new(),\n+                }\n+            }\n+\n+            /// Returns the mappings to the possibly found `DefId`s for each lang item.\n+            pub fn items(&self) -> &[Option<DefId>] {\n+                &*self.items\n+            }\n+\n+            /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n+            /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n+            /// returns an error message as a string.\n+            pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n+                self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n+            }\n+\n+            $(\n+                /// Returns the corresponding `DefId` for the lang item\n+                #[doc = $name]\n+                /// if it exists.\n+                #[allow(dead_code)]\n+                pub fn $method(&self) -> Option<DefId> {\n+                    self.items[$variant as usize]\n+                }\n+            )*\n+        }\n+\n+        lazy_static! {\n+            /// A mapping from the name of the lang item to its order and the form it must be of.\n+            pub static ref ITEM_REFS: FxHashMap<&'static str, (usize, Target)> = {\n+                let mut item_refs = FxHashMap::default();\n+                $( item_refs.insert($name, ($variant as usize, $target)); )*\n+                item_refs\n+            };\n+        }\n+\n+// End of the macro\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for LangItem {\n+    fn hash_stable(&self, _: &mut CTX, hasher: &mut StableHasher) {\n+        ::std::hash::Hash::hash(self, hasher);\n+    }\n+}\n+\n+/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n+/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n+/// are also extracted out when found.\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n+    attrs.iter().find_map(|attr| {\n+        Some(match attr {\n+            _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n+            _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n+            _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n+            _ => return None,\n+        })\n+    })\n+}\n+\n+language_item_table! {\n+//  Variant name,                Name,                 Method name,             Target;\n+    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n+    CharImplItem,                \"char\",               char_impl,               Target::Impl;\n+    StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n+    SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n+    SliceU8ImplItem,             \"slice_u8\",           slice_u8_impl,           Target::Impl;\n+    StrAllocImplItem,            \"str_alloc\",          str_alloc_impl,          Target::Impl;\n+    SliceAllocImplItem,          \"slice_alloc\",        slice_alloc_impl,        Target::Impl;\n+    SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n+    ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n+    MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n+    I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n+    I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n+    I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;\n+    I64ImplItem,                 \"i64\",                i64_impl,                Target::Impl;\n+    I128ImplItem,                \"i128\",               i128_impl,               Target::Impl;\n+    IsizeImplItem,               \"isize\",              isize_impl,              Target::Impl;\n+    U8ImplItem,                  \"u8\",                 u8_impl,                 Target::Impl;\n+    U16ImplItem,                 \"u16\",                u16_impl,                Target::Impl;\n+    U32ImplItem,                 \"u32\",                u32_impl,                Target::Impl;\n+    U64ImplItem,                 \"u64\",                u64_impl,                Target::Impl;\n+    U128ImplItem,                \"u128\",               u128_impl,               Target::Impl;\n+    UsizeImplItem,               \"usize\",              usize_impl,              Target::Impl;\n+    F32ImplItem,                 \"f32\",                f32_impl,                Target::Impl;\n+    F64ImplItem,                 \"f64\",                f64_impl,                Target::Impl;\n+    F32RuntimeImplItem,          \"f32_runtime\",        f32_runtime_impl,        Target::Impl;\n+    F64RuntimeImplItem,          \"f64_runtime\",        f64_runtime_impl,        Target::Impl;\n+\n+    SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n+    UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n+    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n+    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n+    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n+    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n+    CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n+    CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n+    SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n+    FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n+\n+    DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n+\n+    CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n+    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n+\n+    AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n+    SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;\n+    MulTraitLangItem,            \"mul\",                mul_trait,               Target::Trait;\n+    DivTraitLangItem,            \"div\",                div_trait,               Target::Trait;\n+    RemTraitLangItem,            \"rem\",                rem_trait,               Target::Trait;\n+    NegTraitLangItem,            \"neg\",                neg_trait,               Target::Trait;\n+    NotTraitLangItem,            \"not\",                not_trait,               Target::Trait;\n+    BitXorTraitLangItem,         \"bitxor\",             bitxor_trait,            Target::Trait;\n+    BitAndTraitLangItem,         \"bitand\",             bitand_trait,            Target::Trait;\n+    BitOrTraitLangItem,          \"bitor\",              bitor_trait,             Target::Trait;\n+    ShlTraitLangItem,            \"shl\",                shl_trait,               Target::Trait;\n+    ShrTraitLangItem,            \"shr\",                shr_trait,               Target::Trait;\n+    AddAssignTraitLangItem,      \"add_assign\",         add_assign_trait,        Target::Trait;\n+    SubAssignTraitLangItem,      \"sub_assign\",         sub_assign_trait,        Target::Trait;\n+    MulAssignTraitLangItem,      \"mul_assign\",         mul_assign_trait,        Target::Trait;\n+    DivAssignTraitLangItem,      \"div_assign\",         div_assign_trait,        Target::Trait;\n+    RemAssignTraitLangItem,      \"rem_assign\",         rem_assign_trait,        Target::Trait;\n+    BitXorAssignTraitLangItem,   \"bitxor_assign\",      bitxor_assign_trait,     Target::Trait;\n+    BitAndAssignTraitLangItem,   \"bitand_assign\",      bitand_assign_trait,     Target::Trait;\n+    BitOrAssignTraitLangItem,    \"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n+    ShlAssignTraitLangItem,      \"shl_assign\",         shl_assign_trait,        Target::Trait;\n+    ShrAssignTraitLangItem,      \"shr_assign\",         shr_assign_trait,        Target::Trait;\n+    IndexTraitLangItem,          \"index\",              index_trait,             Target::Trait;\n+    IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n+\n+    UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n+    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n+\n+    DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n+    DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n+    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n+\n+    FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n+    FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n+    FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n+\n+    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n+    GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n+    GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n+    UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n+    PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n+\n+    // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n+    EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n+    PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n+\n+    // A number of panic-related lang items. The `panic` item corresponds to\n+    // divide-by-zero and various panic cases with `match`. The\n+    // `panic_bounds_check` item is for indexing arrays.\n+    //\n+    // The `begin_unwind` lang item has a predefined symbol name and is sort of\n+    // a \"weak lang item\" in the sense that a crate is not required to have it\n+    // defined to use it, but a final product is required to define it\n+    // somewhere. Additionally, there are restrictions on crates that use a weak\n+    // lang item, but do not have it defined.\n+    PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n+    PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n+    PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n+    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n+    PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n+    // Libstd panic entry point. Necessary for const eval to be able to catch it\n+    BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;\n+\n+    ExchangeMallocFnLangItem,    \"exchange_malloc\",    exchange_malloc_fn,      Target::Fn;\n+    BoxFreeFnLangItem,           \"box_free\",           box_free_fn,             Target::Fn;\n+    DropInPlaceFnLangItem,       \"drop_in_place\",      drop_in_place_fn,        Target::Fn;\n+    OomLangItem,                 \"oom\",                oom,                     Target::Fn;\n+    AllocLayoutLangItem,         \"alloc_layout\",       alloc_layout,            Target::Struct;\n+\n+    StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n+\n+    EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n+    EhUnwindResumeLangItem,      \"eh_unwind_resume\",   eh_unwind_resume,        Target::Fn;\n+    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n+\n+    OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n+\n+    PhantomDataItem,             \"phantom_data\",       phantom_data,            Target::Struct;\n+\n+    ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n+\n+    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n+\n+    // Align offset for stride != 1; must not panic.\n+    AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n+\n+    TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n+\n+    Arc,                         \"arc\",                arc,                     Target::Struct;\n+    Rc,                          \"rc\",                 rc,                      Target::Struct;\n+}"}, {"sha": "d958dfc681b00fe0703c2770dbf5ef78807a3033", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -17,9 +17,15 @@ mod hir;\n pub mod hir_id;\n pub mod intravisit;\n pub mod itemlikevisit;\n+pub mod lang_items;\n pub mod pat_util;\n pub mod print;\n mod stable_hash_impls;\n+mod target;\n+pub mod weak_lang_items;\n+\n pub use hir::*;\n pub use hir_id::*;\n+pub use lang_items::{LangItem, LanguageItems};\n pub use stable_hash_impls::HashStableContext;\n+pub use target::{MethodKind, Target};"}, {"sha": "501976fc3cb39cb020f9bbb49c5c343309abaf8e", "filename": "src/librustc_hir/target.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Ftarget.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -4,8 +4,8 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use rustc_hir as hir;\n-use rustc_hir::{Item, ItemKind, TraitItem, TraitItemKind};\n+use crate::hir;\n+use crate::{Item, ItemKind, TraitItem, TraitItemKind};\n \n use std::fmt::{self, Display};\n ", "previous_filename": "src/librustc/hir/check_attr.rs"}, {"sha": "79182caae8c80e2c6346950924f5edad3855b88a", "filename": "src/librustc_hir/weak_lang_items.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_hir%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fweak_lang_items.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -0,0 +1,48 @@\n+//! Validity checking for weak lang items\n+\n+use crate::def_id::DefId;\n+use crate::{lang_items, LangItem, LanguageItems};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::{sym, Symbol};\n+use syntax::ast;\n+\n+use lazy_static::lazy_static;\n+\n+macro_rules! weak_lang_items {\n+    ($($name:ident, $item:ident, $sym:ident;)*) => (\n+\n+lazy_static! {\n+    pub static ref WEAK_ITEMS_REFS: FxHashMap<Symbol, LangItem> = {\n+        let mut map = FxHashMap::default();\n+        $(map.insert(sym::$name, lang_items::$item);)*\n+        map\n+    };\n+}\n+\n+pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n+    lang_items::extract(attrs).and_then(|(name, _)| {\n+        $(if name == sym::$name {\n+            Some(sym::$sym)\n+        } else)* {\n+            None\n+        }\n+    })\n+}\n+\n+impl LanguageItems {\n+    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n+        let did = Some(item_def_id);\n+\n+        $(self.$name() == did)||*\n+    }\n+}\n+\n+) }\n+\n+weak_lang_items! {\n+    panic_impl,         PanicImplLangItem,          rust_begin_unwind;\n+    eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n+    eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n+    oom,                OomLangItem,                rust_oom;\n+}"}, {"sha": "bfd30ff5da553ee15c6c33ebe8f87b102a17e7f1", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -40,7 +40,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         ),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n-            let adjustment = match tcx.lang_items().fn_trait_kind(trait_) {\n+            let adjustment = match tcx.fn_trait_kind_from_lang_item(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n                 Some(ty::ClosureKind::FnMut) | Some(ty::ClosureKind::Fn) => Adjustment::Deref,\n                 None => bug!(\"fn pointer {:?} is not an fn\", ty),"}, {"sha": "5cabf3c0262a1e446f06aa0ecf82dd5840ba4c9b", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -4,7 +4,6 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use rustc::hir::check_attr::{MethodKind, Target};\n use rustc::hir::map::Map;\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n@@ -15,6 +14,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::DUMMY_HIR_ID;\n use rustc_hir::{self, HirId, Item, ItemKind, TraitItem};\n+use rustc_hir::{MethodKind, Target};\n use rustc_session::lint::builtin::{CONFLICTING_REPR_HINTS, UNUSED_ATTRIBUTES};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;"}, {"sha": "5f5acc7fdf8150eddc480f25811f23ca502b8ce5", "filename": "src/librustc_passes/lang_items.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -0,0 +1,174 @@\n+//! Detecting language items.\n+//!\n+//! Language items are items that represent concepts intrinsic to the language\n+//! itself. Examples are:\n+//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n+//! * Functions called by the compiler itself.\n+\n+use crate::weak_lang_items;\n+\n+use rustc::middle::cstore::ExternCrate;\n+use rustc::ty::TyCtxt;\n+\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_hir::lang_items::{extract, ITEM_REFS};\n+use rustc_hir::{LangItem, LanguageItems, Target};\n+\n+use rustc::ty::query::Providers;\n+\n+struct LanguageItemCollector<'tcx> {\n+    items: LanguageItems,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n+        if let Some((value, span)) = extract(&item.attrs) {\n+            let actual_target = Target::from_item(item);\n+            match ITEM_REFS.get(&*value.as_str()).cloned() {\n+                // Known lang item with attribute on correct target.\n+                Some((item_index, expected_target)) if actual_target == expected_target => {\n+                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n+                    self.collect_item(item_index, def_id);\n+                }\n+                // Known lang item with attribute on incorrect target.\n+                Some((_, expected_target)) => {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0718,\n+                        \"`{}` language item must be applied to a {}\",\n+                        value,\n+                        expected_target,\n+                    )\n+                    .span_label(\n+                        span,\n+                        format!(\n+                            \"attribute should be applied to a {}, not a {}\",\n+                            expected_target, actual_target,\n+                        ),\n+                    )\n+                    .emit();\n+                }\n+                // Unknown lang item.\n+                _ => {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0522,\n+                        \"definition of an unknown language item: `{}`\",\n+                        value\n+                    )\n+                    .span_label(span, format!(\"definition of unknown language item `{}`\", value))\n+                    .emit();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n+        // At present, lang items are always items, not trait items.\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n+        // At present, lang items are always items, not impl items.\n+    }\n+}\n+\n+impl LanguageItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n+        LanguageItemCollector { tcx, items: LanguageItems::new() }\n+    }\n+\n+    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n+        // Check for duplicates.\n+        if let Some(original_def_id) = self.items.items[item_index] {\n+            if original_def_id != item_def_id {\n+                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n+                    Some(span) => struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0152,\n+                        \"found duplicate lang item `{}`\",\n+                        name\n+                    ),\n+                    None => match self.tcx.extern_crate(item_def_id) {\n+                        Some(ExternCrate { dependency_of, .. }) => {\n+                            self.tcx.sess.struct_err(&format!(\n+                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n+                                self.tcx.crate_name(item_def_id.krate),\n+                                self.tcx.crate_name(*dependency_of),\n+                                name\n+                            ))\n+                        }\n+                        _ => self.tcx.sess.struct_err(&format!(\n+                            \"duplicate lang item in crate `{}`: `{}`.\",\n+                            self.tcx.crate_name(item_def_id.krate),\n+                            name\n+                        )),\n+                    },\n+                };\n+                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n+                    err.span_note(span, \"the lang item is first defined here\");\n+                } else {\n+                    match self.tcx.extern_crate(original_def_id) {\n+                        Some(ExternCrate { dependency_of, .. }) => {\n+                            err.note(&format!(\n+                                \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n+                                self.tcx.crate_name(original_def_id.krate),\n+                                self.tcx.crate_name(*dependency_of)\n+                            ));\n+                        }\n+                        _ => {\n+                            err.note(&format!(\n+                                \"the lang item is first defined in crate `{}`.\",\n+                                self.tcx.crate_name(original_def_id.krate)\n+                            ));\n+                        }\n+                    }\n+                }\n+                err.emit();\n+            }\n+        }\n+\n+        // Matched.\n+        self.items.items[item_index] = Some(item_def_id);\n+    }\n+}\n+\n+/// Traverses and collects all the lang items in all crates.\n+fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n+    // Initialize the collector.\n+    let mut collector = LanguageItemCollector::new(tcx);\n+\n+    // Collect lang items in other crates.\n+    for &cnum in tcx.crates().iter() {\n+        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n+            collector.collect_item(item_index, def_id);\n+        }\n+    }\n+\n+    // Collect lang items in this crate.\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n+\n+    // Extract out the found lang items.\n+    let LanguageItemCollector { mut items, .. } = collector;\n+\n+    // Find all required but not-yet-defined lang items.\n+    weak_lang_items::check_crate(tcx, &mut items);\n+\n+    items\n+}\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.get_lang_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        tcx.arena.alloc(collect(tcx))\n+    };\n+}"}, {"sha": "afafbacb8fa88a6b4640600630c308242aa536d6", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -23,6 +23,7 @@ mod diagnostic_items;\n pub mod entry;\n pub mod hir_stats;\n mod intrinsicck;\n+mod lang_items;\n pub mod layout_test;\n mod lib_features;\n mod liveness;\n@@ -31,12 +32,14 @@ mod reachable;\n mod region;\n pub mod stability;\n mod upvars;\n+mod weak_lang_items;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     check_attr::provide(providers);\n     check_const::provide(providers);\n     diagnostic_items::provide(providers);\n     entry::provide(providers);\n+    lang_items::provide(providers);\n     lib_features::provide(providers);\n     loops::provide(providers);\n     liveness::provide(providers);"}, {"sha": "010712c28ba753f1111bf2e4c2e472769b2450b4", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -0,0 +1,103 @@\n+//! Validity checking for weak lang items\n+\n+use rustc::middle::lang_items;\n+use rustc::middle::lang_items::whitelisted;\n+use rustc::session::config;\n+\n+use rustc::hir::map::Map;\n+use rustc::ty::TyCtxt;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+\n+struct Context<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    items: &'a mut lang_items::LanguageItems,\n+}\n+\n+/// Checks the crate for usage of weak lang items, returning a vector of all the\n+/// language items required by this crate, but not defined yet.\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItems) {\n+    // These are never called by user code, they're generated by the compiler.\n+    // They will never implicitly be added to the `missing` array unless we do\n+    // so here.\n+    if items.eh_personality().is_none() {\n+        items.missing.push(lang_items::EhPersonalityLangItem);\n+    }\n+    if tcx.sess.target.target.options.custom_unwind_resume & items.eh_unwind_resume().is_none() {\n+        items.missing.push(lang_items::EhUnwindResumeLangItem);\n+    }\n+\n+    {\n+        let mut cx = Context { tcx, items };\n+        tcx.hir().krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n+    }\n+    verify(tcx, items);\n+}\n+\n+fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n+    // We only need to check for the presence of weak lang items if we're\n+    // emitting something that's not an rlib.\n+    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| match *kind {\n+        config::CrateType::Dylib\n+        | config::CrateType::ProcMacro\n+        | config::CrateType::Cdylib\n+        | config::CrateType::Executable\n+        | config::CrateType::Staticlib => true,\n+        config::CrateType::Rlib => false,\n+    });\n+    if !needs_check {\n+        return;\n+    }\n+\n+    let mut missing = FxHashSet::default();\n+    for &cnum in tcx.crates().iter() {\n+        for &item in tcx.missing_lang_items(cnum).iter() {\n+            missing.insert(item);\n+        }\n+    }\n+\n+    for (name, &item) in WEAK_ITEMS_REFS.iter() {\n+        if missing.contains(&item) && !whitelisted(tcx, item) && items.require(item).is_err() {\n+            if item == lang_items::PanicImplLangItem {\n+                tcx.sess.err(&format!(\"`#[panic_handler]` function required, but not found\"));\n+            } else if item == lang_items::OomLangItem {\n+                tcx.sess.err(&format!(\"`#[alloc_error_handler]` function required, but not found\"));\n+            } else {\n+                tcx.sess.err(&format!(\"language item required, but not found: `{}`\", name));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Context<'a, 'tcx> {\n+    fn register(&mut self, name: Symbol, span: Span) {\n+        if let Some(&item) = WEAK_ITEMS_REFS.get(&name) {\n+            if self.items.require(item).is_err() {\n+                self.items.missing.push(item);\n+            }\n+        } else {\n+            struct_span_err!(self.tcx.sess, span, E0264, \"unknown external lang item: `{}`\", name)\n+                .emit();\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n+    type Map = Map<'v>;\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, Map<'v>> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n+        if let Some((lang_item, _)) = hir::lang_items::extract(&i.attrs) {\n+            self.register(lang_item, i.span);\n+        }\n+        intravisit::walk_foreign_item(self, i)\n+    }\n+}"}, {"sha": "396534b3caeb7b63840254eeed815da3b4fd6e76", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .next();\n                 let kind = object_type\n                     .principal_def_id()\n-                    .and_then(|did| self.tcx.lang_items().fn_trait_kind(did));\n+                    .and_then(|did| self.tcx.fn_trait_kind_from_lang_item(did));\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // many viable options, so pick the most restrictive.\n         let expected_kind = self\n             .obligations_for_self_ty(expected_vid)\n-            .filter_map(|(tr, _)| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n+            .filter_map(|(tr, _)| self.tcx.fn_trait_kind_from_lang_item(tr.def_id()))\n             .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n \n         (expected_sig, expected_kind)\n@@ -237,7 +237,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n-        let is_fn = tcx.lang_items().fn_trait_kind(trait_ref.def_id()).is_some();\n+        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some();\n         let gen_trait = tcx.require_lang_item(lang_items::GeneratorTraitLangItem, cause_span);\n         let is_gen = gen_trait == trait_ref.def_id();\n         if !is_fn && !is_gen {"}, {"sha": "ea0e4719a24fd34b004dbc913039d82c2f257b43", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -20,8 +20,8 @@ use crate::astconv::{AstConv, Bounds, SizedByDefault};\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n use crate::lint;\n+use crate::middle::lang_items;\n use crate::middle::resolve_lifetime as rl;\n-use crate::middle::weak_lang_items;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::Map;\n use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -2977,7 +2977,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if tcx.is_weak_lang_item(id) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n-    if let Some(name) = weak_lang_items::link_name(&attrs) {\n+    if let Some(name) = lang_items::link_name(&attrs) {\n         codegen_fn_attrs.export_name = Some(name);\n         codegen_fn_attrs.link_name = Some(name);\n     }"}, {"sha": "ef357056504529f9dd5245575ba7e148d7687675", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b0c00da39a4bcad4a6640511f14b15ddfc5c18/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=19b0c00da39a4bcad4a6640511f14b15ddfc5c18", "patch": "@@ -138,7 +138,7 @@ pub fn external_generic_args(\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n+        Some(did) if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() => {\n             assert!(ty_kind.is_some());\n             let inputs = match ty_kind {\n                 Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),"}]}