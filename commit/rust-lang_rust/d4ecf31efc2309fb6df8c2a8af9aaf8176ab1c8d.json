{"sha": "d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZWNmMzFlZmMyMzA5ZmI2ZGY4YzJhOGFmOWFhZjgxNzZhYjFjOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-15T08:09:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-15T08:09:38Z"}, "message": "Auto merge of #73367 - RalfJung:rollup-4ewvk9b, r=RalfJung\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #71824 (Check for live drops in constants after drop elaboration)\n - #72389 (Explain move errors that occur due to method calls involving `self`)\n - #72556 (Fix trait alias inherent impl resolution)\n - #72584 (Stabilize vec::Drain::as_slice)\n - #72598 (Display information about captured variable in `FnMut` error)\n - #73336 (Group `Pattern::strip_*` method together)\n - #73341 (_match.rs: fix module doc comment)\n - #73342 (Fix iterator copied() documentation example code)\n - #73351 (Update E0446.md)\n - #73353 (structural_match: non-structural-match ty closures)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "90b5827146e0a10bf9936642765ffdcb7eb177cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90b5827146e0a10bf9936642765ffdcb7eb177cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "html_url": "https://github.com/rust-lang/rust/commit/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce6d3a73b514e9649e57cee812ad129bb2112016", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce6d3a73b514e9649e57cee812ad129bb2112016", "html_url": "https://github.com/rust-lang/rust/commit/ce6d3a73b514e9649e57cee812ad129bb2112016"}, {"sha": "bca9e90f9f190ed94033d674f195b141dbaf5ec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca9e90f9f190ed94033d674f195b141dbaf5ec6", "html_url": "https://github.com/rust-lang/rust/commit/bca9e90f9f190ed94033d674f195b141dbaf5ec6"}], "stats": {"total": 2081, "additions": 1574, "deletions": 507}, "files": [{"sha": "06462fd96d9a9d16a2e966bbf1a58677b88887fa", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -2779,19 +2779,25 @@ impl<'a, T> Drain<'a, T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(vec_drain_as_slice)]\n     /// let mut vec = vec!['a', 'b', 'c'];\n     /// let mut drain = vec.drain(..);\n     /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n     /// let _ = drain.next().unwrap();\n     /// assert_eq!(drain.as_slice(), &['b', 'c']);\n     /// ```\n-    #[unstable(feature = \"vec_drain_as_slice\", reason = \"recently added\", issue = \"58957\")]\n+    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n     pub fn as_slice(&self) -> &[T] {\n         self.iter.as_slice()\n     }\n }\n \n+#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n+impl<'a, T> AsRef<[T]> for Drain<'a, T> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]"}, {"sha": "9dbc23f5c04c5cea9262c56255e2d94727a84491", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -56,6 +56,7 @@ pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n where\n     T: Generator<ResumeTy, Yield = ()>,\n {\n+    #[rustc_diagnostic_item = \"gen_future\"]\n     struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n \n     // We rely on the fact that async/await futures are immovable in order to create"}, {"sha": "fbfcdc3c1a9ea32177f9ec9735fec79c2d276d42", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -2717,12 +2717,12 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3];\n     ///\n-    /// let v_cloned: Vec<_> = a.iter().copied().collect();\n+    /// let v_copied: Vec<_> = a.iter().copied().collect();\n     ///\n     /// // copied is the same as .map(|&x| x)\n     /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n     ///\n-    /// assert_eq!(v_cloned, vec![1, 2, 3]);\n+    /// assert_eq!(v_copied, vec![1, 2, 3]);\n     /// assert_eq!(v_map, vec![1, 2, 3]);\n     /// ```\n     #[stable(feature = \"iter_copied\", since = \"1.36.0\")]"}, {"sha": "14f1f293d40d68716fd09e8ba5c6dd04db715114", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -69,7 +69,7 @@ use crate::slice::memchr;\n /// |--------------------------|-------------------------------------------|\n /// | `&str`                   | is substring                              |\n /// | `char`                   | is contained in string                    |\n-/// | `&[char]                 | any char in slice is contained in string  |\n+/// | `&[char]`                | any char in slice is contained in string  |\n /// | `F: FnMut(char) -> bool` | `F` returns `true` for a char in string   |\n /// | `&&str`                  | is substring                              |\n /// | `&String`                | is substring                              |\n@@ -117,6 +117,15 @@ pub trait Pattern<'a>: Sized {\n         matches!(self.into_searcher(haystack).next(), SearchStep::Match(0, _))\n     }\n \n+    /// Checks whether the pattern matches at the back of the haystack\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool\n+    where\n+        Self::Searcher: ReverseSearcher<'a>,\n+    {\n+        matches!(self.into_searcher(haystack).next_back(), SearchStep::Match(_, j) if haystack.len() == j)\n+    }\n+\n     /// Removes the pattern from the front of haystack, if it matches.\n     #[inline]\n     fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n@@ -133,15 +142,6 @@ pub trait Pattern<'a>: Sized {\n         }\n     }\n \n-    /// Checks whether the pattern matches at the back of the haystack\n-    #[inline]\n-    fn is_suffix_of(self, haystack: &'a str) -> bool\n-    where\n-        Self::Searcher: ReverseSearcher<'a>,\n-    {\n-        matches!(self.into_searcher(haystack).next_back(), SearchStep::Match(_, j) if haystack.len() == j)\n-    }\n-\n     /// Removes the pattern from the back of haystack, if it matches.\n     #[inline]\n     fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str>"}, {"sha": "e59cacfffc9264b60f7e29ee54168771feb29d31", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n+use rustc_span::source_map::{respan, DesugaringKind, ForLoopLoc, Span, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n@@ -25,6 +25,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n+        let mut span = e.span;\n         ensure_sufficient_stack(|| {\n             let kind = match e.kind {\n                 ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n@@ -53,6 +54,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args, span)\n                 }\n                 ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+                    span = self.mark_span_with_reason(DesugaringKind::Operator, e.span, None);\n                     let binop = self.lower_binop(binop);\n                     let lhs = self.lower_expr(lhs);\n                     let rhs = self.lower_expr(rhs);\n@@ -222,7 +224,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::Expr {\n                 hir_id: self.lower_node_id(e.id),\n                 kind,\n-                span: e.span,\n+                span,\n                 attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n             }\n         })\n@@ -237,6 +239,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_binop(&mut self, b: BinOp) -> hir::BinOp {\n+        let span = self.mark_span_with_reason(DesugaringKind::Operator, b.span, None);\n         Spanned {\n             node: match b.node {\n                 BinOpKind::Add => hir::BinOpKind::Add,\n@@ -258,7 +261,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 BinOpKind::Ge => hir::BinOpKind::Ge,\n                 BinOpKind::Gt => hir::BinOpKind::Gt,\n             },\n-            span: b.span,\n+            span,\n         }\n     }\n \n@@ -1360,9 +1363,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::Expr<'hir> {\n+        let orig_head_span = head.span;\n         // expand <head>\n         let mut head = self.lower_expr_mut(head);\n-        let desugared_span = self.mark_span_with_reason(DesugaringKind::ForLoop, head.span, None);\n+        let desugared_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::Head),\n+            orig_head_span,\n+            None,\n+        );\n         head.span = desugared_span;\n \n         let iter = Ident::with_dummy_span(sym::iter);\n@@ -1457,10 +1465,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `mut iter => { ... }`\n         let iter_arm = self.arm(iter_pat, loop_expr);\n \n+        let into_iter_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::IntoIter),\n+            orig_head_span,\n+            None,\n+        );\n+\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            self.expr_call_std_path(desugared_span, into_iter_path, arena_vec![self; head])\n+            self.expr_call_std_path(into_iter_span, into_iter_path, arena_vec![self; head])\n         };\n \n         let match_expr = self.arena.alloc(self.expr_match("}, {"sha": "6ec47c4962c06fc50414a955175a039b6ab2f604", "filename": "src/librustc_error_codes/error_codes/E0446.md", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,10 +4,10 @@ Erroneous code example:\n \n ```compile_fail,E0446\n #![deny(private_in_public)]\n+struct Bar(u32);\n \n-mod Foo {\n-    struct Bar(u32);\n-\n+mod foo {\n+    use crate::Bar;\n     pub fn bar() -> Bar { // error: private type in public interface\n         Bar(0)\n     }\n@@ -16,15 +16,31 @@ mod Foo {\n fn main() {}\n ```\n \n-To solve this error, please ensure that the type is also public. The type\n-can be made inaccessible if necessary by placing it into a private inner\n-module, but it still has to be marked with `pub`.\n+There are two ways to solve this error. The first is to make the public type\n+signature only public to a module that also has access to the private type.\n+This is done by using pub(crate) or pub(in crate::my_mod::etc)\n Example:\n \n ```\n-mod Foo {\n-    pub struct Bar(u32); // we set the Bar type public\n+struct Bar(u32);\n+\n+mod foo {\n+    use crate::Bar;\n+    pub(crate) fn bar() -> Bar { // only public to crate root\n+        Bar(0)\n+    }\n+}\n \n+fn main() {}\n+```\n+\n+The other way to solve this error is to make the private type public.\n+Example:\n+\n+```\n+pub struct Bar(u32); // we set the Bar type public\n+mod foo {\n+    use crate::Bar;\n     pub fn bar() -> Bar { // ok!\n         Bar(0)\n     }"}, {"sha": "0dcc3b62b4b2f66258b154a8b443989abef6bb49", "filename": "src/librustc_error_codes/error_codes/E0493.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,5 +1,4 @@\n-A type with a `Drop` implementation was destructured when trying to initialize\n-a static item.\n+A value with a custom `Drop` implementation may be dropped during const-eval.\n \n Erroneous code example:\n \n@@ -16,13 +15,14 @@ struct Foo {\n     field1: DropType,\n }\n \n-static FOO: Foo = Foo { ..Foo { field1: DropType::A } }; // error!\n+static FOO: Foo = Foo { field1: (DropType::A, DropType::A).1 }; // error!\n ```\n \n The problem here is that if the given type or one of its fields implements the\n-`Drop` trait, this `Drop` implementation cannot be called during the static\n-type initialization which might cause a memory leak. To prevent this issue,\n-you need to instantiate all the static type's fields by hand.\n+`Drop` trait, this `Drop` implementation cannot be called within a const\n+context since it may run arbitrary, non-const-checked code. To prevent this\n+issue, ensure all values with custom a custom `Drop` implementation escape the\n+initializer.\n \n ```\n enum DropType {"}, {"sha": "d186f35a12b5a1f9566ea39b2aa4e05a532af4d0", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -577,6 +577,9 @@ declare_features! (\n     /// Allows `extern \"avr-interrupt\" fn()` and `extern \"avr-non-blocking-interrupt\" fn()`.\n     (active, abi_avr_interrupt, \"1.45.0\", Some(69664), None),\n \n+    /// Be more precise when looking for live drops in a const context.\n+    (active, const_precise_live_drops, \"1.46.0\", Some(73255), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "1361d5bede63bcb0b863ee9be66e56f47c7c30d1", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -455,7 +455,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n                     None => format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    Some(DesugaringKind::ForLoop) => {\n+                    Some(DesugaringKind::ForLoop(_)) => {\n                         \"the element type for this iterator is not specified\".to_string()\n                     }\n                     _ => format!(\"this needs {}\", suffix),"}, {"sha": "1ed9bc3f1f509d0ac20144cf5cb5246a7ee282d3", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -847,7 +847,11 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n \n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n-            mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n+            mir::transform::check_unsafety::check_unsafety(tcx, def_id);\n+\n+            if tcx.hir().body_const_context(def_id).is_some() {\n+                tcx.ensure().mir_drops_elaborated_and_const_checked(def_id);\n+            }\n         }\n     });\n "}, {"sha": "edde82c40fbf4dbadfeefaae93a266f884006134", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1315,13 +1315,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Symbol] {\n+    fn get_fn_param_names(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) | EntryKind::ForeignFn(data) => data.decode(self).param_names,\n             EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,\n             _ => Lazy::empty(),\n         };\n-        tcx.arena.alloc_from_iter(param_names.decode(self))\n+        tcx.arena.alloc_from_iter(param_names.decode((self, tcx)))\n     }\n \n     fn exported_symbols("}, {"sha": "721b4254c8500ee4e7149862bacd7f22ea5d983e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n use rustc_session::config::CrateType;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n use rustc_target::abi::VariantIdx;\n use std::hash::Hash;\n@@ -994,18 +994,12 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n-    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Symbol]> {\n-        self.tcx.dep_graph.with_ignore(|| {\n-            let body = self.tcx.hir().body(body_id);\n-            self.lazy(body.params.iter().map(|arg| match arg.pat.kind {\n-                hir::PatKind::Binding(_, _, ident, _) => ident.name,\n-                _ => kw::Invalid,\n-            }))\n-        })\n+    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Ident]> {\n+        self.tcx.dep_graph.with_ignore(|| self.lazy(self.tcx.hir().body_param_names(body_id)))\n     }\n \n-    fn encode_fn_param_names(&mut self, param_names: &[Ident]) -> Lazy<[Symbol]> {\n-        self.lazy(param_names.iter().map(|ident| ident.name))\n+    fn encode_fn_param_names(&mut self, param_names: &[Ident]) -> Lazy<[Ident]> {\n+        self.lazy(param_names.iter())\n     }\n \n     fn encode_optimized_mir(&mut self, def_id: LocalDefId) {"}, {"sha": "ec80a2b6171edf7f2f5e65f9355fd8887c39bde5", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -19,7 +19,7 @@ use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::CrateDisambiguator;\n use rustc_span::edition::Edition;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, Span};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n \n@@ -326,7 +326,7 @@ struct ModData {\n struct FnData {\n     asyncness: hir::IsAsync,\n     constness: hir::Constness,\n-    param_names: Lazy<[Symbol]>,\n+    param_names: Lazy<[Ident]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "e3e0856ffc52ea5ac4f72ac536e43528cc0d2399", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n@@ -374,6 +374,13 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    pub fn body_param_names(&self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n+        self.body(id).params.iter().map(|arg| match arg.pat.kind {\n+            PatKind::Binding(_, _, ident, _) => ident,\n+            _ => Ident::new(kw::Invalid, rustc_span::DUMMY_SP),\n+        })\n+    }\n+\n     /// Returns the `BodyOwnerKind` of this `LocalDefId`.\n     ///\n     /// Panics if `LocalDefId` does not have an associated body."}, {"sha": "e152d11c081a12bb430fe39ca9432bc5f7680a39", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -12,10 +12,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n-use rustc_hir::Body;\n-use rustc_hir::HirId;\n-use rustc_hir::ItemLocalId;\n-use rustc_hir::Node;\n+use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n \n pub struct Owner<'tcx> {\n@@ -79,5 +76,20 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n+    providers.fn_arg_names = |tcx, id| {\n+        let hir = tcx.hir();\n+        let hir_id = hir.as_local_hir_id(id.expect_local());\n+        if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n+            tcx.arena.alloc_from_iter(hir.body_param_names(body_id))\n+        } else if let Node::TraitItem(&TraitItem {\n+            kind: TraitItemKind::Fn(_, TraitFn::Required(idents)),\n+            ..\n+        }) = hir.get(hir_id)\n+        {\n+            tcx.arena.alloc_slice(idents)\n+        } else {\n+            span_bug!(hir.span(hir_id), \"fn_arg_names: unexpected item {:?}\", id);\n+        }\n+    };\n     map::provide(providers);\n }"}, {"sha": "923119e359c4749c00556006bfcabb991969c816", "filename": "src/librustc_middle/lint.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flint.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -339,7 +339,9 @@ pub fn struct_lint_level<'s, 'd>(\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n-        ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n+        ExpnKind::Root\n+        | ExpnKind::Desugaring(DesugaringKind::ForLoop(_))\n+        | ExpnKind::Desugaring(DesugaringKind::Operator) => false,\n         ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             // Dummy span for the `def_site` means it's an external macro."}, {"sha": "21f5d9e7dd4c6b678467edff5b37a07f03f459ee", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -76,7 +76,8 @@ pub enum MirPhase {\n     Build = 0,\n     Const = 1,\n     Validated = 2,\n-    Optimized = 3,\n+    DropElab = 3,\n+    Optimized = 4,\n }\n \n impl MirPhase {"}, {"sha": "d82faf3e5fbaa4a89d4ece92bd233869a4faf12b", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -183,7 +183,7 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ConstraintCategory {\n-    Return,\n+    Return(ReturnConstraint),\n     Yield,\n     UseAsConst,\n     UseAsStatic,\n@@ -199,6 +199,7 @@ pub enum ConstraintCategory {\n     SizedBound,\n     Assignment,\n     OpaqueType,\n+    ClosureUpvar(hir::HirId),\n \n     /// A \"boring\" constraint (caused by the given location) is one that\n     /// the user probably doesn't want to see described in diagnostics,\n@@ -216,6 +217,13 @@ pub enum ConstraintCategory {\n     Internal,\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ReturnConstraint {\n+    Normal,\n+    ClosureUpvar(hir::HirId),\n+}\n+\n /// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n /// that must outlive some region.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "3b6d54a1bc1eed958e35888c4f4517e339b1e732", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -190,6 +190,12 @@ rustc_queries! {\n             no_hash\n         }\n \n+        query mir_drops_elaborated_and_const_checked(key: LocalDefId) -> Steal<mir::Body<'tcx>> {\n+            storage(ArenaCacheSelector<'tcx>)\n+            no_hash\n+            desc { |tcx| \"elaborating drops for `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n+\n         query mir_validated(key: LocalDefId) ->\n             (\n                 Steal<mir::Body<'tcx>>,\n@@ -700,7 +706,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query fn_arg_names(def_id: DefId) -> &'tcx [Symbol] {\n+        query fn_arg_names(def_id: DefId) -> &'tcx [rustc_span::symbol::Ident] {\n             desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n         }\n         /// Gets the rendered value of the specified constant or associated constant."}, {"sha": "2e897647a3beb18a32ca9638d881142cc5c0ca80", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 68, "deletions": 10, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -24,7 +24,8 @@ use crate::borrow_check::{\n };\n \n use super::{\n-    explain_borrow::BorrowExplanation, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    explain_borrow::BorrowExplanation, FnSelfUseKind, IncludingDowncast, RegionName,\n+    RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -150,13 +151,70 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n                     );\n                 } else {\n-                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                    move_spans.var_span_label(\n-                        &mut err,\n-                        format!(\"variable moved due to use{}\", move_spans.describe()),\n-                    );\n+                    if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } =\n+                        move_spans\n+                    {\n+                        let place_name = self\n+                            .describe_place(moved_place.as_ref())\n+                            .map(|n| format!(\"`{}`\", n))\n+                            .unwrap_or_else(|| \"value\".to_owned());\n+                        match kind {\n+                            FnSelfUseKind::FnOnceCall => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to this call\", place_name),\n+                                );\n+                                err.span_note(\n+                                    var_span,\n+                                    \"this value implements `FnOnce`, which causes it to be moved when called\",\n+                                );\n+                            }\n+                            FnSelfUseKind::Operator { self_arg } => {\n+                                err.span_label(\n+                                    fn_call_span,\n+                                    &format!(\"{} moved due to usage in operator\", place_name),\n+                                );\n+                                if self.fn_self_span_reported.insert(fn_span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        \"calling this operator moves the left-hand side\",\n+                                    );\n+                                }\n+                            }\n+                            FnSelfUseKind::Normal { self_arg, implicit_into_iter } => {\n+                                if implicit_into_iter {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\n+                                            \"{} moved due to this implicit call to `.into_iter()`\",\n+                                            place_name\n+                                        ),\n+                                    );\n+                                } else {\n+                                    err.span_label(\n+                                        fn_call_span,\n+                                        &format!(\"{} moved due to this method call\", place_name),\n+                                    );\n+                                }\n+                                // Avoid pointing to the same function in multiple different\n+                                // error messages\n+                                if self.fn_self_span_reported.insert(self_arg.span) {\n+                                    err.span_note(\n+                                        self_arg.span,\n+                                        &format!(\"this function consumes the receiver `self` by taking ownership of it, which moves {}\", place_name)\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                        move_spans.var_span_label(\n+                            &mut err,\n+                            format!(\"variable moved due to use{}\", move_spans.describe()),\n+                        );\n+                    }\n                 }\n-                if Some(DesugaringKind::ForLoop) == move_span.desugaring_kind() {\n+                if let Some(DesugaringKind::ForLoop(_)) = move_span.desugaring_kind() {\n                     let sess = self.infcx.tcx.sess;\n                     if let Ok(snippet) = sess.source_map().span_to_snippet(move_span) {\n                         err.span_suggestion(\n@@ -766,7 +824,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     category:\n                         category\n                         @\n-                        (ConstraintCategory::Return\n+                        (ConstraintCategory::Return(_)\n                         | ConstraintCategory::CallArgument\n                         | ConstraintCategory::OpaqueType),\n                     from_closure: false,\n@@ -1089,7 +1147,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         opt_place_desc: Option<&String>,\n     ) -> Option<DiagnosticBuilder<'cx>> {\n         let return_kind = match category {\n-            ConstraintCategory::Return => \"return\",\n+            ConstraintCategory::Return(_) => \"return\",\n             ConstraintCategory::Yield => \"yield\",\n             _ => return None,\n         };\n@@ -1203,7 +1261,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let msg = match category {\n-            ConstraintCategory::Return | ConstraintCategory::OpaqueType => {\n+            ConstraintCategory::Return(_) | ConstraintCategory::OpaqueType => {\n                 format!(\"{} is returned here\", kind)\n             }\n             ConstraintCategory::CallArgument => {"}, {"sha": "d04059ff0fc7ffc405a82505b7fe26462b338102", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -509,7 +509,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Used in a closure.\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n-            UseSpans::OtherUse(span) => {\n+            UseSpans::OtherUse(span) | UseSpans::FnSelfUse { var_span: span, .. } => {\n                 let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {"}, {"sha": "04f48cd65823054613daa1804218756a462b30bc", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 130, "deletions": 20, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -11,7 +11,11 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt};\n-use rustc_span::{symbol::sym, Span};\n+use rustc_span::{\n+    hygiene::{DesugaringKind, ForLoopLoc},\n+    symbol::sym,\n+    Span,\n+};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -33,6 +37,7 @@ crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n+use rustc_span::symbol::Ident;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -529,33 +534,58 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-// The span(s) associated to a use of a place.\n+/// The span(s) associated to a use of a place.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub(super) enum UseSpans {\n-    // The access is caused by capturing a variable for a closure.\n+    /// The access is caused by capturing a variable for a closure.\n     ClosureUse {\n-        // This is true if the captured variable was from a generator.\n+        /// This is true if the captured variable was from a generator.\n         generator_kind: Option<GeneratorKind>,\n-        // The span of the args of the closure, including the `move` keyword if\n-        // it's present.\n+        /// The span of the args of the closure, including the `move` keyword if\n+        /// it's present.\n         args_span: Span,\n-        // The span of the first use of the captured variable inside the closure.\n+        /// The span of the first use of the captured variable inside the closure.\n+        var_span: Span,\n+    },\n+    /// The access is caused by using a variable as the receiver of a method\n+    /// that takes 'self'\n+    FnSelfUse {\n+        /// The span of the variable being moved\n         var_span: Span,\n+        /// The span of the method call on the variable\n+        fn_call_span: Span,\n+        /// The definition span of the method being called\n+        fn_span: Span,\n+        kind: FnSelfUseKind,\n     },\n     // This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub(super) enum FnSelfUseKind {\n+    /// A normal method call of the form `receiver.foo(a, b, c)`\n+    Normal { self_arg: Ident, implicit_into_iter: bool },\n+    /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n+    FnOnceCall,\n+    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n+    Operator { self_arg: Ident },\n+}\n+\n impl UseSpans {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n-            UseSpans::ClosureUse { args_span: span, .. } | UseSpans::OtherUse(span) => span,\n+            UseSpans::ClosureUse { args_span: span, .. }\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n+            | UseSpans::OtherUse(span) => span,\n         }\n     }\n \n     pub(super) fn var_or_use(self) -> Span {\n         match self {\n-            UseSpans::ClosureUse { var_span: span, .. } | UseSpans::OtherUse(span) => span,\n+            UseSpans::ClosureUse { var_span: span, .. }\n+            | UseSpans::FnSelfUse { var_span: span, .. }\n+            | UseSpans::OtherUse(span) => span,\n         }\n     }\n \n@@ -624,6 +654,7 @@ impl UseSpans {\n     {\n         match self {\n             closure @ UseSpans::ClosureUse { .. } => closure,\n+            fn_self @ UseSpans::FnSelfUse { .. } => fn_self,\n             UseSpans::OtherUse(_) => if_other(),\n         }\n     }\n@@ -727,21 +758,100 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n         if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            let def_id = match kind {\n+            match kind {\n                 box AggregateKind::Closure(def_id, _)\n-                | box AggregateKind::Generator(def_id, _, _) => def_id,\n-                _ => return OtherUse(stmt.source_info.span),\n-            };\n-\n-            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-            if let Some((args_span, generator_kind, var_span)) =\n-                self.closure_span(*def_id, moved_place, places)\n-            {\n-                return ClosureUse { generator_kind, args_span, var_span };\n+                | box AggregateKind::Generator(def_id, _, _) => {\n+                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+                    if let Some((args_span, generator_kind, var_span)) =\n+                        self.closure_span(*def_id, moved_place, places)\n+                    {\n+                        return ClosureUse { generator_kind, args_span, var_span };\n+                    }\n+                }\n+                _ => {}\n             }\n         }\n \n-        OtherUse(stmt.source_info.span)\n+        let normal_ret = OtherUse(stmt.source_info.span);\n+\n+        // We are trying to find MIR of the form:\n+        // ```\n+        // _temp = _moved_val;\n+        // ...\n+        // FnSelfCall(_temp, ...)\n+        // ```\n+        //\n+        // where `_moved_val` is the place we generated the move error for,\n+        // `_temp` is some other local, and `FnSelfCall` is a function\n+        // that has a `self` parameter.\n+\n+        let target_temp = match stmt.kind {\n+            StatementKind::Assign(box (temp, _)) if temp.as_local().is_some() => {\n+                temp.as_local().unwrap()\n+            }\n+            _ => return normal_ret,\n+        };\n+\n+        debug!(\"move_spans: target_temp = {:?}\", target_temp);\n+\n+        if let Some(Terminator { kind: TerminatorKind::Call { func, args, fn_span, .. }, .. }) =\n+            &self.body[location.block].terminator\n+        {\n+            let mut method_did = None;\n+            if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n+                if let ty::FnDef(def_id, _) = ty.kind {\n+                    debug!(\"move_spans: fn = {:?}\", def_id);\n+                    if let Some(ty::AssocItem { fn_has_self_parameter, .. }) =\n+                        self.infcx.tcx.opt_associated_item(def_id)\n+                    {\n+                        if *fn_has_self_parameter {\n+                            method_did = Some(def_id);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            let tcx = self.infcx.tcx;\n+            let method_did = if let Some(did) = method_did { did } else { return normal_ret };\n+\n+            if let [Operand::Move(self_place), ..] = **args {\n+                if self_place.as_local() == Some(target_temp) {\n+                    let is_fn_once = tcx.parent(method_did) == tcx.lang_items().fn_once_trait();\n+                    let fn_call_span = *fn_span;\n+\n+                    let self_arg = tcx.fn_arg_names(method_did)[0];\n+\n+                    let kind = if is_fn_once {\n+                        FnSelfUseKind::FnOnceCall\n+                    } else if fn_call_span.is_desugaring(DesugaringKind::Operator) {\n+                        FnSelfUseKind::Operator { self_arg }\n+                    } else {\n+                        debug!(\n+                            \"move_spans: method_did={:?}, fn_call_span={:?}\",\n+                            method_did, fn_call_span\n+                        );\n+                        let implicit_into_iter = matches!(\n+                            fn_call_span.desugaring_kind(),\n+                            Some(DesugaringKind::ForLoop(ForLoopLoc::IntoIter))\n+                        );\n+                        FnSelfUseKind::Normal { self_arg, implicit_into_iter }\n+                    };\n+\n+                    return FnSelfUse {\n+                        var_span: stmt.source_info.span,\n+                        fn_call_span,\n+                        fn_span: self\n+                            .infcx\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .guess_head_span(self.infcx.tcx.def_span(method_did)),\n+                        kind,\n+                    };\n+                }\n+            }\n+        }\n+        return normal_ret;\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)"}, {"sha": "4883b08e424423a71265093c884a7d3e069d3476", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     format!(\"{}.as_ref()\", snippet),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if span.is_desugaring(DesugaringKind::ForLoop)\n+            } else if matches!(span.desugaring_kind(), Some(DesugaringKind::ForLoop(_)))\n                 && self.infcx.tcx.is_diagnostic_item(Symbol::intern(\"vec_type\"), def_id)\n             {\n                 // FIXME: suggest for anything that implements `IntoIterator`."}, {"sha": "b4bc89e827daa7010b7608ab5b68ee73abb8a98b", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -365,7 +365,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n                                 match opt_desugaring_kind {\n                                     // on for loops, RHS points to the iterator part\n-                                    Some(DesugaringKind::ForLoop) => Some((\n+                                    Some(DesugaringKind::ForLoop(_)) => Some((\n                                         false,\n                                         opt_assignment_rhs_span.unwrap(),\n                                         format!("}, {"sha": "f1923b9e81c66ab23f591e80d3ea07a7d402b051", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -5,9 +5,9 @@ use rustc_infer::infer::{\n     error_reporting::nice_region_error::NiceRegionError,\n     error_reporting::unexpected_hidden_region_diagnostic, NLLRegionVariableOrigin,\n };\n-use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n \n use crate::util::borrowck_errors;\n@@ -26,7 +26,7 @@ impl ConstraintDescription for ConstraintCategory {\n         // Must end with a space. Allows for empty names to be provided.\n         match self {\n             ConstraintCategory::Assignment => \"assignment \",\n-            ConstraintCategory::Return => \"returning this value \",\n+            ConstraintCategory::Return(_) => \"returning this value \",\n             ConstraintCategory::Yield => \"yielding this value \",\n             ConstraintCategory::UseAsConst => \"using this value as a constant \",\n             ConstraintCategory::UseAsStatic => \"using this value as a static \",\n@@ -37,6 +37,7 @@ impl ConstraintDescription for ConstraintCategory {\n             ConstraintCategory::SizedBound => \"proving this value is `Sized` \",\n             ConstraintCategory::CopyBound => \"copying this value \",\n             ConstraintCategory::OpaqueType => \"opaque type \",\n+            ConstraintCategory::ClosureUpvar(_) => \"closure capture \",\n             ConstraintCategory::Boring\n             | ConstraintCategory::BoringNoLocation\n             | ConstraintCategory::Internal => \"\",\n@@ -306,8 +307,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n \n         let diag = match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(fr) => {\n-                self.report_fnmut_error(&errci)\n+            (ConstraintCategory::Return(kind), true, false) if self.is_closure_fn_mut(fr) => {\n+                self.report_fnmut_error(&errci, kind)\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => {\n@@ -347,7 +348,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ///            executing...\n     ///    = note: ...therefore, returned references to captured variables will escape the closure\n     /// ```\n-    fn report_fnmut_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n+    fn report_fnmut_error(\n+        &self,\n+        errci: &ErrorConstraintInfo,\n+        kind: ReturnConstraint,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n         let mut diag = self\n@@ -356,19 +361,39 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             .sess\n             .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n-        // We should check if the return type of this closure is in fact a closure - in that\n-        // case, we can special case the error further.\n-        let return_type_is_closure =\n-            self.regioncx.universal_regions().unnormalized_output_ty.is_closure();\n-        let message = if return_type_is_closure {\n-            \"returns a closure that contains a reference to a captured variable, which then \\\n-             escapes the closure body\"\n-        } else {\n-            \"returns a reference to a captured variable which escapes the closure body\"\n+        let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n+        if let ty::Opaque(def_id, _) = output_ty.kind {\n+            output_ty = self.infcx.tcx.type_of(def_id)\n+        };\n+\n+        debug!(\"report_fnmut_error: output_ty={:?}\", output_ty);\n+\n+        let message = match output_ty.kind {\n+            ty::Closure(_, _) => {\n+                \"returns a closure that contains a reference to a captured variable, which then \\\n+                 escapes the closure body\"\n+            }\n+            ty::Adt(def, _) if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did) => {\n+                \"returns an `async` block that contains a reference to a captured variable, which then \\\n+                 escapes the closure body\"\n+            }\n+            _ => \"returns a reference to a captured variable which escapes the closure body\",\n         };\n \n         diag.span_label(*span, message);\n \n+        if let ReturnConstraint::ClosureUpvar(upvar) = kind {\n+            let def_id = match self.regioncx.universal_regions().defining_ty {\n+                DefiningTy::Closure(def_id, _) => def_id,\n+                ty @ _ => bug!(\"unexpected DefiningTy {:?}\", ty),\n+            };\n+\n+            let upvar_def_span = self.infcx.tcx.hir().span(upvar);\n+            let upvar_span = self.infcx.tcx.upvars_mentioned(def_id).unwrap()[&upvar].span;\n+            diag.span_label(upvar_def_span, \"variable defined here\");\n+            diag.span_label(upvar_span, \"variable captured here\");\n+        }\n+\n         match self.give_region_a_name(*outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n@@ -506,7 +531,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n-            (ConstraintCategory::Return, true, _) => {\n+            (ConstraintCategory::Return(_), true, _) => {\n                 diag.span_label(\n                     *span,\n                     format!("}, {"sha": "d099f48adc5c6312534cacd1b74001c90d9eb326", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -216,6 +216,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         &mut flow_inits,\n         &mdpe.move_data,\n         &borrow_set,\n+        &upvars,\n     );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n@@ -277,6 +278,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n+                fn_self_span_reported: Default::default(),\n                 locals_are_invalidated_at_exit,\n                 access_place_error_reported: Default::default(),\n                 reservation_error_reported: Default::default(),\n@@ -310,6 +312,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         location_table,\n         movable_generator,\n         locals_are_invalidated_at_exit,\n+        fn_self_span_reported: Default::default(),\n         access_place_error_reported: Default::default(),\n         reservation_error_reported: Default::default(),\n         reservation_warnings: Default::default(),\n@@ -486,6 +489,10 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     // but it is currently inconvenient to track down the `BorrowIndex`\n     // at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    /// This fields keeps track of the `Span`s that we have\n+    /// used to report extra information for `FnSelfUse`, to avoid\n+    /// unnecessarily verbose errors.\n+    fn_self_span_reported: FxHashSet<Span>,\n     /// Migration warnings to be reported for #56254. We delay reporting these\n     /// so that we can suppress the warning if there's a corresponding error\n     /// for the activation of the borrow.\n@@ -2308,30 +2315,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n     pub fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<Field> {\n-        let mut place_projection = place_ref.projection;\n-        let mut by_ref = false;\n-\n-        if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n-            place_projection = proj_base;\n-            by_ref = true;\n-        }\n-\n-        match place_projection {\n-            [base @ .., ProjectionElem::Field(field, _ty)] => {\n-                let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.local, base, self.body(), tcx).ty;\n-\n-                if (base_ty.is_closure() || base_ty.is_generator())\n-                    && (!by_ref || self.upvars[field.index()].by_ref)\n-                {\n-                    Some(*field)\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            _ => None,\n-        }\n+        path_utils::is_upvar_field_projection(self.infcx.tcx, &self.upvars, place_ref, self.body())\n     }\n }\n "}, {"sha": "ea68364be37a339aa4e60d8dcf4dbfa78cb97cc6", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -39,6 +39,7 @@ use crate::borrow_check::{\n     renumber,\n     type_check::{self, MirTypeckRegionConstraints, MirTypeckResults},\n     universal_regions::UniversalRegions,\n+    Upvar,\n };\n \n crate type PoloniusOutput = Output<RustcFacts>;\n@@ -166,6 +167,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n+    upvars: &[Upvar],\n ) -> NllOutput<'tcx> {\n     let mut all_facts = AllFacts::enabled(infcx.tcx).then_some(AllFacts::default());\n \n@@ -188,6 +190,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n             flow_inits,\n             move_data,\n             elements,\n+            upvars,\n         );\n \n     if let Some(all_facts) = &mut all_facts {"}, {"sha": "934729553a73be6588cc0f34b4b444cfd89d157e", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,10 +1,11 @@\n use crate::borrow_check::borrow_set::{BorrowData, BorrowSet, TwoPhaseActivation};\n use crate::borrow_check::places_conflict;\n use crate::borrow_check::AccessDepth;\n+use crate::borrow_check::Upvar;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::BorrowKind;\n-use rustc_middle::mir::{BasicBlock, Body, Location, Place};\n+use rustc_middle::mir::{BasicBlock, Body, Field, Location, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::TyCtxt;\n \n /// Returns `true` if the borrow represented by `kind` is\n@@ -135,3 +136,38 @@ pub(super) fn borrow_of_local_data(place: Place<'_>) -> bool {\n     // Any errors will be caught on the initial borrow\n     !place.is_indirect()\n }\n+\n+/// If `place` is a field projection, and the field is being projected from a closure type,\n+/// then returns the index of the field being projected. Note that this closure will always\n+/// be `self` in the current MIR, because that is the only time we directly access the fields\n+/// of a closure type.\n+pub(crate) fn is_upvar_field_projection(\n+    tcx: TyCtxt<'tcx>,\n+    upvars: &[Upvar],\n+    place_ref: PlaceRef<'tcx>,\n+    body: &Body<'tcx>,\n+) -> Option<Field> {\n+    let mut place_projection = place_ref.projection;\n+    let mut by_ref = false;\n+\n+    if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n+        place_projection = proj_base;\n+        by_ref = true;\n+    }\n+\n+    match place_projection {\n+        [base @ .., ProjectionElem::Field(field, _ty)] => {\n+            let base_ty = Place::ty_from(place_ref.local, base, body, tcx).ty;\n+\n+            if (base_ty.is_closure() || base_ty.is_generator())\n+                && (!by_ref || upvars[field.index()].by_ref)\n+            {\n+                Some(*field)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        _ => None,\n+    }\n+}"}, {"sha": "3e459bd52f75728838147bd09a77246c67b56c7f", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound}\n use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location,\n+    ConstraintCategory, Local, Location, ReturnConstraint,\n };\n use rustc_middle::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n@@ -2017,7 +2017,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     | ConstraintCategory::BoringNoLocation\n                     | ConstraintCategory::Internal => false,\n                     ConstraintCategory::TypeAnnotation\n-                    | ConstraintCategory::Return\n+                    | ConstraintCategory::Return(_)\n                     | ConstraintCategory::Yield => true,\n                     _ => constraint_sup_scc != target_scc,\n                 }\n@@ -2042,14 +2042,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n-                if categorized_path[i].0 == ConstraintCategory::Return\n+                if matches!(categorized_path[i].0, ConstraintCategory::Return(_))\n                     && next.0 == ConstraintCategory::OpaqueType\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n                     return *next;\n                 }\n             }\n+\n+            if categorized_path[i].0 == ConstraintCategory::Return(ReturnConstraint::Normal) {\n+                let field = categorized_path.iter().find_map(|p| {\n+                    if let ConstraintCategory::ClosureUpvar(f) = p.0 { Some(f) } else { None }\n+                });\n+\n+                if let Some(field) = field {\n+                    categorized_path[i].0 =\n+                        ConstraintCategory::Return(ReturnConstraint::ClosureUpvar(field));\n+                }\n+            }\n+\n             return categorized_path[i];\n         }\n "}, {"sha": "168612f9beec06f76832a1da662359a4cecedef8", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -55,13 +55,15 @@ use crate::borrow_check::{\n     location::LocationTable,\n     member_constraints::MemberConstraintSet,\n     nll::ToRegionVid,\n+    path_utils,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n     },\n     region_infer::{ClosureRegionRequirementsExt, TypeTest},\n     renumber,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n+    Upvar,\n };\n \n macro_rules! span_mirbug {\n@@ -132,6 +134,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n+    upvars: &[Upvar],\n ) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n@@ -162,6 +165,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         borrow_set,\n         all_facts,\n         constraints: &mut constraints,\n+        upvars,\n     };\n \n     let opaque_type_values = type_check_internal(\n@@ -577,7 +581,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = *constraint;\n             constraint.locations = locations;\n-            if let ConstraintCategory::Return\n+            if let ConstraintCategory::Return(_)\n             | ConstraintCategory::UseAsConst\n             | ConstraintCategory::UseAsStatic = constraint.category\n             {\n@@ -827,6 +831,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n     all_facts: &'a mut Option<AllFacts>,\n     borrow_set: &'a BorrowSet<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n+    upvars: &'a [Upvar],\n }\n \n crate struct MirTypeckResults<'tcx> {\n@@ -1420,7 +1425,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ConstraintCategory::UseAsConst\n                             }\n                         } else {\n-                            ConstraintCategory::Return\n+                            ConstraintCategory::Return(ReturnConstraint::Normal)\n                         }\n                     }\n                     Some(l) if !body.local_decls[l].is_user_variable() => {\n@@ -1703,7 +1708,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ConstraintCategory::UseAsConst\n                             }\n                         } else {\n-                            ConstraintCategory::Return\n+                            ConstraintCategory::Return(ReturnConstraint::Normal)\n                         }\n                     }\n                     Some(l) if !body.local_decls[l].is_user_variable() => {\n@@ -2489,14 +2494,26 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n \n         let mut cursor = borrowed_place.projection.as_ref();\n+        let tcx = self.infcx.tcx;\n+        let field = path_utils::is_upvar_field_projection(\n+            tcx,\n+            &self.borrowck_context.upvars,\n+            borrowed_place.as_ref(),\n+            body,\n+        );\n+        let category = if let Some(field) = field {\n+            ConstraintCategory::ClosureUpvar(self.borrowck_context.upvars[field.index()].var_hir_id)\n+        } else {\n+            ConstraintCategory::Boring\n+        };\n+\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n \n             debug!(\"add_reborrow_constraint - iteration {:?}\", elem);\n \n             match elem {\n                 ProjectionElem::Deref => {\n-                    let tcx = self.infcx.tcx;\n                     let base_ty = Place::ty_from(borrowed_place.local, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n@@ -2506,7 +2523,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 sup: ref_region.to_region_vid(),\n                                 sub: borrow_region.to_region_vid(),\n                                 locations: location.to_locations(),\n-                                category: ConstraintCategory::Boring,\n+                                category,\n                             });\n \n                             match mutbl {"}, {"sha": "e4aa88e3c20a7d611c218c4a74e94cb05b21a891", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::ty::{self, TyCtxt};\n pub use self::qualifs::Qualif;\n \n mod ops;\n+pub mod post_drop_elaboration;\n pub mod qualifs;\n mod resolver;\n pub mod validation;"}, {"sha": "d5059c98c9511053c4c14f9eb44f19ae421a3d7d", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -10,6 +10,22 @@ use rustc_span::{Span, Symbol};\n \n use super::ConstCx;\n \n+/// Emits an error if `op` is not allowed in the given const context.\n+pub fn non_const<O: NonConstOp>(ccx: &ConstCx<'_, '_>, op: O, span: Span) {\n+    debug!(\"illegal_op: op={:?}\", op);\n+\n+    if op.is_allowed_in_item(ccx) {\n+        return;\n+    }\n+\n+    if ccx.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+        ccx.tcx.sess.miri_unleashed_feature(span, O::feature_gate());\n+        return;\n+    }\n+\n+    op.emit_error(ccx, span);\n+}\n+\n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n     /// Returns the `Symbol` corresponding to the feature gate that would enable this operation,"}, {"sha": "226e0e2049ebd62a47818d324586309529c68650", "filename": "src/librustc_mir/transform/check_consts/post_drop_elaboration.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,119 @@\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::{self, BasicBlock, Location};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::Span;\n+\n+use super::ops;\n+use super::qualifs::{NeedsDrop, Qualif};\n+use super::validation::Qualifs;\n+use super::ConstCx;\n+\n+/// Returns `true` if we should use the more precise live drop checker that runs after drop\n+/// elaboration.\n+pub fn checking_enabled(tcx: TyCtxt<'tcx>) -> bool {\n+    tcx.features().const_precise_live_drops\n+}\n+\n+/// Look for live drops in a const context.\n+///\n+/// This is separate from the rest of the const checking logic because it must run after drop\n+/// elaboration.\n+pub fn check_live_drops(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &mir::Body<'tcx>) {\n+    let const_kind = tcx.hir().body_const_context(def_id);\n+    if const_kind.is_none() {\n+        return;\n+    }\n+\n+    if !checking_enabled(tcx) {\n+        return;\n+    }\n+\n+    let ccx = ConstCx {\n+        body,\n+        tcx,\n+        def_id: def_id.to_def_id(),\n+        const_kind,\n+        param_env: tcx.param_env(def_id),\n+    };\n+\n+    let mut visitor = CheckLiveDrops { ccx: &ccx, qualifs: Qualifs::default() };\n+\n+    visitor.visit_body(body);\n+}\n+\n+struct CheckLiveDrops<'mir, 'tcx> {\n+    ccx: &'mir ConstCx<'mir, 'tcx>,\n+    qualifs: Qualifs<'mir, 'tcx>,\n+}\n+\n+// So we can access `body` and `tcx`.\n+impl std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n+    type Target = ConstCx<'mir, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.ccx\n+    }\n+}\n+\n+impl CheckLiveDrops<'mir, 'tcx> {\n+    fn check_live_drop(&self, span: Span) {\n+        ops::non_const(self.ccx, ops::LiveDrop, span);\n+    }\n+}\n+\n+impl Visitor<'tcx> for CheckLiveDrops<'mir, 'tcx> {\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, block: &mir::BasicBlockData<'tcx>) {\n+        trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n+\n+        // Ignore drop terminators in cleanup blocks.\n+        if block.is_cleanup {\n+            return;\n+        }\n+\n+        self.super_basic_block_data(bb, block);\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n+\n+        match &terminator.kind {\n+            mir::TerminatorKind::Drop { location: dropped_place, .. } => {\n+                let dropped_ty = dropped_place.ty(self.body, self.tcx).ty;\n+                if !NeedsDrop::in_any_value_of_ty(self.ccx, dropped_ty) {\n+                    return;\n+                }\n+\n+                if dropped_place.is_indirect() {\n+                    self.check_live_drop(terminator.source_info.span);\n+                    return;\n+                }\n+\n+                if self.qualifs.needs_drop(self.ccx, dropped_place.local, location) {\n+                    // Use the span where the dropped local was declared for the error.\n+                    let span = self.body.local_decls[dropped_place.local].source_info.span;\n+                    self.check_live_drop(span);\n+                }\n+            }\n+\n+            mir::TerminatorKind::DropAndReplace { .. } => span_bug!(\n+                terminator.source_info.span,\n+                \"`DropAndReplace` should be removed by drop elaboration\",\n+            ),\n+\n+            mir::TerminatorKind::Abort\n+            | mir::TerminatorKind::Call { .. }\n+            | mir::TerminatorKind::Assert { .. }\n+            | mir::TerminatorKind::FalseEdge { .. }\n+            | mir::TerminatorKind::FalseUnwind { .. }\n+            | mir::TerminatorKind::GeneratorDrop\n+            | mir::TerminatorKind::Goto { .. }\n+            | mir::TerminatorKind::InlineAsm { .. }\n+            | mir::TerminatorKind::Resume\n+            | mir::TerminatorKind::Return\n+            | mir::TerminatorKind::SwitchInt { .. }\n+            | mir::TerminatorKind::Unreachable\n+            | mir::TerminatorKind::Yield { .. } => {}\n+        }\n+    }\n+}"}, {"sha": "428a74bcdcbfba54599dbdf49723e40906ad5160", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -40,7 +40,7 @@ pub struct Qualifs<'mir, 'tcx> {\n }\n \n impl Qualifs<'mir, 'tcx> {\n-    fn indirectly_mutable(\n+    pub fn indirectly_mutable(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -68,7 +68,7 @@ impl Qualifs<'mir, 'tcx> {\n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n-    fn needs_drop(\n+    pub fn needs_drop(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -95,7 +95,7 @@ impl Qualifs<'mir, 'tcx> {\n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary.\n-    fn has_mut_interior(\n+    pub fn has_mut_interior(\n         &mut self,\n         ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n@@ -232,30 +232,15 @@ impl Validator<'mir, 'tcx> {\n         self.qualifs.in_return_place(self.ccx)\n     }\n \n-    /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n-    /// context.\n-    pub fn check_op_spanned<O>(&mut self, op: O, span: Span)\n-    where\n-        O: NonConstOp,\n-    {\n-        debug!(\"check_op: op={:?}\", op);\n-\n-        if op.is_allowed_in_item(self) {\n-            return;\n-        }\n-\n-        if self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-            self.tcx.sess.miri_unleashed_feature(span, O::feature_gate());\n-            return;\n-        }\n-\n-        op.emit_error(self, span);\n-    }\n-\n     /// Emits an error if an expression cannot be evaluated in the current context.\n     pub fn check_op(&mut self, op: impl NonConstOp) {\n-        let span = self.span;\n-        self.check_op_spanned(op, span)\n+        ops::non_const(self.ccx, op, self.span);\n+    }\n+\n+    /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n+    /// context.\n+    pub fn check_op_spanned(&mut self, op: impl NonConstOp, span: Span) {\n+        ops::non_const(self.ccx, op, span);\n     }\n \n     fn check_static(&mut self, def_id: DefId, span: Span) {\n@@ -577,6 +562,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             // projections that cannot be `NeedsDrop`.\n             TerminatorKind::Drop { location: dropped_place, .. }\n             | TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+                // If we are checking live drops after drop-elaboration, don't emit duplicate\n+                // errors here.\n+                if super::post_drop_elaboration::checking_enabled(self.tcx) {\n+                    return;\n+                }\n+\n                 let mut err_span = self.span;\n \n                 // Check to see if the type of this place can ever have a drop impl. If not, this"}, {"sha": "72db35de408c67cb84d81731e726bde9ad9c9895", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -511,6 +511,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // This is basically `force_bits`.\n             let r_bits = r_bits.and_then(|r| r.to_bits_or_ptr(right_size, &self.tcx).ok());\n             if r_bits.map_or(false, |b| b >= left_size_bits as u128) {\n+                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n                     source_info,"}, {"sha": "4240b528a6124c2be08d34ddcbb8ad0b55466b19", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -49,6 +49,7 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n         mir_const,\n         mir_const_qualif,\n         mir_validated,\n+        mir_drops_elaborated_and_const_checked,\n         optimized_mir,\n         is_mir_available,\n         promoted_mir,\n@@ -294,12 +295,31 @@ fn mir_validated(\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n \n-fn run_optimization_passes<'tcx>(\n+fn mir_drops_elaborated_and_const_checked<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> Steal<Body<'tcx>> {\n+    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n+    // execute before we can steal.\n+    tcx.ensure().mir_borrowck(def_id);\n+\n+    let (body, _) = tcx.mir_validated(def_id);\n+    let mut body = body.steal();\n+\n+    run_post_borrowck_cleanup_passes(tcx, &mut body, def_id, None);\n+    check_consts::post_drop_elaboration::check_live_drops(tcx, def_id, &body);\n+    tcx.alloc_steal_mir(body)\n+}\n+\n+/// After this series of passes, no lifetime analysis based on borrowing can be done.\n+fn run_post_borrowck_cleanup_passes<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     def_id: LocalDefId,\n     promoted: Option<Promoted>,\n ) {\n+    debug!(\"post_borrowck_cleanup({:?})\", def_id);\n+\n     let post_borrowck_cleanup: &[&dyn MirPass<'tcx>] = &[\n         // Remove all things only needed by analysis\n         &no_landing_pads::NoLandingPads::new(tcx),\n@@ -318,9 +338,24 @@ fn run_optimization_passes<'tcx>(\n         // but before optimizations begin.\n         &add_retag::AddRetag,\n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n-        // No lifetime analysis based on borrowing can be done from here on out.\n     ];\n \n+    run_passes(\n+        tcx,\n+        body,\n+        InstanceDef::Item(def_id.to_def_id()),\n+        promoted,\n+        MirPhase::DropElab,\n+        &[post_borrowck_cleanup],\n+    );\n+}\n+\n+fn run_optimization_passes<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    def_id: LocalDefId,\n+    promoted: Option<Promoted>,\n+) {\n     let optimizations: &[&dyn MirPass<'tcx>] = &[\n         &unreachable_prop::UnreachablePropagation,\n         &uninhabited_enum_branching::UninhabitedEnumBranching,\n@@ -368,14 +403,14 @@ fn run_optimization_passes<'tcx>(\n \n     let mir_opt_level = tcx.sess.opts.debugging_opts.mir_opt_level;\n \n+    #[rustfmt::skip]\n     run_passes(\n         tcx,\n         body,\n         InstanceDef::Item(def_id.to_def_id()),\n         promoted,\n         MirPhase::Optimized,\n         &[\n-            post_borrowck_cleanup,\n             if mir_opt_level > 0 { optimizations } else { no_optimizations },\n             pre_codegen_cleanup,\n         ],\n@@ -393,12 +428,7 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n \n     let def_id = def_id.expect_local();\n \n-    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n-    // execute before we can steal.\n-    tcx.ensure().mir_borrowck(def_id);\n-\n-    let (body, _) = tcx.mir_validated(def_id);\n-    let mut body = body.steal();\n+    let mut body = tcx.mir_drops_elaborated_and_const_checked(def_id).steal();\n     run_optimization_passes(tcx, &mut body, def_id, None);\n \n     debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n@@ -418,6 +448,7 @@ fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> IndexVec<Promoted, Body<'_>>\n     let mut promoted = promoted.steal();\n \n     for (p, mut body) in promoted.iter_enumerated_mut() {\n+        run_post_borrowck_cleanup_passes(tcx, &mut body, def_id, Some(p));\n         run_optimization_passes(tcx, &mut body, def_id, Some(p));\n     }\n "}, {"sha": "4a4de6c420bd80d86b472f26dcb40af7ef533e13", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 271, "deletions": 271, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,274 +1,274 @@\n-/// Note: most of the tests relevant to this file can be found (at the time of writing) in\n-/// src/tests/ui/pattern/usefulness.\n-///\n-/// This file includes the logic for exhaustiveness and usefulness checking for\n-/// pattern-matching. Specifically, given a list of patterns for a type, we can\n-/// tell whether:\n-/// (a) the patterns cover every possible constructor for the type [exhaustiveness]\n-/// (b) each pattern is necessary [usefulness]\n-///\n-/// The algorithm implemented here is a modified version of the one described in:\n-/// http://moscova.inria.fr/~maranget/papers/warn/index.html\n-/// However, to save future implementors from reading the original paper, we\n-/// summarise the algorithm here to hopefully save time and be a little clearer\n-/// (without being so rigorous).\n-///\n-/// # Premise\n-///\n-/// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-/// are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n-/// a matrix). `U(P, p)` represents whether, given an existing list of patterns\n-/// `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n-/// uncovered values of the type).\n-///\n-/// If we have this predicate, then we can easily compute both exhaustiveness of an\n-/// entire set of patterns and the individual usefulness of each one.\n-/// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n-/// match doesn't increase the number of values we're matching)\n-/// (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n-/// pattern to those that have come before it doesn't increase the number of values\n-/// we're matching).\n-///\n-/// # Core concept\n-///\n-/// The idea that powers everything that is done in this file is the following: a value is made\n-/// from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n-/// (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n-/// constructor for the number `2`). Fields are just a (possibly empty) list of values.\n-///\n-/// Some of the constructors listed above might feel weird: `None` and `2` don't take any\n-/// arguments. This is part of what makes constructors so general: we will consider plain values\n-/// like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n-/// constructors\"; they are the simplest case of constructors. This allows us to see any value as\n-/// made up from a tree of constructors, each having a given number of children. For example:\n-/// `(None, Ok(0))` is made from 4 different constructors.\n-///\n-/// This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n-/// describe this set using constructors. For example, `Err(_)` captures all values of the type\n-/// `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n-/// wildcard `_` captures all values of the given type starting with any of the constructors for\n-/// that type.\n-///\n-/// We use this to compute whether different patterns might capture a same value. Do the patterns\n-/// `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n-/// captures only values starting with the `Ok` constructor and the second only values starting\n-/// with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n-/// since they both capture values starting with `Some`. To be certain, we need to dig under the\n-/// `Some` constructor and continue asking the question. This is the main idea behind the\n-/// exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n-/// figure out if some new pattern might capture a value that hadn't been captured by previous\n-/// patterns.\n-///\n-/// Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n-/// Most of the complexity of this file resides in transforming between patterns and\n-/// (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n-///\n-/// Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n-/// a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n-/// However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n-///\n-///\n-/// # Algorithm\n-///\n-/// Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n-/// adding a new pattern `p` will cover previously-uncovered values of the type.\n-/// During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-/// but rather partially-deconstructed patterns in the form of a list of fields. The paper\n-/// calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n-/// new pattern `p`.\n-///\n-/// For example, say we have the following:\n-/// ```\n-///     // x: (Option<bool>, Result<()>)\n-///     match x {\n-///         (Some(true), _) => {}\n-///         (None, Err(())) => {}\n-///         (None, Err(_)) => {}\n-///     }\n-/// ```\n-/// Here, the matrix `P` starts as:\n-/// [\n-///     [(Some(true), _)],\n-///     [(None, Err(()))],\n-///     [(None, Err(_))],\n-/// ]\n-/// We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-/// `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n-/// all the values it covers are already covered by row 2.\n-///\n-/// A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n-/// the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n-/// To match the paper, the top of the stack is at the beginning / on the left.\n-///\n-/// There are two important operations on pattern-stacks necessary to understand the algorithm:\n-///     1. We can pop a given constructor off the top of a stack. This operation is called\n-///        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-///        `None`) and `p` a pattern-stack.\n-///        If the pattern on top of the stack can cover `c`, this removes the constructor and\n-///        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-///        Otherwise the pattern-stack is discarded.\n-///        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-///        discards the others.\n-///\n-///        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-///        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-///        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-///        nothing back.\n-///\n-///        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-///        on top of the stack, and we have four cases:\n-///             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-///                  push onto the stack the arguments of this constructor, and return the result:\n-///                     r_1, .., r_a, p_2, .., p_n\n-///             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-///                  return nothing.\n-///             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-///                  arguments (its arity), and return the resulting stack:\n-///                     _, .., _, p_2, .., p_n\n-///             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-///                  stack:\n-///                     S(c, (r_1, p_2, .., p_n))\n-///                     S(c, (r_2, p_2, .., p_n))\n-///\n-///     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-///        a pattern-stack.\n-///        This is used when we know there are missing constructor cases, but there might be\n-///        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-///        all its *other* components.\n-///\n-///        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-///        and we have three cases:\n-///             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-///             1.2. `p_1 = _`. We return the rest of the stack:\n-///                     p_2, .., p_n\n-///             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-///               stack.\n-///                     D((r_1, p_2, .., p_n))\n-///                     D((r_2, p_2, .., p_n))\n-///\n-///     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-///     exhaustive integer matching rules, so they're written here for posterity.\n-///\n-/// Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n-/// working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n-/// the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n-///\n-///\n-/// The algorithm for computing `U`\n-/// -------------------------------\n-/// The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n-/// That means we're going to check the components from left-to-right, so the algorithm\n-/// operates principally on the first component of the matrix and new pattern-stack `p`.\n-/// This algorithm is realised in the `is_useful` function.\n-///\n-/// Base case. (`n = 0`, i.e., an empty tuple pattern)\n-///     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n-///       then `U(P, p)` is false.\n-///     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n-///\n-/// Inductive step. (`n > 0`, i.e., whether there's at least one column\n-///                  [which may then be expanded into further columns later])\n-///     We're going to match on the top of the new pattern-stack, `p_1`.\n-///         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-///           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-///           we ignore all the patterns in the first column of `P` that involve other constructors.\n-///           This is where `S(c, P)` comes in:\n-///           `U(P, p) := U(S(c, P), S(c, p))`\n-///           This special case is handled in `is_useful_specialized`.\n-///\n-///           For example, if `P` is:\n-///           [\n-///               [Some(true), _],\n-///               [None, 0],\n-///           ]\n-///           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n-///           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-///           arguments of `Some` to know whether some new value is covered. So we compute\n-///           `U([[true, _]], [false, 0])`.\n-///\n-///         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n-///               component of the rows of `P`:\n-///             + If there are some constructors that aren't present, then we might think that the\n-///               wildcard `_` is useful, since it covers those constructors that weren't covered\n-///               before.\n-///               That's almost correct, but only works if there were no wildcards in those first\n-///               components. So we need to check that `p` is useful with respect to the rows that\n-///               start with a wildcard, if there are any. This is where `D` comes in:\n-///               `U(P, p) := U(D(P), D(p))`\n-///\n-///               For example, if `P` is:\n-///               [\n-///                   [_, true, _],\n-///                   [None, false, 1],\n-///               ]\n-///               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n-///               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-///               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n-///\n-///             + Otherwise, all possible constructors (for the relevant type) are present. In this\n-///               case we must check whether the wildcard pattern covers any unmatched value. For\n-///               that, we can think of the `_` pattern as a big OR-pattern that covers all\n-///               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-///               example. The wildcard pattern is useful in this case if it is useful when\n-///               specialized to one of the possible constructors. So we compute:\n-///               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n-///\n-///               For example, if `P` is:\n-///               [\n-///                   [Some(true), _],\n-///                   [None, false],\n-///               ]\n-///               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n-///               components of `P`. We will therefore try popping both constructors in turn: we\n-///               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n-///               [false]) for the `None` constructor. The first case returns true, so we know that\n-///               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-///               before.\n-///\n-///         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-///           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n-///                    || U(P, (r_2, p_2, .., p_n))`\n-///\n-/// Modifications to the algorithm\n-/// ------------------------------\n-/// The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n-/// example uninhabited types and variable-length slice patterns. These are drawn attention to\n-/// throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n-/// accounted for, though.\n-///\n-/// Exhaustive integer matching\n-/// ---------------------------\n-/// An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n-/// So to support exhaustive integer matching, we can make use of the logic in the paper for\n-/// OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n-/// they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n-/// that we have a constructor *of* constructors (the integers themselves). We then need to work\n-/// through all the inductive step rules above, deriving how the ranges would be treated as\n-/// OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n-/// There are really only four special cases here:\n-/// - When we match on a constructor that's actually a range, we have to treat it as if we would\n-///   an OR-pattern.\n-///     + It turns out that we can simply extend the case for single-value patterns in\n-///      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n-///      constructor.\n-///     + When the pattern itself is a range, you just want to tell whether any of the values in\n-///       the pattern range coincide with values in the constructor range, which is precisely\n-///       intersection.\n-///   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n-///   means that whenever the constructor is a value/range and the pattern is also a value/range,\n-///   we can simply use intersection to test usefulness.\n-/// - When we're testing for usefulness of a pattern and the pattern's first component is a\n-///   wildcard.\n-///     + If all the constructors appear in the matrix, we have a slight complication. By default,\n-///       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n-///       invalid, because we want a disjunction over every *integer* in each range, not just a\n-///       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n-///       to form equivalence classes of subranges of the constructor range for which the behaviour\n-///       of the matrix `P` and new pattern `p` are the same. This is described in more\n-///       detail in `split_grouped_constructors`.\n-///     + If some constructors are missing from the matrix, it turns out we don't need to do\n-///       anything special (because we know none of the integers are actually wildcards: i.e., we\n-///       can't span wildcards using ranges).\n+//! Note: most of the tests relevant to this file can be found (at the time of writing) in\n+//! src/tests/ui/pattern/usefulness.\n+//!\n+//! This file includes the logic for exhaustiveness and usefulness checking for\n+//! pattern-matching. Specifically, given a list of patterns for a type, we can\n+//! tell whether:\n+//! (a) the patterns cover every possible constructor for the type [exhaustiveness]\n+//! (b) each pattern is necessary [usefulness]\n+//!\n+//! The algorithm implemented here is a modified version of the one described in:\n+//! http://moscova.inria.fr/~maranget/papers/warn/index.html\n+//! However, to save future implementors from reading the original paper, we\n+//! summarise the algorithm here to hopefully save time and be a little clearer\n+//! (without being so rigorous).\n+//!\n+//! # Premise\n+//!\n+//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n+//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n+//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n+//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n+//! uncovered values of the type).\n+//!\n+//! If we have this predicate, then we can easily compute both exhaustiveness of an\n+//! entire set of patterns and the individual usefulness of each one.\n+//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n+//! match doesn't increase the number of values we're matching)\n+//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n+//! pattern to those that have come before it doesn't increase the number of values\n+//! we're matching).\n+//!\n+//! # Core concept\n+//!\n+//! The idea that powers everything that is done in this file is the following: a value is made\n+//! from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n+//! (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n+//! constructor for the number `2`). Fields are just a (possibly empty) list of values.\n+//!\n+//! Some of the constructors listed above might feel weird: `None` and `2` don't take any\n+//! arguments. This is part of what makes constructors so general: we will consider plain values\n+//! like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n+//! constructors\"; they are the simplest case of constructors. This allows us to see any value as\n+//! made up from a tree of constructors, each having a given number of children. For example:\n+//! `(None, Ok(0))` is made from 4 different constructors.\n+//!\n+//! This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n+//! describe this set using constructors. For example, `Err(_)` captures all values of the type\n+//! `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n+//! wildcard `_` captures all values of the given type starting with any of the constructors for\n+//! that type.\n+//!\n+//! We use this to compute whether different patterns might capture a same value. Do the patterns\n+//! `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n+//! captures only values starting with the `Ok` constructor and the second only values starting\n+//! with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n+//! since they both capture values starting with `Some`. To be certain, we need to dig under the\n+//! `Some` constructor and continue asking the question. This is the main idea behind the\n+//! exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n+//! figure out if some new pattern might capture a value that hadn't been captured by previous\n+//! patterns.\n+//!\n+//! Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n+//! Most of the complexity of this file resides in transforming between patterns and\n+//! (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n+//!\n+//! Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n+//! a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n+//! However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n+//!\n+//!\n+//! # Algorithm\n+//!\n+//! Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n+//! adding a new pattern `p` will cover previously-uncovered values of the type.\n+//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n+//! but rather partially-deconstructed patterns in the form of a list of fields. The paper\n+//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n+//! new pattern `p`.\n+//!\n+//! For example, say we have the following:\n+//! ```\n+//!     // x: (Option<bool>, Result<()>)\n+//!     match x {\n+//!         (Some(true), _) => {}\n+//!         (None, Err(())) => {}\n+//!         (None, Err(_)) => {}\n+//!     }\n+//! ```\n+//! Here, the matrix `P` starts as:\n+//! [\n+//!     [(Some(true), _)],\n+//!     [(None, Err(()))],\n+//!     [(None, Err(_))],\n+//! ]\n+//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n+//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n+//! all the values it covers are already covered by row 2.\n+//!\n+//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n+//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n+//! To match the paper, the top of the stack is at the beginning / on the left.\n+//!\n+//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n+//!     1. We can pop a given constructor off the top of a stack. This operation is called\n+//!        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!        `None`) and `p` a pattern-stack.\n+//!        If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!        Otherwise the pattern-stack is discarded.\n+//!        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!        discards the others.\n+//!\n+//!        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!        nothing back.\n+//!\n+//!        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!        on top of the stack, and we have four cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!                  push onto the stack the arguments of this constructor, and return the result:\n+//!                     r_1, .., r_a, p_2, .., p_n\n+//!             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!                  return nothing.\n+//!             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!                  arguments (its arity), and return the resulting stack:\n+//!                     _, .., _, p_2, .., p_n\n+//!             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!                  stack:\n+//!                     S(c, (r_1, p_2, .., p_n))\n+//!                     S(c, (r_2, p_2, .., p_n))\n+//!\n+//!     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+//!        a pattern-stack.\n+//!        This is used when we know there are missing constructor cases, but there might be\n+//!        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!        all its *other* components.\n+//!\n+//!        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!        and we have three cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!             1.2. `p_1 = _`. We return the rest of the stack:\n+//!                     p_2, .., p_n\n+//!             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!               stack.\n+//!                     D((r_1, p_2, .., p_n))\n+//!                     D((r_2, p_2, .., p_n))\n+//!\n+//!     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//!     exhaustive integer matching rules, so they're written here for posterity.\n+//!\n+//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n+//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n+//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n+//!\n+//!\n+//! The algorithm for computing `U`\n+//! -------------------------------\n+//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n+//! That means we're going to check the components from left-to-right, so the algorithm\n+//! operates principally on the first component of the matrix and new pattern-stack `p`.\n+//! This algorithm is realised in the `is_useful` function.\n+//!\n+//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n+//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n+//!       then `U(P, p)` is false.\n+//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//!\n+//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n+//!                  [which may then be expanded into further columns later])\n+//!     We're going to match on the top of the new pattern-stack, `p_1`.\n+//!         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//!           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//!           we ignore all the patterns in the first column of `P` that involve other constructors.\n+//!           This is where `S(c, P)` comes in:\n+//!           `U(P, p) := U(S(c, P), S(c, p))`\n+//!           This special case is handled in `is_useful_specialized`.\n+//!\n+//!           For example, if `P` is:\n+//!           [\n+//!               [Some(true), _],\n+//!               [None, 0],\n+//!           ]\n+//!           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//!           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//!           arguments of `Some` to know whether some new value is covered. So we compute\n+//!           `U([[true, _]], [false, 0])`.\n+//!\n+//!         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+//!               component of the rows of `P`:\n+//!             + If there are some constructors that aren't present, then we might think that the\n+//!               wildcard `_` is useful, since it covers those constructors that weren't covered\n+//!               before.\n+//!               That's almost correct, but only works if there were no wildcards in those first\n+//!               components. So we need to check that `p` is useful with respect to the rows that\n+//!               start with a wildcard, if there are any. This is where `D` comes in:\n+//!               `U(P, p) := U(D(P), D(p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [_, true, _],\n+//!                   [None, false, 1],\n+//!               ]\n+//!               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//!               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//!               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//!\n+//!             + Otherwise, all possible constructors (for the relevant type) are present. In this\n+//!               case we must check whether the wildcard pattern covers any unmatched value. For\n+//!               that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//!               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//!               example. The wildcard pattern is useful in this case if it is useful when\n+//!               specialized to one of the possible constructors. So we compute:\n+//!               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [Some(true), _],\n+//!                   [None, false],\n+//!               ]\n+//!               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//!               components of `P`. We will therefore try popping both constructors in turn: we\n+//!               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n+//!               [false]) for the `None` constructor. The first case returns true, so we know that\n+//!               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//!               before.\n+//!\n+//!         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+//!           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!                    || U(P, (r_2, p_2, .., p_n))`\n+//!\n+//! Modifications to the algorithm\n+//! ------------------------------\n+//! The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n+//! example uninhabited types and variable-length slice patterns. These are drawn attention to\n+//! throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n+//! accounted for, though.\n+//!\n+//! Exhaustive integer matching\n+//! ---------------------------\n+//! An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n+//! So to support exhaustive integer matching, we can make use of the logic in the paper for\n+//! OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n+//! they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n+//! that we have a constructor *of* constructors (the integers themselves). We then need to work\n+//! through all the inductive step rules above, deriving how the ranges would be treated as\n+//! OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n+//! There are really only four special cases here:\n+//! - When we match on a constructor that's actually a range, we have to treat it as if we would\n+//!   an OR-pattern.\n+//!     + It turns out that we can simply extend the case for single-value patterns in\n+//!      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n+//!      constructor.\n+//!     + When the pattern itself is a range, you just want to tell whether any of the values in\n+//!       the pattern range coincide with values in the constructor range, which is precisely\n+//!       intersection.\n+//!   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n+//!   means that whenever the constructor is a value/range and the pattern is also a value/range,\n+//!   we can simply use intersection to test usefulness.\n+//! - When we're testing for usefulness of a pattern and the pattern's first component is a\n+//!   wildcard.\n+//!     + If all the constructors appear in the matrix, we have a slight complication. By default,\n+//!       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n+//!       invalid, because we want a disjunction over every *integer* in each range, not just a\n+//!       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n+//!       to form equivalence classes of subranges of the constructor range for which the behaviour\n+//!       of the matrix `P` and new pattern `p` are the same. This is described in more\n+//!       detail in `split_grouped_constructors`.\n+//!     + If some constructors are missing from the matrix, it turns out we don't need to do\n+//!       anything special (because we know none of the integers are actually wildcards: i.e., we\n+//!       can't span wildcards using ranges).\n use self::Constructor::*;\n use self::SliceKind::*;\n use self::Usefulness::*;"}, {"sha": "087c2c064cfaf3c57f4de92a1911f85905ff2b4b", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -130,6 +130,9 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     traits::NonStructuralMatchTy::Generator => {\n                         \"generators cannot be used in patterns\".to_string()\n                     }\n+                    traits::NonStructuralMatchTy::Closure => {\n+                        \"closures cannot be used in patterns\".to_string()\n+                    }\n                     traits::NonStructuralMatchTy::Param => {\n                         bug!(\"use of a constant whose type is a parameter inside a pattern\")\n                     }"}, {"sha": "f2c9f8055b9756d05a4435a9d61311a6ab0e3e3d", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -822,7 +822,15 @@ pub enum DesugaringKind {\n     OpaqueTy,\n     Async,\n     Await,\n-    ForLoop,\n+    ForLoop(ForLoopLoc),\n+    Operator,\n+}\n+\n+/// A location in the desugaring of a `for` loop\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+pub enum ForLoopLoc {\n+    Head,\n+    IntoIter,\n }\n \n impl DesugaringKind {\n@@ -835,7 +843,8 @@ impl DesugaringKind {\n             DesugaringKind::QuestionMark => \"operator `?`\",\n             DesugaringKind::TryBlock => \"`try` block\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n-            DesugaringKind::ForLoop => \"`for` loop\",\n+            DesugaringKind::ForLoop(_) => \"`for` loop\",\n+            DesugaringKind::Operator => \"operator\",\n         }\n     }\n }"}, {"sha": "af9b5a264e313d4bb689077aa285e46551901ec2", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -31,7 +31,9 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n use hygiene::Transparency;\n-pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, MacroKind, SyntaxContext};\n+pub use hygiene::{\n+    DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind, SyntaxContext,\n+};\n pub mod def_id;\n use def_id::{CrateNum, DefId, LOCAL_CRATE};\n mod span_encoding;"}, {"sha": "fdeb58b7b7a313608229ffa056b15e8caec96a81", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -227,6 +227,7 @@ symbols! {\n         const_loop,\n         const_mut_refs,\n         const_panic,\n+        const_precise_live_drops,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,\n         const_transmute,"}, {"sha": "c4deb639140ca3119191d60e7376e4526f70395c", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -18,6 +18,7 @@ pub enum NonStructuralMatchTy<'tcx> {\n     Opaque,\n     Generator,\n     Projection,\n+    Closure,\n }\n \n /// This method traverses the structure of `ty`, trying to find an\n@@ -162,6 +163,10 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 self.found = Some(NonStructuralMatchTy::Generator);\n                 return true; // Stop visiting.\n             }\n+            ty::Closure(..) => {\n+                self.found = Some(NonStructuralMatchTy::Closure);\n+                return true; // Stop visiting.\n+            }\n             ty::RawPtr(..) => {\n                 // structural-match ignores substructure of\n                 // `*const _`/`*mut _`, so skip `super_visit_with`.\n@@ -211,7 +216,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n                 ty.super_visit_with(self);\n                 return false;\n             }\n-            ty::Closure(..) | ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n+            ty::Infer(_) | ty::Placeholder(_) | ty::Bound(..) => {\n                 bug!(\"unexpected type during structural-match checking: {:?}\", ty);\n             }\n             ty::Error => {"}, {"sha": "37652330108c9b806cfa6a8657c41be8d03b6777", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -795,6 +795,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn assemble_inherent_candidates_from_param(&mut self, param_ty: ty::ParamTy) {\n         // FIXME: do we want to commit to this behavior for param bounds?\n+        debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n         let bounds =\n             self.param_env.caller_bounds.iter().filter_map(|predicate| match predicate.kind() {\n@@ -952,7 +953,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         import_ids: import_ids.clone(),\n                         kind: TraitCandidate(new_trait_ref),\n                     },\n-                    true,\n+                    false,\n                 );\n             });\n         } else {"}, {"sha": "842115538c9d85058e8b30cc754772f4bed4402a", "filename": "src/test/ui/async-await/issue-69446-fnmut-capture.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for issue #69446 - we should display\n+// which variable is captured\n+// edition:2018\n+\n+use core::future::Future;\n+\n+struct Foo;\n+impl Foo {\n+    fn foo(&mut self) {}\n+}\n+\n+async fn bar<T>(_: impl FnMut() -> T)\n+where\n+    T: Future<Output = ()>,\n+{}\n+\n+fn main() {\n+    let mut x = Foo;\n+    bar(move || async { //~ ERROR captured\n+        x.foo();\n+    });\n+}"}, {"sha": "3d2b0402bc52c614564988f0e53b8705b0691acf", "filename": "src/test/ui/async-await/issue-69446-fnmut-capture.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,19 @@\n+error: captured variable cannot escape `FnMut` closure body\n+  --> $DIR/issue-69446-fnmut-capture.rs:19:17\n+   |\n+LL |       let mut x = Foo;\n+   |           ----- variable defined here\n+LL |       bar(move || async {\n+   |  _______________-_^\n+   | |               |\n+   | |               inferred to be a `FnMut` closure\n+LL | |         x.foo();\n+   | |         - variable captured here\n+LL | |     });\n+   | |_____^ returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n+   |\n+   = note: `FnMut` closures only have access to their captured variables while they are executing...\n+   = note: ...therefore, they cannot allow references to captured variables to escape\n+\n+error: aborting due to previous error\n+"}, {"sha": "addc8a0efe1aa51c0cc1b9521507b2571a2a25ee", "filename": "src/test/ui/binop/binop-consume-args.stderr", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,10 +4,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs + rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn add<A: Add<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -35,10 +40,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs - rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn sub(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn sub<A: Sub<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -66,10 +76,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs * rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn mul(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn mul<A: Mul<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -97,10 +112,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs / rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn div(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn div<A: Div<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -128,10 +148,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs % rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn rem(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn rem<A: Rem<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -159,10 +184,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs & rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitand(self, rhs: Rhs) -> Self::Output;\n+   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitand<A: BitAnd<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -190,10 +220,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                     --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs | rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitor(self, rhs: Rhs) -> Self::Output;\n+   |              ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitor<A: BitOr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -221,10 +256,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs ^ rhs;\n-   |     --- value moved here\n+   |     --------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn bitxor(self, rhs: Rhs) -> Self::Output;\n+   |               ^^^^\n help: consider further restricting this bound\n    |\n LL | fn bitxor<A: BitXor<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -252,10 +292,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs << rhs;\n-   |     --- value moved here\n+   |     ---------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn shl(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shl<A: Shl<B, Output=()> + Copy, B>(lhs: A, rhs: B) {\n@@ -283,10 +328,15 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                 --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n LL |     lhs >> rhs;\n-   |     --- value moved here\n+   |     ---------- `lhs` moved due to usage in operator\n LL |     drop(lhs);\n    |          ^^^ value used here after move\n    |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn shr(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn shr<A: Shr<B, Output=()> + Copy, B>(lhs: A, rhs: B) {"}, {"sha": "97b70efe20e79d25d468c52c36e2f011b92e92cc", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,14 +1,21 @@\n error[E0382]: use of moved value: `x`\n   --> $DIR/binop-move-semantics.rs:8:5\n    |\n-LL | fn double_move<T: Add<Output=()>>(x: T) {\n-   |                                   - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n-LL |     x\n-   |     - value moved here\n-LL |     +\n-LL |     x;\n-   |     ^ value used here after move\n+LL |   fn double_move<T: Add<Output=()>>(x: T) {\n+   |                                     - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n+LL | /     x\n+LL | |     +\n+LL | |     x;\n+   | |     ^\n+   | |     |\n+   | |_____value used here after move\n+   |       `x` moved due to usage in operator\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n    |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn double_move<T: Add<Output=()> + Copy>(x: T) {"}, {"sha": "4144d70cc16012dd62579e8c6dcd34093e9a7ba0", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -21,10 +21,13 @@ LL |                    *y = 1;\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/borrowck-describe-lvalue.rs:264:16\n    |\n+LL |           let mut x = 0;\n+   |               ----- variable defined here\n LL |              || {\n    |               - inferred to be a `FnMut` closure\n LL | /                || {\n LL | |                    let y = &mut x;\n+   | |                                 - variable captured here\n LL | |                    &mut x;\n LL | |                    *y = 1;\n LL | |                    drop(y);"}, {"sha": "bc1721944fbbb6de8b7b1da9112928d3782de7fe", "filename": "src/test/ui/borrowck/borrowck-unboxed-closures.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -22,10 +22,15 @@ error[E0382]: use of moved value: `f`\n LL | fn c<F:FnOnce(isize, isize) -> isize>(f: F) {\n    |                                       - move occurs because `f` has type `F`, which does not implement the `Copy` trait\n LL |     f(1, 2);\n-   |     - value moved here\n+   |     ------- `f` moved due to this call\n LL |     f(1, 2);\n    |     ^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/borrowck-unboxed-closures.rs:11:5\n+   |\n+LL |     f(1, 2);\n+   |     ^\n help: consider further restricting this bound\n    |\n LL | fn c<F:FnOnce(isize, isize) -> isize + Copy>(f: F) {"}, {"sha": "896bb6dc6bee8a8cfca5c73ef4d84479b85f5bc6", "filename": "src/test/ui/closure_context/issue-42065.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure_context%2Fissue-42065.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `debug_dump_dict`\n   --> $DIR/issue-42065.rs:11:5\n    |\n LL |     debug_dump_dict();\n-   |     --------------- value moved here\n+   |     ----------------- `debug_dump_dict` moved due to this call\n LL |     debug_dump_dict();\n    |     ^^^^^^^^^^^^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `di\n    |\n LL |         for (key, value) in dict {\n    |                             ^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/issue-42065.rs:10:5\n+   |\n+LL |     debug_dump_dict();\n+   |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "614e69e89f6ec539a91349c44ddefc6371fd082e", "filename": "src/test/ui/codemap_tests/tab_3.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab_3.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,10 +4,16 @@ error[E0382]: borrow of moved value: `some_vec`\n LL |     let some_vec = vec![\"hi\"];\n    |         -------- move occurs because `some_vec` has type `std::vec::Vec<&str>`, which does not implement the `Copy` trait\n LL |     some_vec.into_iter();\n-   |     -------- value moved here\n+   |              ----------- `some_vec` moved due to this method call\n LL |     {\n LL |         println!(\"{:?}\", some_vec);\n    |                          ^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `some_vec`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b4b6be8a1e5f0c9ff37c94d45897f0259939ca7b", "filename": "src/test/ui/consts/control-flow/drop-fail.precise.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.precise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.precise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.precise.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,15 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/drop-fail.rs:10:9\n+   |\n+LL |     let x = Some(Vec::new());\n+   |         ^ constants cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/drop-fail.rs:41:9\n+   |\n+LL |     let mut tmp = None;\n+   |         ^^^^^^^ constants cannot evaluate destructors\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "7bd36726cead54238f57dc37ab308bc80765242b", "filename": "src/test/ui/consts/control-flow/drop-fail.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,11 +1,14 @@\n+// revisions: stock precise\n+\n #![feature(const_if_match)]\n #![feature(const_loop)]\n+#![cfg_attr(precise, feature(const_precise_live_drops))]\n \n-// `x` is *not* always moved into the final value may be dropped inside the initializer.\n+// `x` is *not* always moved into the final value and may be dropped inside the initializer.\n const _: Option<Vec<i32>> = {\n     let y: Option<Vec<i32>> = None;\n     let x = Some(Vec::new());\n-    //~^ ERROR destructors cannot be evaluated at compile-time\n+    //[stock,precise]~^ ERROR destructors cannot be evaluated at compile-time\n \n     if true {\n         x\n@@ -18,15 +21,15 @@ const _: Option<Vec<i32>> = {\n // existing analysis.\n const _: Vec<i32> = {\n     let vec_tuple = (Vec::new(),);\n-    //~^ ERROR destructors cannot be evaluated at compile-time\n+    //[stock]~^ ERROR destructors cannot be evaluated at compile-time\n \n     vec_tuple.0\n };\n \n // This applies to single-field enum variants as well.\n const _: Vec<i32> = {\n     let x: Result<_, Vec<i32>> = Ok(Vec::new());\n-    //~^ ERROR destructors cannot be evaluated at compile-time\n+    //[stock]~^ ERROR destructors cannot be evaluated at compile-time\n \n     match x {\n         Ok(x) | Err(x) => x,\n@@ -36,7 +39,7 @@ const _: Vec<i32> = {\n const _: Option<Vec<i32>> = {\n     let mut some = Some(Vec::new());\n     let mut tmp = None;\n-    //~^ ERROR destructors cannot be evaluated at compile-time\n+    //[stock,precise]~^ ERROR destructors cannot be evaluated at compile-time\n \n     let mut i = 0;\n     while i < 10 {", "previous_filename": "src/test/ui/consts/control-flow/drop-failure.rs"}, {"sha": "77cded5c438b5896b0bf4636bce6747da3b8a0bf", "filename": "src/test/ui/consts/control-flow/drop-fail.stock.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-fail.stock.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,23 +1,23 @@\n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/drop-failure.rs:7:9\n+  --> $DIR/drop-fail.rs:10:9\n    |\n LL |     let x = Some(Vec::new());\n    |         ^ constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/drop-failure.rs:20:9\n+  --> $DIR/drop-fail.rs:23:9\n    |\n LL |     let vec_tuple = (Vec::new(),);\n    |         ^^^^^^^^^ constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/drop-failure.rs:28:9\n+  --> $DIR/drop-fail.rs:31:9\n    |\n LL |     let x: Result<_, Vec<i32>> = Ok(Vec::new());\n    |         ^ constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/drop-failure.rs:38:9\n+  --> $DIR/drop-fail.rs:41:9\n    |\n LL |     let mut tmp = None;\n    |         ^^^^^^^ constants cannot evaluate destructors", "previous_filename": "src/test/ui/consts/control-flow/drop-failure.stderr"}, {"sha": "b0afd76c4e6ef9aae0eb15661543d014c5eda31d", "filename": "src/test/ui/consts/control-flow/drop-pass.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-pass.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,7 +1,9 @@\n // run-pass\n+// revisions: stock precise\n \n #![feature(const_if_match)]\n #![feature(const_loop)]\n+#![cfg_attr(precise, feature(const_precise_live_drops))]\n \n // `x` is always moved into the final value and is not dropped inside the initializer.\n const _: Option<Vec<i32>> = {", "previous_filename": "src/test/ui/consts/control-flow/drop-success.rs"}, {"sha": "95df76d9905546bf81f703cfdc61871c3cb960cc", "filename": "src/test/ui/consts/control-flow/drop-precise.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-precise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-precise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fdrop-precise.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,20 @@\n+// run-pass\n+// gate-test-const_precise_live_drops\n+\n+#![feature(const_if_match)]\n+#![feature(const_loop)]\n+#![feature(const_precise_live_drops)]\n+\n+const _: Vec<i32> = {\n+    let vec_tuple = (Vec::new(),);\n+    vec_tuple.0\n+};\n+\n+const _: Vec<i32> = {\n+    let x: Result<_, Vec<i32>> = Ok(Vec::new());\n+    match x {\n+        Ok(x) | Err(x) => x,\n+    }\n+};\n+\n+fn main() {}"}, {"sha": "064dc6c262c88462e64b6ce6ecfb36b5ff4a5e7e", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -6,14 +6,15 @@\n \n static CMP: () = {\n     let x = &0 as *const _;\n-    let _v = x == x;\n+    let _v = x == x; //~ NOTE in this\n     //~^ ERROR could not evaluate static initializer\n     //~| NOTE pointer arithmetic or comparison\n+    //~| NOTE in this\n };\n \n static INT_PTR_ARITH: () = unsafe {\n     let x: usize = std::mem::transmute(&0);\n-    let _v = x + 0;\n+    let _v = x + 0; //~ NOTE in this\n     //~^ ERROR could not evaluate static initializer\n     //~| NOTE pointer-to-integer cast\n };"}, {"sha": "4b3fe9957002e8f359116f6029328841ef67ae79", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -5,7 +5,7 @@ LL |     let _v = x == x;\n    |              ^^^^^^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:16:14\n+  --> $DIR/ptr_arith.rs:17:14\n    |\n LL |     let _v = x + 0;\n    |              ^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n@@ -18,7 +18,7 @@ help: skipping check for `const_compare_raw_pointers` feature\n LL |     let _v = x == x;\n    |              ^^^^^^\n help: skipping check that does not even have a feature gate\n-  --> $DIR/ptr_arith.rs:15:20\n+  --> $DIR/ptr_arith.rs:16:20\n    |\n LL |     let x: usize = std::mem::transmute(&0);\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "fc5ed724e3c67ff03139865769833af7cbfd68f6", "filename": "src/test/ui/hygiene/unpretty-debug.stdout", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -18,8 +18,12 @@ fn y /* 0#0 */() { }\n Expansions:\n 0: parent: ExpnId(0), call_site_ctxt: #0, kind: Root\n 1: parent: ExpnId(0), call_site_ctxt: #0, kind: Macro(Bang, \"foo\")\n+2: parent: ExpnId(0), call_site_ctxt: #1, kind: Desugaring(Operator)\n+3: parent: ExpnId(0), call_site_ctxt: #1, kind: Desugaring(Operator)\n \n SyntaxContexts:\n #0: parent: #0, outer_mark: (ExpnId(0), Opaque)\n #1: parent: #0, outer_mark: (ExpnId(1), SemiTransparent)\n+#2: parent: #1, outer_mark: (ExpnId(2), Transparent)\n+#3: parent: #1, outer_mark: (ExpnId(3), Transparent)\n */"}, {"sha": "fd8fe5f48dfa23aa1a2a1a050e6b84e43f53b896", "filename": "src/test/ui/impl-trait-in-bindings-issue-73003.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fimpl-trait-in-bindings-issue-73003.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fimpl-trait-in-bindings-issue-73003.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait-in-bindings-issue-73003.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+\n+#![feature(impl_trait_in_bindings)]\n+//~^ WARN the feature `impl_trait_in_bindings` is incomplete\n+\n+const _: impl Fn() = ||();\n+\n+fn main() {}"}, {"sha": "715671c8add834eee7f379d64fb6d6317ee70320", "filename": "src/test/ui/impl-trait-in-bindings-issue-73003.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fimpl-trait-in-bindings-issue-73003.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fimpl-trait-in-bindings-issue-73003.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait-in-bindings-issue-73003.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/impl-trait-in-bindings-issue-73003.rs:3:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #63065 <https://github.com/rust-lang/rust/issues/63065> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "b759aa45e3eb707d2a8074447cb22038cf2980bf", "filename": "src/test/ui/issues/issue-12127.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12127.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -2,10 +2,15 @@ error[E0382]: use of moved value: `f`\n   --> $DIR/issue-12127.rs:11:9\n    |\n LL |         f();\n-   |         - value moved here\n+   |         --- `f` moved due to this call\n LL |         f();\n    |         ^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/issue-12127.rs:10:9\n+   |\n+LL |         f();\n+   |         ^\n    = note: move occurs because `f` has type `[closure@$DIR/issue-12127.rs:8:24: 8:41 x:std::boxed::Box<isize>]`, which does not implement the `Copy` trait\n \n error: aborting due to previous error"}, {"sha": "4fb805b37e03f02330f2bc77637b0a231b539b80", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -3,4 +3,5 @@ use std::collections::HashMap;\n fn main() {\n     for _ in HashMap::new().iter().cloned() {} //~ ERROR type mismatch\n     //~^ ERROR type mismatch\n+    //~| ERROR type mismatch\n }"}, {"sha": "20335d2cdd684c6b6d681ce29790b4106a22c2fc", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -17,6 +17,16 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n            found reference `&_`\n    = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n \n-error: aborting due to 2 previous errors\n+error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as std::iter::Iterator>::Item == &_`\n+  --> $DIR/issue-33941.rs:4:14\n+   |\n+LL |     for _ in HashMap::new().iter().cloned() {}\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found reference\n+   |\n+   = note:  expected tuple `(&_, &_)`\n+           found reference `&_`\n+   = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::iter::Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "b4cc1a0aa7eb2bf5dd8fbdbc2c02d74094b714ce", "filename": "src/test/ui/issues/issue-34721.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -5,14 +5,19 @@ LL |     pub fn baz<T: Foo>(x: T) -> T {\n    |                        - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n LL |         if 0 == 1 {\n LL |             bar::bar(x.zero())\n-   |                      - value moved here\n+   |                        ------ `x` moved due to this method call\n LL |         } else {\n LL |             x.zero()\n-   |             - value moved here\n+   |               ------ `x` moved due to this method call\n LL |         };\n LL |         x.zero()\n    |         ^ value used here after move\n    |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $DIR/issue-34721.rs:4:13\n+   |\n+LL |     fn zero(self) -> Self;\n+   |             ^^^^\n help: consider further restricting this bound\n    |\n LL |     pub fn baz<T: Foo + Copy>(x: T) -> T {"}, {"sha": "54df40b6e3d05bda35530bfc79366ef51edd57d6", "filename": "src/test/ui/issues/issue-40510-1.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,10 +1,16 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/issue-40510-1.rs:7:9\n    |\n+LL |     let mut x: Box<()> = Box::new(());\n+   |         ----- variable defined here\n+LL | \n LL |     || {\n    |      - inferred to be a `FnMut` closure\n LL |         &mut x\n-   |         ^^^^^^ returns a reference to a captured variable which escapes the closure body\n+   |         ^^^^^-\n+   |         |    |\n+   |         |    variable captured here\n+   |         returns a reference to a captured variable which escapes the closure body\n    |\n    = note: `FnMut` closures only have access to their captured variables while they are executing...\n    = note: ...therefore, they cannot allow references to captured variables to escape"}, {"sha": "cb885ec7d952aa67802b6e4ade19a7c815f58072", "filename": "src/test/ui/issues/issue-40510-3.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,10 +1,14 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/issue-40510-3.rs:7:9\n    |\n+LL |       let mut x: Vec<()> = Vec::new();\n+   |           ----- variable defined here\n+LL | \n LL |       || {\n    |        - inferred to be a `FnMut` closure\n LL | /         || {\n LL | |             x.push(())\n+   | |             - variable captured here\n LL | |         }\n    | |_________^ returns a closure that contains a reference to a captured variable, which then escapes the closure body\n    |"}, {"sha": "2fec482543d7b410970857aa40ad1bbd5799e6a8", "filename": "src/test/ui/issues/issue-49824.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,11 +1,14 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/issue-49824.rs:4:9\n    |\n+LL |       let mut x = 0;\n+   |           ----- variable defined here\n LL |       || {\n    |        - inferred to be a `FnMut` closure\n LL | /         || {\n LL | |\n LL | |             let _y = &mut x;\n+   | |                           - variable captured here\n LL | |         }\n    | |_________^ returns a closure that contains a reference to a captured variable, which then escapes the closure body\n    |"}, {"sha": "ba43f2d33ee4463058c536652a9dab4aed06fa2e", "filename": "src/test/ui/issues/issue-61108.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -6,11 +6,17 @@ LL |     let mut bad_letters = vec!['e', 't', 'o', 'i'];\n LL |     for l in bad_letters {\n    |              -----------\n    |              |\n-   |              value moved here\n+   |              `bad_letters` moved due to this implicit call to `.into_iter()`\n    |              help: consider borrowing to avoid moving into the for loop: `&bad_letters`\n ...\n LL |     bad_letters.push('s');\n    |     ^^^^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `bad_letters`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2c337bae130171454088824186eee57106c70202", "filename": "src/test/ui/issues/issue-64559.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-64559.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -6,12 +6,18 @@ LL |     let orig = vec![true];\n LL |     for _val in orig {}\n    |                 ----\n    |                 |\n-   |                 value moved here\n+   |                 `orig` moved due to this implicit call to `.into_iter()`\n    |                 help: consider borrowing to avoid moving into the for loop: `&orig`\n LL |     let _closure = || orig;\n    |                    ^^ ---- use occurs due to use in closure\n    |                    |\n    |                    value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `orig`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "6107f53fa19606b20fcfa967a3401fb4cf2310f1", "filename": "src/test/ui/moves/move-fn-self-receiver.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,74 @@\n+use std::pin::Pin;\n+use std::rc::Rc;\n+use std::ops::Add;\n+\n+struct Foo;\n+\n+impl Add for Foo {\n+    type Output = ();\n+    fn add(self, _rhs: Self) -> () {}\n+}\n+\n+impl Foo {\n+    fn use_self(self) {}\n+    fn use_box_self(self: Box<Self>) {}\n+    fn use_pin_box_self(self: Pin<Box<Self>>) {}\n+    fn use_rc_self(self: Rc<Self>) {}\n+    fn use_mut_self(&mut self) -> &mut Self { self }\n+}\n+\n+struct Container(Vec<bool>);\n+\n+impl Container {\n+    fn custom_into_iter(self) -> impl Iterator<Item = bool> {\n+        self.0.into_iter()\n+    }\n+}\n+\n+fn move_out(val: Container) {\n+    val.0.into_iter().next();\n+    val.0; //~ ERROR use of moved\n+\n+    let foo = Foo;\n+    foo.use_self();\n+    foo; //~ ERROR use of moved\n+\n+    let second_foo = Foo;\n+    second_foo.use_self();\n+    second_foo; //~ ERROR use of moved\n+\n+    let boxed_foo = Box::new(Foo);\n+    boxed_foo.use_box_self();\n+    boxed_foo; //~ ERROR use of moved\n+\n+    let pin_box_foo = Box::pin(Foo);\n+    pin_box_foo.use_pin_box_self();\n+    pin_box_foo; //~ ERROR use of moved\n+\n+    let mut mut_foo = Foo;\n+    let ret = mut_foo.use_mut_self();\n+    mut_foo; //~ ERROR cannot move out\n+    ret;\n+\n+    let rc_foo = Rc::new(Foo);\n+    rc_foo.use_rc_self();\n+    rc_foo; //~ ERROR use of moved\n+\n+    let foo_add = Foo;\n+    foo_add + Foo;\n+    foo_add; //~ ERROR use of moved\n+\n+    let implicit_into_iter = vec![true];\n+    for _val in implicit_into_iter {}\n+    implicit_into_iter; //~ ERROR use of moved\n+\n+    let explicit_into_iter = vec![true];\n+    for _val in explicit_into_iter.into_iter() {}\n+    explicit_into_iter; //~ ERROR use of moved\n+\n+    let container = Container(vec![]);\n+    for _val in container.custom_into_iter() {}\n+    container; //~ ERROR use of moved\n+}\n+\n+fn main() {}"}, {"sha": "4333e8a23e866f408cbcbfab35992f4dd7bea440", "filename": "src/test/ui/moves/move-fn-self-receiver.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-fn-self-receiver.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,158 @@\n+error[E0382]: use of moved value: `val.0`\n+  --> $DIR/move-fn-self-receiver.rs:30:5\n+   |\n+LL |     val.0.into_iter().next();\n+   |           ----------- `val.0` moved due to this method call\n+LL |     val.0;\n+   |     ^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `val.0`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n+   = note: move occurs because `val.0` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `foo`\n+  --> $DIR/move-fn-self-receiver.rs:34:5\n+   |\n+LL |     let foo = Foo;\n+   |         --- move occurs because `foo` has type `Foo`, which does not implement the `Copy` trait\n+LL |     foo.use_self();\n+   |         ---------- `foo` moved due to this method call\n+LL |     foo;\n+   |     ^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `foo`\n+  --> $DIR/move-fn-self-receiver.rs:13:17\n+   |\n+LL |     fn use_self(self) {}\n+   |                 ^^^^\n+\n+error[E0382]: use of moved value: `second_foo`\n+  --> $DIR/move-fn-self-receiver.rs:38:5\n+   |\n+LL |     let second_foo = Foo;\n+   |         ---------- move occurs because `second_foo` has type `Foo`, which does not implement the `Copy` trait\n+LL |     second_foo.use_self();\n+   |                ---------- `second_foo` moved due to this method call\n+LL |     second_foo;\n+   |     ^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `boxed_foo`\n+  --> $DIR/move-fn-self-receiver.rs:42:5\n+   |\n+LL |     let boxed_foo = Box::new(Foo);\n+   |         --------- move occurs because `boxed_foo` has type `std::boxed::Box<Foo>`, which does not implement the `Copy` trait\n+LL |     boxed_foo.use_box_self();\n+   |               -------------- `boxed_foo` moved due to this method call\n+LL |     boxed_foo;\n+   |     ^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `boxed_foo`\n+  --> $DIR/move-fn-self-receiver.rs:14:21\n+   |\n+LL |     fn use_box_self(self: Box<Self>) {}\n+   |                     ^^^^\n+\n+error[E0382]: use of moved value: `pin_box_foo`\n+  --> $DIR/move-fn-self-receiver.rs:46:5\n+   |\n+LL |     let pin_box_foo = Box::pin(Foo);\n+   |         ----------- move occurs because `pin_box_foo` has type `std::pin::Pin<std::boxed::Box<Foo>>`, which does not implement the `Copy` trait\n+LL |     pin_box_foo.use_pin_box_self();\n+   |                 ------------------ `pin_box_foo` moved due to this method call\n+LL |     pin_box_foo;\n+   |     ^^^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `pin_box_foo`\n+  --> $DIR/move-fn-self-receiver.rs:15:25\n+   |\n+LL |     fn use_pin_box_self(self: Pin<Box<Self>>) {}\n+   |                         ^^^^\n+\n+error[E0505]: cannot move out of `mut_foo` because it is borrowed\n+  --> $DIR/move-fn-self-receiver.rs:50:5\n+   |\n+LL |     let ret = mut_foo.use_mut_self();\n+   |               ------- borrow of `mut_foo` occurs here\n+LL |     mut_foo;\n+   |     ^^^^^^^ move out of `mut_foo` occurs here\n+LL |     ret;\n+   |     --- borrow later used here\n+\n+error[E0382]: use of moved value: `rc_foo`\n+  --> $DIR/move-fn-self-receiver.rs:55:5\n+   |\n+LL |     let rc_foo = Rc::new(Foo);\n+   |         ------ move occurs because `rc_foo` has type `std::rc::Rc<Foo>`, which does not implement the `Copy` trait\n+LL |     rc_foo.use_rc_self();\n+   |            ------------- `rc_foo` moved due to this method call\n+LL |     rc_foo;\n+   |     ^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `rc_foo`\n+  --> $DIR/move-fn-self-receiver.rs:16:20\n+   |\n+LL |     fn use_rc_self(self: Rc<Self>) {}\n+   |                    ^^^^\n+\n+error[E0382]: use of moved value: `foo_add`\n+  --> $DIR/move-fn-self-receiver.rs:59:5\n+   |\n+LL |     let foo_add = Foo;\n+   |         ------- move occurs because `foo_add` has type `Foo`, which does not implement the `Copy` trait\n+LL |     foo_add + Foo;\n+   |     ------------- `foo_add` moved due to usage in operator\n+LL |     foo_add;\n+   |     ^^^^^^^ value used here after move\n+   |\n+note: calling this operator moves the left-hand side\n+  --> $SRC_DIR/libcore/ops/arith.rs:LL:COL\n+   |\n+LL |     fn add(self, rhs: Rhs) -> Self::Output;\n+   |            ^^^^\n+\n+error[E0382]: use of moved value: `implicit_into_iter`\n+  --> $DIR/move-fn-self-receiver.rs:63:5\n+   |\n+LL |     let implicit_into_iter = vec![true];\n+   |         ------------------ move occurs because `implicit_into_iter` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+LL |     for _val in implicit_into_iter {}\n+   |                 ------------------\n+   |                 |\n+   |                 `implicit_into_iter` moved due to this implicit call to `.into_iter()`\n+   |                 help: consider borrowing to avoid moving into the for loop: `&implicit_into_iter`\n+LL |     implicit_into_iter;\n+   |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `explicit_into_iter`\n+  --> $DIR/move-fn-self-receiver.rs:67:5\n+   |\n+LL |     let explicit_into_iter = vec![true];\n+   |         ------------------ move occurs because `explicit_into_iter` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n+LL |     for _val in explicit_into_iter.into_iter() {}\n+   |                                    ----------- `explicit_into_iter` moved due to this method call\n+LL |     explicit_into_iter;\n+   |     ^^^^^^^^^^^^^^^^^^ value used here after move\n+\n+error[E0382]: use of moved value: `container`\n+  --> $DIR/move-fn-self-receiver.rs:71:5\n+   |\n+LL |     let container = Container(vec![]);\n+   |         --------- move occurs because `container` has type `Container`, which does not implement the `Copy` trait\n+LL |     for _val in container.custom_into_iter() {}\n+   |                           ------------------ `container` moved due to this method call\n+LL |     container;\n+   |     ^^^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `container`\n+  --> $DIR/move-fn-self-receiver.rs:23:25\n+   |\n+LL |     fn custom_into_iter(self) -> impl Iterator<Item = bool> {\n+   |                         ^^^^\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors have detailed explanations: E0382, E0505.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "142feb280d153be2b8a94061d803d5e3cd5805e5", "filename": "src/test/ui/moves/moves-based-on-type-access-to-field.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-access-to-field.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,9 +4,15 @@ error[E0382]: borrow of moved value: `x`\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     consume(x.into_iter().next().unwrap());\n-   |             - value moved here\n+   |               ----------- `x` moved due to this method call\n LL |     touch(&x[0]);\n    |            ^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ff98aab50c9f82ec0bebf89288f1eeb8a2425973", "filename": "src/test/ui/moves/moves-based-on-type-exprs.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-exprs.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -104,19 +104,31 @@ error[E0382]: borrow of moved value: `x`\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = x.into_iter().next().unwrap();\n-   |              - value moved here\n+   |                ----------- `x` moved due to this method call\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/moves-based-on-type-exprs.rs:83:11\n    |\n LL |     let x = vec![\"hi\".to_string()];\n    |         - move occurs because `x` has type `std::vec::Vec<std::string::String>`, which does not implement the `Copy` trait\n LL |     let _y = [x.into_iter().next().unwrap(); 1];\n-   |               - value moved here\n+   |                 ----------- `x` moved due to this method call\n LL |     touch(&x);\n    |           ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/iter/traits/collect.rs:LL:COL\n+   |\n+LL |     fn into_iter(self) -> Self::IntoIter;\n+   |                  ^^^^\n \n error: aborting due to 11 previous errors\n "}, {"sha": "87ffe9b1abf456d26abc45aaa18a0902cf8bf2b1", "filename": "src/test/ui/nll/issue-53040.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fnll%2Fissue-53040.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fnll%2Fissue-53040.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53040.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,9 +1,13 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/issue-53040.rs:3:8\n    |\n+LL |     let mut v: Vec<()> = Vec::new();\n+   |         ----- variable defined here\n LL |     || &mut v;\n-   |      - ^^^^^^ returns a reference to a captured variable which escapes the closure body\n-   |      |\n+   |      - ^^^^^-\n+   |      | |    |\n+   |      | |    variable captured here\n+   |      | returns a reference to a captured variable which escapes the closure body\n    |      inferred to be a `FnMut` closure\n    |\n    = note: `FnMut` closures only have access to their captured variables while they are executing..."}, {"sha": "8761b5261d51bab1ebf7b6a2fd2cedcd6680df98", "filename": "src/test/ui/once-cant-call-twice-on-heap.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,10 +4,15 @@ error[E0382]: use of moved value: `blk`\n LL | fn foo<F:FnOnce()>(blk: F) {\n    |                    --- move occurs because `blk` has type `F`, which does not implement the `Copy` trait\n LL |     blk();\n-   |     --- value moved here\n+   |     ----- `blk` moved due to this call\n LL |     blk();\n    |     ^^^ value used here after move\n    |\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/once-cant-call-twice-on-heap.rs:8:5\n+   |\n+LL |     blk();\n+   |     ^^^\n help: consider further restricting this bound\n    |\n LL | fn foo<F:FnOnce() + Copy>(blk: F) {"}, {"sha": "b087e03b464b38586c017af38eeac10233991ac9", "filename": "src/test/ui/regions/regions-return-ref-to-upvar-issue-17403.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -1,9 +1,13 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:7:24\n    |\n+LL |         let mut x = 0;\n+   |             ----- variable defined here\n LL |         let mut f = || &mut x;\n-   |                      - ^^^^^^ returns a reference to a captured variable which escapes the closure body\n-   |                      |\n+   |                      - ^^^^^-\n+   |                      | |    |\n+   |                      | |    variable captured here\n+   |                      | returns a reference to a captured variable which escapes the closure body\n    |                      inferred to be a `FnMut` closure\n    |\n    = note: `FnMut` closures only have access to their captured variables while they are executing..."}, {"sha": "5e27ed3c6460eba62cc2ca8844ca0d1f7a2e5567", "filename": "src/test/ui/traits/trait-alias/issue-60021-assoc-method-resolve.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Fissue-60021-assoc-method-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Fissue-60021-assoc-method-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Fissue-60021-assoc-method-resolve.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+#![feature(trait_alias)]\n+\n+trait SomeTrait {\n+    fn map(&self) {}\n+}\n+\n+impl<T> SomeTrait for Option<T> {}\n+\n+trait SomeAlias = SomeTrait;\n+\n+fn main() {\n+    let x = Some(123);\n+    // This should resolve to the trait impl for Option\n+    Option::map(x, |z| z);\n+    // This should resolve to the trait impl for SomeTrait\n+    SomeTrait::map(&x);\n+}"}, {"sha": "e49125d10249d635391f7b231862a285e24eb175", "filename": "src/test/ui/traits/trait-alias/issue-72415-assoc-const-resolve.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Fissue-72415-assoc-const-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Fissue-72415-assoc-const-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Fissue-72415-assoc-const-resolve.rs?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+#![feature(trait_alias)]\n+\n+trait Bounded { const MAX: Self; }\n+\n+impl Bounded for u32 {\n+    // This should correctly resolve to the associated const in the inherent impl of u32.\n+    const MAX: Self = u32::MAX;\n+}\n+\n+trait Num = Bounded + Copy;\n+\n+fn main() {}"}, {"sha": "ab6f06518467c9bacaa471e69fb0562f96a987b9", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-call-twice.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-call-twice.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tick`\n   --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:10:5\n    |\n LL |     tick();\n-   |     ---- value moved here\n+   |     ------ `tick` moved due to this call\n LL |     tick();\n    |     ^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `co\n    |\n LL |     let tick = || mem::drop(counter);\n    |                             ^^^^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/unboxed-closures-infer-fnonce-call-twice.rs:9:5\n+   |\n+LL |     tick();\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8d70a2b17602b1508e8018239048f850a07bf7a2", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnonce-move-call-twice.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnonce-move-call-twice.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value: `tick`\n   --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:10:5\n    |\n LL |     tick();\n-   |     ---- value moved here\n+   |     ------ `tick` moved due to this call\n LL |     tick();\n    |     ^^^^ value used here after move\n    |\n@@ -11,6 +11,11 @@ note: closure cannot be invoked more than once because it moves the variable `co\n    |\n LL |     let tick = move || mem::drop(counter);\n    |                                  ^^^^^^^\n+note: this value implements `FnOnce`, which causes it to be moved when called\n+  --> $DIR/unboxed-closures-infer-fnonce-move-call-twice.rs:9:5\n+   |\n+LL |     tick();\n+   |     ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "7e9c8559a4b39f01317ccf14b9011f0a2f79af60", "filename": "src/test/ui/unop-move-semantics.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,11 +4,16 @@ error[E0382]: borrow of moved value: `x`\n LL | fn move_then_borrow<T: Not<Output=T> + Clone>(x: T) {\n    |                                               - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n LL |     !x;\n-   |      - value moved here\n+   |     -- `x` moved due to this method call\n LL | \n LL |     x.clone();\n    |     ^ value borrowed here after move\n    |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `x`\n+  --> $SRC_DIR/libcore/ops/bit.rs:LL:COL\n+   |\n+LL |     fn not(self) -> Self::Output;\n+   |            ^^^^\n help: consider further restricting this bound\n    |\n LL | fn move_then_borrow<T: Not<Output=T> + Clone + Copy>(x: T) {"}, {"sha": "906b543e421229e20a3f67af6201b2dd4118193f", "filename": "src/test/ui/unsized-locals/borrow-after-move.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fborrow-after-move.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -37,10 +37,16 @@ error[E0382]: borrow of moved value: `y`\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n-   |         - value moved here\n+   |           ----- `y` moved due to this method call\n ...\n LL |         println!(\"{}\", &y);\n    |                        ^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n+  --> $DIR/borrow-after-move.rs:4:12\n+   |\n+LL |     fn foo(self) -> String;\n+   |            ^^^^\n \n error[E0382]: borrow of moved value: `x`\n   --> $DIR/borrow-after-move.rs:39:24"}, {"sha": "49b2031c6b9d969a12b82b603d77b3629920697c", "filename": "src/test/ui/unsized-locals/double-move.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fdouble-move.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -34,9 +34,15 @@ error[E0382]: use of moved value: `y`\n LL |         let y = *x;\n    |             - move occurs because `y` has type `str`, which does not implement the `Copy` trait\n LL |         y.foo();\n-   |         - value moved here\n+   |           ----- `y` moved due to this method call\n LL |         y.foo();\n    |         ^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `y`\n+  --> $DIR/double-move.rs:4:12\n+   |\n+LL |     fn foo(self) -> String;\n+   |            ^^^^\n \n error[E0382]: use of moved value: `x`\n   --> $DIR/double-move.rs:45:9"}, {"sha": "b9440f4de07a9e9a38075d6f93a7769de37c4a6d", "filename": "src/test/ui/use/use-after-move-self-based-on-type.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,9 +4,15 @@ error[E0382]: use of moved value: `self`\n LL |     pub fn foo(self) -> isize {\n    |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n-   |         ---- value moved here\n+   |              ----- `self` moved due to this method call\n LL |         return self.x;\n    |                ^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `self`\n+  --> $DIR/use-after-move-self-based-on-type.rs:15:16\n+   |\n+LL |     pub fn bar(self) {}\n+   |                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3da53b024db440506d518511fb2c20f4f870da71", "filename": "src/test/ui/use/use-after-move-self.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,9 +4,15 @@ error[E0382]: use of moved value: `self`\n LL |     pub fn foo(self) -> isize {\n    |                ---- move occurs because `self` has type `S`, which does not implement the `Copy` trait\n LL |         self.bar();\n-   |         ---- value moved here\n+   |              ----- `self` moved due to this method call\n LL |         return *self.x;\n    |                ^^^^^^^ value used here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `self`\n+  --> $DIR/use-after-move-self.rs:13:16\n+   |\n+LL |     pub fn bar(self) {}\n+   |                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ece63a2b8194745d2be6b0b7b9f66aeef1a986c3", "filename": "src/test/ui/walk-struct-literal-with.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwalk-struct-literal-with.stderr?ref=d4ecf31efc2309fb6df8c2a8af9aaf8176ab1c8d", "patch": "@@ -4,9 +4,15 @@ error[E0382]: borrow of moved value: `start`\n LL |     let start = Mine{test:\"Foo\".to_string(), other_val:0};\n    |         ----- move occurs because `start` has type `Mine`, which does not implement the `Copy` trait\n LL |     let end = Mine{other_val:1, ..start.make_string_bar()};\n-   |                                   ----- value moved here\n+   |                                         ----------------- `start` moved due to this method call\n LL |     println!(\"{}\", start.test);\n    |                    ^^^^^^^^^^ value borrowed here after move\n+   |\n+note: this function consumes the receiver `self` by taking ownership of it, which moves `start`\n+  --> $DIR/walk-struct-literal-with.rs:7:28\n+   |\n+LL |     fn make_string_bar(mut self) -> Mine{\n+   |                            ^^^^\n \n error: aborting due to previous error\n "}]}