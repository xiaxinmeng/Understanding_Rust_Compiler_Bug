{"sha": "4436c9d35498e7ae3da261f6141d6d73b915e1e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MzZjOWQzNTQ5OGU3YWUzZGEyNjFmNjE0MWQ2ZDczYjkxNWUxZTg=", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2019-11-27T18:29:00Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2019-11-30T02:43:27Z"}, "message": "Format libstd with rustfmt\n\nThis commit applies rustfmt with rust-lang/rust's default settings to\nfiles in src/libstd *that are not involved in any currently open PR* to\nminimize merge conflicts. THe list of files involved in open PRs was\ndetermined by querying GitHub's GraphQL API with this script:\nhttps://gist.github.com/dtolnay/aa9c34993dc051a4f344d1b10e4487e8\n\nWith the list of files from the script in outstanding_files, the\nrelevant commands were:\n\n    $ find src/libstd -name '*.rs' \\\n        | xargs rustfmt --edition=2018 --unstable-features --skip-children\n    $ rg libstd outstanding_files | xargs git checkout --\n\nRepeating this process several months apart should get us coverage of\nmost of the rest of libstd.\n\nTo confirm no funny business:\n\n    $ git checkout $THIS_COMMIT^\n    $ git show --pretty= --name-only $THIS_COMMIT \\\n        | xargs rustfmt --edition=2018 --unstable-features --skip-children\n    $ git diff $THIS_COMMIT  # there should be no difference", "tree": {"sha": "5bee9f8714a41c4ad672d0cc5c302ede56197726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bee9f8714a41c4ad672d0cc5c302ede56197726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4436c9d35498e7ae3da261f6141d6d73b915e1e8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAl3h108ACgkQ+boUO5X/\nbYJQXg//aunCyanGhZI4uyeQy7HWDj0CA+EGH/a9t5F70+54EhOfP7lOvipz3g82\ndSlej15RO27qJXixv14/hsfChyeorn6EvQRJR+WvZa3O4CT1aem4V8/LJTJLWBv/\n9OLfa4yCa1sKm6dWn/QETLBT/Dtdr+vCIouXlD9ypMo8j2VbVOVBidPiUK6BFrIj\njR3tLg0xUFMuV3Umh+GV6mHxxCHrJXcKIZxu3ZHbu2uL29oumSit6fqpvcH6jvk9\nC7Wt/ieESRWfZAFf2SCX3Wgplb3ppAhL7lcenzqYtm03SZXGwLttfF2K1o48LGh9\nm/BgLPy99iShXoTQdonHMdM5eNnx7WLfbzjN1tGFuAVVHxZjQwbsIh/RrhQvFXir\nPTann1lx1F60pqOmriVzQkFiQSW6BxwWO2x4Y0JU4QzcSrSC+YIoKh/cTNpOYLPk\nYI/zKdNlyHqYxn/99ZoY9GHK5niHkMg0WTjBK1lyQEDxpb/Y1X2vsLhJFLKxLlU+\nCxmR9tfywBpmdnVauzjyjgc1d1rjQQVzYk0+PeOK3W9u9rQ0J/M0fhzDgOrQk4UT\ncM7jvIq4SNsZpSvGZ4F83kbQ1wWjW64WM1g8AP2aGr8y9CYkYpjPy+QcskiGjC4v\naeQ3O3kXDJw2C3IDy7+IaTXAOVv3s2/t0uEEtRsW9WVD1AaJ1aw=\n=Lo3+\n-----END PGP SIGNATURE-----", "payload": "tree 5bee9f8714a41c4ad672d0cc5c302ede56197726\nparent 9081929d45f12d3f56d43b1d6db7519981580fc9\nauthor David Tolnay <dtolnay@gmail.com> 1574879340 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1575081807 -0800\n\nFormat libstd with rustfmt\n\nThis commit applies rustfmt with rust-lang/rust's default settings to\nfiles in src/libstd *that are not involved in any currently open PR* to\nminimize merge conflicts. THe list of files involved in open PRs was\ndetermined by querying GitHub's GraphQL API with this script:\nhttps://gist.github.com/dtolnay/aa9c34993dc051a4f344d1b10e4487e8\n\nWith the list of files from the script in outstanding_files, the\nrelevant commands were:\n\n    $ find src/libstd -name '*.rs' \\\n        | xargs rustfmt --edition=2018 --unstable-features --skip-children\n    $ rg libstd outstanding_files | xargs git checkout --\n\nRepeating this process several months apart should get us coverage of\nmost of the rest of libstd.\n\nTo confirm no funny business:\n\n    $ git checkout $THIS_COMMIT^\n    $ git show --pretty= --name-only $THIS_COMMIT \\\n        | xargs rustfmt --edition=2018 --unstable-features --skip-children\n    $ git diff $THIS_COMMIT  # there should be no difference\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4436c9d35498e7ae3da261f6141d6d73b915e1e8", "html_url": "https://github.com/rust-lang/rust/commit/4436c9d35498e7ae3da261f6141d6d73b915e1e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4436c9d35498e7ae3da261f6141d6d73b915e1e8/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9081929d45f12d3f56d43b1d6db7519981580fc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9081929d45f12d3f56d43b1d6db7519981580fc9", "html_url": "https://github.com/rust-lang/rust/commit/9081929d45f12d3f56d43b1d6db7519981580fc9"}], "stats": {"total": 5557, "additions": 2897, "deletions": 2660}, "files": [{"sha": "41bdfea53e5599d77a5432d02087e41b962875ff", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -17,7 +17,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::ascii::{EscapeDefault, escape_default};\n+pub use core::ascii::{escape_default, EscapeDefault};\n \n /// Extension methods for ASCII-subset only operations.\n ///"}, {"sha": "5ba1c940251dc3b92233fd62c59d301009ad39e7", "filename": "src/libstd/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbacktrace.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -95,10 +95,10 @@ use crate::env;\n use crate::fmt;\n use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sync::Mutex;\n-use crate::sys_common::backtrace::{output_filename, lock};\n+use crate::sys_common::backtrace::{lock, output_filename};\n use crate::vec::Vec;\n-use backtrace_rs as backtrace;\n use backtrace::BytesOrWideString;\n+use backtrace_rs as backtrace;\n \n /// A captured OS thread stack backtrace.\n ///"}, {"sha": "bf646cbae47db81fc26fba47cf6c56dba18eeee7", "filename": "src/libstd/benches/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fbenches%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fbenches%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbenches%2Fhash%2Fmap.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,7 +1,7 @@\n #![cfg(test)]\n \n-use test::Bencher;\n use std::collections::HashMap;\n+use test::Bencher;\n \n #[bench]\n fn new_drop(b: &mut Bencher) {"}, {"sha": "522b8b25144f42073dfa727dc0f2eed831e67a2f", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -413,20 +413,20 @@\n #[doc(hidden)]\n pub use crate::ops::Bound;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc_crate::collections::{BinaryHeap, BTreeMap, BTreeSet};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc_crate::collections::{LinkedList, VecDeque};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::collections::{binary_heap, btree_map, btree_set};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::collections::{linked_list, vec_deque};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc_crate::collections::{BTreeMap, BTreeSet, BinaryHeap};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use alloc_crate::collections::{LinkedList, VecDeque};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_map::HashMap;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_set::HashSet;\n \n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n pub use alloc_crate::collections::TryReserveError;\n \n mod hash;"}, {"sha": "cf71b61b917a748e42d0ac5dcaf29d4c9da3444d", "filename": "src/libstd/env.rs", "status": "modified", "additions": 94, "deletions": 67, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -78,7 +78,9 @@ pub fn set_current_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// [`std::env::vars`]: fn.vars.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct Vars { inner: VarsOs }\n+pub struct Vars {\n+    inner: VarsOs,\n+}\n \n /// An iterator over a snapshot of the environment variables of this process.\n ///\n@@ -87,7 +89,9 @@ pub struct Vars { inner: VarsOs }\n ///\n /// [`std::env::vars_os`]: fn.vars_os.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct VarsOs { inner: os_imp::Env }\n+pub struct VarsOs {\n+    inner: os_imp::Env,\n+}\n \n /// Returns an iterator of (variable, value) pairs of strings, for all the\n /// environment variables of the current process.\n@@ -147,11 +151,11 @@ pub fn vars_os() -> VarsOs {\n impl Iterator for Vars {\n     type Item = (String, String);\n     fn next(&mut self) -> Option<(String, String)> {\n-        self.inner.next().map(|(a, b)| {\n-            (a.into_string().unwrap(), b.into_string().unwrap())\n-        })\n+        self.inner.next().map(|(a, b)| (a.into_string().unwrap(), b.into_string().unwrap()))\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n     }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -164,8 +168,12 @@ impl fmt::Debug for Vars {\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for VarsOs {\n     type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -239,9 +247,8 @@ pub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> {\n }\n \n fn _var_os(key: &OsStr) -> Option<OsString> {\n-    os_imp::getenv(key).unwrap_or_else(|e| {\n-        panic!(\"failed to get environment variable `{:?}`: {}\", key, e)\n-    })\n+    os_imp::getenv(key)\n+        .unwrap_or_else(|e| panic!(\"failed to get environment variable `{:?}`: {}\", key, e))\n }\n \n /// The error type for operations interacting with environment variables.\n@@ -321,8 +328,7 @@ pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) {\n \n fn _set_var(k: &OsStr, v: &OsStr) {\n     os_imp::setenv(k, v).unwrap_or_else(|e| {\n-        panic!(\"failed to set environment variable `{:?}` to `{:?}`: {}\",\n-               k, v, e)\n+        panic!(\"failed to set environment variable `{:?}` to `{:?}`: {}\", k, v, e)\n     })\n }\n \n@@ -363,9 +369,8 @@ pub fn remove_var<K: AsRef<OsStr>>(k: K) {\n }\n \n fn _remove_var(k: &OsStr) {\n-    os_imp::unsetenv(k).unwrap_or_else(|e| {\n-        panic!(\"failed to remove environment variable `{:?}`: {}\", k, e)\n-    })\n+    os_imp::unsetenv(k)\n+        .unwrap_or_else(|e| panic!(\"failed to remove environment variable `{:?}`: {}\", k, e))\n }\n \n /// An iterator that splits an environment variable into paths according to\n@@ -379,7 +384,9 @@ fn _remove_var(k: &OsStr) {\n /// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n /// [`std::env::split_paths`]: fn.split_paths.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n+pub struct SplitPaths<'a> {\n+    inner: os_imp::SplitPaths<'a>,\n+}\n \n /// Parses input according to platform conventions for the `PATH`\n /// environment variable.\n@@ -412,8 +419,12 @@ pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths<'_> {\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl<'a> Iterator for SplitPaths<'a> {\n     type Item = PathBuf;\n-    fn next(&mut self) -> Option<PathBuf> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<PathBuf> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -430,7 +441,7 @@ impl fmt::Debug for SplitPaths<'_> {\n #[derive(Debug)]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub struct JoinPathsError {\n-    inner: os_imp::JoinPathsError\n+    inner: os_imp::JoinPathsError,\n }\n \n /// Joins a collection of [`Path`]s appropriately for the `PATH`\n@@ -499,11 +510,11 @@ pub struct JoinPathsError {\n /// [`env::split_paths`]: fn.split_paths.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: IntoIterator<Item=T>, T: AsRef<OsStr>\n+where\n+    I: IntoIterator<Item = T>,\n+    T: AsRef<OsStr>,\n {\n-    os_imp::join_paths(paths.into_iter()).map_err(|e| {\n-        JoinPathsError { inner: e }\n-    })\n+    os_imp::join_paths(paths.into_iter()).map_err(|e| JoinPathsError { inner: e })\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n@@ -515,7 +526,9 @@ impl fmt::Display for JoinPathsError {\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Error for JoinPathsError {\n-    fn description(&self) -> &str { self.inner.description() }\n+    fn description(&self) -> &str {\n+        self.inner.description()\n+    }\n }\n \n /// Returns the path of the current user's home directory if known.\n@@ -549,9 +562,11 @@ impl Error for JoinPathsError {\n ///     None => println!(\"Impossible to get your home dir!\"),\n /// }\n /// ```\n-#[rustc_deprecated(since = \"1.29.0\",\n+#[rustc_deprecated(\n+    since = \"1.29.0\",\n     reason = \"This function's behavior is unexpected and probably not what you want. \\\n-              Consider using the home_dir function from https://crates.io/crates/dirs instead.\")]\n+              Consider using the home_dir function from https://crates.io/crates/dirs instead.\"\n+)]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn home_dir() -> Option<PathBuf> {\n     os_imp::home_dir()\n@@ -674,7 +689,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n /// [`String`]: ../string/struct.String.html\n /// [`std::env::args`]: ./fn.args.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct Args { inner: ArgsOs }\n+pub struct Args {\n+    inner: ArgsOs,\n+}\n \n /// An iterator over the arguments of a process, yielding an [`OsString`] value\n /// for each argument.\n@@ -689,7 +706,9 @@ pub struct Args { inner: ArgsOs }\n /// [`OsString`]: ../ffi/struct.OsString.html\n /// [`std::env::args_os`]: ./fn.args_os.html\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct ArgsOs { inner: sys::args::Args }\n+pub struct ArgsOs {\n+    inner: sys::args::Args,\n+}\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n@@ -769,13 +788,19 @@ impl Iterator for Args {\n     fn next(&mut self) -> Option<String> {\n         self.inner.next().map(|s| s.into_string().unwrap())\n     }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.inner.len() }\n-    fn is_empty(&self) -> bool { self.inner.is_empty() }\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+    fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n }\n \n #[stable(feature = \"env_iterators\", since = \"1.12.0\")]\n@@ -788,9 +813,7 @@ impl DoubleEndedIterator for Args {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Args {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Args\")\n-            .field(\"inner\", &self.inner.inner.inner_debug())\n-            .finish()\n+        f.debug_struct(\"Args\").field(\"inner\", &self.inner.inner.inner_debug()).finish()\n     }\n }\n \n@@ -803,27 +826,35 @@ impl !Sync for ArgsOs {}\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for ArgsOs {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<OsString> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl ExactSizeIterator for ArgsOs {\n-    fn len(&self) -> usize { self.inner.len() }\n-    fn is_empty(&self) -> bool { self.inner.is_empty() }\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+    fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n }\n \n #[stable(feature = \"env_iterators\", since = \"1.12.0\")]\n impl DoubleEndedIterator for ArgsOs {\n-    fn next_back(&mut self) -> Option<OsString> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for ArgsOs {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"ArgsOs\")\n-            .field(\"inner\", &self.inner.inner_debug())\n-            .finish()\n+        f.debug_struct(\"ArgsOs\").field(\"inner\", &self.inner.inner_debug()).finish()\n     }\n }\n \n@@ -1033,20 +1064,21 @@ mod tests {\n         use crate::path::PathBuf;\n \n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n+            split_paths(unparsed).collect::<Vec<_>>()\n+                == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));\n         assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n         assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n         assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n         assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n-        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n-                            &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n+        assert!(check_parse(r\"c:\\;c:\\Program Files\\\", &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n         assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n-        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n-                            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n+        assert!(check_parse(\n+            r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n+            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]\n+        ));\n     }\n \n     #[test]\n@@ -1055,8 +1087,8 @@ mod tests {\n         use crate::path::PathBuf;\n \n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n+            split_paths(unparsed).collect::<Vec<_>>()\n+                == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));\n@@ -1072,15 +1104,12 @@ mod tests {\n         use crate::ffi::OsStr;\n \n         fn test_eq(input: &[&str], output: &str) -> bool {\n-            &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::new(output)\n+            &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n-                         \"/bin:/usr/bin:/usr/local/bin\"));\n-        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n-                         \":/bin:::/usr/bin:\"));\n+        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"], \"/bin:/usr/bin:/usr/local/bin\"));\n+        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"], \":/bin:::/usr/bin:\"));\n         assert!(join_paths([\"/te:st\"].iter().cloned()).is_err());\n     }\n \n@@ -1090,27 +1119,25 @@ mod tests {\n         use crate::ffi::OsStr;\n \n         fn test_eq(input: &[&str], output: &str) -> bool {\n-            &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::new(output)\n+            &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"],\n-                        r\"c:\\windows;c:\\\"));\n-        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n-                        r\";c:\\windows;;;c:\\;\"));\n-        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"],\n-                        r#\"\"c:\\te;st\";c:\\\"#));\n+        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"], r\"c:\\windows;c:\\\"));\n+        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"], r\";c:\\windows;;;c:\\;\"));\n+        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"], r#\"\"c:\\te;st\";c:\\\"#));\n         assert!(join_paths([r#\"c:\\te\"st\"#].iter().cloned()).is_err());\n     }\n \n     #[test]\n     fn args_debug() {\n         assert_eq!(\n             format!(\"Args {{ inner: {:?} }}\", args().collect::<Vec<_>>()),\n-            format!(\"{:?}\", args()));\n+            format!(\"{:?}\", args())\n+        );\n         assert_eq!(\n             format!(\"ArgsOs {{ inner: {:?} }}\", args_os().collect::<Vec<_>>()),\n-            format!(\"{:?}\", args_os()));\n+            format!(\"{:?}\", args_os())\n+        );\n     }\n }"}, {"sha": "54e0caeddaa0bc68f537450106a254f498124b87", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -14,15 +14,15 @@ use crate::intrinsics;\n use crate::sys::cmath;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f32::consts;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f32::{DIGITS, EPSILON, MANTISSA_DIGITS, RADIX};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f32::{INFINITY, MAX_10_EXP, NAN, NEG_INFINITY};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n+pub use core::f32::{MAX, MIN, MIN_POSITIVE};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f32::consts;\n+pub use core::f32::{MAX_EXP, MIN_10_EXP, MIN_EXP};\n \n #[cfg(not(test))]\n #[lang = \"f32_runtime\"]\n@@ -142,7 +142,9 @@ impl f32 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn fract(self) -> f32 { self - self.trunc() }\n+    pub fn fract(self) -> f32 {\n+        self - self.trunc()\n+    }\n \n     /// Computes the absolute value of `self`. Returns `NAN` if the\n     /// number is `NAN`.\n@@ -192,11 +194,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn signum(self) -> f32 {\n-        if self.is_nan() {\n-            NAN\n-        } else {\n-            1.0_f32.copysign(self)\n-        }\n+        if self.is_nan() { NAN } else { 1.0_f32.copysign(self) }\n     }\n \n     /// Returns a number composed of the magnitude of `self` and the sign of\n@@ -277,7 +275,7 @@ impl f32 {\n     pub fn div_euclid(self, rhs: f32) -> f32 {\n         let q = (self / rhs).trunc();\n         if self % rhs < 0.0 {\n-            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 }\n+            return if rhs > 0.0 { q - 1.0 } else { q + 1.0 };\n         }\n         q\n     }\n@@ -310,14 +308,9 @@ impl f32 {\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n     pub fn rem_euclid(self, rhs: f32) -> f32 {\n         let r = self % rhs;\n-        if r < 0.0 {\n-            r + rhs.abs()\n-        } else {\n-            r\n-        }\n+        if r < 0.0 { r + rhs.abs() } else { r }\n     }\n \n-\n     /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n@@ -383,11 +376,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sqrt(self) -> f32 {\n-        if self < 0.0 {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf32(self) }\n-        }\n+        if self < 0.0 { NAN } else { unsafe { intrinsics::sqrtf32(self) } }\n     }\n \n     /// Returns `e^(self)`, (the exponential function).\n@@ -486,7 +475,9 @@ impl f32 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n+    pub fn log(self, base: f32) -> f32 {\n+        self.ln() / base.ln()\n+    }\n \n     /// Returns the base 2 logarithm of the number.\n     ///\n@@ -559,14 +550,16 @@ impl f32 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    #[rustc_deprecated(since = \"1.10.0\",\n-                       reason = \"you probably meant `(self - other).abs()`: \\\n-                                 this operation is `(self - other).max(0.0)` \\\n-                                 except that `abs_sub` also propagates NaNs (also \\\n-                                 known as `fdimf` in C). If you truly need the positive \\\n-                                 difference, consider using that expression or the C function \\\n-                                 `fdimf`, depending on how you wish to handle NaN (please consider \\\n-                                 filing an issue describing your use-case too).\")]\n+    #[rustc_deprecated(\n+        since = \"1.10.0\",\n+        reason = \"you probably meant `(self - other).abs()`: \\\n+                  this operation is `(self - other).max(0.0)` \\\n+                  except that `abs_sub` also propagates NaNs (also \\\n+                  known as `fdimf` in C). If you truly need the positive \\\n+                  difference, consider using that expression or the C function \\\n+                  `fdimf`, depending on how you wish to handle NaN (please consider \\\n+                  filing an issue describing your use-case too).\"\n+    )]\n     pub fn abs_sub(self, other: f32) -> f32 {\n         unsafe { cmath::fdimf(self, other) }\n     }\n@@ -967,11 +960,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f32 {\n-        if self < 1.0 {\n-            crate::f32::NAN\n-        } else {\n-            (self + ((self * self) - 1.0).sqrt()).ln()\n-        }\n+        if self < 1.0 { crate::f32::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n     }\n \n     /// Inverse hyperbolic tangent function.\n@@ -1022,19 +1011,22 @@ impl f32 {\n     pub fn clamp(self, min: f32, max: f32) -> f32 {\n         assert!(min <= max);\n         let mut x = self;\n-        if x < min { x = min; }\n-        if x > max { x = max; }\n+        if x < min {\n+            x = min;\n+        }\n+        if x > max {\n+            x = max;\n+        }\n         x\n     }\n-\n }\n \n #[cfg(test)]\n mod tests {\n     use crate::f32;\n     use crate::f32::*;\n-    use crate::num::*;\n     use crate::num::FpCategory as Fp;\n+    use crate::num::*;\n \n     #[test]\n     fn test_num_f32() {\n@@ -1279,7 +1271,7 @@ mod tests {\n         assert_eq!((-0f32).abs(), 0f32);\n         assert_eq!((-1f32).abs(), 1f32);\n         assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f32/NEG_INFINITY).abs(), 0f32);\n+        assert_eq!((1f32 / NEG_INFINITY).abs(), 0f32);\n         assert!(NAN.abs().is_nan());\n     }\n \n@@ -1291,7 +1283,7 @@ mod tests {\n         assert_eq!((-0f32).signum(), -1f32);\n         assert_eq!((-1f32).signum(), -1f32);\n         assert_eq!(NEG_INFINITY.signum(), -1f32);\n-        assert_eq!((1f32/NEG_INFINITY).signum(), -1f32);\n+        assert_eq!((1f32 / NEG_INFINITY).signum(), -1f32);\n         assert!(NAN.signum().is_nan());\n     }\n \n@@ -1303,7 +1295,7 @@ mod tests {\n         assert!(!(-0f32).is_sign_positive());\n         assert!(!(-1f32).is_sign_positive());\n         assert!(!NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f32/NEG_INFINITY).is_sign_positive());\n+        assert!(!(1f32 / NEG_INFINITY).is_sign_positive());\n         assert!(NAN.is_sign_positive());\n         assert!(!(-NAN).is_sign_positive());\n     }\n@@ -1316,7 +1308,7 @@ mod tests {\n         assert!((-0f32).is_sign_negative());\n         assert!((-1f32).is_sign_negative());\n         assert!(NEG_INFINITY.is_sign_negative());\n-        assert!((1f32/NEG_INFINITY).is_sign_negative());\n+        assert!((1f32 / NEG_INFINITY).is_sign_negative());\n         assert!(!NAN.is_sign_negative());\n         assert!((-NAN).is_sign_negative());\n     }"}, {"sha": "aa32e5fb998bc54cfa577f0b0747ab5808007274", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -14,15 +14,15 @@ use crate::intrinsics;\n use crate::sys::cmath;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n+pub use core::f64::consts;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f64::{DIGITS, EPSILON, MANTISSA_DIGITS, RADIX};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f64::{INFINITY, MAX_10_EXP, NAN, NEG_INFINITY};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n+pub use core::f64::{MAX, MIN, MIN_POSITIVE};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::f64::consts;\n+pub use core::f64::{MAX_EXP, MIN_10_EXP, MIN_EXP};\n \n #[cfg(not(test))]\n #[lang = \"f64_runtime\"]\n@@ -120,7 +120,9 @@ impl f64 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn fract(self) -> f64 { self - self.trunc() }\n+    pub fn fract(self) -> f64 {\n+        self - self.trunc()\n+    }\n \n     /// Computes the absolute value of `self`. Returns `NAN` if the\n     /// number is `NAN`.\n@@ -170,11 +172,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn signum(self) -> f64 {\n-        if self.is_nan() {\n-            NAN\n-        } else {\n-            1.0_f64.copysign(self)\n-        }\n+        if self.is_nan() { NAN } else { 1.0_f64.copysign(self) }\n     }\n \n     /// Returns a number composed of the magnitude of `self` and the sign of\n@@ -286,11 +284,7 @@ impl f64 {\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n     pub fn rem_euclid(self, rhs: f64) -> f64 {\n         let r = self % rhs;\n-        if r < 0.0 {\n-            r + rhs.abs()\n-        } else {\n-            r\n-        }\n+        if r < 0.0 { r + rhs.abs() } else { r }\n     }\n \n     /// Raises a number to an integer power.\n@@ -348,11 +342,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sqrt(self) -> f64 {\n-        if self < 0.0 {\n-            NAN\n-        } else {\n-            unsafe { intrinsics::sqrtf64(self) }\n-        }\n+        if self < 0.0 { NAN } else { unsafe { intrinsics::sqrtf64(self) } }\n     }\n \n     /// Returns `e^(self)`, (the exponential function).\n@@ -413,7 +403,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn ln(self) -> f64 {\n-        self.log_wrapper(|n| { unsafe { intrinsics::logf64(n) } })\n+        self.log_wrapper(|n| unsafe { intrinsics::logf64(n) })\n     }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n@@ -435,7 +425,9 @@ impl f64 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n+    pub fn log(self, base: f64) -> f64 {\n+        self.ln() / base.ln()\n+    }\n \n     /// Returns the base 2 logarithm of the number.\n     ///\n@@ -455,9 +447,9 @@ impl f64 {\n     pub fn log2(self) -> f64 {\n         self.log_wrapper(|n| {\n             #[cfg(target_os = \"android\")]\n-                return crate::sys::android::log2f64(n);\n+            return crate::sys::android::log2f64(n);\n             #[cfg(not(target_os = \"android\"))]\n-                return unsafe { intrinsics::log2f64(n) };\n+            return unsafe { intrinsics::log2f64(n) };\n         })\n     }\n \n@@ -477,7 +469,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn log10(self) -> f64 {\n-        self.log_wrapper(|n| { unsafe { intrinsics::log10f64(n) } })\n+        self.log_wrapper(|n| unsafe { intrinsics::log10f64(n) })\n     }\n \n     /// The positive difference of two numbers.\n@@ -500,14 +492,16 @@ impl f64 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    #[rustc_deprecated(since = \"1.10.0\",\n-    reason = \"you probably meant `(self - other).abs()`: \\\n-                                 this operation is `(self - other).max(0.0)` \\\n-                                 except that `abs_sub` also propagates NaNs (also \\\n-                                 known as `fdim` in C). If you truly need the positive \\\n-                                 difference, consider using that expression or the C function \\\n-                                 `fdim`, depending on how you wish to handle NaN (please consider \\\n-                                 filing an issue describing your use-case too).\")]\n+    #[rustc_deprecated(\n+        since = \"1.10.0\",\n+        reason = \"you probably meant `(self - other).abs()`: \\\n+                  this operation is `(self - other).max(0.0)` \\\n+                  except that `abs_sub` also propagates NaNs (also \\\n+                  known as `fdim` in C). If you truly need the positive \\\n+                  difference, consider using that expression or the C function \\\n+                  `fdim`, depending on how you wish to handle NaN (please consider \\\n+                  filing an issue describing your use-case too).\"\n+    )]\n     pub fn abs_sub(self, other: f64) -> f64 {\n         unsafe { cmath::fdim(self, other) }\n     }\n@@ -888,11 +882,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f64 {\n-        if self < 1.0 {\n-            NAN\n-        } else {\n-            (self + ((self * self) - 1.0).sqrt()).ln()\n-        }\n+        if self < 1.0 { NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n     }\n \n     /// Inverse hyperbolic tangent function.\n@@ -943,8 +933,12 @@ impl f64 {\n     pub fn clamp(self, min: f64, max: f64) -> f64 {\n         assert!(min <= max);\n         let mut x = self;\n-        if x < min { x = min; }\n-        if x > max { x = max; }\n+        if x < min {\n+            x = min;\n+        }\n+        if x > max {\n+            x = max;\n+        }\n         x\n     }\n \n@@ -978,8 +972,8 @@ impl f64 {\n mod tests {\n     use crate::f64;\n     use crate::f64::*;\n-    use crate::num::*;\n     use crate::num::FpCategory as Fp;\n+    use crate::num::*;\n \n     #[test]\n     fn test_num_f64() {"}, {"sha": "72f7367c9dcdbd11838235ddaad663eda8e62f25", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -155,21 +155,23 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::c_str::{CString, CStr, NulError, IntoStringError};\n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n-pub use self::c_str::{FromBytesWithNulError};\n+pub use self::c_str::FromBytesWithNulError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::c_str::{CStr, CString, IntoStringError, NulError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::os_str::{OsString, OsStr};\n+pub use self::os_str::{OsStr, OsString};\n \n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub use core::ffi::c_void;\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n pub use core::ffi::{VaList, VaListImpl};\n \n mod c_str;"}, {"sha": "e5cf022f0444e338a27622bb3ea07a2020cfe9aa", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 204, "deletions": 131, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -9,12 +9,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::fmt;\n use crate::ffi::OsString;\n-use crate::io::{self, SeekFrom, Seek, Read, Initializer, Write, IoSlice, IoSliceMut};\n+use crate::fmt;\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n use crate::path::{Path, PathBuf};\n use crate::sys::fs as fs_imp;\n-use crate::sys_common::{AsInnerMut, FromInner, AsInner, IntoInner};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n use crate::time::SystemTime;\n \n /// A reference to an open file on the filesystem.\n@@ -585,9 +585,7 @@ impl File {\n     /// ```\n     #[stable(feature = \"file_try_clone\", since = \"1.9.0\")]\n     pub fn try_clone(&self) -> io::Result<File> {\n-        Ok(File {\n-            inner: self.inner.duplicate()?\n-        })\n+        Ok(File { inner: self.inner.duplicate()? })\n     }\n \n     /// Changes the permissions on the underlying file.\n@@ -629,7 +627,9 @@ impl File {\n }\n \n impl AsInner<fs_imp::File> for File {\n-    fn as_inner(&self) -> &fs_imp::File { &self.inner }\n+    fn as_inner(&self) -> &fs_imp::File {\n+        &self.inner\n+    }\n }\n impl FromInner<fs_imp::File> for File {\n     fn from_inner(f: fs_imp::File) -> File {\n@@ -674,7 +674,9 @@ impl Write for File {\n         self.inner.write_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.flush()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Seek for File {\n@@ -707,7 +709,9 @@ impl Write for &File {\n         self.inner.write_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.flush()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Seek for &File {\n@@ -748,7 +752,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&mut self, read: bool) -> &mut OpenOptions {\n-        self.0.read(read); self\n+        self.0.read(read);\n+        self\n     }\n \n     /// Sets the option for write access.\n@@ -768,7 +773,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&mut self, write: bool) -> &mut OpenOptions {\n-        self.0.write(write); self\n+        self.0.write(write);\n+        self\n     }\n \n     /// Sets the option for the append mode.\n@@ -814,7 +820,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, append: bool) -> &mut OpenOptions {\n-        self.0.append(append); self\n+        self.0.append(append);\n+        self\n     }\n \n     /// Sets the option for truncating a previous file.\n@@ -833,7 +840,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions {\n-        self.0.truncate(truncate); self\n+        self.0.truncate(truncate);\n+        self\n     }\n \n     /// Sets the option for creating a new file.\n@@ -856,7 +864,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn create(&mut self, create: bool) -> &mut OpenOptions {\n-        self.0.create(create); self\n+        self.0.create(create);\n+        self\n     }\n \n     /// Sets the option to always create a new file.\n@@ -889,7 +898,8 @@ impl OpenOptions {\n     /// ```\n     #[stable(feature = \"expand_open_options2\", since = \"1.9.0\")]\n     pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions {\n-        self.0.create_new(create_new); self\n+        self.0.create_new(create_new);\n+        self\n     }\n \n     /// Opens a file at `path` with the options specified by `self`.\n@@ -946,11 +956,15 @@ impl OpenOptions {\n }\n \n impl AsInner<fs_imp::OpenOptions> for OpenOptions {\n-    fn as_inner(&self) -> &fs_imp::OpenOptions { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::OpenOptions {\n+        &self.0\n+    }\n }\n \n impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n-    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions { &mut self.0 }\n+    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions {\n+        &mut self.0\n+    }\n }\n \n impl Metadata {\n@@ -994,7 +1008,9 @@ impl Metadata {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_dir(&self) -> bool { self.file_type().is_dir() }\n+    pub fn is_dir(&self) -> bool {\n+        self.file_type().is_dir()\n+    }\n \n     /// Returns `true` if this metadata is for a regular file. The\n     /// result is mutually exclusive to the result of\n@@ -1017,7 +1033,9 @@ impl Metadata {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_file(&self) -> bool { self.file_type().is_file() }\n+    pub fn is_file(&self) -> bool {\n+        self.file_type().is_file()\n+    }\n \n     /// Returns the size of the file, in bytes, this metadata is for.\n     ///\n@@ -1034,7 +1052,9 @@ impl Metadata {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> u64 { self.0.size() }\n+    pub fn len(&self) -> u64 {\n+        self.0.size()\n+    }\n \n     /// Returns the permissions of the file this metadata is for.\n     ///\n@@ -1170,11 +1190,15 @@ impl fmt::Debug for Metadata {\n }\n \n impl AsInner<fs_imp::FileAttr> for Metadata {\n-    fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::FileAttr {\n+        &self.0\n+    }\n }\n \n impl FromInner<fs_imp::FileAttr> for Metadata {\n-    fn from_inner(attr: fs_imp::FileAttr) -> Metadata { Metadata(attr) }\n+    fn from_inner(attr: fs_imp::FileAttr) -> Metadata {\n+        Metadata(attr)\n+    }\n }\n \n impl Permissions {\n@@ -1194,7 +1218,9 @@ impl Permissions {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn readonly(&self) -> bool { self.0.readonly() }\n+    pub fn readonly(&self) -> bool {\n+        self.0.readonly()\n+    }\n \n     /// Modifies the readonly flag for this set of permissions. If the\n     /// `readonly` argument is `true`, using the resulting `Permission` will\n@@ -1256,7 +1282,9 @@ impl FileType {\n     /// }\n     /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n-    pub fn is_dir(&self) -> bool { self.0.is_dir() }\n+    pub fn is_dir(&self) -> bool {\n+        self.0.is_dir()\n+    }\n \n     /// Tests whether this file type represents a regular file.\n     /// The result is  mutually exclusive to the results of\n@@ -1280,7 +1308,9 @@ impl FileType {\n     /// }\n     /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n-    pub fn is_file(&self) -> bool { self.0.is_file() }\n+    pub fn is_file(&self) -> bool {\n+        self.0.is_file()\n+    }\n \n     /// Tests whether this file type represents a symbolic link.\n     /// The result is mutually exclusive to the results of\n@@ -1314,11 +1344,15 @@ impl FileType {\n     /// }\n     /// ```\n     #[stable(feature = \"file_type\", since = \"1.1.0\")]\n-    pub fn is_symlink(&self) -> bool { self.0.is_symlink() }\n+    pub fn is_symlink(&self) -> bool {\n+        self.0.is_symlink()\n+    }\n }\n \n impl AsInner<fs_imp::FileType> for FileType {\n-    fn as_inner(&self) -> &fs_imp::FileType { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::FileType {\n+        &self.0\n+    }\n }\n \n impl FromInner<fs_imp::FilePermissions> for Permissions {\n@@ -1328,7 +1362,9 @@ impl FromInner<fs_imp::FilePermissions> for Permissions {\n }\n \n impl AsInner<fs_imp::FilePermissions> for Permissions {\n-    fn as_inner(&self) -> &fs_imp::FilePermissions { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::FilePermissions {\n+        &self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1370,7 +1406,9 @@ impl DirEntry {\n     ///\n     /// The exact text, of course, depends on what files you have in `.`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn path(&self) -> PathBuf { self.0.path() }\n+    pub fn path(&self) -> PathBuf {\n+        self.0.path()\n+    }\n \n     /// Returns the metadata for the file that this entry points at.\n     ///\n@@ -1468,14 +1506,14 @@ impl DirEntry {\n #[stable(feature = \"dir_entry_debug\", since = \"1.13.0\")]\n impl fmt::Debug for DirEntry {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"DirEntry\")\n-            .field(&self.path())\n-            .finish()\n+        f.debug_tuple(\"DirEntry\").field(&self.path()).finish()\n     }\n }\n \n impl AsInner<fs_imp::DirEntry> for DirEntry {\n-    fn as_inner(&self) -> &fs_imp::DirEntry { &self.0 }\n+    fn as_inner(&self) -> &fs_imp::DirEntry {\n+        &self.0\n+    }\n }\n \n /// Removes a file from the filesystem.\n@@ -1744,9 +1782,11 @@ pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.1.0\",\n-             reason = \"replaced with std::os::unix::fs::symlink and \\\n-                       std::os::windows::fs::{symlink_file, symlink_dir}\")]\n+#[rustc_deprecated(\n+    since = \"1.1.0\",\n+    reason = \"replaced with std::os::unix::fs::symlink and \\\n+              std::os::windows::fs::{symlink_file, symlink_dir}\"\n+)]\n pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     fs_imp::symlink(src.as_ref(), dst.as_ref())\n }\n@@ -2089,8 +2129,7 @@ pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n /// }\n /// ```\n #[stable(feature = \"set_permissions\", since = \"1.1.0\")]\n-pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions)\n-                                       -> io::Result<()> {\n+pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result<()> {\n     fs_imp::set_perm(path.as_ref(), perm.0)\n }\n \n@@ -2107,10 +2146,7 @@ impl DirBuilder {\n     /// ```\n     #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n     pub fn new() -> DirBuilder {\n-        DirBuilder {\n-            inner: fs_imp::DirBuilder::new(),\n-            recursive: false,\n-        }\n+        DirBuilder { inner: fs_imp::DirBuilder::new(), recursive: false }\n     }\n \n     /// Indicates that directories should be created recursively, creating all\n@@ -2157,16 +2193,12 @@ impl DirBuilder {\n     }\n \n     fn _create(&self, path: &Path) -> io::Result<()> {\n-        if self.recursive {\n-            self.create_dir_all(path)\n-        } else {\n-            self.inner.mkdir(path)\n-        }\n+        if self.recursive { self.create_dir_all(path) } else { self.inner.mkdir(path) }\n     }\n \n     fn create_dir_all(&self, path: &Path) -> io::Result<()> {\n         if path == Path::new(\"\") {\n-            return Ok(())\n+            return Ok(());\n         }\n \n         match self.inner.mkdir(path) {\n@@ -2177,7 +2209,9 @@ impl DirBuilder {\n         }\n         match path.parent() {\n             Some(p) => self.create_dir_all(p)?,\n-            None => return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\")),\n+            None => {\n+                return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\"));\n+            }\n         }\n         match self.inner.mkdir(path) {\n             Ok(()) => Ok(()),\n@@ -2201,48 +2235,62 @@ mod tests {\n     use crate::io::{ErrorKind, SeekFrom};\n     use crate::path::Path;\n     use crate::str;\n-    use crate::sys_common::io::test::{TempDir, tmpdir};\n+    use crate::sys_common::io::test::{tmpdir, TempDir};\n     use crate::thread;\n \n     use rand::{rngs::StdRng, RngCore, SeedableRng};\n \n-    #[cfg(windows)]\n-    use crate::os::windows::fs::{symlink_dir, symlink_file};\n-    #[cfg(windows)]\n-    use crate::sys::fs::symlink_junction;\n     #[cfg(unix)]\n     use crate::os::unix::fs::symlink as symlink_dir;\n     #[cfg(unix)]\n     use crate::os::unix::fs::symlink as symlink_file;\n     #[cfg(unix)]\n     use crate::os::unix::fs::symlink as symlink_junction;\n+    #[cfg(windows)]\n+    use crate::os::windows::fs::{symlink_dir, symlink_file};\n+    #[cfg(windows)]\n+    use crate::sys::fs::symlink_junction;\n \n-    macro_rules! check { ($e:expr) => (\n-        match $e {\n-            Ok(t) => t,\n-            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n-        }\n-    ) }\n+    macro_rules! check {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(t) => t,\n+                Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n+            }\n+        };\n+    }\n \n     #[cfg(windows)]\n-    macro_rules! error { ($e:expr, $s:expr) => (\n-        match $e {\n-            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-            Err(ref err) => assert!(err.raw_os_error() == Some($s),\n-                                    format!(\"`{}` did not have a code of `{}`\", err, $s))\n-        }\n-    ) }\n+    macro_rules! error {\n+        ($e:expr, $s:expr) => {\n+            match $e {\n+                Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n+                Err(ref err) => assert!(\n+                    err.raw_os_error() == Some($s),\n+                    format!(\"`{}` did not have a code of `{}`\", err, $s)\n+                ),\n+            }\n+        };\n+    }\n \n     #[cfg(unix)]\n-    macro_rules! error { ($e:expr, $s:expr) => ( error_contains!($e, $s) ) }\n-\n-    macro_rules! error_contains { ($e:expr, $s:expr) => (\n-        match $e {\n-            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-            Err(ref err) => assert!(err.to_string().contains($s),\n-                                    format!(\"`{}` did not contain `{}`\", err, $s))\n-        }\n-    ) }\n+    macro_rules! error {\n+        ($e:expr, $s:expr) => {\n+            error_contains!($e, $s)\n+        };\n+    }\n+\n+    macro_rules! error_contains {\n+        ($e:expr, $s:expr) => {\n+            match $e {\n+                Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n+                Err(ref err) => assert!(\n+                    err.to_string().contains($s),\n+                    format!(\"`{}` did not contain `{}`\", err, $s)\n+                ),\n+            }\n+        };\n+    }\n \n     // Several test fail on windows if the user does not have permission to\n     // create symlinks (the `SeCreateSymbolicLinkPrivilege`). Instead of\n@@ -2251,7 +2299,9 @@ mod tests {\n     // tests most of the time, but at least we do if the user has the right\n     // permissions.\n     pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n-        if cfg!(unix) { return true }\n+        if cfg!(unix) {\n+            return true;\n+        }\n         let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n \n         match symlink_file(r\"nonexisting_target\", link) {\n@@ -2276,7 +2326,7 @@ mod tests {\n             let mut read_buf = [0; 1028];\n             let read_str = match check!(read_stream.read(&mut read_buf)) {\n                 0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(&read_buf[..n]).unwrap().to_string()\n+                n => str::from_utf8(&read_buf[..n]).unwrap().to_string(),\n             };\n             assert_eq!(read_str, message);\n         }\n@@ -2363,9 +2413,9 @@ mod tests {\n \n     #[test]\n     fn file_test_io_seek_and_write() {\n-        let initial_msg =   \"food-is-yummy\";\n-        let overwrite_msg =    \"-the-bar!!\";\n-        let final_msg =     \"foo-the-bar!!\";\n+        let initial_msg = \"food-is-yummy\";\n+        let overwrite_msg = \"-the-bar!!\";\n+        let final_msg = \"foo-the-bar!!\";\n         let seek_idx = 3;\n         let mut read_mem = [0; 13];\n         let tmpdir = tmpdir();\n@@ -2388,7 +2438,7 @@ mod tests {\n     #[test]\n     fn file_test_io_seek_shakedown() {\n         //                   01234567890123\n-        let initial_msg =   \"qwer-asdf-zxcv\";\n+        let initial_msg = \"qwer-asdf-zxcv\";\n         let chunk_one: &str = \"qwer\";\n         let chunk_two: &str = \"asdf\";\n         let chunk_three: &str = \"zxcv\";\n@@ -2497,13 +2547,11 @@ mod tests {\n         check!(fs::create_dir(filename));\n         let mask = 0o7777;\n \n-        check!(fs::set_permissions(filename,\n-                                   fs::Permissions::from_mode(0)));\n+        check!(fs::set_permissions(filename, fs::Permissions::from_mode(0)));\n         let metadata0 = check!(fs::metadata(filename));\n         assert_eq!(mask & metadata0.permissions().mode(), 0);\n \n-        check!(fs::set_permissions(filename,\n-                                   fs::Permissions::from_mode(0o1777)));\n+        check!(fs::set_permissions(filename, fs::Permissions::from_mode(0o1777)));\n         let metadata1 = check!(fs::metadata(filename));\n         assert_eq!(mask & metadata1.permissions().mode(), 0o1777);\n     }\n@@ -2568,8 +2616,7 @@ mod tests {\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n         {\n             let mut opts = OpenOptions::new();\n-            let mut fs = check!(opts.read(true).write(true)\n-                                    .create(true).open(filename));\n+            let mut fs = check!(opts.read(true).write(true).create(true).open(filename));\n             let msg = \"hw\";\n             fs.write(msg.as_bytes()).unwrap();\n \n@@ -2703,7 +2750,7 @@ mod tests {\n             for _ in 0..40 {\n                 dir = dir.join(\"a\");\n             }\n-            let mut join = vec!();\n+            let mut join = vec![];\n             for _ in 0..8 {\n                 let dir = dir.clone();\n                 join.push(thread::spawn(move || {\n@@ -2771,7 +2818,9 @@ mod tests {\n     #[cfg(windows)]\n     fn recursive_rmdir_of_file_symlink() {\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         let f1 = tmpdir.join(\"f1\");\n         let f2 = tmpdir.join(\"f2\");\n@@ -2854,8 +2903,7 @@ mod tests {\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n         assert_eq!(v, b\"hello\");\n \n-        assert_eq!(check!(input.metadata()).permissions(),\n-                   check!(out.metadata()).permissions());\n+        assert_eq!(check!(input.metadata()).permissions(), check!(out.metadata()).permissions());\n     }\n \n     #[test]\n@@ -2865,7 +2913,8 @@ mod tests {\n \n         check!(File::create(&out));\n         match fs::copy(&*out, tmpdir.path()) {\n-            Ok(..) => panic!(), Err(..) => {}\n+            Ok(..) => panic!(),\n+            Err(..) => {}\n         }\n     }\n \n@@ -2890,7 +2939,8 @@ mod tests {\n         let out = tmpdir.join(\"out\");\n \n         match fs::copy(tmpdir.path(), &out) {\n-            Ok(..) => panic!(), Err(..) => {}\n+            Ok(..) => panic!(),\n+            Err(..) => {}\n         }\n         assert!(!out.exists());\n     }\n@@ -2938,7 +2988,9 @@ mod tests {\n     #[test]\n     fn copy_file_follows_dst_symlink() {\n         let tmp = tmpdir();\n-        if !got_symlink_permission(&tmp) { return };\n+        if !got_symlink_permission(&tmp) {\n+            return;\n+        };\n \n         let in_path = tmp.join(\"in.txt\");\n         let out_path = tmp.join(\"out.txt\");\n@@ -2958,16 +3010,17 @@ mod tests {\n     #[test]\n     fn symlinks_work() {\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n         check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n         check!(symlink_file(&input, &out));\n         assert!(check!(out.symlink_metadata()).file_type().is_symlink());\n-        assert_eq!(check!(fs::metadata(&out)).len(),\n-                   check!(fs::metadata(&input)).len());\n+        assert_eq!(check!(fs::metadata(&out)).len(), check!(fs::metadata(&input)).len());\n         let mut v = Vec::new();\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n         assert_eq!(v, b\"foobar\".to_vec());\n@@ -2977,31 +3030,40 @@ mod tests {\n     fn symlink_noexist() {\n         // Symlinks can point to things that don't exist\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         // Use a relative path for testing. Symlinks get normalized by Windows,\n         // so we may not get the same path back for absolute paths\n         check!(symlink_file(&\"foo\", &tmpdir.join(\"bar\")));\n-        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))).to_str().unwrap(),\n-                   \"foo\");\n+        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))).to_str().unwrap(), \"foo\");\n     }\n \n     #[test]\n     fn read_link() {\n         if cfg!(windows) {\n             // directory symlink\n-            assert_eq!(check!(fs::read_link(r\"C:\\Users\\All Users\")).to_str().unwrap(),\n-                       r\"C:\\ProgramData\");\n+            assert_eq!(\n+                check!(fs::read_link(r\"C:\\Users\\All Users\")).to_str().unwrap(),\n+                r\"C:\\ProgramData\"\n+            );\n             // junction\n-            assert_eq!(check!(fs::read_link(r\"C:\\Users\\Default User\")).to_str().unwrap(),\n-                       r\"C:\\Users\\Default\");\n+            assert_eq!(\n+                check!(fs::read_link(r\"C:\\Users\\Default User\")).to_str().unwrap(),\n+                r\"C:\\Users\\Default\"\n+            );\n             // junction with special permissions\n-            assert_eq!(check!(fs::read_link(r\"C:\\Documents and Settings\\\")).to_str().unwrap(),\n-                       r\"C:\\Users\");\n+            assert_eq!(\n+                check!(fs::read_link(r\"C:\\Documents and Settings\\\")).to_str().unwrap(),\n+                r\"C:\\Users\"\n+            );\n         }\n         let tmpdir = tmpdir();\n         let link = tmpdir.join(\"link\");\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n         check!(symlink_file(&\"foo\", &link));\n         assert_eq!(check!(fs::read_link(&link)).to_str().unwrap(), \"foo\");\n     }\n@@ -3023,10 +3085,8 @@ mod tests {\n \n         check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n         check!(fs::hard_link(&input, &out));\n-        assert_eq!(check!(fs::metadata(&out)).len(),\n-                   check!(fs::metadata(&input)).len());\n-        assert_eq!(check!(fs::metadata(&out)).len(),\n-                   check!(input.metadata()).len());\n+        assert_eq!(check!(fs::metadata(&out)).len(), check!(fs::metadata(&input)).len());\n+        assert_eq!(check!(fs::metadata(&out)).len(), check!(input.metadata()).len());\n         let mut v = Vec::new();\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n         assert_eq!(v, b\"foobar\".to_vec());\n@@ -3134,15 +3194,22 @@ mod tests {\n     #[test]\n     fn open_flavors() {\n         use crate::fs::OpenOptions as OO;\n-        fn c<T: Clone>(t: &T) -> T { t.clone() }\n+        fn c<T: Clone>(t: &T) -> T {\n+            t.clone()\n+        }\n \n         let tmpdir = tmpdir();\n \n-        let mut r = OO::new(); r.read(true);\n-        let mut w = OO::new(); w.write(true);\n-        let mut rw = OO::new(); rw.read(true).write(true);\n-        let mut a = OO::new(); a.append(true);\n-        let mut ra = OO::new(); ra.read(true).append(true);\n+        let mut r = OO::new();\n+        r.read(true);\n+        let mut w = OO::new();\n+        w.write(true);\n+        let mut rw = OO::new();\n+        rw.read(true).write(true);\n+        let mut a = OO::new();\n+        a.append(true);\n+        let mut ra = OO::new();\n+        ra.read(true).append(true);\n \n         #[cfg(windows)]\n         let invalid_options = 87; // ERROR_INVALID_PARAMETER\n@@ -3201,7 +3268,7 @@ mod tests {\n \n         // Test opening a file without setting an access mode\n         let mut blank = OO::new();\n-         error!(blank.create(true).open(&tmpdir.join(\"f\")), invalid_options);\n+        error!(blank.create(true).open(&tmpdir.join(\"f\")), invalid_options);\n \n         // Test write works\n         check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foobar\".as_bytes()));\n@@ -3279,8 +3346,10 @@ mod tests {\n         assert!(v == &bytes[..]);\n \n         check!(fs::write(&tmpdir.join(\"not-utf8\"), &[0xFF]));\n-        error_contains!(fs::read_to_string(&tmpdir.join(\"not-utf8\")),\n-                        \"stream did not contain valid UTF-8\");\n+        error_contains!(\n+            fs::read_to_string(&tmpdir.join(\"not-utf8\")),\n+            \"stream did not contain valid UTF-8\"\n+        );\n \n         let s = \"\ud800\udc41\ud800\udc13\ud800\udc20\ud800\udc34\ud800\udc0d\";\n         check!(fs::write(&tmpdir.join(\"utf8\"), s.as_bytes()));\n@@ -3292,11 +3361,9 @@ mod tests {\n     fn file_try_clone() {\n         let tmpdir = tmpdir();\n \n-        let mut f1 = check!(OpenOptions::new()\n-                                       .read(true)\n-                                       .write(true)\n-                                       .create(true)\n-                                       .open(&tmpdir.join(\"test\")));\n+        let mut f1 = check!(\n+            OpenOptions::new().read(true).write(true).create(true).open(&tmpdir.join(\"test\"))\n+        );\n         let mut f2 = check!(f1.try_clone());\n \n         check!(f1.write_all(b\"hello world\"));\n@@ -3341,7 +3408,9 @@ mod tests {\n     #[test]\n     fn realpath_works() {\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n         let file = tmpdir.join(\"test\");\n@@ -3366,7 +3435,9 @@ mod tests {\n     #[test]\n     fn realpath_works_tricky() {\n         let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n \n         let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n         let a = tmpdir.join(\"a\");\n@@ -3452,7 +3523,9 @@ mod tests {\n         assert!(junction.is_dir());\n         assert!(b.exists());\n \n-        if !got_symlink_permission(&tmpdir) { return };\n+        if !got_symlink_permission(&tmpdir) {\n+            return;\n+        };\n         check!(symlink_dir(&target, &link));\n         check!(fs::create_dir_all(&d));\n         assert!(link.is_dir());\n@@ -3482,8 +3555,8 @@ mod tests {\n             // Not always available\n             match (a.created(), b.created()) {\n                 (Ok(t1), Ok(t2)) => assert!(t1 <= t2),\n-                (Err(e1), Err(e2)) if e1.kind() == ErrorKind::Other &&\n-                                      e2.kind() == ErrorKind::Other => {}\n+                (Err(e1), Err(e2))\n+                    if e1.kind() == ErrorKind::Other && e2.kind() == ErrorKind::Other => {}\n                 (a, b) => panic!(\n                     \"creation time must be always supported or not supported: {:?} {:?}\",\n                     a, b,"}, {"sha": "8e81b292f6fa38fc1315b494d3f71d6d23ad468e", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 80, "deletions": 67, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -5,8 +5,9 @@ use crate::io::prelude::*;\n use crate::cmp;\n use crate::error;\n use crate::fmt;\n-use crate::io::{self, Initializer, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom, IoSlice,\n-        IoSliceMut};\n+use crate::io::{\n+    self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom, DEFAULT_BUF_SIZE,\n+};\n use crate::memchr;\n \n /// The `BufReader<R>` struct adds buffering to any reader.\n@@ -100,12 +101,7 @@ impl<R: Read> BufReader<R> {\n             let mut buffer = Vec::with_capacity(capacity);\n             buffer.set_len(capacity);\n             inner.initializer().initialize(&mut buffer);\n-            BufReader {\n-                inner,\n-                buf: buffer.into_boxed_slice(),\n-                pos: 0,\n-                cap: 0,\n-            }\n+            BufReader { inner, buf: buffer.into_boxed_slice(), pos: 0, cap: 0 }\n         }\n     }\n }\n@@ -130,7 +126,9 @@ impl<R> BufReader<R> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &R { &self.inner }\n+    pub fn get_ref(&self) -> &R {\n+        &self.inner\n+    }\n \n     /// Gets a mutable reference to the underlying reader.\n     ///\n@@ -151,7 +149,9 @@ impl<R> BufReader<R> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n+    pub fn get_mut(&mut self) -> &mut R {\n+        &mut self.inner\n+    }\n \n     /// Returns a reference to the internally buffered data.\n     ///\n@@ -199,7 +199,9 @@ impl<R> BufReader<R> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> R { self.inner }\n+    pub fn into_inner(self) -> R {\n+        self.inner\n+    }\n \n     /// Invalidates all data in the internal buffer.\n     #[inline]\n@@ -220,17 +222,17 @@ impl<R: Seek> BufReader<R> {\n         if offset < 0 {\n             if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n                 self.pos = new_pos as usize;\n-                return Ok(())\n+                return Ok(());\n             }\n         } else {\n             if let Some(new_pos) = pos.checked_add(offset as u64) {\n                 if new_pos <= self.cap as u64 {\n                     self.pos = new_pos as usize;\n-                    return Ok(())\n+                    return Ok(());\n                 }\n             }\n         }\n-        self.seek(SeekFrom::Current(offset)).map(|_|())\n+        self.seek(SeekFrom::Current(offset)).map(|_| ())\n     }\n }\n \n@@ -293,7 +295,10 @@ impl<R: Read> BufRead for BufReader<R> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n+impl<R> fmt::Debug for BufReader<R>\n+where\n+    R: fmt::Debug,\n+{\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufReader\")\n             .field(\"reader\", &self.inner)\n@@ -483,11 +488,7 @@ impl<W: Write> BufWriter<W> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n-        BufWriter {\n-            inner: Some(inner),\n-            buf: Vec::with_capacity(capacity),\n-            panicked: false,\n-        }\n+        BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n     }\n \n     fn flush_buf(&mut self) -> io::Result<()> {\n@@ -501,14 +502,16 @@ impl<W: Write> BufWriter<W> {\n \n             match r {\n                 Ok(0) => {\n-                    ret = Err(Error::new(ErrorKind::WriteZero,\n-                                         \"failed to write the buffered data\"));\n+                    ret =\n+                        Err(Error::new(ErrorKind::WriteZero, \"failed to write the buffered data\"));\n                     break;\n                 }\n                 Ok(n) => written += n,\n                 Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => { ret = Err(e); break }\n-\n+                Err(e) => {\n+                    ret = Err(e);\n+                    break;\n+                }\n             }\n         }\n         if written > 0 {\n@@ -531,7 +534,9 @@ impl<W: Write> BufWriter<W> {\n     /// let reference = buffer.get_ref();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.as_ref().unwrap()\n+    }\n \n     /// Gets a mutable reference to the underlying writer.\n     ///\n@@ -549,7 +554,9 @@ impl<W: Write> BufWriter<W> {\n     /// let reference = buffer.get_mut();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n+    pub fn get_mut(&mut self) -> &mut W {\n+        self.inner.as_mut().unwrap()\n+    }\n \n     /// Returns a reference to the internally buffered data.\n     ///\n@@ -592,7 +599,7 @@ impl<W: Write> BufWriter<W> {\n     pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n         match self.flush_buf() {\n             Err(e) => Err(IntoInnerError(self, e)),\n-            Ok(()) => Ok(self.inner.take().unwrap())\n+            Ok(()) => Ok(self.inner.take().unwrap()),\n         }\n     }\n }\n@@ -634,7 +641,10 @@ impl<W: Write> Write for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n+impl<W: Write> fmt::Debug for BufWriter<W>\n+where\n+    W: fmt::Debug,\n+{\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"BufWriter\")\n             .field(\"writer\", &self.inner.as_ref().unwrap())\n@@ -693,7 +703,9 @@ impl<W> IntoInnerError<W> {\n     /// };\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn error(&self) -> &Error { &self.1 }\n+    pub fn error(&self) -> &Error {\n+        &self.1\n+    }\n \n     /// Returns the buffered writer instance which generated the error.\n     ///\n@@ -726,12 +738,16 @@ impl<W> IntoInnerError<W> {\n     /// };\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> W { self.0 }\n+    pub fn into_inner(self) -> W {\n+        self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W> From<IntoInnerError<W>> for Error {\n-    fn from(iie: IntoInnerError<W>) -> Error { iie.1 }\n+    fn from(iie: IntoInnerError<W>) -> Error {\n+        iie.1\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -856,10 +872,7 @@ impl<W: Write> LineWriter<W> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n-        LineWriter {\n-            inner: BufWriter::with_capacity(capacity, inner),\n-            need_flush: false,\n-        }\n+        LineWriter { inner: BufWriter::with_capacity(capacity, inner), need_flush: false }\n     }\n \n     /// Gets a reference to the underlying writer.\n@@ -879,7 +892,9 @@ impl<W: Write> LineWriter<W> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W { self.inner.get_ref() }\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.get_ref()\n+    }\n \n     /// Gets a mutable reference to the underlying writer.\n     ///\n@@ -902,7 +917,9 @@ impl<W: Write> LineWriter<W> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut W { self.inner.get_mut() }\n+    pub fn get_mut(&mut self) -> &mut W {\n+        self.inner.get_mut()\n+    }\n \n     /// Unwraps this `LineWriter`, returning the underlying writer.\n     ///\n@@ -930,10 +947,7 @@ impl<W: Write> LineWriter<W> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n         self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n-            IntoInnerError(LineWriter {\n-                inner: buf,\n-                need_flush: false,\n-            }, e)\n+            IntoInnerError(LineWriter { inner: buf, need_flush: false }, e)\n         })\n     }\n }\n@@ -953,7 +967,6 @@ impl<W: Write> Write for LineWriter<W> {\n             None => return self.inner.write(buf),\n         };\n \n-\n         // Ok, we're going to write a partial amount of the data given first\n         // followed by flushing the newline. After we've successfully written\n         // some data then we *must* report that we wrote that data, so future\n@@ -962,7 +975,7 @@ impl<W: Write> Write for LineWriter<W> {\n         let n = self.inner.write(&buf[..=i])?;\n         self.need_flush = true;\n         if self.flush().is_err() || n != i + 1 {\n-            return Ok(n)\n+            return Ok(n);\n         }\n \n         // At this point we successfully wrote `i + 1` bytes and flushed it out,\n@@ -984,12 +997,17 @@ impl<W: Write> Write for LineWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n+impl<W: Write> fmt::Debug for LineWriter<W>\n+where\n+    W: fmt::Debug,\n+{\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"LineWriter\")\n             .field(\"writer\", &self.inner.inner)\n-            .field(\"buffer\",\n-                   &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()))\n+            .field(\n+                \"buffer\",\n+                &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()),\n+            )\n             .finish()\n     }\n }\n@@ -1008,11 +1026,7 @@ mod tests {\n \n     impl Read for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-            if self.lengths.is_empty() {\n-                Ok(0)\n-            } else {\n-                Ok(self.lengths.remove(0))\n-            }\n+            if self.lengths.is_empty() { Ok(0) } else { Ok(self.lengths.remove(0)) }\n         }\n     }\n \n@@ -1123,7 +1137,7 @@ mod tests {\n     fn test_buffered_reader_seek_underflow() {\n         // gimmick reader that yields its position modulo 256 for each byte\n         struct PositionReader {\n-            pos: u64\n+            pos: u64,\n         }\n         impl Read for PositionReader {\n             fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -1154,7 +1168,7 @@ mod tests {\n \n         let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n         assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n-        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::max_value()-5));\n+        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::max_value() - 5));\n         assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n         // the following seek will require two underlying seeks\n         let expected = 9223372036854775802;\n@@ -1361,7 +1375,7 @@ mod tests {\n \n     #[test]\n     fn test_short_reads() {\n-        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n+        let inner = ShortReader { lengths: vec![0, 1, 2, 0, 1, 0] };\n         let mut reader = BufReader::new(inner);\n         let mut buf = [0, 0];\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n@@ -1379,7 +1393,9 @@ mod tests {\n         struct FailFlushWriter;\n \n         impl Write for FailFlushWriter {\n-            fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+                Ok(buf.len())\n+            }\n             fn flush(&mut self) -> io::Result<()> {\n                 Err(io::Error::last_os_error())\n             }\n@@ -1405,30 +1421,30 @@ mod tests {\n                 WRITES.fetch_add(1, Ordering::SeqCst);\n                 panic!();\n             }\n-            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+            fn flush(&mut self) -> io::Result<()> {\n+                Ok(())\n+            }\n         }\n \n         thread::spawn(|| {\n             let mut writer = BufWriter::new(PanicWriter);\n             let _ = writer.write(b\"hello world\");\n             let _ = writer.flush();\n-        }).join().unwrap_err();\n+        })\n+        .join()\n+        .unwrap_err();\n \n         assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n     }\n \n     #[bench]\n     fn bench_buffered_reader(b: &mut test::Bencher) {\n-        b.iter(|| {\n-            BufReader::new(io::empty())\n-        });\n+        b.iter(|| BufReader::new(io::empty()));\n     }\n \n     #[bench]\n     fn bench_buffered_writer(b: &mut test::Bencher) {\n-        b.iter(|| {\n-            BufWriter::new(io::sink())\n-        });\n+        b.iter(|| BufWriter::new(io::sink()));\n     }\n \n     struct AcceptOneThenFail {\n@@ -1457,10 +1473,7 @@ mod tests {\n \n     #[test]\n     fn erroneous_flush_retried() {\n-        let a = AcceptOneThenFail {\n-            written: false,\n-            flushed: false,\n-        };\n+        let a = AcceptOneThenFail { written: false, flushed: false };\n \n         let mut l = LineWriter::new(a);\n         assert_eq!(l.write(b\"a\\nb\\na\").unwrap(), 4);"}, {"sha": "c20bd3097b27dea93720d637d91db3a814ac85e1", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,8 +1,8 @@\n+use crate::convert::From;\n use crate::error;\n use crate::fmt;\n use crate::result;\n use crate::sys;\n-use crate::convert::From;\n \n /// A specialized [`Result`](../result/enum.Result.html) type for I/O\n /// operations.\n@@ -73,7 +73,7 @@ enum Repr {\n #[derive(Debug)]\n struct Custom {\n     kind: ErrorKind,\n-    error: Box<dyn error::Error+Send+Sync>,\n+    error: Box<dyn error::Error + Send + Sync>,\n }\n \n /// A list specifying general categories of I/O error.\n@@ -220,9 +220,7 @@ impl From<ErrorKind> for Error {\n     /// [`Error`]: ../../std/io/struct.Error.html\n     #[inline]\n     fn from(kind: ErrorKind) -> Error {\n-        Error {\n-            repr: Repr::Simple(kind)\n-        }\n+        Error { repr: Repr::Simple(kind) }\n     }\n }\n \n@@ -247,18 +245,14 @@ impl Error {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<E>(kind: ErrorKind, error: E) -> Error\n-        where E: Into<Box<dyn error::Error+Send+Sync>>\n+    where\n+        E: Into<Box<dyn error::Error + Send + Sync>>,\n     {\n         Self::_new(kind, error.into())\n     }\n \n-    fn _new(kind: ErrorKind, error: Box<dyn error::Error+Send+Sync>) -> Error {\n-        Error {\n-            repr: Repr::Custom(Box::new(Custom {\n-                kind,\n-                error,\n-            }))\n-        }\n+    fn _new(kind: ErrorKind, error: Box<dyn error::Error + Send + Sync>) -> Error {\n+        Error { repr: Repr::Custom(Box::new(Custom { kind, error })) }\n     }\n \n     /// Returns an error representing the last OS error which occurred.\n@@ -370,7 +364,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n-    pub fn get_ref(&self) -> Option<&(dyn error::Error+Send+Sync+'static)> {\n+    pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n@@ -441,7 +435,7 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n-    pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error+Send+Sync+'static)> {\n+    pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n@@ -475,11 +469,11 @@ impl Error {\n     /// }\n     /// ```\n     #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n-    pub fn into_inner(self) -> Option<Box<dyn error::Error+Send+Sync>> {\n+    pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n-            Repr::Custom(c) => Some(c.error)\n+            Repr::Custom(c) => Some(c.error),\n         }\n     }\n \n@@ -514,11 +508,12 @@ impl Error {\n impl fmt::Debug for Repr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            Repr::Os(code) =>\n-                fmt.debug_struct(\"Os\")\n-                    .field(\"code\", &code)\n-                    .field(\"kind\", &sys::decode_error_kind(code))\n-                    .field(\"message\", &sys::os::error_string(code)).finish(),\n+            Repr::Os(code) => fmt\n+                .debug_struct(\"Os\")\n+                .field(\"code\", &code)\n+                .field(\"kind\", &sys::decode_error_kind(code))\n+                .field(\"message\", &sys::os::error_string(code))\n+                .finish(),\n             Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n             Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n         }\n@@ -567,17 +562,17 @@ impl error::Error for Error {\n }\n \n fn _assert_error_is_sync_send() {\n-    fn _is_sync_send<T: Sync+Send>() {}\n+    fn _is_sync_send<T: Sync + Send>() {}\n     _is_sync_send::<Error>();\n }\n \n #[cfg(test)]\n mod test {\n-    use super::{Error, ErrorKind, Repr, Custom};\n+    use super::{Custom, Error, ErrorKind, Repr};\n     use crate::error;\n     use crate::fmt;\n-    use crate::sys::os::error_string;\n     use crate::sys::decode_error_kind;\n+    use crate::sys::os::error_string;\n \n     #[test]\n     fn test_debug_error() {\n@@ -587,20 +582,18 @@ mod test {\n         let err = Error {\n             repr: Repr::Custom(box Custom {\n                 kind: ErrorKind::InvalidInput,\n-                error: box Error {\n-                    repr: super::Repr::Os(code)\n-                },\n-            })\n+                error: box Error { repr: super::Repr::Os(code) },\n+            }),\n         };\n         let expected = format!(\n             \"Custom {{ \\\n-                kind: InvalidInput, \\\n-                error: Os {{ \\\n-                    code: {:?}, \\\n-                    kind: {:?}, \\\n-                    message: {:?} \\\n-                }} \\\n-            }}\",\n+             kind: InvalidInput, \\\n+             error: Os {{ \\\n+             code: {:?}, \\\n+             kind: {:?}, \\\n+             message: {:?} \\\n+             }} \\\n+             }}\",\n             code, kind, msg\n         );\n         assert_eq!(format!(\"{:?}\", err), expected);"}, {"sha": "b7f82e652990d993b27dd6d5c977856884e09bd5", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,7 +1,8 @@\n use crate::cmp;\n-use crate::io::{self, SeekFrom, Read, Initializer, Write, Seek, BufRead, Error, ErrorKind,\n-        IoSliceMut, IoSlice};\n use crate::fmt;\n+use crate::io::{\n+    self, BufRead, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n+};\n use crate::mem;\n \n // =============================================================================\n@@ -42,15 +43,19 @@ impl<R: Read + ?Sized> Read for &mut R {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write + ?Sized> Write for &mut W {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        (**self).write(buf)\n+    }\n \n     #[inline]\n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         (**self).write_vectored(bufs)\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (**self).flush()\n+    }\n \n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n@@ -65,15 +70,21 @@ impl<W: Write + ?Sized> Write for &mut W {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Seek + ?Sized> Seek for &mut S {\n     #[inline]\n-    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        (**self).seek(pos)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: BufRead + ?Sized> BufRead for &mut B {\n     #[inline]\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        (**self).fill_buf()\n+    }\n \n     #[inline]\n-    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+    fn consume(&mut self, amt: usize) {\n+        (**self).consume(amt)\n+    }\n \n     #[inline]\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -121,15 +132,19 @@ impl<R: Read + ?Sized> Read for Box<R> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write + ?Sized> Write for Box<W> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { (**self).write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        (**self).write(buf)\n+    }\n \n     #[inline]\n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         (**self).write_vectored(bufs)\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { (**self).flush() }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (**self).flush()\n+    }\n \n     #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n@@ -144,15 +159,21 @@ impl<W: Write + ?Sized> Write for Box<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Seek + ?Sized> Seek for Box<S> {\n     #[inline]\n-    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { (**self).seek(pos) }\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        (**self).seek(pos)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: BufRead + ?Sized> BufRead for Box<B> {\n     #[inline]\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        (**self).fill_buf()\n+    }\n \n     #[inline]\n-    fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n+    fn consume(&mut self, amt: usize) {\n+        (**self).consume(amt)\n+    }\n \n     #[inline]\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -227,8 +248,7 @@ impl Read for &[u8] {\n     #[inline]\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         if buf.len() > self.len() {\n-            return Err(Error::new(ErrorKind::UnexpectedEof,\n-                                  \"failed to fill whole buffer\"));\n+            return Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"));\n         }\n         let (a, b) = self.split_at(buf.len());\n \n@@ -257,10 +277,14 @@ impl Read for &[u8] {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BufRead for &[u8] {\n     #[inline]\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(*self) }\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        Ok(*self)\n+    }\n \n     #[inline]\n-    fn consume(&mut self, amt: usize) { *self = &self[amt..]; }\n+    fn consume(&mut self, amt: usize) {\n+        *self = &self[amt..];\n+    }\n }\n \n /// Write is implemented for `&mut [u8]` by copying into the slice, overwriting\n@@ -302,7 +326,9 @@ impl Write for &mut [u8] {\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n /// Write is implemented for `Vec<u8>` by appending to the vector.\n@@ -332,7 +358,9 @@ impl Write for Vec<u8> {\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "20c1c5cd1b8ad9bfa84d9c851e050eaab73a416c", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 89, "deletions": 79, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -261,49 +261,54 @@\n \n use crate::cmp;\n use crate::fmt;\n-use crate::slice;\n-use crate::str;\n use crate::memchr;\n use crate::ops::{Deref, DerefMut};\n use crate::ptr;\n+use crate::slice;\n+use crate::str;\n use crate::sys;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::buffered::{BufReader, BufWriter, LineWriter};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::IntoInnerError;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::cursor::Cursor;\n+pub use self::buffered::{BufReader, BufWriter, LineWriter};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::error::{Result, Error, ErrorKind};\n+pub use self::cursor::Cursor;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::util::{copy, sink, Sink, empty, Empty, repeat, Repeat};\n+pub use self::error::{Error, ErrorKind, Result};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::stdio::{stdin, stdout, stderr, Stdin, Stdout, Stderr};\n+pub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::stdio::{StdoutLock, StderrLock, StdinLock};\n+pub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n #[unstable(feature = \"print_internals\", issue = \"0\")]\n-pub use self::stdio::{_print, _eprint};\n+pub use self::stdio::{_eprint, _print};\n #[unstable(feature = \"libstd_io_internals\", issue = \"42788\")]\n #[doc(no_inline, hidden)]\n pub use self::stdio::{set_panic, set_print};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::util::{copy, empty, repeat, sink, Empty, Repeat, Sink};\n \n-pub mod prelude;\n mod buffered;\n mod cursor;\n mod error;\n mod impls;\n mod lazy;\n-mod util;\n+pub mod prelude;\n mod stdio;\n+mod util;\n \n const DEFAULT_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n \n-struct Guard<'a> { buf: &'a mut Vec<u8>, len: usize }\n+struct Guard<'a> {\n+    buf: &'a mut Vec<u8>,\n+    len: usize,\n+}\n \n impl Drop for Guard<'_> {\n     fn drop(&mut self) {\n-        unsafe { self.buf.set_len(self.len); }\n+        unsafe {\n+            self.buf.set_len(self.len);\n+        }\n     }\n }\n \n@@ -326,15 +331,15 @@ impl Drop for Guard<'_> {\n //    the function only *appends* bytes to the buffer. We'll get undefined\n //    behavior if existing bytes are overwritten to have non-UTF-8 data.\n fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n-    where F: FnOnce(&mut Vec<u8>) -> Result<usize>\n+where\n+    F: FnOnce(&mut Vec<u8>) -> Result<usize>,\n {\n     unsafe {\n         let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };\n         let ret = f(g.buf);\n         if str::from_utf8(&g.buf[g.len..]).is_err() {\n             ret.and_then(|_| {\n-                Err(Error::new(ErrorKind::InvalidData,\n-                               \"stream did not contain valid UTF-8\"))\n+                Err(Error::new(ErrorKind::InvalidData, \"stream did not contain valid UTF-8\"))\n             })\n         } else {\n             g.len = g.buf.len();\n@@ -405,23 +410,17 @@ where\n \n pub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>\n where\n-    F: FnOnce(&mut [u8]) -> Result<usize>\n+    F: FnOnce(&mut [u8]) -> Result<usize>,\n {\n-    let buf = bufs\n-        .iter_mut()\n-        .find(|b| !b.is_empty())\n-        .map_or(&mut [][..], |b| &mut **b);\n+    let buf = bufs.iter_mut().find(|b| !b.is_empty()).map_or(&mut [][..], |b| &mut **b);\n     read(buf)\n }\n \n pub(crate) fn default_write_vectored<F>(write: F, bufs: &[IoSlice<'_>]) -> Result<usize>\n where\n-    F: FnOnce(&[u8]) -> Result<usize>\n+    F: FnOnce(&[u8]) -> Result<usize>,\n {\n-    let buf = bufs\n-        .iter()\n-        .find(|b| !b.is_empty())\n-        .map_or(&[][..], |b| &**b);\n+    let buf = bufs.iter().find(|b| !b.is_empty()).map_or(&[][..], |b| &**b);\n     write(buf)\n }\n \n@@ -767,14 +766,16 @@ pub trait Read {\n         while !buf.is_empty() {\n             match self.read(buf) {\n                 Ok(0) => break,\n-                Ok(n) => { let tmp = buf; buf = &mut tmp[n..]; }\n+                Ok(n) => {\n+                    let tmp = buf;\n+                    buf = &mut tmp[n..];\n+                }\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                 Err(e) => return Err(e),\n             }\n         }\n         if !buf.is_empty() {\n-            Err(Error::new(ErrorKind::UnexpectedEof,\n-                           \"failed to fill whole buffer\"))\n+            Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -815,7 +816,12 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n+    fn by_ref(&mut self) -> &mut Self\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n \n     /// Transforms this `Read` instance to an [`Iterator`] over its bytes.\n     ///\n@@ -852,7 +858,10 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn bytes(self) -> Bytes<Self> where Self: Sized {\n+    fn bytes(self) -> Bytes<Self>\n+    where\n+        Self: Sized,\n+    {\n         Bytes { inner: self }\n     }\n \n@@ -887,7 +896,10 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized {\n+    fn chain<R: Read>(self, next: R) -> Chain<Self, R>\n+    where\n+        Self: Sized,\n+    {\n         Chain { first: self, second: next, done_first: false }\n     }\n \n@@ -923,7 +935,10 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n+    fn take(self, limit: u64) -> Take<Self>\n+    where\n+        Self: Sized,\n+    {\n         Take { inner: self, limit: limit }\n     }\n }\n@@ -1339,8 +1354,9 @@ pub trait Write {\n     fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n         while !buf.is_empty() {\n             match self.write(buf) {\n-                Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n-                                               \"failed to write whole buffer\")),\n+                Ok(0) => {\n+                    return Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"));\n+                }\n                 Ok(n) => buf = &buf[n..],\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                 Err(e) => return Err(e),\n@@ -1444,7 +1460,12 @@ pub trait Write {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n+    fn by_ref(&mut self) -> &mut Self\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n }\n \n /// The `Seek` trait provides a cursor which can be moved within a stream of\n@@ -1601,15 +1622,14 @@ pub enum SeekFrom {\n     Current(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n }\n \n-fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n-                                   -> Result<usize> {\n+fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> Result<usize> {\n     let mut read = 0;\n     loop {\n         let (done, used) = {\n             let available = match r.fill_buf() {\n                 Ok(n) => n,\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n-                Err(e) => return Err(e)\n+                Err(e) => return Err(e),\n             };\n             match memchr::memchr(delim, available) {\n                 Some(i) => {\n@@ -1900,7 +1920,10 @@ pub trait BufRead: Read {\n     /// assert_eq!(split_iter.next(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n+    fn split(self, byte: u8) -> Split<Self>\n+    where\n+        Self: Sized,\n+    {\n         Split { buf: self, delim: byte }\n     }\n \n@@ -1939,7 +1962,10 @@ pub trait BufRead: Read {\n     ///\n     /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn lines(self) -> Lines<Self> where Self: Sized {\n+    fn lines(self) -> Lines<Self>\n+    where\n+        Self: Sized,\n+    {\n         Lines { buf: self }\n     }\n }\n@@ -2035,10 +2061,7 @@ impl<T, U> Chain<T, U> {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<T: fmt::Debug, U: fmt::Debug> fmt::Debug for Chain<T, U> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Chain\")\n-            .field(\"t\", &self.first)\n-            .field(\"u\", &self.second)\n-            .finish()\n+        f.debug_struct(\"Chain\").field(\"t\", &self.first).field(\"u\", &self.second).finish()\n     }\n }\n \n@@ -2066,11 +2089,7 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n \n     unsafe fn initializer(&self) -> Initializer {\n         let initializer = self.first.initializer();\n-        if initializer.should_initialize() {\n-            initializer\n-        } else {\n-            self.second.initializer()\n-        }\n+        if initializer.should_initialize() { initializer } else { self.second.initializer() }\n     }\n }\n \n@@ -2079,19 +2098,17 @@ impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n     fn fill_buf(&mut self) -> Result<&[u8]> {\n         if !self.done_first {\n             match self.first.fill_buf()? {\n-                buf if buf.is_empty() => { self.done_first = true; }\n+                buf if buf.is_empty() => {\n+                    self.done_first = true;\n+                }\n                 buf => return Ok(buf),\n             }\n         }\n         self.second.fill_buf()\n     }\n \n     fn consume(&mut self, amt: usize) {\n-        if !self.done_first {\n-            self.first.consume(amt)\n-        } else {\n-            self.second.consume(amt)\n-        }\n+        if !self.done_first { self.first.consume(amt) } else { self.second.consume(amt) }\n     }\n }\n \n@@ -2137,7 +2154,9 @@ impl<T> Take<T> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn limit(&self) -> u64 { self.limit }\n+    pub fn limit(&self) -> u64 {\n+        self.limit\n+    }\n \n     /// Sets the number of bytes that can be read before this instance will\n     /// return EOF. This is the same as constructing a new `Take` instance, so\n@@ -2351,7 +2370,7 @@ impl<B: BufRead> Iterator for Split<B> {\n                 }\n                 Some(Ok(buf))\n             }\n-            Err(e) => Some(Err(e))\n+            Err(e) => Some(Err(e)),\n         }\n     }\n }\n@@ -2385,16 +2404,16 @@ impl<B: BufRead> Iterator for Lines<B> {\n                 }\n                 Some(Ok(buf))\n             }\n-            Err(e) => Some(Err(e))\n+            Err(e) => Some(Err(e)),\n         }\n     }\n }\n \n #[cfg(test)]\n mod tests {\n+    use super::{repeat, Cursor, SeekFrom};\n     use crate::cmp;\n     use crate::io::prelude::*;\n-    use super::{Cursor, SeekFrom, repeat};\n     use crate::io::{self, IoSlice, IoSliceMut};\n     use crate::mem;\n     use crate::ops::Deref;\n@@ -2509,29 +2528,25 @@ mod tests {\n         let mut buf = [0; 4];\n \n         let mut c = Cursor::new(&b\"\"[..]);\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n-                   io::ErrorKind::UnexpectedEof);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n \n         let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n         c.read_exact(&mut buf).unwrap();\n         assert_eq!(&buf, b\"1234\");\n         c.read_exact(&mut buf).unwrap();\n         assert_eq!(&buf, b\"5678\");\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n-                   io::ErrorKind::UnexpectedEof);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n     }\n \n     #[test]\n     fn read_exact_slice() {\n         let mut buf = [0; 4];\n \n         let mut c = &b\"\"[..];\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n-                   io::ErrorKind::UnexpectedEof);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n \n         let mut c = &b\"123\"[..];\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(),\n-                   io::ErrorKind::UnexpectedEof);\n+        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n         // make sure the optimized (early returning) method is being used\n         assert_eq!(&buf, &[0; 4]);\n \n@@ -2558,7 +2573,7 @@ mod tests {\n             fn fill_buf(&mut self) -> io::Result<&[u8]> {\n                 Err(io::Error::new(io::ErrorKind::Other, \"\"))\n             }\n-            fn consume(&mut self, _amt: usize) { }\n+            fn consume(&mut self, _amt: usize) {}\n         }\n \n         let mut buf = [0; 1];\n@@ -2591,11 +2606,9 @@ mod tests {\n     #[test]\n     fn chain_bufread() {\n         let testdata = b\"ABCDEFGHIJKL\";\n-        let chain1 = (&testdata[..3]).chain(&testdata[3..6])\n-                                     .chain(&testdata[6..9])\n-                                     .chain(&testdata[9..]);\n-        let chain2 = (&testdata[..4]).chain(&testdata[4..8])\n-                                     .chain(&testdata[8..]);\n+        let chain1 =\n+            (&testdata[..3]).chain(&testdata[3..6]).chain(&testdata[6..9]).chain(&testdata[9..]);\n+        let chain2 = (&testdata[..4]).chain(&testdata[4..8]).chain(&testdata[8..]);\n         cmp_bufread(chain1, chain2, &testdata[..]);\n     }\n \n@@ -2651,7 +2664,6 @@ mod tests {\n         assert_eq!(c.stream_position()?, 15);\n         assert_eq!(c.stream_position()?, 15);\n \n-\n         c.seek(SeekFrom::Start(7))?;\n         c.seek(SeekFrom::Current(2))?;\n         assert_eq!(c.stream_position()?, 9);\n@@ -2700,9 +2712,7 @@ mod tests {\n         // that will not allocate when the limit has already been reached. In\n         // this case, vec2 never grows.\n         let mut vec2 = Vec::with_capacity(input.len());\n-        ExampleSliceReader { slice: input }\n-            .take(input.len() as u64)\n-            .read_to_end(&mut vec2)?;\n+        ExampleSliceReader { slice: input }.take(input.len() as u64).read_to_end(&mut vec2)?;\n         assert_eq!(vec2.len(), input.len());\n         assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n "}, {"sha": "3baab2be37795f390cb01eda75cb17d1aefb01e4", "filename": "src/libstd/io/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -11,4 +11,4 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use super::{Read, Write, BufRead, Seek};\n+pub use super::{BufRead, Read, Seek, Write};"}, {"sha": "b09161b97aa5e8d2cd67fc7ef8da53e100146bae", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,7 +1,7 @@\n #![allow(missing_copy_implementations)]\n \n use crate::fmt;\n-use crate::io::{self, Read, Initializer, Write, ErrorKind, BufRead, IoSlice, IoSliceMut};\n+use crate::io::{self, BufRead, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Write};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -41,15 +41,19 @@ use crate::mem::MaybeUninit;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n-    where R: Read, W: Write\n+where\n+    R: Read,\n+    W: Write,\n {\n     let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n     // FIXME(#53491): This is calling `get_mut` and `get_ref` on an uninitialized\n     // `MaybeUninit`. Revisit this once we decided whether that is valid or not.\n     // This is still technically undefined behavior due to creating a reference\n     // to uninitialized data, but within libstd we can rely on more guarantees\n     // than if this code were in an external lib.\n-    unsafe { reader.initializer().initialize(buf.get_mut()); }\n+    unsafe {\n+        reader.initializer().initialize(buf.get_mut());\n+    }\n \n     let mut written = 0;\n     loop {\n@@ -71,7 +75,9 @@ pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<\n ///\n /// [`empty`]: fn.empty.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Empty { _priv: () }\n+pub struct Empty {\n+    _priv: (),\n+}\n \n /// Constructs a new handle to an empty reader.\n ///\n@@ -91,12 +97,16 @@ pub struct Empty { _priv: () }\n /// assert!(buffer.is_empty());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn empty() -> Empty { Empty { _priv: () } }\n+pub fn empty() -> Empty {\n+    Empty { _priv: () }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Empty {\n     #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> { Ok(0) }\n+    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n+    }\n \n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n@@ -106,7 +116,9 @@ impl Read for Empty {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl BufRead for Empty {\n     #[inline]\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> { Ok(&[]) }\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        Ok(&[])\n+    }\n     #[inline]\n     fn consume(&mut self, _n: usize) {}\n }\n@@ -125,7 +137,9 @@ impl fmt::Debug for Empty {\n ///\n /// [repeat]: fn.repeat.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Repeat { byte: u8 }\n+pub struct Repeat {\n+    byte: u8,\n+}\n \n /// Creates an instance of a reader that infinitely repeats one byte.\n ///\n@@ -142,7 +156,9 @@ pub struct Repeat { byte: u8 }\n /// assert_eq!(buffer, [0b101, 0b101, 0b101]);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn repeat(byte: u8) -> Repeat { Repeat { byte } }\n+pub fn repeat(byte: u8) -> Repeat {\n+    Repeat { byte }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Repeat {\n@@ -183,7 +199,9 @@ impl fmt::Debug for Repeat {\n ///\n /// [sink]: fn.sink.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Sink { _priv: () }\n+pub struct Sink {\n+    _priv: (),\n+}\n \n /// Creates an instance of a writer which will successfully consume all data.\n ///\n@@ -200,12 +218,16 @@ pub struct Sink { _priv: () }\n /// assert_eq!(num_bytes, 5);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn sink() -> Sink { Sink { _priv: () } }\n+pub fn sink() -> Sink {\n+    Sink { _priv: () }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Sink {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { Ok(buf.len()) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        Ok(buf.len())\n+    }\n \n     #[inline]\n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n@@ -214,7 +236,9 @@ impl Write for Sink {\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -227,7 +251,7 @@ impl fmt::Debug for Sink {\n #[cfg(test)]\n mod tests {\n     use crate::io::prelude::*;\n-    use crate::io::{copy, sink, empty, repeat};\n+    use crate::io::{copy, empty, repeat, sink};\n \n     #[test]\n     fn copy_copies() {"}, {"sha": "11850a1b5fc3884200dc12eb5ec131384629d845", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -313,9 +313,8 @@ macro_rules! dbg {\n \n #[cfg(test)]\n macro_rules! assert_approx_eq {\n-    ($a:expr, $b:expr) => ({\n+    ($a:expr, $b:expr) => {{\n         let (a, b) = (&$a, &$b);\n-        assert!((*a - *b).abs() < 1.0e-6,\n-                \"{} is not approximately equal to {}\", *a, *b);\n-    })\n+        assert!((*a - *b).abs() < 1.0e-6, \"{} is not approximately equal to {}\", *a, *b);\n+    }};\n }"}, {"sha": "d5f4ece726bea86b9b1ae9a18f686742e422b5c6", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,16 +1,16 @@\n+use crate::convert::TryInto;\n use crate::fmt;\n use crate::hash;\n use crate::io;\n+use crate::iter;\n use crate::mem;\n-use crate::net::{ntoh, hton, IpAddr, Ipv4Addr, Ipv6Addr};\n+use crate::net::{hton, ntoh, IpAddr, Ipv4Addr, Ipv6Addr};\n use crate::option;\n+use crate::slice;\n use crate::sys::net::netc as c;\n-use crate::sys_common::{FromInner, AsInner, IntoInner};\n use crate::sys_common::net::LookupHost;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::vec;\n-use crate::iter;\n-use crate::slice;\n-use crate::convert::TryInto;\n \n /// An internet socket address, either IPv4 or IPv6.\n ///\n@@ -74,7 +74,9 @@ pub enum SocketAddr {\n /// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV4 { inner: c::sockaddr_in }\n+pub struct SocketAddrV4 {\n+    inner: c::sockaddr_in,\n+}\n \n /// An IPv6 socket address.\n ///\n@@ -104,7 +106,9 @@ pub struct SocketAddrV4 { inner: c::sockaddr_in }\n /// ```\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SocketAddrV6 { inner: c::sockaddr_in6 }\n+pub struct SocketAddrV6 {\n+    inner: c::sockaddr_in6,\n+}\n \n impl SocketAddr {\n     /// Creates a new socket address from an [IP address] and a port number.\n@@ -274,7 +278,7 @@ impl SocketAddrV4 {\n                 sin_family: c::AF_INET as c::sa_family_t,\n                 sin_port: hton(port),\n                 sin_addr: *ip.as_inner(),\n-                .. unsafe { mem::zeroed() }\n+                ..unsafe { mem::zeroed() }\n             },\n         }\n     }\n@@ -291,9 +295,7 @@ impl SocketAddrV4 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv4Addr {\n-        unsafe {\n-            &*(&self.inner.sin_addr as *const c::in_addr as *const Ipv4Addr)\n-        }\n+        unsafe { &*(&self.inner.sin_addr as *const c::in_addr as *const Ipv4Addr) }\n     }\n \n     /// Changes the IP address associated with this socket address.\n@@ -362,16 +364,15 @@ impl SocketAddrV6 {\n     /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32)\n-               -> SocketAddrV6 {\n+    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n         SocketAddrV6 {\n             inner: c::sockaddr_in6 {\n                 sin6_family: c::AF_INET6 as c::sa_family_t,\n                 sin6_port: hton(port),\n                 sin6_addr: *ip.as_inner(),\n                 sin6_flowinfo: flowinfo,\n                 sin6_scope_id: scope_id,\n-                .. unsafe { mem::zeroed() }\n+                ..unsafe { mem::zeroed() }\n             },\n         }\n     }\n@@ -388,9 +389,7 @@ impl SocketAddrV6 {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv6Addr {\n-        unsafe {\n-            &*(&self.inner.sin6_addr as *const c::in6_addr as *const Ipv6Addr)\n-        }\n+        unsafe { &*(&self.inner.sin6_addr as *const c::in6_addr as *const Ipv6Addr) }\n     }\n \n     /// Changes the IP address associated with this socket address.\n@@ -633,27 +632,31 @@ impl fmt::Debug for SocketAddrV6 {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for SocketAddrV4 {\n-    fn clone(&self) -> SocketAddrV4 { *self }\n+    fn clone(&self) -> SocketAddrV4 {\n+        *self\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for SocketAddrV6 {\n-    fn clone(&self) -> SocketAddrV6 { *self }\n+    fn clone(&self) -> SocketAddrV6 {\n+        *self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for SocketAddrV4 {\n     fn eq(&self, other: &SocketAddrV4) -> bool {\n-        self.inner.sin_port == other.inner.sin_port &&\n-            self.inner.sin_addr.s_addr == other.inner.sin_addr.s_addr\n+        self.inner.sin_port == other.inner.sin_port\n+            && self.inner.sin_addr.s_addr == other.inner.sin_addr.s_addr\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for SocketAddrV6 {\n     fn eq(&self, other: &SocketAddrV6) -> bool {\n-        self.inner.sin6_port == other.inner.sin6_port &&\n-            self.inner.sin6_addr.s6_addr == other.inner.sin6_addr.s6_addr &&\n-            self.inner.sin6_flowinfo == other.inner.sin6_flowinfo &&\n-            self.inner.sin6_scope_id == other.inner.sin6_scope_id\n+        self.inner.sin6_port == other.inner.sin6_port\n+            && self.inner.sin6_addr.s6_addr == other.inner.sin6_addr.s6_addr\n+            && self.inner.sin6_flowinfo == other.inner.sin6_flowinfo\n+            && self.inner.sin6_scope_id == other.inner.sin6_scope_id\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -670,8 +673,13 @@ impl hash::Hash for SocketAddrV4 {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl hash::Hash for SocketAddrV6 {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        (self.inner.sin6_port, &self.inner.sin6_addr.s6_addr,\n-         self.inner.sin6_flowinfo, self.inner.sin6_scope_id).hash(s)\n+        (\n+            self.inner.sin6_port,\n+            &self.inner.sin6_addr.s6_addr,\n+            self.inner.sin6_flowinfo,\n+            self.inner.sin6_scope_id,\n+        )\n+            .hash(s)\n     }\n }\n \n@@ -795,7 +803,7 @@ pub trait ToSocketAddrs {\n     /// Returned iterator over socket addresses which this type may correspond\n     /// to.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Iter: Iterator<Item=SocketAddr>;\n+    type Iter: Iterator<Item = SocketAddr>;\n \n     /// Converts this object to an iterator of resolved `SocketAddr`s.\n     ///\n@@ -864,7 +872,12 @@ impl ToSocketAddrs for (Ipv6Addr, u16) {\n \n fn resolve_socket_addr(lh: LookupHost) -> io::Result<vec::IntoIter<SocketAddr>> {\n     let p = lh.port();\n-    let v: Vec<_> = lh.map(|mut a| { a.set_port(p); a }).collect();\n+    let v: Vec<_> = lh\n+        .map(|mut a| {\n+            a.set_port(p);\n+            a\n+        })\n+        .collect();\n     Ok(v.into_iter())\n }\n \n@@ -877,11 +890,11 @@ impl ToSocketAddrs for (&str, u16) {\n         // try to parse the host as a regular IP address first\n         if let Ok(addr) = host.parse::<Ipv4Addr>() {\n             let addr = SocketAddrV4::new(addr, port);\n-            return Ok(vec![SocketAddr::V4(addr)].into_iter())\n+            return Ok(vec![SocketAddr::V4(addr)].into_iter());\n         }\n         if let Ok(addr) = host.parse::<Ipv6Addr>() {\n             let addr = SocketAddrV6::new(addr, port, 0, 0);\n-            return Ok(vec![SocketAddr::V6(addr)].into_iter())\n+            return Ok(vec![SocketAddr::V6(addr)].into_iter());\n         }\n \n         resolve_socket_addr((host, port).try_into()?)\n@@ -929,8 +942,8 @@ impl ToSocketAddrs for String {\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n+    use crate::net::test::{sa4, sa6, tsa};\n     use crate::net::*;\n-    use crate::net::test::{tsa, sa6, sa4};\n \n     #[test]\n     fn to_socket_addr_ipaddr_u16() {\n@@ -991,8 +1004,12 @@ mod tests {\n \n     #[test]\n     fn set_ip() {\n-        fn ip4(low: u8) -> Ipv4Addr { Ipv4Addr::new(77, 88, 21, low) }\n-        fn ip6(low: u16) -> Ipv6Addr { Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low) }\n+        fn ip4(low: u8) -> Ipv4Addr {\n+            Ipv4Addr::new(77, 88, 21, low)\n+        }\n+        fn ip6(low: u16) -> Ipv6Addr {\n+            Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low)\n+        }\n \n         let mut v4 = SocketAddrV4::new(ip4(11), 80);\n         assert_eq!(v4.ip(), &ip4(11));\n@@ -1068,7 +1085,11 @@ mod tests {\n     #[test]\n     fn is_v6() {\n         let v6 = SocketAddr::V6(SocketAddrV6::new(\n-                Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 10, 0));\n+            Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1),\n+            80,\n+            10,\n+            0,\n+        ));\n         assert!(!v6.is_ipv4());\n         assert!(v6.is_ipv6());\n     }"}, {"sha": "8106d1c3315aaec9bd6a3731a54f4818a4375e95", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -16,18 +16,16 @@ struct Parser<'a> {\n \n impl<'a> Parser<'a> {\n     fn new(s: &'a str) -> Parser<'a> {\n-        Parser {\n-            s: s.as_bytes(),\n-            pos: 0,\n-        }\n+        Parser { s: s.as_bytes(), pos: 0 }\n     }\n \n     fn is_eof(&self) -> bool {\n         self.pos == self.s.len()\n     }\n \n     // Commit only if parser returns Some\n-    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where\n+    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T>\n+    where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n         let pos = self.pos;\n@@ -39,17 +37,18 @@ impl<'a> Parser<'a> {\n     }\n \n     // Commit only if parser read till EOF\n-    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where\n+    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T>\n+    where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_atomically(move |p| {\n-            cb(p).filter(|_| p.is_eof())\n-        })\n+        self.read_atomically(move |p| cb(p).filter(|_| p.is_eof()))\n     }\n \n     // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &mut [Box<dyn FnMut(&mut Parser<'_>) -> Option<T> + 'static>])\n-               -> Option<T> {\n+    fn read_or<T>(\n+        &mut self,\n+        parsers: &mut [Box<dyn FnMut(&mut Parser<'_>) -> Option<T> + 'static>],\n+    ) -> Option<T> {\n         for pf in parsers {\n             if let Some(r) = self.read_atomically(|p: &mut Parser<'_>| pf(p)) {\n                 return Some(r);\n@@ -59,11 +58,8 @@ impl<'a> Parser<'a> {\n     }\n \n     // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,\n-                                       pa: PA,\n-                                       pb: PB,\n-                                       pc: PC)\n-                                       -> Option<(A, B, C)> where\n+    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self, pa: PA, pb: PB, pc: PC) -> Option<(A, B, C)>\n+    where\n         PA: FnOnce(&mut Parser<'_>) -> Option<A>,\n         PB: FnOnce(&mut Parser<'_>) -> Option<B>,\n         PC: FnOnce(&mut Parser<'_>) -> Option<C>,\n@@ -74,7 +70,7 @@ impl<'a> Parser<'a> {\n             let c = if b.is_some() { pc(p) } else { None };\n             match (a, b, c) {\n                 (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n-                _ => None\n+                _ => None,\n             }\n         })\n     }\n@@ -92,11 +88,9 @@ impl<'a> Parser<'a> {\n \n     // Return char and advance iff next char is equal to requested\n     fn read_given_char(&mut self, c: char) -> Option<char> {\n-        self.read_atomically(|p| {\n-            match p.read_char() {\n-                Some(next) if next == c => Some(next),\n-                _ => None,\n-            }\n+        self.read_atomically(|p| match p.read_char() {\n+            Some(next) if next == c => Some(next),\n+            _ => None,\n         })\n     }\n \n@@ -116,9 +110,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        self.read_atomically(|p| {\n-            p.read_char().and_then(|c| parse_digit(c, radix))\n-        })\n+        self.read_atomically(|p| p.read_char().and_then(|c| parse_digit(c, radix)))\n     }\n \n     fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n@@ -130,14 +122,14 @@ impl<'a> Parser<'a> {\n                     r = r * (radix as u32) + (d as u32);\n                     digit_count += 1;\n                     if digit_count > max_digits || r >= upto {\n-                        return None\n+                        return None;\n                     }\n                 }\n                 None => {\n                     if digit_count == 0 {\n-                        return None\n+                        return None;\n                     } else {\n-                        return Some(r)\n+                        return Some(r);\n                     }\n                 }\n             };\n@@ -173,12 +165,11 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0; 8];\n             gs[..head.len()].copy_from_slice(head);\n-            gs[(8 - tail.len()) .. 8].copy_from_slice(tail);\n+            gs[(8 - tail.len())..8].copy_from_slice(tail);\n             Ipv6Addr::new(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n \n-        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16; 8], limit: usize)\n-                       -> (usize, bool) {\n+        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n             let mut i = 0;\n             while i < limit {\n                 if i < limit - 1 {\n@@ -206,7 +197,7 @@ impl<'a> Parser<'a> {\n                 });\n                 match group {\n                     Some(g) => groups[i] = g,\n-                    None => return (i, false)\n+                    None => return (i, false),\n                 }\n                 i += 1;\n             }\n@@ -218,13 +209,13 @@ impl<'a> Parser<'a> {\n \n         if head_size == 8 {\n             return Some(Ipv6Addr::new(\n-                head[0], head[1], head[2], head[3],\n-                head[4], head[5], head[6], head[7]))\n+                head[0], head[1], head[2], head[3], head[4], head[5], head[6], head[7],\n+            ));\n         }\n \n         // IPv4 part is not allowed before `::`\n         if head_ipv4 {\n-            return None\n+            return None;\n         }\n \n         // read `::` if previous code parsed less than 8 groups\n@@ -252,9 +243,7 @@ impl<'a> Parser<'a> {\n     fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n         let ip_addr = |p: &mut Parser<'_>| p.read_ipv4_addr();\n         let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| {\n-            p.read_number(10, 5, 0x10000).map(|n| n as u16)\n-        };\n+        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n \n         self.read_seq_3(ip_addr, colon, port).map(|t| {\n             let (ip, _, port): (Ipv4Addr, char, u16) = t;\n@@ -270,9 +259,7 @@ impl<'a> Parser<'a> {\n             p.read_seq_3(open_br, ip_addr, clos_br).map(|t| t.1)\n         };\n         let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| {\n-            p.read_number(10, 5, 0x10000).map(|n| n as u16)\n-        };\n+        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n \n         self.read_seq_3(ip_addr, colon, port).map(|t| {\n             let (ip, _, port): (Ipv6Addr, char, u16) = t;\n@@ -293,7 +280,7 @@ impl FromStr for IpAddr {\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n         match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n             Some(s) => Ok(s),\n-            None => Err(AddrParseError(()))\n+            None => Err(AddrParseError(())),\n         }\n     }\n }\n@@ -304,7 +291,7 @@ impl FromStr for Ipv4Addr {\n     fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n         match Parser::new(s).read_till_eof(|p| p.read_ipv4_addr()) {\n             Some(s) => Ok(s),\n-            None => Err(AddrParseError(()))\n+            None => Err(AddrParseError(())),\n         }\n     }\n }\n@@ -315,7 +302,7 @@ impl FromStr for Ipv6Addr {\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n         match Parser::new(s).read_till_eof(|p| p.read_ipv6_addr()) {\n             Some(s) => Ok(s),\n-            None => Err(AddrParseError(()))\n+            None => Err(AddrParseError(())),\n         }\n     }\n }"}, {"sha": "5c02215997088cfadaea32f2128218c2e4589d7a", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 146, "deletions": 93, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -2,7 +2,7 @@ use crate::io::prelude::*;\n \n use crate::fmt;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n-use crate::net::{ToSocketAddrs, SocketAddr, Shutdown};\n+use crate::net::{Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n@@ -93,7 +93,9 @@ pub struct TcpListener(net_imp::TcpListener);\n /// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct Incoming<'a> { listener: &'a TcpListener }\n+pub struct Incoming<'a> {\n+    listener: &'a TcpListener,\n+}\n \n impl TcpStream {\n     /// Opens a TCP connection to a remote host.\n@@ -567,7 +569,9 @@ impl TcpStream {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n@@ -580,17 +584,23 @@ impl Read for TcpStream {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         self.0.write_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for &TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         self.0.read_vectored(bufs)\n@@ -603,25 +613,35 @@ impl Read for &TcpStream {\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for &TcpStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         self.0.write_vectored(bufs)\n     }\n \n-    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n }\n \n impl AsInner<net_imp::TcpStream> for TcpStream {\n-    fn as_inner(&self) -> &net_imp::TcpStream { &self.0 }\n+    fn as_inner(&self) -> &net_imp::TcpStream {\n+        &self.0\n+    }\n }\n \n impl FromInner<net_imp::TcpStream> for TcpStream {\n-    fn from_inner(inner: net_imp::TcpStream) -> TcpStream { TcpStream(inner) }\n+    fn from_inner(inner: net_imp::TcpStream) -> TcpStream {\n+        TcpStream(inner)\n+    }\n }\n \n impl IntoInner<net_imp::TcpStream> for TcpStream {\n-    fn into_inner(self) -> net_imp::TcpStream { self.0 }\n+    fn into_inner(self) -> net_imp::TcpStream {\n+        self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -814,16 +834,20 @@ impl TcpListener {\n     }\n \n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n-    #[rustc_deprecated(since = \"1.16.0\",\n-                       reason = \"this option can only be set before the socket is bound\")]\n+    #[rustc_deprecated(\n+        since = \"1.16.0\",\n+        reason = \"this option can only be set before the socket is bound\"\n+    )]\n     #[allow(missing_docs)]\n     pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n         self.0.set_only_v6(only_v6)\n     }\n \n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n-    #[rustc_deprecated(since = \"1.16.0\",\n-                       reason = \"this option can only be set before the socket is bound\")]\n+    #[rustc_deprecated(\n+        since = \"1.16.0\",\n+        reason = \"this option can only be set before the socket is bound\"\n+    )]\n     #[allow(missing_docs)]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n@@ -907,7 +931,9 @@ impl<'a> Iterator for Incoming<'a> {\n }\n \n impl AsInner<net_imp::TcpListener> for TcpListener {\n-    fn as_inner(&self) -> &net_imp::TcpListener { &self.0 }\n+    fn as_inner(&self) -> &net_imp::TcpListener {\n+        &self.0\n+    }\n }\n \n impl FromInner<net_imp::TcpListener> for TcpListener {\n@@ -917,7 +943,9 @@ impl FromInner<net_imp::TcpListener> for TcpListener {\n }\n \n impl IntoInner<net_imp::TcpListener> for TcpListener {\n-    fn into_inner(self) -> net_imp::TcpListener { self.0 }\n+    fn into_inner(self) -> net_imp::TcpListener {\n+        self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -930,13 +958,13 @@ impl fmt::Debug for TcpListener {\n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n     use crate::fmt;\n-    use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n     use crate::io::prelude::*;\n-    use crate::net::*;\n+    use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n     use crate::net::test::{next_test_ip4, next_test_ip6};\n+    use crate::net::*;\n     use crate::sync::mpsc::channel;\n-    use crate::time::{Instant, Duration};\n     use crate::thread;\n+    use crate::time::{Duration, Instant};\n \n     fn each_ip(f: &mut dyn FnMut(SocketAddr)) {\n         f(next_test_ip4());\n@@ -949,27 +977,30 @@ mod tests {\n                 Ok(t) => t,\n                 Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n             }\n-        }\n+        };\n     }\n \n     #[test]\n     fn bind_error() {\n         match TcpListener::bind(\"1.1.1.1:9999\") {\n             Ok(..) => panic!(),\n-            Err(e) =>\n-                assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n         }\n     }\n \n     #[test]\n     fn connect_error() {\n         match TcpStream::connect(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n-            Err(e) => assert!(e.kind() == ErrorKind::ConnectionRefused ||\n-                              e.kind() == ErrorKind::InvalidInput ||\n-                              e.kind() == ErrorKind::AddrInUse ||\n-                              e.kind() == ErrorKind::AddrNotAvailable,\n-                              \"bad error: {} {:?}\", e, e.kind()),\n+            Err(e) => assert!(\n+                e.kind() == ErrorKind::ConnectionRefused\n+                    || e.kind() == ErrorKind::InvalidInput\n+                    || e.kind() == ErrorKind::AddrInUse\n+                    || e.kind() == ErrorKind::AddrNotAvailable,\n+                \"bad error: {} {:?}\",\n+                e,\n+                e.kind()\n+            ),\n         }\n     }\n \n@@ -979,8 +1010,7 @@ mod tests {\n         let listener = t!(TcpListener::bind(&socket_addr));\n \n         let _t = thread::spawn(move || {\n-            let mut stream = t!(TcpStream::connect(&(\"localhost\",\n-                                                     socket_addr.port())));\n+            let mut stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n             t!(stream.write(&[144]));\n         });\n \n@@ -995,7 +1025,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let host = match addr {\n                     SocketAddr::V4(..) => \"127.0.0.1\",\n                     SocketAddr::V6(..) => \"::1\",\n@@ -1017,7 +1047,7 @@ mod tests {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n             let (tx, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 t!(stream.write(&[99]));\n                 tx.send(t!(stream.local_addr())).unwrap();\n@@ -1036,7 +1066,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _stream = t!(TcpStream::connect(&addr));\n                 // Close\n             });\n@@ -1056,7 +1086,7 @@ mod tests {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n             let (tx, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(t!(TcpStream::connect(&addr)));\n                 tx.send(()).unwrap();\n             });\n@@ -1067,10 +1097,13 @@ mod tests {\n             match stream.write(&buf) {\n                 Ok(..) => {}\n                 Err(e) => {\n-                    assert!(e.kind() == ErrorKind::ConnectionReset ||\n-                            e.kind() == ErrorKind::BrokenPipe ||\n-                            e.kind() == ErrorKind::ConnectionAborted,\n-                            \"unknown error: {}\", e);\n+                    assert!(\n+                        e.kind() == ErrorKind::ConnectionReset\n+                            || e.kind() == ErrorKind::BrokenPipe\n+                            || e.kind() == ErrorKind::ConnectionAborted,\n+                        \"unknown error: {}\",\n+                        e\n+                    );\n                 }\n             }\n         })\n@@ -1082,7 +1115,7 @@ mod tests {\n             let max = 10;\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 for _ in 0..max {\n                     let mut stream = t!(TcpStream::connect(&addr));\n                     t!(stream.write(&[99]));\n@@ -1104,11 +1137,11 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let acceptor = acceptor;\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n                     // Start another thread to handle the connection\n-                    let _t = thread::spawn(move|| {\n+                    let _t = thread::spawn(move || {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n                         t!(stream.read(&mut buf));\n@@ -1121,9 +1154,11 @@ mod tests {\n         });\n \n         fn connect(i: usize, addr: SocketAddr) {\n-            if i == MAX { return }\n+            if i == MAX {\n+                return;\n+            }\n \n-            let t = thread::spawn(move|| {\n+            let t = thread::spawn(move || {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 // Connect again before writing\n                 connect(i + 1, addr);\n@@ -1139,10 +1174,10 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 for stream in acceptor.incoming().take(MAX) {\n                     // Start another thread to handle the connection\n-                    let _t = thread::spawn(move|| {\n+                    let _t = thread::spawn(move || {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n                         t!(stream.read(&mut buf));\n@@ -1155,9 +1190,11 @@ mod tests {\n         });\n \n         fn connect(i: usize, addr: SocketAddr) {\n-            if i == MAX { return }\n+            if i == MAX {\n+                return;\n+            }\n \n-            let t = thread::spawn(move|| {\n+            let t = thread::spawn(move || {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 connect(i + 1, addr);\n                 t!(stream.write(&[99]));\n@@ -1172,7 +1209,7 @@ mod tests {\n             let listener = t!(TcpListener::bind(&addr));\n             let so_name = t!(listener.local_addr());\n             assert_eq!(addr, so_name);\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 t!(listener.accept());\n             });\n \n@@ -1186,7 +1223,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let (tx, rx) = channel();\n             let srv = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut cl = t!(srv.accept()).0;\n                 cl.write(&[10]).unwrap();\n                 let mut b = [0];\n@@ -1215,9 +1252,11 @@ mod tests {\n             let mut a = [];\n             let mut b = [0];\n             let mut c = [0; 3];\n-            let len = t!(s2.read_vectored(\n-                &mut [IoSliceMut::new(&mut a), IoSliceMut::new(&mut b), IoSliceMut::new(&mut c)],\n-            ));\n+            let len = t!(s2.read_vectored(&mut [\n+                IoSliceMut::new(&mut a),\n+                IoSliceMut::new(&mut b),\n+                IoSliceMut::new(&mut c)\n+            ],));\n             assert!(len > 0);\n             assert_eq!(b, [10]);\n             // some implementations don't support readv, so we may only fill the first buffer\n@@ -1260,10 +1299,14 @@ mod tests {\n                     listener1, listener2\n                 ),\n                 Err(e) => {\n-                    assert!(e.kind() == ErrorKind::ConnectionRefused ||\n-                            e.kind() == ErrorKind::Other ||\n-                            e.kind() == ErrorKind::AddrInUse,\n-                            \"unknown error: {} {:?}\", e, e.kind());\n+                    assert!(\n+                        e.kind() == ErrorKind::ConnectionRefused\n+                            || e.kind() == ErrorKind::Other\n+                            || e.kind() == ErrorKind::AddrInUse,\n+                        \"unknown error: {} {:?}\",\n+                        e,\n+                        e.kind()\n+                    );\n                 }\n             }\n         })\n@@ -1274,7 +1317,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 t!(TcpStream::connect(&addr));\n             });\n \n@@ -1289,7 +1332,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 0];\n                 assert_eq!(s.read(&mut buf).unwrap(), 1);\n@@ -1302,7 +1345,7 @@ mod tests {\n \n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s2 = s2;\n                 rx1.recv().unwrap();\n                 t!(s2.write(&[1]));\n@@ -1322,7 +1365,7 @@ mod tests {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 t!(s.write(&[1]));\n                 rx.recv().unwrap();\n@@ -1334,7 +1377,7 @@ mod tests {\n             let s2 = t!(s1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s2 = s2;\n                 let mut buf = [0, 0];\n                 t!(s2.read(&mut buf));\n@@ -1354,7 +1397,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 1];\n                 t!(s.read(&mut buf));\n@@ -1365,7 +1408,7 @@ mod tests {\n             let s2 = t!(s1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s2 = s2;\n                 t!(s2.write(&[1]));\n                 done.send(()).unwrap();\n@@ -1382,7 +1425,7 @@ mod tests {\n     fn shutdown_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut c = t!(a.accept()).0;\n                 let mut b = [0];\n                 assert_eq!(c.read(&mut b).unwrap(), 0);\n@@ -1405,7 +1448,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n             let (tx, rx) = channel::<()>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _s = t!(a.accept());\n                 let _ = rx.recv();\n             });\n@@ -1444,15 +1487,15 @@ mod tests {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n             let (tx1, rx) = channel::<()>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _s = t!(a.accept());\n                 let _ = rx.recv();\n             });\n \n             let s = t!(TcpStream::connect(&addr));\n             let s2 = t!(s.try_clone());\n             let (tx, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut s2 = s2;\n                 assert_eq!(t!(s2.read(&mut [0])), 0);\n                 tx.send(()).unwrap();\n@@ -1475,7 +1518,7 @@ mod tests {\n             let (tx, rx) = channel();\n             let (txdone, rxdone) = channel();\n             let txdone2 = txdone.clone();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut tcp = t!(TcpStream::connect(&addr));\n                 rx.recv().unwrap();\n                 t!(tcp.write(&[0]));\n@@ -1486,7 +1529,7 @@ mod tests {\n             let tcp = t!(accept.accept()).0;\n             let tcp2 = t!(tcp.try_clone());\n             let txdone3 = txdone.clone();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut tcp2 = tcp2;\n                 t!(tcp2.read(&mut [0]));\n                 txdone3.send(()).unwrap();\n@@ -1512,10 +1555,10 @@ mod tests {\n             let a = t!(TcpListener::bind(&addr));\n             let a2 = t!(a.try_clone());\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _ = TcpStream::connect(&addr);\n             });\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _ = TcpStream::connect(&addr);\n             });\n \n@@ -1533,17 +1576,17 @@ mod tests {\n             let (tx, rx) = channel();\n             let tx2 = tx.clone();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 tx.send(t!(a.accept())).unwrap();\n             });\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 tx2.send(t!(a2.accept())).unwrap();\n             });\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _ = TcpStream::connect(&addr);\n             });\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let _ = TcpStream::connect(&addr);\n             });\n \n@@ -1563,10 +1606,10 @@ mod tests {\n             addr.to_string()\n         }\n \n-        #[cfg(unix)]\n-        use crate::os::unix::io::AsRawFd;\n         #[cfg(target_env = \"sgx\")]\n         use crate::os::fortanix_sgx::io::AsRawFd;\n+        #[cfg(unix)]\n+        use crate::os::unix::io::AsRawFd;\n         #[cfg(not(windows))]\n         fn render_inner(addr: &dyn AsRawFd) -> impl fmt::Debug {\n             addr.as_raw_fd()\n@@ -1576,22 +1619,26 @@ mod tests {\n             addr.as_raw_socket()\n         }\n \n-        let inner_name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        let inner_name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n         let socket_addr = next_test_ip4();\n \n         let listener = t!(TcpListener::bind(&socket_addr));\n-        let compare = format!(\"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n-                              render_socket_addr(&socket_addr),\n-                              inner_name,\n-                              render_inner(&listener));\n+        let compare = format!(\n+            \"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n+            render_socket_addr(&socket_addr),\n+            inner_name,\n+            render_inner(&listener)\n+        );\n         assert_eq!(format!(\"{:?}\", listener), compare);\n \n         let stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n-        let compare = format!(\"TcpStream {{ addr: {:?}, peer: {:?}, {}: {:?} }}\",\n-                              render_socket_addr(&stream.local_addr().unwrap()),\n-                              render_socket_addr(&stream.peer_addr().unwrap()),\n-                              inner_name,\n-                              render_inner(&stream));\n+        let compare = format!(\n+            \"TcpStream {{ addr: {:?}, peer: {:?}, {}: {:?} }}\",\n+            render_socket_addr(&stream.local_addr().unwrap()),\n+            render_socket_addr(&stream.peer_addr().unwrap()),\n+            inner_name,\n+            render_inner(&stream)\n+        );\n         assert_eq!(format!(\"{:?}\", stream), compare);\n     }\n \n@@ -1638,8 +1685,11 @@ mod tests {\n         let mut buf = [0; 10];\n         let start = Instant::now();\n         let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                \"unexpected_error: {:?}\", kind);\n+        assert!(\n+            kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+            \"unexpected_error: {:?}\",\n+            kind\n+        );\n         assert!(start.elapsed() > Duration::from_millis(400));\n         drop(listener);\n     }\n@@ -1662,8 +1712,11 @@ mod tests {\n \n         let start = Instant::now();\n         let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                \"unexpected_error: {:?}\", kind);\n+        assert!(\n+            kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+            \"unexpected_error: {:?}\",\n+            kind\n+        );\n         assert!(start.elapsed() > Duration::from_millis(400));\n         drop(listener);\n     }\n@@ -1749,9 +1802,9 @@ mod tests {\n             let (txdone, rxdone) = channel();\n \n             let srv = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut cl = t!(srv.accept()).0;\n-                cl.write(&[1,3,3,7]).unwrap();\n+                cl.write(&[1, 3, 3, 7]).unwrap();\n                 t!(rxdone.recv());\n             });\n "}, {"sha": "37937b5ea95410a1f7b94c6e4a3f579fe2c4ebfa", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,7 +1,7 @@\n #![allow(warnings)] // not used on emscripten\n \n use crate::env;\n-use crate::net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n+use crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n use crate::sync::atomic::{AtomicUsize, Ordering};\n \n static PORT: AtomicUsize = AtomicUsize::new(0);\n@@ -13,8 +13,7 @@ pub fn next_test_ip4() -> SocketAddr {\n \n pub fn next_test_ip6() -> SocketAddr {\n     let port = PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port();\n-    SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1),\n-                                     port, 0, 0))\n+    SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), port, 0, 0))\n }\n \n pub fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n@@ -41,11 +40,21 @@ fn base_port() -> u16 {\n     } else {\n         env::current_dir().unwrap().into_os_string().into_string().unwrap()\n     };\n-    let dirs = [\"32-opt\", \"32-nopt\",\n-                \"musl-64-opt\", \"cross-opt\",\n-                \"64-opt\", \"64-nopt\", \"64-opt-vg\", \"64-debug-opt\",\n-                \"all-opt\", \"snap3\", \"dist\", \"sgx\"];\n-    dirs.iter().enumerate().find(|&(_, dir)| {\n-        cwd.contains(dir)\n-    }).map(|p| p.0).unwrap_or(0) as u16 * 1000 + 19600\n+    let dirs = [\n+        \"32-opt\",\n+        \"32-nopt\",\n+        \"musl-64-opt\",\n+        \"cross-opt\",\n+        \"64-opt\",\n+        \"64-nopt\",\n+        \"64-opt-vg\",\n+        \"64-debug-opt\",\n+        \"all-opt\",\n+        \"snap3\",\n+        \"dist\",\n+        \"sgx\",\n+    ];\n+    dirs.iter().enumerate().find(|&(_, dir)| cwd.contains(dir)).map(|p| p.0).unwrap_or(0) as u16\n+        * 1000\n+        + 19600\n }"}, {"sha": "0096b827ca456df7bd19801054c3e89fe31ed0a9", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,6 +1,6 @@\n use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n-use crate::net::{ToSocketAddrs, SocketAddr, Ipv4Addr, Ipv6Addr};\n+use crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n@@ -171,12 +171,10 @@ impl UdpSocket {\n     /// socket.send_to(&[0; 10], \"127.0.0.1:4242\").expect(\"couldn't send data\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)\n-                                     -> io::Result<usize> {\n+    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> io::Result<usize> {\n         match addr.to_socket_addrs()?.next() {\n             Some(addr) => self.0.send_to(buf, &addr),\n-            None => Err(Error::new(ErrorKind::InvalidInput,\n-                                   \"no addresses to send data to\")),\n+            None => Err(Error::new(ErrorKind::InvalidInput, \"no addresses to send data to\")),\n         }\n     }\n \n@@ -817,15 +815,21 @@ impl UdpSocket {\n }\n \n impl AsInner<net_imp::UdpSocket> for UdpSocket {\n-    fn as_inner(&self) -> &net_imp::UdpSocket { &self.0 }\n+    fn as_inner(&self) -> &net_imp::UdpSocket {\n+        &self.0\n+    }\n }\n \n impl FromInner<net_imp::UdpSocket> for UdpSocket {\n-    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket { UdpSocket(inner) }\n+    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket {\n+        UdpSocket(inner)\n+    }\n }\n \n impl IntoInner<net_imp::UdpSocket> for UdpSocket {\n-    fn into_inner(self) -> net_imp::UdpSocket { self.0 }\n+    fn into_inner(self) -> net_imp::UdpSocket {\n+        self.0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -838,12 +842,12 @@ impl fmt::Debug for UdpSocket {\n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n mod tests {\n     use crate::io::ErrorKind;\n-    use crate::net::*;\n     use crate::net::test::{next_test_ip4, next_test_ip6};\n+    use crate::net::*;\n     use crate::sync::mpsc::channel;\n     use crate::sys_common::AsInner;\n-    use crate::time::{Instant, Duration};\n     use crate::thread;\n+    use crate::time::{Duration, Instant};\n \n     fn each_ip(f: &mut dyn FnMut(SocketAddr, SocketAddr)) {\n         f(next_test_ip4(), next_test_ip4());\n@@ -856,16 +860,14 @@ mod tests {\n                 Ok(t) => t,\n                 Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n             }\n-        }\n+        };\n     }\n \n     #[test]\n     fn bind_error() {\n         match UdpSocket::bind(\"1.1.1.1:9999\") {\n             Ok(..) => panic!(),\n-            Err(e) => {\n-                assert_eq!(e.kind(), ErrorKind::AddrNotAvailable)\n-            }\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n         }\n     }\n \n@@ -875,7 +877,7 @@ mod tests {\n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let client = t!(UdpSocket::bind(&client_ip));\n                 rx1.recv().unwrap();\n                 t!(client.send_to(&[99], &server_ip));\n@@ -917,7 +919,7 @@ mod tests {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n             let sock2 = t!(UdpSocket::bind(&addr2));\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut buf = [0, 0];\n                 assert_eq!(sock2.recv_from(&mut buf).unwrap(), (1, addr1));\n                 assert_eq!(buf[0], 1);\n@@ -928,7 +930,7 @@ mod tests {\n \n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 rx1.recv().unwrap();\n                 t!(sock3.send_to(&[1], &addr2));\n                 tx2.send(()).unwrap();\n@@ -948,7 +950,7 @@ mod tests {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 t!(sock2.send_to(&[1], &addr1));\n                 rx.recv().unwrap();\n                 t!(sock2.send_to(&[2], &addr1));\n@@ -958,7 +960,7 @@ mod tests {\n             let sock3 = t!(sock1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut buf = [0, 0];\n                 t!(sock3.recv_from(&mut buf));\n                 tx2.send(()).unwrap();\n@@ -981,7 +983,7 @@ mod tests {\n             let (tx, rx) = channel();\n             let (serv_tx, serv_rx) = channel();\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 let mut buf = [0, 1];\n                 rx.recv().unwrap();\n                 t!(sock2.recv_from(&mut buf));\n@@ -992,15 +994,19 @@ mod tests {\n \n             let (done, rx) = channel();\n             let tx2 = tx.clone();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 match sock3.send_to(&[1], &addr2) {\n-                    Ok(..) => { let _ = tx2.send(()); }\n+                    Ok(..) => {\n+                        let _ = tx2.send(());\n+                    }\n                     Err(..) => {}\n                 }\n                 done.send(()).unwrap();\n             });\n             match sock1.send_to(&[2], &addr2) {\n-                Ok(..) => { let _ = tx.send(()); }\n+                Ok(..) => {\n+                    let _ = tx.send(());\n+                }\n                 Err(..) => {}\n             }\n             drop(tx);\n@@ -1012,13 +1018,13 @@ mod tests {\n \n     #[test]\n     fn debug() {\n-        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n         let socket_addr = next_test_ip4();\n \n         let udpsock = t!(UdpSocket::bind(&socket_addr));\n         let udpsock_inner = udpsock.0.socket().as_inner();\n-        let compare = format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\",\n-                              socket_addr, name, udpsock_inner);\n+        let compare =\n+            format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\", socket_addr, name, udpsock_inner);\n         assert_eq!(format!(\"{:?}\", udpsock), compare);\n     }\n \n@@ -1063,8 +1069,11 @@ mod tests {\n         loop {\n             let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n             if kind != ErrorKind::Interrupted {\n-                assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                        \"unexpected_error: {:?}\", kind);\n+                assert!(\n+                    kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+                    \"unexpected_error: {:?}\",\n+                    kind\n+                );\n                 break;\n             }\n         }\n@@ -1088,8 +1097,11 @@ mod tests {\n         loop {\n             let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n             if kind != ErrorKind::Interrupted {\n-                assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                        \"unexpected_error: {:?}\", kind);\n+                assert!(\n+                    kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+                    \"unexpected_error: {:?}\",\n+                    kind\n+                );\n                 break;\n             }\n         }"}, {"sha": "de8acf8d9d4721b8ed07347b636bb68f90455e32", "filename": "src/libstd/num.rs", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -6,57 +6,65 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::Wrapping;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::num::{FpCategory, ParseFloatError, ParseIntError, TryFromIntError};\n \n-#[stable(feature = \"nonzero\", since = \"1.28.0\")]\n-pub use core::num::{NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize};\n #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\n-pub use core::num::{NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize};\n-\n-#[unstable(feature = \"int_error_matching\",\n-           reason = \"it can be useful to match errors when making error messages \\\n-                     for integer parsing\",\n-           issue = \"22639\")]\n+pub use core::num::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n+#[stable(feature = \"nonzero\", since = \"1.28.0\")]\n+pub use core::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n+\n+#[unstable(\n+    feature = \"int_error_matching\",\n+    reason = \"it can be useful to match errors when making error messages \\\n+              for integer parsing\",\n+    issue = \"22639\"\n+)]\n pub use core::num::IntErrorKind;\n \n-#[cfg(test)] use crate::fmt;\n-#[cfg(test)] use crate::ops::{Add, Sub, Mul, Div, Rem};\n+#[cfg(test)]\n+use crate::fmt;\n+#[cfg(test)]\n+use crate::ops::{Add, Div, Mul, Rem, Sub};\n \n /// Helper function for testing numeric operations\n #[cfg(test)]\n-pub fn test_num<T>(ten: T, two: T) where\n+pub fn test_num<T>(ten: T, two: T)\n+where\n     T: PartialEq\n-     + Add<Output=T> + Sub<Output=T>\n-     + Mul<Output=T> + Div<Output=T>\n-     + Rem<Output=T> + fmt::Debug\n-     + Copy\n+        + Add<Output = T>\n+        + Sub<Output = T>\n+        + Mul<Output = T>\n+        + Div<Output = T>\n+        + Rem<Output = T>\n+        + fmt::Debug\n+        + Copy,\n {\n-    assert_eq!(ten.add(two),  ten + two);\n-    assert_eq!(ten.sub(two),  ten - two);\n-    assert_eq!(ten.mul(two),  ten * two);\n-    assert_eq!(ten.div(two),  ten / two);\n-    assert_eq!(ten.rem(two),  ten % two);\n+    assert_eq!(ten.add(two), ten + two);\n+    assert_eq!(ten.sub(two), ten - two);\n+    assert_eq!(ten.mul(two), ten * two);\n+    assert_eq!(ten.div(two), ten / two);\n+    assert_eq!(ten.rem(two), ten % two);\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::u8;\n+    use crate::ops::Mul;\n     use crate::u16;\n     use crate::u32;\n     use crate::u64;\n+    use crate::u8;\n     use crate::usize;\n-    use crate::ops::Mul;\n \n     #[test]\n     fn test_saturating_add_uint() {\n         use crate::usize::MAX;\n         assert_eq!(3_usize.saturating_add(5_usize), 8_usize);\n-        assert_eq!(3_usize.saturating_add(MAX-1), MAX);\n+        assert_eq!(3_usize.saturating_add(MAX - 1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n-        assert_eq!((MAX-2).saturating_add(1), MAX-1);\n+        assert_eq!((MAX - 2).saturating_add(1), MAX - 1);\n     }\n \n     #[test]\n@@ -65,31 +73,31 @@ mod tests {\n         assert_eq!(5_usize.saturating_sub(3_usize), 2_usize);\n         assert_eq!(3_usize.saturating_sub(5_usize), 0_usize);\n         assert_eq!(0_usize.saturating_sub(1_usize), 0_usize);\n-        assert_eq!((MAX-1).saturating_sub(MAX), 0);\n+        assert_eq!((MAX - 1).saturating_sub(MAX), 0);\n     }\n \n     #[test]\n     fn test_saturating_add_int() {\n-        use crate::isize::{MIN,MAX};\n+        use crate::isize::{MAX, MIN};\n         assert_eq!(3i32.saturating_add(5), 8);\n-        assert_eq!(3isize.saturating_add(MAX-1), MAX);\n+        assert_eq!(3isize.saturating_add(MAX - 1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n-        assert_eq!((MAX-2).saturating_add(1), MAX-1);\n+        assert_eq!((MAX - 2).saturating_add(1), MAX - 1);\n         assert_eq!(3i32.saturating_add(-5), -2);\n         assert_eq!(MIN.saturating_add(-1), MIN);\n         assert_eq!((-2isize).saturating_add(-MAX), MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n-        use crate::isize::{MIN,MAX};\n+        use crate::isize::{MAX, MIN};\n         assert_eq!(3i32.saturating_sub(5), -2);\n         assert_eq!(MIN.saturating_sub(1), MIN);\n         assert_eq!((-2isize).saturating_sub(MAX), MIN);\n         assert_eq!(3i32.saturating_sub(-5), 8);\n-        assert_eq!(3isize.saturating_sub(-(MAX-1)), MAX);\n+        assert_eq!(3isize.saturating_sub(-(MAX - 1)), MAX);\n         assert_eq!(MAX.saturating_sub(-MAX), MAX);\n-        assert_eq!((MAX-2).saturating_sub(-1), MAX-1);\n+        assert_eq!((MAX - 2).saturating_sub(-1), MAX - 1);\n     }\n \n     #[test]\n@@ -128,7 +136,7 @@ mod tests {\n     }\n \n     macro_rules! test_is_power_of_two {\n-        ($test_name:ident, $T:ident) => (\n+        ($test_name:ident, $T:ident) => {\n             fn $test_name() {\n                 #![test]\n                 assert_eq!((0 as $T).is_power_of_two(), false);\n@@ -139,27 +147,29 @@ mod tests {\n                 assert_eq!((5 as $T).is_power_of_two(), false);\n                 assert_eq!(($T::MAX / 2 + 1).is_power_of_two(), true);\n             }\n-        )\n+        };\n     }\n \n-    test_is_power_of_two!{ test_is_power_of_two_u8, u8 }\n-    test_is_power_of_two!{ test_is_power_of_two_u16, u16 }\n-    test_is_power_of_two!{ test_is_power_of_two_u32, u32 }\n-    test_is_power_of_two!{ test_is_power_of_two_u64, u64 }\n-    test_is_power_of_two!{ test_is_power_of_two_uint, usize }\n+    test_is_power_of_two! { test_is_power_of_two_u8, u8 }\n+    test_is_power_of_two! { test_is_power_of_two_u16, u16 }\n+    test_is_power_of_two! { test_is_power_of_two_u32, u32 }\n+    test_is_power_of_two! { test_is_power_of_two_u64, u64 }\n+    test_is_power_of_two! { test_is_power_of_two_uint, usize }\n \n     macro_rules! test_next_power_of_two {\n-        ($test_name:ident, $T:ident) => (\n+        ($test_name:ident, $T:ident) => {\n             fn $test_name() {\n                 #![test]\n                 assert_eq!((0 as $T).next_power_of_two(), 1);\n                 let mut next_power = 1;\n                 for i in 1 as $T..40 {\n-                     assert_eq!(i.next_power_of_two(), next_power);\n-                     if i == next_power { next_power *= 2 }\n+                    assert_eq!(i.next_power_of_two(), next_power);\n+                    if i == next_power {\n+                        next_power *= 2\n+                    }\n                 }\n             }\n-        )\n+        };\n     }\n \n     test_next_power_of_two! { test_next_power_of_two_u8, u8 }\n@@ -169,23 +179,25 @@ mod tests {\n     test_next_power_of_two! { test_next_power_of_two_uint, usize }\n \n     macro_rules! test_checked_next_power_of_two {\n-        ($test_name:ident, $T:ident) => (\n+        ($test_name:ident, $T:ident) => {\n             fn $test_name() {\n                 #![test]\n                 assert_eq!((0 as $T).checked_next_power_of_two(), Some(1));\n                 let smax = $T::MAX >> 1;\n-                assert_eq!(smax.checked_next_power_of_two(), Some(smax+1));\n+                assert_eq!(smax.checked_next_power_of_two(), Some(smax + 1));\n                 assert_eq!((smax + 1).checked_next_power_of_two(), Some(smax + 1));\n                 assert_eq!((smax + 2).checked_next_power_of_two(), None);\n                 assert_eq!(($T::MAX - 1).checked_next_power_of_two(), None);\n                 assert_eq!($T::MAX.checked_next_power_of_two(), None);\n                 let mut next_power = 1;\n                 for i in 1 as $T..40 {\n-                     assert_eq!(i.checked_next_power_of_two(), Some(next_power));\n-                     if i == next_power { next_power *= 2 }\n+                    assert_eq!(i.checked_next_power_of_two(), Some(next_power));\n+                    if i == next_power {\n+                        next_power *= 2\n+                    }\n                 }\n             }\n-        )\n+        };\n     }\n \n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u8, u8 }\n@@ -196,15 +208,15 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Mul<Output=T> + Copy>(one: T, base: T, exp: usize) -> T {\n+        fn naive_pow<T: Mul<Output = T> + Copy>(one: T, base: T, exp: usize) -> T {\n             (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n             (($num:expr, $exp:expr) => $expected:expr) => {{\n                 let result = $num.pow($exp);\n                 assert_eq!(result, $expected);\n                 assert_eq!(result, naive_pow(1, $num, $exp));\n-            }}\n+            }};\n         }\n         assert_pow!((3u32,     0 ) => 1);\n         assert_pow!((5u32,     1 ) => 5);\n@@ -280,14 +292,15 @@ mod tests {\n     }\n }\n \n-\n #[cfg(test)]\n mod bench {\n     use test::Bencher;\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n         let v = (0..1024).collect::<Vec<u32>>();\n-        b.iter(|| {v.iter().fold(0u32, |old, new| old.pow(*new as u32));});\n+        b.iter(|| {\n+            v.iter().fold(0u32, |old, new| old.pow(*new as u32));\n+        });\n     }\n }"}, {"sha": "ac8e0daf766bfc4d7df36e7a8545bde1cfd3c778", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -7,21 +7,21 @@ use crate::cell::UnsafeCell;\n use crate::collections;\n use crate::fmt;\n use crate::future::Future;\n-use crate::pin::Pin;\n use crate::ops::{Deref, DerefMut};\n use crate::panicking;\n-use crate::ptr::{Unique, NonNull};\n+use crate::pin::Pin;\n+use crate::ptr::{NonNull, Unique};\n use crate::rc::Rc;\n-use crate::sync::{Arc, Mutex, RwLock};\n use crate::sync::atomic;\n+use crate::sync::{Arc, Mutex, RwLock};\n use crate::task::{Context, Poll};\n use crate::thread::Result;\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-pub use crate::panicking::{take_hook, set_hook};\n+pub use crate::panicking::{set_hook, take_hook};\n \n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n-pub use core::panic::{PanicInfo, Location};\n+pub use core::panic::{Location, PanicInfo};\n \n /// A marker trait which represents \"panic safe\" types in Rust.\n ///\n@@ -103,8 +103,8 @@ pub use core::panic::{PanicInfo, Location};\n /// [`AssertUnwindSafe`]: ./struct.AssertUnwindSafe.html\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented(\n-    message=\"the type `{Self}` may not be safely transferred across an unwind boundary\",\n-    label=\"`{Self}` may not be safely transferred across an unwind boundary\",\n+    message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n+    label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n )]\n pub auto trait UnwindSafe {}\n \n@@ -121,10 +121,10 @@ pub auto trait UnwindSafe {}\n /// [`UnwindSafe`]: ./trait.UnwindSafe.html\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented(\n-    message=\"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n-             transferrable across a catch_unwind boundary\",\n-    label=\"`{Self}` may contain interior mutability and a reference may not be safely \\\n-           transferrable across a catch_unwind boundary\",\n+    message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n+               transferrable across a catch_unwind boundary\",\n+    label = \"`{Self}` may contain interior mutability and a reference may not be safely \\\n+             transferrable across a catch_unwind boundary\"\n )]\n pub auto trait RefUnwindSafe {}\n \n@@ -187,10 +187,7 @@ pub auto trait RefUnwindSafe {}\n /// // ...\n /// ```\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-pub struct AssertUnwindSafe<T>(\n-    #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n-    pub T\n-);\n+pub struct AssertUnwindSafe<T>(#[stable(feature = \"catch_unwind\", since = \"1.9.0\")] pub T);\n \n // Implementations of the `UnwindSafe` trait:\n //\n@@ -290,7 +287,12 @@ impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n // https://github.com/rust-lang/rust/issues/62301\n #[stable(feature = \"hashbrown\", since = \"1.36.0\")]\n impl<K, V, S> UnwindSafe for collections::HashMap<K, V, S>\n-    where K: UnwindSafe, V: UnwindSafe, S: UnwindSafe {}\n+where\n+    K: UnwindSafe,\n+    V: UnwindSafe,\n+    S: UnwindSafe,\n+{\n+}\n \n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> Deref for AssertUnwindSafe<T> {\n@@ -320,9 +322,7 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"AssertUnwindSafe\")\n-            .field(&self.0)\n-            .finish()\n+        f.debug_tuple(\"AssertUnwindSafe\").field(&self.0).finish()\n     }\n }\n \n@@ -391,9 +391,7 @@ impl<F: Future> Future for AssertUnwindSafe<F> {\n /// ```\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n-    unsafe {\n-        panicking::r#try(f)\n-    }\n+    unsafe { panicking::r#try(f) }\n }\n \n /// Triggers a panic without invoking the panic hook."}, {"sha": "42bca0a9575b3da705f9e17192453f512b7f93d9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 781, "deletions": 847, "changes": 1628, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -84,7 +84,7 @@ use crate::sync::Arc;\n \n use crate::ffi::{OsStr, OsString};\n \n-use crate::sys::path::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n+use crate::sys::path::{is_sep_byte, is_verbatim_sep, parse_prefix, MAIN_SEP_STR};\n \n ////////////////////////////////////////////////////////////////////////////////\n // GENERAL NOTES\n@@ -196,26 +196,13 @@ impl<'a> Prefix<'a> {\n         match *self {\n             Verbatim(x) => 4 + os_str_len(x),\n             VerbatimUNC(x, y) => {\n-                8 + os_str_len(x) +\n-                if os_str_len(y) > 0 {\n-                    1 + os_str_len(y)\n-                } else {\n-                    0\n-                }\n-            },\n+                8 + os_str_len(x) + if os_str_len(y) > 0 { 1 + os_str_len(y) } else { 0 }\n+            }\n             VerbatimDisk(_) => 6,\n-            UNC(x, y) => {\n-                2 + os_str_len(x) +\n-                if os_str_len(y) > 0 {\n-                    1 + os_str_len(y)\n-                } else {\n-                    0\n-                }\n-            },\n+            UNC(x, y) => 2 + os_str_len(x) + if os_str_len(y) > 0 { 1 + os_str_len(y) } else { 0 },\n             DeviceNS(x) => 4 + os_str_len(x),\n             Disk(_) => 2,\n         }\n-\n     }\n \n     /// Determines if the prefix is verbatim, i.e., begins with `\\\\?\\`.\n@@ -291,8 +278,9 @@ pub const MAIN_SEPARATOR: char = crate::sys::path::MAIN_SEP;\n // is not a prefix of `iter`, otherwise return `Some(iter_after_prefix)` giving\n // `iter` after having exhausted `prefix`.\n fn iter_after<'a, 'b, I, J>(mut iter: I, mut prefix: J) -> Option<I>\n-    where I: Iterator<Item = Component<'a>> + Clone,\n-          J: Iterator<Item = Component<'b>>,\n+where\n+    I: Iterator<Item = Component<'a>> + Clone,\n+    J: Iterator<Item = Component<'b>>,\n {\n     loop {\n         let mut iter_next = iter.clone();\n@@ -326,11 +314,7 @@ fn has_redox_scheme(s: &[u8]) -> bool {\n \n /// Says whether the first byte after the prefix is a separator.\n fn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n-    let path = if let Some(p) = prefix {\n-        &s[p.len()..]\n-    } else {\n-        s\n-    };\n+    let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n     !path.is_empty() && is_sep_byte(path[0])\n }\n \n@@ -352,8 +336,7 @@ fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n         if before == Some(b\"\") {\n             (Some(file), None)\n         } else {\n-            (before.map(|s| u8_slice_as_os_str(s)),\n-             after.map(|s| u8_slice_as_os_str(s)))\n+            (before.map(|s| u8_slice_as_os_str(s)), after.map(|s| u8_slice_as_os_str(s)))\n         }\n     }\n }\n@@ -370,9 +353,9 @@ fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n /// directory component, and a body (of normal components)\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n enum State {\n-    Prefix = 0,         // c:\n-    StartDir = 1,       // / or . or nothing\n-    Body = 2,           // foo/bar/baz\n+    Prefix = 0,   // c:\n+    StartDir = 1, // / or . or nothing\n+    Body = 2,     // foo/bar/baz\n     Done = 3,\n }\n \n@@ -509,9 +492,7 @@ pub enum Component<'a> {\n     ///\n     /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Prefix(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>\n-    ),\n+    Prefix(#[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>),\n \n     /// The root directory component, appears after any prefix and before anything else.\n     ///\n@@ -637,15 +618,11 @@ impl fmt::Debug for Components<'_> {\n \n         impl fmt::Debug for DebugHelper<'_> {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.debug_list()\n-                    .entries(self.0.components())\n-                    .finish()\n+                f.debug_list().entries(self.0.components()).finish()\n             }\n         }\n \n-        f.debug_tuple(\"Components\")\n-            .field(&DebugHelper(self.as_path()))\n-            .finish()\n+        f.debug_tuple(\"Components\").field(&DebugHelper(self.as_path())).finish()\n     }\n }\n \n@@ -664,26 +641,14 @@ impl<'a> Components<'a> {\n     /// how much of the prefix is left from the point of view of iteration?\n     #[inline]\n     fn prefix_remaining(&self) -> usize {\n-        if self.front == State::Prefix {\n-            self.prefix_len()\n-        } else {\n-            0\n-        }\n+        if self.front == State::Prefix { self.prefix_len() } else { 0 }\n     }\n \n     // Given the iteration so far, how much of the pre-State::Body path is left?\n     #[inline]\n     fn len_before_body(&self) -> usize {\n-        let root = if self.front <= State::StartDir && self.has_physical_root {\n-            1\n-        } else {\n-            0\n-        };\n-        let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() {\n-            1\n-        } else {\n-            0\n-        };\n+        let root = if self.front <= State::StartDir && self.has_physical_root { 1 } else { 0 };\n+        let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() { 1 } else { 0 };\n         self.prefix_remaining() + root + cur_dir\n     }\n \n@@ -695,11 +660,7 @@ impl<'a> Components<'a> {\n \n     #[inline]\n     fn is_sep_byte(&self, b: u8) -> bool {\n-        if self.prefix_verbatim() {\n-            is_verbatim_sep(b)\n-        } else {\n-            is_sep_byte(b)\n-        }\n+        if self.prefix_verbatim() { is_verbatim_sep(b) } else { is_sep_byte(b) }\n     }\n \n     /// Extracts a slice corresponding to the portion of the path remaining for iteration.\n@@ -758,8 +719,8 @@ impl<'a> Components<'a> {\n         match comp {\n             b\".\" if self.prefix_verbatim() => Some(Component::CurDir),\n             b\".\" => None, // . components are normalized away, except at\n-                          // the beginning of a path, which is treated\n-                          // separately via `include_cur_dir`\n+            // the beginning of a path, which is treated\n+            // separately via `include_cur_dir`\n             b\"..\" => Some(Component::ParentDir),\n             b\"\" => None,\n             _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) })),\n@@ -835,15 +796,11 @@ impl fmt::Debug for Iter<'_> {\n \n         impl fmt::Debug for DebugHelper<'_> {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.debug_list()\n-                    .entries(self.0.iter())\n-                    .finish()\n+                f.debug_list().entries(self.0.iter()).finish()\n             }\n         }\n \n-        f.debug_tuple(\"Iter\")\n-            .field(&DebugHelper(self.as_path()))\n-            .finish()\n+        f.debug_tuple(\"Iter\").field(&DebugHelper(self.as_path())).finish()\n     }\n }\n \n@@ -1174,9 +1131,7 @@ impl PathBuf {\n     /// [`OsString`]: ../ffi/struct.OsString.html\n     #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n     pub fn with_capacity(capacity: usize) -> PathBuf {\n-        PathBuf {\n-            inner: OsString::with_capacity(capacity)\n-        }\n+        PathBuf { inner: OsString::with_capacity(capacity) }\n     }\n \n     /// Coerces to a [`Path`] slice.\n@@ -1239,8 +1194,10 @@ impl PathBuf {\n         // in the special case of `C:` on Windows, do *not* add a separator\n         {\n             let comps = self.components();\n-            if comps.prefix_len() > 0 && comps.prefix_len() == comps.path.len() &&\n-               comps.prefix.unwrap().is_drive() {\n+            if comps.prefix_len() > 0\n+                && comps.prefix_len() == comps.path.len()\n+                && comps.prefix.unwrap().is_drive()\n+            {\n                 need_sep = false\n             }\n         }\n@@ -1527,7 +1484,7 @@ impl From<PathBuf> for OsString {\n     /// Converts a `PathBuf` into a `OsString`\n     ///\n     /// This conversion does not allocate or copy memory.\n-    fn from(path_buf : PathBuf) -> OsString {\n+    fn from(path_buf: PathBuf) -> OsString {\n         path_buf.inner\n     }\n }\n@@ -1992,13 +1949,11 @@ impl Path {\n     pub fn parent(&self) -> Option<&Path> {\n         let mut comps = self.components();\n         let comp = comps.next_back();\n-        comp.and_then(|p| {\n-            match p {\n-                Component::Normal(_) |\n-                Component::CurDir |\n-                Component::ParentDir => Some(comps.as_path()),\n-                _ => None,\n+        comp.and_then(|p| match p {\n+            Component::Normal(_) | Component::CurDir | Component::ParentDir => {\n+                Some(comps.as_path())\n             }\n+            _ => None,\n         })\n     }\n \n@@ -2026,9 +1981,7 @@ impl Path {\n     /// [`parent`]: struct.Path.html#method.parent\n     #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n     pub fn ancestors(&self) -> Ancestors<'_> {\n-        Ancestors {\n-            next: Some(&self),\n-        }\n+        Ancestors { next: Some(&self) }\n     }\n \n     /// Returns the final component of the `Path`, if there is one.\n@@ -2055,11 +2008,9 @@ impl Path {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n-        self.components().next_back().and_then(|p| {\n-            match p {\n-                Component::Normal(p) => Some(p.as_ref()),\n-                _ => None,\n-            }\n+        self.components().next_back().and_then(|p| match p {\n+            Component::Normal(p) => Some(p.as_ref()),\n+            _ => None,\n         })\n     }\n \n@@ -2092,15 +2043,14 @@ impl Path {\n     /// assert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));\n     /// ```\n     #[stable(since = \"1.7.0\", feature = \"path_strip_prefix\")]\n-    pub fn strip_prefix<P>(&self, base: P)\n-                           -> Result<&Path, StripPrefixError>\n-        where P: AsRef<Path>\n+    pub fn strip_prefix<P>(&self, base: P) -> Result<&Path, StripPrefixError>\n+    where\n+        P: AsRef<Path>,\n     {\n         self._strip_prefix(base.as_ref())\n     }\n \n-    fn _strip_prefix(&self, base: &Path)\n-                     -> Result<&Path, StripPrefixError> {\n+    fn _strip_prefix(&self, base: &Path) -> Result<&Path, StripPrefixError> {\n         iter_after(self.components(), base.components())\n             .map(|c| c.as_path())\n             .ok_or(StripPrefixError(()))\n@@ -2329,8 +2279,8 @@ impl Path {\n         Components {\n             path: self.as_u8_slice(),\n             prefix,\n-            has_physical_root: has_physical_root(self.as_u8_slice(), prefix) ||\n-                               has_redox_scheme(self.as_u8_slice()),\n+            has_physical_root: has_physical_root(self.as_u8_slice(), prefix)\n+                || has_redox_scheme(self.as_u8_slice()),\n             front: State::Prefix,\n             back: State::Body,\n         }\n@@ -2727,28 +2677,36 @@ impl AsRef<Path> for PathBuf {\n impl<'a> IntoIterator for &'a PathBuf {\n     type Item = &'a OsStr;\n     type IntoIter = Iter<'a>;\n-    fn into_iter(self) -> Iter<'a> { self.iter() }\n+    fn into_iter(self) -> Iter<'a> {\n+        self.iter()\n+    }\n }\n \n #[stable(feature = \"path_into_iter\", since = \"1.6.0\")]\n impl<'a> IntoIterator for &'a Path {\n     type Item = &'a OsStr;\n     type IntoIter = Iter<'a>;\n-    fn into_iter(self) -> Iter<'a> { self.iter() }\n+    fn into_iter(self) -> Iter<'a> {\n+        self.iter()\n+    }\n }\n \n macro_rules! impl_cmp {\n     ($lhs:ty, $rhs: ty) => {\n         #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n         impl<'a, 'b> PartialEq<$rhs> for $lhs {\n             #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { <Path as PartialEq>::eq(self, other) }\n+            fn eq(&self, other: &$rhs) -> bool {\n+                <Path as PartialEq>::eq(self, other)\n+            }\n         }\n \n         #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n         impl<'a, 'b> PartialEq<$lhs> for $rhs {\n             #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { <Path as PartialEq>::eq(self, other) }\n+            fn eq(&self, other: &$lhs) -> bool {\n+                <Path as PartialEq>::eq(self, other)\n+            }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n@@ -2766,7 +2724,7 @@ macro_rules! impl_cmp {\n                 <Path as PartialOrd>::partial_cmp(self, other)\n             }\n         }\n-    }\n+    };\n }\n \n impl_cmp!(PathBuf, Path);\n@@ -2780,13 +2738,17 @@ macro_rules! impl_cmp_os_str {\n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n         impl<'a, 'b> PartialEq<$rhs> for $lhs {\n             #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { <Path as PartialEq>::eq(self, other.as_ref()) }\n+            fn eq(&self, other: &$rhs) -> bool {\n+                <Path as PartialEq>::eq(self, other.as_ref())\n+            }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n         impl<'a, 'b> PartialEq<$lhs> for $rhs {\n             #[inline]\n-            fn eq(&self, other: &$lhs) -> bool { <Path as PartialEq>::eq(self.as_ref(), other) }\n+            fn eq(&self, other: &$lhs) -> bool {\n+                <Path as PartialEq>::eq(self.as_ref(), other)\n+            }\n         }\n \n         #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n@@ -2804,7 +2766,7 @@ macro_rules! impl_cmp_os_str {\n                 <Path as PartialOrd>::partial_cmp(self.as_ref(), other)\n             }\n         }\n-    }\n+    };\n }\n \n impl_cmp_os_str!(PathBuf, OsStr);\n@@ -2831,7 +2793,9 @@ impl fmt::Display for StripPrefixError {\n \n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n impl Error for StripPrefixError {\n-    fn description(&self) -> &str { \"prefix not found\" }\n+    fn description(&self) -> &str {\n+        \"prefix not found\"\n+    }\n }\n \n #[cfg(test)]\n@@ -2948,568 +2912,568 @@ mod tests {\n     #[cfg(unix)]\n     pub fn test_decompositions_unix() {\n         t!(\"\",\n-           iter: [],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"/\",\n-           iter: [\"/\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"/\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"/foo\",\n-           iter: [\"/\", \"foo\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"/foo/\",\n-           iter: [\"/\", \"foo\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/bar\",\n-           iter: [\"foo\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"/foo/bar\",\n-           iter: [\"/\", \"foo\", \"bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\", \"bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"///foo///\",\n-           iter: [\"/\", \"foo\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"///foo///bar\",\n-           iter: [\"/\", \"foo\", \"bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"///foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"/\", \"foo\", \"bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"///foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"./.\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"/..\",\n-           iter: [\"/\", \"..\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"/\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"/\", \"..\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"/\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"../\",\n-           iter: [\"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/.\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/..\",\n-           iter: [\"foo\", \"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/./\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/./bar\",\n-           iter: [\"foo\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"foo/../\",\n-           iter: [\"foo\", \"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/../bar\",\n-           iter: [\"foo\", \"..\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo/..\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo/..\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"./a\",\n-           iter: [\".\", \"a\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\".\"),\n-           file_name: Some(\"a\"),\n-           file_stem: Some(\"a\"),\n-           extension: None\n-           );\n+        iter: [\".\", \"a\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\".\"),\n+        file_name: Some(\"a\"),\n+        file_stem: Some(\"a\"),\n+        extension: None\n+        );\n \n         t!(\".\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"./\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"a/b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a//b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a/./b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a/b/c\",\n-           iter: [\"a\", \"b\", \"c\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a/b\"),\n-           file_name: Some(\"c\"),\n-           file_stem: Some(\"c\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\", \"c\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a/b\"),\n+        file_name: Some(\"c\"),\n+        file_stem: Some(\"c\"),\n+        extension: None\n+        );\n \n         t!(\".foo\",\n-           iter: [\".foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\".foo\"),\n-           file_stem: Some(\".foo\"),\n-           extension: None\n-           );\n+        iter: [\".foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\".foo\"),\n+        file_stem: Some(\".foo\"),\n+        extension: None\n+        );\n     }\n \n     #[test]\n     #[cfg(windows)]\n     pub fn test_decompositions_windows() {\n         t!(\"\",\n-           iter: [],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"/\",\n-           iter: [\"\\\\\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\",\n-           iter: [\"\\\\\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"c:\",\n-           iter: [\"c:\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"c:\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"c:\\\\\",\n-           iter: [\"c:\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"c:\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"c:/\",\n-           iter: [\"c:\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"c:\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"/foo\",\n-           iter: [\"\\\\\", \"foo\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"/foo/\",\n-           iter: [\"\\\\\", \"foo\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/bar\",\n-           iter: [\"foo\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"/foo/bar\",\n-           iter: [\"\\\\\", \"foo\", \"bar\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\", \"bar\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"///foo///\",\n-           iter: [\"\\\\\", \"foo\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"///foo///bar\",\n-           iter: [\"\\\\\", \"foo\", \"bar\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"///foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"foo\", \"bar\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"///foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"./.\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"/..\",\n-           iter: [\"\\\\\", \"..\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"/\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"..\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"/\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"../\",\n-           iter: [\"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/.\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/..\",\n-           iter: [\"foo\", \"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/./\",\n-           iter: [\"foo\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: Some(\"foo\"),\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        iter: [\"foo\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: Some(\"foo\"),\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo/./bar\",\n-           iter: [\"foo\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"foo/../\",\n-           iter: [\"foo\", \"..\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"foo/../bar\",\n-           iter: [\"foo\", \"..\", \"bar\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"foo/..\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n+        iter: [\"foo\", \"..\", \"bar\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"foo/..\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"./a\",\n-           iter: [\".\", \"a\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\".\"),\n-           file_name: Some(\"a\"),\n-           file_stem: Some(\"a\"),\n-           extension: None\n-           );\n+        iter: [\".\", \"a\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\".\"),\n+        file_name: Some(\"a\"),\n+        file_stem: Some(\"a\"),\n+        extension: None\n+        );\n \n         t!(\".\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"./\",\n-           iter: [\".\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"\"),\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\".\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"\"),\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"a/b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a//b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a/./b\",\n-           iter: [\"a\", \"b\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n \n         t!(\"a/b/c\",\n            iter: [\"a\", \"b\", \"c\"],\n@@ -3521,291 +3485,273 @@ mod tests {\n            extension: None);\n \n         t!(\"a\\\\b\\\\c\",\n-           iter: [\"a\", \"b\", \"c\"],\n-           has_root: false,\n-           is_absolute: false,\n-           parent: Some(\"a\\\\b\"),\n-           file_name: Some(\"c\"),\n-           file_stem: Some(\"c\"),\n-           extension: None\n-           );\n+        iter: [\"a\", \"b\", \"c\"],\n+        has_root: false,\n+        is_absolute: false,\n+        parent: Some(\"a\\\\b\"),\n+        file_name: Some(\"c\"),\n+        file_stem: Some(\"c\"),\n+        extension: None\n+        );\n \n         t!(\"\\\\a\",\n-           iter: [\"\\\\\", \"a\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"\\\\\"),\n-           file_name: Some(\"a\"),\n-           file_stem: Some(\"a\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"a\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"\\\\\"),\n+        file_name: Some(\"a\"),\n+        file_stem: Some(\"a\"),\n+        extension: None\n+        );\n \n         t!(\"c:\\\\foo.txt\",\n-           iter: [\"c:\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"c:\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        iter: [\"c:\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"c:\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\server\\\\share\\\\foo.txt\",\n-           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\server\\\\share\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        iter: [\"\\\\\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\server\\\\share\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\server\\\\share\",\n-           iter: [\"\\\\\\\\server\\\\share\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\server\\\\share\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\server\",\n-           iter: [\"\\\\\", \"server\"],\n-           has_root: true,\n-           is_absolute: false,\n-           parent: Some(\"\\\\\"),\n-           file_name: Some(\"server\"),\n-           file_stem: Some(\"server\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\", \"server\"],\n+        has_root: true,\n+        is_absolute: false,\n+        parent: Some(\"\\\\\"),\n+        file_name: Some(\"server\"),\n+        file_stem: Some(\"server\"),\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\bar\\\\foo.txt\",\n-           iter: [\"\\\\\\\\?\\\\bar\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\bar\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        iter: [\"\\\\\\\\?\\\\bar\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\?\\\\bar\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\?\\\\bar\",\n-           iter: [\"\\\\\\\\?\\\\bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\\",\n-           iter: [\"\\\\\\\\?\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\",\n-           iter: [\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        iter: [\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\?\\\\UNC\\\\server\",\n-           iter: [\"\\\\\\\\?\\\\UNC\\\\server\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\UNC\\\\server\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\UNC\\\\\",\n-           iter: [\"\\\\\\\\?\\\\UNC\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\UNC\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\C:\\\\foo.txt\",\n-           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo.txt\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\C:\\\\\"),\n-           file_name: Some(\"foo.txt\"),\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\", \"foo.txt\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\?\\\\C:\\\\\"),\n+        file_name: Some(\"foo.txt\"),\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"\\\\\\\\?\\\\C:\\\\\",\n-           iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\C:\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\C:\",\n-           iter: [\"\\\\\\\\?\\\\C:\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\C:\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\foo/bar\",\n-           iter: [\"\\\\\\\\?\\\\foo/bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\foo/bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\C:/foo\",\n-           iter: [\"\\\\\\\\?\\\\C:/foo\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\?\\\\C:/foo\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\foo\\\\bar\",\n-           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\.\\\\foo\\\\\"),\n-           file_name: Some(\"bar\"),\n-           file_stem: Some(\"bar\"),\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\.\\\\foo\\\\\"),\n+        file_name: Some(\"bar\"),\n+        file_stem: Some(\"bar\"),\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\foo\",\n-           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\foo/bar\",\n-           iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\.\\\\foo/bar\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\foo\\\\bar/baz\",\n-           iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\", \"baz\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\.\\\\foo\\\\bar\"),\n-           file_name: Some(\"baz\"),\n-           file_stem: Some(\"baz\"),\n-           extension: None\n-           );\n-\n+        iter: [\"\\\\\\\\.\\\\foo\", \"\\\\\", \"bar\", \"baz\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\.\\\\foo\\\\bar\"),\n+        file_name: Some(\"baz\"),\n+        file_stem: Some(\"baz\"),\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\.\\\\\",\n-           iter: [\"\\\\\\\\.\\\\\", \"\\\\\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: None,\n-           file_name: None,\n-           file_stem: None,\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\.\\\\\", \"\\\\\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: None,\n+        file_name: None,\n+        file_stem: None,\n+        extension: None\n+        );\n \n         t!(\"\\\\\\\\?\\\\a\\\\b\\\\\",\n-           iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\"],\n-           has_root: true,\n-           is_absolute: true,\n-           parent: Some(\"\\\\\\\\?\\\\a\\\\\"),\n-           file_name: Some(\"b\"),\n-           file_stem: Some(\"b\"),\n-           extension: None\n-           );\n+        iter: [\"\\\\\\\\?\\\\a\", \"\\\\\", \"b\"],\n+        has_root: true,\n+        is_absolute: true,\n+        parent: Some(\"\\\\\\\\?\\\\a\\\\\"),\n+        file_name: Some(\"b\"),\n+        file_stem: Some(\"b\"),\n+        extension: None\n+        );\n     }\n \n     #[test]\n     pub fn test_stem_ext() {\n         t!(\"foo\",\n-           file_stem: Some(\"foo\"),\n-           extension: None\n-           );\n+        file_stem: Some(\"foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo.\",\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"\")\n-           );\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"\")\n+        );\n \n         t!(\".foo\",\n-           file_stem: Some(\".foo\"),\n-           extension: None\n-           );\n+        file_stem: Some(\".foo\"),\n+        extension: None\n+        );\n \n         t!(\"foo.txt\",\n-           file_stem: Some(\"foo\"),\n-           extension: Some(\"txt\")\n-           );\n+        file_stem: Some(\"foo\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"foo.bar.txt\",\n-           file_stem: Some(\"foo.bar\"),\n-           extension: Some(\"txt\")\n-           );\n+        file_stem: Some(\"foo.bar\"),\n+        extension: Some(\"txt\")\n+        );\n \n         t!(\"foo.bar.\",\n-           file_stem: Some(\"foo.bar\"),\n-           extension: Some(\"\")\n-           );\n+        file_stem: Some(\"foo.bar\"),\n+        extension: Some(\"\")\n+        );\n \n-        t!(\".\",\n-           file_stem: None,\n-           extension: None\n-           );\n+        t!(\".\", file_stem: None, extension: None);\n \n-        t!(\"..\",\n-           file_stem: None,\n-           extension: None\n-           );\n+        t!(\"..\", file_stem: None, extension: None);\n \n-        t!(\"\",\n-           file_stem: None,\n-           extension: None\n-           );\n+        t!(\"\", file_stem: None, extension: None);\n     }\n \n     #[test]\n@@ -3873,26 +3819,20 @@ mod tests {\n             tp!(\"C:a\\\\b\\\\c\", \"C:d\", \"C:d\");\n             tp!(\"C:\", r\"a\\b\\c\", r\"C:a\\b\\c\");\n             tp!(\"C:\", r\"..\\a\", r\"C:..\\a\");\n-            tp!(\"\\\\\\\\server\\\\share\\\\foo\",\n-                \"bar\",\n-                \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n             tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\",\n-                \"bar\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n \n             // Note: modified from old path API\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\foo\");\n \n-            tp!(\"C:\\\\a\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n+            tp!(\"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n             tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n             tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n             // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n@@ -3945,15 +3885,9 @@ mod tests {\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n             tp!(\"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\",\n-                true);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\",\n-                true);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n-                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n-                false);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\", true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n             tp!(\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n             tp!(\"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\\\\\", true);\n             tp!(\"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n@@ -4051,8 +3985,8 @@ mod tests {\n \n     #[test]\n     pub fn test_compare() {\n-        use crate::hash::{Hash, Hasher};\n         use crate::collections::hash_map::DefaultHasher;\n+        use crate::hash::{Hash, Hasher};\n \n         fn hash<T: Hash>(t: T) -> u64 {\n             let mut s = DefaultHasher::new();\n@@ -4095,83 +4029,83 @@ mod tests {\n         );\n \n         tc!(\"\", \"\",\n-            eq: true,\n-            starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"\")\n-            );\n+        eq: true,\n+        starts_with: true,\n+        ends_with: true,\n+        relative_from: Some(\"\")\n+        );\n \n         tc!(\"foo\", \"\",\n-            eq: false,\n-            starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"foo\")\n-            );\n+        eq: false,\n+        starts_with: true,\n+        ends_with: true,\n+        relative_from: Some(\"foo\")\n+        );\n \n         tc!(\"\", \"foo\",\n-            eq: false,\n-            starts_with: false,\n-            ends_with: false,\n-            relative_from: None\n-            );\n+        eq: false,\n+        starts_with: false,\n+        ends_with: false,\n+        relative_from: None\n+        );\n \n         tc!(\"foo\", \"foo\",\n-            eq: true,\n-            starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"\")\n-            );\n+        eq: true,\n+        starts_with: true,\n+        ends_with: true,\n+        relative_from: Some(\"\")\n+        );\n \n         tc!(\"foo/\", \"foo\",\n-            eq: true,\n-            starts_with: true,\n-            ends_with: true,\n-            relative_from: Some(\"\")\n-            );\n+        eq: true,\n+        starts_with: true,\n+        ends_with: true,\n+        relative_from: Some(\"\")\n+        );\n \n         tc!(\"foo/bar\", \"foo\",\n-            eq: false,\n-            starts_with: true,\n-            ends_with: false,\n-            relative_from: Some(\"bar\")\n-            );\n+        eq: false,\n+        starts_with: true,\n+        ends_with: false,\n+        relative_from: Some(\"bar\")\n+        );\n \n         tc!(\"foo/bar/baz\", \"foo/bar\",\n-            eq: false,\n-            starts_with: true,\n-            ends_with: false,\n-            relative_from: Some(\"baz\")\n-            );\n+        eq: false,\n+        starts_with: true,\n+        ends_with: false,\n+        relative_from: Some(\"baz\")\n+        );\n \n         tc!(\"foo/bar\", \"foo/bar/baz\",\n-            eq: false,\n-            starts_with: false,\n-            ends_with: false,\n-            relative_from: None\n-            );\n+        eq: false,\n+        starts_with: false,\n+        ends_with: false,\n+        relative_from: None\n+        );\n \n         tc!(\"./foo/bar/\", \".\",\n+        eq: false,\n+        starts_with: true,\n+        ends_with: false,\n+        relative_from: Some(\"foo/bar\")\n+        );\n+\n+        if cfg!(windows) {\n+            tc!(r\"C:\\src\\rust\\cargo-test\\test\\Cargo.toml\",\n+            r\"c:\\src\\rust\\cargo-test\\test\",\n             eq: false,\n             starts_with: true,\n             ends_with: false,\n-            relative_from: Some(\"foo/bar\")\n+            relative_from: Some(\"Cargo.toml\")\n             );\n \n-        if cfg!(windows) {\n-            tc!(r\"C:\\src\\rust\\cargo-test\\test\\Cargo.toml\",\n-                r\"c:\\src\\rust\\cargo-test\\test\",\n-                eq: false,\n-                starts_with: true,\n-                ends_with: false,\n-                relative_from: Some(\"Cargo.toml\")\n-                );\n-\n             tc!(r\"c:\\foo\", r\"C:\\foo\",\n-                eq: true,\n-                starts_with: true,\n-                ends_with: true,\n-                relative_from: Some(\"\")\n-                );\n+            eq: true,\n+            starts_with: true,\n+            ends_with: true,\n+            relative_from: Some(\"\")\n+            );\n         }\n     }\n "}, {"sha": "7c0efe828c27acff030c97a114b8dc5797631dc0", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 12, "deletions": 46, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -2,8 +2,6 @@\n //!\n //! See the [module-level documentation](../index.html) for more.\n \n-\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Re-exported core operators\n@@ -22,45 +20,27 @@ pub use crate::mem::drop;\n // Re-exported types and traits\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::convert::{AsRef, AsMut, Into, From};\n+pub use crate::convert::{AsMut, AsRef, From, Into};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{Iterator, Extend, IntoIterator};\n+pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n+pub use crate::iter::{Extend, IntoIterator, Iterator};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::option::Option::{self, Some, None};\n+pub use crate::option::Option::{self, None, Some};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::result::Result::{self, Ok, Err};\n+pub use crate::result::Result::{self, Err, Ok};\n \n // Re-exported built-in macros\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use core::prelude::v1::{\n-    asm,\n-    assert,\n-    cfg,\n-    column,\n-    compile_error,\n-    concat,\n-    concat_idents,\n-    env,\n-    file,\n-    format_args,\n-    format_args_nl,\n-    global_asm,\n-    include,\n-    include_bytes,\n-    include_str,\n-    line,\n-    log_syntax,\n-    module_path,\n-    option_env,\n-    stringify,\n-    trace_macros,\n+    asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n+    format_args_nl, global_asm, include, include_bytes, include_str, line, log_syntax, module_path,\n+    option_env, stringify, trace_macros,\n };\n \n // FIXME: Attribute and derive macros are not documented because for them rustdoc generates\n@@ -69,35 +49,21 @@ pub use core::prelude::v1::{\n #[allow(deprecated)]\n #[doc(hidden)]\n pub use core::prelude::v1::{\n-    Clone,\n-    Copy,\n-    Debug,\n-    Default,\n-    Eq,\n-    Hash,\n-    Ord,\n-    PartialEq,\n-    PartialOrd,\n-    RustcDecodable,\n-    RustcEncodable,\n-    bench,\n-    global_allocator,\n-    test,\n-    test_case,\n+    bench, global_allocator, test, test_case, Clone, Copy, Debug, Default, Eq, Hash, Ord,\n+    PartialEq, PartialOrd, RustcDecodable, RustcEncodable,\n };\n \n // The file so far is equivalent to src/libcore/prelude/v1.rs,\n // and below to src/liballoc/prelude.rs.\n // Those files are duplicated rather than using glob imports\n // because we want docs to show these re-exports as pointing to within `std`.\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::boxed::Box;\n+pub use crate::borrow::ToOwned;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::borrow::ToOwned;\n+pub use crate::boxed::Box;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::string::{String, ToString};"}, {"sha": "3eee45d000cd10ea6ac1237833606fcb2ad3e302", "filename": "src/libstd/process.rs", "status": "modified", "additions": 133, "deletions": 86, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -186,7 +186,9 @@ pub struct Child {\n }\n \n impl AsInner<imp::Process> for Child {\n-    fn as_inner(&self) -> &imp::Process { &self.handle }\n+    fn as_inner(&self) -> &imp::Process {\n+        &self.handle\n+    }\n }\n \n impl FromInner<(imp::Process, imp::StdioPipes)> for Child {\n@@ -201,7 +203,9 @@ impl FromInner<(imp::Process, imp::StdioPipes)> for Child {\n }\n \n impl IntoInner<imp::Process> for Child {\n-    fn into_inner(self) -> imp::Process { self.handle }\n+    fn into_inner(self) -> imp::Process {\n+        self.handle\n+    }\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -228,7 +232,7 @@ impl fmt::Debug for Child {\n /// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n-    inner: AnonPipe\n+    inner: AnonPipe,\n }\n \n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -247,11 +251,15 @@ impl Write for ChildStdin {\n }\n \n impl AsInner<AnonPipe> for ChildStdin {\n-    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+    fn as_inner(&self) -> &AnonPipe {\n+        &self.inner\n+    }\n }\n \n impl IntoInner<AnonPipe> for ChildStdin {\n-    fn into_inner(self) -> AnonPipe { self.inner }\n+    fn into_inner(self) -> AnonPipe {\n+        self.inner\n+    }\n }\n \n impl FromInner<AnonPipe> for ChildStdin {\n@@ -279,7 +287,7 @@ impl fmt::Debug for ChildStdin {\n /// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n-    inner: AnonPipe\n+    inner: AnonPipe,\n }\n \n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -299,11 +307,15 @@ impl Read for ChildStdout {\n }\n \n impl AsInner<AnonPipe> for ChildStdout {\n-    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+    fn as_inner(&self) -> &AnonPipe {\n+        &self.inner\n+    }\n }\n \n impl IntoInner<AnonPipe> for ChildStdout {\n-    fn into_inner(self) -> AnonPipe { self.inner }\n+    fn into_inner(self) -> AnonPipe {\n+        self.inner\n+    }\n }\n \n impl FromInner<AnonPipe> for ChildStdout {\n@@ -331,7 +343,7 @@ impl fmt::Debug for ChildStdout {\n /// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n-    inner: AnonPipe\n+    inner: AnonPipe,\n }\n \n #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -351,11 +363,15 @@ impl Read for ChildStderr {\n }\n \n impl AsInner<AnonPipe> for ChildStderr {\n-    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+    fn as_inner(&self) -> &AnonPipe {\n+        &self.inner\n+    }\n }\n \n impl IntoInner<AnonPipe> for ChildStderr {\n-    fn into_inner(self) -> AnonPipe { self.inner }\n+    fn into_inner(self) -> AnonPipe {\n+        self.inner\n+    }\n }\n \n impl FromInner<AnonPipe> for ChildStderr {\n@@ -533,7 +549,9 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn args<I, S>(&mut self, args: I) -> &mut Command\n-        where I: IntoIterator<Item=S>, S: AsRef<OsStr>\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n     {\n         for arg in args {\n             self.arg(arg.as_ref());\n@@ -560,7 +578,9 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n-        where K: AsRef<OsStr>, V: AsRef<OsStr>\n+    where\n+        K: AsRef<OsStr>,\n+        V: AsRef<OsStr>,\n     {\n         self.inner.env_mut().set(key.as_ref(), val.as_ref());\n         self\n@@ -592,7 +612,10 @@ impl Command {\n     /// ```\n     #[stable(feature = \"command_envs\", since = \"1.19.0\")]\n     pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Command\n-        where I: IntoIterator<Item=(K, V)>, K: AsRef<OsStr>, V: AsRef<OsStr>\n+    where\n+        I: IntoIterator<Item = (K, V)>,\n+        K: AsRef<OsStr>,\n+        V: AsRef<OsStr>,\n     {\n         for (ref key, ref val) in vars {\n             self.inner.env_mut().set(key.as_ref(), val.as_ref());\n@@ -794,7 +817,9 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn output(&mut self) -> io::Result<Output> {\n-        self.inner.spawn(imp::Stdio::MakePipe, false).map(Child::from_inner)\n+        self.inner\n+            .spawn(imp::Stdio::MakePipe, false)\n+            .map(Child::from_inner)\n             .and_then(|p| p.wait_with_output())\n     }\n \n@@ -819,8 +844,10 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn status(&mut self) -> io::Result<ExitStatus> {\n-        self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n-                  .and_then(|mut p| p.wait())\n+        self.inner\n+            .spawn(imp::Stdio::Inherit, true)\n+            .map(Child::from_inner)\n+            .and_then(|mut p| p.wait())\n     }\n }\n \n@@ -835,11 +862,15 @@ impl fmt::Debug for Command {\n }\n \n impl AsInner<imp::Command> for Command {\n-    fn as_inner(&self) -> &imp::Command { &self.inner }\n+    fn as_inner(&self) -> &imp::Command {\n+        &self.inner\n+    }\n }\n \n impl AsInnerMut<imp::Command> for Command {\n-    fn as_inner_mut(&mut self) -> &mut imp::Command { &mut self.inner }\n+    fn as_inner_mut(&mut self) -> &mut imp::Command {\n+        &mut self.inner\n+    }\n }\n \n /// The output of a finished process.\n@@ -871,17 +902,16 @@ pub struct Output {\n #[stable(feature = \"process_output_debug\", since = \"1.7.0\")]\n impl fmt::Debug for Output {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-\n         let stdout_utf8 = str::from_utf8(&self.stdout);\n         let stdout_debug: &dyn fmt::Debug = match stdout_utf8 {\n             Ok(ref str) => str,\n-            Err(_) => &self.stdout\n+            Err(_) => &self.stdout,\n         };\n \n         let stderr_utf8 = str::from_utf8(&self.stderr);\n         let stderr_debug: &dyn fmt::Debug = match stderr_utf8 {\n             Ok(ref str) => str,\n-            Err(_) => &self.stderr\n+            Err(_) => &self.stderr,\n         };\n \n         fmt.debug_struct(\"Output\")\n@@ -943,7 +973,9 @@ impl Stdio {\n     /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\");\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn piped() -> Stdio { Stdio(imp::Stdio::MakePipe) }\n+    pub fn piped() -> Stdio {\n+        Stdio(imp::Stdio::MakePipe)\n+    }\n \n     /// The child inherits from the corresponding parent descriptor.\n     ///\n@@ -980,7 +1012,9 @@ impl Stdio {\n     /// io::stdout().write_all(&output.stdout).unwrap();\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn inherit() -> Stdio { Stdio(imp::Stdio::Inherit) }\n+    pub fn inherit() -> Stdio {\n+        Stdio(imp::Stdio::Inherit)\n+    }\n \n     /// This stream will be ignored. This is the equivalent of attaching the\n     /// stream to `/dev/null`\n@@ -1017,7 +1051,9 @@ impl Stdio {\n     /// // Ignores any piped-in input\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn null() -> Stdio { Stdio(imp::Stdio::Null) }\n+    pub fn null() -> Stdio {\n+        Stdio(imp::Stdio::Null)\n+    }\n }\n \n impl FromInner<imp::Stdio> for Stdio {\n@@ -1217,7 +1253,9 @@ impl ExitStatus {\n }\n \n impl AsInner<imp::ExitStatus> for ExitStatus {\n-    fn as_inner(&self) -> &imp::ExitStatus { &self.0 }\n+    fn as_inner(&self) -> &imp::ExitStatus {\n+        &self.0\n+    }\n }\n \n impl FromInner<imp::ExitStatus> for ExitStatus {\n@@ -1449,11 +1487,7 @@ impl Child {\n         }\n \n         let status = self.wait()?;\n-        Ok(Output {\n-            status,\n-            stdout,\n-            stderr,\n-        })\n+        Ok(Output { status, stdout, stderr })\n     }\n }\n \n@@ -1604,8 +1638,9 @@ pub fn id() -> u32 {\n #[cfg_attr(not(test), lang = \"termination\")]\n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n #[rustc_on_unimplemented(\n-  message=\"`main` has invalid return type `{Self}`\",\n-  label=\"`main` can only return types that implement `{Termination}`\")]\n+    message = \"`main` has invalid return type `{Self}`\",\n+    label = \"`main` can only return types that implement `{Termination}`\"\n+)]\n pub trait Termination {\n     /// Is called to get the representation of the value as status code.\n     /// This status code is returned to the operating system.\n@@ -1615,7 +1650,9 @@ pub trait Termination {\n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n impl Termination for () {\n     #[inline]\n-    fn report(self) -> i32 { ExitCode::SUCCESS.report() }\n+    fn report(self) -> i32 {\n+        ExitCode::SUCCESS.report()\n+    }\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n@@ -1630,7 +1667,9 @@ impl<E: fmt::Debug> Termination for Result<(), E> {\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n impl Termination for ! {\n-    fn report(self) -> i32 { self }\n+    fn report(self) -> i32 {\n+        self\n+    }\n }\n \n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n@@ -1654,9 +1693,9 @@ impl Termination for ExitCode {\n mod tests {\n     use crate::io::prelude::*;\n \n+    use super::{Command, Output, Stdio};\n     use crate::io::ErrorKind;\n     use crate::str;\n-    use super::{Command, Output, Stdio};\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n \n@@ -1702,15 +1741,12 @@ mod tests {\n     fn signal_reported_right() {\n         use crate::os::unix::process::ExitStatusExt;\n \n-        let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"read a\")\n-                            .stdin(Stdio::piped())\n-                            .spawn().unwrap();\n+        let mut p =\n+            Command::new(\"/bin/sh\").arg(\"-c\").arg(\"read a\").stdin(Stdio::piped()).spawn().unwrap();\n         p.kill().unwrap();\n         match p.wait().unwrap().signal() {\n-            Some(9) => {},\n-            result => panic!(\"not terminated by signal 9 (instead, {:?})\",\n-                             result),\n+            Some(9) => {}\n+            result => panic!(\"not terminated by signal 9 (instead, {:?})\", result),\n         }\n     }\n \n@@ -1743,20 +1779,20 @@ mod tests {\n     #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n     fn set_current_dir_works() {\n         let mut cmd = Command::new(\"/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"pwd\")\n-           .current_dir(\"/\")\n-           .stdout(Stdio::piped());\n+        cmd.arg(\"-c\").arg(\"pwd\").current_dir(\"/\").stdout(Stdio::piped());\n         assert_eq!(run_output(cmd), \"/\\n\");\n     }\n \n     #[test]\n     #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n     fn stdin_works() {\n         let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"read line; echo $line\")\n-                            .stdin(Stdio::piped())\n-                            .stdout(Stdio::piped())\n-                            .spawn().unwrap();\n+            .arg(\"-c\")\n+            .arg(\"read line; echo $line\")\n+            .stdin(Stdio::piped())\n+            .stdout(Stdio::piped())\n+            .spawn()\n+            .unwrap();\n         p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n         drop(p.stdin.take());\n         let mut out = String::new();\n@@ -1787,19 +1823,18 @@ mod tests {\n     fn test_process_output_fail_to_start() {\n         match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n             Err(e) => assert_eq!(e.kind(), ErrorKind::NotFound),\n-            Ok(..) => panic!()\n+            Ok(..) => panic!(),\n         }\n     }\n \n     #[test]\n     #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n     fn test_process_output_output() {\n-        let Output {status, stdout, stderr}\n-             = if cfg!(target_os = \"windows\") {\n-                 Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).output().unwrap()\n-             } else {\n-                 Command::new(\"echo\").arg(\"hello\").output().unwrap()\n-             };\n+        let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).output().unwrap()\n+        } else {\n+            Command::new(\"echo\").arg(\"hello\").output().unwrap()\n+        };\n         let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n@@ -1810,12 +1845,11 @@ mod tests {\n     #[test]\n     #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n     fn test_process_output_error() {\n-        let Output {status, stdout, stderr}\n-             = if cfg!(target_os = \"windows\") {\n-                 Command::new(\"cmd\").args(&[\"/C\", \"mkdir .\"]).output().unwrap()\n-             } else {\n-                 Command::new(\"mkdir\").arg(\"./\").output().unwrap()\n-             };\n+        let Output { status, stdout, stderr } = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"mkdir .\"]).output().unwrap()\n+        } else {\n+            Command::new(\"mkdir\").arg(\"./\").output().unwrap()\n+        };\n \n         assert!(status.code() == Some(1));\n         assert_eq!(stdout, Vec::new());\n@@ -1854,19 +1888,19 @@ mod tests {\n             Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped()).spawn().unwrap()\n         };\n \n-        let Output {status, stdout, stderr} = prog.wait_with_output().unwrap();\n+        let Output { status, stdout, stderr } = prog.wait_with_output().unwrap();\n         let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n         assert_eq!(stderr, Vec::new());\n     }\n \n-    #[cfg(all(unix, not(target_os=\"android\")))]\n+    #[cfg(all(unix, not(target_os = \"android\")))]\n     pub fn env_cmd() -> Command {\n         Command::new(\"env\")\n     }\n-    #[cfg(target_os=\"android\")]\n+    #[cfg(target_os = \"android\")]\n     pub fn env_cmd() -> Command {\n         let mut cmd = Command::new(\"/system/bin/sh\");\n         cmd.arg(\"-c\").arg(\"set\");\n@@ -1897,8 +1931,11 @@ mod tests {\n         let result = cmd.output().unwrap();\n         let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+        assert!(\n+            output.contains(\"RUN_TEST_NEW_ENV=123\"),\n+            \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n+            output\n+        );\n     }\n \n     #[test]\n@@ -1907,8 +1944,11 @@ mod tests {\n         let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n         let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+        assert!(\n+            output.contains(\"RUN_TEST_NEW_ENV=123\"),\n+            \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\",\n+            output\n+        );\n     }\n \n     #[test]\n@@ -1927,10 +1967,16 @@ mod tests {\n \n         let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n-        assert!(output.contains(\"RUN_TEST_NEW_ENV1=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV1 inside of:\\n\\n{}\", output);\n-        assert!(output.contains(\"RUN_TEST_NEW_ENV2=456\"),\n-                \"didn't find RUN_TEST_NEW_ENV2 inside of:\\n\\n{}\", output);\n+        assert!(\n+            output.contains(\"RUN_TEST_NEW_ENV1=123\"),\n+            \"didn't find RUN_TEST_NEW_ENV1 inside of:\\n\\n{}\",\n+            output\n+        );\n+        assert!(\n+            output.contains(\"RUN_TEST_NEW_ENV2=456\"),\n+            \"didn't find RUN_TEST_NEW_ENV2 inside of:\\n\\n{}\",\n+            output\n+        );\n     }\n \n     // Regression tests for #30858.\n@@ -2005,8 +2051,11 @@ mod tests {\n \n         extern \"system\" {\n             fn WaitForDebugEvent(lpDebugEvent: *mut DEBUG_EVENT, dwMilliseconds: DWORD) -> BOOL;\n-            fn ContinueDebugEvent(dwProcessId: DWORD, dwThreadId: DWORD,\n-                                  dwContinueStatus: DWORD) -> BOOL;\n+            fn ContinueDebugEvent(\n+                dwProcessId: DWORD,\n+                dwThreadId: DWORD,\n+                dwContinueStatus: DWORD,\n+            ) -> BOOL;\n         }\n \n         const DEBUG_PROCESS: DWORD = 1;\n@@ -2015,15 +2064,12 @@ mod tests {\n \n         let mut child = Command::new(\"cmd\")\n             .creation_flags(DEBUG_PROCESS)\n-            .stdin(Stdio::piped()).spawn().unwrap();\n+            .stdin(Stdio::piped())\n+            .spawn()\n+            .unwrap();\n         child.stdin.take().unwrap().write_all(b\"exit\\r\\n\").unwrap();\n         let mut events = 0;\n-        let mut event = DEBUG_EVENT {\n-            event_code: 0,\n-            process_id: 0,\n-            thread_id: 0,\n-            _junk: [0; 164],\n-        };\n+        let mut event = DEBUG_EVENT { event_code: 0, process_id: 0, thread_id: 0, _junk: [0; 164] };\n         loop {\n             if unsafe { WaitForDebugEvent(&mut event as *mut DEBUG_EVENT, INFINITE) } == 0 {\n                 panic!(\"WaitForDebugEvent failed!\");\n@@ -2034,9 +2080,10 @@ mod tests {\n                 break;\n             }\n \n-            if unsafe { ContinueDebugEvent(event.process_id,\n-                                           event.thread_id,\n-                                           DBG_EXCEPTION_NOT_HANDLED) } == 0 {\n+            if unsafe {\n+                ContinueDebugEvent(event.process_id, event.thread_id, DBG_EXCEPTION_NOT_HANDLED)\n+            } == 0\n+            {\n                 panic!(\"ContinueDebugEvent failed!\");\n             }\n         }"}, {"sha": "1ed984509d27c56a0d55849e63fb4d981d296f9c", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -6,21 +6,25 @@\n //! and should be considered as private implementation details for the\n //! time being.\n \n-#![unstable(feature = \"rt\",\n-            reason = \"this public module should not exist and is highly likely \\\n-                      to disappear\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"rt\",\n+    reason = \"this public module should not exist and is highly likely \\\n+              to disappear\",\n+    issue = \"0\"\n+)]\n #![doc(hidden)]\n \n-\n // Re-export some of our utilities which are expected by other crates.\n pub use crate::panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n \n // To reduce the generated code of the new `lang_start`, this function is doing\n // the real work.\n #[cfg(not(test))]\n-fn lang_start_internal(main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindSafe),\n-                       argc: isize, argv: *const *const u8) -> isize {\n+fn lang_start_internal(\n+    main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindSafe),\n+    argc: isize,\n+    argv: *const *const u8,\n+) -> isize {\n     use crate::panic;\n     use crate::sys;\n     use crate::sys_common;\n@@ -55,8 +59,10 @@ fn lang_start_internal(main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindS\n \n #[cfg(not(test))]\n #[lang = \"start\"]\n-fn lang_start<T: crate::process::Termination + 'static>\n-    (main: fn() -> T, argc: isize, argv: *const *const u8) -> isize\n-{\n+fn lang_start<T: crate::process::Termination + 'static>(\n+    main: fn() -> T,\n+    argc: isize,\n+    argv: *const *const u8,\n+) -> isize {\n     lang_start_internal(&move || main().report(), argc, argv)\n }"}, {"sha": "eddbdff257a992a21b09eb1a5acdd707340203a7", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,5 +1,5 @@\n use crate::fmt;\n-use crate::sync::{Mutex, Condvar};\n+use crate::sync::{Condvar, Mutex};\n \n /// A barrier enables multiple threads to synchronize the beginning\n /// of some computation.\n@@ -82,10 +82,7 @@ impl Barrier {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(n: usize) -> Barrier {\n         Barrier {\n-            lock: Mutex::new(BarrierState {\n-                count: 0,\n-                generation_id: 0,\n-            }),\n+            lock: Mutex::new(BarrierState { count: 0, generation_id: 0 }),\n             cvar: Condvar::new(),\n             num_threads: n,\n         }\n@@ -135,8 +132,7 @@ impl Barrier {\n         if lock.count < self.num_threads {\n             // We need a while loop to guard against spurious wakeups.\n             // http://en.wikipedia.org/wiki/Spurious_wakeup\n-            while local_gen == lock.generation_id &&\n-                  lock.count < self.num_threads {\n+            while local_gen == lock.generation_id && lock.count < self.num_threads {\n                 lock = self.cvar.wait(lock).unwrap();\n             }\n             BarrierWaitResult(false)\n@@ -152,9 +148,7 @@ impl Barrier {\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for BarrierWaitResult {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"BarrierWaitResult\")\n-            .field(\"is_leader\", &self.is_leader())\n-            .finish()\n+        f.debug_struct(\"BarrierWaitResult\").field(\"is_leader\", &self.is_leader()).finish()\n     }\n }\n \n@@ -176,13 +170,15 @@ impl BarrierWaitResult {\n     /// println!(\"{:?}\", barrier_wait_result.is_leader());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_leader(&self) -> bool { self.0 }\n+    pub fn is_leader(&self) -> bool {\n+        self.0\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::sync::{Arc, Barrier};\n     use crate::sync::mpsc::{channel, TryRecvError};\n+    use crate::sync::{Arc, Barrier};\n     use crate::thread;\n \n     #[test]\n@@ -196,7 +192,7 @@ mod tests {\n         for _ in 0..N - 1 {\n             let c = barrier.clone();\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 tx.send(c.wait().is_leader()).unwrap();\n             });\n         }"}, {"sha": "d34de6a4fac3e9bfe87f62449f23c12b37f7c5b8", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,9 +1,9 @@\n //! Generic support for building blocking abstractions.\n \n-use crate::thread::{self, Thread};\n+use crate::mem;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::Arc;\n-use crate::mem;\n+use crate::thread::{self, Thread};\n use crate::time::Instant;\n \n struct Inner {\n@@ -28,16 +28,9 @@ impl !Send for WaitToken {}\n impl !Sync for WaitToken {}\n \n pub fn tokens() -> (WaitToken, SignalToken) {\n-    let inner = Arc::new(Inner {\n-        thread: thread::current(),\n-        woken: AtomicBool::new(false),\n-    });\n-    let wait_token = WaitToken {\n-        inner: inner.clone(),\n-    };\n-    let signal_token = SignalToken {\n-        inner,\n-    };\n+    let inner = Arc::new(Inner { thread: thread::current(), woken: AtomicBool::new(false) });\n+    let wait_token = WaitToken { inner: inner.clone() };\n+    let signal_token = SignalToken { inner };\n     (wait_token, signal_token)\n }\n "}, {"sha": "b0842144328a8bfa2f21f11d2f2e338fc5bd04cf", "filename": "src/libstd/sync/mpsc/cache_aligned.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fcache_aligned.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -8,16 +8,16 @@ pub(super) struct Aligner;\n pub(super) struct CacheAligned<T>(pub T, pub Aligner);\n \n impl<T> Deref for CacheAligned<T> {\n-     type Target = T;\n-     fn deref(&self) -> &Self::Target {\n-         &self.0\n-     }\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n }\n \n impl<T> DerefMut for CacheAligned<T> {\n-     fn deref_mut(&mut self) -> &mut Self::Target {\n-         &mut self.0\n-     }\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n }\n \n impl<T> CacheAligned<T> {"}, {"sha": "2831bbcb88d2e49e790f3f420b368a808263cb85", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 251, "deletions": 259, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -269,20 +269,20 @@\n // And now that you've seen all the races that I found and attempted to fix,\n // here's the code for you to find some more!\n \n-use crate::sync::Arc;\n+use crate::cell::UnsafeCell;\n use crate::error;\n use crate::fmt;\n use crate::mem;\n-use crate::cell::UnsafeCell;\n+use crate::sync::Arc;\n use crate::time::{Duration, Instant};\n \n mod blocking;\n+mod mpsc_queue;\n mod oneshot;\n mod shared;\n+mod spsc_queue;\n mod stream;\n mod sync;\n-mod mpsc_queue;\n-mod spsc_queue;\n \n mod cache_aligned;\n \n@@ -322,10 +322,10 @@ pub struct Receiver<T> {\n // The receiver port can be sent from place to place, so long as it\n // is not used to receive non-sendable things.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for Receiver<T> { }\n+unsafe impl<T: Send> Send for Receiver<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> !Sync for Receiver<T> { }\n+impl<T> !Sync for Receiver<T> {}\n \n /// An iterator over messages on a [`Receiver`], created by [`iter`].\n ///\n@@ -359,7 +359,7 @@ impl<T> !Sync for Receiver<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, T: 'a> {\n-    rx: &'a Receiver<T>\n+    rx: &'a Receiver<T>,\n }\n \n /// An iterator that attempts to yield all pending values for a [`Receiver`],\n@@ -404,7 +404,7 @@ pub struct Iter<'a, T: 'a> {\n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n #[derive(Debug)]\n pub struct TryIter<'a, T: 'a> {\n-    rx: &'a Receiver<T>\n+    rx: &'a Receiver<T>,\n }\n \n /// An owning iterator over messages on a [`Receiver`],\n@@ -439,7 +439,7 @@ pub struct TryIter<'a, T: 'a> {\n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n-    rx: Receiver<T>\n+    rx: Receiver<T>,\n }\n \n /// The sending-half of Rust's asynchronous [`channel`] type. This half can only be\n@@ -482,10 +482,10 @@ pub struct Sender<T> {\n // The send port can be sent from place to place, so long as it\n // is not used to send non-sendable things.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for Sender<T> { }\n+unsafe impl<T: Send> Send for Sender<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> !Sync for Sender<T> { }\n+impl<T> !Sync for Sender<T> {}\n \n /// The sending-half of Rust's synchronous [`sync_channel`] type.\n ///\n@@ -772,9 +772,7 @@ pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n \n impl<T> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n-        Sender {\n-            inner: UnsafeCell::new(inner),\n-        }\n+        Sender { inner: UnsafeCell::new(inner) }\n     }\n \n     /// Attempts to send a value on this channel, returning it back if it could\n@@ -856,8 +854,7 @@ impl<T> Clone for Sender<T> {\n                     let guard = a.postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n                     let sleeper = match p.upgrade(rx) {\n-                        oneshot::UpSuccess |\n-                        oneshot::UpDisconnected => None,\n+                        oneshot::UpSuccess | oneshot::UpDisconnected => None,\n                         oneshot::UpWoke(task) => Some(task),\n                     };\n                     a.inherit_blocker(sleeper, guard);\n@@ -870,8 +867,7 @@ impl<T> Clone for Sender<T> {\n                     let guard = a.postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n                     let sleeper = match p.upgrade(rx) {\n-                        stream::UpSuccess |\n-                        stream::UpDisconnected => None,\n+                        stream::UpSuccess | stream::UpDisconnected => None,\n                         stream::UpWoke(task) => Some(task),\n                     };\n                     a.inherit_blocker(sleeper, guard);\n@@ -1078,48 +1074,31 @@ impl<T> Receiver<T> {\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.try_recv() {\n-                        Ok(t) => return Ok(t),\n-                        Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n-                        Err(oneshot::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n-                        Err(oneshot::Upgraded(rx)) => rx,\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.try_recv() {\n-                        Ok(t) => return Ok(t),\n-                        Err(stream::Empty) => return Err(TryRecvError::Empty),\n-                        Err(stream::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n-                        Err(stream::Upgraded(rx)) => rx,\n-                    }\n-                }\n-                Flavor::Shared(ref p) => {\n-                    match p.try_recv() {\n-                        Ok(t) => return Ok(t),\n-                        Err(shared::Empty) => return Err(TryRecvError::Empty),\n-                        Err(shared::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n-                    }\n-                }\n-                Flavor::Sync(ref p) => {\n-                    match p.try_recv() {\n-                        Ok(t) => return Ok(t),\n-                        Err(sync::Empty) => return Err(TryRecvError::Empty),\n-                        Err(sync::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n-                    }\n-                }\n+                Flavor::Oneshot(ref p) => match p.try_recv() {\n+                    Ok(t) => return Ok(t),\n+                    Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n+                    Err(oneshot::Disconnected) => return Err(TryRecvError::Disconnected),\n+                    Err(oneshot::Upgraded(rx)) => rx,\n+                },\n+                Flavor::Stream(ref p) => match p.try_recv() {\n+                    Ok(t) => return Ok(t),\n+                    Err(stream::Empty) => return Err(TryRecvError::Empty),\n+                    Err(stream::Disconnected) => return Err(TryRecvError::Disconnected),\n+                    Err(stream::Upgraded(rx)) => rx,\n+                },\n+                Flavor::Shared(ref p) => match p.try_recv() {\n+                    Ok(t) => return Ok(t),\n+                    Err(shared::Empty) => return Err(TryRecvError::Empty),\n+                    Err(shared::Disconnected) => return Err(TryRecvError::Disconnected),\n+                },\n+                Flavor::Sync(ref p) => match p.try_recv() {\n+                    Ok(t) => return Ok(t),\n+                    Err(sync::Empty) => return Err(TryRecvError::Empty),\n+                    Err(sync::Disconnected) => return Err(TryRecvError::Disconnected),\n+                },\n             };\n             unsafe {\n-                mem::swap(self.inner_mut(),\n-                          new_port.inner_mut());\n+                mem::swap(self.inner_mut(), new_port.inner_mut());\n             }\n         }\n     }\n@@ -1185,29 +1164,23 @@ impl<T> Receiver<T> {\n     pub fn recv(&self) -> Result<T, RecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.recv(None) {\n-                        Ok(t) => return Ok(t),\n-                        Err(oneshot::Disconnected) => return Err(RecvError),\n-                        Err(oneshot::Upgraded(rx)) => rx,\n-                        Err(oneshot::Empty) => unreachable!(),\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.recv(None) {\n-                        Ok(t) => return Ok(t),\n-                        Err(stream::Disconnected) => return Err(RecvError),\n-                        Err(stream::Upgraded(rx)) => rx,\n-                        Err(stream::Empty) => unreachable!(),\n-                    }\n-                }\n-                Flavor::Shared(ref p) => {\n-                    match p.recv(None) {\n-                        Ok(t) => return Ok(t),\n-                        Err(shared::Disconnected) => return Err(RecvError),\n-                        Err(shared::Empty) => unreachable!(),\n-                    }\n-                }\n+                Flavor::Oneshot(ref p) => match p.recv(None) {\n+                    Ok(t) => return Ok(t),\n+                    Err(oneshot::Disconnected) => return Err(RecvError),\n+                    Err(oneshot::Upgraded(rx)) => rx,\n+                    Err(oneshot::Empty) => unreachable!(),\n+                },\n+                Flavor::Stream(ref p) => match p.recv(None) {\n+                    Ok(t) => return Ok(t),\n+                    Err(stream::Disconnected) => return Err(RecvError),\n+                    Err(stream::Upgraded(rx)) => rx,\n+                    Err(stream::Empty) => unreachable!(),\n+                },\n+                Flavor::Shared(ref p) => match p.recv(None) {\n+                    Ok(t) => return Ok(t),\n+                    Err(shared::Disconnected) => return Err(RecvError),\n+                    Err(shared::Empty) => unreachable!(),\n+                },\n                 Flavor::Sync(ref p) => return p.recv(None).map_err(|_| RecvError),\n             };\n             unsafe {\n@@ -1383,36 +1356,28 @@ impl<T> Receiver<T> {\n \n         loop {\n             let port_or_empty = match *unsafe { self.inner() } {\n-                Flavor::Oneshot(ref p) => {\n-                    match p.recv(Some(deadline)) {\n-                        Ok(t) => return Ok(t),\n-                        Err(oneshot::Disconnected) => return Err(Disconnected),\n-                        Err(oneshot::Upgraded(rx)) => Some(rx),\n-                        Err(oneshot::Empty) => None,\n-                    }\n-                }\n-                Flavor::Stream(ref p) => {\n-                    match p.recv(Some(deadline)) {\n-                        Ok(t) => return Ok(t),\n-                        Err(stream::Disconnected) => return Err(Disconnected),\n-                        Err(stream::Upgraded(rx)) => Some(rx),\n-                        Err(stream::Empty) => None,\n-                    }\n-                }\n-                Flavor::Shared(ref p) => {\n-                    match p.recv(Some(deadline)) {\n-                        Ok(t) => return Ok(t),\n-                        Err(shared::Disconnected) => return Err(Disconnected),\n-                        Err(shared::Empty) => None,\n-                    }\n-                }\n-                Flavor::Sync(ref p) => {\n-                    match p.recv(Some(deadline)) {\n-                        Ok(t) => return Ok(t),\n-                        Err(sync::Disconnected) => return Err(Disconnected),\n-                        Err(sync::Empty) => None,\n-                    }\n-                }\n+                Flavor::Oneshot(ref p) => match p.recv(Some(deadline)) {\n+                    Ok(t) => return Ok(t),\n+                    Err(oneshot::Disconnected) => return Err(Disconnected),\n+                    Err(oneshot::Upgraded(rx)) => Some(rx),\n+                    Err(oneshot::Empty) => None,\n+                },\n+                Flavor::Stream(ref p) => match p.recv(Some(deadline)) {\n+                    Ok(t) => return Ok(t),\n+                    Err(stream::Disconnected) => return Err(Disconnected),\n+                    Err(stream::Upgraded(rx)) => Some(rx),\n+                    Err(stream::Empty) => None,\n+                },\n+                Flavor::Shared(ref p) => match p.recv(Some(deadline)) {\n+                    Ok(t) => return Ok(t),\n+                    Err(shared::Disconnected) => return Err(Disconnected),\n+                    Err(shared::Empty) => None,\n+                },\n+                Flavor::Sync(ref p) => match p.recv(Some(deadline)) {\n+                    Ok(t) => return Ok(t),\n+                    Err(sync::Disconnected) => return Err(Disconnected),\n+                    Err(sync::Empty) => None,\n+                },\n             };\n \n             if let Some(new_port) = port_or_empty {\n@@ -1502,39 +1467,46 @@ impl<T> Receiver<T> {\n     pub fn try_iter(&self) -> TryIter<'_, T> {\n         TryIter { rx: self }\n     }\n-\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = T;\n \n-    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n+    fn next(&mut self) -> Option<T> {\n+        self.rx.recv().ok()\n+    }\n }\n \n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n impl<'a, T> Iterator for TryIter<'a, T> {\n     type Item = T;\n \n-    fn next(&mut self) -> Option<T> { self.rx.try_recv().ok() }\n+    fn next(&mut self) -> Option<T> {\n+        self.rx.try_recv().ok()\n+    }\n }\n \n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n impl<'a, T> IntoIterator for &'a Receiver<T> {\n     type Item = T;\n     type IntoIter = Iter<'a, T>;\n \n-    fn into_iter(self) -> Iter<'a, T> { self.iter() }\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n }\n \n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n-    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n+    fn next(&mut self) -> Option<T> {\n+        self.rx.recv().ok()\n+    }\n }\n \n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n-impl <T> IntoIterator for Receiver<T> {\n+impl<T> IntoIterator for Receiver<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -1597,27 +1569,18 @@ impl<T> fmt::Debug for TrySendError<T> {\n impl<T> fmt::Display for TrySendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            TrySendError::Full(..) => {\n-                \"sending on a full channel\".fmt(f)\n-            }\n-            TrySendError::Disconnected(..) => {\n-                \"sending on a closed channel\".fmt(f)\n-            }\n+            TrySendError::Full(..) => \"sending on a full channel\".fmt(f),\n+            TrySendError::Disconnected(..) => \"sending on a closed channel\".fmt(f),\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> error::Error for TrySendError<T> {\n-\n     fn description(&self) -> &str {\n         match *self {\n-            TrySendError::Full(..) => {\n-                \"sending on a full channel\"\n-            }\n-            TrySendError::Disconnected(..) => {\n-                \"sending on a closed channel\"\n-            }\n+            TrySendError::Full(..) => \"sending on a full channel\",\n+            TrySendError::Disconnected(..) => \"sending on a closed channel\",\n         }\n     }\n }\n@@ -1640,7 +1603,6 @@ impl fmt::Display for RecvError {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl error::Error for RecvError {\n-\n     fn description(&self) -> &str {\n         \"receiving on a closed channel\"\n     }\n@@ -1650,27 +1612,18 @@ impl error::Error for RecvError {\n impl fmt::Display for TryRecvError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            TryRecvError::Empty => {\n-                \"receiving on an empty channel\".fmt(f)\n-            }\n-            TryRecvError::Disconnected => {\n-                \"receiving on a closed channel\".fmt(f)\n-            }\n+            TryRecvError::Empty => \"receiving on an empty channel\".fmt(f),\n+            TryRecvError::Disconnected => \"receiving on a closed channel\".fmt(f),\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl error::Error for TryRecvError {\n-\n     fn description(&self) -> &str {\n         match *self {\n-            TryRecvError::Empty => {\n-                \"receiving on an empty channel\"\n-            }\n-            TryRecvError::Disconnected => {\n-                \"receiving on a closed channel\"\n-            }\n+            TryRecvError::Empty => \"receiving on an empty channel\",\n+            TryRecvError::Disconnected => \"receiving on a closed channel\",\n         }\n     }\n }\n@@ -1688,12 +1641,8 @@ impl From<RecvError> for TryRecvError {\n impl fmt::Display for RecvTimeoutError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            RecvTimeoutError::Timeout => {\n-                \"timed out waiting on channel\".fmt(f)\n-            }\n-            RecvTimeoutError::Disconnected => {\n-                \"channel is empty and sending half is closed\".fmt(f)\n-            }\n+            RecvTimeoutError::Timeout => \"timed out waiting on channel\".fmt(f),\n+            RecvTimeoutError::Disconnected => \"channel is empty and sending half is closed\".fmt(f),\n         }\n     }\n }\n@@ -1702,12 +1651,8 @@ impl fmt::Display for RecvTimeoutError {\n impl error::Error for RecvTimeoutError {\n     fn description(&self) -> &str {\n         match *self {\n-            RecvTimeoutError::Timeout => {\n-                \"timed out waiting on channel\"\n-            }\n-            RecvTimeoutError::Disconnected => {\n-                \"channel is empty and sending half is closed\"\n-            }\n+            RecvTimeoutError::Timeout => \"timed out waiting on channel\",\n+            RecvTimeoutError::Disconnected => \"channel is empty and sending half is closed\",\n         }\n     }\n }\n@@ -1769,7 +1714,7 @@ mod tests {\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = channel::<i32>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             tx.send(1).unwrap();\n         });\n         assert_eq!(rx.recv().unwrap(), 1);\n@@ -1801,7 +1746,7 @@ mod tests {\n     #[test]\n     fn port_gone_concurrent() {\n         let (tx, rx) = channel::<i32>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() {}\n@@ -1811,7 +1756,7 @@ mod tests {\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<i32>();\n         let tx2 = tx.clone();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n@@ -1836,7 +1781,7 @@ mod tests {\n     #[test]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<i32>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n         });\n@@ -1846,8 +1791,10 @@ mod tests {\n     #[test]\n     fn stress() {\n         let (tx, rx) = channel::<i32>();\n-        let t = thread::spawn(move|| {\n-            for _ in 0..10000 { tx.send(1).unwrap(); }\n+        let t = thread::spawn(move || {\n+            for _ in 0..10000 {\n+                tx.send(1).unwrap();\n+            }\n         });\n         for _ in 0..10000 {\n             assert_eq!(rx.recv().unwrap(), 1);\n@@ -1861,7 +1808,7 @@ mod tests {\n         const NTHREADS: u32 = 8;\n         let (tx, rx) = channel::<i32>();\n \n-        let t = thread::spawn(move|| {\n+        let t = thread::spawn(move || {\n             for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1873,8 +1820,10 @@ mod tests {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n-                for _ in 0..AMT { tx.send(1).unwrap(); }\n+            thread::spawn(move || {\n+                for _ in 0..AMT {\n+                    tx.send(1).unwrap();\n+                }\n             });\n         }\n         drop(tx);\n@@ -1885,14 +1834,14 @@ mod tests {\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<i32>();\n-        let t1 = thread::spawn(move|| {\n+        let t1 = thread::spawn(move || {\n             tx1.send(()).unwrap();\n             for _ in 0..40 {\n                 assert_eq!(rx2.recv().unwrap(), 1);\n             }\n         });\n         rx1.recv().unwrap();\n-        let t2 = thread::spawn(move|| {\n+        let t2 = thread::spawn(move || {\n             for _ in 0..40 {\n                 tx2.send(1).unwrap();\n             }\n@@ -1904,7 +1853,7 @@ mod tests {\n     #[test]\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<i32>();\n-        let t = thread::spawn(move|| {\n+        let t = thread::spawn(move || {\n             for _ in 0..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1919,11 +1868,11 @@ mod tests {\n     fn no_runtime() {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<i32>();\n-        let t1 = thread::spawn(move|| {\n+        let t1 = thread::spawn(move || {\n             assert_eq!(rx1.recv().unwrap(), 1);\n             tx2.send(2).unwrap();\n         });\n-        let t2 = thread::spawn(move|| {\n+        let t2 = thread::spawn(move || {\n             tx1.send(1).unwrap();\n             assert_eq!(rx2.recv().unwrap(), 2);\n         });\n@@ -1956,11 +1905,12 @@ mod tests {\n     #[test]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = thread::spawn(move|| {\n+        let res = thread::spawn(move || {\n             let (tx, rx) = channel::<i32>();\n             drop(tx);\n             rx.recv().unwrap();\n-        }).join();\n+        })\n+        .join();\n         // What is our res?\n         assert!(res.is_err());\n     }\n@@ -2025,7 +1975,7 @@ mod tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<i32>>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             assert!(*rx.recv().unwrap() == 10);\n         });\n \n@@ -2035,20 +1985,21 @@ mod tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<i32>>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             drop(tx);\n         });\n-        let res = thread::spawn(move|| {\n+        let res = thread::spawn(move || {\n             assert!(*rx.recv().unwrap() == 10);\n-        }).join();\n+        })\n+        .join();\n         assert!(res.is_err());\n     }\n \n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -2059,27 +2010,29 @@ mod tests {\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(rx);\n             });\n-            let _ = thread::spawn(move|| {\n+            let _ = thread::spawn(move || {\n                 tx.send(1).unwrap();\n-            }).join();\n+            })\n+            .join();\n         }\n     }\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n-            thread::spawn(move|| {\n-                let res = thread::spawn(move|| {\n+            thread::spawn(move || {\n+                let res = thread::spawn(move || {\n                     rx.recv().unwrap();\n-                }).join();\n+                })\n+                .join();\n                 assert!(res.is_err());\n             });\n-            let _t = thread::spawn(move|| {\n-                thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n+                thread::spawn(move || {\n                     drop(tx);\n                 });\n             });\n@@ -2090,7 +2043,7 @@ mod tests {\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<Box<isize>>();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 tx.send(box 10).unwrap();\n             });\n             assert!(*rx.recv().unwrap() == 10);\n@@ -2106,18 +2059,22 @@ mod tests {\n             recv(rx, 0);\n \n             fn send(tx: Sender<Box<i32>>, i: i32) {\n-                if i == 10 { return }\n+                if i == 10 {\n+                    return;\n+                }\n \n-                thread::spawn(move|| {\n+                thread::spawn(move || {\n                     tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 });\n             }\n \n             fn recv(rx: Receiver<Box<i32>>, i: i32) {\n-                if i == 10 { return }\n+                if i == 10 {\n+                    return;\n+                }\n \n-                thread::spawn(move|| {\n+                thread::spawn(move || {\n                     assert!(*rx.recv().unwrap() == i);\n                     recv(rx, i + 1);\n                 });\n@@ -2214,9 +2171,8 @@ mod tests {\n     #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn very_long_recv_timeout_wont_panic() {\n         let (tx, rx) = channel::<()>();\n-        let join_handle = thread::spawn(move || {\n-            rx.recv_timeout(Duration::from_secs(u64::max_value()))\n-        });\n+        let join_handle =\n+            thread::spawn(move || rx.recv_timeout(Duration::from_secs(u64::max_value())));\n         thread::sleep(Duration::from_secs(1));\n         assert!(tx.send(()).is_ok());\n         assert_eq!(join_handle.join().unwrap(), Ok(()));\n@@ -2226,8 +2182,12 @@ mod tests {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n-        for _ in 0..10000 { tx.send(()).unwrap(); }\n-        for _ in 0..10000 { rx.recv().unwrap(); }\n+        for _ in 0..10000 {\n+            tx.send(()).unwrap();\n+        }\n+        for _ in 0..10000 {\n+            rx.recv().unwrap();\n+        }\n     }\n \n     #[test]\n@@ -2237,12 +2197,14 @@ mod tests {\n         let total = 5;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 tx.send(()).unwrap();\n             });\n         }\n \n-        for _ in 0..total { rx.recv().unwrap(); }\n+        for _ in 0..total {\n+            rx.recv().unwrap();\n+        }\n \n         assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n         tx.send(()).unwrap();\n@@ -2255,7 +2217,7 @@ mod tests {\n         let total = stress_factor() + 100;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 tx.send(()).unwrap();\n             });\n         }\n@@ -2270,7 +2232,7 @@ mod tests {\n         let (tx, rx) = channel::<i32>();\n         let (total_tx, total_rx) = channel::<i32>();\n \n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -2290,7 +2252,7 @@ mod tests {\n         let (tx, rx) = channel::<i32>();\n         let (count_tx, count_rx) = channel();\n \n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -2316,7 +2278,7 @@ mod tests {\n         let (response_tx, response_rx) = channel();\n \n         // Request `x`s until we have `6`.\n-        let t = thread::spawn(move|| {\n+        let t = thread::spawn(move || {\n             let mut count = 0;\n             loop {\n                 for x in response_rx.try_iter() {\n@@ -2341,11 +2303,11 @@ mod tests {\n     #[test]\n     fn test_recv_into_iter_owned() {\n         let mut iter = {\n-          let (tx, rx) = channel::<i32>();\n-          tx.send(1).unwrap();\n-          tx.send(2).unwrap();\n+            let (tx, rx) = channel::<i32>();\n+            tx.send(1).unwrap();\n+            tx.send(2).unwrap();\n \n-          rx.into_iter()\n+            rx.into_iter()\n         };\n         assert_eq!(iter.next().unwrap(), 1);\n         assert_eq!(iter.next().unwrap(), 2);\n@@ -2369,7 +2331,7 @@ mod tests {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx2.recv().unwrap();\n             tx1.send(1).unwrap();\n             tx3.send(()).unwrap();\n@@ -2394,13 +2356,15 @@ mod tests {\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap(); // wait on a oneshot\n-            drop(rx);  // destroy a shared\n+            drop(rx); // destroy a shared\n             tx2.send(()).unwrap();\n         });\n         // make sure the other thread has gone to sleep\n-        for _ in 0..5000 { thread::yield_now(); }\n+        for _ in 0..5000 {\n+            thread::yield_now();\n+        }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -2468,7 +2432,7 @@ mod sync_tests {\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             tx.send(1).unwrap();\n         });\n         assert_eq!(rx.recv().unwrap(), 1);\n@@ -2493,7 +2457,7 @@ mod sync_tests {\n     #[test]\n     fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() {}\n@@ -2503,7 +2467,7 @@ mod sync_tests {\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n@@ -2528,7 +2492,7 @@ mod sync_tests {\n     #[test]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n         });\n@@ -2538,8 +2502,10 @@ mod sync_tests {\n     #[test]\n     fn stress() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        thread::spawn(move|| {\n-            for _ in 0..10000 { tx.send(1).unwrap(); }\n+        thread::spawn(move || {\n+            for _ in 0..10000 {\n+                tx.send(1).unwrap();\n+            }\n         });\n         for _ in 0..10000 {\n             assert_eq!(rx.recv().unwrap(), 1);\n@@ -2551,8 +2517,10 @@ mod sync_tests {\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n \n-        thread::spawn(move|| {\n-            for _ in 0..10000 { tx.send(1).unwrap(); }\n+        thread::spawn(move || {\n+            for _ in 0..10000 {\n+                tx.send(1).unwrap();\n+            }\n         });\n \n         let mut recv_count = 0;\n@@ -2561,7 +2529,7 @@ mod sync_tests {\n                 Ok(v) => {\n                     assert_eq!(v, 1);\n                     recv_count += 1;\n-                },\n+                }\n                 Err(RecvTimeoutError::Timeout) => continue,\n                 Err(RecvTimeoutError::Disconnected) => break,\n             }\n@@ -2578,14 +2546,14 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut recv_count = 0;\n             loop {\n                 match rx.recv_timeout(Duration::from_millis(10)) {\n                     Ok(v) => {\n                         assert_eq!(v, 1);\n                         recv_count += 1;\n-                    },\n+                    }\n                     Err(RecvTimeoutError::Timeout) => continue,\n                     Err(RecvTimeoutError::Disconnected) => break,\n                 }\n@@ -2599,8 +2567,10 @@ mod sync_tests {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n-                for _ in 0..AMT { tx.send(1).unwrap(); }\n+            thread::spawn(move || {\n+                for _ in 0..AMT {\n+                    tx.send(1).unwrap();\n+                }\n             });\n         }\n \n@@ -2616,7 +2586,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -2629,8 +2599,10 @@ mod sync_tests {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n-                for _ in 0..AMT { tx.send(1).unwrap(); }\n+            thread::spawn(move || {\n+                for _ in 0..AMT {\n+                    tx.send(1).unwrap();\n+                }\n             });\n         }\n         drop(tx);\n@@ -2662,11 +2634,12 @@ mod sync_tests {\n     #[test]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = thread::spawn(move|| {\n+        let res = thread::spawn(move || {\n             let (tx, rx) = sync_channel::<i32>(0);\n             drop(tx);\n             rx.recv().unwrap();\n-        }).join();\n+        })\n+        .join();\n         // What is our res?\n         assert!(res.is_err());\n     }\n@@ -2746,7 +2719,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             assert!(*rx.recv().unwrap() == 10);\n         });\n \n@@ -2756,20 +2729,21 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             drop(tx);\n         });\n-        let res = thread::spawn(move|| {\n+        let res = thread::spawn(move || {\n             assert!(*rx.recv().unwrap() == 10);\n-        }).join();\n+        })\n+        .join();\n         assert!(res.is_err());\n     }\n \n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -2780,27 +2754,29 @@ mod sync_tests {\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 drop(rx);\n             });\n             let _ = thread::spawn(move || {\n                 tx.send(1).unwrap();\n-            }).join();\n+            })\n+            .join();\n         }\n     }\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n-            let _t = thread::spawn(move|| {\n-                let res = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n+                let res = thread::spawn(move || {\n                     rx.recv().unwrap();\n-                }).join();\n+                })\n+                .join();\n                 assert!(res.is_err());\n             });\n-            let _t = thread::spawn(move|| {\n-                thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n+                thread::spawn(move || {\n                     drop(tx);\n                 });\n             });\n@@ -2811,7 +2787,7 @@ mod sync_tests {\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<i32>>(0);\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 tx.send(box 10).unwrap();\n             });\n             assert!(*rx.recv().unwrap() == 10);\n@@ -2827,18 +2803,22 @@ mod sync_tests {\n             recv(rx, 0);\n \n             fn send(tx: SyncSender<Box<i32>>, i: i32) {\n-                if i == 10 { return }\n+                if i == 10 {\n+                    return;\n+                }\n \n-                thread::spawn(move|| {\n+                thread::spawn(move || {\n                     tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 });\n             }\n \n             fn recv(rx: Receiver<Box<i32>>, i: i32) {\n-                if i == 10 { return }\n+                if i == 10 {\n+                    return;\n+                }\n \n-                thread::spawn(move|| {\n+                thread::spawn(move || {\n                     assert!(*rx.recv().unwrap() == i);\n                     recv(rx, i + 1);\n                 });\n@@ -2850,8 +2830,12 @@ mod sync_tests {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = sync_channel(10000);\n-        for _ in 0..10000 { tx.send(()).unwrap(); }\n-        for _ in 0..10000 { rx.recv().unwrap(); }\n+        for _ in 0..10000 {\n+            tx.send(()).unwrap();\n+        }\n+        for _ in 0..10000 {\n+            rx.recv().unwrap();\n+        }\n     }\n \n     #[test]\n@@ -2860,7 +2844,7 @@ mod sync_tests {\n         let total = stress_factor() + 100;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 tx.send(()).unwrap();\n             });\n         }\n@@ -2875,7 +2859,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (total_tx, total_rx) = sync_channel::<i32>(0);\n \n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -2895,7 +2879,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -2920,7 +2904,7 @@ mod sync_tests {\n         let (tx1, rx1) = sync_channel::<i32>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx2.recv().unwrap();\n             tx1.send(1).unwrap();\n             tx3.send(()).unwrap();\n@@ -2945,13 +2929,15 @@ mod sync_tests {\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap(); // wait on a oneshot\n-            drop(rx);  // destroy a shared\n+            drop(rx); // destroy a shared\n             tx2.send(()).unwrap();\n         });\n         // make sure the other thread has gone to sleep\n-        for _ in 0..5000 { thread::yield_now(); }\n+        for _ in 0..5000 {\n+            thread::yield_now();\n+        }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -2965,22 +2951,28 @@ mod sync_tests {\n     #[test]\n     fn send1() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n+        let _t = thread::spawn(move || {\n+            rx.recv().unwrap();\n+        });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n     fn send2() {\n         let (tx, rx) = sync_channel::<i32>(0);\n-        let _t = thread::spawn(move|| { drop(rx); });\n+        let _t = thread::spawn(move || {\n+            drop(rx);\n+        });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send3() {\n         let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.send(1), Ok(()));\n-        let _t =thread::spawn(move|| { drop(rx); });\n+        let _t = thread::spawn(move || {\n+            drop(rx);\n+        });\n         assert!(tx.send(1).is_err());\n     }\n \n@@ -2990,11 +2982,11 @@ mod sync_tests {\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             assert!(tx.send(1).is_err());\n             done.send(()).unwrap();\n         });\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             assert!(tx2.send(2).is_err());\n             done2.send(()).unwrap();\n         });\n@@ -3030,7 +3022,7 @@ mod sync_tests {\n             let (tx1, rx1) = sync_channel::<()>(3);\n             let (tx2, rx2) = sync_channel::<()>(3);\n \n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 rx1.recv().unwrap();\n                 tx2.try_send(()).unwrap();\n             });"}, {"sha": "6e7a7be4430edae471def217e6c63b5ae451ce9b", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -13,8 +13,8 @@\n \n pub use self::PopResult::*;\n \n-use core::ptr;\n use core::cell::UnsafeCell;\n+use core::ptr;\n \n use crate::boxed::Box;\n use crate::sync::atomic::{AtomicPtr, Ordering};\n@@ -45,15 +45,12 @@ pub struct Queue<T> {\n     tail: UnsafeCell<*mut Node<T>>,\n }\n \n-unsafe impl<T: Send> Send for Queue<T> { }\n-unsafe impl<T: Send> Sync for Queue<T> { }\n+unsafe impl<T: Send> Send for Queue<T> {}\n+unsafe impl<T: Send> Sync for Queue<T> {}\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        Box::into_raw(box Node {\n-            next: AtomicPtr::new(ptr::null_mut()),\n-            value: v,\n-        })\n+        Box::into_raw(box Node { next: AtomicPtr::new(ptr::null_mut()), value: v })\n     }\n }\n \n@@ -62,10 +59,7 @@ impl<T> Queue<T> {\n     /// one consumer.\n     pub fn new() -> Queue<T> {\n         let stub = unsafe { Node::new(None) };\n-        Queue {\n-            head: AtomicPtr::new(stub),\n-            tail: UnsafeCell::new(stub),\n-        }\n+        Queue { head: AtomicPtr::new(stub), tail: UnsafeCell::new(stub) }\n     }\n \n     /// Pushes a new value onto this queue.\n@@ -101,7 +95,7 @@ impl<T> Queue<T> {\n                 return Data(ret);\n             }\n \n-            if self.head.load(Ordering::Acquire) == tail {Empty} else {Inconsistent}\n+            if self.head.load(Ordering::Acquire) == tail { Empty } else { Inconsistent }\n         }\n     }\n }\n@@ -121,7 +115,7 @@ impl<T> Drop for Queue<T> {\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n-    use super::{Queue, Data, Empty, Inconsistent};\n+    use super::{Data, Empty, Inconsistent, Queue};\n     use crate::sync::mpsc::channel;\n     use crate::sync::Arc;\n     use crate::thread;\n@@ -140,15 +134,15 @@ mod tests {\n         let q = Queue::new();\n         match q.pop() {\n             Empty => {}\n-            Inconsistent | Data(..) => panic!()\n+            Inconsistent | Data(..) => panic!(),\n         }\n         let (tx, rx) = channel();\n         let q = Arc::new(q);\n \n         for _ in 0..nthreads {\n             let tx = tx.clone();\n             let q = q.clone();\n-            thread::spawn(move|| {\n+            thread::spawn(move || {\n                 for i in 0..nmsgs {\n                     q.push(i);\n                 }\n@@ -159,8 +153,8 @@ mod tests {\n         let mut i = 0;\n         while i < nthreads * nmsgs {\n             match q.pop() {\n-                Empty | Inconsistent => {},\n-                Data(_) => { i += 1 }\n+                Empty | Inconsistent => {}\n+                Data(_) => i += 1,\n             }\n         }\n         drop(tx);"}, {"sha": "bbe77e7d0fb5c41f201782a8f72f760361df66c7", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -21,22 +21,21 @@\n /// consuming the port). This upgrade is then also stored in the shared packet.\n /// The one caveat to consider is that when a port sees a disconnected channel\n /// it must check for data because there is no \"data plus upgrade\" state.\n-\n pub use self::Failure::*;\n-pub use self::UpgradeResult::*;\n use self::MyUpgrade::*;\n+pub use self::UpgradeResult::*;\n \n-use crate::sync::mpsc::Receiver;\n-use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::cell::UnsafeCell;\n use crate::ptr;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::mpsc::blocking::{self, SignalToken};\n+use crate::sync::mpsc::Receiver;\n use crate::time::Instant;\n \n // Various states you can find a port in.\n-const EMPTY: usize = 0;          // initial state: no data, no blocked receiver\n-const DATA: usize = 1;           // data ready for receiver to take\n-const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n+const EMPTY: usize = 0; // initial state: no data, no blocked receiver\n+const DATA: usize = 1; // data ready for receiver to take\n+const DISCONNECTED: usize = 2; // channel is disconnected OR upgraded\n // Any other value represents a pointer to a SignalToken value. The\n // protocol ensures that when the state moves *to* a pointer,\n // ownership of the token is given to the packet, and when the state\n@@ -178,21 +177,17 @@ impl<T> Packet<T> {\n                 // and an upgrade flags the channel as disconnected, so when we see\n                 // this we first need to check if there's data available and *then*\n                 // we go through and process the upgrade.\n-                DISCONNECTED => {\n-                    match (&mut *self.data.get()).take() {\n-                        Some(data) => Ok(data),\n-                        None => {\n-                            match ptr::replace(self.upgrade.get(), SendUsed) {\n-                                SendUsed | NothingSent => Err(Disconnected),\n-                                GoUp(upgrade) => Err(Upgraded(upgrade))\n-                            }\n-                        }\n-                    }\n-                }\n+                DISCONNECTED => match (&mut *self.data.get()).take() {\n+                    Some(data) => Ok(data),\n+                    None => match ptr::replace(self.upgrade.get(), SendUsed) {\n+                        SendUsed | NothingSent => Err(Disconnected),\n+                        GoUp(upgrade) => Err(Upgraded(upgrade)),\n+                    },\n+                },\n \n                 // We are the sole receiver; there cannot be a blocking\n                 // receiver already.\n-                _ => unreachable!()\n+                _ => unreachable!(),\n             }\n         }\n     }\n@@ -217,10 +212,13 @@ impl<T> Packet<T> {\n \n                 // If the other end is already disconnected, then we failed the\n                 // upgrade. Be sure to trash the port we were given.\n-                DISCONNECTED => { ptr::replace(self.upgrade.get(), prev); UpDisconnected }\n+                DISCONNECTED => {\n+                    ptr::replace(self.upgrade.get(), prev);\n+                    UpDisconnected\n+                }\n \n                 // If someone's waiting, we gotta wake them up\n-                ptr => UpWoke(SignalToken::cast_from_usize(ptr))\n+                ptr => UpWoke(SignalToken::cast_from_usize(ptr)),\n             }\n         }\n     }\n@@ -232,7 +230,7 @@ impl<T> Packet<T> {\n             // If someone's waiting, we gotta wake them up\n             ptr => unsafe {\n                 SignalToken::cast_from_usize(ptr).signal();\n-            }\n+            },\n         }\n     }\n \n@@ -246,10 +244,12 @@ impl<T> Packet<T> {\n             // There's data on the channel, so make sure we destroy it promptly.\n             // This is why not using an arc is a little difficult (need the box\n             // to stay valid while we take the data).\n-            DATA => unsafe { (&mut *self.data.get()).take().unwrap(); },\n+            DATA => unsafe {\n+                (&mut *self.data.get()).take().unwrap();\n+            },\n \n             // We're the only ones that can block on this port\n-            _ => unreachable!()\n+            _ => unreachable!(),\n         }\n     }\n \n@@ -265,13 +265,11 @@ impl<T> Packet<T> {\n         let state = match self.state.load(Ordering::SeqCst) {\n             // Each of these states means that no further activity will happen\n             // with regard to abortion selection\n-            s @ EMPTY |\n-            s @ DATA |\n-            s @ DISCONNECTED => s,\n+            s @ EMPTY | s @ DATA | s @ DISCONNECTED => s,\n \n             // If we've got a blocked thread, then use an atomic to gain ownership\n             // of it (may fail)\n-            ptr => self.state.compare_and_swap(ptr, EMPTY, Ordering::SeqCst)\n+            ptr => self.state.compare_and_swap(ptr, EMPTY, Ordering::SeqCst),\n         };\n \n         // Now that we've got ownership of our state, figure out what to do\n@@ -302,7 +300,7 @@ impl<T> Packet<T> {\n             ptr => unsafe {\n                 drop(SignalToken::cast_from_usize(ptr));\n                 Ok(false)\n-            }\n+            },\n         }\n     }\n }"}, {"sha": "2b0393573fdc4a44d7e278f0ef717463dca60c10", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -7,7 +7,6 @@\n /// High level implementation details can be found in the comment of the parent\n /// module. You'll also note that the implementation of the shared and stream\n /// channels are quite similar, and this is no coincidence!\n-\n pub use self::Failure::*;\n use self::StartResult::*;\n \n@@ -17,7 +16,7 @@ use core::isize;\n \n use crate::cell::UnsafeCell;\n use crate::ptr;\n-use crate::sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n+use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::mpsc_queue as mpsc;\n use crate::sync::{Mutex, MutexGuard};\n@@ -34,9 +33,9 @@ const MAX_STEALS: isize = 1 << 20;\n \n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n-    cnt: AtomicIsize, // How many items are on this channel\n+    cnt: AtomicIsize,          // How many items are on this channel\n     steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n-    to_wake: AtomicUsize, // SignalToken for wake up\n+    to_wake: AtomicUsize,      // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n     channels: AtomicUsize,\n@@ -92,9 +91,7 @@ impl<T> Packet<T> {\n     // threads in select().\n     //\n     // This can only be called at channel-creation time\n-    pub fn inherit_blocker(&self,\n-                           token: Option<SignalToken>,\n-                           guard: MutexGuard<'_, ()>) {\n+    pub fn inherit_blocker(&self, token: Option<SignalToken>, guard: MutexGuard<'_, ()>) {\n         token.map(|token| {\n             assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n@@ -119,7 +116,9 @@ impl<T> Packet<T> {\n             // To offset this bad increment, we initially set the steal count to\n             // -1. You'll find some special code in abort_selection() as well to\n             // ensure that this -1 steal count doesn't escape too far.\n-            unsafe { *self.steals.get() = -1; }\n+            unsafe {\n+                *self.steals.get() = -1;\n+            }\n         });\n \n         // When the shared packet is constructed, we grabbed this lock. The\n@@ -132,7 +131,9 @@ impl<T> Packet<T> {\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n         // See Port::drop for what's going on\n-        if self.port_dropped.load(Ordering::SeqCst) { return Err(t) }\n+        if self.port_dropped.load(Ordering::SeqCst) {\n+            return Err(t);\n+        }\n \n         // Note that the multiple sender case is a little trickier\n         // semantically than the single sender case. The logic for\n@@ -160,7 +161,7 @@ impl<T> Packet<T> {\n         // received\". Once we get beyond this check, we have permanently\n         // entered the realm of \"this may be received\"\n         if self.cnt.load(Ordering::SeqCst) < DISCONNECTED + FUDGE {\n-            return Err(t)\n+            return Err(t);\n         }\n \n         self.queue.push(t);\n@@ -197,7 +198,7 @@ impl<T> Packet<T> {\n                         // maybe we're done, if we're not the last ones\n                         // here, then we need to go try again.\n                         if self.sender_drain.fetch_sub(1, Ordering::SeqCst) == 1 {\n-                            break\n+                            break;\n                         }\n                     }\n \n@@ -236,7 +237,10 @@ impl<T> Packet<T> {\n         }\n \n         match self.try_recv() {\n-            data @ Ok(..) => unsafe { *self.steals.get() -= 1; data },\n+            data @ Ok(..) => unsafe {\n+                *self.steals.get() -= 1;\n+                data\n+            },\n             data => data,\n         }\n     }\n@@ -252,12 +256,16 @@ impl<T> Packet<T> {\n             let steals = ptr::replace(self.steals.get(), 0);\n \n             match self.cnt.fetch_sub(1 + steals, Ordering::SeqCst) {\n-                DISCONNECTED => { self.cnt.store(DISCONNECTED, Ordering::SeqCst); }\n+                DISCONNECTED => {\n+                    self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n+                }\n                 // If we factor in our steals and notice that the channel has no\n                 // data, we successfully sleep\n                 n => {\n                     assert!(n >= 0);\n-                    if n - steals <= 0 { return Installed }\n+                    if n - steals <= 0 {\n+                        return Installed;\n+                    }\n                 }\n             }\n \n@@ -290,7 +298,10 @@ impl<T> Packet<T> {\n                 loop {\n                     thread::yield_now();\n                     match self.queue.pop() {\n-                        mpsc::Data(t) => { data = t; break }\n+                        mpsc::Data(t) => {\n+                            data = t;\n+                            break;\n+                        }\n                         mpsc::Empty => panic!(\"inconsistent => empty\"),\n                         mpsc::Inconsistent => {}\n                     }\n@@ -361,9 +372,13 @@ impl<T> Packet<T> {\n         }\n \n         match self.cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n-            -1 => { self.take_to_wake().signal(); }\n+            -1 => {\n+                self.take_to_wake().signal();\n+            }\n             DISCONNECTED => {}\n-            n => { assert!(n >= 0); }\n+            n => {\n+                assert!(n >= 0);\n+            }\n         }\n     }\n \n@@ -380,7 +395,9 @@ impl<T> Packet<T> {\n             // control of this thread.\n             loop {\n                 match self.queue.pop() {\n-                    mpsc::Data(..) => { steals += 1; }\n+                    mpsc::Data(..) => {\n+                        steals += 1;\n+                    }\n                     mpsc::Empty | mpsc::Inconsistent => break,\n                 }\n             }\n@@ -406,7 +423,7 @@ impl<T> Packet<T> {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 DISCONNECTED\n             }\n-            n => n\n+            n => n,\n         }\n     }\n \n@@ -432,7 +449,7 @@ impl<T> Packet<T> {\n         // positive.\n         let steals = {\n             let cnt = self.cnt.load(Ordering::SeqCst);\n-            if cnt < 0 && cnt != DISCONNECTED {-cnt} else {0}\n+            if cnt < 0 && cnt != DISCONNECTED { -cnt } else { 0 }\n         };\n         let prev = self.bump(steals + 1);\n "}, {"sha": "c51aa7619db77c3935dcb67aaeca3f0fa9463302", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -6,8 +6,8 @@\n \n // http://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n \n-use core::ptr;\n use core::cell::UnsafeCell;\n+use core::ptr;\n \n use crate::boxed::Box;\n use crate::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n@@ -19,16 +19,16 @@ struct Node<T> {\n     // FIXME: this could be an uninitialized T if we're careful enough, and\n     //      that would reduce memory usage (and be a bit faster).\n     //      is it worth it?\n-    value: Option<T>,           // nullable for re-use of nodes\n-    cached: bool,               // This node goes into the node cache\n-    next: AtomicPtr<Node<T>>,   // next node in the queue\n+    value: Option<T>,         // nullable for re-use of nodes\n+    cached: bool,             // This node goes into the node cache\n+    next: AtomicPtr<Node<T>>, // next node in the queue\n }\n \n /// The single-producer single-consumer queue. This structure is not cloneable,\n /// but it can be safely shared in an Arc if it is guaranteed that there\n /// is only one popper and one pusher touching the queue at any one point in\n /// time.\n-pub struct Queue<T, ProducerAddition=(), ConsumerAddition=()> {\n+pub struct Queue<T, ProducerAddition = (), ConsumerAddition = ()> {\n     // consumer fields\n     consumer: CacheAligned<Consumer<T, ConsumerAddition>>,\n \n@@ -38,9 +38,9 @@ pub struct Queue<T, ProducerAddition=(), ConsumerAddition=()> {\n \n struct Consumer<T, Addition> {\n     tail: UnsafeCell<*mut Node<T>>, // where to pop from\n-    tail_prev: AtomicPtr<Node<T>>, // where to pop from\n-    cache_bound: usize, // maximum cache size\n-    cached_nodes: AtomicUsize, // number of nodes marked as cachable\n+    tail_prev: AtomicPtr<Node<T>>,  // where to pop from\n+    cache_bound: usize,             // maximum cache size\n+    cached_nodes: AtomicUsize,      // number of nodes marked as cachable\n     addition: Addition,\n }\n \n@@ -51,9 +51,9 @@ struct Producer<T, Addition> {\n     addition: Addition,\n }\n \n-unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Send for Queue<T, P, C> { }\n+unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Send for Queue<T, P, C> {}\n \n-unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Sync for Queue<T, P, C> { }\n+unsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Sync for Queue<T, P, C> {}\n \n impl<T> Node<T> {\n     fn new() -> *mut Node<T> {\n@@ -66,7 +66,6 @@ impl<T> Node<T> {\n }\n \n impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerAddition> {\n-\n     /// Creates a new queue. With given additional elements in the producer and\n     /// consumer portions of the queue.\n     ///\n@@ -107,13 +106,13 @@ impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerA\n                 tail_prev: AtomicPtr::new(n1),\n                 cache_bound: bound,\n                 cached_nodes: AtomicUsize::new(0),\n-                addition: consumer_addition\n+                addition: consumer_addition,\n             }),\n             producer: CacheAligned::new(Producer {\n                 head: UnsafeCell::new(n2),\n                 first: UnsafeCell::new(n1),\n                 tail_copy: UnsafeCell::new(n1),\n-                addition: producer_addition\n+                addition: producer_addition,\n             }),\n         }\n     }\n@@ -142,8 +141,7 @@ impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerA\n         }\n         // If the above fails, then update our copy of the tail and try\n         // again.\n-        *self.producer.0.tail_copy.get() =\n-            self.consumer.tail_prev.load(Ordering::Acquire);\n+        *self.producer.0.tail_copy.get() = self.consumer.tail_prev.load(Ordering::Acquire);\n         if *self.producer.first.get() != *self.producer.tail_copy.get() {\n             let ret = *self.producer.first.get();\n             *self.producer.0.first.get() = (*ret).next.load(Ordering::Relaxed);\n@@ -164,7 +162,9 @@ impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerA\n             // the current tail node is a candidate for going into the cache.\n             let tail = *self.consumer.tail.get();\n             let next = (*tail).next.load(Ordering::Acquire);\n-            if next.is_null() { return None }\n+            if next.is_null() {\n+                return None;\n+            }\n             assert!((*next).value.is_some());\n             let ret = (*next).value.take();\n \n@@ -182,7 +182,8 @@ impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerA\n                     self.consumer.tail_prev.store(tail, Ordering::Release);\n                 } else {\n                     (*self.consumer.tail_prev.load(Ordering::Relaxed))\n-                        .next.store(next, Ordering::Relaxed);\n+                        .next\n+                        .store(next, Ordering::Relaxed);\n                     // We have successfully erased all references to 'tail', so\n                     // now we can safely drop it.\n                     let _: Box<Node<T>> = Box::from_raw(tail);\n@@ -234,9 +235,9 @@ impl<T, ProducerAddition, ConsumerAddition> Drop for Queue<T, ProducerAddition,\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use super::Queue;\n+    use crate::sync::mpsc::channel;\n     use crate::sync::Arc;\n     use crate::thread;\n-    use crate::sync::mpsc::channel;\n \n     #[test]\n     fn smoke() {\n@@ -265,15 +266,15 @@ mod tests {\n             match queue.peek() {\n                 Some(vec) => {\n                     assert_eq!(&*vec, &[1]);\n-                },\n-                None => unreachable!()\n+                }\n+                None => unreachable!(),\n             }\n \n             match queue.pop() {\n                 Some(vec) => {\n                     assert_eq!(&*vec, &[1]);\n-                },\n-                None => unreachable!()\n+                }\n+                None => unreachable!(),\n             }\n         }\n     }\n@@ -316,7 +317,7 @@ mod tests {\n \n             let (tx, rx) = channel();\n             let q2 = q.clone();\n-            let _t = thread::spawn(move|| {\n+            let _t = thread::spawn(move || {\n                 for _ in 0..100000 {\n                     loop {\n                         match q2.pop() {"}, {"sha": "2e3270e81fcd033f4494d95c160bc525fc3ab537", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 62, "deletions": 50, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -6,10 +6,9 @@\n ///\n /// High level implementation details can be found in the comment of the parent\n /// module.\n-\n pub use self::Failure::*;\n-pub use self::UpgradeResult::*;\n use self::Message::*;\n+pub use self::UpgradeResult::*;\n \n use core::cmp;\n use core::isize;\n@@ -19,10 +18,10 @@ use crate::ptr;\n use crate::thread;\n use crate::time::Instant;\n \n-use crate::sync::atomic::{AtomicIsize, AtomicUsize, Ordering, AtomicBool};\n-use crate::sync::mpsc::Receiver;\n+use crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize, Ordering};\n use crate::sync::mpsc::blocking::{self, SignalToken};\n use crate::sync::mpsc::spsc_queue as spsc;\n+use crate::sync::mpsc::Receiver;\n \n const DISCONNECTED: isize = isize::MIN;\n #[cfg(test)]\n@@ -36,17 +35,16 @@ pub struct Packet<T> {\n }\n \n struct ProducerAddition {\n-    cnt: AtomicIsize, // How many items are on this channel\n+    cnt: AtomicIsize,     // How many items are on this channel\n     to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n }\n \n struct ConsumerAddition {\n-    steals: UnsafeCell<isize>,  // How many times has a port received without blocking?\n+    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n }\n \n-\n pub enum Failure<T> {\n     Empty,\n     Disconnected,\n@@ -69,30 +67,34 @@ enum Message<T> {\n impl<T> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n-            queue: unsafe { spsc::Queue::with_additions(\n-                128,\n-                ProducerAddition {\n-                    cnt: AtomicIsize::new(0),\n-                    to_wake: AtomicUsize::new(0),\n-\n-                    port_dropped: AtomicBool::new(false),\n-                },\n-                ConsumerAddition {\n-                    steals: UnsafeCell::new(0),\n-                }\n-            )},\n+            queue: unsafe {\n+                spsc::Queue::with_additions(\n+                    128,\n+                    ProducerAddition {\n+                        cnt: AtomicIsize::new(0),\n+                        to_wake: AtomicUsize::new(0),\n+\n+                        port_dropped: AtomicBool::new(false),\n+                    },\n+                    ConsumerAddition { steals: UnsafeCell::new(0) },\n+                )\n+            },\n         }\n     }\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n         // If the other port has deterministically gone away, then definitely\n         // must return the data back up the stack. Otherwise, the data is\n         // considered as being sent.\n-        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) { return Err(t) }\n+        if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n+            return Err(t);\n+        }\n \n         match self.do_send(Data(t)) {\n-            UpSuccess | UpDisconnected => {},\n-            UpWoke(token) => { token.signal(); }\n+            UpSuccess | UpDisconnected => {}\n+            UpWoke(token) => {\n+                token.signal();\n+            }\n         }\n         Ok(())\n     }\n@@ -101,7 +103,7 @@ impl<T> Packet<T> {\n         // If the port has gone away, then there's no need to proceed any\n         // further.\n         if self.queue.producer_addition().port_dropped.load(Ordering::SeqCst) {\n-            return UpDisconnected\n+            return UpDisconnected;\n         }\n \n         self.do_send(GoUp(up))\n@@ -136,7 +138,10 @@ impl<T> Packet<T> {\n \n             // Otherwise we just sent some data on a non-waiting queue, so just\n             // make sure the world is sane and carry on!\n-            n => { assert!(n >= 0); UpSuccess }\n+            n => {\n+                assert!(n >= 0);\n+                UpSuccess\n+            }\n         }\n     }\n \n@@ -166,7 +171,9 @@ impl<T> Packet<T> {\n             // data, we successfully sleep\n             n => {\n                 assert!(n >= 0);\n-                if n - steals <= 0 { return Ok(()) }\n+                if n - steals <= 0 {\n+                    return Ok(());\n+                }\n             }\n         }\n \n@@ -199,8 +206,7 @@ impl<T> Packet<T> {\n             // Messages which actually popped from the queue shouldn't count as\n             // a steal, so offset the decrement here (we already have our\n             // \"steal\" factored into the channel count above).\n-            data @ Ok(..) |\n-            data @ Err(Upgraded(..)) => unsafe {\n+            data @ Ok(..) | data @ Err(Upgraded(..)) => unsafe {\n                 *self.queue.consumer_addition().steals.get() -= 1;\n                 data\n             },\n@@ -226,8 +232,10 @@ impl<T> Packet<T> {\n                 if *self.queue.consumer_addition().steals.get() > MAX_STEALS {\n                     match self.queue.producer_addition().cnt.swap(0, Ordering::SeqCst) {\n                         DISCONNECTED => {\n-                            self.queue.producer_addition().cnt.store(\n-                                DISCONNECTED, Ordering::SeqCst);\n+                            self.queue\n+                                .producer_addition()\n+                                .cnt\n+                                .store(DISCONNECTED, Ordering::SeqCst);\n                         }\n                         n => {\n                             let m = cmp::min(n, *self.queue.consumer_addition().steals.get());\n@@ -259,13 +267,11 @@ impl<T> Packet<T> {\n                     // We can ignore steals because the other end is\n                     // disconnected and we'll never need to really factor in our\n                     // steals again.\n-                    _ => {\n-                        match self.queue.pop() {\n-                            Some(Data(t)) => Ok(t),\n-                            Some(GoUp(up)) => Err(Upgraded(up)),\n-                            None => Err(Disconnected),\n-                        }\n-                    }\n+                    _ => match self.queue.pop() {\n+                        Some(Data(t)) => Ok(t),\n+                        Some(GoUp(up)) => Err(Upgraded(up)),\n+                        None => Err(Disconnected),\n+                    },\n                 }\n             }\n         }\n@@ -275,9 +281,13 @@ impl<T> Packet<T> {\n         // Dropping a channel is pretty simple, we just flag it as disconnected\n         // and then wakeup a blocker if there is one.\n         match self.queue.producer_addition().cnt.swap(DISCONNECTED, Ordering::SeqCst) {\n-            -1 => { self.take_to_wake().signal(); }\n+            -1 => {\n+                self.take_to_wake().signal();\n+            }\n             DISCONNECTED => {}\n-            n => { assert!(n >= 0); }\n+            n => {\n+                assert!(n >= 0);\n+            }\n         }\n     }\n \n@@ -314,10 +324,15 @@ impl<T> Packet<T> {\n         let mut steals = unsafe { *self.queue.consumer_addition().steals.get() };\n         while {\n             let cnt = self.queue.producer_addition().cnt.compare_and_swap(\n-                            steals, DISCONNECTED, Ordering::SeqCst);\n+                steals,\n+                DISCONNECTED,\n+                Ordering::SeqCst,\n+            );\n             cnt != DISCONNECTED && cnt != steals\n         } {\n-            while let Some(_) = self.queue.pop() { steals += 1; }\n+            while let Some(_) = self.queue.pop() {\n+                steals += 1;\n+            }\n         }\n \n         // At this point in time, we have gated all future senders from sending,\n@@ -338,13 +353,12 @@ impl<T> Packet<T> {\n                 self.queue.producer_addition().cnt.store(DISCONNECTED, Ordering::SeqCst);\n                 DISCONNECTED\n             }\n-            n => n\n+            n => n,\n         }\n     }\n \n     // Removes a previous thread from being blocked in this port\n-    pub fn abort_selection(&self,\n-                           was_upgrade: bool) -> Result<bool, Receiver<T>> {\n+    pub fn abort_selection(&self, was_upgrade: bool) -> Result<bool, Receiver<T>> {\n         // If we're aborting selection after upgrading from a oneshot, then\n         // we're guarantee that no one is waiting. The only way that we could\n         // have seen the upgrade is if data was actually sent on the channel\n@@ -361,7 +375,7 @@ impl<T> Packet<T> {\n         if was_upgrade {\n             assert_eq!(unsafe { *self.queue.consumer_addition().steals.get() }, 0);\n             assert_eq!(self.queue.producer_addition().to_wake.load(Ordering::SeqCst), 0);\n-            return Ok(true)\n+            return Ok(true);\n         }\n \n         // We want to make sure that the count on the channel goes non-negative,\n@@ -416,12 +430,10 @@ impl<T> Packet<T> {\n         // upgraded port.\n         if has_data {\n             match self.queue.peek() {\n-                Some(&mut GoUp(..)) => {\n-                    match self.queue.pop() {\n-                        Some(GoUp(port)) => Err(port),\n-                        _ => unreachable!(),\n-                    }\n-                }\n+                Some(&mut GoUp(..)) => match self.queue.pop() {\n+                    Some(GoUp(port)) => Err(port),\n+                    _ => unreachable!(),\n+                },\n                 _ => Ok(true),\n             }\n         } else {"}, {"sha": "79e868171546b4b35ce4b96ed036bb9452469c51", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 66, "deletions": 55, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,3 +1,4 @@\n+use self::Blocker::*;\n /// Synchronous channels/ports\n ///\n /// This channel implementation differs significantly from the asynchronous\n@@ -22,17 +23,15 @@\n /// implementation shares almost all code for the buffered and unbuffered cases\n /// of a synchronous channel. There are a few branches for the unbuffered case,\n /// but they're mostly just relevant to blocking senders.\n-\n pub use self::Failure::*;\n-use self::Blocker::*;\n \n use core::intrinsics::abort;\n use core::isize;\n use core::mem;\n use core::ptr;\n \n-use crate::sync::atomic::{Ordering, AtomicUsize};\n-use crate::sync::mpsc::blocking::{self, WaitToken, SignalToken};\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sync::mpsc::blocking::{self, SignalToken, WaitToken};\n use crate::sync::{Mutex, MutexGuard};\n use crate::time::Instant;\n \n@@ -46,9 +45,9 @@ pub struct Packet<T> {\n     lock: Mutex<State<T>>,\n }\n \n-unsafe impl<T: Send> Send for Packet<T> { }\n+unsafe impl<T: Send> Send for Packet<T> {}\n \n-unsafe impl<T: Send> Sync for Packet<T> { }\n+unsafe impl<T: Send> Sync for Packet<T> {}\n \n struct State<T> {\n     disconnected: bool, // Is the channel disconnected yet?\n@@ -72,7 +71,7 @@ unsafe impl<T: Send> Send for State<T> {}\n enum Blocker {\n     BlockedSender(SignalToken),\n     BlockedReceiver(SignalToken),\n-    NoneBlocked\n+    NoneBlocked,\n }\n \n /// Simple queue for threading threads together. Nodes are stack-allocated, so\n@@ -104,35 +103,35 @@ pub enum Failure {\n \n /// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n /// in the meantime. This re-locks the mutex upon returning.\n-fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n-                   mut guard: MutexGuard<'b, State<T>>,\n-                   f: fn(SignalToken) -> Blocker)\n-                   -> MutexGuard<'a, State<T>>\n-{\n+fn wait<'a, 'b, T>(\n+    lock: &'a Mutex<State<T>>,\n+    mut guard: MutexGuard<'b, State<T>>,\n+    f: fn(SignalToken) -> Blocker,\n+) -> MutexGuard<'a, State<T>> {\n     let (wait_token, signal_token) = blocking::tokens();\n     match mem::replace(&mut guard.blocker, f(signal_token)) {\n         NoneBlocked => {}\n         _ => unreachable!(),\n     }\n-    drop(guard);         // unlock\n-    wait_token.wait();   // block\n+    drop(guard); // unlock\n+    wait_token.wait(); // block\n     lock.lock().unwrap() // relock\n }\n \n /// Same as wait, but waiting at most until `deadline`.\n-fn wait_timeout_receiver<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n-                                    deadline: Instant,\n-                                    mut guard: MutexGuard<'b, State<T>>,\n-                                    success: &mut bool)\n-                                    -> MutexGuard<'a, State<T>>\n-{\n+fn wait_timeout_receiver<'a, 'b, T>(\n+    lock: &'a Mutex<State<T>>,\n+    deadline: Instant,\n+    mut guard: MutexGuard<'b, State<T>>,\n+    success: &mut bool,\n+) -> MutexGuard<'a, State<T>> {\n     let (wait_token, signal_token) = blocking::tokens();\n     match mem::replace(&mut guard.blocker, BlockedReceiver(signal_token)) {\n         NoneBlocked => {}\n         _ => unreachable!(),\n     }\n-    drop(guard);         // unlock\n-    *success = wait_token.wait_max_until(deadline);   // block\n+    drop(guard); // unlock\n+    *success = wait_token.wait_max_until(deadline); // block\n     let mut new_guard = lock.lock().unwrap(); // relock\n     if !*success {\n         abort_selection(&mut new_guard);\n@@ -147,7 +146,10 @@ fn abort_selection<T>(guard: &mut MutexGuard<'_, State<T>>) -> bool {\n             guard.blocker = BlockedSender(token);\n             true\n         }\n-        BlockedReceiver(token) => { drop(token); false }\n+        BlockedReceiver(token) => {\n+            drop(token);\n+            false\n+        }\n     }\n }\n \n@@ -168,12 +170,9 @@ impl<T> Packet<T> {\n                 blocker: NoneBlocked,\n                 cap: capacity,\n                 canceled: None,\n-                queue: Queue {\n-                    head: ptr::null_mut(),\n-                    tail: ptr::null_mut(),\n-                },\n+                queue: Queue { head: ptr::null_mut(), tail: ptr::null_mut() },\n                 buf: Buffer {\n-                    buf: (0..capacity + if capacity == 0 {1} else {0}).map(|_| None).collect(),\n+                    buf: (0..capacity + if capacity == 0 { 1 } else { 0 }).map(|_| None).collect(),\n                     start: 0,\n                     size: 0,\n                 },\n@@ -200,7 +199,9 @@ impl<T> Packet<T> {\n \n     pub fn send(&self, t: T) -> Result<(), T> {\n         let mut guard = self.acquire_send_slot();\n-        if guard.disconnected { return Err(t) }\n+        if guard.disconnected {\n+            return Err(t);\n+        }\n         guard.buf.enqueue(t);\n \n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n@@ -213,14 +214,17 @@ impl<T> Packet<T> {\n                 assert!(guard.canceled.is_none());\n                 guard.canceled = Some(unsafe { mem::transmute(&mut canceled) });\n                 let mut guard = wait(&self.lock, guard, BlockedSender);\n-                if canceled {Err(guard.buf.dequeue())} else {Ok(())}\n+                if canceled { Err(guard.buf.dequeue()) } else { Ok(()) }\n             }\n \n             // success, we buffered some data\n             NoneBlocked => Ok(()),\n \n             // success, someone's about to receive our buffered data.\n-            BlockedReceiver(token) => { wakeup(token, guard); Ok(()) }\n+            BlockedReceiver(token) => {\n+                wakeup(token, guard);\n+                Ok(())\n+            }\n \n             BlockedSender(..) => panic!(\"lolwut\"),\n         }\n@@ -271,10 +275,8 @@ impl<T> Packet<T> {\n         // while loop because we're the only receiver.\n         if !guard.disconnected && guard.buf.size() == 0 {\n             if let Some(deadline) = deadline {\n-                guard = wait_timeout_receiver(&self.lock,\n-                                              deadline,\n-                                              guard,\n-                                              &mut woke_up_after_waiting);\n+                guard =\n+                    wait_timeout_receiver(&self.lock, deadline, guard, &mut woke_up_after_waiting);\n             } else {\n                 guard = wait(&self.lock, guard, BlockedReceiver);\n                 woke_up_after_waiting = true;\n@@ -290,7 +292,9 @@ impl<T> Packet<T> {\n         // Pick up the data, wake up our neighbors, and carry on\n         assert!(guard.buf.size() > 0 || (deadline.is_some() && !woke_up_after_waiting));\n \n-        if guard.buf.size() == 0 { return Err(Empty); }\n+        if guard.buf.size() == 0 {\n+            return Err(Empty);\n+        }\n \n         let ret = guard.buf.dequeue();\n         self.wakeup_senders(woke_up_after_waiting, guard);\n@@ -301,8 +305,12 @@ impl<T> Packet<T> {\n         let mut guard = self.lock.lock().unwrap();\n \n         // Easy cases first\n-        if guard.disconnected && guard.buf.size() == 0 { return Err(Disconnected) }\n-        if guard.buf.size() == 0 { return Err(Empty) }\n+        if guard.disconnected && guard.buf.size() == 0 {\n+            return Err(Disconnected);\n+        }\n+        if guard.buf.size() == 0 {\n+            return Err(Empty);\n+        }\n \n         // Be sure to wake up neighbors\n         let ret = Ok(guard.buf.dequeue());\n@@ -357,12 +365,14 @@ impl<T> Packet<T> {\n         // Only flag the channel as disconnected if we're the last channel\n         match self.channels.fetch_sub(1, Ordering::SeqCst) {\n             1 => {}\n-            _ => return\n+            _ => return,\n         }\n \n         // Not much to do other than wake up a receiver if one's there\n         let mut guard = self.lock.lock().unwrap();\n-        if guard.disconnected { return }\n+        if guard.disconnected {\n+            return;\n+        }\n         guard.disconnected = true;\n         match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => {}\n@@ -374,23 +384,19 @@ impl<T> Packet<T> {\n     pub fn drop_port(&self) {\n         let mut guard = self.lock.lock().unwrap();\n \n-        if guard.disconnected { return }\n+        if guard.disconnected {\n+            return;\n+        }\n         guard.disconnected = true;\n \n         // If the capacity is 0, then the sender may want its data back after\n         // we're disconnected. Otherwise it's now our responsibility to destroy\n         // the buffered data. As with many other portions of this code, this\n         // needs to be careful to destroy the data *outside* of the lock to\n         // prevent deadlock.\n-        let _data = if guard.cap != 0 {\n-            mem::take(&mut guard.buf.buf)\n-        } else {\n-            Vec::new()\n-        };\n-        let mut queue = mem::replace(&mut guard.queue, Queue {\n-            head: ptr::null_mut(),\n-            tail: ptr::null_mut(),\n-        });\n+        let _data = if guard.cap != 0 { mem::take(&mut guard.buf.buf) } else { Vec::new() };\n+        let mut queue =\n+            mem::replace(&mut guard.queue, Queue { head: ptr::null_mut(), tail: ptr::null_mut() });\n \n         let waiter = match mem::replace(&mut guard.blocker, NoneBlocked) {\n             NoneBlocked => None,\n@@ -402,7 +408,9 @@ impl<T> Packet<T> {\n         };\n         mem::drop(guard);\n \n-        while let Some(token) = queue.dequeue() { token.signal(); }\n+        while let Some(token) = queue.dequeue() {\n+            token.signal();\n+        }\n         waiter.map(|t| t.signal());\n     }\n }\n@@ -416,7 +424,6 @@ impl<T> Drop for Packet<T> {\n     }\n }\n \n-\n ////////////////////////////////////////////////////////////////////////////////\n // Buffer, a simple ring buffer backed by Vec<T>\n ////////////////////////////////////////////////////////////////////////////////\n@@ -437,8 +444,12 @@ impl<T> Buffer<T> {\n         result.take().unwrap()\n     }\n \n-    fn size(&self) -> usize { self.size }\n-    fn capacity(&self) -> usize { self.buf.len() }\n+    fn size(&self) -> usize {\n+        self.size\n+    }\n+    fn capacity(&self) -> usize {\n+        self.buf.len()\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -466,7 +477,7 @@ impl Queue {\n \n     fn dequeue(&mut self) -> Option<SignalToken> {\n         if self.head.is_null() {\n-            return None\n+            return None;\n         }\n         let node = self.head;\n         self.head = unsafe { (*node).next };"}, {"sha": "713b9949f64610c0c41499bba33912a86ee6a9d0", "filename": "src/libstd/sys_common/alloc.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Falloc.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -6,20 +6,24 @@ use crate::ptr;\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values.\n-#[cfg(all(any(target_arch = \"x86\",\n-              target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"powerpc\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"asmjs\",\n-              target_arch = \"wasm32\",\n-              target_arch = \"hexagon\")))]\n+#[cfg(all(any(\n+    target_arch = \"x86\",\n+    target_arch = \"arm\",\n+    target_arch = \"mips\",\n+    target_arch = \"powerpc\",\n+    target_arch = \"powerpc64\",\n+    target_arch = \"asmjs\",\n+    target_arch = \"wasm32\",\n+    target_arch = \"hexagon\"\n+)))]\n pub const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86_64\",\n-              target_arch = \"aarch64\",\n-              target_arch = \"mips64\",\n-              target_arch = \"s390x\",\n-              target_arch = \"sparc64\")))]\n+#[cfg(all(any(\n+    target_arch = \"x86_64\",\n+    target_arch = \"aarch64\",\n+    target_arch = \"mips64\",\n+    target_arch = \"s390x\",\n+    target_arch = \"sparc64\"\n+)))]\n pub const MIN_ALIGN: usize = 16;\n \n pub unsafe fn realloc_fallback("}, {"sha": "dccc3bc4a19a85f61112a759a45faabc9e83037e", "filename": "src/libstd/sys_common/bytestring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fbytestring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fbytestring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbytestring.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -25,7 +25,7 @@ pub fn debug_fmt_bytestring(slice: &[u8], f: &mut Formatter<'_>) -> Result {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::fmt::{Formatter, Result, Debug};\n+    use crate::fmt::{Debug, Formatter, Result};\n \n     #[test]\n     fn smoke() {\n@@ -37,7 +37,7 @@ mod tests {\n             }\n         }\n \n-        let input =      b\"\\xF0hello,\\tworld\";\n+        let input = b\"\\xF0hello,\\tworld\";\n         let expected = r#\"\"\\xF0hello,\\tworld\"\"#;\n         let output = format!(\"{:?}\", Helper(input));\n "}, {"sha": "e30e8018a31fe9b4f677f157a82b2d10ac59a39e", "filename": "src/libstd/sys_common/fs.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Ffs.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,13 +1,15 @@\n #![allow(dead_code)] // not used on all platforms\n \n-use crate::path::Path;\n use crate::fs;\n use crate::io::{self, Error, ErrorKind};\n+use crate::path::Path;\n \n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n+        return Err(Error::new(\n+            ErrorKind::InvalidInput,\n+            \"the source path is not an existing regular file\",\n+        ));\n     }\n \n     let mut reader = fs::File::open(from)?;\n@@ -21,11 +23,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n \n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n     let filetype = fs::symlink_metadata(path)?.file_type();\n-    if filetype.is_symlink() {\n-        fs::remove_file(path)\n-    } else {\n-        remove_dir_all_recursive(path)\n-    }\n+    if filetype.is_symlink() { fs::remove_file(path) } else { remove_dir_all_recursive(path) }\n }\n \n fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {"}, {"sha": "7c1d98a5abd599bb6b0460c6942ebaebd94175d4", "filename": "src/libstd/sys_common/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fio.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -3,9 +3,9 @@ pub const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n #[cfg(test)]\n #[allow(dead_code)] // not used on emscripten\n pub mod test {\n-    use crate::path::{Path, PathBuf};\n     use crate::env;\n     use crate::fs;\n+    use crate::path::{Path, PathBuf};\n     use rand::RngCore;\n \n     pub struct TempDir(PathBuf);"}, {"sha": "9d40d9f0afd5cade8f38e78ca3859c6298d6ef0b", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 143, "deletions": 113, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,79 +1,119 @@\n use crate::cmp;\n+use crate::convert::{TryFrom, TryInto};\n use crate::ffi::CString;\n use crate::fmt;\n use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut};\n use crate::mem;\n-use crate::net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::ptr;\n-use crate::sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n use crate::sys::net::netc as c;\n+use crate::sys::net::{cvt, cvt_gai, cvt_r, init, wrlen_t, Socket};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n-use crate::convert::{TryFrom, TryInto};\n \n use libc::{c_int, c_void};\n \n-#[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n-          target_os = \"ios\", target_os = \"macos\",\n-          target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\"))]\n-use crate::sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n-#[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n-              target_os = \"ios\", target_os = \"macos\",\n-              target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\")))]\n+#[cfg(not(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"ios\",\n+    target_os = \"macos\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"solaris\",\n+    target_os = \"haiku\",\n+    target_os = \"l4re\"\n+)))]\n use crate::sys::net::netc::IPV6_ADD_MEMBERSHIP;\n-#[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n-          target_os = \"ios\", target_os = \"macos\",\n-          target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\"))]\n-use crate::sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n-#[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n-              target_os = \"ios\", target_os = \"macos\",\n-              target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\")))]\n+#[cfg(not(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"ios\",\n+    target_os = \"macos\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"solaris\",\n+    target_os = \"haiku\",\n+    target_os = \"l4re\"\n+)))]\n use crate::sys::net::netc::IPV6_DROP_MEMBERSHIP;\n+#[cfg(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"ios\",\n+    target_os = \"macos\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"solaris\",\n+    target_os = \"haiku\",\n+    target_os = \"l4re\"\n+))]\n+use crate::sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n+#[cfg(any(\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"ios\",\n+    target_os = \"macos\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"solaris\",\n+    target_os = \"haiku\",\n+    target_os = \"l4re\"\n+))]\n+use crate::sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n \n-#[cfg(any(target_os = \"linux\", target_os = \"android\",\n-          target_os = \"dragonfly\", target_os = \"freebsd\",\n-          target_os = \"openbsd\", target_os = \"netbsd\",\n-          target_os = \"haiku\"))]\n+#[cfg(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"haiku\"\n+))]\n use libc::MSG_NOSIGNAL;\n-#[cfg(not(any(target_os = \"linux\", target_os = \"android\",\n-              target_os = \"dragonfly\", target_os = \"freebsd\",\n-              target_os = \"openbsd\", target_os = \"netbsd\",\n-              target_os = \"haiku\")))]\n+#[cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"haiku\"\n+)))]\n const MSG_NOSIGNAL: c_int = 0x0;\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n-                     payload: T) -> io::Result<()> {\n+pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int, payload: T) -> io::Result<()> {\n     unsafe {\n         let payload = &payload as *const T as *const c_void;\n-        cvt(c::setsockopt(*sock.as_inner(), opt, val, payload,\n-                          mem::size_of::<T>() as c::socklen_t))?;\n+        cvt(c::setsockopt(\n+            *sock.as_inner(),\n+            opt,\n+            val,\n+            payload,\n+            mem::size_of::<T>() as c::socklen_t,\n+        ))?;\n         Ok(())\n     }\n }\n \n-pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n-                       val: c_int) -> io::Result<T> {\n+pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int, val: c_int) -> io::Result<T> {\n     unsafe {\n         let mut slot: T = mem::zeroed();\n         let mut len = mem::size_of::<T>() as c::socklen_t;\n-        cvt(c::getsockopt(*sock.as_inner(), opt, val,\n-                          &mut slot as *mut _ as *mut _,\n-                          &mut len))?;\n+        cvt(c::getsockopt(*sock.as_inner(), opt, val, &mut slot as *mut _ as *mut _, &mut len))?;\n         assert_eq!(len as usize, mem::size_of::<T>());\n         Ok(slot)\n     }\n }\n \n fn sockname<F>(f: F) -> io::Result<SocketAddr>\n-    where F: FnOnce(*mut c::sockaddr, *mut c::socklen_t) -> c_int\n+where\n+    F: FnOnce(*mut c::sockaddr, *mut c::socklen_t) -> c_int,\n {\n     unsafe {\n         let mut storage: c::sockaddr_storage = mem::zeroed();\n@@ -83,8 +123,7 @@ fn sockname<F>(f: F) -> io::Result<SocketAddr>\n     }\n }\n \n-pub fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n-                    len: usize) -> io::Result<SocketAddr> {\n+pub fn sockaddr_to_addr(storage: &c::sockaddr_storage, len: usize) -> io::Result<SocketAddr> {\n     match storage.ss_family as c_int {\n         c::AF_INET => {\n             assert!(len as usize >= mem::size_of::<c::sockaddr_in>());\n@@ -98,9 +137,7 @@ pub fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n                 *(storage as *const _ as *const c::sockaddr_in6)\n             })))\n         }\n-        _ => {\n-            Err(Error::new(ErrorKind::InvalidInput, \"invalid argument\"))\n-        }\n+        _ => Err(Error::new(ErrorKind::InvalidInput, \"invalid argument\")),\n     }\n }\n \n@@ -121,7 +158,7 @@ fn to_ipv6mr_interface(value: u32) -> libc::c_uint {\n pub struct LookupHost {\n     original: *mut c::addrinfo,\n     cur: *mut c::addrinfo,\n-    port: u16\n+    port: u16,\n }\n \n impl LookupHost {\n@@ -137,9 +174,7 @@ impl Iterator for LookupHost {\n             unsafe {\n                 let cur = self.cur.as_ref()?;\n                 self.cur = cur.ai_next;\n-                match sockaddr_to_addr(mem::transmute(cur.ai_addr),\n-                                       cur.ai_addrlen as usize)\n-                {\n+                match sockaddr_to_addr(mem::transmute(cur.ai_addr), cur.ai_addrlen as usize) {\n                     Ok(addr) => return Some(addr),\n                     Err(_) => continue,\n                 }\n@@ -162,13 +197,12 @@ impl TryFrom<&str> for LookupHost {\n \n     fn try_from(s: &str) -> io::Result<LookupHost> {\n         macro_rules! try_opt {\n-            ($e:expr, $msg:expr) => (\n+            ($e:expr, $msg:expr) => {\n                 match $e {\n                     Some(r) => r,\n-                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                                                      $msg)),\n+                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput, $msg)),\n                 }\n-            )\n+            };\n         }\n \n         // split the string by ':' and convert the second part to u16\n@@ -192,9 +226,8 @@ impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n         hints.ai_socktype = c::SOCK_STREAM;\n         let mut res = ptr::null_mut();\n         unsafe {\n-            cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)).map(|_| {\n-                LookupHost { original: res, cur: res, port }\n-            })\n+            cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res))\n+                .map(|_| LookupHost { original: res, cur: res, port })\n         }\n     }\n }\n@@ -228,9 +261,13 @@ impl TcpStream {\n         Ok(TcpStream { inner: sock })\n     }\n \n-    pub fn socket(&self) -> &Socket { &self.inner }\n+    pub fn socket(&self) -> &Socket {\n+        &self.inner\n+    }\n \n-    pub fn into_socket(self) -> Socket { self.inner }\n+    pub fn into_socket(self) -> Socket {\n+        self.inner\n+    }\n \n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         self.inner.set_timeout(dur, c::SO_RCVTIMEO)\n@@ -263,10 +300,7 @@ impl TcpStream {\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let ret = cvt(unsafe {\n-            c::send(*self.inner.as_inner(),\n-                    buf.as_ptr() as *const c_void,\n-                    len,\n-                    MSG_NOSIGNAL)\n+            c::send(*self.inner.as_inner(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n         })?;\n         Ok(ret as usize)\n     }\n@@ -276,15 +310,11 @@ impl TcpStream {\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe {\n-            c::getpeername(*self.inner.as_inner(), buf, len)\n-        })\n+        sockname(|buf, len| unsafe { c::getpeername(*self.inner.as_inner(), buf, len) })\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe {\n-            c::getsockname(*self.inner.as_inner(), buf, len)\n-        })\n+        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n@@ -339,9 +369,8 @@ impl fmt::Debug for TcpStream {\n             res.field(\"peer\", &peer);\n         }\n \n-        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n-        res.field(name, &self.inner.as_inner())\n-            .finish()\n+        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n+        res.field(name, &self.inner.as_inner()).finish()\n     }\n }\n \n@@ -365,8 +394,7 @@ impl TcpListener {\n         // to quickly rebind a socket, without needing to wait for\n         // the OS to clean up the previous one.\n         if !cfg!(windows) {\n-            setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR,\n-                       1 as c_int)?;\n+            setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR, 1 as c_int)?;\n         }\n \n         // Bind our new socket\n@@ -378,23 +406,24 @@ impl TcpListener {\n         Ok(TcpListener { inner: sock })\n     }\n \n-    pub fn socket(&self) -> &Socket { &self.inner }\n+    pub fn socket(&self) -> &Socket {\n+        &self.inner\n+    }\n \n-    pub fn into_socket(self) -> Socket { self.inner }\n+    pub fn into_socket(self) -> Socket {\n+        self.inner\n+    }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe {\n-            c::getsockname(*self.inner.as_inner(), buf, len)\n-        })\n+        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n     }\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         let mut storage: c::sockaddr_storage = unsafe { mem::zeroed() };\n         let mut len = mem::size_of_val(&storage) as c::socklen_t;\n-        let sock = self.inner.accept(&mut storage as *mut _ as *mut _,\n-                                     &mut len)?;\n+        let sock = self.inner.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n         let addr = sockaddr_to_addr(&storage, len as usize)?;\n-        Ok((TcpStream { inner: sock, }, addr))\n+        Ok((TcpStream { inner: sock }, addr))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpListener> {\n@@ -442,9 +471,8 @@ impl fmt::Debug for TcpListener {\n             res.field(\"addr\", &addr);\n         }\n \n-        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n-        res.field(name, &self.inner.as_inner())\n-            .finish()\n+        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n+        res.field(name, &self.inner.as_inner()).finish()\n     }\n }\n \n@@ -468,20 +496,20 @@ impl UdpSocket {\n         Ok(UdpSocket { inner: sock })\n     }\n \n-    pub fn socket(&self) -> &Socket { &self.inner }\n+    pub fn socket(&self) -> &Socket {\n+        &self.inner\n+    }\n \n-    pub fn into_socket(self) -> Socket { self.inner }\n+    pub fn into_socket(self) -> Socket {\n+        self.inner\n+    }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe {\n-            c::getpeername(*self.inner.as_inner(), buf, len)\n-        })\n+        sockname(|buf, len| unsafe { c::getpeername(*self.inner.as_inner(), buf, len) })\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe {\n-            c::getsockname(*self.inner.as_inner(), buf, len)\n-        })\n+        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n     }\n \n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n@@ -496,9 +524,14 @@ impl UdpSocket {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let (dstp, dstlen) = dst.into_inner();\n         let ret = cvt(unsafe {\n-            c::sendto(*self.inner.as_inner(),\n-                      buf.as_ptr() as *const c_void, len,\n-                      MSG_NOSIGNAL, dstp, dstlen)\n+            c::sendto(\n+                *self.inner.as_inner(),\n+                buf.as_ptr() as *const c_void,\n+                len,\n+                MSG_NOSIGNAL,\n+                dstp,\n+                dstlen,\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -559,35 +592,31 @@ impl UdpSocket {\n         Ok(raw != 0)\n     }\n \n-    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n         let mreq = c::ip_mreq {\n             imr_multiaddr: *multiaddr.as_inner(),\n             imr_interface: *interface.as_inner(),\n         };\n         setsockopt(&self.inner, c::IPPROTO_IP, c::IP_ADD_MEMBERSHIP, mreq)\n     }\n \n-    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)\n-                         -> io::Result<()> {\n+    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n         let mreq = c::ipv6_mreq {\n             ipv6mr_multiaddr: *multiaddr.as_inner(),\n             ipv6mr_interface: to_ipv6mr_interface(interface),\n         };\n         setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, mreq)\n     }\n \n-    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n         let mreq = c::ip_mreq {\n             imr_multiaddr: *multiaddr.as_inner(),\n             imr_interface: *interface.as_inner(),\n         };\n         setsockopt(&self.inner, c::IPPROTO_IP, c::IP_DROP_MEMBERSHIP, mreq)\n     }\n \n-    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)\n-                          -> io::Result<()> {\n+    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n         let mreq = c::ipv6_mreq {\n             ipv6mr_multiaddr: *multiaddr.as_inner(),\n             ipv6mr_interface: to_ipv6mr_interface(interface),\n@@ -623,10 +652,7 @@ impl UdpSocket {\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let ret = cvt(unsafe {\n-            c::send(*self.inner.as_inner(),\n-                    buf.as_ptr() as *const c_void,\n-                    len,\n-                    MSG_NOSIGNAL)\n+            c::send(*self.inner.as_inner(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n         })?;\n         Ok(ret as usize)\n     }\n@@ -651,9 +677,8 @@ impl fmt::Debug for UdpSocket {\n             res.field(\"addr\", &addr);\n         }\n \n-        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n-        res.field(name, &self.inner.as_inner())\n-            .finish()\n+        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n+        res.field(name, &self.inner.as_inner()).finish()\n     }\n }\n \n@@ -667,10 +692,15 @@ mod tests {\n         let mut addrs = HashMap::new();\n         let lh = match LookupHost::try_from((\"localhost\", 0)) {\n             Ok(lh) => lh,\n-            Err(e) => panic!(\"couldn't resolve `localhost': {}\", e)\n+            Err(e) => panic!(\"couldn't resolve `localhost': {}\", e),\n         };\n-        for sa in lh { *addrs.entry(sa).or_insert(0) += 1; };\n-        assert_eq!(addrs.iter().filter(|&(_, &v)| v > 1).collect::<Vec<_>>(), vec![],\n-                   \"There should be no duplicate localhost entries\");\n+        for sa in lh {\n+            *addrs.entry(sa).or_insert(0) += 1;\n+        }\n+        assert_eq!(\n+            addrs.iter().filter(|&(_, &v)| v > 1).collect::<Vec<_>>(),\n+            vec![],\n+            \"There should be no duplicate localhost entries\"\n+        );\n     }\n }"}, {"sha": "a2608ad4000d420c90fc70124dfeb4f71f0d246b", "filename": "src/libstd/sys_common/os_str_bytes.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -4,18 +4,18 @@\n use crate::borrow::Cow;\n use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n-use crate::str;\n use crate::mem;\n use crate::rc::Rc;\n+use crate::str;\n use crate::sync::Arc;\n-use crate::sys_common::{FromInner, IntoInner, AsInner};\n use crate::sys_common::bytestring::debug_fmt_bytestring;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n use core::str::lossy::Utf8Lossy;\n \n #[derive(Clone, Hash)]\n pub(crate) struct Buf {\n-    pub inner: Vec<u8>\n+    pub inner: Vec<u8>,\n }\n \n // FIXME:\n@@ -25,7 +25,7 @@ pub(crate) struct Buf {\n // Anyway, `Slice` representation and layout are considered implementation detail, are\n // not documented and must not be relied upon.\n pub(crate) struct Slice {\n-    pub inner: [u8]\n+    pub inner: [u8],\n }\n \n impl fmt::Debug for Slice {\n@@ -64,17 +64,14 @@ impl AsInner<[u8]> for Buf {\n     }\n }\n \n-\n impl Buf {\n     pub fn from_string(s: String) -> Buf {\n         Buf { inner: s.into_bytes() }\n     }\n \n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Buf {\n-        Buf {\n-            inner: Vec::with_capacity(capacity)\n-        }\n+        Buf { inner: Vec::with_capacity(capacity) }\n     }\n \n     #[inline]\n@@ -112,7 +109,7 @@ impl Buf {\n     }\n \n     pub fn into_string(self) -> Result<String, Buf> {\n-        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n+        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() })\n     }\n \n     pub fn push_slice(&mut self, s: &Slice) {"}, {"sha": "0157b952996acc97f363bfd65f04bb8e8c2b169f", "filename": "src/libstd/sys_common/poison.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fpoison.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,9 +1,11 @@\n-use crate::error::{Error};\n+use crate::error::Error;\n use crate::fmt;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::thread;\n \n-pub struct Flag { failed: AtomicBool }\n+pub struct Flag {\n+    failed: AtomicBool,\n+}\n \n // Note that the Ordering uses to access the `failed` field of `Flag` below is\n // always `Relaxed`, and that's because this isn't actually protecting any data,\n@@ -24,11 +26,7 @@ impl Flag {\n     #[inline]\n     pub fn borrow(&self) -> LockResult<Guard> {\n         let ret = Guard { panicking: thread::panicking() };\n-        if self.get() {\n-            Err(PoisonError::new(ret))\n-        } else {\n-            Ok(ret)\n-        }\n+        if self.get() { Err(PoisonError::new(ret)) } else { Ok(ret) }\n     }\n \n     #[inline]\n@@ -192,17 +190,23 @@ impl<T> PoisonError<T> {\n     /// println!(\"recovered {} items\", data.len());\n     /// ```\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n-    pub fn into_inner(self) -> T { self.guard }\n+    pub fn into_inner(self) -> T {\n+        self.guard\n+    }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// reference to the underlying guard to allow access regardless.\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n-    pub fn get_ref(&self) -> &T { &self.guard }\n+    pub fn get_ref(&self) -> &T {\n+        &self.guard\n+    }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// mutable reference to the underlying guard to allow access regardless.\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n-    pub fn get_mut(&mut self) -> &mut T { &mut self.guard }\n+    pub fn get_mut(&mut self) -> &mut T {\n+        &mut self.guard\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -217,7 +221,7 @@ impl<T> fmt::Debug for TryLockError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             TryLockError::Poisoned(..) => \"Poisoned(..)\".fmt(f),\n-            TryLockError::WouldBlock => \"WouldBlock\".fmt(f)\n+            TryLockError::WouldBlock => \"WouldBlock\".fmt(f),\n         }\n     }\n }\n@@ -227,8 +231,9 @@ impl<T> fmt::Display for TryLockError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             TryLockError::Poisoned(..) => \"poisoned lock: another task failed inside\",\n-            TryLockError::WouldBlock => \"try_lock failed because the operation would block\"\n-        }.fmt(f)\n+            TryLockError::WouldBlock => \"try_lock failed because the operation would block\",\n+        }\n+        .fmt(f)\n     }\n }\n \n@@ -237,23 +242,24 @@ impl<T> Error for TryLockError<T> {\n     fn description(&self) -> &str {\n         match *self {\n             TryLockError::Poisoned(ref p) => p.description(),\n-            TryLockError::WouldBlock => \"try_lock failed because the operation would block\"\n+            TryLockError::WouldBlock => \"try_lock failed because the operation would block\",\n         }\n     }\n \n     fn cause(&self) -> Option<&dyn Error> {\n         match *self {\n             TryLockError::Poisoned(ref p) => Some(p),\n-            _ => None\n+            _ => None,\n         }\n     }\n }\n \n-pub fn map_result<T, U, F>(result: LockResult<T>, f: F)\n-                           -> LockResult<U>\n-                           where F: FnOnce(T) -> U {\n+pub fn map_result<T, U, F>(result: LockResult<T>, f: F) -> LockResult<U>\n+where\n+    F: FnOnce(T) -> U,\n+{\n     match result {\n         Ok(t) => Ok(f(t)),\n-        Err(PoisonError { guard }) => Err(PoisonError::new(f(guard)))\n+        Err(PoisonError { guard }) => Err(PoisonError::new(f(guard))),\n     }\n }"}, {"sha": "55b421794c4130d6b942271e0452b95dbff3cd03", "filename": "src/libstd/sys_common/process.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fprocess.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -11,16 +11,12 @@ use crate::sys::process::EnvKey;\n pub struct CommandEnv {\n     clear: bool,\n     saw_path: bool,\n-    vars: BTreeMap<EnvKey, Option<OsString>>\n+    vars: BTreeMap<EnvKey, Option<OsString>>,\n }\n \n impl Default for CommandEnv {\n     fn default() -> Self {\n-        CommandEnv {\n-            clear: false,\n-            saw_path: false,\n-            vars: Default::default()\n-        }\n+        CommandEnv { clear: false, saw_path: false, vars: Default::default() }\n     }\n }\n \n@@ -64,11 +60,7 @@ impl CommandEnv {\n     }\n \n     pub fn capture_if_changed(&self) -> Option<BTreeMap<EnvKey, OsString>> {\n-        if self.is_unchanged() {\n-            None\n-        } else {\n-            Some(self.capture())\n-        }\n+        if self.is_unchanged() { None } else { Some(self.capture()) }\n     }\n \n     // The following functions build up changes"}, {"sha": "f09d16c33e6d6401470b61814af5e2ea39ff27b8", "filename": "src/libstd/sys_common/thread_info.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_info.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -12,16 +12,19 @@ struct ThreadInfo {\n thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None) }\n \n impl ThreadInfo {\n-    fn with<R, F>(f: F) -> Option<R> where F: FnOnce(&mut ThreadInfo) -> R {\n-        THREAD_INFO.try_with(move |c| {\n-            if c.borrow().is_none() {\n-                *c.borrow_mut() = Some(ThreadInfo {\n-                    stack_guard: None,\n-                    thread: Thread::new(None),\n-                })\n-            }\n-            f(c.borrow_mut().as_mut().unwrap())\n-        }).ok()\n+    fn with<R, F>(f: F) -> Option<R>\n+    where\n+        F: FnOnce(&mut ThreadInfo) -> R,\n+    {\n+        THREAD_INFO\n+            .try_with(move |c| {\n+                if c.borrow().is_none() {\n+                    *c.borrow_mut() =\n+                        Some(ThreadInfo { stack_guard: None, thread: Thread::new(None) })\n+                }\n+                f(c.borrow_mut().as_mut().unwrap())\n+            })\n+            .ok()\n     }\n }\n \n@@ -35,10 +38,7 @@ pub fn stack_guard() -> Option<Guard> {\n \n pub fn set(stack_guard: Option<Guard>, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n-    THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n-        stack_guard,\n-        thread,\n-    }));\n+    THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo { stack_guard, thread }));\n }\n \n pub fn reset_guard(stack_guard: Option<Guard>) {"}, {"sha": "00f7db4c037619a8724b86aa37d951a727ba7cf1", "filename": "src/libstd/sys_common/util.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Futil.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -16,11 +16,15 @@ pub fn dumb_print(args: fmt::Arguments<'_>) {\n \n pub fn abort(args: fmt::Arguments<'_>) -> ! {\n     dumb_print(format_args!(\"fatal runtime error: {}\\n\", args));\n-    unsafe { crate::sys::abort_internal(); }\n+    unsafe {\n+        crate::sys::abort_internal();\n+    }\n }\n \n #[allow(dead_code)] // stack overflow detection not enabled on all platforms\n pub unsafe fn report_overflow() {\n-    dumb_print(format_args!(\"\\nthread '{}' has overflowed its stack\\n\",\n-                            thread::current().name().unwrap_or(\"<unknown>\")));\n+    dumb_print(format_args!(\n+        \"\\nthread '{}' has overflowed its stack\\n\",\n+        thread::current().name().unwrap_or(\"<unknown>\")\n+    ));\n }"}, {"sha": "1d96cdfe46042c5617d8826e94f078eff06010b4", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 122, "deletions": 121, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -39,7 +39,7 @@ const UTF8_REPLACEMENT_CHARACTER: &str = \"\\u{FFFD}\";\n /// a code point that is not a surrogate (U+D800 to U+DFFF).\n #[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]\n pub struct CodePoint {\n-    value: u32\n+    value: u32,\n }\n \n /// Format the code point as `U+` followed by four to six hexadecimal digits.\n@@ -66,8 +66,8 @@ impl CodePoint {\n     #[inline]\n     pub fn from_u32(value: u32) -> Option<CodePoint> {\n         match value {\n-            0 ..= 0x10FFFF => Some(CodePoint { value }),\n-            _ => None\n+            0..=0x10FFFF => Some(CodePoint { value }),\n+            _ => None,\n         }\n     }\n \n@@ -91,8 +91,8 @@ impl CodePoint {\n     #[inline]\n     pub fn to_char(&self) -> Option<char> {\n         match self.value {\n-            0xD800 ..= 0xDFFF => None,\n-            _ => Some(unsafe { char::from_u32_unchecked(self.value) })\n+            0xD800..=0xDFFF => None,\n+            _ => Some(unsafe { char::from_u32_unchecked(self.value) }),\n         }\n     }\n \n@@ -112,7 +112,7 @@ impl CodePoint {\n /// if they\u2019re not in a surrogate pair.\n #[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]\n pub struct Wtf8Buf {\n-    bytes: Vec<u8>\n+    bytes: Vec<u8>,\n }\n \n impl ops::Deref for Wtf8Buf {\n@@ -188,9 +188,7 @@ impl Wtf8Buf {\n                 Err(surrogate) => {\n                     let surrogate = surrogate.unpaired_surrogate();\n                     // Surrogates are known to be in the code point range.\n-                    let code_point = unsafe {\n-                        CodePoint::from_u32_unchecked(surrogate as u32)\n-                    };\n+                    let code_point = unsafe { CodePoint::from_u32_unchecked(surrogate as u32) };\n                     // Skip the WTF-8 concatenation check,\n                     // surrogate pairs are already decoded by decode_utf16\n                     string.push_code_point_unchecked(code_point)\n@@ -203,9 +201,7 @@ impl Wtf8Buf {\n     /// Copied from String::push\n     /// This does **not** include the WTF-8 concatenation check.\n     fn push_code_point_unchecked(&mut self, code_point: CodePoint) {\n-        let c = unsafe {\n-            char::from_u32_unchecked(code_point.value)\n-        };\n+        let c = unsafe { char::from_u32_unchecked(code_point.value) };\n         let mut bytes = [0; 4];\n         let bytes = c.encode_utf8(&mut bytes).as_bytes();\n         self.bytes.extend_from_slice(bytes)\n@@ -278,7 +274,7 @@ impl Wtf8Buf {\n                 self.push_char(decode_surrogate_pair(lead, trail));\n                 self.bytes.extend_from_slice(other_without_trail_surrogate);\n             }\n-            _ => self.bytes.extend_from_slice(&other.bytes)\n+            _ => self.bytes.extend_from_slice(&other.bytes),\n         }\n     }\n \n@@ -300,7 +296,7 @@ impl Wtf8Buf {\n                 let len_without_lead_surrogate = self.len() - 3;\n                 self.bytes.truncate(len_without_lead_surrogate);\n                 self.push_char(decode_surrogate_pair(lead, trail as u16));\n-                return\n+                return;\n             }\n         }\n \n@@ -347,8 +343,8 @@ impl Wtf8Buf {\n                     pos = surrogate_pos + 3;\n                     self.bytes[surrogate_pos..pos]\n                         .copy_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());\n-                },\n-                None => return unsafe { String::from_utf8_unchecked(self.bytes) }\n+                }\n+                None => return unsafe { String::from_utf8_unchecked(self.bytes) },\n             }\n         }\n     }\n@@ -371,7 +367,7 @@ impl Wtf8Buf {\n /// This replaces surrogate code point pairs with supplementary code points,\n /// like concatenating ill-formed UTF-16 strings effectively would.\n impl FromIterator<CodePoint> for Wtf8Buf {\n-    fn from_iter<T: IntoIterator<Item=CodePoint>>(iter: T) -> Wtf8Buf {\n+    fn from_iter<T: IntoIterator<Item = CodePoint>>(iter: T) -> Wtf8Buf {\n         let mut string = Wtf8Buf::new();\n         string.extend(iter);\n         string\n@@ -383,7 +379,7 @@ impl FromIterator<CodePoint> for Wtf8Buf {\n /// This replaces surrogate code point pairs with supplementary code points,\n /// like concatenating ill-formed UTF-16 strings effectively would.\n impl Extend<CodePoint> for Wtf8Buf {\n-    fn extend<T: IntoIterator<Item=CodePoint>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = CodePoint>>(&mut self, iter: T) {\n         let iterator = iter.into_iter();\n         let (low, _high) = iterator.size_hint();\n         // Lower bound of one byte per code point (ASCII only)\n@@ -398,11 +394,13 @@ impl Extend<CodePoint> for Wtf8Buf {\n /// if they\u2019re not in a surrogate pair.\n #[derive(Eq, Ord, PartialEq, PartialOrd)]\n pub struct Wtf8 {\n-    bytes: [u8]\n+    bytes: [u8],\n }\n \n impl AsInner<[u8]> for Wtf8 {\n-    fn as_inner(&self) -> &[u8] { &self.bytes }\n+    fn as_inner(&self) -> &[u8] {\n+        &self.bytes\n+    }\n }\n \n /// Format the slice with double quotes,\n@@ -421,19 +419,13 @@ impl fmt::Debug for Wtf8 {\n         formatter.write_str(\"\\\"\")?;\n         let mut pos = 0;\n         while let Some((surrogate_pos, surrogate)) = self.next_surrogate(pos) {\n-            write_str_escaped(\n-                formatter,\n-                unsafe { str::from_utf8_unchecked(\n-                    &self.bytes[pos .. surrogate_pos]\n-                )},\n-            )?;\n+            write_str_escaped(formatter, unsafe {\n+                str::from_utf8_unchecked(&self.bytes[pos..surrogate_pos])\n+            })?;\n             write!(formatter, \"\\\\u{{{:x}}}\", surrogate)?;\n             pos = surrogate_pos + 3;\n         }\n-        write_str_escaped(\n-            formatter,\n-            unsafe { str::from_utf8_unchecked(&self.bytes[pos..]) },\n-        )?;\n+        write_str_escaped(formatter, unsafe { str::from_utf8_unchecked(&self.bytes[pos..]) })?;\n         formatter.write_str(\"\\\"\")\n     }\n }\n@@ -446,20 +438,14 @@ impl fmt::Display for Wtf8 {\n             match self.next_surrogate(pos) {\n                 Some((surrogate_pos, _)) => {\n                     formatter.write_str(unsafe {\n-                        str::from_utf8_unchecked(&wtf8_bytes[pos .. surrogate_pos])\n+                        str::from_utf8_unchecked(&wtf8_bytes[pos..surrogate_pos])\n                     })?;\n                     formatter.write_str(UTF8_REPLACEMENT_CHARACTER)?;\n                     pos = surrogate_pos + 3;\n-                },\n+                }\n                 None => {\n-                    let s = unsafe {\n-                        str::from_utf8_unchecked(&wtf8_bytes[pos..])\n-                    };\n-                    if pos == 0 {\n-                        return s.fmt(formatter)\n-                    } else {\n-                        return formatter.write_str(s)\n-                    }\n+                    let s = unsafe { str::from_utf8_unchecked(&wtf8_bytes[pos..]) };\n+                    if pos == 0 { return s.fmt(formatter) } else { return formatter.write_str(s) }\n                 }\n             }\n         }\n@@ -513,8 +499,8 @@ impl Wtf8 {\n     #[inline]\n     pub fn ascii_byte_at(&self, position: usize) -> u8 {\n         match self.bytes[position] {\n-            ascii_byte @ 0x00 ..= 0x7F => ascii_byte,\n-            _ => 0xFF\n+            ascii_byte @ 0x00..=0x7F => ascii_byte,\n+            _ => 0xFF,\n         }\n     }\n \n@@ -558,13 +544,13 @@ impl Wtf8 {\n         loop {\n             match self.next_surrogate(pos) {\n                 Some((surrogate_pos, _)) => {\n-                    utf8_bytes.extend_from_slice(&wtf8_bytes[pos .. surrogate_pos]);\n+                    utf8_bytes.extend_from_slice(&wtf8_bytes[pos..surrogate_pos]);\n                     utf8_bytes.extend_from_slice(UTF8_REPLACEMENT_CHARACTER.as_bytes());\n                     pos = surrogate_pos + 3;\n-                },\n+                }\n                 None => {\n                     utf8_bytes.extend_from_slice(&wtf8_bytes[pos..]);\n-                    return Cow::Owned(unsafe { String::from_utf8_unchecked(utf8_bytes) })\n+                    return Cow::Owned(unsafe { String::from_utf8_unchecked(utf8_bytes) });\n                 }\n             }\n         }\n@@ -594,9 +580,9 @@ impl Wtf8 {\n             } else if b == 0xED {\n                 match (iter.next(), iter.next()) {\n                     (Some(&b2), Some(&b3)) if b2 >= 0xA0 => {\n-                        return Some((pos, decode_surrogate(b2, b3)))\n+                        return Some((pos, decode_surrogate(b2, b3)));\n                     }\n-                    _ => pos += 3\n+                    _ => pos += 3,\n                 }\n             } else if b < 0xF0 {\n                 iter.next();\n@@ -615,23 +601,23 @@ impl Wtf8 {\n     fn final_lead_surrogate(&self) -> Option<u16> {\n         let len = self.len();\n         if len < 3 {\n-            return None\n+            return None;\n         }\n         match &self.bytes[(len - 3)..] {\n             &[0xED, b2 @ 0xA0..=0xAF, b3] => Some(decode_surrogate(b2, b3)),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n     #[inline]\n     fn initial_trail_surrogate(&self) -> Option<u16> {\n         let len = self.len();\n         if len < 3 {\n-            return None\n+            return None;\n         }\n         match &self.bytes[..3] {\n             &[0xED, b2 @ 0xB0..=0xBF, b3] => Some(decode_surrogate(b2, b3)),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n@@ -661,7 +647,6 @@ impl Wtf8 {\n     }\n }\n \n-\n /// Returns a slice of the given string for the byte range [`begin`..`end`).\n ///\n /// # Panics\n@@ -674,9 +659,10 @@ impl ops::Index<ops::Range<usize>> for Wtf8 {\n     #[inline]\n     fn index(&self, range: ops::Range<usize>) -> &Wtf8 {\n         // is_code_point_boundary checks that the index is in [0, .len()]\n-        if range.start <= range.end &&\n-           is_code_point_boundary(self, range.start) &&\n-           is_code_point_boundary(self, range.end) {\n+        if range.start <= range.end\n+            && is_code_point_boundary(self, range.start)\n+            && is_code_point_boundary(self, range.end)\n+        {\n             unsafe { slice_unchecked(self, range.start, range.end) }\n         } else {\n             slice_error_fail(self, range.start, range.end)\n@@ -748,7 +734,9 @@ fn decode_surrogate_pair(lead: u16, trail: u16) -> char {\n /// Copied from core::str::StrPrelude::is_char_boundary\n #[inline]\n pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool {\n-    if index == slice.len() { return true; }\n+    if index == slice.len() {\n+        return true;\n+    }\n     match slice.bytes.get(index) {\n         None => false,\n         Some(&b) => b < 128 || b >= 192,\n@@ -759,26 +747,22 @@ pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool {\n #[inline]\n pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 {\n     // memory layout of an &[u8] and &Wtf8 are the same\n-    Wtf8::from_bytes_unchecked(slice::from_raw_parts(\n-        s.bytes.as_ptr().add(begin),\n-        end - begin\n-    ))\n+    Wtf8::from_bytes_unchecked(slice::from_raw_parts(s.bytes.as_ptr().add(begin), end - begin))\n }\n \n /// Copied from core::str::raw::slice_error_fail\n #[inline(never)]\n pub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> ! {\n     assert!(begin <= end);\n-    panic!(\"index {} and/or {} in `{:?}` do not lie on character boundary\",\n-          begin, end, s);\n+    panic!(\"index {} and/or {} in `{:?}` do not lie on character boundary\", begin, end, s);\n }\n \n /// Iterator for the code points of a WTF-8 string.\n ///\n /// Created with the method `.code_points()`.\n #[derive(Clone)]\n pub struct Wtf8CodePoints<'a> {\n-    bytes: slice::Iter<'a, u8>\n+    bytes: slice::Iter<'a, u8>,\n }\n \n impl<'a> Iterator for Wtf8CodePoints<'a> {\n@@ -801,7 +785,7 @@ impl<'a> Iterator for Wtf8CodePoints<'a> {\n #[derive(Clone)]\n pub struct EncodeWide<'a> {\n     code_points: Wtf8CodePoints<'a>,\n-    extra: u16\n+    extra: u16,\n }\n \n // Copied from libunicode/u_str.rs\n@@ -819,9 +803,7 @@ impl<'a> Iterator for EncodeWide<'a> {\n \n         let mut buf = [0; 2];\n         self.code_points.next().map(|code_point| {\n-            let c = unsafe {\n-                char::from_u32_unchecked(code_point.value)\n-            };\n+            let c = unsafe { char::from_u32_unchecked(code_point.value) };\n             let n = c.encode_utf16(&mut buf).len();\n             if n == 2 {\n                 self.extra = buf[1];\n@@ -864,13 +846,15 @@ impl Hash for Wtf8 {\n }\n \n impl Wtf8 {\n-    pub fn make_ascii_uppercase(&mut self) { self.bytes.make_ascii_uppercase() }\n+    pub fn make_ascii_uppercase(&mut self) {\n+        self.bytes.make_ascii_uppercase()\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::borrow::Cow;\n     use super::*;\n+    use crate::borrow::Cow;\n \n     #[test]\n     fn code_point_from_u32() {\n@@ -882,7 +866,9 @@ mod tests {\n \n     #[test]\n     fn code_point_to_u32() {\n-        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        fn c(value: u32) -> CodePoint {\n+            CodePoint::from_u32(value).unwrap()\n+        }\n         assert_eq!(c(0).to_u32(), 0);\n         assert_eq!(c(0xD800).to_u32(), 0xD800);\n         assert_eq!(c(0x10FFFF).to_u32(), 0x10FFFF);\n@@ -902,15 +888,19 @@ mod tests {\n \n     #[test]\n     fn code_point_to_char() {\n-        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        fn c(value: u32) -> CodePoint {\n+            CodePoint::from_u32(value).unwrap()\n+        }\n         assert_eq!(c(0x61).to_char(), Some('a'));\n         assert_eq!(c(0x1F4A9).to_char(), Some('\ud83d\udca9'));\n         assert_eq!(c(0xD800).to_char(), None);\n     }\n \n     #[test]\n     fn code_point_to_char_lossy() {\n-        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        fn c(value: u32) -> CodePoint {\n+            CodePoint::from_u32(value).unwrap()\n+        }\n         assert_eq!(c(0x61).to_char_lossy(), 'a');\n         assert_eq!(c(0x1F4A9).to_char_lossy(), '\ud83d\udca9');\n         assert_eq!(c(0xD800).to_char_lossy(), '\\u{FFFD}');\n@@ -924,23 +914,25 @@ mod tests {\n     #[test]\n     fn wtf8buf_from_str() {\n         assert_eq!(Wtf8Buf::from_str(\"\").bytes, b\"\");\n-        assert_eq!(Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\").bytes,\n-                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(Wtf8Buf::from_str(\"a\u00e9 \ud83d\udca9\").bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n     }\n \n     #[test]\n     fn wtf8buf_from_string() {\n         assert_eq!(Wtf8Buf::from_string(String::from(\"\")).bytes, b\"\");\n-        assert_eq!(Wtf8Buf::from_string(String::from(\"a\u00e9 \ud83d\udca9\")).bytes,\n-                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(\n+            Wtf8Buf::from_string(String::from(\"a\u00e9 \ud83d\udca9\")).bytes,\n+            b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\"\n+        );\n     }\n \n     #[test]\n     fn wtf8buf_from_wide() {\n         assert_eq!(Wtf8Buf::from_wide(&[]).bytes, b\"\");\n-        assert_eq!(Wtf8Buf::from_wide(\n-                      &[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]).bytes,\n-                   b\"a\\xC3\\xA9 \\xED\\xA0\\xBD\\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(\n+            Wtf8Buf::from_wide(&[0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]).bytes,\n+            b\"a\\xC3\\xA9 \\xED\\xA0\\xBD\\xF0\\x9F\\x92\\xA9\"\n+        );\n     }\n \n     #[test]\n@@ -966,41 +958,43 @@ mod tests {\n         string.push(CodePoint::from_char('\ud83d\udca9'));\n         assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n \n-        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        fn c(value: u32) -> CodePoint {\n+            CodePoint::from_u32(value).unwrap()\n+        }\n \n         let mut string = Wtf8Buf::new();\n-        string.push(c(0xD83D));  // lead\n-        string.push(c(0xDCA9));  // trail\n-        assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        string.push(c(0xD83D)); // lead\n+        string.push(c(0xDCA9)); // trail\n+        assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n \n         let mut string = Wtf8Buf::new();\n-        string.push(c(0xD83D));  // lead\n-        string.push(c(0x20));  // not surrogate\n-        string.push(c(0xDCA9));  // trail\n+        string.push(c(0xD83D)); // lead\n+        string.push(c(0x20)); // not surrogate\n+        string.push(c(0xDCA9)); // trail\n         assert_eq!(string.bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push(c(0xD800));  // lead\n-        string.push(c(0xDBFF));  // lead\n+        string.push(c(0xD800)); // lead\n+        string.push(c(0xDBFF)); // lead\n         assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push(c(0xD800));  // lead\n-        string.push(c(0xE000));  // not surrogate\n+        string.push(c(0xD800)); // lead\n+        string.push(c(0xE000)); // not surrogate\n         assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push(c(0xD7FF));  // not surrogate\n-        string.push(c(0xDC00));  // trail\n+        string.push(c(0xD7FF)); // not surrogate\n+        string.push(c(0xDC00)); // trail\n         assert_eq!(string.bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push(c(0x61));  // not surrogate, < 3 bytes\n-        string.push(c(0xDC00));  // trail\n+        string.push(c(0x61)); // not surrogate, < 3 bytes\n+        string.push(c(0xDC00)); // trail\n         assert_eq!(string.bytes, b\"\\x61\\xED\\xB0\\x80\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push(c(0xDC00));  // trail\n+        string.push(c(0xDC00)); // trail\n         assert_eq!(string.bytes, b\"\\xED\\xB0\\x80\");\n     }\n \n@@ -1011,41 +1005,43 @@ mod tests {\n         string.push_wtf8(Wtf8::from_str(\" \ud83d\udca9\"));\n         assert_eq!(string.bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n \n-        fn w(v: &[u8]) -> &Wtf8 { unsafe { Wtf8::from_bytes_unchecked(v) } }\n+        fn w(v: &[u8]) -> &Wtf8 {\n+            unsafe { Wtf8::from_bytes_unchecked(v) }\n+        }\n \n         let mut string = Wtf8Buf::new();\n-        string.push_wtf8(w(b\"\\xED\\xA0\\xBD\"));  // lead\n-        string.push_wtf8(w(b\"\\xED\\xB2\\xA9\"));  // trail\n-        assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        string.push_wtf8(w(b\"\\xED\\xA0\\xBD\")); // lead\n+        string.push_wtf8(w(b\"\\xED\\xB2\\xA9\")); // trail\n+        assert_eq!(string.bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n \n         let mut string = Wtf8Buf::new();\n-        string.push_wtf8(w(b\"\\xED\\xA0\\xBD\"));  // lead\n-        string.push_wtf8(w(b\" \"));  // not surrogate\n-        string.push_wtf8(w(b\"\\xED\\xB2\\xA9\"));  // trail\n+        string.push_wtf8(w(b\"\\xED\\xA0\\xBD\")); // lead\n+        string.push_wtf8(w(b\" \")); // not surrogate\n+        string.push_wtf8(w(b\"\\xED\\xB2\\xA9\")); // trail\n         assert_eq!(string.bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push_wtf8(w(b\"\\xED\\xA0\\x80\"));  // lead\n-        string.push_wtf8(w(b\"\\xED\\xAF\\xBF\"));  // lead\n+        string.push_wtf8(w(b\"\\xED\\xA0\\x80\")); // lead\n+        string.push_wtf8(w(b\"\\xED\\xAF\\xBF\")); // lead\n         assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push_wtf8(w(b\"\\xED\\xA0\\x80\"));  // lead\n-        string.push_wtf8(w(b\"\\xEE\\x80\\x80\"));  // not surrogate\n+        string.push_wtf8(w(b\"\\xED\\xA0\\x80\")); // lead\n+        string.push_wtf8(w(b\"\\xEE\\x80\\x80\")); // not surrogate\n         assert_eq!(string.bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push_wtf8(w(b\"\\xED\\x9F\\xBF\"));  // not surrogate\n-        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        string.push_wtf8(w(b\"\\xED\\x9F\\xBF\")); // not surrogate\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n         assert_eq!(string.bytes, b\"\\xED\\x9F\\xBF\\xED\\xB0\\x80\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push_wtf8(w(b\"a\"));  // not surrogate, < 3 bytes\n-        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        string.push_wtf8(w(b\"a\")); // not surrogate, < 3 bytes\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n         assert_eq!(string.bytes, b\"\\x61\\xED\\xB0\\x80\");\n \n         let mut string = Wtf8Buf::new();\n-        string.push_wtf8(w(b\"\\xED\\xB0\\x80\"));  // trail\n+        string.push_wtf8(w(b\"\\xED\\xB0\\x80\")); // trail\n         assert_eq!(string.bytes, b\"\\xED\\xB0\\x80\");\n     }\n \n@@ -1093,7 +1089,7 @@ mod tests {\n         }\n         assert_eq!(f(&[0x61, 0xE9, 0x20, 0x1F4A9]).bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n \n-        assert_eq!(f(&[0xD83D, 0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(f(&[0xD83D, 0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n         assert_eq!(f(&[0xD83D, 0x20, 0xDCA9]).bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n         assert_eq!(f(&[0xD800, 0xDBFF]).bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n         assert_eq!(f(&[0xD800, 0xE000]).bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n@@ -1105,16 +1101,17 @@ mod tests {\n     #[test]\n     fn wtf8buf_extend() {\n         fn e(initial: &[u32], extended: &[u32]) -> Wtf8Buf {\n-            fn c(value: &u32) -> CodePoint { CodePoint::from_u32(*value).unwrap() }\n+            fn c(value: &u32) -> CodePoint {\n+                CodePoint::from_u32(*value).unwrap()\n+            }\n             let mut string = initial.iter().map(c).collect::<Wtf8Buf>();\n             string.extend(extended.iter().map(c));\n             string\n         }\n \n-        assert_eq!(e(&[0x61, 0xE9], &[0x20, 0x1F4A9]).bytes,\n-                   b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n+        assert_eq!(e(&[0x61, 0xE9], &[0x20, 0x1F4A9]).bytes, b\"a\\xC3\\xA9 \\xF0\\x9F\\x92\\xA9\");\n \n-        assert_eq!(e(&[0xD83D], &[0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\");  // Magic!\n+        assert_eq!(e(&[0xD83D], &[0xDCA9]).bytes, b\"\\xF0\\x9F\\x92\\xA9\"); // Magic!\n         assert_eq!(e(&[0xD83D, 0x20], &[0xDCA9]).bytes, b\"\\xED\\xA0\\xBD \\xED\\xB2\\xA9\");\n         assert_eq!(e(&[0xD800], &[0xDBFF]).bytes, b\"\\xED\\xA0\\x80\\xED\\xAF\\xBF\");\n         assert_eq!(e(&[0xD800], &[0xE000]).bytes, b\"\\xED\\xA0\\x80\\xEE\\x80\\x80\");\n@@ -1156,13 +1153,13 @@ mod tests {\n \n     #[test]\n     fn wtf8_slice() {\n-        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[1.. 4].bytes, b\"\\xC3\\xA9 \");\n+        assert_eq!(&Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[1..4].bytes, b\"\\xC3\\xA9 \");\n     }\n \n     #[test]\n     #[should_panic]\n     fn wtf8_slice_not_code_point_boundary() {\n-        &Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[2.. 4];\n+        &Wtf8::from_str(\"a\u00e9 \ud83d\udca9\")[2..4];\n     }\n \n     #[test]\n@@ -1199,7 +1196,9 @@ mod tests {\n \n     #[test]\n     fn wtf8_code_points() {\n-        fn c(value: u32) -> CodePoint { CodePoint::from_u32(value).unwrap() }\n+        fn c(value: u32) -> CodePoint {\n+            CodePoint::from_u32(value).unwrap()\n+        }\n         fn cp(string: &Wtf8Buf) -> Vec<Option<char>> {\n             string.code_points().map(|c| c.to_char()).collect::<Vec<_>>()\n         }\n@@ -1249,7 +1248,9 @@ mod tests {\n         let mut string = Wtf8Buf::from_str(\"a\u00e9 \");\n         string.push(CodePoint::from_u32(0xD83D).unwrap());\n         string.push_char('\ud83d\udca9');\n-        assert_eq!(string.encode_wide().collect::<Vec<_>>(),\n-                   vec![0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]);\n+        assert_eq!(\n+            string.encode_wide().collect::<Vec<_>>(),\n+            vec![0x61, 0xE9, 0x20, 0xD83D, 0xD83D, 0xDCA9]\n+        );\n     }\n }"}, {"sha": "c94fc41178dfe0bdc6d51096e0d41eba876861af", "filename": "src/libstd/tests/env.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Ftests%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Ftests%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftests%2Fenv.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -1,13 +1,12 @@\n use std::env::*;\n-use std::ffi::{OsString, OsStr};\n+use std::ffi::{OsStr, OsString};\n \n-use rand::{thread_rng, Rng};\n use rand::distributions::Alphanumeric;\n+use rand::{thread_rng, Rng};\n \n fn make_rand_name() -> OsString {\n     let rng = thread_rng();\n-    let n = format!(\"TEST{}\", rng.sample_iter(&Alphanumeric).take(10)\n-                                 .collect::<String>());\n+    let n = format!(\"TEST{}\", rng.sample_iter(&Alphanumeric).take(10).collect::<String>());\n     let n = OsString::from(n);\n     assert!(var_os(&n).is_none());\n     n\n@@ -73,11 +72,7 @@ fn test_env_set_var() {\n \n     let mut e = vars_os();\n     set_var(&n, \"VALUE\");\n-    assert!(!e.any(|(k, v)| {\n-        &*k == &*n && &*v == \"VALUE\"\n-    }));\n+    assert!(!e.any(|(k, v)| { &*k == &*n && &*v == \"VALUE\" }));\n \n-    assert!(vars_os().any(|(k, v)| {\n-        &*k == &*n && &*v == \"VALUE\"\n-    }));\n+    assert!(vars_os().any(|(k, v)| { &*k == &*n && &*v == \"VALUE\" }));\n }"}, {"sha": "9c530e7b3248c88e5270c8742f23c18ba6bd7799", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 49, "deletions": 54, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4436c9d35498e7ae3da261f6141d6d73b915e1e8/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=4436c9d35498e7ae3da261f6141d6d73b915e1e8", "patch": "@@ -142,9 +142,7 @@ macro_rules! thread_local {\n }\n \n #[doc(hidden)]\n-#[unstable(feature = \"thread_local_internals\",\n-           reason = \"should not be necessary\",\n-           issue = \"0\")]\n+#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"0\")]\n #[macro_export]\n #[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n #[allow_internal_unsafe]\n@@ -214,13 +212,13 @@ impl Error for AccessError {}\n \n impl<T: 'static> LocalKey<T> {\n     #[doc(hidden)]\n-    #[unstable(feature = \"thread_local_internals\",\n-               reason = \"recently added to create a key\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"thread_local_internals\",\n+        reason = \"recently added to create a key\",\n+        issue = \"0\"\n+    )]\n     pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n-        LocalKey {\n-            inner,\n-        }\n+        LocalKey { inner }\n     }\n \n     /// Acquires a reference to the value in this TLS key.\n@@ -235,9 +233,13 @@ impl<T: 'static> LocalKey<T> {\n     /// previously been run for this thread.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with<F, R>(&'static self, f: F) -> R\n-                      where F: FnOnce(&T) -> R {\n-        self.try_with(f).expect(\"cannot access a Thread Local Storage value \\\n-                                 during or after destruction\")\n+    where\n+        F: FnOnce(&T) -> R,\n+    {\n+        self.try_with(f).expect(\n+            \"cannot access a Thread Local Storage value \\\n+             during or after destruction\",\n+        )\n     }\n \n     /// Acquires a reference to the value in this TLS key.\n@@ -256,28 +258,24 @@ impl<T: 'static> LocalKey<T> {\n         F: FnOnce(&T) -> R,\n     {\n         unsafe {\n-            let thread_local = (self.inner)().ok_or(AccessError {\n-                _private: (),\n-            })?;\n+            let thread_local = (self.inner)().ok_or(AccessError { _private: () })?;\n             Ok(f(thread_local))\n         }\n     }\n }\n \n mod lazy {\n     use crate::cell::UnsafeCell;\n-    use crate::mem;\n     use crate::hint;\n+    use crate::mem;\n \n     pub struct LazyKeyInner<T> {\n         inner: UnsafeCell<Option<T>>,\n     }\n \n     impl<T> LazyKeyInner<T> {\n         pub const fn new() -> LazyKeyInner<T> {\n-            LazyKeyInner {\n-                inner: UnsafeCell::new(None),\n-            }\n+            LazyKeyInner { inner: UnsafeCell::new(None) }\n         }\n \n         pub unsafe fn get(&self) -> Option<&'static T> {\n@@ -334,7 +332,7 @@ pub mod statik {\n         inner: LazyKeyInner<T>,\n     }\n \n-    unsafe impl<T> Sync for Key<T> { }\n+    unsafe impl<T> Sync for Key<T> {}\n \n     impl<T> fmt::Debug for Key<T> {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -344,9 +342,7 @@ pub mod statik {\n \n     impl<T> Key<T> {\n         pub const fn new() -> Key<T> {\n-            Key {\n-                inner: LazyKeyInner::new(),\n-            }\n+            Key { inner: LazyKeyInner::new() }\n         }\n \n         pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n@@ -404,10 +400,7 @@ pub mod fast {\n \n     impl<T> Key<T> {\n         pub const fn new() -> Key<T> {\n-            Key {\n-                inner: LazyKeyInner::new(),\n-                dtor_state: Cell::new(DtorState::Unregistered),\n-            }\n+            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n         }\n \n         pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n@@ -441,23 +434,20 @@ pub mod fast {\n             match self.dtor_state.get() {\n                 DtorState::Unregistered => {\n                     // dtor registration happens before initialization.\n-                    register_dtor(self as *const _ as *mut u8,\n-                                destroy_value::<T>);\n+                    register_dtor(self as *const _ as *mut u8, destroy_value::<T>);\n                     self.dtor_state.set(DtorState::Registered);\n                     true\n                 }\n                 DtorState::Registered => {\n                     // recursively initialized\n                     true\n                 }\n-                DtorState::RunningOrHasRun => {\n-                    false\n-                }\n+                DtorState::RunningOrHasRun => false,\n             }\n         }\n     }\n \n-    unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n+    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n         let ptr = ptr as *mut Key<T>;\n \n         // Right before we run the user destructor be sure to set the\n@@ -491,7 +481,7 @@ pub mod os {\n         }\n     }\n \n-    unsafe impl<T> Sync for Key<T> { }\n+    unsafe impl<T> Sync for Key<T> {}\n \n     struct Value<T: 'static> {\n         inner: LazyKeyInner<T>,\n@@ -500,10 +490,7 @@ pub mod os {\n \n     impl<T: 'static> Key<T> {\n         pub const fn new() -> Key<T> {\n-            Key {\n-                os: OsStaticKey::new(Some(destroy_value::<T>)),\n-                marker: marker::PhantomData\n-            }\n+            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n         }\n \n         pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n@@ -523,16 +510,13 @@ pub mod os {\n             let ptr = self.os.get() as *mut Value<T>;\n             if ptr as usize == 1 {\n                 // destructor is running\n-                return None\n+                return None;\n             }\n \n             let ptr = if ptr.is_null() {\n                 // If the lookup returned null, we haven't initialized our own\n                 // local copy, so do that now.\n-                let ptr: Box<Value<T>> = box Value {\n-                    inner: LazyKeyInner::new(),\n-                    key: self,\n-                };\n+                let ptr: Box<Value<T>> = box Value { inner: LazyKeyInner::new(), key: self };\n                 let ptr = Box::into_raw(ptr);\n                 self.os.set(ptr as *mut u8);\n                 ptr\n@@ -545,7 +529,7 @@ pub mod os {\n         }\n     }\n \n-    unsafe extern fn destroy_value<T: 'static>(ptr: *mut u8) {\n+    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n         // The OS TLS ensures that this key contains a NULL value when this\n         // destructor starts to run. We set it back to a sentinel value of 1 to\n         // ensure that any future calls to `get` for this thread will return\n@@ -563,8 +547,8 @@ pub mod os {\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n-    use crate::sync::mpsc::{channel, Sender};\n     use crate::cell::{Cell, UnsafeCell};\n+    use crate::sync::mpsc::{channel, Sender};\n     use crate::thread;\n \n     struct Foo(Sender<()>);\n@@ -585,7 +569,7 @@ mod tests {\n             f.set(2);\n         });\n         let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n+        let _t = thread::spawn(move || {\n             FOO.with(|f| {\n                 assert_eq!(f.get(), 1);\n             });\n@@ -610,15 +594,18 @@ mod tests {\n \n         thread::spawn(|| {\n             assert!(FOO.try_with(|_| ()).is_ok());\n-        }).join().ok().expect(\"thread panicked\");\n+        })\n+        .join()\n+        .ok()\n+        .expect(\"thread panicked\");\n     }\n \n     #[test]\n     fn smoke_dtor() {\n         thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n \n         let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| unsafe {\n+        let _t = thread::spawn(move || unsafe {\n             let mut tx = Some(tx);\n             FOO.with(|f| {\n                 *f.get() = Some(Foo(tx.take().unwrap()));\n@@ -662,9 +649,12 @@ mod tests {\n             }\n         }\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             drop(S1);\n-        }).join().ok().expect(\"thread panicked\");\n+        })\n+        .join()\n+        .ok()\n+        .expect(\"thread panicked\");\n     }\n \n     #[test]\n@@ -678,9 +668,12 @@ mod tests {\n             }\n         }\n \n-        thread::spawn(move|| unsafe {\n+        thread::spawn(move || unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n-        }).join().ok().expect(\"thread panicked\");\n+        })\n+        .join()\n+        .ok()\n+        .expect(\"thread panicked\");\n     }\n \n     // Note that this test will deadlock if TLS destructors aren't run (this\n@@ -701,7 +694,7 @@ mod tests {\n         }\n \n         let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| unsafe {\n+        let _t = thread::spawn(move || unsafe {\n             let mut tx = Some(tx);\n             K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n         });\n@@ -716,7 +709,9 @@ mod dynamic_tests {\n \n     #[test]\n     fn smoke() {\n-        fn square(i: i32) -> i32 { i * i }\n+        fn square(i: i32) -> i32 {\n+            i * i\n+        }\n         thread_local!(static FOO: i32 = square(3));\n \n         FOO.with(|f| {"}]}