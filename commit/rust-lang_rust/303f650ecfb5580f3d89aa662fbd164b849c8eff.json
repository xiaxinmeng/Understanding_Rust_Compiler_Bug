{"sha": "303f650ecfb5580f3d89aa662fbd164b849c8eff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwM2Y2NTBlY2ZiNTU4MGYzZDg5YWE2NjJmYmQxNjRiODQ5YzhlZmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-21T19:25:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-19T11:13:15Z"}, "message": "Issue #3678: Remove wrappers and call foreign functions directly", "tree": {"sha": "d1821491f928f15750c4d857ef2028e47c3420aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1821491f928f15750c4d857ef2028e47c3420aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/303f650ecfb5580f3d89aa662fbd164b849c8eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/303f650ecfb5580f3d89aa662fbd164b849c8eff", "html_url": "https://github.com/rust-lang/rust/commit/303f650ecfb5580f3d89aa662fbd164b849c8eff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/303f650ecfb5580f3d89aa662fbd164b849c8eff/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c178b52fe594c6724d0cf9124665de7e627899a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c178b52fe594c6724d0cf9124665de7e627899a9", "html_url": "https://github.com/rust-lang/rust/commit/c178b52fe594c6724d0cf9124665de7e627899a9"}], "stats": {"total": 3249, "additions": 1690, "deletions": 1559}, "files": [{"sha": "0ad53c4d49c1a14ed20222222d42d296bf89163b", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -16,8 +16,6 @@ use lib::llvm::{ModuleRef, ValueRef};\n \n pub struct Upcalls {\n     trace: ValueRef,\n-    call_shim_on_c_stack: ValueRef,\n-    call_shim_on_rust_stack: ValueRef,\n     rust_personality: ValueRef,\n     reset_stack_limit: ValueRef\n }\n@@ -47,9 +45,6 @@ pub fn declare_upcalls(targ_cfg: @session::config, llmod: ModuleRef) -> @Upcalls\n \n     @Upcalls {\n         trace: upcall!(fn trace(opaque_ptr, opaque_ptr, int_ty) -> Type::void()),\n-        call_shim_on_c_stack: upcall!(fn call_shim_on_c_stack(opaque_ptr, opaque_ptr) -> int_ty),\n-        call_shim_on_rust_stack:\n-            upcall!(fn call_shim_on_rust_stack(opaque_ptr, opaque_ptr) -> int_ty),\n         rust_personality: upcall!(nothrow fn rust_personality -> Type::i32()),\n         reset_stack_limit: upcall!(nothrow fn reset_stack_limit -> Type::void())\n     }"}, {"sha": "828c01157682a3c37b66268537c30c5a5c3b4d32", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -265,6 +265,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     time(time_passes, ~\"loop checking\", ||\n          middle::check_loop::check_crate(ty_cx, crate));\n \n+    time(time_passes, ~\"stack checking\", ||\n+         middle::stack_check::stack_check_crate(ty_cx, crate));\n+\n     let middle::moves::MoveMaps {moves_map, moved_variables_set,\n                                  capture_map} =\n         time(time_passes, ~\"compute moves\", ||"}, {"sha": "b9e4e3da9200e8ba347a6efda36b328977d93b88", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -2246,6 +2246,11 @@ impl TypeNames {\n         self.type_to_str_depth(ty, 30)\n     }\n \n+    pub fn types_to_str(&self, tys: &[Type]) -> ~str {\n+        let strs = tys.map(|t| self.type_to_str(*t));\n+        fmt!(\"[%s]\", strs.connect(\",\"))\n+    }\n+\n     pub fn val_to_str(&self, val: ValueRef) -> ~str {\n         unsafe {\n             let ty = Type::from_ref(llvm::LLVMTypeOf(val));"}, {"sha": "880095db2ee1de151d90f41d4bde0efa81aa24e2", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -73,6 +73,7 @@ use syntax::{ast, oldvisit, ast_util, visit};\n #[deriving(Clone, Eq)]\n pub enum lint {\n     ctypes,\n+    cstack,\n     unused_imports,\n     unnecessary_qualification,\n     while_true,\n@@ -146,6 +147,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n      }),\n \n+    (\"cstack\",\n+     LintSpec {\n+        lint: cstack,\n+        desc: \"only invoke foreign functions from fixedstacksegment fns\",\n+        default: deny\n+     }),\n+\n     (\"unused_imports\",\n      LintSpec {\n         lint: unused_imports,"}, {"sha": "eb5e47959489daff0cc61c85c90f791434437e19", "filename": "src/librustc/middle/stack_check.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Fstack_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstack_check.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Lint mode to detect cases where we call non-Rust fns, which do not\n+have a stack growth check, from locations not annotated to request\n+large stacks.\n+\n+*/\n+\n+use middle::lint;\n+use middle::ty;\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::codemap::span;\n+use visit = syntax::oldvisit;\n+use util::ppaux::Repr;\n+\n+#[deriving(Clone)]\n+struct Context {\n+    tcx: ty::ctxt,\n+    safe_stack: bool\n+}\n+\n+pub fn stack_check_crate(tcx: ty::ctxt,\n+                         crate: &ast::Crate) {\n+    let new_cx = Context {\n+        tcx: tcx,\n+        safe_stack: false\n+    };\n+    let visitor = visit::mk_vt(@visit::Visitor {\n+        visit_item: stack_check_item,\n+        visit_fn: stack_check_fn,\n+        visit_expr: stack_check_expr,\n+        ..*visit::default_visitor()\n+    });\n+    visit::visit_crate(crate, (new_cx, visitor));\n+}\n+\n+fn stack_check_item(item: @ast::item,\n+                    (in_cx, v): (Context, visit::vt<Context>)) {\n+    let safe_stack = match item.node {\n+        ast::item_fn(*) => {\n+            attr::contains_name(item.attrs, \"fixed_stack_segment\")\n+        }\n+        _ => {\n+            false\n+        }\n+    };\n+    let new_cx = Context {\n+        tcx: in_cx.tcx,\n+        safe_stack: safe_stack\n+    };\n+    visit::visit_item(item, (new_cx, v));\n+}\n+\n+fn stack_check_fn<'a>(fk: &visit::fn_kind,\n+                      decl: &ast::fn_decl,\n+                      body: &ast::Block,\n+                      sp: span,\n+                      id: ast::NodeId,\n+                      (in_cx, v): (Context, visit::vt<Context>)) {\n+    let safe_stack = match *fk {\n+        visit::fk_item_fn(*) => in_cx.safe_stack, // see stack_check_item above\n+        visit::fk_anon(*) | visit::fk_fn_block | visit::fk_method(*) => false,\n+    };\n+    let new_cx = Context {\n+        tcx: in_cx.tcx,\n+        safe_stack: safe_stack\n+    };\n+    debug!(\"stack_check_fn(safe_stack=%b, id=%?)\", safe_stack, id);\n+    visit::visit_fn(fk, decl, body, sp, id, (new_cx, v));\n+}\n+\n+fn stack_check_expr<'a>(expr: @ast::expr,\n+                        (cx, v): (Context, visit::vt<Context>)) {\n+    debug!(\"stack_check_expr(safe_stack=%b, expr=%s)\",\n+           cx.safe_stack, expr.repr(cx.tcx));\n+    if !cx.safe_stack {\n+        match expr.node {\n+            ast::expr_call(callee, _, _) => {\n+                let callee_ty = ty::expr_ty(cx.tcx, callee);\n+                debug!(\"callee_ty=%s\", callee_ty.repr(cx.tcx));\n+                match ty::get(callee_ty).sty {\n+                    ty::ty_bare_fn(ref fty) => {\n+                        if !fty.abis.is_rust() && !fty.abis.is_intrinsic() {\n+                            cx.tcx.sess.add_lint(\n+                                lint::cstack,\n+                                callee.id,\n+                                callee.span,\n+                                fmt!(\"invoking non-Rust fn in fn without \\\n+                                      #[fixed_stack_segment]\"));\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    visit::visit_expr(expr, (cx, v));\n+}"}, {"sha": "6189d28b0ed088a7c49f04449ce15e2fea732101", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -203,28 +203,28 @@ pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRe\n     return llfn;\n }\n \n-pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: @str,\n+pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: &str,\n                      cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n-    match externs.find_copy(&name) {\n-        Some(n) => return n,\n+    match externs.find_equiv(&name) {\n+        Some(n) => return *n,\n         None => ()\n     }\n     let f = decl_fn(llmod, name, cc, ty);\n-    externs.insert(name, f);\n+    externs.insert(name.to_owned(), f);\n     return f;\n }\n \n pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n-                        name: @str, ty: Type) -> ValueRef {\n-    match externs.find_copy(&name) {\n-        Some(n) => return n,\n+                        name: &str, ty: Type) -> ValueRef {\n+    match externs.find_equiv(&name) {\n+        Some(n) => return *n,\n         None => ()\n     }\n     unsafe {\n         let c = do name.with_c_str |buf| {\n             llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n         };\n-        externs.insert(name, c);\n+        externs.insert(name.to_owned(), c);\n         return c;\n     }\n }\n@@ -511,7 +511,6 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n                                      None,\n                                      ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n-        let name = name.to_managed(); // :-(\n         get_extern_fn(&mut ccx.externs,\n                       ccx.llmod,\n                       name,\n@@ -798,13 +797,13 @@ pub fn fail_if_zero(cx: @mut Block, span: span, divrem: ast::binop,\n     }\n }\n \n-pub fn null_env_ptr(bcx: @mut Block) -> ValueRef {\n-    C_null(Type::opaque_box(bcx.ccx()).ptr_to())\n+pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n+    C_null(Type::opaque_box(ccx).ptr_to())\n }\n \n pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n-    let name = csearch::get_symbol(ccx.sess.cstore, did).to_managed(); // Sad\n+    let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n       ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n         let llty = type_of_fn_from_ty(ccx, t);\n@@ -1572,7 +1571,7 @@ pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> ValueRef {\n     unsafe {\n-        if !ty::type_is_immediate(fcx.ccx.tcx, output_type) {\n+        if type_of::return_uses_outptr(fcx.ccx.tcx, output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n@@ -1612,7 +1611,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n             ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n         }\n     };\n-    let is_immediate = ty::type_is_immediate(ccx.tcx, substd_output_type);\n+    let uses_outptr = type_of::return_uses_outptr(ccx.tcx, substd_output_type);\n     let fcx = @mut FunctionContext {\n           llfn: llfndecl,\n           llenv: unsafe {\n@@ -1624,7 +1623,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n           llreturn: None,\n           llself: None,\n           personality: None,\n-          has_immediate_return_value: is_immediate,\n+          caller_expects_out_pointer: uses_outptr,\n           llargs: @mut HashMap::new(),\n           lllocals: @mut HashMap::new(),\n           llupvars: @mut HashMap::new(),\n@@ -1647,8 +1646,15 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n         fcx.alloca_insert_pt = Some(llvm::LLVMGetFirstInstruction(entry_bcx.llbb));\n     }\n \n-    if !ty::type_is_nil(substd_output_type) && !(is_immediate && skip_retptr) {\n-        fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n+    if !ty::type_is_voidish(substd_output_type) {\n+        // If the function returns nil/bot, there is no real return\n+        // value, so do not set `llretptr`.\n+        if !skip_retptr || uses_outptr {\n+            // Otherwise, we normally allocate the llretptr, unless we\n+            // have been instructed to skip it for immediate return\n+            // values.\n+            fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n+        }\n     }\n     fcx\n }\n@@ -1796,7 +1802,7 @@ pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n // Builds the return block for a function.\n pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n     // Return the value if this function immediate; otherwise, return void.\n-    if fcx.llretptr.is_none() || !fcx.has_immediate_return_value {\n+    if fcx.llretptr.is_none() || fcx.caller_expects_out_pointer {\n         return RetVoid(ret_cx);\n     }\n \n@@ -1882,9 +1888,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n-    if body.expr.is_none() || ty::type_is_bot(block_ty) ||\n-        ty::type_is_nil(block_ty)\n-    {\n+    if body.expr.is_none() || ty::type_is_voidish(block_ty) {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n         let dest = expr::SaveIn(fcx.llretptr.unwrap());\n@@ -2129,13 +2133,14 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n       ast::item_fn(ref decl, purity, _abis, ref generics, ref body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n-            foreign::trans_foreign_fn(ccx,\n-                                      vec::append((*path).clone(),\n-                                                  [path_name(item.ident)]),\n-                                      decl,\n-                                      body,\n-                                      llfndecl,\n-                                      item.id);\n+            foreign::trans_rust_fn_with_foreign_abi(\n+                ccx,\n+                &vec::append((*path).clone(),\n+                             [path_name(item.ident)]),\n+                decl,\n+                body,\n+                llfndecl,\n+                item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n@@ -2196,7 +2201,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n           }\n       },\n       ast::item_foreign_mod(ref foreign_mod) => {\n-        foreign::trans_foreign_mod(ccx, path, foreign_mod);\n+        foreign::trans_foreign_mod(ccx, foreign_mod);\n       }\n       ast::item_struct(struct_def, ref generics) => {\n         if !generics.is_type_parameterized() {\n@@ -2291,16 +2296,15 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n \n     fn create_main(ccx: @mut CrateContext, main_llfn: ValueRef) -> ValueRef {\n         let nt = ty::mk_nil();\n-\n-        let llfty = type_of_fn(ccx, [], nt);\n+        let llfty = type_of_rust_fn(ccx, [], nt);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n         let fcx = new_fn_ctxt(ccx, ~[], llfdecl, nt, None);\n \n         // the args vector built in create_entry_fn will need\n         // be updated if this assertion starts to fail.\n-        assert!(fcx.has_immediate_return_value);\n+        assert!(!fcx.caller_expects_out_pointer);\n \n         let bcx = fcx.entry_bcx.unwrap();\n         // Call main.\n@@ -2463,7 +2467,10 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             let llfn = if purity != ast::extern_fn {\n                                 register_fn(ccx, i.span, sym, i.id, ty)\n                             } else {\n-                                foreign::register_foreign_fn(ccx, i.span, sym, i.id)\n+                                foreign::register_rust_fn_with_foreign_abi(ccx,\n+                                                                           i.span,\n+                                                                           sym,\n+                                                                           i.id)\n                             };\n                             set_inline_hint_if_appr(i.attrs, llfn);\n                             llfn\n@@ -2509,9 +2516,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                     match ni.node {\n                         ast::foreign_item_fn(*) => {\n                             let path = vec::append((*pth).clone(), [path_name(ni.ident)]);\n-                            let sym = exported_name(ccx, path, ty, ni.attrs);\n-\n-                            register_fn(ccx, ni.span, sym, ni.id, ty)\n+                            foreign::register_foreign_item_fn(ccx, abis, &path, ni);\n                         }\n                         ast::foreign_item_static(*) => {\n                             let ident = token::ident_to_str(&ni.ident);"}, {"sha": "005483a075f8df31145a6fc14e80ba2794fb7e4a", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 35, "deletions": 150, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -8,169 +8,54 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::{llvm, ValueRef, Attribute, Void};\n-use middle::trans::base::*;\n-use middle::trans::build::*;\n-use middle::trans::common::*;\n-\n-use middle::trans::type_::Type;\n-\n-use std::libc::c_uint;\n+use lib::llvm::Attribute;\n use std::option;\n-\n-pub trait ABIInfo {\n-    fn compute_info(&self, atys: &[Type], rty: Type, ret_def: bool) -> FnType;\n-}\n+use middle::trans::context::CrateContext;\n+use middle::trans::cabi_x86;\n+use middle::trans::cabi_x86_64;\n+use middle::trans::cabi_arm;\n+use middle::trans::cabi_mips;\n+use middle::trans::type_::Type;\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n \n #[deriving(Clone)]\n pub struct LLVMType {\n     cast: bool,\n     ty: Type\n }\n \n+/// Metadata describing how the arguments to a native function\n+/// should be passed in order to respect the native ABI.\n+///\n+/// I will do my best to describe this structure, but these\n+/// comments are reverse-engineered and may be inaccurate. -NDM\n pub struct FnType {\n+    /// The LLVM types of each argument. If the cast flag is true,\n+    /// then the argument should be cast, typically because the\n+    /// official argument type will be an int and the rust type is i8\n+    /// or something like that.\n     arg_tys: ~[LLVMType],\n-    ret_ty: LLVMType,\n-    attrs: ~[option::Option<Attribute>],\n-    sret: bool\n-}\n-\n-impl FnType {\n-    pub fn decl_fn(&self, decl: &fn(fnty: Type) -> ValueRef) -> ValueRef {\n-        let atys = self.arg_tys.iter().map(|t| t.ty).collect::<~[Type]>();\n-        let rty = self.ret_ty.ty;\n-        let fnty = Type::func(atys, &rty);\n-        let llfn = decl(fnty);\n-\n-        for (i, a) in self.attrs.iter().enumerate() {\n-            match *a {\n-                option::Some(attr) => {\n-                    unsafe {\n-                        let llarg = get_param(llfn, i);\n-                        llvm::LLVMAddAttribute(llarg, attr as c_uint);\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-        return llfn;\n-    }\n \n-    pub fn build_shim_args(&self, bcx: @mut Block, arg_tys: &[Type], llargbundle: ValueRef)\n-                           -> ~[ValueRef] {\n-        let mut atys: &[LLVMType] = self.arg_tys;\n-        let mut attrs: &[option::Option<Attribute>] = self.attrs;\n-\n-        let mut llargvals = ~[];\n-        let mut i = 0u;\n-        let n = arg_tys.len();\n-\n-        if self.sret {\n-            let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n-            let llretloc = Load(bcx, llretptr);\n-                llargvals = ~[llretloc];\n-                atys = atys.tail();\n-                attrs = attrs.tail();\n-        }\n-\n-        while i < n {\n-            let llargval = if atys[i].cast {\n-                let arg_ptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let arg_ptr = BitCast(bcx, arg_ptr, atys[i].ty.ptr_to());\n-                Load(bcx, arg_ptr)\n-            } else if attrs[i].is_some() {\n-                GEPi(bcx, llargbundle, [0u, i])\n-            } else {\n-                load_inbounds(bcx, llargbundle, [0u, i])\n-            };\n-            llargvals.push(llargval);\n-            i += 1u;\n-        }\n-\n-        return llargvals;\n-    }\n-\n-    pub fn build_shim_ret(&self, bcx: @mut Block, arg_tys: &[Type], ret_def: bool,\n-                          llargbundle: ValueRef, llretval: ValueRef) {\n-        for (i, a) in self.attrs.iter().enumerate() {\n-            match *a {\n-                option::Some(attr) => {\n-                    unsafe {\n-                        llvm::LLVMAddInstrAttribute(llretval, (i + 1u) as c_uint, attr as c_uint);\n-                    }\n-                }\n-                _ => ()\n-            }\n-        }\n-        if self.sret || !ret_def {\n-            return;\n-        }\n-        let n = arg_tys.len();\n-        // R** llretptr = &args->r;\n-        let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n-        // R* llretloc = *llretptr; /* (args->r) */\n-        let llretloc = Load(bcx, llretptr);\n-        if self.ret_ty.cast {\n-            let tmp_ptr = BitCast(bcx, llretloc, self.ret_ty.ty.ptr_to());\n-            // *args->r = r;\n-            Store(bcx, llretval, tmp_ptr);\n-        } else {\n-            // *args->r = r;\n-            Store(bcx, llretval, llretloc);\n-        };\n-    }\n-\n-    pub fn build_wrap_args(&self, bcx: @mut Block, ret_ty: Type,\n-                           llwrapfn: ValueRef, llargbundle: ValueRef) {\n-        let mut atys: &[LLVMType] = self.arg_tys;\n-        let mut attrs: &[option::Option<Attribute>] = self.attrs;\n-        let mut j = 0u;\n-        let llretptr = if self.sret {\n-            atys = atys.tail();\n-            attrs = attrs.tail();\n-            j = 1u;\n-            get_param(llwrapfn, 0u)\n-        } else if self.ret_ty.cast {\n-            let retptr = alloca(bcx, self.ret_ty.ty, \"\");\n-            BitCast(bcx, retptr, ret_ty.ptr_to())\n-        } else {\n-            alloca(bcx, ret_ty, \"\")\n-        };\n+    /// A list of attributes to be attached to each argument (parallel\n+    /// the `arg_tys` array). If the attribute for a given is Some,\n+    /// then the argument should be passed by reference.\n+    attrs: ~[option::Option<Attribute>],\n \n-        let mut i = 0u;\n-        let n = atys.len();\n-        while i < n {\n-            let mut argval = get_param(llwrapfn, i + j);\n-            if attrs[i].is_some() {\n-                argval = Load(bcx, argval);\n-                store_inbounds(bcx, argval, llargbundle, [0u, i]);\n-            } else if atys[i].cast {\n-                let argptr = GEPi(bcx, llargbundle, [0u, i]);\n-                let argptr = BitCast(bcx, argptr, atys[i].ty.ptr_to());\n-                Store(bcx, argval, argptr);\n-            } else {\n-                store_inbounds(bcx, argval, llargbundle, [0u, i]);\n-            }\n-            i += 1u;\n-        }\n-        store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n-    }\n+    /// LLVM return type.\n+    ret_ty: LLVMType,\n \n-    pub fn build_wrap_ret(&self, bcx: @mut Block, arg_tys: &[Type], llargbundle: ValueRef) {\n-        if self.ret_ty.ty.kind() == Void {\n-            return;\n-        }\n+    /// If true, then an implicit pointer should be added for the result.\n+    sret: bool\n+}\n \n-        if bcx.fcx.llretptr.is_some() {\n-            let llretval = load_inbounds(bcx, llargbundle, [ 0, arg_tys.len() ]);\n-            let llretval = if self.ret_ty.cast {\n-                let retptr = BitCast(bcx, llretval, self.ret_ty.ty.ptr_to());\n-                Load(bcx, retptr)\n-            } else {\n-                Load(bcx, llretval)\n-            };\n-            let llretptr = BitCast(bcx, bcx.fcx.llretptr.unwrap(), self.ret_ty.ty.ptr_to());\n-            Store(bcx, llretval, llretptr);\n-        }\n+pub fn compute_abi_info(ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n+    match ccx.sess.targ_cfg.arch {\n+        X86 => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n+        X86_64 => cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def),\n+        Arm => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n+        Mips => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n     }\n }"}, {"sha": "19f0b9b78eb353baa4c4bd3d12ed7bf47ab1017c", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -10,7 +10,8 @@\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::{Attribute, StructRetAttribute};\n-use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n+use middle::trans::cabi::{FnType, LLVMType};\n+use middle::trans::context::CrateContext;\n \n use middle::trans::type_::Type;\n \n@@ -124,45 +125,37 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-enum ARM_ABIInfo { ARM_ABIInfo }\n-\n-impl ABIInfo for ARM_ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[Type],\n-                    rty: Type,\n-                    ret_def: bool) -> FnType {\n-        let mut arg_tys = ~[];\n-        let mut attrs = ~[];\n-        for &aty in atys.iter() {\n-            let (ty, attr) = classify_arg_ty(aty);\n-            arg_tys.push(ty);\n-            attrs.push(attr);\n-        }\n-\n-        let (ret_ty, ret_attr) = if ret_def {\n-            classify_ret_ty(rty)\n-        } else {\n-            (LLVMType { cast: false, ty: Type::void() }, None)\n-        };\n+pub fn compute_abi_info(_ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n+    let mut arg_tys = ~[];\n+    let mut attrs = ~[];\n+    for &aty in atys.iter() {\n+        let (ty, attr) = classify_arg_ty(aty);\n+        arg_tys.push(ty);\n+        attrs.push(attr);\n+    }\n \n-        let mut ret_ty = ret_ty;\n+    let (ret_ty, ret_attr) = if ret_def {\n+        classify_ret_ty(rty)\n+    } else {\n+        (LLVMType { cast: false, ty: Type::void() }, None)\n+    };\n \n-        let sret = ret_attr.is_some();\n-        if sret {\n-            arg_tys.unshift(ret_ty);\n-            attrs.unshift(ret_attr);\n-            ret_ty = LLVMType { cast: false, ty: Type::void() };\n-        }\n+    let mut ret_ty = ret_ty;\n \n-        return FnType {\n-            arg_tys: arg_tys,\n-            ret_ty: ret_ty,\n-            attrs: attrs,\n-            sret: sret\n-        };\n+    let sret = ret_attr.is_some();\n+    if sret {\n+        arg_tys.unshift(ret_ty);\n+        attrs.unshift(ret_attr);\n+        ret_ty = LLVMType { cast: false, ty: Type::void() };\n     }\n-}\n \n-pub fn abi_info() -> @ABIInfo {\n-    return @ARM_ABIInfo as @ABIInfo;\n+    return FnType {\n+        arg_tys: arg_tys,\n+        ret_ty: ret_ty,\n+        attrs: attrs,\n+        sret: sret\n+    };\n }"}, {"sha": "4577bf11b84de8b7a5c5b78efb22b3d5e7c9ca33", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -14,6 +14,7 @@ use std::num;\n use std::vec;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::{Attribute, StructRetAttribute};\n+use middle::trans::context::CrateContext;\n use middle::trans::context::task_llcx;\n use middle::trans::cabi::*;\n \n@@ -170,47 +171,39 @@ fn struct_ty(ty: Type,\n     return Type::struct_(fields, false);\n }\n \n-enum MIPS_ABIInfo { MIPS_ABIInfo }\n-\n-impl ABIInfo for MIPS_ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[Type],\n-                    rty: Type,\n-                    ret_def: bool) -> FnType {\n-        let (ret_ty, ret_attr) = if ret_def {\n-            classify_ret_ty(rty)\n-        } else {\n-            (LLVMType { cast: false, ty: Type::void() }, None)\n-        };\n-\n-        let mut ret_ty = ret_ty;\n-\n-        let sret = ret_attr.is_some();\n-        let mut arg_tys = ~[];\n-        let mut attrs = ~[];\n-        let mut offset = if sret { 4 } else { 0 };\n-\n-        for aty in atys.iter() {\n-            let (ty, attr) = classify_arg_ty(*aty, &mut offset);\n-            arg_tys.push(ty);\n-            attrs.push(attr);\n-        };\n-\n-        if sret {\n-            arg_tys = vec::append(~[ret_ty], arg_tys);\n-            attrs = vec::append(~[ret_attr], attrs);\n-            ret_ty = LLVMType { cast: false, ty: Type::void() };\n-        }\n+pub fn compute_abi_info(_ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n+    let (ret_ty, ret_attr) = if ret_def {\n+        classify_ret_ty(rty)\n+    } else {\n+        (LLVMType { cast: false, ty: Type::void() }, None)\n+    };\n+\n+    let mut ret_ty = ret_ty;\n+\n+    let sret = ret_attr.is_some();\n+    let mut arg_tys = ~[];\n+    let mut attrs = ~[];\n+    let mut offset = if sret { 4 } else { 0 };\n \n-        return FnType {\n-            arg_tys: arg_tys,\n-            ret_ty: ret_ty,\n-            attrs: attrs,\n-            sret: sret\n-        };\n+    for aty in atys.iter() {\n+        let (ty, attr) = classify_arg_ty(*aty, &mut offset);\n+        arg_tys.push(ty);\n+        attrs.push(attr);\n+    };\n+\n+    if sret {\n+        arg_tys = vec::append(~[ret_ty], arg_tys);\n+        attrs = vec::append(~[ret_attr], attrs);\n+        ret_ty = LLVMType { cast: false, ty: Type::void() };\n     }\n-}\n \n-pub fn abi_info() -> @ABIInfo {\n-    return @MIPS_ABIInfo as @ABIInfo;\n+    return FnType {\n+        arg_tys: arg_tys,\n+        ret_ty: ret_ty,\n+        attrs: attrs,\n+        sret: sret\n+    };\n }"}, {"sha": "f0af31e795af239c218bcc3c350bf09715939df6", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 70, "deletions": 53, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -14,70 +14,87 @@ use lib::llvm::*;\n use super::cabi::*;\n use super::common::*;\n use super::machine::*;\n-\n use middle::trans::type_::Type;\n \n-struct X86_ABIInfo {\n-    ccx: @mut CrateContext\n-}\n+pub fn compute_abi_info(ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n+    let mut arg_tys = ~[];\n+    let mut attrs = ~[];\n \n-impl ABIInfo for X86_ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[Type],\n-                    rty: Type,\n-                    ret_def: bool) -> FnType {\n-        let mut arg_tys = do atys.map |a| {\n-            LLVMType { cast: false, ty: *a }\n-        };\n-        let mut ret_ty = LLVMType {\n+    let ret_ty;\n+    let sret;\n+    if !ret_def {\n+        ret_ty = LLVMType {\n             cast: false,\n-            ty: rty\n+            ty: Type::void(),\n         };\n-        let mut attrs = do atys.map |_| {\n-            None\n-        };\n-\n-        // Rules for returning structs taken from\n+        sret = false;\n+    } else if rty.kind() == Struct {\n+        // Returning a structure. Most often, this will use\n+        // a hidden first argument. On some platforms, though,\n+        // small structs are returned as integers.\n+        //\n+        // Some links:\n         // http://www.angelcode.com/dev/callconv/callconv.html\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-        let sret = {\n-            let returning_a_struct = rty.kind() == Struct && ret_def;\n-            let big_struct = match self.ccx.sess.targ_cfg.os {\n-                os_win32 | os_macos => llsize_of_alloc(self.ccx, rty) > 8,\n-                _ => true\n-            };\n-            returning_a_struct && big_struct\n+\n+        enum Strategy { RetValue(Type), RetPointer }\n+        let strategy = match ccx.sess.targ_cfg.os {\n+            os_win32 | os_macos => {\n+                match llsize_of_alloc(ccx, rty) {\n+                    1 => RetValue(Type::i8()),\n+                    2 => RetValue(Type::i16()),\n+                    4 => RetValue(Type::i32()),\n+                    8 => RetValue(Type::i64()),\n+                    _ => RetPointer\n+                }\n+            }\n+            _ => {\n+                RetPointer\n+            }\n         };\n \n-        if sret {\n-            let ret_ptr_ty = LLVMType {\n-                cast: false,\n-                ty: ret_ty.ty.ptr_to()\n-            };\n-            arg_tys = ~[ret_ptr_ty] + arg_tys;\n-            attrs = ~[Some(StructRetAttribute)] + attrs;\n-            ret_ty = LLVMType {\n-                cast: false,\n-                ty: Type::void(),\n-            };\n-        } else if !ret_def {\n-            ret_ty = LLVMType {\n-                cast: false,\n-                ty: Type::void()\n-            };\n-        }\n+        match strategy {\n+            RetValue(t) => {\n+                ret_ty = LLVMType {\n+                    cast: true,\n+                    ty: t\n+                };\n+                sret = false;\n+            }\n+            RetPointer => {\n+                arg_tys.push(LLVMType {\n+                    cast: false,\n+                    ty: rty.ptr_to()\n+                });\n+                attrs.push(Some(StructRetAttribute));\n \n-        return FnType {\n-            arg_tys: arg_tys,\n-            ret_ty: ret_ty,\n-            attrs: attrs,\n-            sret: sret\n+                ret_ty = LLVMType {\n+                    cast: false,\n+                    ty: Type::void(),\n+                };\n+                sret = true;\n+            }\n+        }\n+    } else {\n+        ret_ty = LLVMType {\n+            cast: false,\n+            ty: rty\n         };\n+        sret = false;\n+    }\n+\n+    for &a in atys.iter() {\n+        arg_tys.push(LLVMType { cast: false, ty: a });\n+        attrs.push(None);\n     }\n-}\n \n-pub fn abi_info(ccx: @mut CrateContext) -> @ABIInfo {\n-    return @X86_ABIInfo {\n-        ccx: ccx\n-    } as @ABIInfo;\n+    return FnType {\n+        arg_tys: arg_tys,\n+        ret_ty: ret_ty,\n+        attrs: attrs,\n+        sret: sret\n+    };\n }"}, {"sha": "179366878418f0a879d0481a7454925480c613c5", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -15,6 +15,7 @@ use lib::llvm::{llvm, Integer, Pointer, Float, Double};\n use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n use middle::trans::cabi::*;\n+use middle::trans::context::CrateContext;\n \n use middle::trans::type_::Type;\n \n@@ -331,10 +332,10 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n     return Type::struct_(tys, false);\n }\n \n-fn x86_64_tys(atys: &[Type],\n-              rty: Type,\n-              ret_def: bool) -> FnType {\n-\n+pub fn compute_abi_info(_ccx: &mut CrateContext,\n+                        atys: &[Type],\n+                        rty: Type,\n+                        ret_def: bool) -> FnType {\n     fn x86_64_ty(ty: Type,\n                  is_mem_cls: &fn(cls: &[RegClass]) -> bool,\n                  attr: Attribute) -> (LLVMType, Option<Attribute>) {\n@@ -384,18 +385,3 @@ fn x86_64_tys(atys: &[Type],\n         sret: sret\n     };\n }\n-\n-enum X86_64_ABIInfo { X86_64_ABIInfo }\n-\n-impl ABIInfo for X86_64_ABIInfo {\n-    fn compute_info(&self,\n-                    atys: &[Type],\n-                    rty: Type,\n-                    ret_def: bool) -> FnType {\n-        return x86_64_tys(atys, rty, ret_def);\n-    }\n-}\n-\n-pub fn abi_info() -> @ABIInfo {\n-    return @X86_64_ABIInfo as @ABIInfo;\n-}"}, {"sha": "c4720f5cb35b144e156782518af4286301566783", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 151, "deletions": 83, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -37,6 +37,7 @@ use middle::trans::inline;\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::type_of;\n+use middle::trans::foreign;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n@@ -46,6 +47,7 @@ use util::ppaux::Repr;\n use middle::trans::type_::Type;\n \n use syntax::ast;\n+use syntax::abi::AbiSet;\n use syntax::ast_map;\n use syntax::oldvisit;\n \n@@ -240,20 +242,20 @@ pub fn trans_fn_ref_with_vtables(\n         type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>) // vtables for the call\n      -> FnData {\n-    //!\n-    //\n-    // Translates a reference to a fn/method item, monomorphizing and\n-    // inlining as it goes.\n-    //\n-    // # Parameters\n-    //\n-    // - `bcx`: the current block where the reference to the fn occurs\n-    // - `def_id`: def id of the fn or method item being referenced\n-    // - `ref_id`: node id of the reference to the fn/method, if applicable.\n-    //   This parameter may be zero; but, if so, the resulting value may not\n-    //   have the right type, so it must be cast before being used.\n-    // - `type_params`: values for each of the fn/method's type parameters\n-    // - `vtables`: values for each bound on each of the type parameters\n+    /*!\n+     * Translates a reference to a fn/method item, monomorphizing and\n+     * inlining as it goes.\n+     *\n+     * # Parameters\n+     *\n+     * - `bcx`: the current block where the reference to the fn occurs\n+     * - `def_id`: def id of the fn or method item being referenced\n+     * - `ref_id`: node id of the reference to the fn/method, if applicable.\n+     *   This parameter may be zero; but, if so, the resulting value may not\n+     *   have the right type, so it must be cast before being used.\n+     * - `type_params`: values for each of the fn/method's type parameters\n+     * - `vtables`: values for each bound on each of the type parameters\n+     */\n \n     let _icx = push_ctxt(\"trans_fn_ref_with_vtables\");\n     let ccx = bcx.ccx();\n@@ -386,7 +388,7 @@ pub fn trans_fn_ref_with_vtables(\n     }\n \n     // Find the actual function pointer.\n-    let val = {\n+    let mut val = {\n         if def_id.crate == ast::LOCAL_CRATE {\n             // Internal reference.\n             get_item_val(ccx, def_id.node)\n@@ -396,6 +398,35 @@ pub fn trans_fn_ref_with_vtables(\n         }\n     };\n \n+    // This is subtle and surprising, but sometimes we have to bitcast\n+    // the resulting fn pointer.  The reason has to do with external\n+    // functions.  If you have two crates that both bind the same C\n+    // library, they may not use precisely the same types: for\n+    // example, they will probably each declare their own structs,\n+    // which are distinct types from LLVM's point of view (nominal\n+    // types).\n+    //\n+    // Now, if those two crates are linked into an application, and\n+    // they contain inlined code, you can wind up with a situation\n+    // where both of those functions wind up being loaded into this\n+    // application simultaneously. In that case, the same function\n+    // (from LLVM's point of view) requires two types. But of course\n+    // LLVM won't allow one function to have two types.\n+    //\n+    // What we currently do, therefore, is declare the function with\n+    // one of the two types (whichever happens to come first) and then\n+    // bitcast as needed when the function is referenced to make sure\n+    // it has the type we expect.\n+    //\n+    // This can occur on either a crate-local or crate-external\n+    // reference. It also occurs when testing libcore and in some\n+    // other weird situations. Annoying.\n+    let llty = type_of::type_of_fn_from_ty(ccx, fn_tpt.ty);\n+    let llptrty = llty.ptr_to();\n+    if val_ty(val) != llptrty {\n+        val = BitCast(bcx, val, llptrty);\n+    }\n+\n     return FnData {llfn: val};\n }\n \n@@ -543,16 +574,26 @@ pub fn body_contains_ret(body: &ast::Block) -> bool {\n     *cx\n }\n \n-// See [Note-arg-mode]\n pub fn trans_call_inner(in_cx: @mut Block,\n                         call_info: Option<NodeInfo>,\n-                        fn_expr_ty: ty::t,\n+                        callee_ty: ty::t,\n                         ret_ty: ty::t,\n                         get_callee: &fn(@mut Block) -> Callee,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)\n                         -> Result {\n+    /*!\n+     * This behemoth of a function translates function calls.\n+     * Unfortunately, in order to generate more efficient LLVM\n+     * output at -O0, it has quite a complex signature (refactoring\n+     * this into two functions seems like a good idea).\n+     *\n+     * In particular, for lang items, it is invoked with a dest of\n+     * None, and\n+     */\n+\n+\n     do base::with_scope_result(in_cx, call_info, \"call\") |cx| {\n         let callee = get_callee(cx);\n         let mut bcx = callee.bcx;\n@@ -580,98 +621,125 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             }\n         };\n \n-        let llretslot = trans_ret_slot(bcx, fn_expr_ty, dest);\n+        let abi = match ty::get(callee_ty).sty {\n+            ty::ty_bare_fn(ref f) => f.abis,\n+            _ => AbiSet::Rust()\n+        };\n+        let is_rust_fn =\n+            abi.is_rust() ||\n+            abi.is_intrinsic();\n+\n+        // Generate a location to store the result. If the user does\n+        // not care about the result, just make a stack slot.\n+        let opt_llretslot = match dest {\n+            None => {\n+                assert!(!type_of::return_uses_outptr(in_cx.tcx(), ret_ty));\n+                None\n+            }\n+            Some(expr::SaveIn(dst)) => Some(dst),\n+            Some(expr::Ignore) => {\n+                if !ty::type_is_voidish(ret_ty) {\n+                    Some(alloc_ty(bcx, ret_ty, \"__llret\"))\n+                } else {\n+                    unsafe {\n+                        Some(llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()))\n+                    }\n+                }\n+            }\n+        };\n \n-        let mut llargs = ~[];\n+        let mut llresult = unsafe {\n+            llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n+        };\n \n-        if !ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-            llargs.push(llretslot);\n-        }\n+        // The code below invokes the function, using either the Rust\n+        // conventions (if it is a rust fn) or the native conventions\n+        // (otherwise).  The important part is that, when all is sad\n+        // and done, either the return value of the function will have been\n+        // written in opt_llretslot (if it is Some) or `llresult` will be\n+        // set appropriately (otherwise).\n+        if is_rust_fn {\n+            let mut llargs = ~[];\n+\n+            // Push the out-pointer if we use an out-pointer for this\n+            // return type, otherwise push \"undef\".\n+            if type_of::return_uses_outptr(in_cx.tcx(), ret_ty) {\n+                llargs.push(opt_llretslot.unwrap());\n+            }\n+\n+            // Push the environment.\n+            llargs.push(llenv);\n \n-        llargs.push(llenv);\n-        bcx = trans_args(bcx, args, fn_expr_ty, autoref_arg, &mut llargs);\n+            // Push the arguments.\n+            bcx = trans_args(bcx, args, callee_ty,\n+                             autoref_arg, &mut llargs);\n \n-        // Now that the arguments have finished evaluating, we need to revoke\n-        // the cleanup for the self argument\n-        match callee.data {\n-            Method(d) => {\n-                for &v in d.temp_cleanup.iter() {\n-                    revoke_clean(bcx, v);\n+            // Now that the arguments have finished evaluating, we\n+            // need to revoke the cleanup for the self argument\n+            match callee.data {\n+                Method(d) => {\n+                    for &v in d.temp_cleanup.iter() {\n+                        revoke_clean(bcx, v);\n+                    }\n                 }\n+                _ => {}\n             }\n-            _ => {}\n-        }\n \n-        // Uncomment this to debug calls.\n-        /*\n-        printfln!(\"calling: %s\", bcx.val_to_str(llfn));\n-        for llarg in llargs.iter() {\n-            printfln!(\"arg: %s\", bcx.val_to_str(*llarg));\n+            // Invoke the actual rust fn and update bcx/llresult.\n+            let (llret, b) = base::invoke(bcx, llfn, llargs);\n+            bcx = b;\n+            llresult = llret;\n+\n+            // If the Rust convention for this type is return via\n+            // the return value, copy it into llretslot.\n+            match opt_llretslot {\n+                Some(llretslot) => {\n+                    if !type_of::return_uses_outptr(bcx.tcx(), ret_ty) &&\n+                        !ty::type_is_voidish(ret_ty)\n+                    {\n+                        Store(bcx, llret, llretslot);\n+                    }\n+                }\n+                None => {}\n+            }\n+        } else {\n+            // Lang items are the only case where dest is None, and\n+            // they are always Rust fns.\n+            assert!(dest.is_some());\n+\n+            let mut llargs = ~[];\n+            bcx = trans_args(bcx, args, callee_ty,\n+                             autoref_arg, &mut llargs);\n+            bcx = foreign::trans_native_call(bcx, callee_ty,\n+                                             llfn, opt_llretslot.unwrap(), llargs);\n         }\n-        io::println(\"---\");\n-        */\n-\n-        // If the block is terminated, then one or more of the args\n-        // has type _|_. Since that means it diverges, the code for\n-        // the call itself is unreachable.\n-        let (llresult, new_bcx) = base::invoke(bcx, llfn, llargs);\n-        bcx = new_bcx;\n \n+        // If the caller doesn't care about the result of this fn call,\n+        // drop the temporary slot we made.\n         match dest {\n-            None => { assert!(ty::type_is_immediate(bcx.tcx(), ret_ty)) }\n+            None => {\n+                assert!(!type_of::return_uses_outptr(bcx.tcx(), ret_ty));\n+            }\n             Some(expr::Ignore) => {\n                 // drop the value if it is not being saved.\n-                if ty::type_needs_drop(bcx.tcx(), ret_ty) {\n-                    if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-                        let llscratchptr = alloc_ty(bcx, ret_ty, \"__ret\");\n-                        Store(bcx, llresult, llscratchptr);\n-                        bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n-                    } else {\n-                        bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n-                    }\n-                }\n-            }\n-            Some(expr::SaveIn(lldest)) => {\n-                // If this is an immediate, store into the result location.\n-                // (If this was not an immediate, the result will already be\n-                // directly written into the output slot.)\n-                if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-                    Store(bcx, llresult, lldest);\n-                }\n+                bcx = glue::drop_ty(bcx, opt_llretslot.unwrap(), ret_ty);\n             }\n+            Some(expr::SaveIn(_)) => { }\n         }\n \n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         }\n+\n         rslt(bcx, llresult)\n     }\n }\n \n-\n pub enum CallArgs<'self> {\n     ArgExprs(&'self [@ast::expr]),\n     ArgVals(&'self [ValueRef])\n }\n \n-pub fn trans_ret_slot(bcx: @mut Block, fn_ty: ty::t, dest: Option<expr::Dest>)\n-                      -> ValueRef {\n-    let retty = ty::ty_fn_ret(fn_ty);\n-\n-    match dest {\n-        Some(expr::SaveIn(dst)) => dst,\n-        _ => {\n-            if ty::type_is_immediate(bcx.tcx(), retty) {\n-                unsafe {\n-                    llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n-                }\n-            } else {\n-                alloc_ty(bcx, retty, \"__trans_ret_slot\")\n-            }\n-        }\n-    }\n-}\n-\n pub fn trans_args(cx: @mut Block,\n                   args: CallArgs,\n                   fn_ty: ty::t,\n@@ -795,7 +863,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n \n         if formal_arg_ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n-            let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, &formal_arg_ty);\n+            let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, formal_arg_ty);\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n                    bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);"}, {"sha": "027696d37f128746950816a78c19672537731df1", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -121,7 +121,7 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = HashMap<@str, ValueRef>;\n+pub type ExternMap = HashMap<~str, ValueRef>;\n \n // Types used for llself.\n pub struct ValSelfData {\n@@ -197,10 +197,10 @@ pub struct FunctionContext {\n     // outputting the resume instruction.\n     personality: Option<ValueRef>,\n \n-    // True if this function has an immediate return value, false otherwise.\n-    // If this is false, the llretptr will alias the first argument of the\n-    // function.\n-    has_immediate_return_value: bool,\n+    // True if the caller expects this fn to use the out pointer to\n+    // return. Either way, your code should write into llretptr, but if\n+    // this value is false, llretptr will be a local alloca.\n+    caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n     llargs: @mut HashMap<ast::NodeId, ValueRef>,\n@@ -232,20 +232,20 @@ pub struct FunctionContext {\n \n impl FunctionContext {\n     pub fn arg_pos(&self, arg: uint) -> uint {\n-        if self.has_immediate_return_value {\n-            arg + 1u\n-        } else {\n+        if self.caller_expects_out_pointer {\n             arg + 2u\n+        } else {\n+            arg + 1u\n         }\n     }\n \n     pub fn out_arg_pos(&self) -> uint {\n-        assert!(!self.has_immediate_return_value);\n+        assert!(self.caller_expects_out_pointer);\n         0u\n     }\n \n     pub fn env_arg_pos(&self) -> uint {\n-        if !self.has_immediate_return_value {\n+        if self.caller_expects_out_pointer {\n             1u\n         } else {\n             0u"}, {"sha": "1060a06a5cfa9d5a6b9a1511c7df0a65ab8ce014", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -190,12 +190,12 @@ pub fn scratch_datum(bcx: @mut Block, ty: ty::t, name: &str, zero: bool) -> Datu\n \n pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n     /*!\n-    *\n-    * Indicates the \"appropriate\" mode for this value,\n-    * which is either by ref or by value, depending\n-    * on whether type is immediate or not. */\n+     * Indicates the \"appropriate\" mode for this value,\n+     * which is either by ref or by value, depending\n+     * on whether type is immediate or not.\n+     */\n \n-    if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+    if ty::type_is_voidish(ty) {\n         ByValue\n     } else if ty::type_is_immediate(tcx, ty) {\n         ByValue\n@@ -271,7 +271,7 @@ impl Datum {\n \n         let _icx = push_ctxt(\"copy_to\");\n \n-        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+        if ty::type_is_voidish(self.ty) {\n             return bcx;\n         }\n \n@@ -343,7 +343,7 @@ impl Datum {\n         debug!(\"move_to(self=%s, action=%?, dst=%s)\",\n                self.to_str(bcx.ccx()), action, bcx.val_to_str(dst));\n \n-        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+        if ty::type_is_voidish(self.ty) {\n             return bcx;\n         }\n \n@@ -432,7 +432,7 @@ impl Datum {\n          *\n          * Yields the value itself. */\n \n-        if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+        if ty::type_is_voidish(self.ty) {\n             C_nil()\n         } else {\n             match self.mode {\n@@ -469,7 +469,7 @@ impl Datum {\n         match self.mode {\n             ByRef(_) => self.val,\n             ByValue => {\n-                if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n+                if ty::type_is_voidish(self.ty) {\n                     C_null(type_of::type_of(bcx.ccx(), self.ty).ptr_to())\n                 } else {\n                     let slot = alloc_ty(bcx, self.ty, \"\");"}, {"sha": "2ce8756848fa818b710307d5ece1e98a99d3cd3a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -290,7 +290,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n         assert_eq!(datum.appropriate_mode(tcx), ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n-        Store(bcx, base::null_env_ptr(bcx), llenv);\n+        Store(bcx, base::null_env_ptr(bcx.ccx()), llenv);\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n@@ -416,7 +416,7 @@ pub fn trans_into(bcx: @mut Block, expr: @ast::expr, dest: Dest) -> @mut Block {\n     debuginfo::update_source_pos(bcx.fcx, expr.id, expr.span);\n \n     let dest = {\n-        if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+        if ty::type_is_voidish(ty) {\n             Ignore\n         } else {\n             dest\n@@ -507,7 +507,7 @@ fn trans_to_datum_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n \n         ty::RvalueDpsExpr => {\n             let ty = expr_ty(bcx, expr);\n-            if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+            if ty::type_is_voidish(ty) {\n                 bcx = trans_rvalue_dps_unadjusted(bcx, expr, Ignore);\n                 return nil(bcx, ty);\n             } else {"}, {"sha": "5586f1183ef87257539f97f63d1f9ec98f0489cc", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 614, "deletions": 1085, "changes": 1699, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -9,1206 +9,735 @@\n // except according to those terms.\n \n \n-use back::{link, abi};\n-use lib::llvm::{Pointer, ValueRef};\n+use back::{link};\n+use std::libc::c_uint;\n+use lib::llvm::{ValueRef, Attribute, CallConv};\n+use lib::llvm::llvm;\n use lib;\n-use middle::trans::base::*;\n+use middle::trans::machine;\n+use middle::trans::base;\n+use middle::trans::base::push_ctxt;\n use middle::trans::cabi;\n-use middle::trans::cabi_x86;\n-use middle::trans::cabi_x86_64;\n-use middle::trans::cabi_arm;\n-use middle::trans::cabi_mips;\n use middle::trans::build::*;\n-use middle::trans::callee::*;\n+use middle::trans::builder::noname;\n use middle::trans::common::*;\n-use middle::trans::datum::*;\n-use middle::trans::expr::Ignore;\n-use middle::trans::machine::llsize_of;\n-use middle::trans::glue;\n-use middle::trans::machine;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n use middle::ty;\n use middle::ty::FnSig;\n-use util::ppaux::ty_to_str;\n \n-use std::cell::Cell;\n+use std::uint;\n use std::vec;\n use syntax::codemap::span;\n-use syntax::{ast, ast_util};\n+use syntax::{ast};\n use syntax::{attr, ast_map};\n-use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n-use syntax::parse::token;\n-use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n-                  Cdecl, Aapcs, C};\n+                  Cdecl, Aapcs, C, AbiSet};\n+use util::ppaux::{Repr, UserString};\n use middle::trans::type_::Type;\n \n-fn abi_info(ccx: @mut CrateContext) -> @cabi::ABIInfo {\n-    return match ccx.sess.targ_cfg.arch {\n-        X86 => cabi_x86::abi_info(ccx),\n-        X86_64 => cabi_x86_64::abi_info(),\n-        Arm => cabi_arm::abi_info(),\n-        Mips => cabi_mips::abi_info(),\n-    }\n-}\n-\n-pub fn link_name(ccx: &CrateContext, i: &ast::foreign_item) -> @str {\n-     match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n-        None => ccx.sess.str_of(i.ident),\n-        Some(ln) => ln,\n-    }\n-}\n+///////////////////////////////////////////////////////////////////////////\n+// Type definitions\n \n-struct ShimTypes {\n+struct ForeignTypes {\n+    /// Rust signature of the function\n     fn_sig: ty::FnSig,\n \n+    /// Adapter object for handling native ABI rules (trust me, you\n+    /// don't want to know)\n+    fn_ty: cabi::FnType,\n+\n     /// LLVM types that will appear on the foreign function\n     llsig: LlvmSignature,\n \n     /// True if there is a return value (not bottom, not unit)\n     ret_def: bool,\n-\n-    /// Type of the struct we will use to shuttle values back and forth.\n-    /// This is always derived from the llsig.\n-    bundle_ty: Type,\n-\n-    /// Type of the shim function itself.\n-    shim_fn_ty: Type,\n-\n-    /// Adapter object for handling native ABI rules (trust me, you\n-    /// don't want to know).\n-    fn_ty: cabi::FnType\n }\n \n struct LlvmSignature {\n+    // LLVM versions of the types of this function's arguments.\n     llarg_tys: ~[Type],\n-    llret_ty: Type,\n-    sret: bool,\n-}\n \n-fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n-                     -> LlvmSignature {\n-    /*!\n-     * The ForeignSignature is the LLVM types of the arguments/return type\n-     * of a function.  Note that these LLVM types are not quite the same\n-     * as the LLVM types would be for a native Rust function because foreign\n-     * functions just plain ignore modes.  They also don't pass aggregate\n-     * values by pointer like we do.\n-     */\n+    // LLVM version of the type that this function returns.  Note that\n+    // this *may not be* the declared return type of the foreign\n+    // function, because the foreign function may opt to return via an\n+    // out pointer.\n+    llret_ty: Type,\n \n-    let llarg_tys = fn_sig.inputs.map(|arg_ty| type_of(ccx, *arg_ty));\n-    let llret_ty = type_of::type_of(ccx, fn_sig.output);\n-    LlvmSignature {\n-        llarg_tys: llarg_tys,\n-        llret_ty: llret_ty,\n-        sret: !ty::type_is_immediate(ccx.tcx, fn_sig.output),\n-    }\n+    // True if *Rust* would use an outpointer for this function.\n+    sret: bool,\n }\n \n-fn shim_types(ccx: @mut CrateContext, id: ast::NodeId) -> ShimTypes {\n-    let fn_sig = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n-        ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n-        _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n-    };\n-    let llsig = foreign_signature(ccx, &fn_sig);\n-    let bundle_ty = Type::struct_(llsig.llarg_tys + &[llsig.llret_ty.ptr_to()], false);\n-    let ret_def = !ty::type_is_bot(fn_sig.output) &&\n-                  !ty::type_is_nil(fn_sig.output);\n-    let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys, llsig.llret_ty, ret_def);\n-    ShimTypes {\n-        fn_sig: fn_sig,\n-        llsig: llsig,\n-        ret_def: ret_def,\n-        bundle_ty: bundle_ty,\n-        shim_fn_ty: Type::func([bundle_ty.ptr_to()], &Type::void()),\n-        fn_ty: fn_ty\n-    }\n-}\n \n-type shim_arg_builder<'self> =\n-    &'self fn(bcx: @mut Block, tys: &ShimTypes,\n-              llargbundle: ValueRef) -> ~[ValueRef];\n-\n-type shim_ret_builder<'self> =\n-    &'self fn(bcx: @mut Block, tys: &ShimTypes,\n-              llargbundle: ValueRef,\n-              llretval: ValueRef);\n-\n-fn build_shim_fn_(ccx: @mut CrateContext,\n-                  shim_name: &str,\n-                  llbasefn: ValueRef,\n-                  tys: &ShimTypes,\n-                  cc: lib::llvm::CallConv,\n-                  arg_builder: shim_arg_builder,\n-                  ret_builder: shim_ret_builder)\n-               -> ValueRef {\n-    let llshimfn = decl_internal_cdecl_fn(\n-        ccx.llmod, shim_name, tys.shim_fn_ty);\n-\n-    // Declare the body of the shim function:\n-    let fcx = new_fn_ctxt(ccx, ~[], llshimfn, tys.fn_sig.output, None);\n-    let bcx = fcx.entry_bcx.unwrap();\n-\n-    let llargbundle = get_param(llshimfn, 0u);\n-    let llargvals = arg_builder(bcx, tys, llargbundle);\n-\n-    // Create the call itself and store the return value:\n-    let llretval = CallWithConv(bcx, llbasefn, llargvals, cc);\n-\n-    ret_builder(bcx, tys, llargbundle, llretval);\n-\n-    // Don't finish up the function in the usual way, because this doesn't\n-    // follow the normal Rust calling conventions.\n-    let ret_cx = match fcx.llreturn {\n-        Some(llreturn) => raw_block(fcx, false, llreturn),\n-        None => bcx\n-    };\n-    RetVoid(ret_cx);\n-    fcx.cleanup();\n+///////////////////////////////////////////////////////////////////////////\n+// Calls to external functions\n \n-    return llshimfn;\n-}\n+fn llvm_calling_convention(ccx: @mut CrateContext,\n+                           abis: AbiSet)\n+                           -> Option<CallConv> {\n+    let arch = ccx.sess.targ_cfg.arch;\n+    abis.for_arch(arch).map(|abi| {\n+        match *abi {\n+            RustIntrinsic => {\n+                // Intrinsics are emitted by monomorphic fn\n+                ccx.sess.bug(fmt!(\"Asked to register intrinsic fn\"));\n+            }\n \n-type wrap_arg_builder<'self> = &'self fn(bcx: @mut Block,\n-                                         tys: &ShimTypes,\n-                                         llwrapfn: ValueRef,\n-                                         llargbundle: ValueRef);\n-\n-type wrap_ret_builder<'self> = &'self fn(bcx: @mut Block,\n-                                         tys: &ShimTypes,\n-                                         llargbundle: ValueRef);\n-\n-fn build_wrap_fn_(ccx: @mut CrateContext,\n-                  tys: &ShimTypes,\n-                  llshimfn: ValueRef,\n-                  llwrapfn: ValueRef,\n-                  shim_upcall: ValueRef,\n-                  needs_c_return: bool,\n-                  arg_builder: wrap_arg_builder,\n-                  ret_builder: wrap_ret_builder) {\n-    let _icx = push_ctxt(\"foreign::build_wrap_fn_\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n-    let bcx = fcx.entry_bcx.unwrap();\n-\n-    // Patch up the return type if it's not immediate and we're returning via\n-    // the C ABI.\n-    if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n-        let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n-        fcx.llretptr = Some(alloca(bcx, lloutputtype, \"\"));\n-    }\n+            Rust => {\n+                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n+                ccx.sess.unimpl(\n+                    fmt!(\"Foreign functions with Rust ABI\"));\n+            }\n \n-    // Allocate the struct and write the arguments into it.\n-    let llargbundle = alloca(bcx, tys.bundle_ty, \"__llargbundle\");\n-    arg_builder(bcx, tys, llwrapfn, llargbundle);\n+            Stdcall => lib::llvm::X86StdcallCallConv,\n+            Fastcall => lib::llvm::X86FastcallCallConv,\n+            C => lib::llvm::CCallConv,\n \n-    // Create call itself.\n-    let llshimfnptr = PointerCast(bcx, llshimfn, Type::i8p());\n-    let llrawargbundle = PointerCast(bcx, llargbundle, Type::i8p());\n-    Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n-    ret_builder(bcx, tys, llargbundle);\n+            // NOTE These API constants ought to be more specific\n+            Cdecl => lib::llvm::CCallConv,\n+            Aapcs => lib::llvm::CCallConv,\n+        }\n+    })\n+}\n \n-    // Then return according to the C ABI.\n-    let return_context = match fcx.llreturn {\n-        Some(llreturn) => raw_block(fcx, false, llreturn),\n-        None => bcx\n-    };\n \n-    let llfunctiontype = val_ty(llwrapfn);\n-    let llfunctiontype = llfunctiontype.element_type();\n-    let return_type = llfunctiontype.return_type();\n-    if return_type.kind() == ::lib::llvm::Void {\n-        // XXX: This might be wrong if there are any functions for which\n-        // the C ABI specifies a void output pointer and the Rust ABI\n-        // does not.\n-        RetVoid(return_context);\n-    } else {\n-        // Cast if we have to...\n-        // XXX: This is ugly.\n-        let llretptr = BitCast(return_context, fcx.llretptr.unwrap(), return_type.ptr_to());\n-        Ret(return_context, Load(return_context, llretptr));\n-    }\n-    fcx.cleanup();\n-}\n+pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n+                                abis: AbiSet,\n+                                path: &ast_map::path,\n+                                foreign_item: @ast::foreign_item) -> ValueRef {\n+    /*!\n+     * Registers a foreign function found in a library.\n+     * Just adds a LLVM global.\n+     */\n \n-// For each foreign function F, we generate a wrapper function W and a shim\n-// function S that all work together.  The wrapper function W is the function\n-// that other rust code actually invokes.  Its job is to marshall the\n-// arguments into a struct.  It then uses a small bit of assembly to switch\n-// over to the C stack and invoke the shim function.  The shim function S then\n-// unpacks the arguments from the struct and invokes the actual function F\n-// according to its specified calling convention.\n-//\n-// Example: Given a foreign c-stack function F(x: X, y: Y) -> Z,\n-// we generate a wrapper function W that looks like:\n-//\n-//    void W(Z* dest, void *env, X x, Y y) {\n-//        struct { X x; Y y; Z *z; } args = { x, y, z };\n-//        call_on_c_stack_shim(S, &args);\n-//    }\n-//\n-// The shim function S then looks something like:\n-//\n-//     void S(struct { X x; Y y; Z *z; } *args) {\n-//         *args->z = F(args->x, args->y);\n-//     }\n-//\n-// However, if the return type of F is dynamically sized or of aggregate type,\n-// the shim function looks like:\n-//\n-//     void S(struct { X x; Y y; Z *z; } *args) {\n-//         F(args->z, args->x, args->y);\n-//     }\n-//\n-// Note: on i386, the layout of the args struct is generally the same\n-// as the desired layout of the arguments on the C stack.  Therefore,\n-// we could use upcall_alloc_c_stack() to allocate the `args`\n-// structure and switch the stack pointer appropriately to avoid a\n-// round of copies.  (In fact, the shim function itself is\n-// unnecessary). We used to do this, in fact, and will perhaps do so\n-// in the future.\n-pub fn trans_foreign_mod(ccx: @mut CrateContext,\n-                         path: &ast_map::path,\n-                         foreign_mod: &ast::foreign_mod) {\n-    let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n+    debug!(\"register_foreign_item_fn(abis=%s, \\\n+            path=%s, \\\n+            foreign_item.id=%?)\",\n+           abis.repr(ccx.tcx),\n+           path.repr(ccx.tcx),\n+           foreign_item.id);\n \n-    let arch = ccx.sess.targ_cfg.arch;\n-    let abi = match foreign_mod.abis.for_arch(arch) {\n+    let cc = match llvm_calling_convention(ccx, abis) {\n+        Some(cc) => cc,\n         None => {\n+            // FIXME(#8357) We really ought to report a span here\n             ccx.sess.fatal(\n-                fmt!(\"No suitable ABI for target architecture \\\n+                fmt!(\"ABI `%s` has no suitable ABI \\\n+                      for target architecture \\\n                       in module %s\",\n+                     abis.user_string(ccx.tcx),\n                      ast_map::path_to_str(*path,\n                                           ccx.sess.intr())));\n         }\n-\n-        Some(abi) => abi,\n     };\n \n-    for &foreign_item in foreign_mod.items.iter() {\n-        match foreign_item.node {\n-            ast::foreign_item_fn(*) => {\n-                let id = foreign_item.id;\n-                match abi {\n-                    RustIntrinsic => {\n-                        // Intrinsics are emitted by monomorphic fn\n-                    }\n-\n-                    Rust => {\n-                        // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                        ccx.sess.unimpl(\n-                            fmt!(\"Foreign functions with Rust ABI\"));\n-                    }\n-\n-                    Stdcall => {\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::X86StdcallCallConv);\n-                    }\n-\n-                    Fastcall => {\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::X86FastcallCallConv);\n-                    }\n-\n-                    Cdecl => {\n-                        // FIXME(#3678) should really be more specific\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::CCallConv);\n-                    }\n-\n-                    Aapcs => {\n-                        // FIXME(#3678) should really be more specific\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::CCallConv);\n-                    }\n-\n-                    C => {\n-                        build_foreign_fn(ccx, id, foreign_item,\n-                                         lib::llvm::CCallConv);\n-                    }\n-                }\n-            }\n-            ast::foreign_item_static(*) => {\n-                let ident = token::ident_to_str(&foreign_item.ident);\n-                ccx.item_symbols.insert(foreign_item.id, /* bad */ident.to_owned());\n-            }\n-        }\n-    }\n+    // Register the function as a C extern fn\n+    let lname = link_name(ccx, foreign_item);\n+    let tys = foreign_types_for_id(ccx, foreign_item.id);\n \n-    fn build_foreign_fn(ccx: @mut CrateContext,\n-                        id: ast::NodeId,\n-                        foreign_item: @ast::foreign_item,\n-                        cc: lib::llvm::CallConv) {\n-        let llwrapfn = get_item_val(ccx, id);\n-        let tys = shim_types(ccx, id);\n-        if attr::contains_name(foreign_item.attrs, \"rust_stack\") {\n-            build_direct_fn(ccx, llwrapfn, foreign_item,\n-                            &tys, cc);\n-        } else if attr::contains_name(foreign_item.attrs, \"fast_ffi\") {\n-            build_fast_ffi_fn(ccx, llwrapfn, foreign_item, &tys, cc);\n-        } else {\n-            let llshimfn = build_shim_fn(ccx, foreign_item, &tys, cc);\n-            build_wrap_fn(ccx, &tys, llshimfn, llwrapfn);\n-        }\n-    }\n+    // Create the LLVM value for the C extern fn\n+    let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n+    let llfn = base::get_extern_fn(&mut ccx.externs, ccx.llmod,\n+                                   lname, cc, llfn_ty);\n+    add_argument_attributes(&tys, llfn);\n \n-    fn build_shim_fn(ccx: @mut CrateContext,\n-                     foreign_item: &ast::foreign_item,\n-                     tys: &ShimTypes,\n-                     cc: lib::llvm::CallConv)\n-                  -> ValueRef {\n-        /*!\n-         *\n-         * Build S, from comment above:\n-         *\n-         *     void S(struct { X x; Y y; Z *z; } *args) {\n-         *         F(args->z, args->x, args->y);\n-         *     }\n-         */\n-\n-        let _icx = push_ctxt(\"foreign::build_shim_fn\");\n-\n-        fn build_args(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef)\n-                   -> ~[ValueRef] {\n-            let _icx = push_ctxt(\"foreign::shim::build_args\");\n-            tys.fn_ty.build_shim_args(bcx, tys.llsig.llarg_tys, llargbundle)\n-        }\n+    return llfn;\n+}\n \n-        fn build_ret(bcx: @mut Block,\n-                     tys: &ShimTypes,\n-                     llargbundle: ValueRef,\n-                     llretval: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::shim::build_ret\");\n-            tys.fn_ty.build_shim_ret(bcx,\n-                                     tys.llsig.llarg_tys,\n-                                     tys.ret_def,\n-                                     llargbundle,\n-                                     llretval);\n-        }\n+pub fn trans_native_call(bcx: @mut Block,\n+                         callee_ty: ty::t,\n+                         llfn: ValueRef,\n+                         llretptr: ValueRef,\n+                         llargs_rust: &[ValueRef]) -> @mut Block {\n+    /*!\n+     * Prepares a call to a native function. This requires adapting\n+     * from the Rust argument passing rules to the native rules.\n+     *\n+     * # Parameters\n+     *\n+     * - `callee_ty`: Rust type for the function we are calling\n+     * - `llfn`: the function pointer we are calling\n+     * - `llretptr`: where to store the return value of the function\n+     * - `llargs_rust`: a list of the argument values, prepared\n+     *   as they would be if calling a Rust function\n+     */\n \n-        let lname = link_name(ccx, foreign_item);\n-        let llbasefn = base_fn(ccx, lname, tys, cc);\n-        // Name the shim function\n-        let shim_name = fmt!(\"%s__c_stack_shim\", lname);\n-        build_shim_fn_(ccx,\n-                       shim_name,\n-                       llbasefn,\n-                       tys,\n-                       cc,\n-                       build_args,\n-                       build_ret)\n-    }\n+    let ccx = bcx.ccx();\n+    let tcx = bcx.tcx();\n \n-    fn base_fn(ccx: &CrateContext,\n-               lname: &str,\n-               tys: &ShimTypes,\n-               cc: lib::llvm::CallConv)\n-               -> ValueRef {\n-        // Declare the \"prototype\" for the base function F:\n-        do tys.fn_ty.decl_fn |fnty| {\n-            decl_fn(ccx.llmod, lname, cc, fnty)\n-        }\n-    }\n+    debug!(\"trans_native_call(callee_ty=%s, \\\n+            llfn=%s, \\\n+            llretptr=%s)\",\n+           callee_ty.repr(tcx),\n+           ccx.tn.val_to_str(llfn),\n+           ccx.tn.val_to_str(llretptr));\n \n-    // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n-    // over the place\n-    fn build_direct_fn(ccx: @mut CrateContext,\n-                       decl: ValueRef,\n-                       item: &ast::foreign_item,\n-                       tys: &ShimTypes,\n-                       cc: lib::llvm::CallConv) {\n-        debug!(\"build_direct_fn(%s)\", link_name(ccx, item));\n-\n-        let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = fcx.entry_bcx.unwrap();\n-        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n-        let ty = ty::lookup_item_type(ccx.tcx,\n-                                      ast_util::local_def(item.id)).ty;\n-        let ret_ty = ty::ty_fn_ret(ty);\n-        let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n-            get_param(decl, fcx.arg_pos(i))\n-        });\n-        let retval = Call(bcx, llbasefn, args);\n-        if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr.unwrap());\n+    let (fn_abis, fn_sig) = match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n+        _ => ccx.sess.bug(\"trans_native_call called on non-function type\")\n+    };\n+    let llsig = foreign_signature(ccx, &fn_sig);\n+    let ret_def = !ty::type_is_voidish(fn_sig.output);\n+    let fn_type = cabi::compute_abi_info(ccx,\n+                                         llsig.llarg_tys,\n+                                         llsig.llret_ty,\n+                                         ret_def);\n+\n+    let all_arg_tys: &[cabi::LLVMType] = fn_type.arg_tys;\n+    let all_attributes: &[Option<Attribute>] = fn_type.attrs;\n+\n+    let mut llargs_foreign = ~[];\n+\n+    // If the foreign ABI expects return value by pointer, supply the\n+    // pointer that Rust gave us. Sometimes we have to bitcast\n+    // because foreign fns return slightly different (but equivalent)\n+    // views on the same type (e.g., i64 in place of {i32,i32}).\n+    let (arg_tys, attributes) = {\n+        if fn_type.sret {\n+            if all_arg_tys[0].cast {\n+                let llcastedretptr =\n+                    BitCast(bcx, llretptr, all_arg_tys[0].ty.ptr_to());\n+                llargs_foreign.push(llcastedretptr);\n+            } else {\n+                llargs_foreign.push(llretptr);\n+            }\n+            (all_arg_tys.tail(), all_attributes.tail())\n+        } else {\n+            (all_arg_tys, all_attributes)\n         }\n-        finish_fn(fcx, bcx);\n-    }\n+    };\n \n-    // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n-    // over the place\n-    fn build_fast_ffi_fn(ccx: @mut CrateContext,\n-                         decl: ValueRef,\n-                         item: &ast::foreign_item,\n-                         tys: &ShimTypes,\n-                         cc: lib::llvm::CallConv) {\n-        debug!(\"build_fast_ffi_fn(%s)\", link_name(ccx, item));\n-\n-        let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = fcx.entry_bcx.unwrap();\n-        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n-        set_no_inline(fcx.llfn);\n-        set_fixed_stack_segment(fcx.llfn);\n-        let ty = ty::lookup_item_type(ccx.tcx,\n-                                      ast_util::local_def(item.id)).ty;\n-        let ret_ty = ty::ty_fn_ret(ty);\n-        let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n-            get_param(decl, fcx.arg_pos(i))\n-        });\n-        let retval = Call(bcx, llbasefn, args);\n-        if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr.unwrap());\n-        }\n-        finish_fn(fcx, bcx);\n-    }\n+    for (i, &llarg_rust) in llargs_rust.iter().enumerate() {\n+        let mut llarg_rust = llarg_rust;\n \n-    fn build_wrap_fn(ccx: @mut CrateContext,\n-                     tys: &ShimTypes,\n-                     llshimfn: ValueRef,\n-                     llwrapfn: ValueRef) {\n-        /*!\n-         *\n-         * Build W, from comment above:\n-         *\n-         *     void W(Z* dest, void *env, X x, Y y) {\n-         *         struct { X x; Y y; Z *z; } args = { x, y, z };\n-         *         call_on_c_stack_shim(S, &args);\n-         *     }\n-         *\n-         * One thing we have to be very careful of is to\n-         * account for the Rust modes.\n-         */\n-\n-        let _icx = push_ctxt(\"foreign::build_wrap_fn\");\n-\n-        build_wrap_fn_(ccx,\n-                       tys,\n-                       llshimfn,\n-                       llwrapfn,\n-                       ccx.upcalls.call_shim_on_c_stack,\n-                       false,\n-                       build_args,\n-                       build_ret);\n-\n-        fn build_args(bcx: @mut Block,\n-                      tys: &ShimTypes,\n-                      llwrapfn: ValueRef,\n-                      llargbundle: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::wrap::build_args\");\n-            let ccx = bcx.ccx();\n-            let n = tys.llsig.llarg_tys.len();\n-            for i in range(0u, n) {\n-                let arg_i = bcx.fcx.arg_pos(i);\n-                let mut llargval = get_param(llwrapfn, arg_i);\n-\n-                // In some cases, Rust will pass a pointer which the\n-                // native C type doesn't have.  In that case, just\n-                // load the value from the pointer.\n-                if type_of::arg_is_indirect(ccx, &tys.fn_sig.inputs[i]) {\n-                    llargval = Load(bcx, llargval);\n-                }\n+        // Does Rust pass this argument by pointer?\n+        let rust_indirect = type_of::arg_is_indirect(ccx, fn_sig.inputs[i]);\n \n-                store_inbounds(bcx, llargval, llargbundle, [0u, i]);\n-            }\n+        debug!(\"argument %u, llarg_rust=%s, rust_indirect=%b, arg_ty=%s\",\n+               i,\n+               ccx.tn.val_to_str(llarg_rust),\n+               rust_indirect,\n+               ccx.tn.type_to_str(arg_tys[i].ty));\n \n-            for &retptr in bcx.fcx.llretptr.iter() {\n-                store_inbounds(bcx, retptr, llargbundle, [0u, n]);\n-            }\n+        // Ensure that we always have the Rust value indirectly,\n+        // because it makes bitcasting easier.\n+        if !rust_indirect {\n+            let scratch = base::alloca(bcx, arg_tys[i].ty, \"__arg\");\n+            Store(bcx, llarg_rust, scratch);\n+            llarg_rust = scratch;\n         }\n \n-        fn build_ret(bcx: @mut Block,\n-                     shim_types: &ShimTypes,\n-                     llargbundle: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::wrap::build_ret\");\n-            let arg_count = shim_types.fn_sig.inputs.len();\n-            for &retptr in bcx.fcx.llretptr.iter() {\n-                let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n-                Store(bcx, Load(bcx, llretptr), retptr);\n-            }\n-        }\n-    }\n-}\n+        debug!(\"llarg_rust=%s (after indirection)\",\n+               ccx.tn.val_to_str(llarg_rust));\n \n-pub fn trans_intrinsic(ccx: @mut CrateContext,\n-                       decl: ValueRef,\n-                       item: &ast::foreign_item,\n-                       path: ast_map::path,\n-                       substs: @param_substs,\n-                       attributes: &[ast::Attribute],\n-                       ref_id: Option<ast::NodeId>) {\n-    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n-\n-    fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n-        assert!(num_args <= 4);\n-        let mut args = [0 as ValueRef, ..4];\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        for i in range(0u, num_args) {\n-            args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n+        // Check whether we need to do any casting\n+        let foreignarg_ty = arg_tys[i].ty;\n+        if arg_tys[i].cast {\n+            llarg_rust = BitCast(bcx, llarg_rust, foreignarg_ty.ptr_to());\n         }\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n-    }\n-\n-    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let a = get_param(bcx.fcx.llfn, first_real_arg);\n-        let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-\n-        // convert `i1` to a `bool`, and write to the out parameter\n-        let val = Call(bcx, llfn, [a, b]);\n-        let result = ExtractValue(bcx, val, 0);\n-        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n-        let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n-        let ret = Load(bcx, retptr);\n-        let ret = InsertValue(bcx, ret, result, 0);\n-        let ret = InsertValue(bcx, ret, overflow, 1);\n-        Store(bcx, ret, retptr);\n-        RetVoid(bcx)\n-    }\n \n-    fn memcpy_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n-        let ccx = bcx.ccx();\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-        let size = match sizebits {\n-            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n-            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n-            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n-        };\n+        debug!(\"llarg_rust=%s (after casting)\",\n+               ccx.tn.val_to_str(llarg_rust));\n \n-        let decl = bcx.fcx.llfn;\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-        let count = get_param(decl, first_real_arg + 2);\n-        let volatile = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        RetVoid(bcx);\n-    }\n-\n-    fn memset_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n-        let ccx = bcx.ccx();\n-        let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-        let size = match sizebits {\n-            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n-            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n-            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        // Finally, load the value if needed for the foreign ABI\n+        let foreign_indirect = attributes[i].is_some();\n+        let llarg_foreign = if foreign_indirect {\n+            llarg_rust\n+        } else {\n+            Load(bcx, llarg_rust)\n         };\n \n-        let decl = bcx.fcx.llfn;\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-        let val = get_param(decl, first_real_arg + 1);\n-        let count = get_param(decl, first_real_arg + 2);\n-        let volatile = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n-        RetVoid(bcx);\n-    }\n+        debug!(\"argument %u, llarg_foreign=%s\",\n+               i, ccx.tn.val_to_str(llarg_foreign));\n \n-    fn count_zeros_intrinsic(bcx: @mut Block, name: &'static str) {\n-        let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n-        let y = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        Ret(bcx, Call(bcx, llfn, [x, y]));\n+        llargs_foreign.push(llarg_foreign);\n     }\n \n-    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n-\n-    let fcx = new_fn_ctxt_w_id(ccx,\n-                               path,\n-                               decl,\n-                               item.id,\n-                               output_type,\n-                               true,\n-                               Some(substs),\n-                               None,\n-                               Some(item.span));\n-\n-    set_always_inline(fcx.llfn);\n+    let cc = match llvm_calling_convention(ccx, fn_abis) {\n+        Some(cc) => cc,\n+        None => {\n+            // FIXME(#8357) We really ought to report a span here\n+            ccx.sess.fatal(\n+                fmt!(\"ABI string `%s` has no suitable ABI \\\n+                      for target architecture\",\n+                     fn_abis.user_string(ccx.tcx)));\n+        }\n+    };\n \n-    // Set the fixed stack segment flag if necessary.\n-    if attr::contains_name(attributes, \"fixed_stack_segment\") {\n-        set_fixed_stack_segment(fcx.llfn);\n-    }\n+    let llforeign_retval = CallWithConv(bcx, llfn, llargs_foreign, cc);\n \n-    let mut bcx = fcx.entry_bcx.unwrap();\n-    let first_real_arg = fcx.arg_pos(0u);\n+    // If the function we just called does not use an outpointer,\n+    // store the result into the rust outpointer. Cast the outpointer\n+    // type to match because some ABIs will use a different type than\n+    // the Rust type. e.g., a {u32,u32} struct could be returned as\n+    // u64.\n+    if ret_def && !fn_type.sret {\n+        let llrust_ret_ty = llsig.llret_ty;\n+        let llforeign_ret_ty = fn_type.ret_ty.ty;\n \n-    let nm = ccx.sess.str_of(item.ident);\n-    let name = nm.as_slice();\n+        debug!(\"llretptr=%s\", ccx.tn.val_to_str(llretptr));\n+        debug!(\"llforeign_retval=%s\", ccx.tn.val_to_str(llforeign_retval));\n+        debug!(\"llrust_ret_ty=%s\", ccx.tn.type_to_str(llrust_ret_ty));\n+        debug!(\"llforeign_ret_ty=%s\", ccx.tn.type_to_str(llforeign_ret_ty));\n \n-    // This requires that atomic intrinsics follow a specific naming pattern:\n-    // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n-    if name.starts_with(\"atomic_\") {\n-        let split : ~[&str] = name.split_iter('_').collect();\n-        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n-        let order = if split.len() == 2 {\n-            lib::llvm::SequentiallyConsistent\n+        if llrust_ret_ty == llforeign_ret_ty {\n+            Store(bcx, llforeign_retval, llretptr);\n         } else {\n-            match split[2] {\n-                \"relaxed\" => lib::llvm::Monotonic,\n-                \"acq\"     => lib::llvm::Acquire,\n-                \"rel\"     => lib::llvm::Release,\n-                \"acqrel\"  => lib::llvm::AcquireRelease,\n-                _ => ccx.sess.fatal(\"Unknown ordering in atomic intrinsic\")\n-            }\n-        };\n-\n-        match split[1] {\n-            \"cxchg\" => {\n-                let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n-                                        get_param(decl, first_real_arg + 1u),\n-                                        get_param(decl, first_real_arg + 2u),\n-                                        order);\n-                Ret(bcx, old);\n-            }\n-            \"load\" => {\n-                let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n-                                     order);\n-                Ret(bcx, old);\n-            }\n-            \"store\" => {\n-                AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n-                            get_param(decl, first_real_arg),\n-                            order);\n-                RetVoid(bcx);\n-            }\n-            \"fence\" => {\n-                AtomicFence(bcx, order);\n-                RetVoid(bcx);\n-            }\n-            op => {\n-                // These are all AtomicRMW ops\n-                let atom_op = match op {\n-                    \"xchg\"  => lib::llvm::Xchg,\n-                    \"xadd\"  => lib::llvm::Add,\n-                    \"xsub\"  => lib::llvm::Sub,\n-                    \"and\"   => lib::llvm::And,\n-                    \"nand\"  => lib::llvm::Nand,\n-                    \"or\"    => lib::llvm::Or,\n-                    \"xor\"   => lib::llvm::Xor,\n-                    \"max\"   => lib::llvm::Max,\n-                    \"min\"   => lib::llvm::Min,\n-                    \"umax\"  => lib::llvm::UMax,\n-                    \"umin\"  => lib::llvm::UMin,\n-                    _ => ccx.sess.fatal(\"Unknown atomic operation\")\n-                };\n-\n-                let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n-                                    get_param(decl, first_real_arg + 1u),\n-                                    order);\n-                Ret(bcx, old);\n-            }\n+            // The actual return type is a struct, but the ABI\n+            // adaptation code has cast it into some scalar type.  The\n+            // code that follows is the only reliable way I have\n+            // found to do a transform like i64 -> {i32,i32}.\n+            // Basically we dump the data onto the stack then memcpy it.\n+            //\n+            // Other approaches I tried:\n+            // - Casting rust ret pointer to the foreign type and using Store\n+            //   is (a) unsafe if size of foreign type > size of rust type and\n+            //   (b) runs afoul of strict aliasing rules, yielding invalid\n+            //   assembly under -O (specifically, the store gets removed).\n+            // - Truncating foreign type to correct integral type and then\n+            //   bitcasting to the struct type yields invalid cast errors.\n+            let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n+            Store(bcx, llforeign_retval, llscratch);\n+            let llscratch_i8 = BitCast(bcx, llscratch, Type::i8().ptr_to());\n+            let llretptr_i8 = BitCast(bcx, llretptr, Type::i8().ptr_to());\n+            let llrust_size = machine::llsize_of_store(ccx, llrust_ret_ty);\n+            let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n+            let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n+            let llalign = uint::min(llforeign_align, llrust_align);\n+            debug!(\"llrust_size=%?\", llrust_size);\n+            base::call_memcpy(bcx, llretptr_i8, llscratch_i8,\n+                              C_uint(ccx, llrust_size), llalign as u32);\n         }\n-\n-        fcx.cleanup();\n-        return;\n     }\n \n-    match name {\n-        \"size_of\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)));\n-        }\n-        \"move_val\" => {\n-            // Create a datum reflecting the value being moved.\n-            // Use `appropriate_mode` so that the datum is by ref\n-            // if the value is non-immediate. Note that, with\n-            // intrinsics, there are no argument cleanups to\n-            // concern ourselves with.\n-            let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(ccx.tcx, tp_ty);\n-            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode};\n-            bcx = src.move_to(bcx, DROP_EXISTING,\n-                              get_param(decl, first_real_arg));\n-            RetVoid(bcx);\n-        }\n-        \"move_val_init\" => {\n-            // See comments for `\"move_val\"`.\n-            let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(ccx.tcx, tp_ty);\n-            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode};\n-            bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n-            RetVoid(bcx);\n-        }\n-        \"min_align_of\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)));\n-        }\n-        \"pref_align_of\"=> {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)));\n-        }\n-        \"get_tydesc\" => {\n-            let tp_ty = substs.tys[0];\n-            let static_ti = get_tydesc(ccx, tp_ty);\n-            glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n-\n-            // FIXME (#3730): ideally this shouldn't need a cast,\n-            // but there's a circularity between translating rust types to llvm\n-            // types and having a tydesc type available. So I can't directly access\n-            // the llvm type of intrinsic::TyDesc struct.\n-            let userland_tydesc_ty = type_of::type_of(ccx, output_type);\n-            let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n-            Ret(bcx, td);\n-        }\n-        \"init\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            match bcx.fcx.llretptr {\n-                Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n-                None if ty::type_is_nil(tp_ty) => RetVoid(bcx),\n-                None => Ret(bcx, C_null(lltp_ty)),\n-            }\n-        }\n-        \"uninit\" => {\n-            // Do nothing, this is effectively a no-op\n-            let retty = substs.tys[0];\n-            if ty::type_is_immediate(ccx.tcx, retty) && !ty::type_is_nil(retty) {\n-                unsafe {\n-                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n-                }\n-            } else {\n-                RetVoid(bcx)\n-            }\n-        }\n-        \"forget\" => {\n-            RetVoid(bcx);\n-        }\n-        \"transmute\" => {\n-            let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n-            let llintype = type_of::type_of(ccx, in_type);\n-            let llouttype = type_of::type_of(ccx, out_type);\n-\n-            let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n-            let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n-            if in_type_size != out_type_size {\n-                let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n-                    ast_map::node_expr(e) => e.span,\n-                    _ => fail!(\"transmute has non-expr arg\"),\n-                };\n-                let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n-                ccx.sess.span_fatal(sp,\n-                                    fmt!(\"transmute called on types with \\\n-                                          different sizes: %s (%u bit%s) to \\\n-                                          %s (%u bit%s)\",\n-                                         ty_to_str(ccx.tcx, in_type),\n-                                         in_type_size,\n-                                         pluralize(in_type_size),\n-                                         ty_to_str(ccx.tcx, out_type),\n-                                         out_type_size,\n-                                         pluralize(out_type_size)));\n-            }\n+    return bcx;\n+}\n \n-            if !ty::type_is_nil(out_type) {\n-                let llsrcval = get_param(decl, first_real_arg);\n-                if ty::type_is_immediate(ccx.tcx, in_type) {\n-                    match fcx.llretptr {\n-                        Some(llretptr) => {\n-                            Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n-                            RetVoid(bcx);\n-                        }\n-                        None => match (llintype.kind(), llouttype.kind()) {\n-                            (Pointer, other) | (other, Pointer) if other != Pointer => {\n-                                let tmp = Alloca(bcx, llouttype, \"\");\n-                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n-                                Ret(bcx, Load(bcx, tmp));\n-                            }\n-                            _ => Ret(bcx, BitCast(bcx, llsrcval, llouttype))\n-                        }\n-                    }\n-                } else if ty::type_is_immediate(ccx.tcx, out_type) {\n-                    let llsrcptr = PointerCast(bcx, llsrcval, llouttype.ptr_to());\n-                    Ret(bcx, Load(bcx, llsrcptr));\n-                } else {\n-                    // NB: Do not use a Load and Store here. This causes massive\n-                    // code bloat when `transmute` is used on large structural\n-                    // types.\n-                    let lldestptr = fcx.llretptr.unwrap();\n-                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n-                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n-\n-                    let llsize = llsize_of(ccx, llintype);\n-                    call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n-                    RetVoid(bcx);\n-                };\n-            } else {\n-                RetVoid(bcx);\n-            }\n-        }\n-        \"needs_drop\" => {\n-            let tp_ty = substs.tys[0];\n-            Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n-        }\n-        \"contains_managed\" => {\n-            let tp_ty = substs.tys[0];\n-            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()));\n-        }\n-        \"visit_tydesc\" => {\n-            let td = get_param(decl, first_real_arg);\n-            let visitor = get_param(decl, first_real_arg + 1u);\n-            let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n-            glue::call_tydesc_glue_full(bcx, visitor, td,\n-                                        abi::tydesc_field_visit_glue, None);\n-            RetVoid(bcx);\n-        }\n-        \"frame_address\" => {\n-            let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n-            let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n-            let star_u8 = ty::mk_imm_ptr(\n-                bcx.tcx(),\n-                ty::mk_mach_uint(ast::ty_u8));\n-            let fty = ty::mk_closure(bcx.tcx(), ty::ClosureTy {\n-                purity: ast::impure_fn,\n-                sigil: ast::BorrowedSigil,\n-                onceness: ast::Many,\n-                region: ty::re_bound(ty::br_anon(0)),\n-                bounds: ty::EmptyBuiltinBounds(),\n-                sig: FnSig {\n-                    bound_lifetime_names: opt_vec::Empty,\n-                    inputs: ~[ star_u8 ],\n-                    output: ty::mk_nil()\n-                }\n-            });\n-            let datum = Datum {val: get_param(decl, first_real_arg),\n-                               mode: ByRef(ZeroMem), ty: fty};\n-            let arg_vals = ~[frameaddress_val];\n-            bcx = trans_call_inner(\n-                bcx, None, fty, ty::mk_nil(),\n-                |bcx| Callee {bcx: bcx, data: Closure(datum)},\n-                ArgVals(arg_vals), Some(Ignore), DontAutorefArg).bcx;\n-            RetVoid(bcx);\n-        }\n-        \"morestack_addr\" => {\n-            // XXX This is a hack to grab the address of this particular\n-            // native function. There should be a general in-language\n-            // way to do this\n-            let llfty = type_of_fn(bcx.ccx(), [], ty::mk_nil());\n-            let morestack_addr = decl_cdecl_fn(\n-                bcx.ccx().llmod, \"__morestack\", llfty);\n-            let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n-            Ret(bcx, morestack_addr);\n-        }\n-        \"offset\" => {\n-            let ptr = get_param(decl, first_real_arg);\n-            let offset = get_param(decl, first_real_arg + 1);\n-            Ret(bcx, GEP(bcx, ptr, [offset]));\n-        }\n-        \"offset_inbounds\" => {\n-            let ptr = get_param(decl, first_real_arg);\n-            let offset = get_param(decl, first_real_arg + 1);\n-            Ret(bcx, InBoundsGEP(bcx, ptr, [offset]));\n-        }\n-        \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n-        \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n-        \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),\n-        \"memmove64\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i64\", substs.tys[0], 64),\n-        \"memset32\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i32\", substs.tys[0], 32),\n-        \"memset64\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i64\", substs.tys[0], 64),\n-        \"sqrtf32\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f32\", 1),\n-        \"sqrtf64\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f64\", 1),\n-        \"powif32\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f32\", 2),\n-        \"powif64\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f64\", 2),\n-        \"sinf32\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f32\", 1),\n-        \"sinf64\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f64\", 1),\n-        \"cosf32\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f32\", 1),\n-        \"cosf64\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f64\", 1),\n-        \"powf32\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f32\", 2),\n-        \"powf64\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f64\", 2),\n-        \"expf32\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f32\", 1),\n-        \"expf64\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f64\", 1),\n-        \"exp2f32\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f32\", 1),\n-        \"exp2f64\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f64\", 1),\n-        \"logf32\" => simple_llvm_intrinsic(bcx, \"llvm.log.f32\", 1),\n-        \"logf64\" => simple_llvm_intrinsic(bcx, \"llvm.log.f64\", 1),\n-        \"log10f32\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f32\", 1),\n-        \"log10f64\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f64\", 1),\n-        \"log2f32\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f32\", 1),\n-        \"log2f64\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f64\", 1),\n-        \"fmaf32\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f32\", 3),\n-        \"fmaf64\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f64\", 3),\n-        \"fabsf32\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f32\", 1),\n-        \"fabsf64\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f64\", 1),\n-        \"floorf32\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f32\", 1),\n-        \"floorf64\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f64\", 1),\n-        \"ceilf32\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f32\", 1),\n-        \"ceilf64\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f64\", 1),\n-        \"truncf32\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f32\", 1),\n-        \"truncf64\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f64\", 1),\n-        \"ctpop8\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i8\", 1),\n-        \"ctpop16\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i16\", 1),\n-        \"ctpop32\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i32\", 1),\n-        \"ctpop64\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i64\", 1),\n-        \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n-        \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n-        \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),\n-        \"ctlz64\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\"),\n-        \"cttz8\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\"),\n-        \"cttz16\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\"),\n-        \"cttz32\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\"),\n-        \"cttz64\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\"),\n-        \"bswap16\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i16\", 1),\n-        \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n-        \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n-\n-        \"i8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i8\"),\n-        \"i16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i16\"),\n-        \"i32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i32\"),\n-        \"i64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i64\"),\n-\n-        \"u8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i8\"),\n-        \"u16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i16\"),\n-        \"u32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i32\"),\n-        \"u64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i64\"),\n-\n-        \"i8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i8\"),\n-        \"i16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i16\"),\n-        \"i32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i32\"),\n-        \"i64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i64\"),\n-\n-        \"u8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i8\"),\n-        \"u16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i16\"),\n-        \"u32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i32\"),\n-        \"u64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i64\"),\n-\n-        \"i8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i8\"),\n-        \"i16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i16\"),\n-        \"i32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i32\"),\n-        \"i64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i64\"),\n-\n-        \"u8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i8\"),\n-        \"u16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i16\"),\n-        \"u32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i32\"),\n-        \"u64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i64\"),\n-\n-        _ => {\n-            // Could we make this an enum rather than a string? does it get\n-            // checked earlier?\n-            ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n-        }\n+pub fn trans_foreign_mod(ccx: @mut CrateContext,\n+                         foreign_mod: &ast::foreign_mod) {\n+    let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n+    for &foreign_item in foreign_mod.items.iter() {\n+        let lname = link_name(ccx, foreign_item);\n+        ccx.item_symbols.insert(foreign_item.id, lname.to_owned());\n     }\n-    fcx.cleanup();\n }\n \n-/**\n- * Translates a \"crust\" fn, meaning a Rust fn that can be called\n- * from C code.  In this case, we have to perform some adaptation\n- * to (1) switch back to the Rust stack and (2) adapt the C calling\n- * convention to our own.\n- *\n- * Example: Given a crust fn F(x: X, y: Y) -> Z, we generate a\n- * Rust function R as normal:\n- *\n- *    void R(Z* dest, void *env, X x, Y y) {...}\n- *\n- * and then we generate a wrapper function W that looks like:\n- *\n- *    Z W(X x, Y y) {\n- *        struct { X x; Y y; Z *z; } args = { x, y, z };\n- *        call_on_c_stack_shim(S, &args);\n- *    }\n- *\n- * Note that the wrapper follows the foreign (typically \"C\") ABI.\n- * The wrapper is the actual \"value\" of the foreign fn.  Finally,\n- * we generate a shim function S that looks like:\n- *\n- *     void S(struct { X x; Y y; Z *z; } *args) {\n- *         R(args->z, NULL, args->x, args->y);\n- *     }\n- */\n-pub fn trans_foreign_fn(ccx: @mut CrateContext,\n-                        path: ast_map::path,\n-                        decl: &ast::fn_decl,\n-                        body: &ast::Block,\n-                        llwrapfn: ValueRef,\n-                        id: ast::NodeId) {\n+///////////////////////////////////////////////////////////////////////////\n+// Rust functions with foreign ABIs\n+//\n+// These are normal Rust functions defined with foreign ABIs.  For\n+// now, and perhaps forever, we translate these using a \"layer of\n+// indirection\". That is, given a Rust declaration like:\n+//\n+//     extern \"C\" fn foo(i: u32) -> u32 { ... }\n+//\n+// we will generate a function like:\n+//\n+//     S foo(T i) {\n+//         S r;\n+//         foo0(&r, NULL, i);\n+//         return r;\n+//     }\n+//\n+//     #[inline_always]\n+//     void foo0(uint32_t *r, void *env, uint32_t i) { ... }\n+//\n+// Here the (internal) `foo0` function follows the Rust ABI as normal,\n+// where the `foo` function follows the C ABI. We rely on LLVM to\n+// inline the one into the other. Of course we could just generate the\n+// correct code in the first place, but this is much simpler.\n+\n+pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n+                                         sp: span,\n+                                         sym: ~str,\n+                                         node_id: ast::NodeId)\n+                                         -> ValueRef {\n+    let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n+\n+    let tys = foreign_types_for_id(ccx, node_id);\n+    let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n+    let llfn = base::register_fn_llvmty(ccx,\n+                                        sp,\n+                                        sym,\n+                                        node_id,\n+                                        lib::llvm::CCallConv,\n+                                        llfn_ty);\n+    add_argument_attributes(&tys, llfn);\n+    debug!(\"register_rust_fn_with_foreign_abi(node_id=%?, llfn_ty=%s, llfn=%s)\",\n+           node_id, ccx.tn.type_to_str(llfn_ty), ccx.tn.val_to_str(llfn));\n+    llfn\n+}\n+\n+pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n+                                      path: &ast_map::path,\n+                                      decl: &ast::fn_decl,\n+                                      body: &ast::Block,\n+                                      llwrapfn: ValueRef,\n+                                      id: ast::NodeId) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n+    let tys = foreign_types_for_id(ccx, id);\n+\n+    unsafe { // unsafe because we call LLVM operations\n+        // Build up the Rust function (`foo0` above).\n+        let llrustfn = build_rust_fn(ccx, path, decl, body, id);\n+\n+        // Build up the foreign wrapper (`foo` above).\n+        return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys);\n+    }\n \n     fn build_rust_fn(ccx: @mut CrateContext,\n                      path: &ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n                      id: ast::NodeId)\n-                  -> ValueRef {\n+                     -> ValueRef {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n-        let t = ty::node_id_to_type(ccx.tcx, id);\n-        // XXX: Bad copy.\n+        let tcx = ccx.tcx;\n+        let t = ty::node_id_to_type(tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n-                            ccx,\n-                            vec::append_one((*path).clone(),\n-                                            ast_map::path_name(\n-                                            special_idents::clownshoe_abi)));\n+            ccx, vec::append_one((*path).clone(), ast_map::path_name(\n+                special_idents::clownshoe_abi\n+            )));\n         let llty = type_of_fn_from_ty(ccx, t);\n-        let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n-        trans_fn(ccx,\n-                 (*path).clone(),\n-                 decl,\n-                 body,\n-                 llfndecl,\n-                 no_self,\n-                 None,\n-                 id,\n-                 []);\n+        let llfndecl = base::decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n+        base::trans_fn(ccx,\n+                       (*path).clone(),\n+                       decl,\n+                       body,\n+                       llfndecl,\n+                       base::no_self,\n+                       None,\n+                       id,\n+                       []);\n         return llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: @mut CrateContext,\n-                     path: ast_map::path,\n-                     llrustfn: ValueRef,\n-                     tys: &ShimTypes)\n-                     -> ValueRef {\n-        /*!\n-         *\n-         * Generate the shim S:\n-         *\n-         *     void S(struct { X x; Y y; Z *z; } *args) {\n-         *         R(args->z, NULL, &args->x, args->y);\n-         *     }\n-         *\n-         * One complication is that we must adapt to the Rust\n-         * calling convention, which introduces indirection\n-         * in some cases.  To demonstrate this, I wrote one of the\n-         * entries above as `&args->x`, because presumably `X` is\n-         * one of those types that is passed by pointer in Rust.\n-         */\n-\n-        let _icx = push_ctxt(\"foreign::foreign::build_shim_fn\");\n-\n-        fn build_args(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef)\n-                      -> ~[ValueRef] {\n-            let _icx = push_ctxt(\"foreign::extern::shim::build_args\");\n-            let ccx = bcx.ccx();\n-            let mut llargvals = ~[];\n-            let mut i = 0u;\n-            let n = tys.fn_sig.inputs.len();\n-\n-            if !ty::type_is_immediate(bcx.tcx(), tys.fn_sig.output) {\n-                let llretptr = load_inbounds(bcx, llargbundle, [0u, n]);\n-                llargvals.push(llretptr);\n+    unsafe fn build_wrap_fn(ccx: @mut CrateContext,\n+                            llrustfn: ValueRef,\n+                            llwrapfn: ValueRef,\n+                            tys: &ForeignTypes) {\n+        let _icx = push_ctxt(\n+            \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n+        let tcx = ccx.tcx;\n+\n+        debug!(\"build_wrap_fn(llrustfn=%s, llwrapfn=%s)\",\n+               ccx.tn.val_to_str(llrustfn),\n+               ccx.tn.val_to_str(llwrapfn));\n+\n+        // Avoid all the Rust generation stuff and just generate raw\n+        // LLVM here.\n+        //\n+        // We want to generate code like this:\n+        //\n+        //     S foo(T i) {\n+        //         S r;\n+        //         foo0(&r, NULL, i);\n+        //         return r;\n+        //     }\n+\n+        let the_block =\n+            \"the block\".to_c_str().with_ref(\n+                |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llwrapfn, s));\n+\n+        let builder = ccx.builder.B;\n+        llvm::LLVMPositionBuilderAtEnd(builder, the_block);\n+\n+        // Array for the arguments we will pass to the rust function.\n+        let mut llrust_args = ~[];\n+        let mut next_foreign_arg_counter: c_uint = 0;\n+        let next_foreign_arg: &fn() -> c_uint = {\n+            || {\n+                next_foreign_arg_counter += 1;\n+                next_foreign_arg_counter - 1\n             }\n+        };\n \n-            let llenvptr = C_null(Type::opaque_box(bcx.ccx()).ptr_to());\n-            llargvals.push(llenvptr);\n-            while i < n {\n-                // Get a pointer to the argument:\n-                let mut llargval = GEPi(bcx, llargbundle, [0u, i]);\n+        // If there is an out pointer on the foreign function\n+        let foreign_outptr = {\n+            if tys.fn_ty.sret {\n+                Some(llvm::LLVMGetParam(llwrapfn, next_foreign_arg()))\n+            } else {\n+                None\n+            }\n+        };\n \n-                if !type_of::arg_is_indirect(ccx, &tys.fn_sig.inputs[i]) {\n-                    // If Rust would pass this by value, load the value.\n-                    llargval = Load(bcx, llargval);\n+        // Push Rust return pointer, using null if it will be unused.\n+        let rust_uses_outptr =\n+            type_of::return_uses_outptr(tcx, tys.fn_sig.output);\n+        let return_alloca: Option<ValueRef>;\n+        let llrust_ret_ty = tys.llsig.llret_ty;\n+        let llrust_retptr_ty = llrust_ret_ty.ptr_to();\n+        if rust_uses_outptr {\n+            // Rust expects to use an outpointer. If the foreign fn\n+            // also uses an outpointer, we can reuse it, but the types\n+            // may vary, so cast first to the Rust type. If the\n+            // foriegn fn does NOT use an outpointer, we will have to\n+            // alloca some scratch space on the stack.\n+            match foreign_outptr {\n+                Some(llforeign_outptr) => {\n+                    debug!(\"out pointer, foreign=%s\",\n+                           ccx.tn.val_to_str(llforeign_outptr));\n+                    let llrust_retptr =\n+                        llvm::LLVMBuildBitCast(builder,\n+                                               llforeign_outptr,\n+                                               llrust_ret_ty.ptr_to().to_ref(),\n+                                               noname());\n+                    debug!(\"out pointer, foreign=%s (casted)\",\n+                           ccx.tn.val_to_str(llrust_retptr));\n+                    llrust_args.push(llrust_retptr);\n+                    return_alloca = None;\n                 }\n \n-                llargvals.push(llargval);\n-                i += 1u;\n+                None => {\n+                    let slot = {\n+                        \"return_alloca\".to_c_str().with_ref(\n+                            |s| llvm::LLVMBuildAlloca(builder,\n+                                                      llrust_ret_ty.to_ref(),\n+                                                      s))\n+                    };\n+                    debug!(\"out pointer, \\\n+                            allocad=%s, \\\n+                            llrust_ret_ty=%s, \\\n+                            return_ty=%s\",\n+                           ccx.tn.val_to_str(slot),\n+                           ccx.tn.type_to_str(llrust_ret_ty),\n+                           tys.fn_sig.output.repr(tcx));\n+                    llrust_args.push(slot);\n+                    return_alloca = Some(slot);\n+                }\n+            }\n+        } else {\n+            // Rust does not expect an outpointer. If the foreign fn\n+            // does use an outpointer, then we will do a store of the\n+            // value that the Rust fn returns.\n+            return_alloca = None;\n+        };\n+\n+        // Push an (null) env pointer\n+        let env_pointer = base::null_env_ptr(ccx);\n+        debug!(\"env pointer=%s\", ccx.tn.val_to_str(env_pointer));\n+        llrust_args.push(env_pointer);\n+\n+        // Build up the arguments to the call to the rust function.\n+        // Careful to adapt for cases where the native convention uses\n+        // a pointer and Rust does not or vice versa.\n+        for i in range(0, tys.fn_sig.inputs.len()) {\n+            let rust_ty = tys.fn_sig.inputs[i];\n+            let llrust_ty = tys.llsig.llarg_tys[i];\n+            let foreign_index = next_foreign_arg();\n+            let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n+            let foreign_indirect = tys.fn_ty.attrs[foreign_index].is_some();\n+            let mut llforeign_arg = llvm::LLVMGetParam(llwrapfn, foreign_index);\n+\n+            debug!(\"llforeign_arg #%u: %s\",\n+                   i, ccx.tn.val_to_str(llforeign_arg));\n+            debug!(\"rust_indirect = %b, foreign_indirect = %b\",\n+                   rust_indirect, foreign_indirect);\n+\n+            // Ensure that the foreign argument is indirect (by\n+            // pointer).  It makes adapting types easier, since we can\n+            // always just bitcast pointers.\n+            if !foreign_indirect {\n+                let lltemp =\n+                    llvm::LLVMBuildAlloca(\n+                        builder, val_ty(llforeign_arg).to_ref(), noname());\n+                llvm::LLVMBuildStore(\n+                    builder, llforeign_arg, lltemp);\n+                llforeign_arg = lltemp;\n+            }\n+\n+            // If the types in the ABI and the Rust types don't match,\n+            // bitcast the llforeign_arg pointer so it matches the types\n+            // Rust expects.\n+            if tys.fn_ty.arg_tys[foreign_index].cast {\n+                assert!(!foreign_indirect);\n+                llforeign_arg = llvm::LLVMBuildBitCast(\n+                    builder, llforeign_arg,\n+                    llrust_ty.ptr_to().to_ref(), noname());\n             }\n-            return llargvals;\n-        }\n \n-        fn build_ret(bcx: @mut Block,\n-                     shim_types: &ShimTypes,\n-                     llargbundle: ValueRef,\n-                     llretval: ValueRef) {\n-            if bcx.fcx.llretptr.is_some() &&\n-                ty::type_is_immediate(bcx.tcx(), shim_types.fn_sig.output) {\n-                // Write the value into the argument bundle.\n-                let arg_count = shim_types.fn_sig.inputs.len();\n-                let llretptr = load_inbounds(bcx,\n-                                             llargbundle,\n-                                             [0, arg_count]);\n-                Store(bcx, llretval, llretptr);\n+            let llrust_arg = if rust_indirect {\n+                llforeign_arg\n             } else {\n-                // NB: The return pointer in the Rust ABI function is wired\n-                // directly into the return slot in the shim struct.\n+                llvm::LLVMBuildLoad(builder, llforeign_arg, noname())\n+            };\n+\n+            debug!(\"llrust_arg #%u: %s\",\n+                   i, ccx.tn.val_to_str(llrust_arg));\n+            llrust_args.push(llrust_arg);\n+        }\n+\n+        // Perform the call itself\n+        let llrust_ret_val = do llrust_args.as_imm_buf |ptr, len| {\n+            debug!(\"calling llrustfn = %s\", ccx.tn.val_to_str(llrustfn));\n+            llvm::LLVMBuildCall(builder, llrustfn, ptr,\n+                                len as c_uint, noname())\n+        };\n+\n+        // Get the return value where the foreign fn expects it.\n+        let llforeign_ret_ty = tys.fn_ty.ret_ty.ty;\n+        match foreign_outptr {\n+            None if !tys.ret_def => {\n+                // Function returns `()` or `bot`, which in Rust is the LLVM\n+                // type \"{}\" but in foreign ABIs is \"Void\".\n+                llvm::LLVMBuildRetVoid(builder);\n+            }\n+\n+            None if rust_uses_outptr => {\n+                // Rust uses an outpointer, but the foreign ABI does not. Load.\n+                let llrust_outptr = return_alloca.unwrap();\n+                let llforeign_outptr_casted =\n+                    llvm::LLVMBuildBitCast(builder,\n+                                           llrust_outptr,\n+                                           llforeign_ret_ty.ptr_to().to_ref(),\n+                                           noname());\n+                let llforeign_retval =\n+                    llvm::LLVMBuildLoad(builder, llforeign_outptr_casted, noname());\n+                llvm::LLVMBuildRet(builder, llforeign_retval);\n+            }\n+\n+            None if llforeign_ret_ty != llrust_ret_ty => {\n+                // Neither ABI uses an outpointer, but the types don't\n+                // quite match. Must cast. Probably we should try and\n+                // examine the types and use a concrete llvm cast, but\n+                // right now we just use a temp memory location and\n+                // bitcast the pointer, which is the same thing the\n+                // old wrappers used to do.\n+                let lltemp =\n+                    llvm::LLVMBuildAlloca(\n+                        builder, llforeign_ret_ty.to_ref(), noname());\n+                let lltemp_casted =\n+                    llvm::LLVMBuildBitCast(builder,\n+                                           lltemp,\n+                                           llrust_ret_ty.ptr_to().to_ref(),\n+                                           noname());\n+                llvm::LLVMBuildStore(\n+                    builder, llrust_ret_val, lltemp_casted);\n+                let llforeign_retval =\n+                    llvm::LLVMBuildLoad(builder, lltemp, noname());\n+                llvm::LLVMBuildRet(builder, llforeign_retval);\n+            }\n+\n+            None => {\n+                // Neither ABI uses an outpointer, and the types\n+                // match. Easy peasy.\n+                llvm::LLVMBuildRet(builder, llrust_ret_val);\n+            }\n+\n+            Some(llforeign_outptr) if !rust_uses_outptr => {\n+                // Foreign ABI requires an out pointer, but Rust doesn't.\n+                // Store Rust return value.\n+                let llforeign_outptr_casted =\n+                    llvm::LLVMBuildBitCast(builder,\n+                                           llforeign_outptr,\n+                                           llrust_retptr_ty.to_ref(),\n+                                           noname());\n+                llvm::LLVMBuildStore(\n+                    builder, llrust_ret_val, llforeign_outptr_casted);\n+                llvm::LLVMBuildRetVoid(builder);\n+            }\n+\n+            Some(_) => {\n+                // Both ABIs use outpointers. Easy peasy.\n+                llvm::LLVMBuildRetVoid(builder);\n             }\n         }\n+    }\n+}\n \n-        let shim_name = link::mangle_internal_name_by_path(\n-            ccx,\n-            vec::append_one(path, ast_map::path_name(\n-                special_idents::clownshoe_stack_shim\n-            )));\n-        build_shim_fn_(ccx,\n-                       shim_name,\n-                       llrustfn,\n-                       tys,\n-                       lib::llvm::CCallConv,\n-                       build_args,\n-                       build_ret)\n+///////////////////////////////////////////////////////////////////////////\n+// General ABI Support\n+//\n+// This code is kind of a confused mess and needs to be reworked given\n+// the massive simplifications that have occurred.\n+\n+pub fn link_name(ccx: &CrateContext, i: @ast::foreign_item) -> @str {\n+     match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n+        None => ccx.sess.str_of(i.ident),\n+        Some(ln) => ln,\n     }\n+}\n \n-    fn build_wrap_fn(ccx: @mut CrateContext,\n-                     llshimfn: ValueRef,\n-                     llwrapfn: ValueRef,\n-                     tys: &ShimTypes) {\n-        /*!\n-         *\n-         * Generate the wrapper W:\n-         *\n-         *    Z W(X x, Y y) {\n-         *        struct { X x; Y y; Z *z; } args = { x, y, z };\n-         *        call_on_c_stack_shim(S, &args);\n-         *    }\n-         */\n-\n-        let _icx = push_ctxt(\"foreign::foreign::build_wrap_fn\");\n-\n-        build_wrap_fn_(ccx,\n-                       tys,\n-                       llshimfn,\n-                       llwrapfn,\n-                       ccx.upcalls.call_shim_on_rust_stack,\n-                       true,\n-                       build_args,\n-                       build_ret);\n-\n-        fn build_args(bcx: @mut Block,\n-                      tys: &ShimTypes,\n-                      llwrapfn: ValueRef,\n-                      llargbundle: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::foreign::wrap::build_args\");\n-            tys.fn_ty.build_wrap_args(bcx,\n-                                      tys.llsig.llret_ty,\n-                                      llwrapfn,\n-                                      llargbundle);\n-        }\n+fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n+                     -> LlvmSignature {\n+    /*!\n+     * The ForeignSignature is the LLVM types of the arguments/return type\n+     * of a function.  Note that these LLVM types are not quite the same\n+     * as the LLVM types would be for a native Rust function because foreign\n+     * functions just plain ignore modes.  They also don't pass aggregate\n+     * values by pointer like we do.\n+     */\n \n-        fn build_ret(bcx: @mut Block, tys: &ShimTypes, llargbundle: ValueRef) {\n-            let _icx = push_ctxt(\"foreign::foreign::wrap::build_ret\");\n-            tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n-        }\n+    let llarg_tys = fn_sig.inputs.map(|&arg| type_of(ccx, arg));\n+    let llret_ty = type_of::type_of(ccx, fn_sig.output);\n+    LlvmSignature {\n+        llarg_tys: llarg_tys,\n+        llret_ty: llret_ty,\n+        sret: type_of::return_uses_outptr(ccx.tcx, fn_sig.output),\n     }\n+}\n \n-    let tys = shim_types(ccx, id);\n-    // The internal Rust ABI function - runs on the Rust stack\n-    // XXX: Bad copy.\n-    let llrustfn = build_rust_fn(ccx, &path, decl, body, id);\n-    // The internal shim function - runs on the Rust stack\n-    let llshimfn = build_shim_fn(ccx, path, llrustfn, &tys);\n-    // The foreign C function - runs on the C stack\n-    build_wrap_fn(ccx, llshimfn, llwrapfn, &tys)\n+fn foreign_types_for_id(ccx: &mut CrateContext,\n+                        id: ast::NodeId) -> ForeignTypes {\n+    foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx, id))\n }\n \n-pub fn register_foreign_fn(ccx: @mut CrateContext,\n-                           sp: span,\n-                           sym: ~str,\n-                           node_id: ast::NodeId)\n-                           -> ValueRef {\n-    let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n+fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n+                           ty: ty::t) -> ForeignTypes {\n+    let fn_sig = match ty::get(ty).sty {\n+        ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n+        _ => ccx.sess.bug(\"foreign_types_for_fn_ty called on non-function type\")\n+    };\n+    let llsig = foreign_signature(ccx, &fn_sig);\n+    let ret_def = !ty::type_is_voidish(fn_sig.output);\n+    let fn_ty = cabi::compute_abi_info(ccx,\n+                                       llsig.llarg_tys,\n+                                       llsig.llret_ty,\n+                                       ret_def);\n+    debug!(\"foreign_types_for_fn_ty(\\\n+           ty=%s, \\\n+           llsig=%s -> %s, \\\n+           fn_ty=%s -> %s, \\\n+           ret_def=%b\",\n+           ty.repr(ccx.tcx),\n+           ccx.tn.types_to_str(llsig.llarg_tys),\n+           ccx.tn.type_to_str(llsig.llret_ty),\n+           ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty)),\n+           ccx.tn.type_to_str(fn_ty.ret_ty.ty),\n+           ret_def);\n+\n+    ForeignTypes {\n+        fn_sig: fn_sig,\n+        llsig: llsig,\n+        ret_def: ret_def,\n+        fn_ty: fn_ty\n+    }\n+}\n \n-    let sym = Cell::new(sym);\n+fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n+    let llargument_tys: ~[Type] =\n+        tys.fn_ty.arg_tys.iter().map(|t| t.ty).collect();\n+    let llreturn_ty = tys.fn_ty.ret_ty.ty;\n+    Type::func(llargument_tys, &llreturn_ty)\n+}\n+\n+pub fn lltype_for_foreign_fn(ccx: &mut CrateContext, ty: ty::t) -> Type {\n+    let fn_types = foreign_types_for_fn_ty(ccx, ty);\n+    lltype_for_fn_from_foreign_types(&fn_types)\n+}\n \n-    let tys = shim_types(ccx, node_id);\n-    do tys.fn_ty.decl_fn |fnty| {\n-        register_fn_llvmty(ccx, sp, sym.take(), node_id, lib::llvm::CCallConv, fnty)\n+fn add_argument_attributes(tys: &ForeignTypes,\n+                           llfn: ValueRef) {\n+    for (i, a) in tys.fn_ty.attrs.iter().enumerate() {\n+        match *a {\n+            Some(attr) => {\n+                let llarg = get_param(llfn, i);\n+                unsafe {\n+                    llvm::LLVMAddAttribute(llarg, attr as c_uint);\n+                }\n+            }\n+            None => ()\n+        }\n     }\n }"}, {"sha": "2232b8966b8695bd938e5e19e24e46570eb2fbbb", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -0,0 +1,503 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use back::{abi};\n+use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n+use lib::llvm::{ValueRef, Pointer};\n+use lib;\n+use middle::trans::base::*;\n+use middle::trans::build::*;\n+use middle::trans::callee::*;\n+use middle::trans::common::*;\n+use middle::trans::datum::*;\n+use middle::trans::type_of::*;\n+use middle::trans::type_of;\n+use middle::trans::expr::Ignore;\n+use middle::trans::machine;\n+use middle::trans::glue;\n+use middle::ty::FnSig;\n+use middle::ty;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::attr;\n+use syntax::opt_vec;\n+use util::ppaux::{ty_to_str};\n+use middle::trans::machine::llsize_of;\n+use middle::trans::type_::Type;\n+\n+pub fn trans_intrinsic(ccx: @mut CrateContext,\n+                       decl: ValueRef,\n+                       item: &ast::foreign_item,\n+                       path: ast_map::path,\n+                       substs: @param_substs,\n+                       attributes: &[ast::Attribute],\n+                       ref_id: Option<ast::NodeId>) {\n+    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n+\n+    fn simple_llvm_intrinsic(bcx: @mut Block, name: &'static str, num_args: uint) {\n+        assert!(num_args <= 4);\n+        let mut args = [0 as ValueRef, ..4];\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        for i in range(0u, num_args) {\n+            args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n+        }\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n+    }\n+\n+    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let a = get_param(bcx.fcx.llfn, first_real_arg);\n+        let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+\n+        // convert `i1` to a `bool`, and write to the out parameter\n+        let val = Call(bcx, llfn, [a, b]);\n+        let result = ExtractValue(bcx, val, 0);\n+        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n+        let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n+        let ret = Load(bcx, retptr);\n+        let ret = InsertValue(bcx, ret, result, 0);\n+        let ret = InsertValue(bcx, ret, overflow, 1);\n+        Store(bcx, ret, retptr);\n+        RetVoid(bcx)\n+    }\n+\n+    fn memcpy_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+        let ccx = bcx.ccx();\n+        let lltp_ty = type_of::type_of(ccx, tp_ty);\n+        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let size = match sizebits {\n+            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n+            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n+            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        };\n+\n+        let decl = bcx.fcx.llfn;\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n+        let count = get_param(decl, first_real_arg + 2);\n+        let volatile = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n+        RetVoid(bcx);\n+    }\n+\n+    fn memset_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+        let ccx = bcx.ccx();\n+        let lltp_ty = type_of::type_of(ccx, tp_ty);\n+        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let size = match sizebits {\n+            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n+            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n+            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        };\n+\n+        let decl = bcx.fcx.llfn;\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let val = get_param(decl, first_real_arg + 1);\n+        let count = get_param(decl, first_real_arg + 2);\n+        let volatile = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n+        RetVoid(bcx);\n+    }\n+\n+    fn count_zeros_intrinsic(bcx: @mut Block, name: &'static str) {\n+        let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n+        let y = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Ret(bcx, Call(bcx, llfn, [x, y]));\n+    }\n+\n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n+\n+    let fcx = new_fn_ctxt_w_id(ccx,\n+                               path,\n+                               decl,\n+                               item.id,\n+                               output_type,\n+                               true,\n+                               Some(substs),\n+                               None,\n+                               Some(item.span));\n+\n+    set_always_inline(fcx.llfn);\n+\n+    // Set the fixed stack segment flag if necessary.\n+    if attr::contains_name(attributes, \"fixed_stack_segment\") {\n+        set_fixed_stack_segment(fcx.llfn);\n+    }\n+\n+    let mut bcx = fcx.entry_bcx.unwrap();\n+    let first_real_arg = fcx.arg_pos(0u);\n+\n+    let nm = ccx.sess.str_of(item.ident);\n+    let name = nm.as_slice();\n+\n+    // This requires that atomic intrinsics follow a specific naming pattern:\n+    // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n+    if name.starts_with(\"atomic_\") {\n+        let split : ~[&str] = name.split_iter('_').collect();\n+        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+        let order = if split.len() == 2 {\n+            lib::llvm::SequentiallyConsistent\n+        } else {\n+            match split[2] {\n+                \"relaxed\" => lib::llvm::Monotonic,\n+                \"acq\"     => lib::llvm::Acquire,\n+                \"rel\"     => lib::llvm::Release,\n+                \"acqrel\"  => lib::llvm::AcquireRelease,\n+                _ => ccx.sess.fatal(\"Unknown ordering in atomic intrinsic\")\n+            }\n+        };\n+\n+        match split[1] {\n+            \"cxchg\" => {\n+                let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n+                                        get_param(decl, first_real_arg + 1u),\n+                                        get_param(decl, first_real_arg + 2u),\n+                                        order);\n+                Ret(bcx, old);\n+            }\n+            \"load\" => {\n+                let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n+                                     order);\n+                Ret(bcx, old);\n+            }\n+            \"store\" => {\n+                AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n+                            get_param(decl, first_real_arg),\n+                            order);\n+                RetVoid(bcx);\n+            }\n+            \"fence\" => {\n+                AtomicFence(bcx, order);\n+                RetVoid(bcx);\n+            }\n+            op => {\n+                // These are all AtomicRMW ops\n+                let atom_op = match op {\n+                    \"xchg\"  => lib::llvm::Xchg,\n+                    \"xadd\"  => lib::llvm::Add,\n+                    \"xsub\"  => lib::llvm::Sub,\n+                    \"and\"   => lib::llvm::And,\n+                    \"nand\"  => lib::llvm::Nand,\n+                    \"or\"    => lib::llvm::Or,\n+                    \"xor\"   => lib::llvm::Xor,\n+                    \"max\"   => lib::llvm::Max,\n+                    \"min\"   => lib::llvm::Min,\n+                    \"umax\"  => lib::llvm::UMax,\n+                    \"umin\"  => lib::llvm::UMin,\n+                    _ => ccx.sess.fatal(\"Unknown atomic operation\")\n+                };\n+\n+                let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n+                                    get_param(decl, first_real_arg + 1u),\n+                                    order);\n+                Ret(bcx, old);\n+            }\n+        }\n+\n+        fcx.cleanup();\n+        return;\n+    }\n+\n+    match name {\n+        \"size_of\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)));\n+        }\n+        \"move_val\" => {\n+            // Create a datum reflecting the value being moved.\n+            // Use `appropriate_mode` so that the datum is by ref\n+            // if the value is non-immediate. Note that, with\n+            // intrinsics, there are no argument cleanups to\n+            // concern ourselves with.\n+            let tp_ty = substs.tys[0];\n+            let mode = appropriate_mode(ccx.tcx, tp_ty);\n+            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n+                             ty: tp_ty, mode: mode};\n+            bcx = src.move_to(bcx, DROP_EXISTING,\n+                              get_param(decl, first_real_arg));\n+            RetVoid(bcx);\n+        }\n+        \"move_val_init\" => {\n+            // See comments for `\"move_val\"`.\n+            let tp_ty = substs.tys[0];\n+            let mode = appropriate_mode(ccx.tcx, tp_ty);\n+            let src = Datum {val: get_param(decl, first_real_arg + 1u),\n+                             ty: tp_ty, mode: mode};\n+            bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n+            RetVoid(bcx);\n+        }\n+        \"min_align_of\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)));\n+        }\n+        \"pref_align_of\"=> {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)));\n+        }\n+        \"get_tydesc\" => {\n+            let tp_ty = substs.tys[0];\n+            let static_ti = get_tydesc(ccx, tp_ty);\n+            glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n+\n+            // FIXME (#3730): ideally this shouldn't need a cast,\n+            // but there's a circularity between translating rust types to llvm\n+            // types and having a tydesc type available. So I can't directly access\n+            // the llvm type of intrinsic::TyDesc struct.\n+            let userland_tydesc_ty = type_of::type_of(ccx, output_type);\n+            let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n+            Ret(bcx, td);\n+        }\n+        \"init\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            match bcx.fcx.llretptr {\n+                Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n+                None if ty::type_is_nil(tp_ty) => RetVoid(bcx),\n+                None => Ret(bcx, C_null(lltp_ty)),\n+            }\n+        }\n+        \"uninit\" => {\n+            // Do nothing, this is effectively a no-op\n+            let retty = substs.tys[0];\n+            if ty::type_is_immediate(ccx.tcx, retty) && !ty::type_is_nil(retty) {\n+                unsafe {\n+                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n+                }\n+            } else {\n+                RetVoid(bcx)\n+            }\n+        }\n+        \"forget\" => {\n+            RetVoid(bcx);\n+        }\n+        \"transmute\" => {\n+            let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n+            let llintype = type_of::type_of(ccx, in_type);\n+            let llouttype = type_of::type_of(ccx, out_type);\n+\n+            let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n+            let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n+            if in_type_size != out_type_size {\n+                let sp = match ccx.tcx.items.get_copy(&ref_id.unwrap()) {\n+                    ast_map::node_expr(e) => e.span,\n+                    _ => fail!(\"transmute has non-expr arg\"),\n+                };\n+                let pluralize = |n| if 1u == n { \"\" } else { \"s\" };\n+                ccx.sess.span_fatal(sp,\n+                                    fmt!(\"transmute called on types with \\\n+                                          different sizes: %s (%u bit%s) to \\\n+                                          %s (%u bit%s)\",\n+                                         ty_to_str(ccx.tcx, in_type),\n+                                         in_type_size,\n+                                         pluralize(in_type_size),\n+                                         ty_to_str(ccx.tcx, out_type),\n+                                         out_type_size,\n+                                         pluralize(out_type_size)));\n+            }\n+\n+            if !ty::type_is_voidish(out_type) {\n+                let llsrcval = get_param(decl, first_real_arg);\n+                if ty::type_is_immediate(ccx.tcx, in_type) {\n+                    match fcx.llretptr {\n+                        Some(llretptr) => {\n+                            Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n+                            RetVoid(bcx);\n+                        }\n+                        None => match (llintype.kind(), llouttype.kind()) {\n+                            (Pointer, other) | (other, Pointer) if other != Pointer => {\n+                                let tmp = Alloca(bcx, llouttype, \"\");\n+                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n+                                Ret(bcx, Load(bcx, tmp));\n+                            }\n+                            _ => Ret(bcx, BitCast(bcx, llsrcval, llouttype))\n+                        }\n+                    }\n+                } else if ty::type_is_immediate(ccx.tcx, out_type) {\n+                    let llsrcptr = PointerCast(bcx, llsrcval, llouttype.ptr_to());\n+                    Ret(bcx, Load(bcx, llsrcptr));\n+                } else {\n+                    // NB: Do not use a Load and Store here. This causes massive\n+                    // code bloat when `transmute` is used on large structural\n+                    // types.\n+                    let lldestptr = fcx.llretptr.unwrap();\n+                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n+                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n+\n+                    let llsize = llsize_of(ccx, llintype);\n+                    call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n+                    RetVoid(bcx);\n+                };\n+            } else {\n+                RetVoid(bcx);\n+            }\n+        }\n+        \"needs_drop\" => {\n+            let tp_ty = substs.tys[0];\n+            Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n+        }\n+        \"contains_managed\" => {\n+            let tp_ty = substs.tys[0];\n+            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()));\n+        }\n+        \"visit_tydesc\" => {\n+            let td = get_param(decl, first_real_arg);\n+            let visitor = get_param(decl, first_real_arg + 1u);\n+            let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n+            glue::call_tydesc_glue_full(bcx, visitor, td,\n+                                        abi::tydesc_field_visit_glue, None);\n+            RetVoid(bcx);\n+        }\n+        \"frame_address\" => {\n+            let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n+            let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n+            let star_u8 = ty::mk_imm_ptr(\n+                bcx.tcx(),\n+                ty::mk_mach_uint(ast::ty_u8));\n+            let fty = ty::mk_closure(bcx.tcx(), ty::ClosureTy {\n+                purity: ast::impure_fn,\n+                sigil: ast::BorrowedSigil,\n+                onceness: ast::Many,\n+                region: ty::re_bound(ty::br_anon(0)),\n+                bounds: ty::EmptyBuiltinBounds(),\n+                sig: FnSig {\n+                    bound_lifetime_names: opt_vec::Empty,\n+                    inputs: ~[ star_u8 ],\n+                    output: ty::mk_nil()\n+                }\n+            });\n+            let datum = Datum {val: get_param(decl, first_real_arg),\n+                               mode: ByRef(ZeroMem), ty: fty};\n+            let arg_vals = ~[frameaddress_val];\n+            bcx = trans_call_inner(\n+                bcx, None, fty, ty::mk_nil(),\n+                |bcx| Callee {bcx: bcx, data: Closure(datum)},\n+                ArgVals(arg_vals), Some(Ignore), DontAutorefArg).bcx;\n+            RetVoid(bcx);\n+        }\n+        \"morestack_addr\" => {\n+            // XXX This is a hack to grab the address of this particular\n+            // native function. There should be a general in-language\n+            // way to do this\n+            let llfty = type_of_rust_fn(bcx.ccx(), [], ty::mk_nil());\n+            let morestack_addr = decl_cdecl_fn(\n+                bcx.ccx().llmod, \"__morestack\", llfty);\n+            let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n+            Ret(bcx, morestack_addr);\n+        }\n+        \"offset\" => {\n+            let ptr = get_param(decl, first_real_arg);\n+            let offset = get_param(decl, first_real_arg + 1);\n+            Ret(bcx, GEP(bcx, ptr, [offset]));\n+        }\n+        \"offset_inbounds\" => {\n+            let ptr = get_param(decl, first_real_arg);\n+            let offset = get_param(decl, first_real_arg + 1);\n+            Ret(bcx, InBoundsGEP(bcx, ptr, [offset]));\n+        }\n+        \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n+        \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n+        \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),\n+        \"memmove64\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i64\", substs.tys[0], 64),\n+        \"memset32\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i32\", substs.tys[0], 32),\n+        \"memset64\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i64\", substs.tys[0], 64),\n+        \"sqrtf32\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f32\", 1),\n+        \"sqrtf64\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f64\", 1),\n+        \"powif32\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f32\", 2),\n+        \"powif64\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f64\", 2),\n+        \"sinf32\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f32\", 1),\n+        \"sinf64\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f64\", 1),\n+        \"cosf32\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f32\", 1),\n+        \"cosf64\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f64\", 1),\n+        \"powf32\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f32\", 2),\n+        \"powf64\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f64\", 2),\n+        \"expf32\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f32\", 1),\n+        \"expf64\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f64\", 1),\n+        \"exp2f32\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f32\", 1),\n+        \"exp2f64\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f64\", 1),\n+        \"logf32\" => simple_llvm_intrinsic(bcx, \"llvm.log.f32\", 1),\n+        \"logf64\" => simple_llvm_intrinsic(bcx, \"llvm.log.f64\", 1),\n+        \"log10f32\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f32\", 1),\n+        \"log10f64\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f64\", 1),\n+        \"log2f32\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f32\", 1),\n+        \"log2f64\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f64\", 1),\n+        \"fmaf32\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f32\", 3),\n+        \"fmaf64\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f64\", 3),\n+        \"fabsf32\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f32\", 1),\n+        \"fabsf64\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f64\", 1),\n+        \"floorf32\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f32\", 1),\n+        \"floorf64\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f64\", 1),\n+        \"ceilf32\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f32\", 1),\n+        \"ceilf64\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f64\", 1),\n+        \"truncf32\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f32\", 1),\n+        \"truncf64\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f64\", 1),\n+        \"ctpop8\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i8\", 1),\n+        \"ctpop16\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i16\", 1),\n+        \"ctpop32\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i32\", 1),\n+        \"ctpop64\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i64\", 1),\n+        \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n+        \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n+        \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),\n+        \"ctlz64\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\"),\n+        \"cttz8\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\"),\n+        \"cttz16\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\"),\n+        \"cttz32\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\"),\n+        \"cttz64\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\"),\n+        \"bswap16\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i16\", 1),\n+        \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n+        \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n+\n+        \"i8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i8\"),\n+        \"i16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i16\"),\n+        \"i32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i32\"),\n+        \"i64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i64\"),\n+\n+        \"u8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i8\"),\n+        \"u16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i16\"),\n+        \"u32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i32\"),\n+        \"u64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i64\"),\n+\n+        \"i8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i8\"),\n+        \"i16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i16\"),\n+        \"i32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i32\"),\n+        \"i64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i64\"),\n+\n+        \"u8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i8\"),\n+        \"u16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i16\"),\n+        \"u32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i32\"),\n+        \"u64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i64\"),\n+\n+        \"i8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i8\"),\n+        \"i16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i16\"),\n+        \"i32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i32\"),\n+        \"i64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i64\"),\n+\n+        \"u8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i8\"),\n+        \"u16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i16\"),\n+        \"u32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i32\"),\n+        \"u64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i64\"),\n+\n+        _ => {\n+            // Could we make this an enum rather than a string? does it get\n+            // checked earlier?\n+            ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n+        }\n+    }\n+    fcx.cleanup();\n+}"}, {"sha": "cf6d465cb820c50f230e222cac3b3f3d7f73091f", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -35,6 +35,7 @@ pub mod cabi_x86_64;\n pub mod cabi_arm;\n pub mod cabi_mips;\n pub mod foreign;\n+pub mod intrinsic;\n pub mod reflect;\n pub mod debuginfo;\n pub mod type_use;"}, {"sha": "5249a2b9b7bb642443ed9b7659d2c5afeb8ce967", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -19,12 +19,12 @@ use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::datum;\n-use middle::trans::foreign;\n use middle::trans::machine;\n use middle::trans::meth;\n use middle::trans::type_of::type_of_fn_from_ty;\n use middle::trans::type_of;\n use middle::trans::type_use;\n+use middle::trans::intrinsic;\n use middle::ty;\n use middle::ty::{FnSig};\n use middle::typeck;\n@@ -239,8 +239,8 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       }\n       ast_map::node_foreign_item(i, _, _, _) => {\n           let d = mk_lldecl();\n-          foreign::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n-                                ref_id);\n+          intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n+                                     ref_id);\n           d\n       }\n       ast_map::node_variant(ref v, enum_item, _) => {"}, {"sha": "dd1b041ef80f1aae3d49dd4012a6b087986b3464", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -284,7 +284,7 @@ impl Reflector {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfty = type_of_fn(ccx, [opaqueptrty], ty::mk_int());\n+                let llfty = type_of_rust_fn(ccx, [opaqueptrty], ty::mk_int());\n                 let llfdecl = decl_internal_cdecl_fn(ccx.llmod, sym, llfty);\n                 let fcx = new_fn_ctxt(ccx,\n                                       ~[],"}, {"sha": "6a57827e6d1c60ab3a6f2599a4c62d6ee1e17e55", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -11,6 +11,7 @@\n \n use middle::trans::adt;\n use middle::trans::common::*;\n+use middle::trans::foreign;\n use middle::ty;\n use util::ppaux;\n \n@@ -19,12 +20,16 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::opt_vec;\n \n-pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: &ty::t) -> bool {\n-    !ty::type_is_immediate(ccx.tcx, *arg_ty)\n+pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n+    !ty::type_is_immediate(ccx.tcx, arg_ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> Type {\n-    let llty = type_of(ccx, *arg_ty);\n+pub fn return_uses_outptr(tcx: ty::ctxt, ty: ty::t) -> bool {\n+    !ty::type_is_immediate(tcx, ty)\n+}\n+\n+pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: ty::t) -> Type {\n+    let llty = type_of(ccx, arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {\n         llty.ptr_to()\n     } else {\n@@ -34,17 +39,19 @@ pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> Type {\n \n pub fn type_of_explicit_args(ccx: &mut CrateContext,\n                              inputs: &[ty::t]) -> ~[Type] {\n-    inputs.map(|arg_ty| type_of_explicit_arg(ccx, arg_ty))\n+    inputs.map(|&arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n-pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Type {\n+pub fn type_of_rust_fn(cx: &mut CrateContext,\n+                       inputs: &[ty::t],\n+                       output: ty::t) -> Type {\n     let mut atys: ~[Type] = ~[];\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n-    let output_is_immediate = ty::type_is_immediate(cx.tcx, output);\n+    let use_out_pointer = return_uses_outptr(cx.tcx, output);\n     let lloutputtype = type_of(cx, output);\n-    if !output_is_immediate {\n+    if use_out_pointer {\n         atys.push(lloutputtype.ptr_to());\n     }\n \n@@ -55,7 +62,7 @@ pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Typ\n     atys.push_all(type_of_explicit_args(cx, inputs));\n \n     // Use the output as the actual return value if it's immediate.\n-    if output_is_immediate && !ty::type_is_nil(output) {\n+    if !use_out_pointer && !ty::type_is_voidish(output) {\n         Type::func(atys, &lloutputtype)\n     } else {\n         Type::func(atys, &Type::void())\n@@ -64,13 +71,21 @@ pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Typ\n \n // Given a function type and a count of ty params, construct an llvm type\n pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n-    match ty::get(fty).sty {\n-        ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n-        ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n+    return match ty::get(fty).sty {\n+        ty::ty_closure(ref f) => {\n+            type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n+        }\n+        ty::ty_bare_fn(ref f) => {\n+            if f.abis.is_rust() || f.abis.is_intrinsic() {\n+                type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n+            } else {\n+                foreign::lltype_for_foreign_fn(cx, fty)\n+            }\n+        }\n         _ => {\n             cx.sess.bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n         }\n-    }\n+    };\n }\n \n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n@@ -250,7 +265,9 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n           Type::array(&type_of(cx, mt.ty), n as u64)\n       }\n \n-      ty::ty_bare_fn(_) => type_of_fn_from_ty(cx, t).ptr_to(),\n+      ty::ty_bare_fn(_) => {\n+          type_of_fn_from_ty(cx, t).ptr_to()\n+      }\n       ty::ty_closure(_) => {\n           let ty = type_of_fn_from_ty(cx, t);\n           Type::func_pair(cx, &ty)"}, {"sha": "685699f781900e741a98d3c44516ef5df2a8cc1e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -1545,6 +1545,11 @@ pub fn subst(cx: ctxt,\n \n // Type utilities\n \n+pub fn type_is_voidish(ty: t) -> bool {\n+    //! \"nil\" and \"bot\" are void types in that they represent 0 bits of information\n+    type_is_nil(ty) || type_is_bot(ty)\n+}\n+\n pub fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n \n pub fn type_is_bot(ty: t) -> bool {"}, {"sha": "0bf0a74b2f43b764bfa262cf2d714e9dbe885282", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -68,6 +68,7 @@ pub mod middle {\n     pub mod reachable;\n     pub mod graph;\n     pub mod cfg;\n+    pub mod stack_check;\n }\n \n pub mod front {"}, {"sha": "5ba52326579e1b1d820218f1b83e0df5f663d3d1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -862,3 +862,15 @@ impl UserString for ty::t {\n         ty_to_str(tcx, *self)\n     }\n }\n+\n+impl Repr for AbiSet {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        self.to_str()\n+    }\n+}\n+\n+impl UserString for AbiSet {\n+    fn user_string(&self, _tcx: ctxt) -> ~str {\n+        self.to_str()\n+    }\n+}"}, {"sha": "be6871ae6ffa7657e2a96dd5d32d4302608b0480", "filename": "src/test/compile-fail/warn-foreign-int-types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern:libc::c_int or libc::c_long should be used\n+#[forbid(ctypes)];\n+\n mod xx {\n     extern {\n-        pub fn strlen(str: *u8) -> uint;\n-        pub fn foo(x: int, y: uint);\n+        pub fn strlen(str: *u8) -> uint; //~ ERROR found rust type `uint`\n+        pub fn foo(x: int, y: uint); //~ ERROR found rust type `int`\n+        //~^ ERROR found rust type `uint`\n     }\n }\n \n fn main() {\n-  // let it fail to verify warning message\n-  fail!()\n }"}, {"sha": "ba671a1c4949f3bf82ea231708f881591fcbcd9b", "filename": "src/test/run-pass/extern-return-TwoU16s.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-win32 #5745\n-// xfail-macos Broken on mac i686\n-\n struct TwoU16s {\n     one: u16, two: u16\n }"}, {"sha": "5d2fd14075844f46379e416535bd9445d590e38f", "filename": "src/test/run-pass/extern-return-TwoU8s.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-win32 #5745\n-// xfail-macos Broken on mac i686\n-\n struct TwoU8s {\n     one: u8, two: u8\n }"}, {"sha": "1e5ea7126e4403396c409eac4f34335c2457d53b", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303f650ecfb5580f3d89aa662fbd164b849c8eff/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=303f650ecfb5580f3d89aa662fbd164b849c8eff", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test - FIXME(#8538) some kind of problem linking induced by extern \"C\" fns that I do not understand\n // xfail-fast - windows doesn't like this\n \n // Smallest hello world with no runtime"}]}