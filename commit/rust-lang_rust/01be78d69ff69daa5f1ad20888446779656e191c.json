{"sha": "01be78d69ff69daa5f1ad20888446779656e191c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYmU3OGQ2OWZmNjlkYWE1ZjFhZDIwODg4NDQ2Nzc5NjU2ZTE5MWM=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2019-04-05T18:46:30Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2019-04-08T21:22:31Z"}, "message": "Add Waker::wake_by_ref and make Waker::wake consume the Waker", "tree": {"sha": "ff61399e5a66fef387848c1ddb43f89c8330c861", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff61399e5a66fef387848c1ddb43f89c8330c861"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01be78d69ff69daa5f1ad20888446779656e191c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01be78d69ff69daa5f1ad20888446779656e191c", "html_url": "https://github.com/rust-lang/rust/commit/01be78d69ff69daa5f1ad20888446779656e191c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01be78d69ff69daa5f1ad20888446779656e191c/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3750348daff89741e3153e0e120aa70a45ff5b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/3750348daff89741e3153e0e120aa70a45ff5b68", "html_url": "https://github.com/rust-lang/rust/commit/3750348daff89741e3153e0e120aa70a45ff5b68"}], "stats": {"total": 92, "additions": 73, "deletions": 19}, "files": [{"sha": "085695b902262cf0e1e3aac6028db601bb81332c", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/01be78d69ff69daa5f1ad20888446779656e191c/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01be78d69ff69daa5f1ad20888446779656e191c/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=01be78d69ff69daa5f1ad20888446779656e191c", "patch": "@@ -72,10 +72,18 @@ pub struct RawWakerVTable {\n     /// This function will be called when `wake` is called on the [`Waker`].\n     /// It must wake up the task associated with this [`RawWaker`].\n     ///\n-    /// The implemention of this function must not consume the provided data\n-    /// pointer.\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n+    /// associated task.\n     wake: unsafe fn(*const ()),\n \n+    /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n+    ///\n+    /// This function is similar to `wake`, but must not consume the provided data\n+    /// pointer.\n+    wake_by_ref: unsafe fn(*const ()),\n+\n     /// This function gets called when a [`RawWaker`] gets dropped.\n     ///\n     /// The implementation of this function must make sure to release any\n@@ -85,8 +93,8 @@ pub struct RawWakerVTable {\n }\n \n impl RawWakerVTable {\n-    /// Creates a new `RawWakerVTable` from the provided `clone`, `wake`, and\n-    /// `drop` functions.\n+    /// Creates a new `RawWakerVTable` from the provided `clone`, `wake`,\n+    /// `wake_by_ref`, and `drop` functions.\n     ///\n     /// # `clone`\n     ///\n@@ -103,7 +111,16 @@ impl RawWakerVTable {\n     /// This function will be called when `wake` is called on the [`Waker`].\n     /// It must wake up the task associated with this [`RawWaker`].\n     ///\n-    /// The implemention of this function must not consume the provided data\n+    /// The implementation of this function must make sure to release any\n+    /// resources that are associated with this instance of a [`RawWaker`] and\n+    /// associated task.\n+    ///\n+    /// # `wake_by_ref`\n+    ///\n+    /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n+    /// It must wake up the task associated with this [`RawWaker`].\n+    ///\n+    /// This function is similar to `wake`, but must not consume the provided data\n     /// pointer.\n     ///\n     /// # `drop`\n@@ -120,11 +137,13 @@ impl RawWakerVTable {\n     pub const fn new(\n         clone: unsafe fn(*const ()) -> RawWaker,\n         wake: unsafe fn(*const ()),\n+        wake_by_ref: unsafe fn(*const ()),\n         drop: unsafe fn(*const ()),\n     ) -> Self {\n         Self {\n             clone,\n             wake,\n+            wake_by_ref,\n             drop,\n         }\n     }\n@@ -187,14 +206,33 @@ unsafe impl Sync for Waker {}\n impl Waker {\n     /// Wake up the task associated with this `Waker`.\n     #[inline]\n-    pub fn wake(&self) {\n+    pub fn wake(self) {\n         // The actual wakeup call is delegated through a virtual function call\n         // to the implementation which is defined by the executor.\n+        let wake = self.waker.vtable.wake;\n+        let data = self.waker.data;\n+\n+        // Don't call `drop` -- the waker will be consumed by `wake`.\n+        crate::mem::forget(self);\n \n         // SAFETY: This is safe because `Waker::new_unchecked` is the only way\n         // to initialize `wake` and `data` requiring the user to acknowledge\n         // that the contract of `RawWaker` is upheld.\n-        unsafe { (self.waker.vtable.wake)(self.waker.data) }\n+        unsafe { (wake)(data) };\n+    }\n+\n+    /// Wake up the task associated with this `Waker` without consuming the `Waker`.\n+    ///\n+    /// This is similar to `wake`, but may be slightly less efficient in the case\n+    /// where an owned `Waker` is available. This method should be preferred to\n+    /// calling `waker.clone().wake()`.\n+    #[inline]\n+    pub fn wake_by_ref(&self) {\n+        // The actual wakeup call is delegated through a virtual function call\n+        // to the implementation which is defined by the executor.\n+\n+        // SAFETY: see `wake`\n+        unsafe { (self.waker.vtable.wake_by_ref)(self.waker.data) }\n     }\n \n     /// Returns `true` if this `Waker` and another `Waker` have awoken the same task."}, {"sha": "518452aefc15256067e1255b7a0cb96f0605d576", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/01be78d69ff69daa5f1ad20888446779656e191c/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01be78d69ff69daa5f1ad20888446779656e191c/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=01be78d69ff69daa5f1ad20888446779656e191c", "patch": "@@ -19,7 +19,10 @@ struct Counter {\n }\n \n impl ArcWake for Counter {\n-    fn wake(arc_self: &Arc<Self>) {\n+    fn wake(self: Arc<Self>) {\n+        Self::wake_by_ref(&self)\n+    }\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n         arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n@@ -34,7 +37,7 @@ impl Future for WakeOnceThenComplete {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n-            cx.waker().wake();\n+            cx.waker().wake_by_ref();\n             self.0 = true;\n             Poll::Pending\n         }"}, {"sha": "d573a866cab3315cbfd39ea5dea66cfcfde9d7d3", "filename": "src/test/run-pass/auxiliary/arc_wake.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01be78d69ff69daa5f1ad20888446779656e191c/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01be78d69ff69daa5f1ad20888446779656e191c/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Farc_wake.rs?ref=01be78d69ff69daa5f1ad20888446779656e191c", "patch": "@@ -12,25 +12,30 @@ macro_rules! waker_vtable {\n         &RawWakerVTable::new(\n             clone_arc_raw::<$ty>,\n             wake_arc_raw::<$ty>,\n+            wake_by_ref_arc_raw::<$ty>,\n             drop_arc_raw::<$ty>,\n         )\n     };\n }\n \n pub trait ArcWake {\n-    fn wake(arc_self: &Arc<Self>);\n+    fn wake(self: Arc<Self>);\n+\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n+        arc_self.clone().wake()\n+    }\n \n     fn into_waker(wake: Arc<Self>) -> Waker where Self: Sized\n     {\n-        let ptr = Arc::into_raw(wake) as *const();\n+        let ptr = Arc::into_raw(wake) as *const ();\n \n         unsafe {\n             Waker::new_unchecked(RawWaker::new(ptr, waker_vtable!(Self)))\n         }\n     }\n }\n \n-unsafe fn increase_refcount<T: ArcWake>(data: *const()) {\n+unsafe fn increase_refcount<T: ArcWake>(data: *const ()) {\n     // Retain Arc by creating a copy\n     let arc: Arc<T> = Arc::from_raw(data as *const T);\n     let arc_clone = arc.clone();\n@@ -39,18 +44,23 @@ unsafe fn increase_refcount<T: ArcWake>(data: *const()) {\n     let _ = Arc::into_raw(arc_clone);\n }\n \n-unsafe fn clone_arc_raw<T: ArcWake>(data: *const()) -> RawWaker {\n+unsafe fn clone_arc_raw<T: ArcWake>(data: *const ()) -> RawWaker {\n     increase_refcount::<T>(data);\n     RawWaker::new(data, waker_vtable!(T))\n }\n \n-unsafe fn drop_arc_raw<T: ArcWake>(data: *const()) {\n+unsafe fn drop_arc_raw<T: ArcWake>(data: *const ()) {\n     // Drop Arc\n     let _: Arc<T> = Arc::from_raw(data as *const T);\n }\n \n-unsafe fn wake_arc_raw<T: ArcWake>(data: *const()) {\n+unsafe fn wake_arc_raw<T: ArcWake>(data: *const ()) {\n+    let arc: Arc<T> = Arc::from_raw(data as *const T);\n+    ArcWake::wake(arc);\n+}\n+\n+unsafe fn wake_by_ref_arc_raw<T: ArcWake>(data: *const ()) {\n     let arc: Arc<T> = Arc::from_raw(data as *const T);\n-    ArcWake::wake(&arc);\n+    ArcWake::wake_by_ref(&arc);\n     let _ = Arc::into_raw(arc);\n }"}, {"sha": "6094f15569bb60a43a9f9d3119278db8cad720d8", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01be78d69ff69daa5f1ad20888446779656e191c/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01be78d69ff69daa5f1ad20888446779656e191c/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=01be78d69ff69daa5f1ad20888446779656e191c", "patch": "@@ -20,7 +20,10 @@ struct Counter {\n }\n \n impl ArcWake for Counter {\n-    fn wake(arc_self: &Arc<Self>) {\n+    fn wake(self: Arc<Self>) {\n+        Self::wake_by_ref(&self)\n+    }\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n         arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n     }\n }\n@@ -32,8 +35,8 @@ impl Future for MyFuture {\n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         // Wake twice\n         let waker = cx.waker();\n-        waker.wake();\n-        waker.wake();\n+        waker.wake_by_ref();\n+        waker.wake_by_ref();\n         Poll::Ready(())\n     }\n }"}]}