{"sha": "ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f", "node_id": "C_kwDOAAsO6NoAKGVmM2FhYTFmMjEwYjJlNzJjMTZhOWE4ODBhZTNkMWZkNjA2MWZjOWY", "commit": {"author": {"name": "Ellis Hoag", "email": "ellis.sparky.hoag@gmail.com", "date": "2022-09-11T23:43:18Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2023-03-01T00:13:18Z"}, "message": "Add monomorphization errors", "tree": {"sha": "5efe0643b7826df2eb8ba99c34fcfbae5b824134", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5efe0643b7826df2eb8ba99c34fcfbae5b824134"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f", "html_url": "https://github.com/rust-lang/rust/commit/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f/comments", "author": {"login": "ellishg", "id": 8961915, "node_id": "MDQ6VXNlcjg5NjE5MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8961915?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ellishg", "html_url": "https://github.com/ellishg", "followers_url": "https://api.github.com/users/ellishg/followers", "following_url": "https://api.github.com/users/ellishg/following{/other_user}", "gists_url": "https://api.github.com/users/ellishg/gists{/gist_id}", "starred_url": "https://api.github.com/users/ellishg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ellishg/subscriptions", "organizations_url": "https://api.github.com/users/ellishg/orgs", "repos_url": "https://api.github.com/users/ellishg/repos", "events_url": "https://api.github.com/users/ellishg/events{/privacy}", "received_events_url": "https://api.github.com/users/ellishg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f21041d7c3eb68ecbb3b06b4878071e30d387f9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f21041d7c3eb68ecbb3b06b4878071e30d387f9d", "html_url": "https://github.com/rust-lang/rust/commit/f21041d7c3eb68ecbb3b06b4878071e30d387f9d"}], "stats": {"total": 418, "additions": 271, "deletions": 147}, "files": [{"sha": "a70ebf62da3e91f0215cc3ad0e8bef999c673105", "filename": "src/errors.rs", "status": "modified", "additions": 197, "deletions": 1, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f/src%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f/src%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferrors.rs?ref=ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f", "patch": "@@ -1,6 +1,7 @@\n use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_macros::SessionDiagnostic;\n-use rustc_span::Span;\n+use rustc_middle::ty::Ty;\n+use rustc_span::{Span, Symbol};\n use std::borrow::Cow;\n \n struct ExitCode {\n@@ -29,6 +30,201 @@ impl RanlibFailure {\n     }\n }\n \n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_basic_integer, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: &'a str,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_not_float, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unrecognized, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnrecognized {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: Ty<'a>,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub elem_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+    pub expected_int_bits: u64,\n+    pub expected_bytes: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_simd, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub position: &'a str,\n+    pub found_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mask_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_inserted_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub m_len: u64,\n+    pub v_len: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_elem: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+}\n+\n #[derive(SessionDiagnostic)]\n #[diag(codegen_gcc::layout_size_overflow)]\n pub(crate) struct LayoutSizeOverflow {"}, {"sha": "bdeede2ab5e64fbc6fcf8541f42dba14e3962d34", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f", "patch": "@@ -7,7 +7,7 @@ use std::iter;\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n-use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n@@ -31,6 +31,7 @@ use crate::abi::FnAbiGccExt;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMonomorphizationBasicInteger;\n use crate::type_of::LayoutGccExt;\n use crate::intrinsic::simd::generic_simd_intrinsic;\n \n@@ -253,15 +254,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                 _ => bug!(),\n                             },\n                             None => {\n-                                span_invalid_monomorphization_error(\n-                                    tcx.sess,\n-                                    span,\n-                                    &format!(\n-                                        \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                      name, ty\n-                                    ),\n-                                );\n+                                tcx.sess.emit_err(InvalidMonomorphizationBasicInteger { span, name, ty });\n                                 return;\n                             }\n                         }"}, {"sha": "f95db2271b33f6750688257d04e5071d22aa70ca", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 71, "deletions": 136, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=ef3aaa1f210b2e72c16a9a880ae3d1fd6061fc9f", "patch": "@@ -2,7 +2,7 @@\n use gccjit::{ToRValue, ComparisonOp, UnaryOp};\n use gccjit::{BinaryOp, RValue, Type};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::{IntPredicate, TypeKind, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -16,42 +16,46 @@ use rustc_target::abi::Align;\n use crate::builder::Builder;\n #[cfg(feature=\"master\")]\n use crate::context::CodegenCx;\n+use crate::errors::{\n+    InvalidMonomorphizationInvalidFloatVector,\n+    InvalidMonomorphizationNotFloat,\n+    InvalidMonomorphizationUnrecognized,\n+    InvalidMonomorphizationExpectedSignedUnsigned,\n+    InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationSimdShuffle,\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationMaskType,\n+    InvalidMonomorphizationReturnLength,\n+    InvalidMonomorphizationReturnLengthInputType,\n+    InvalidMonomorphizationReturnElement,\n+    InvalidMonomorphizationReturnType,\n+    InvalidMonomorphizationInsertedType,\n+    InvalidMonomorphizationReturnIntegerType,\n+    InvalidMonomorphizationMismatchedLengths,\n+    InvalidMonomorphizationUnsupportedOperation\n+};\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n+        ($err:expr) => {\n             {\n-                emit_error!($($fmt)*);\n+                bx.sess().emit_err($err);\n                 return Err(());\n             }\n         }\n     }\n-\n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond:expr, $err:expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($err);\n             }\n-        };\n+        }\n     }\n-\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+            require!($ty.is_simd(), InvalidMonomorphizationExpectedSimd { span, name, position: $position, found_ty: $ty })\n         };\n     }\n \n@@ -83,10 +87,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n             _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n-                mask_ty,\n-                expected_int_bits,\n-                expected_bytes\n+                InvalidMonomorphizationInvalidBitmask { span, name, ty: mask_ty, expected_int_bits, expected_bytes }\n             ),\n         };\n \n@@ -133,18 +134,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnIntegerType {span, name, ret_ty, out_ty}\n         );\n \n         return Ok(compare_simd_types(\n@@ -169,8 +163,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         })\n                     }\n                     _ => return_error!(\n-                        \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                        args[2].layout.ty\n+                        InvalidMonomorphizationSimdShuffle { span, name, ty: args[2].layout.ty }\n                     ),\n                 }\n             }\n@@ -185,19 +178,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let vector = args[2].immediate();\n@@ -213,10 +198,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphizationInsertedType { span, name, in_elem, in_ty, out_ty: arg_tys[2] }\n         );\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n@@ -233,10 +215,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         let vector = args[0].immediate();\n         return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n@@ -249,13 +228,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphizationMismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphizationMaskType { span, name, ty: m_elem_ty }),\n         }\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n@@ -266,12 +243,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -322,10 +294,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -403,40 +372,28 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         span: Span,\n         args: &[OperandRef<'tcx, RValue<'gcc>>],\n     ) -> Result<RValue<'gcc>, ()> {\n-        macro_rules! emit_error {\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n+            ($err:expr) => {\n                 {\n-                    emit_error!($($fmt)*);\n+                    bx.sess().emit_err($err);\n                     return Err(());\n                 }\n             }\n         }\n-\n         let (elem_ty_str, elem_ty) =\n             if let ty::Float(f) = in_elem.kind() {\n                 let elem_ty = bx.cx.type_float_from_ty(*f);\n                 match f.bit_width() {\n                     32 => (\"f\", elem_ty),\n                     64 => (\"\", elem_ty),\n                     _ => {\n-                        return_error!(\n-                            \"unsupported element type `{}` of floating-point vector `{}`\",\n-                            f.name_str(),\n-                            in_ty\n-                        );\n+                        // Can we pass elem_ty directly?\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n                     }\n                 }\n             }\n             else {\n-                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n             };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n@@ -459,7 +416,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 sym::simd_fsqrt => \"sqrt\",\n                 sym::simd_round => \"round\",\n                 sym::simd_trunc => \"trunc\",\n-                _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n             };\n         let builtin_name = format!(\"{}{}\", intr_name, elem_ty_str);\n         let funcs = bx.cx.functions.borrow();\n@@ -813,10 +770,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -836,13 +790,25 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_int_from_ty(i)),\n                 ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_uint_from_ty(i)),\n                 _ => {\n-                    return_error!(\n-                        \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                     arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                     arg_tys[0]\n-                    );\n-                }\n+                return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n+                    span,\n+                    name,\n+                    elem_ty: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vec_ty: arg_tys[0],\n+                });\n+            }\n+        };\n+        let builtin_name =\n+            match (signed, is_add, in_len, elem_width) {\n+                (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n+                (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n+                (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n+                (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n+                (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n+                (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n+                (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n+                (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n+                _ => unimplemented!(\"signed: {}, is_add: {}, in_len: {}, elem_width: {}\", signed, is_add, in_len, elem_width),\n             };\n \n         let result =\n@@ -924,10 +890,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -951,13 +914,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -998,21 +955,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => Ok(bx.$int_red(args[0].immediate())),\n                     ty::Float(_) => Ok(bx.$float_red(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -1030,22 +978,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n-                            in_ty,\n-                            in_elem,\n-                            ret_ty\n-                        ),\n+                        _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                     }\n \n                     args[0].immediate()\n@@ -1056,11 +995,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         Ok(if !$boolean { r } else { bx.icmp(IntPredicate::IntNE, r, bx.context.new_rvalue_zero(r.get_type())) })\n                     }\n                     _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n+                        InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }\n                     ),\n                 };\n             }"}]}