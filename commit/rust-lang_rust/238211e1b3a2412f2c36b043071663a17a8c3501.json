{"sha": "238211e1b3a2412f2c36b043071663a17a8c3501", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzODIxMWUxYjNhMjQxMmYyYzM2YjA0MzA3MTY2M2ExN2E4YzM1MDE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-25T23:40:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-30T17:41:38Z"}, "message": "implement TLS", "tree": {"sha": "0f6c5e5fa499a1e232da575db58274dabe0f0782", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f6c5e5fa499a1e232da575db58274dabe0f0782"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/238211e1b3a2412f2c36b043071663a17a8c3501", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/238211e1b3a2412f2c36b043071663a17a8c3501", "html_url": "https://github.com/rust-lang/rust/commit/238211e1b3a2412f2c36b043071663a17a8c3501", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/238211e1b3a2412f2c36b043071663a17a8c3501/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "452cc9b396507dc94e2047cb4d2ad843b23eccc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/452cc9b396507dc94e2047cb4d2ad843b23eccc7", "html_url": "https://github.com/rust-lang/rust/commit/452cc9b396507dc94e2047cb4d2ad843b23eccc7"}], "stats": {"total": 132, "additions": 110, "deletions": 22}, "files": [{"sha": "25d939be3ab3fbbca4e7eb788e143b340a0c4018", "filename": "src/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/238211e1b3a2412f2c36b043071663a17a8c3501/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/238211e1b3a2412f2c36b043071663a17a8c3501/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=238211e1b3a2412f2c36b043071663a17a8c3501", "patch": "@@ -38,6 +38,8 @@ pub enum EvalError<'tcx> {\n     },\n     ExecutionTimeLimitReached,\n     StackFrameLimitReached,\n+    OutOfTls,\n+    TlsOutOfBounds,\n     AlignmentCheckFailed {\n         required: u64,\n         has: u64,\n@@ -101,6 +103,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"reached the configured maximum execution time\",\n             EvalError::StackFrameLimitReached =>\n                 \"reached the configured maximum number of stack frames\",\n+            EvalError::OutOfTls =>\n+                \"reached the maximum number of representable TLS keys\",\n+            EvalError::TlsOutOfBounds =>\n+                \"accessed an invalid (unallocated) TLS key\",\n             EvalError::AlignmentCheckFailed{..} =>\n                 \"tried to execute a misaligned read or write\",\n             EvalError::CalledClosureAsFunction =>"}, {"sha": "bb5a1d6f26905bb5a3d0de97c7e7a61f4e05a3e3", "filename": "src/memory.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/238211e1b3a2412f2c36b043071663a17a8c3501/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/238211e1b3a2412f2c36b043071663a17a8c3501/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=238211e1b3a2412f2c36b043071663a17a8c3501", "patch": "@@ -15,6 +15,8 @@ use value::PrimVal;\n #[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n pub struct AllocId(pub u64);\n \n+pub type TlsKey = usize;\n+\n impl fmt::Display for AllocId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.0)\n@@ -149,6 +151,12 @@ pub struct Memory<'a, 'tcx> {\n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n+    \n+    /// pthreads-style Thread-local storage.  We only have one thread, so this is just a map from TLS keys (indices into the vector) to the pointer stored there.\n+    thread_local: HashMap<TlsKey, Pointer>,\n+\n+    /// The Key to use for the next thread-local allocation.\n+    next_thread_local: TlsKey,\n }\n \n const ZST_ALLOC_ID: AllocId = AllocId(0);\n@@ -167,6 +175,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             packed: BTreeSet::new(),\n             static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n+            thread_local: HashMap::new(),\n+            next_thread_local: 0,\n         }\n     }\n \n@@ -345,6 +355,45 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub(crate) fn clear_packed(&mut self) {\n         self.packed.clear();\n     }\n+\n+    pub(crate) fn create_tls_key(&mut self) -> TlsKey {\n+        let new_key = self.next_thread_local;\n+        self.next_thread_local += 1;\n+        self.thread_local.insert(new_key, Pointer::from_int(0));\n+        trace!(\"New TLS key allocated: {}\", new_key);\n+        return new_key;\n+    }\n+\n+    pub(crate) fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n+        return match self.thread_local.remove(&key) {\n+            Some(_) => {\n+                trace!(\"TLS key {} removed\", key);\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n+        return match self.thread_local.get(&key) {\n+            Some(&ptr) => {\n+                trace!(\"TLS key {} loaded: {:?}\", key, ptr);\n+                Ok(ptr)\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    pub(crate) fn store_tls(&mut self, key: TlsKey, new_ptr: Pointer) -> EvalResult<'tcx> {\n+        return match self.thread_local.get_mut(&key) {\n+            Some(ptr) => {\n+                trace!(\"TLS key {} stored: {:?}\", key, new_ptr);\n+                *ptr = new_ptr;\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n }\n \n // The derived `Ord` impl sorts first by the first field, then, if the fields are the same"}, {"sha": "94a221b32c77428dd32d2bbcdd5962fd05e32046", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/238211e1b3a2412f2c36b043071663a17a8c3501/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/238211e1b3a2412f2c36b043071663a17a8c3501/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=238211e1b3a2412f2c36b043071663a17a8c3501", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, TypeVariants, Ty, TyS, TypeAndMut};\n use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n use syntax::attr;\n@@ -9,7 +9,7 @@ use syntax::abi::Abi;\n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::Pointer;\n+use memory::{Pointer, TlsKey};\n use value::PrimVal;\n use value::Value;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -367,18 +367,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         // Only trait methods can have a Self parameter.\n \n-        // Intercept some methods (even if we can find MIR for them)\n-        if let ty::InstanceDef::Item(def_id) = instance.def {\n-            match &self.tcx.item_path_str(def_id)[..] {\n-                \"std::sys::imp::fast_thread_local::register_dtor\" => {\n-                    // Just don't execute this one, we don't handle all this thread-local stuff anyway.\n-                    self.goto_block(destination.unwrap().1);\n-                    return Ok(true)\n-                }\n-                _ => {}\n-            }\n-        }\n-        \n         let mir = match self.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError::NoMirFor(path)) => {\n@@ -480,7 +468,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn call_c_abi(\n         &mut self,\n         def_id: DefId,\n-        args: &[mir::Operand<'tcx>],\n+        arg_operands: &[mir::Operand<'tcx>],\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -490,7 +478,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             .unwrap_or(name)\n             .as_str();\n \n-        let args_res: EvalResult<Vec<Value>> = args.iter()\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n         let args = args_res?;\n@@ -555,9 +543,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(num - idx as u64 - 1);\n-                    self.write_value(Value::ByVal(PrimVal::Ptr(new_ptr)), dest, dest_ty)?;\n+                    self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n-                    self.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, dest_ty)?;\n+                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 }\n             }\n \n@@ -567,9 +555,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n                     let new_ptr = ptr.offset(idx as u64);\n-                    self.write_value(Value::ByVal(PrimVal::Ptr(new_ptr)), dest, dest_ty)?;\n+                    self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n                 } else {\n-                    self.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, dest_ty)?;\n+                    self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n                 }\n             }\n \n@@ -579,7 +567,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     info!(\"ignored env var request for `{:?}`\", ::std::str::from_utf8(name));\n                 }\n-                self.write_value(Value::ByVal(PrimVal::Bytes(0)), dest, dest_ty)?;\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n             }\n             \n             \"write\" => {\n@@ -605,9 +593,54 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n             }\n \n+            // Hook pthread calls that go to the thread-local storage memory subsystem\n+            \"pthread_key_create\" => {\n+                let key = self.memory.create_tls_key();\n+                let key_ptr = args[0].read_ptr(&self.memory)?;\n+\n+                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n+                let key_size = match self.operand_ty(&arg_operands[0]) {\n+                    &TyS { sty: TypeVariants::TyRawPtr(TypeAndMut { ty, .. }), .. } => {\n+                        let layout = self.type_layout(ty)?;\n+                        layout.size(&self.tcx.data_layout)\n+                    }\n+                    _ => return Err(EvalError::Unimplemented(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))\n+                };\n+                \n+                // Write the key into the memory where key_ptr wants it\n+                if key >= (1 << key_size.bits()) {\n+                    return Err(EvalError::OutOfTls);\n+                }\n+                self.memory.write_int(key_ptr, key as i128, key_size.bytes())?;\n+                \n+                // Return success (0)\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+            \"pthread_key_delete\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                self.memory.delete_tls_key(key)?;\n+                // Return success (0)\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+            \"pthread_getspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let ptr = self.memory.load_tls(key)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"pthread_setspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let new_ptr = args[1].read_ptr(&self.memory)?;\n+                self.memory.store_tls(key, new_ptr)?;\n+                \n+                // Return success (0)\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+\n             link_name if link_name.starts_with(\"pthread_\") => {\n                 warn!(\"ignoring C ABI call: {}\", link_name);\n-                return Ok(());\n             },\n \n             _ => {"}]}