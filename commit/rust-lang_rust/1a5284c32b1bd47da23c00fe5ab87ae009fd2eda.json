{"sha": "1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNTI4NGMzMmIxYmQ0N2RhMjNjMDBmZTVhYjg3YWUwMDlmZDJlZGE=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-05-03T01:21:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-03T01:21:17Z"}, "message": "Rollup merge of #41217 - topecongiro:docs/atomic-fence, r=steveklabnik\n\nUpdate docs of 'fence'\n\nThis PR updates the docs for `std::sync::atomic::fence` with an example and a diagram.\nPart of #29377.\nr? @steveklabnik", "tree": {"sha": "28dc3d53f017f91da463fde9b19ac4b97537782a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28dc3d53f017f91da463fde9b19ac4b97537782a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "html_url": "https://github.com/rust-lang/rust/commit/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d81b14b80a076fa249a4b7022688c600f2e9590", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d81b14b80a076fa249a4b7022688c600f2e9590", "html_url": "https://github.com/rust-lang/rust/commit/4d81b14b80a076fa249a4b7022688c600f2e9590"}, {"sha": "91a9866bb33c39c2dabcc2e61ca2986a79b9a076", "url": "https://api.github.com/repos/rust-lang/rust/commits/91a9866bb33c39c2dabcc2e61ca2986a79b9a076", "html_url": "https://github.com/rust-lang/rust/commit/91a9866bb33c39c2dabcc2e61ca2986a79b9a076"}], "stats": {"total": 55, "additions": 52, "deletions": 3}, "files": [{"sha": "c13fd5583543e6f7b43928eda2cd23df67984485", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a5284c32b1bd47da23c00fe5ab87ae009fd2eda/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=1a5284c32b1bd47da23c00fe5ab87ae009fd2eda", "patch": "@@ -1573,12 +1573,30 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// An atomic fence.\n ///\n-/// A fence 'A' which has [`Release`] ordering semantics, synchronizes with a\n-/// fence 'B' with (at least) [`Acquire`] semantics, if and only if there exists\n-/// atomic operations X and Y, both operating on some atomic object 'M' such\n+/// Depending on the specified order, a fence prevents the compiler and CPU from\n+/// reordering certain types of memory operations around it.\n+/// That creates synchronizes-with relationships between it and atomic operations\n+/// or fences in other threads.\n+///\n+/// A fence 'A' which has (at least) [`Release`] ordering semantics, synchronizes\n+/// with a fence 'B' with (at least) [`Acquire`] semantics, if and only if there\n+/// exist operations X and Y, both operating on some atomic object 'M' such\n /// that A is sequenced before X, Y is synchronized before B and Y observes\n /// the change to M. This provides a happens-before dependence between A and B.\n ///\n+/// ```text\n+///     Thread 1                                          Thread 2\n+///\n+/// fence(Release);      A --------------\n+/// x.store(3, Relaxed); X ---------    |\n+///                                |    |\n+///                                |    |\n+///                                -------------> Y  if x.load(Relaxed) == 3 {\n+///                                     |-------> B      fence(Acquire);\n+///                                                      ...\n+///                                                  }\n+/// ```\n+///\n /// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n /// with a fence.\n ///\n@@ -1592,6 +1610,37 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n ///\n /// Panics if `order` is [`Relaxed`].\n ///\n+/// # Examples\n+///\n+/// ```\n+/// use std::sync::atomic::AtomicBool;\n+/// use std::sync::atomic::fence;\n+/// use std::sync::atomic::Ordering;\n+///\n+/// // A mutual exclusion primitive based on spinlock.\n+/// pub struct Mutex {\n+///     flag: AtomicBool,\n+/// }\n+///\n+/// impl Mutex {\n+///     pub fn new() -> Mutex {\n+///         Mutex {\n+///             flag: AtomicBool::new(false),\n+///         }\n+///     }\n+///\n+///     pub fn lock(&self) {\n+///         while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n+///         // This fence syncronizes-with store in `unlock`.\n+///         fence(Ordering::Acquire);\n+///     }\n+///\n+///     pub fn unlock(&self) {\n+///         self.flag.store(false, Ordering::Release);\n+///     }\n+/// }\n+/// ```\n+///\n /// [`Ordering`]: enum.Ordering.html\n /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst"}]}