{"sha": "b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NjkwYThjMzVlOWFmYTNlMGY2NTE0MGNjNjlkNGJhMWI5ZTc4YzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-11T07:36:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-11T07:36:59Z"}, "message": "Auto merge of #68961 - eddyb:dbg-stack-dunk, r=nagisa\n\nrustc_codegen_ssa: only \"spill\" SSA-like values to the stack for debuginfo.\n\nThis is an implementation of the idea described in https://github.com/rust-lang/rust/issues/68817#issuecomment-583719182.\n\nIn short, instead of debuginfo forcing otherwise-SSA-like MIR locals into `alloca`s, and requiring a `load` for each use (or two, for scalar pairs), the `alloca` is now *only* used for attaching debuginfo with `llvm.dbg.declare`: the `OperandRef` is stored to the `alloca`, but *never loaded* from it.\n\nOutside of `debug_introduce_local`, nothing cares about the debuginfo-only `alloca`, and instead works with `OperandRef` the same as MIR locals without debuginfo before this PR.\n\nThis should have some of the benefits of `llvm.dbg.value`, while working today.\n\ncc @nagisa @nikomatsakis", "tree": {"sha": "038abc30010b3400090a949e420260c92428fb92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038abc30010b3400090a949e420260c92428fb92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "html_url": "https://github.com/rust-lang/rust/commit/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc4242d9052a42cdf329c3a2430d02a3b3d415cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4242d9052a42cdf329c3a2430d02a3b3d415cb", "html_url": "https://github.com/rust-lang/rust/commit/dc4242d9052a42cdf329c3a2430d02a3b3d415cb"}, {"sha": "1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a", "html_url": "https://github.com/rust-lang/rust/commit/1a8f5efab8ccd9d5f6ac794ab1bcf90b5efa536a"}], "stats": {"total": 79, "additions": 41, "deletions": 38}, "files": [{"sha": "7bf222f4701b7ea70a8d1a52b44b929df7a7782b", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "patch": "@@ -8,7 +8,6 @@ use rustc::mir::visit::{\n     MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext, Visitor,\n };\n use rustc::mir::{self, Location, TerminatorKind};\n-use rustc::session::config::DebugInfo;\n use rustc::ty;\n use rustc::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_data_structures::graph::dominators::Dominators;\n@@ -24,15 +23,6 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     analyzer.visit_body(mir);\n \n     for (local, decl) in mir.local_decls.iter_enumerated() {\n-        // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n-        // of putting everything in allocas just so we can use llvm.dbg.declare.\n-        if fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n-            if fx.mir.local_kind(local) == mir::LocalKind::Arg {\n-                analyzer.not_ssa(local);\n-                continue;\n-            }\n-        }\n-\n         let ty = fx.monomorphize(&decl.ty);\n         debug!(\"local {:?} has type `{}`\", local, ty);\n         let layout = fx.cx.spanned_layout_of(ty, decl.source_info.span);\n@@ -281,15 +271,6 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                 self.assign(local, location);\n             }\n \n-            PlaceContext::NonUse(NonUseContext::VarDebugInfo) => {\n-                // We need to keep locals in `alloca`s for debuginfo.\n-                // FIXME(eddyb): We should figure out how to use `llvm.dbg.value` instead\n-                // of putting everything in allocas just so we can use `llvm.dbg.declare`.\n-                if self.fx.cx.sess().opts.debuginfo == DebugInfo::Full {\n-                    self.not_ssa(local);\n-                }\n-            }\n-\n             PlaceContext::NonUse(_) | PlaceContext::MutatingUse(MutatingUseContext::Retag) => {}\n \n             PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy)"}, {"sha": "0a4610e9e490dcff18a290427a91310f746d6fad", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "patch": "@@ -1145,6 +1145,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let op = bx.load_operand(place);\n                     place.storage_dead(bx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n+                    self.debug_introduce_local(bx, index);\n                 }\n                 LocalRef::Operand(Some(op)) => {\n                     assert!(op.layout.is_zst(), \"assigning to initialized SSAtemp\");\n@@ -1186,6 +1187,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let op = bx.load_operand(tmp);\n                 tmp.storage_dead(bx);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n+                self.debug_introduce_local(bx, index);\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n@@ -1200,6 +1202,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     OperandRef::from_immediate_or_packed_pair(bx, llval, ret_abi.layout)\n                 };\n                 self.locals[index] = LocalRef::Operand(Some(op));\n+                self.debug_introduce_local(bx, index);\n             }\n         }\n     }"}, {"sha": "e5f21013ce3e32a487c0edd88bafab024c6f65c3", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "patch": "@@ -9,7 +9,8 @@ use rustc_index::vec::IndexVec;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n \n-use super::OperandValue;\n+use super::operand::OperandValue;\n+use super::place::PlaceRef;\n use super::{FunctionCx, LocalRef};\n \n pub struct FunctionDebugContext<D> {\n@@ -111,8 +112,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     /// Apply debuginfo and/or name, after creating the `alloca` for a local,\n     /// or initializing the local with an operand (whichever applies).\n-    // FIXME(eddyb) use `llvm.dbg.value` (which would work for operands),\n-    // not just `llvm.dbg.declare` (which requires `alloca`).\n     pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n         let full_debug_info = bx.sess().opts.debuginfo == DebugInfo::Full;\n \n@@ -180,38 +179,60 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let local_ref = &self.locals[local];\n \n-        if !bx.sess().fewer_names() {\n-            let name = match whole_local_var.or(fallback_var) {\n+        let name = if bx.sess().fewer_names() {\n+            None\n+        } else {\n+            Some(match whole_local_var.or(fallback_var) {\n                 Some(var) if var.name != kw::Invalid => var.name.to_string(),\n                 _ => format!(\"{:?}\", local),\n-            };\n+            })\n+        };\n+\n+        if let Some(name) = &name {\n             match local_ref {\n                 LocalRef::Place(place) | LocalRef::UnsizedPlace(place) => {\n-                    bx.set_var_name(place.llval, &name);\n+                    bx.set_var_name(place.llval, name);\n                 }\n                 LocalRef::Operand(Some(operand)) => match operand.val {\n                     OperandValue::Ref(x, ..) | OperandValue::Immediate(x) => {\n-                        bx.set_var_name(x, &name);\n+                        bx.set_var_name(x, name);\n                     }\n                     OperandValue::Pair(a, b) => {\n                         // FIXME(eddyb) these are scalar components,\n                         // maybe extract the high-level fields?\n                         bx.set_var_name(a, &(name.clone() + \".0\"));\n-                        bx.set_var_name(b, &(name + \".1\"));\n+                        bx.set_var_name(b, &(name.clone() + \".1\"));\n                     }\n                 },\n                 LocalRef::Operand(None) => {}\n             }\n         }\n \n-        if !full_debug_info {\n+        if !full_debug_info || vars.is_empty() && fallback_var.is_none() {\n             return;\n         }\n \n-        // FIXME(eddyb) add debuginfo for unsized places too.\n         let base = match local_ref {\n-            LocalRef::Place(place) => place,\n-            _ => return,\n+            LocalRef::Operand(None) => return,\n+\n+            LocalRef::Operand(Some(operand)) => {\n+                // \"Spill\" the value onto the stack, for debuginfo,\n+                // without forcing non-debuginfo uses of the local\n+                // to also load from the stack every single time.\n+                // FIXME(#68817) use `llvm.dbg.value` instead,\n+                // at least for the cases which LLVM handles correctly.\n+                let spill_slot = PlaceRef::alloca(bx, operand.layout);\n+                if let Some(name) = name {\n+                    bx.set_var_name(spill_slot.llval, &(name + \".dbg.spill\"));\n+                }\n+                operand.val.store(bx, spill_slot);\n+                spill_slot\n+            }\n+\n+            LocalRef::Place(place) => *place,\n+\n+            // FIXME(eddyb) add debuginfo for unsized places too.\n+            LocalRef::UnsizedPlace(_) => return,\n         };\n \n         let vars = vars.iter().copied().chain(fallback_var);"}, {"sha": "493c1b9f0ba6b9a2655d506a4c62b551a21b4fe1", "filename": "src/test/codegen/naked-functions.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnaked-functions.rs?ref=b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-linelength\n-\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n@@ -61,19 +59,19 @@ pub fn naked_recursive() {\n \n     naked_empty();\n \n-    // CHECK-NEXT: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_return()\n+    // CHECK-NEXT: %_4 = call i{{[0-9]+}} @naked_with_return()\n \n     // FIXME(#39685) Avoid one block per call.\n     // CHECK-NEXT: br label %bb2\n     // CHECK: bb2:\n \n-    // CHECK-NEXT: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_args_and_return(i{{[0-9]+}} %{{[0-9]+}})\n+    // CHECK-NEXT: %_3 = call i{{[0-9]+}} @naked_with_args_and_return(i{{[0-9]+}} %_4)\n \n     // FIXME(#39685) Avoid one block per call.\n     // CHECK-NEXT: br label %bb3\n     // CHECK: bb3:\n \n-    // CHECK-NEXT: call void @naked_with_args(i{{[0-9]+}} %{{[0-9]+}})\n+    // CHECK-NEXT: call void @naked_with_args(i{{[0-9]+}} %_3)\n \n     // FIXME(#39685) Avoid one block per call.\n     // CHECK-NEXT: br label %bb4"}, {"sha": "389221cbbf15104c64c7a962fe322c7726722f04", "filename": "src/test/debuginfo/issue-12886.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Ftest%2Fdebuginfo%2Fissue-12886.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4/src%2Ftest%2Fdebuginfo%2Fissue-12886.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue-12886.rs?ref=b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "patch": "@@ -6,7 +6,7 @@\n \n // gdb-command:run\n // gdb-command:next\n-// gdb-check:[...]25[...]s\n+// gdb-check:[...]24[...]let s = Some(5).unwrap(); // #break\n // gdb-command:continue\n \n #![feature(omit_gdb_pretty_printer_section)]"}]}