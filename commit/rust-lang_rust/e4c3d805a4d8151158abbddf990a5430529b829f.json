{"sha": "e4c3d805a4d8151158abbddf990a5430529b829f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YzNkODA1YTRkODE1MTE1OGFiYmRkZjk5MGE1NDMwNTI5YjgyOWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-21T19:41:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-03-26T23:20:02Z"}, "message": "syntax: Removing uses of HashMap", "tree": {"sha": "71a30e4b910586a55681a68bd6a5045dff9fc143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71a30e4b910586a55681a68bd6a5045dff9fc143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4c3d805a4d8151158abbddf990a5430529b829f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c3d805a4d8151158abbddf990a5430529b829f", "html_url": "https://github.com/rust-lang/rust/commit/e4c3d805a4d8151158abbddf990a5430529b829f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4c3d805a4d8151158abbddf990a5430529b829f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa7772893a63e6ac83ab461f80fb1f35c8633325", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7772893a63e6ac83ab461f80fb1f35c8633325", "html_url": "https://github.com/rust-lang/rust/commit/fa7772893a63e6ac83ab461f80fb1f35c8633325"}], "stats": {"total": 115, "additions": 61, "deletions": 54}, "files": [{"sha": "6f97bf6dde231d8b649b3af332d3a5826e2cfeea", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=e4c3d805a4d8151158abbddf990a5430529b829f", "patch": "@@ -656,6 +656,11 @@ pub mod linear {\n         fn reserve_at_least(&mut self, n: uint) {\n             self.map.reserve_at_least(n)\n         }\n+\n+        /// Consumes all of the elements in the set, emptying it out\n+        fn consume(&mut self, f: &fn(T)) {\n+            self.map.consume(|k, _| f(k))\n+        }\n     }\n \n     #[test]"}, {"sha": "b7ba9c5c6c042def95e756c453c23327dc050e4f", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e4c3d805a4d8151158abbddf990a5430529b829f", "patch": "@@ -186,9 +186,9 @@ pub enum named_match {\n pub type earley_item = ~MatcherPos;\n \n pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n-            -> HashMap<ident,@named_match> {\n+            -> LinearMap<ident,@named_match> {\n     fn n_rec(p_s: @mut ParseSess, m: matcher, res: ~[@named_match],\n-             ret_val: HashMap<ident, @named_match>) {\n+             ret_val: &mut LinearMap<ident, @named_match>) {\n         match m {\n           codemap::spanned {node: match_tok(_), _} => (),\n           codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n@@ -207,13 +207,13 @@ pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n           }\n         }\n     }\n-    let ret_val = HashMap();\n-    for ms.each() |m| { n_rec(p_s, *m, res, ret_val) }\n+    let mut ret_val = LinearMap::new();\n+    for ms.each() |m| { n_rec(p_s, *m, res, &mut ret_val) }\n     return ret_val;\n }\n \n pub enum parse_result {\n-    success(HashMap<ident, @named_match>),\n+    success(LinearMap<ident, @named_match>),\n     failure(codemap::span, ~str),\n     error(codemap::span, ~str)\n }\n@@ -223,11 +223,11 @@ pub fn parse_or_else(\n     +cfg: ast::crate_cfg,\n     rdr: @reader,\n     ms: ~[matcher]\n-) -> HashMap<ident, @named_match> {\n+) -> LinearMap<ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n-      failure(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str)),\n-      error(sp, ref str) => sess.span_diagnostic.span_fatal(sp, (*str))\n+      failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),\n+      error(sp, str) => sess.span_diagnostic.span_fatal(sp, str)\n     }\n }\n "}, {"sha": "6bd72b95109d730280ab910b39f0d8726c32f8b8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e4c3d805a4d8151158abbddf990a5430529b829f", "patch": "@@ -63,12 +63,12 @@ pub fn add_new_extension(cx: @ext_ctxt,\n                                      argument_gram);\n \n     // Extract the arguments:\n-    let lhses = match argument_map.get(&lhs_nm) {\n+    let lhses = match *argument_map.get(&lhs_nm) {\n         @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n         _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n \n-    let rhses = match argument_map.get(&rhs_nm) {\n+    let rhses = match *argument_map.get(&rhs_nm) {\n       @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };"}, {"sha": "67c2f438269d80d258648f82bc08fb6b2aee4288", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e4c3d805a4d8151158abbddf990a5430529b829f", "patch": "@@ -18,6 +18,7 @@ use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n use parse::lexer::TokenAndSpan;\n \n+use core::hashmap::linear::LinearMap;\n use core::option;\n use core::vec;\n \n@@ -38,7 +39,7 @@ pub struct TtReader {\n     // the unzipped tree:\n     cur: @mut TtFrame,\n     /* for MBE-style macro transcription */\n-    interpolations: std::oldmap::HashMap<ident, @named_match>,\n+    interpolations: LinearMap<ident, @named_match>,\n     repeat_idx: ~[uint],\n     repeat_len: ~[uint],\n     /* cached: */\n@@ -51,7 +52,7 @@ pub struct TtReader {\n  *  should) be none. */\n pub fn new_tt_reader(sp_diag: @span_handler,\n                      itr: @ident_interner,\n-                     interp: Option<std::oldmap::HashMap<ident,@named_match>>,\n+                     interp: Option<LinearMap<ident,@named_match>>,\n                      +src: ~[ast::token_tree])\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n@@ -65,7 +66,7 @@ pub fn new_tt_reader(sp_diag: @span_handler,\n             up: option::None\n         },\n         interpolations: match interp { /* just a convienience */\n-            None => std::oldmap::HashMap(),\n+            None => LinearMap::new(),\n             Some(x) => x\n         },\n         repeat_idx: ~[],\n@@ -123,7 +124,10 @@ fn lookup_cur_matched_by_matched(r: &mut TtReader,\n }\n \n fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n-    lookup_cur_matched_by_matched(r, r.interpolations.get(&name))\n+    // FIXME (#3850): this looks a bit silly with an extra scope.\n+    let start;\n+    { start = *r.interpolations.get(&name); }\n+    return lookup_cur_matched_by_matched(r, start);\n }\n enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)"}, {"sha": "c14c7bed1399f8cb8c3abfb2a900fd45b3c18cc1", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=e4c3d805a4d8151158abbddf990a5430529b829f", "patch": "@@ -129,7 +129,7 @@ pub impl Parser {\n \n     // A sanity check that the word we are asking for is a known keyword\n     fn require_keyword(&self, word: &~str) {\n-        if !self.keywords.contains_key(word) {\n+        if !self.keywords.contains(word) {\n             self.bug(fmt!(\"unknown keyword: %s\", *word));\n         }\n     }\n@@ -153,7 +153,7 @@ pub impl Parser {\n     fn is_any_keyword(&self, tok: &token::Token) -> bool {\n         match *tok {\n           token::IDENT(sid, false) => {\n-            self.keywords.contains_key(self.id_to_str(sid))\n+            self.keywords.contains(self.id_to_str(sid))\n           }\n           _ => false\n         }\n@@ -183,7 +183,7 @@ pub impl Parser {\n     }\n \n     fn is_strict_keyword(&self, word: &~str) -> bool {\n-        self.strict_keywords.contains_key(word)\n+        self.strict_keywords.contains(word)\n     }\n \n     fn check_strict_keywords(&self) {\n@@ -203,7 +203,7 @@ pub impl Parser {\n     }\n \n     fn is_reserved_keyword(&self, word: &~str) -> bool {\n-        self.reserved_keywords.contains_key(word)\n+        self.reserved_keywords.contains(word)\n     }\n \n     fn check_reserved_keywords(&self) {"}, {"sha": "32c8b88aed8bdaf8aec9f74593f92dc1c864ac9f", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=e4c3d805a4d8151158abbddf990a5430529b829f", "patch": "@@ -225,9 +225,9 @@ pub impl Parser {\n                    desc: &str) {\n         self.span_err(sp, fmt!(\"obsolete syntax: %s\", kind_str));\n \n-        if !self.obsolete_set.contains_key(&kind) {\n+        if !self.obsolete_set.contains(&kind) {\n             self.sess.span_diagnostic.handler().note(fmt!(\"%s\", desc));\n-            self.obsolete_set.insert(kind, ());\n+            self.obsolete_set.insert(kind);\n         }\n     }\n "}, {"sha": "171cd90bcd2b359b91d2467662ba289c41ed1131", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e4c3d805a4d8151158abbddf990a5430529b829f", "patch": "@@ -92,8 +92,8 @@ use opt_vec::OptVec;\n \n use core::either::{Either, Left, Right};\n use core::either;\n+use core::hashmap::linear::LinearSet;\n use core::vec;\n-use std::oldmap::HashMap;\n \n #[deriving(Eq)]\n enum restriction {\n@@ -240,7 +240,7 @@ pub fn Parser(sess: @mut ParseSess,\n         keywords: token::keyword_table(),\n         strict_keywords: token::strict_keyword_table(),\n         reserved_keywords: token::reserved_keyword_table(),\n-        obsolete_set: HashMap(),\n+        obsolete_set: @mut LinearSet::new(),\n         mod_path_stack: @mut ~[],\n     }\n }\n@@ -259,12 +259,12 @@ pub struct Parser {\n     quote_depth: @mut uint, // not (yet) related to the quasiquoter\n     reader: @reader,\n     interner: @token::ident_interner,\n-    keywords: HashMap<~str, ()>,\n-    strict_keywords: HashMap<~str, ()>,\n-    reserved_keywords: HashMap<~str, ()>,\n+    keywords: LinearSet<~str>,\n+    strict_keywords: LinearSet<~str>,\n+    reserved_keywords: LinearSet<~str>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n-    obsolete_set: HashMap<ObsoleteSyntax, ()>,\n+    obsolete_set: @mut LinearSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n     mod_path_stack: @mut ~[~str],\n "}, {"sha": "5fdf6f7620cc145c34926685d1187ef339c0b9f1", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c3d805a4d8151158abbddf990a5430529b829f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e4c3d805a4d8151158abbddf990a5430529b829f", "patch": "@@ -18,9 +18,9 @@ use util::interner;\n \n use core::cast;\n use core::char;\n+use core::hashmap::linear::LinearSet;\n use core::str;\n use core::task;\n-use std::oldmap::HashMap;\n \n #[auto_encode]\n #[auto_decode]\n@@ -458,35 +458,33 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n  * appear as identifiers at all. Reserved keywords are not used anywhere in\n  * the language and may not appear as identifiers.\n  */\n-pub fn keyword_table() -> HashMap<~str, ()> {\n-    let keywords = HashMap();\n-    for temporary_keyword_table().each_key |&word| {\n-        keywords.insert(word, ());\n-    }\n-    for strict_keyword_table().each_key |&word| {\n-        keywords.insert(word, ());\n-    }\n-    for reserved_keyword_table().each_key |&word| {\n-        keywords.insert(word, ());\n-    }\n-    keywords\n+pub fn keyword_table() -> LinearSet<~str> {\n+    let mut keywords = LinearSet::new();\n+    let mut tmp = temporary_keyword_table();\n+    let mut strict = strict_keyword_table();\n+    let mut reserved = reserved_keyword_table();\n+\n+    do tmp.consume |word|      { keywords.insert(word); }\n+    do strict.consume |word|   { keywords.insert(word); }\n+    do reserved.consume |word| { keywords.insert(word); }\n+    return keywords;\n }\n \n /// Keywords that may be used as identifiers\n-pub fn temporary_keyword_table() -> HashMap<~str, ()> {\n-    let words = HashMap();\n+pub fn temporary_keyword_table() -> LinearSet<~str> {\n+    let mut words = LinearSet::new();\n     let keys = ~[\n         ~\"self\", ~\"static\",\n     ];\n-    for keys.each |word| {\n-        words.insert(copy *word, ());\n+    do vec::consume(keys) |_, s| {\n+        words.insert(s);\n     }\n-    words\n+    return words;\n }\n \n /// Full keywords. May not appear anywhere else.\n-pub fn strict_keyword_table() -> HashMap<~str, ()> {\n-    let words = HashMap();\n+pub fn strict_keyword_table() -> LinearSet<~str> {\n+    let mut words = LinearSet::new();\n     let keys = ~[\n         ~\"as\",\n         ~\"break\",\n@@ -505,21 +503,21 @@ pub fn strict_keyword_table() -> HashMap<~str, ()> {\n         ~\"unsafe\", ~\"use\",\n         ~\"while\"\n     ];\n-    for keys.each |word| {\n-        words.insert(copy *word, ());\n+    do vec::consume(keys) |_, w| {\n+        words.insert(w);\n     }\n-    words\n+    return words;\n }\n \n-pub fn reserved_keyword_table() -> HashMap<~str, ()> {\n-    let words = HashMap();\n+pub fn reserved_keyword_table() -> LinearSet<~str> {\n+    let mut words = LinearSet::new();\n     let keys = ~[\n         ~\"be\"\n     ];\n-    for keys.each |word| {\n-        words.insert(copy *word, ());\n+    do vec::consume(keys) |_, s| {\n+        words.insert(s);\n     }\n-    words\n+    return words;\n }\n \n "}]}