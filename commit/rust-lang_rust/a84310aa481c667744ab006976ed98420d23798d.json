{"sha": "a84310aa481c667744ab006976ed98420d23798d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NDMxMGFhNDgxYzY2Nzc0NGFiMDA2OTc2ZWQ5ODQyMGQyMzc5OGQ=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-09T00:33:49Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-11T21:05:09Z"}, "message": "Started working on MapReduce.\n\nCurrently it's only sequential, but it can do word frequency\ncounting. In an ideal world it would all be polymorphic, but that\npushes the limits of our type system right now. We can generalize it\nlater.", "tree": {"sha": "d61b26d72b8df5936fabe38764f123e2c41ffa13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d61b26d72b8df5936fabe38764f123e2c41ffa13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a84310aa481c667744ab006976ed98420d23798d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a84310aa481c667744ab006976ed98420d23798d", "html_url": "https://github.com/rust-lang/rust/commit/a84310aa481c667744ab006976ed98420d23798d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a84310aa481c667744ab006976ed98420d23798d/comments", "author": null, "committer": null, "parents": [{"sha": "d151e1863382d99a6a6885e98432964eef107a62", "url": "https://api.github.com/repos/rust-lang/rust/commits/d151e1863382d99a6a6885e98432964eef107a62", "html_url": "https://github.com/rust-lang/rust/commit/d151e1863382d99a6a6885e98432964eef107a62"}], "stats": {"total": 220, "additions": 220, "deletions": 0}, "files": [{"sha": "51c50c6bf90ef4783cc7865d75d1a079e66a4c33", "filename": "src/test/bench/task-perf/word-count.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/a84310aa481c667744ab006976ed98420d23798d/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a84310aa481c667744ab006976ed98420d23798d/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs?ref=a84310aa481c667744ab006976ed98420d23798d", "patch": "@@ -0,0 +1,220 @@\n+/**\n+   A parallel word-frequency counting program.\n+\n+   This is meant primarily to demonstrate Rust's MapReduce framework.\n+\n+   It takes a list of files on the command line and outputs a list of\n+   words along with how many times each word is used.\n+\n+*/\n+\n+use std;\n+\n+import std::io;\n+import option = std::option::t;\n+import std::option::some;\n+import std::option::none;\n+import std::str;\n+import std::vec;\n+import std::map;\n+\n+mod map_reduce {\n+    export putter;\n+    export getter;\n+    export mapper;\n+    export reducer;\n+    export map_reduce;\n+\n+    type putter = fn(str, str) -> ();\n+\n+    type mapper = fn(str, putter);\n+\n+    type getter = fn() -> option[str];\n+    \n+    type reducer = fn(str, getter);\n+\n+    \n+    fn map_reduce (vec[str] inputs,\n+                   mapper f,\n+                   reducer reduce) {\n+        auto intermediates = map::new_str_hash[vec[str]]();\n+\n+        fn emit(&map::hashmap[str, vec[str]] im,\n+                str key, str val) {\n+            auto old = [];\n+            alt(im.remove(key)) {\n+                case (some(?v)) {\n+                    old = v;\n+                }\n+                case (none) { }\n+            }\n+            \n+            im.insert(key, old + [val]);\n+        }\n+\n+        for (str i in inputs) {\n+            f(i, bind emit(intermediates, _, _));\n+        }\n+\n+        fn get(vec[str] vals, &mutable uint i) -> option[str] {\n+            i += 1u;\n+            if(i <= vec::len(vals)) {\n+                some(vals.(i - 1u))\n+            }\n+            else {\n+                none\n+            }\n+        }\n+\n+        for each (@tup(str, vec[str]) kv in intermediates.items()) {\n+            auto i = 0u;\n+            reduce(kv._0, bind get(kv._1, i));\n+        }\n+    }\n+}\n+\n+fn main(vec[str] argv) {\n+    if(vec::len(argv) < 2u) {\n+        auto out = io::stdout();\n+\n+        out.write_line(#fmt(\"Usage: %s <filename> ...\", argv.(0)));\n+        fail;\n+    }\n+\n+    fn map(str filename, map_reduce::putter emit) {\n+        auto f = io::file_reader(filename);\n+\n+        while(true) {\n+            alt(read_word(f)) {\n+                case (some(?w)) { \n+                    emit(w, \"1\");\n+                }\n+                case (none) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn reduce(str word, map_reduce::getter get) {\n+        auto count = 0;\n+        \n+        while(true) {\n+            alt(get()) {\n+                case(some(_)) { count += 1 }\n+                case(none) { break }\n+            }\n+        }\n+\n+        auto out = io::stdout();\n+        out.write_line(#fmt(\"%s: %d\", word, count));\n+    }\n+\n+    map_reduce::map_reduce(vec::slice(argv, 1u, vec::len(argv)), map, reduce);\n+}\n+\n+fn read_word(io::reader r) -> option[str] {\n+    auto w = \"\";\n+\n+    while(!r.eof()) {\n+        auto c = r.read_char();\n+\n+        if(is_word_char(c)) {\n+            w += str::from_char(c);\n+        }\n+        else {\n+            if(w != \"\") {\n+                ret some(w);\n+            }\n+        }\n+    }\n+    ret none;\n+}\n+\n+fn is_digit(char c) -> bool {\n+    alt(c) {\n+        case ('0') { true }\n+        case ('1') { true }\n+        case ('2') { true }\n+        case ('3') { true }\n+        case ('4') { true }\n+        case ('5') { true }\n+        case ('6') { true }\n+        case ('7') { true }\n+        case ('8') { true }\n+        case ('9') { true }\n+        case (_) { false }\n+    }\n+}\n+\n+fn is_alpha_lower (char c) -> bool {\n+    alt(c) {\n+        case ('a') { true }\n+        case ('b') { true }\n+        case ('c') { true }\n+        case ('d') { true }\n+        case ('e') { true }\n+        case ('f') { true }\n+        case ('g') { true }\n+        case ('h') { true }\n+        case ('i') { true }\n+        case ('j') { true }\n+        case ('k') { true }\n+        case ('l') { true }\n+        case ('m') { true }\n+        case ('n') { true }\n+        case ('o') { true }\n+        case ('p') { true }\n+        case ('q') { true }\n+        case ('r') { true }\n+        case ('s') { true }\n+        case ('t') { true }\n+        case ('u') { true }\n+        case ('v') { true }\n+        case ('w') { true }\n+        case ('x') { true }\n+        case ('y') { true }\n+        case ('z') { true }\n+        case (_) { false }\n+    }\n+}\n+\n+fn is_alpha_upper (char c) -> bool {\n+    alt(c) {\n+        case ('A') { true }\n+        case ('B') { true }\n+        case ('C') { true }\n+        case ('D') { true }\n+        case ('E') { true }\n+        case ('F') { true }\n+        case ('G') { true }\n+        case ('H') { true }\n+        case ('I') { true }\n+        case ('J') { true }\n+        case ('K') { true }\n+        case ('L') { true }\n+        case ('M') { true }\n+        case ('N') { true }\n+        case ('O') { true }\n+        case ('P') { true }\n+        case ('Q') { true }\n+        case ('R') { true }\n+        case ('S') { true }\n+        case ('T') { true }\n+        case ('U') { true }\n+        case ('V') { true }\n+        case ('W') { true }\n+        case ('X') { true }\n+        case ('Y') { true }\n+        case ('Z') { true }\n+        case (_) { false }\n+    }\n+}\n+\n+fn is_alpha(char c) -> bool {\n+    is_alpha_upper(c) || is_alpha_lower(c)\n+}\n+\n+fn is_word_char(char c) -> bool {\n+    is_alpha(c) || is_digit(c) || c == '_'\n+}\n\\ No newline at end of file"}]}