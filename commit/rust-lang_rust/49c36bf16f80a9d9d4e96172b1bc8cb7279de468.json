{"sha": "49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YzM2YmYxNmY4MGE5ZDlkNGU5NjE3MmIxYmM4Y2I3Mjc5ZGU0Njg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-04T05:58:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-04T05:58:55Z"}, "message": "Auto merge of #36306 - nagisa:mir-local-cleanup, r=eddyb\n\nA way to remove otherwise unused locals from MIR\n\nThere is a certain amount of desire for a pass which cleans up the provably unused variables (no assignments or reads). There has been an implementation of such pass by @scottcarr, and another (two!) implementations by me in my own dataflow efforts.\n\nPR like https://github.com/rust-lang/rust/pull/35916 proves that this pass is useful even on its own, which is why I cherry-picked it out from my dataflow effort.\n\n@nikomatsakis previously expressed concerns over this pass not seeming to be very cheap to run and therefore unsuitable for regular cleanup duties. Turns out, regular cleanup of local declarations is not at all necessary, at least now, because majority of passes simply do not (or should not) care about them. That\u2019s why it is viable to only run this pass once (perhaps a few more times in the future?) per function, right before translation.\n\nr? @eddyb or @nikomatsakis", "tree": {"sha": "d45fc028bc95be0f72a19744ed6c535e20ec5216", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d45fc028bc95be0f72a19744ed6c535e20ec5216"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "html_url": "https://github.com/rust-lang/rust/commit/49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0", "html_url": "https://github.com/rust-lang/rust/commit/ac919fcd9d4a958baf99b2f2ed5c3d38a2ebf9d0"}, {"sha": "475236770fe4fd973957d734a074a54c5ac88c87", "url": "https://api.github.com/repos/rust-lang/rust/commits/475236770fe4fd973957d734a074a54c5ac88c87", "html_url": "https://github.com/rust-lang/rust/commit/475236770fe4fd973957d734a074a54c5ac88c87"}], "stats": {"total": 172, "additions": 137, "deletions": 35}, "files": [{"sha": "b5da304a10986d353f3499d1648194a578f24cc9", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "patch": "@@ -157,14 +157,14 @@ macro_rules! make_mir_visitor {\n \n             fn visit_projection(&mut self,\n                                 lvalue: & $($mutability)* LvalueProjection<'tcx>,\n-                                context: LvalueContext,\n+                                context: LvalueContext<'tcx>,\n                                 location: Location) {\n                 self.super_projection(lvalue, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n                                      lvalue: & $($mutability)* LvalueElem<'tcx>,\n-                                     context: LvalueContext,\n+                                     context: LvalueContext<'tcx>,\n                                      location: Location) {\n                 self.super_projection_elem(lvalue, context, location);\n             }\n@@ -579,7 +579,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_projection(&mut self,\n                                 proj: & $($mutability)* LvalueProjection<'tcx>,\n-                                context: LvalueContext,\n+                                context: LvalueContext<'tcx>,\n                                 location: Location) {\n                 let Projection {\n                     ref $($mutability)* base,\n@@ -596,7 +596,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_projection_elem(&mut self,\n                                      proj: & $($mutability)* LvalueElem<'tcx>,\n-                                     _context: LvalueContext,\n+                                     _context: LvalueContext<'tcx>,\n                                      location: Location) {\n                 match *proj {\n                     ProjectionElem::Deref => {\n@@ -739,7 +739,7 @@ macro_rules! make_mir_visitor {\n make_mir_visitor!(Visitor,);\n make_mir_visitor!(MutVisitor,mut);\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum LvalueContext<'tcx> {\n     // Appears as LHS of an assignment\n     Store,"}, {"sha": "00cea9cbdf6b7100aac27aa01164f32810c28afe", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "patch": "@@ -149,6 +149,21 @@ impl<I: Idx, T> IndexVec<I, T> {\n     pub fn last(&self) -> Option<I> {\n         self.len().checked_sub(1).map(I::new)\n     }\n+\n+    #[inline]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.raw.shrink_to_fit()\n+    }\n+\n+    #[inline]\n+    pub fn swap(&mut self, a: usize, b: usize) {\n+        self.raw.swap(a, b)\n+    }\n+\n+    #[inline]\n+    pub fn truncate(&mut self, a: usize) {\n+        self.raw.truncate(a)\n+    }\n }\n \n impl<I: Idx, T> Index<I> for IndexVec<I, T> {"}, {"sha": "e33428a3e963be50ea2393935f46443652c46f33", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "patch": "@@ -917,17 +917,19 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR dump\",\n              || mir::mir_map::build_mir_for_crate(tcx));\n \n-        time(time_passes, \"MIR passes\", || {\n+        time(time_passes, \"MIR cleanup and validation\", || {\n             let mut passes = sess.mir_passes.borrow_mut();\n-            // Push all the built-in passes.\n+            // Push all the built-in validation passes.\n+            // NB: if you\u2019re adding an *optimisation* it ought to go to another set of passes\n+            // in stage 4 below.\n             passes.push_hook(box mir::transform::dump_mir::DumpMir);\n-            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"initial\"));\n+            passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n             passes.push_pass(\n                 box mir::transform::qualify_consts::QualifyAndPromoteConstants::default());\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(\n                 box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n-            passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"qualify-consts\"));\n+            passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n             // And run everything.\n             passes.run_passes(tcx);\n         });\n@@ -989,27 +991,28 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n-    // Run the passes that transform the MIR into a more suitable for translation\n-    // to LLVM code.\n-    time(time_passes, \"Prepare MIR codegen passes\", || {\n+    // Run the passes that transform the MIR into a more suitable form for translation to LLVM\n+    // code.\n+    time(time_passes, \"MIR optimisations\", || {\n         let mut passes = ::rustc::mir::transform::Passes::new();\n         passes.push_hook(box mir::transform::dump_mir::DumpMir);\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"no-landing-pads\"));\n+        passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n \n         // From here on out, regions are gone.\n         passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n \n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box borrowck::ElaborateDrops);\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n-        passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg::new(\"elaborate-drops\"));\n+        passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n \n         // No lifetime analysis based on borrowing can be done from here on out.\n         passes.push_pass(box mir::transform::instcombine::InstCombine::new());\n         passes.push_pass(box mir::transform::deaggregator::Deaggregator);\n         passes.push_pass(box mir::transform::copy_prop::CopyPropagation);\n \n+        passes.push_pass(box mir::transform::simplify::SimplifyLocals);\n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));\n "}, {"sha": "ae255f70fb78892ac21ca8e0e813427692053639", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub mod simplify_branches;\n-pub mod simplify_cfg;\n+pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;"}, {"sha": "d5fc90289e2cc20465af956a30abf84cd3c8d18b", "filename": "src/librustc_mir/transform/simplify.rs", "status": "renamed", "additions": 104, "deletions": 14, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "patch": "@@ -8,35 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A pass that removes various redundancies in the CFG. It should be\n-//! called after every significant CFG modification to tidy things\n-//! up.\n+//! A number of passes which remove various redundancies in the CFG.\n //!\n-//! This pass must also be run before any analysis passes because it removes\n-//! dead blocks, and some of these can be ill-typed.\n+//! The `SimplifyCfg` pass gets rid of unnecessary blocks in the CFG, whereas the `SimplifyLocals`\n+//! gets rid of all the unnecessary local variable declarations.\n //!\n-//! The cause of that is that typeck lets most blocks whose end is not\n-//! reachable have an arbitrary return type, rather than having the\n-//! usual () return type (as a note, typeck's notion of reachability\n-//! is in fact slightly weaker than MIR CFG reachability - see #31617).\n+//! The `SimplifyLocals` pass is kinda expensive and therefore not very suitable to be run often.\n+//! Most of the passes should not care or be impacted in meaningful ways due to extra locals\n+//! either, so running the pass once, right before translation, should suffice.\n+//!\n+//! On the other side of the spectrum, the `SimplifyCfg` pass is considerably cheap to run, thus\n+//! one should run it after every pass which may modify CFG in significant ways. This pass must\n+//! also be run before any analysis passes because it removes dead blocks, and some of these can be\n+//! ill-typed.\n+//!\n+//! The cause of this typing issue is typeck allowing most blocks whose end is not reachable have\n+//! an arbitrary return type, rather than having the usual () return type (as a note, typeck's\n+//! notion of reachability is in fact slightly weaker than MIR CFG reachability - see #31617). A\n+//! standard example of the situation is:\n //!\n-//! A standard example of the situation is:\n //! ```rust\n //!   fn example() {\n //!       let _a: char = { return; };\n //!   }\n //! ```\n //!\n-//! Here the block (`{ return; }`) has the return type `char`,\n-//! rather than `()`, but the MIR we naively generate still contains\n-//! the `_a = ()` write in the unreachable block \"after\" the return.\n-\n+//! Here the block (`{ return; }`) has the return type `char`, rather than `()`, but the MIR we\n+//! naively generate still contains the `_a = ()` write in the unreachable block \"after\" the\n+//! return.\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::visit::{MutVisitor, Visitor, LvalueContext};\n use std::fmt;\n \n pub struct SimplifyCfg<'a> { label: &'a str }\n@@ -257,3 +263,87 @@ fn remove_dead_blocks(mir: &mut Mir) {\n         }\n     }\n }\n+\n+\n+pub struct SimplifyLocals;\n+\n+impl Pass for SimplifyLocals {\n+    fn name(&self) -> ::std::borrow::Cow<'static, str> { \"SimplifyLocals\".into() }\n+}\n+\n+impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+        let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n+        marker.visit_mir(mir);\n+        // Return pointer and arguments are always live\n+        marker.locals.insert(0);\n+        for idx in mir.args_iter() {\n+            marker.locals.insert(idx.index());\n+        }\n+        let map = make_local_map(&mut mir.local_decls, marker.locals);\n+        // Update references to all vars and tmps now\n+        LocalUpdater { map: map }.visit_mir(mir);\n+        mir.local_decls.shrink_to_fit();\n+    }\n+}\n+\n+/// Construct the mapping while swapping out unused stuff out from the `vec`.\n+fn make_local_map<'tcx, I: Idx, V>(vec: &mut IndexVec<I, V>, mask: BitVector) -> Vec<usize> {\n+    let mut map: Vec<usize> = ::std::iter::repeat(!0).take(vec.len()).collect();\n+    let mut used = 0;\n+    for alive_index in mask.iter() {\n+        map[alive_index] = used;\n+        if alive_index != used {\n+            vec.swap(alive_index, used);\n+        }\n+        used += 1;\n+    }\n+    vec.truncate(used);\n+    map\n+}\n+\n+struct DeclMarker {\n+    pub locals: BitVector,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DeclMarker {\n+    fn visit_lvalue(&mut self, lval: &Lvalue<'tcx>, ctx: LvalueContext<'tcx>, loc: Location) {\n+        if ctx == LvalueContext::StorageLive || ctx == LvalueContext::StorageDead {\n+            // ignore these altogether, they get removed along with their otherwise unused decls.\n+            return;\n+        }\n+        if let Lvalue::Local(ref v) = *lval {\n+            self.locals.insert(v.index());\n+        }\n+        self.super_lvalue(lval, ctx, loc);\n+    }\n+}\n+\n+struct LocalUpdater {\n+    map: Vec<usize>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n+        // Remove unnecessary StorageLive and StorageDead annotations.\n+        data.statements.retain(|stmt| {\n+            match stmt.kind {\n+                StatementKind::StorageLive(ref lval) | StatementKind::StorageDead(ref lval) => {\n+                    match *lval {\n+                        Lvalue::Local(l) => self.map[l.index()] != !0,\n+                        _ => true\n+                    }\n+                }\n+                _ => true\n+            }\n+        });\n+        self.super_basic_block_data(block, data);\n+    }\n+    fn visit_lvalue(&mut self, lval: &mut Lvalue<'tcx>, ctx: LvalueContext<'tcx>, loc: Location) {\n+        match *lval {\n+            Lvalue::Local(ref mut l) => *l = Local::new(self.map[l.index()]),\n+            _ => (),\n+        };\n+        self.super_lvalue(lval, ctx, loc);\n+    }\n+}", "previous_filename": "src/librustc_mir/transform/simplify_cfg.rs"}, {"sha": "e4d0533ec878422bc60b6e52f0ba2d1a6471afae", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c36bf16f80a9d9d4e96172b1bc8cb7279de468/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=49c36bf16f80a9d9d4e96172b1bc8cb7279de468", "patch": "@@ -42,12 +42,6 @@ pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n                     common::type_is_fat_ptr(bcx.tcx(), ty));\n         } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n             // We allow pairs and uses of any of their 2 fields.\n-        } else if !analyzer.seen_assigned.contains(index) {\n-            // No assignment has been seen, which means that\n-            // either the local has been marked as lvalue\n-            // already, or there is no possible initialization\n-            // for the local, making any reads invalid.\n-            // This is useful in weeding out dead temps.\n         } else {\n             // These sorts of types require an alloca. Note that\n             // type_is_immediate() may *still* be true, particularly"}]}