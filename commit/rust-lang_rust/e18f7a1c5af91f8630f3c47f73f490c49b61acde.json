{"sha": "e18f7a1c5af91f8630f3c47f73f490c49b61acde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxOGY3YTFjNWFmOTFmODYzMGYzYzQ3ZjczZjQ5MGM0OWI2MWFjZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-18T00:33:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-18T00:33:58Z"}, "message": "Auto merge of #31739 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #31565, #31679, #31694, #31695, #31703, #31720, #31733\n- Failed merges:", "tree": {"sha": "6086c5424b53c30250fe8d0ff9c02415ab660dd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6086c5424b53c30250fe8d0ff9c02415ab660dd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e18f7a1c5af91f8630f3c47f73f490c49b61acde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e18f7a1c5af91f8630f3c47f73f490c49b61acde", "html_url": "https://github.com/rust-lang/rust/commit/e18f7a1c5af91f8630f3c47f73f490c49b61acde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e18f7a1c5af91f8630f3c47f73f490c49b61acde/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d3eebff9dc9474f56cdba810edde324130fbc61", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3eebff9dc9474f56cdba810edde324130fbc61", "html_url": "https://github.com/rust-lang/rust/commit/4d3eebff9dc9474f56cdba810edde324130fbc61"}, {"sha": "27ede43c896fc7343975b8ecd67d208ea6673d53", "url": "https://api.github.com/repos/rust-lang/rust/commits/27ede43c896fc7343975b8ecd67d208ea6673d53", "html_url": "https://github.com/rust-lang/rust/commit/27ede43c896fc7343975b8ecd67d208ea6673d53"}], "stats": {"total": 508, "additions": 326, "deletions": 182}, "files": [{"sha": "a247eb2e9555c999f08c6edc2e7eb4b50671d498", "filename": "RELEASES.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -94,11 +94,11 @@ Misc\n   the `-Z unstable-options` flag.\n * [When running tests with `--test`, rustdoc will pass `--cfg`\n   arguments to the compiler][1.7dt].\n-* [The compiler is built with RPATH information by default][1.7rp].\n+* [The compiler is built with RPATH information by default][1.7rpa].\n   This means that it will be possible to run `rustc` when installed in\n   unusual configurations without configuring the dynamic linker search\n   path explicitly.\n-* [`rustc` passes `--enable-new-dtags` to GNU ld][1.7dt]. This makes\n+* [`rustc` passes `--enable-new-dtags` to GNU ld][1.7dta]. This makes\n   any RPATH entries (emitted with `-C rpath`) *not* take precedence\n   over `LD_LIBRARY_PATH`.\n \n@@ -132,15 +132,15 @@ Compatibility Notes\n [1.7cp]: https://github.com/rust-lang/cargo/pull/2224\n [1.7d]: https://github.com/rust-lang/rust/pull/30724\n [1.7dt]: https://github.com/rust-lang/rust/pull/30372\n-[1.7dt]: https://github.com/rust-lang/rust/pull/30394\n+[1.7dta]: https://github.com/rust-lang/rust/pull/30394\n [1.7f]: https://github.com/rust-lang/rust/pull/30672\n [1.7h]: https://github.com/rust-lang/rust/pull/30818\n [1.7j]: https://github.com/rust-lang/rust/pull/30711\n [1.7ll]: https://github.com/rust-lang/rust/pull/30663\n [1.7m]: https://github.com/rust-lang/rust/pull/30381\n [1.7p]: https://github.com/rust-lang/rust/pull/30681\n [1.7rp]: https://github.com/rust-lang/rust/pull/29498\n-[1.7rp]: https://github.com/rust-lang/rust/pull/30353\n+[1.7rpa]: https://github.com/rust-lang/rust/pull/30353\n [1.7rr]: https://github.com/rust-lang/cargo/pull/2279\n [1.7sf]: https://github.com/rust-lang/rust/pull/30389\n [1.7utf8]: https://github.com/rust-lang/rust/pull/30740"}, {"sha": "8f15544b20b2b3a724f3425179bee934a6f94dc2", "filename": "src/doc/book/ownership.md", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Fdoc%2Fbook%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Fdoc%2Fbook%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fownership.md?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -124,21 +124,65 @@ special annotation here, it\u2019s the default thing that Rust does.\n ## The details\n \n The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n-important. When we write code like this:\n+important. \n+\n+When we write code like this:\n+\n+```rust\n+let x = 10;\n+```\n+\n+Rust allocates memory for an integer [i32] on the [stack][sh], copies the bit\n+pattern representing the value of 10 to the allocated memory and binds the\n+variable name x to this memory region for future reference.\n+\n+Now consider the following code fragment:\n \n ```rust\n let v = vec![1, 2, 3];\n \n-let v2 = v;\n+let mut v2 = v;\n+```\n+\n+The first line allocates memory for the vector object `v` on the stack like\n+it does for `x` above. But in addition to that it also allocates some memory\n+on the [heap][sh] for the actual data (`[1, 2, 3]`). Rust copies the address\n+of this heap allocation to an internal pointer, which is part of the vector\n+object placed on the stack (let's call it the data pointer). \n+\n+It is worth pointing out (even at the risk of stating the obvious) that the\n+vector object and its data live in separate memory regions instead of being a\n+single contiguous memory allocation (due to reasons we will not go into at\n+this point of time). These two parts of the vector (the one on the stack and\n+one on the heap) must agree with each other at all times with regards to\n+things like the length, capacity etc.\n+\n+When we move `v` to `v2`, rust actually does a bitwise copy of the vector\n+object `v` into the stack allocation represented by `v2`. This shallow copy\n+does not create a copy of the heap allocation containing the actual data.\n+Which means that there would be two pointers to the contents of the vector\n+both pointing to the same memory allocation on the heap. It would violate\n+Rust\u2019s safety guarantees by introducing a data race if one could access both\n+`v` and `v2` at the same time. \n+\n+For example if we truncated the vector to just two elements through `v2`:\n+\n+```rust\n+# let v = vec![1, 2, 3];\n+# let mut v2 = v;\n+v2.truncate(2);\n ```\n \n-The first line allocates memory for the vector object, `v`, and for the data it\n-contains. The vector object is stored on the [stack][sh] and contains a pointer\n-to the content (`[1, 2, 3]`) stored on the [heap][sh]. When we move `v` to `v2`,\n-it creates a copy of that pointer, for `v2`. Which means that there would be two\n-pointers to the content of the vector on the heap. It would violate Rust\u2019s\n-safety guarantees by introducing a data race. Therefore, Rust forbids using `v`\n-after we\u2019ve done the move.\n+and `v1` were still accessible we'd end up with an invalid vector since `v1`\n+would not know that the heap data has been truncated. Now, the part of the\n+vector `v1` on the stack does not agree with the corresponding part on the\n+heap. `v1` still thinks there are three elements in the vector and will\n+happily let us access the non existent element `v1[2]` but as you might\n+already know this is a recipe for disaster. Especially because it might lead\n+to a segmentation fault or worse allow an unauthorized user to read from\n+memory to which they don't have access.\n+\n+This is why Rust forbids using `v` after we\u2019ve done the move.\n \n [sh]: the-stack-and-the-heap.html\n "}, {"sha": "7207e7b151c1eae3966022d942574d4cc9a672c2", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -375,9 +375,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// If the map did not have this key present, `None` is returned.\n     ///\n-    /// If the map did have this key present, the key is not updated, the\n-    /// value is updated and the old value is returned.\n-    /// See the [module-level documentation] for more.\n+    /// If the map did have this key present, the value is updated, and the old\n+    /// value is returned. The key is not updated, though; this matters for\n+    /// types that can be `==` without being identical. See the [module-level\n+    /// documentation] for more.\n     ///\n     /// [module-level documentation]: index.html#insert-and-complex-keys\n     ///"}, {"sha": "c36ad592ad3b54500858bc8149a1a6e031cda2b3", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -571,9 +571,25 @@ pub const POST_DROP_USIZE: usize = POST_DROP_U64 as usize;\n /// ```\n /// use std::mem;\n ///\n-/// let one = unsafe { mem::transmute_copy(&1) };\n+/// #[repr(packed)]\n+/// struct Foo {\n+///     bar: u8,\n+/// }\n+///\n+/// let foo_slice = [10u8];\n+///\n+/// unsafe {\n+///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n+///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n+///     assert_eq!(foo_struct.bar, 10);\n+///\n+///     // Modify the copied data\n+///     foo_struct.bar = 20;\n+///     assert_eq!(foo_struct.bar, 20);\n+/// }\n ///\n-/// assert_eq!(1, one);\n+/// // The contents of 'foo_slice' should not have changed\n+/// assert_eq!(foo_slice, [10]);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "92db527ef9803ac3b0e1f8b52a994f113a0de5c1", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 162, "deletions": 85, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -20,8 +20,8 @@ This error suggests that the expression arm corresponding to the noted pattern\n will never be reached as for all possible values of the expression being\n matched, one of the preceding patterns will match.\n \n-This means that perhaps some of the preceding patterns are too general, this one\n-is too specific or the ordering is incorrect.\n+This means that perhaps some of the preceding patterns are too general, this\n+one is too specific or the ordering is incorrect.\n \n For example, the following `match` block has too many arms:\n \n@@ -104,28 +104,86 @@ E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for\n one or more possible inputs to a match expression. Guaranteed matches are\n required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution.\n+determine the flow of execution. Erroneous code example:\n+\n+```compile_fail\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n+    Terminator::TalkToMyHand => {}\n+}\n+```\n \n If you encounter this error you must alter your patterns so that every possible\n value of the input type is matched. For types with a small number of variants\n (like enums) you should probably cover all cases explicitly. Alternatively, the\n underscore `_` wildcard pattern can be added after all other patterns to match\n-\"anything else\".\n+\"anything else\". Example:\n+\n+```\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    Terminator::HastaLaVistaBaby => {}\n+}\n+\n+// or:\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    _ => {}\n+}\n+```\n \"##,\n \n E0005: r##\"\n Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. If you encounter this error you\n-probably need to use a `match` or `if let` to deal with the possibility of\n-failure.\n+that a name will be extracted in all cases. Erroneous code example:\n+\n+```compile_fail\n+let x = Some(1);\n+let Some(y) = x;\n+// error: refutable pattern in local binding: `None` not covered\n+```\n+\n+If you encounter this error you probably need to use a `match` or `if let` to\n+deal with the possibility of failure. Example:\n+\n+```compile_fail\n+let x = Some(1);\n+\n+match x {\n+    Some(y) => {\n+        // do something\n+    },\n+    None => {}\n+}\n+\n+// or:\n+\n+if let Some(y) = x {\n+    // do something\n+}\n+```\n \"##,\n \n E0007: r##\"\n This error indicates that the bindings in a match arm would require a value to\n-be moved into more than one location, thus violating unique ownership. Code like\n-the following is invalid as it requires the entire `Option<String>` to be moved\n-into a variable called `op_string` while simultaneously requiring the inner\n-String to be moved into a variable called `s`.\n+be moved into more than one location, thus violating unique ownership. Code\n+like the following is invalid as it requires the entire `Option<String>` to be\n+moved into a variable called `op_string` while simultaneously requiring the\n+inner `String` to be moved into a variable called `s`.\n \n ```compile_fail\n let x = Some(\"s\".to_string());\n@@ -180,7 +238,7 @@ by-ref.\n \n This limitation may be removed in a future version of Rust.\n \n-Wrong example:\n+Erroneous code example:\n \n ```compile_fail\n struct X { x: (), }\n@@ -264,7 +322,7 @@ trait Foo where Self: Sized {\n }\n ```\n \n-we cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n+We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n `Self` would not be `Sized`.\n \n Generally, `Self : Sized` is used to indicate that the trait should not be used\n@@ -294,7 +352,7 @@ impl Trait for u8 {\n ```\n \n (Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n-cause this problem)\n+cause this problem.)\n \n In such a case, the compiler cannot predict the return type of `foo()` in a\n situation like the following:\n@@ -573,15 +631,15 @@ type X = u32; // ok!\n \"##,\n \n E0133: r##\"\n-Using unsafe functionality, is potentially dangerous and disallowed\n-by safety checks. Examples:\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n \n-- Dereferencing raw pointers\n-- Calling functions via FFI\n-- Calling functions marked unsafe\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n \n-These safety checks can be relaxed for a section of the code\n-by wrapping the unsafe instructions with an `unsafe` block. For instance:\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n \n ```\n unsafe fn f() { return; }\n@@ -1039,14 +1097,16 @@ let y = match x {\n println!(\"{}\", y);\n ```\n \n-In the previous example, the print statement was never reached when the wildcard\n-match arm was hit, so we were okay with `foo()` not returning an integer that we\n-could set to `y`. But in this example, `foo()` actually does return control, so\n-the print statement will be executed with an uninitialized value.\n+In the previous example, the print statement was never reached when the\n+wildcard match arm was hit, so we were okay with `foo()` not returning an\n+integer that we could set to `y`. But in this example, `foo()` actually does\n+return control, so the print statement will be executed with an uninitialized\n+value.\n \n Obviously we cannot have functions which are allowed to be used in such\n positions and yet can return control. So, if you are defining a function that\n-returns `!`, make sure that there is no way for it to actually finish executing.\n+returns `!`, make sure that there is no way for it to actually finish\n+executing.\n \"##,\n \n E0271: r##\"\n@@ -1206,19 +1266,19 @@ trait Index<Idx> { ... }\n foo(true); // `bool` does not implement `Index<u8>`\n ```\n \n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+There will be an error about `bool` not implementing `Index<u8>`, followed by a\n note saying \"the type `bool` cannot be indexed by `u8`\".\n \n-As you can see, you can specify type parameters in curly braces for substitution\n-with the actual types (using the regular format string syntax) in a given\n-situation. Furthermore, `{Self}` will substitute to the type (in this case,\n-`bool`) that we tried to use.\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n \n This error appears when the curly braces contain an identifier which doesn't\n-match with any of the type parameters or the string `Self`. This might happen if\n-you misspelled a type parameter, or if you intended to use literal curly braces.\n-If it is the latter, escape the curly braces with a second curly brace of the\n-same type; e.g. a literal `{` is `{{`\n+match with any of the type parameters or the string `Self`. This might happen\n+if you misspelled a type parameter, or if you intended to use literal curly\n+braces. If it is the latter, escape the curly braces with a second curly brace\n+of the same type; e.g. a literal `{` is `{{`.\n \"##,\n \n E0273: r##\"\n@@ -1239,10 +1299,10 @@ foo(true); // `bool` does not implement `Index<u8>`\n there will be an error about `bool` not implementing `Index<u8>`, followed by a\n note saying \"the type `bool` cannot be indexed by `u8`\".\n \n-As you can see, you can specify type parameters in curly braces for substitution\n-with the actual types (using the regular format string syntax) in a given\n-situation. Furthermore, `{Self}` will substitute to the type (in this case,\n-`bool`) that we tried to use.\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n \n This error appears when the curly braces do not contain an identifier. Please\n add one of the same name as a type parameter. If you intended to use literal\n@@ -1274,8 +1334,8 @@ trait.\n \n E0275: r##\"\n This error occurs when there was a recursive trait requirement that overflowed\n-before it could be evaluated. Often this means that there is unbounded recursion\n-in resolving some type bounds.\n+before it could be evaluated. Often this means that there is unbounded\n+recursion in resolving some type bounds.\n \n For example, in the following code:\n \n@@ -1288,9 +1348,9 @@ impl<T> Foo for T where Bar<T>: Foo {}\n ```\n \n To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n-to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To determine\n-this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is clearly a\n-recursive requirement that can't be resolved directly.\n+to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To\n+determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is\n+clearly a recursive requirement that can't be resolved directly.\n \n Consider changing your trait bounds so that they're less self-referential.\n \"##,\n@@ -1336,7 +1396,7 @@ fn main() {\n     // we now call the method with the i32 type, which doesn't implement\n     // the Foo trait\n     some_func(5i32); // error: the trait `Foo` is not implemented for the\n-                     //     type `i32`\n+                     //        type `i32`\n }\n ```\n \n@@ -1564,7 +1624,9 @@ borrows were allowed:\n ```compile_fail\n match Some(()) {\n     None => { },\n-    option if option.take().is_none() => { /* impossible, option is `Some` */ },\n+    option if option.take().is_none() => {\n+        /* impossible, option is `Some` */\n+    },\n     Some(_) => { } // When the previous match failed, the option became `None`.\n }\n ```\n@@ -1615,12 +1677,29 @@ See also https://github.com/rust-lang/rust/issues/14587\n \n E0306: r##\"\n In an array literal `[x; N]`, `N` is the number of elements in the array. This\n-number cannot be negative.\n+must be an unsigned integer. Erroneous code example:\n+\n+```compile_fail\n+let x = [0i32; true]; // error: expected positive integer for repeat count,\n+                      //        found boolean\n+```\n+\n+Working example:\n+\n+```\n+let x = [0i32; 2];\n+```\n \"##,\n \n E0307: r##\"\n-The length of an array is part of its type. For this reason, this length must be\n-a compile-time constant.\n+The length of an array is part of its type. For this reason, this length must\n+be a compile-time constant. Erroneous code example:\n+\n+```compile_fail\n+    let len = 10;\n+    let x = [0i32; len]; // error: expected constant integer for repeat count,\n+                         //        found variable\n+```\n \"##,\n \n E0308: r##\"\n@@ -1713,24 +1792,22 @@ struct Foo<T: 'static> {\n \"##,\n \n E0398: r##\"\n-In Rust 1.3, the default object lifetime bounds are expected to\n-change, as described in RFC #1156 [1]. You are getting a warning\n-because the compiler thinks it is possible that this change will cause\n-a compilation error in your code. It is possible, though unlikely,\n-that this is a false alarm.\n-\n-The heart of the change is that where `&'a Box<SomeTrait>` used to\n-default to `&'a Box<SomeTrait+'a>`, it now defaults to `&'a\n-Box<SomeTrait+'static>` (here, `SomeTrait` is the name of some trait\n-type). Note that the only types which are affected are references to\n-boxes, like `&Box<SomeTrait>` or `&[Box<SomeTrait>]`.  More common\n-types like `&SomeTrait` or `Box<SomeTrait>` are unaffected.\n-\n-To silence this warning, edit your code to use an explicit bound.\n-Most of the time, this means that you will want to change the\n-signature of a function that you are calling. For example, if\n-the error is reported on a call like `foo(x)`, and `foo` is\n-defined as follows:\n+In Rust 1.3, the default object lifetime bounds are expected to change, as\n+described in RFC #1156 [1]. You are getting a warning because the compiler\n+thinks it is possible that this change will cause a compilation error in your\n+code. It is possible, though unlikely, that this is a false alarm.\n+\n+The heart of the change is that where `&'a Box<SomeTrait>` used to default to\n+`&'a Box<SomeTrait+'a>`, it now defaults to `&'a Box<SomeTrait+'static>` (here,\n+`SomeTrait` is the name of some trait type). Note that the only types which are\n+affected are references to boxes, like `&Box<SomeTrait>` or\n+`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`\n+are unaffected.\n+\n+To silence this warning, edit your code to use an explicit bound. Most of the\n+time, this means that you will want to change the signature of a function that\n+you are calling. For example, if the error is reported on a call like `foo(x)`,\n+and `foo` is defined as follows:\n \n ```ignore\n fn foo(arg: &Box<SomeTrait>) { ... }\n@@ -1742,8 +1819,8 @@ You might change it to:\n fn foo<'a>(arg: &Box<SomeTrait+'a>) { ... }\n ```\n \n-This explicitly states that you expect the trait object `SomeTrait` to\n-contain references (with a maximum lifetime of `'a`).\n+This explicitly states that you expect the trait object `SomeTrait` to contain\n+references (with a maximum lifetime of `'a`).\n \n [1]: https://github.com/rust-lang/rfcs/pull/1156\n \"##,\n@@ -1812,8 +1889,8 @@ Also, for now, it is not possible to write deprecation messages either.\n \"##,\n \n E0517: r##\"\n-This error indicates that a `#[repr(..)]` attribute was placed on an unsupported\n-item.\n+This error indicates that a `#[repr(..)]` attribute was placed on an\n+unsupported item.\n \n Examples of erroneous code:\n \n@@ -1829,29 +1906,29 @@ struct Foo {bar: bool, baz: bool}\n \n #[repr(C)]\n impl Foo {\n-    ...\n+    // ...\n }\n ```\n \n- - The `#[repr(C)]` attribute can only be placed on structs and enums\n- - The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs\n- - The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums\n+* The `#[repr(C)]` attribute can only be placed on structs and enums.\n+* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\n+* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\n \n These attributes do not work on typedefs, since typedefs are just aliases.\n \n Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\n-discriminant size for C-like enums (when there is no associated data, e.g. `enum\n-Color {Red, Blue, Green}`), effectively setting the size of the enum to the size\n-of the provided type. Such an enum can be cast to a value of the same type as\n-well. In short, `#[repr(u8)]` makes the enum behave like an integer with a\n-constrained set of allowed values.\n+discriminant size for C-like enums (when there is no associated data, e.g.\n+`enum Color {Red, Blue, Green}`), effectively setting the size of the enum to\n+the size of the provided type. Such an enum can be cast to a value of the same\n+type as well. In short, `#[repr(u8)]` makes the enum behave like an integer\n+with a constrained set of allowed values.\n \n Only C-like enums can be cast to numerical primitives, so this attribute will\n not apply to structs.\n \n `#[repr(packed)]` reduces padding to make the struct size smaller. The\n-representation of enums isn't strictly defined in Rust, and this attribute won't\n-work on enums.\n+representation of enums isn't strictly defined in Rust, and this attribute\n+won't work on enums.\n \n `#[repr(simd)]` will give a struct consisting of a homogenous series of machine\n types (i.e. `u8`, `i32`, etc) a representation that permits vectorization via\n@@ -1860,8 +1937,8 @@ single list of data.\n \"##,\n \n E0518: r##\"\n-This error indicates that an `#[inline(..)]` attribute was incorrectly placed on\n-something other than a function or method.\n+This error indicates that an `#[inline(..)]` attribute was incorrectly placed\n+on something other than a function or method.\n \n Examples of erroneous code:\n \n@@ -1871,7 +1948,7 @@ struct Foo;\n \n #[inline(never)]\n impl Foo {\n-    ...\n+    // ...\n }\n ```\n "}, {"sha": "7f6fd9de3d294709957a0e363e4cc5f5d5ee541c", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -26,7 +26,8 @@ fn foo() -> Box<Fn(u32) -> u32> {\n \n Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n closed-over data by reference. This means that once `foo()` returns, `x` no\n-longer exists. An attempt to access `x` within the closure would thus be unsafe.\n+longer exists. An attempt to access `x` within the closure would thus be\n+unsafe.\n \n Another situation where this might be encountered is when spawning threads:\n \n@@ -73,7 +74,14 @@ fn main() {\n ```\n \n To fix this, ensure that any declared variables are initialized before being\n-used.\n+used. Example:\n+\n+```\n+fn main() {\n+    let x: i32 = 0;\n+    let y = x; // ok!\n+}\n+```\n \"##,\n \n E0382: r##\"\n@@ -210,8 +218,8 @@ let mut y: Box<_> = Box::new(&mut x);\n **y = 2;\n ```\n \n-It can also be fixed by using a type with interior mutability, such as `Cell` or\n-`RefCell`:\n+It can also be fixed by using a type with interior mutability, such as `Cell`\n+or `RefCell`:\n \n ```\n use std::cell::Cell;\n@@ -259,8 +267,8 @@ fn foo<F: FnMut()>(f: F) { }\n ```\n \n Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n-interior mutability through a shared reference. Our example's `mutable` function\n-could be redefined as below:\n+interior mutability through a shared reference. Our example's `mutable`\n+function could be redefined as below:\n \n ```\n use std::cell::Cell;"}, {"sha": "36ba3d0ca73636bb291c1310ab4c9e6b4998c5d9", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -27,8 +27,8 @@ pub fn foo<T: Foo> (t: T) {} // same error\n ```\n \n To solve this error, please ensure that the trait is also public. The trait\n-can be made inaccessible if necessary by placing it into a private inner module,\n-but it still has to be marked with `pub`. Example:\n+can be made inaccessible if necessary by placing it into a private inner\n+module, but it still has to be marked with `pub`. Example:\n \n ```ignore\n pub trait Foo { // we set the Foo trait public\n@@ -55,8 +55,8 @@ mod Foo {\n ```\n \n To solve this error, please ensure that the type is also public. The type\n-can be made inaccessible if necessary by placing it into a private inner module,\n-but it still has to be marked with `pub`.\n+can be made inaccessible if necessary by placing it into a private inner\n+module, but it still has to be marked with `pub`.\n Example:\n \n ```\n@@ -165,7 +165,7 @@ let f = Bar::Foo(0); // error: cannot invoke tuple struct constructor with\n ```\n \n To solve this issue, please ensure that all of the fields of the tuple struct\n-are public. Alternatively, provide a new() method to the tuple struct to\n+are public. Alternatively, provide a `new()` method to the tuple struct to\n construct it from a given inner value. Example:\n \n ```"}, {"sha": "dee2727c163167b65ddf83cc186173db1712c79e", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -94,8 +94,8 @@ mod bar {\n \"##,\n \n E0253: r##\"\n-Attempt was made to import an unimportable value. This can happen when\n-trying to import a method from a trait. An example of this error:\n+Attempt was made to import an unimportable value. This can happen when trying\n+to import a method from a trait. An example of this error:\n \n ```compile_fail\n mod foo {\n@@ -149,10 +149,10 @@ fn main() {}\n \"##,\n \n E0259: r##\"\n-The name chosen for an external crate conflicts with another external crate that\n-has been imported into the current module.\n+The name chosen for an external crate conflicts with another external crate\n+that has been imported into the current module.\n \n-Wrong example:\n+Erroneous code example:\n \n ```compile_fail\n extern crate a;\n@@ -251,8 +251,8 @@ https://doc.rust-lang.org/reference.html#types\n \"##,\n \n E0364: r##\"\n-Private items cannot be publicly re-exported.  This error indicates that\n-you attempted to `pub use` a type or value that was not itself public.\n+Private items cannot be publicly re-exported.  This error indicates that you\n+attempted to `pub use` a type or value that was not itself public.\n \n Here is an example that demonstrates the error:\n \n@@ -275,15 +275,15 @@ mod foo {\n pub use foo::X;\n ```\n \n-See the 'Use Declarations' section of the reference for more information\n-on this topic:\n+See the 'Use Declarations' section of the reference for more information on\n+this topic:\n \n https://doc.rust-lang.org/reference.html#use-declarations\n \"##,\n \n E0365: r##\"\n-Private modules cannot be publicly re-exported.  This error indicates\n-that you attempted to `pub use` a module that was not itself public.\n+Private modules cannot be publicly re-exported. This error indicates that you\n+attempted to `pub use` a module that was not itself public.\n \n Here is an example that demonstrates the error:\n \n@@ -313,8 +313,8 @@ https://doc.rust-lang.org/reference.html#use-declarations\n \"##,\n \n E0401: r##\"\n-Inner items do not inherit type parameters from the functions they are\n-embedded in. For example, this will not compile:\n+Inner items do not inherit type parameters from the functions they are embedded\n+in. For example, this will not compile:\n \n ```compile_fail\n fn foo<T>(x: T) {\n@@ -543,16 +543,15 @@ impl Bar {\n \"##,\n \n E0411: r##\"\n-The `Self` keyword was used outside an impl or a trait. Erroneous\n-code example:\n+The `Self` keyword was used outside an impl or a trait. Erroneous code example:\n \n ```compile_fail\n <Self>::foo; // error: use of `Self` outside of an impl or trait\n ```\n \n-The `Self` keyword represents the current type, which explains why it\n-can only be used inside an impl or a trait. It gives access to the\n-associated items of a type:\n+The `Self` keyword represents the current type, which explains why it can only\n+be used inside an impl or a trait. It gives access to the associated items of a\n+type:\n \n ```\n trait Foo {\n@@ -564,7 +563,7 @@ trait Baz : Foo {\n }\n ```\n \n-However, be careful when two types has a common associated type:\n+However, be careful when two types have a common associated type:\n \n ```compile_fail\n trait Foo {\n@@ -581,8 +580,8 @@ trait Baz : Foo + Foo2 {\n }\n ```\n \n-This problem can be solved by specifying from which trait we want\n-to use the `Bar` type:\n+This problem can be solved by specifying from which trait we want to use the\n+`Bar` type:\n \n ```\n trait Foo {\n@@ -604,16 +603,20 @@ An undeclared type name was used. Example of erroneous codes:\n \n ```compile_fail\n impl Something {} // error: use of undeclared type name `Something`\n+\n // or:\n+\n trait Foo {\n     fn bar(N); // error: use of undeclared type name `N`\n }\n+\n // or:\n+\n fn foo(x: T) {} // error: use of undeclared type name `T`\n ```\n \n-To fix this error, please verify you didn't misspell the type name,\n-you did declare it or imported it into the scope. Examples:\n+To fix this error, please verify you didn't misspell the type name, you did\n+declare it or imported it into the scope. Examples:\n \n ```\n struct Something;\n@@ -635,8 +638,8 @@ fn foo<T>(x: T) {} // ok!\n \"##,\n \n E0413: r##\"\n-A declaration shadows an enum variant or unit-like struct in scope.\n-Example of erroneous code:\n+A declaration shadows an enum variant or unit-like struct in scope. Example of\n+erroneous code:\n \n ```compile_fail\n struct Foo;\n@@ -666,8 +669,7 @@ The goal here is to avoid a conflict of names.\n \"##,\n \n E0415: r##\"\n-More than one function parameter have the same name. Example of erroneous\n-code:\n+More than one function parameter have the same name. Example of erroneous code:\n \n ```compile_fail\n fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n@@ -682,8 +684,7 @@ fn foo(f: i32, g: i32) {} // ok!\n \"##,\n \n E0416: r##\"\n-An identifier is bound more than once in a pattern. Example of erroneous\n-code:\n+An identifier is bound more than once in a pattern. Example of erroneous code:\n \n ```compile_fail\n match (1, 2) {\n@@ -739,8 +740,7 @@ match 0 {\n \"##,\n \n E0419: r##\"\n-An unknown enum variant, struct or const was used. Example of\n-erroneous code:\n+An unknown enum variant, struct or const was used. Example of erroneous code:\n \n ```compile_fail\n match 0 {\n@@ -766,8 +766,8 @@ match Something::NotFoo {\n \"##,\n \n E0422: r##\"\n-You are trying to use an identifier that is either undefined or not a\n-struct. For instance:\n+You are trying to use an identifier that is either undefined or not a struct.\n+For instance:\n \n ``` compile_fail\n fn main () {\n@@ -785,13 +785,13 @@ fn main () {\n }\n ```\n \n-In this case, `foo` is defined, but is not a struct, so Rust can't use\n-it as one.\n+In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n+one.\n \"##,\n \n E0423: r##\"\n-A `struct` variant name was used like a function name. Example of\n-erroneous code:\n+A `struct` variant name was used like a function name. Example of erroneous\n+code:\n \n ```compile_fail\n struct Foo { a: bool};\n@@ -801,8 +801,8 @@ let f = Foo();\n //        it like a function name\n ```\n \n-Please verify you didn't misspell the name of what you actually wanted\n-to use here. Example:\n+Please verify you didn't misspell the name of what you actually wanted to use\n+here. Example:\n \n ```\n fn Foo() -> u32 { 0 }\n@@ -851,13 +851,15 @@ something_that_doesnt_exist::foo;\n // error: unresolved name `something_that_doesnt_exist::foo`\n \n // or:\n+\n trait Foo {\n     fn bar() {\n         Self; // error: unresolved name `Self`\n     }\n }\n \n // or:\n+\n let x = unknown_variable;  // error: unresolved name `unknown_variable`\n ```\n \n@@ -941,7 +943,7 @@ use something::self; // ok!\n \"##,\n \n E0431: r##\"\n-`self` import was made. Erroneous code example:\n+An invalid `self` import was made. Erroneous code example:\n \n ```compile_fail\n use {self}; // error: `self` import can only appear in an import list with a"}, {"sha": "7220690469c2a62080bb6170efdf23f7e2f2baa8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -1157,9 +1157,10 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// If the map did not have this key present, `None` is returned.\n     ///\n-    /// If the map did have this key present, the key is not updated, the\n-    /// value is updated and the old value is returned.\n-    /// See the [module-level documentation] for more.\n+    /// If the map did have this key present, the value is updated, and the old\n+    /// value is returned. The key is not updated, though; this matters for\n+    /// types that can be `==` without being identical. See the [module-level\n+    /// documentation] for more.\n     ///\n     /// [module-level documentation]: index.html#insert-and-complex-keys\n     ///"}, {"sha": "06c14157606b2a40b7f2b9a96f6487cea445bd93", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -397,12 +397,15 @@\n //! }\n //!\n //! let mut map = BTreeMap::new();\n-//! map.insert(Foo { a: 1, b: \"baz\" }, ());\n+//! map.insert(Foo { a: 1, b: \"baz\" }, 99);\n //!\n //! // We already have a Foo with an a of 1, so this will be updating the value.\n-//! map.insert(Foo { a: 1, b: \"xyz\" }, ());\n+//! map.insert(Foo { a: 1, b: \"xyz\" }, 100);\n //!\n-//! // ... but the key hasn't changed. b is still \"baz\", not \"xyz\"\n+//! // The value has been updated...\n+//! assert_eq!(map.values().next().unwrap(), &100);\n+//!\n+//! // ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\n //! assert_eq!(map.keys().next().unwrap().b, \"baz\");\n //! ```\n "}, {"sha": "3798fb76ad6a5784c8c7118d2004c9dcafd7601d", "filename": "src/libstd/path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -1582,8 +1582,10 @@ impl Path {\n \n     /// Returns a path that, when joined onto `base`, yields `self`.\n     ///\n+    /// # Errors\n+    ///\n     /// If `base` is not a prefix of `self` (i.e. `starts_with`\n-    /// returns false), then `relative_from` returns `None`.\n+    /// returns `false`), returns `Err`.\n     #[stable(since = \"1.7.0\", feature = \"path_strip_prefix\")]\n     pub fn strip_prefix<'a, P: ?Sized>(&'a self, base: &'a P)\n                                        -> Result<&'a Path, StripPrefixError>"}, {"sha": "b840e51873e3f2f40534c1b777813a3a8ca873d4", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18f7a1c5af91f8630f3c47f73f490c49b61acde/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=e18f7a1c5af91f8630f3c47f73f490c49b61acde", "patch": "@@ -50,27 +50,30 @@ mod prim_bool { }\n /// [`String`]: string/struct.String.html\n ///\n /// As always, remember that a human intuition for 'character' may not map to\n-/// Unicode's definitions. For example, emoji symbols such as '\u2764\ufe0f' are more than\n-/// one byte; \u2764\ufe0f in particular is six:\n+/// Unicode's definitions. For example, emoji symbols such as '\u2764\ufe0f' can be more\n+/// than one Unicode code point; this \u2764\ufe0f in particular is two:\n ///\n /// ```\n /// let s = String::from(\"\u2764\ufe0f\");\n ///\n-/// // six bytes times one byte for each element\n-/// assert_eq!(6, s.len() * std::mem::size_of::<u8>());\n+/// // we get two chars out of a single \u2764\ufe0f\n+/// let mut iter = s.chars();\n+/// assert_eq!(Some('\\u{2764}'), iter.next());\n+/// assert_eq!(Some('\\u{fe0f}'), iter.next());\n+/// assert_eq!(None, iter.next());\n /// ```\n ///\n-/// This also means it won't fit into a `char`, and so trying to create a\n-/// literal with `let heart = '\u2764\ufe0f';` gives an error:\n+/// This means it won't fit into a `char`. Trying to create a literal with\n+/// `let heart = '\u2764\ufe0f';` gives an error:\n ///\n /// ```text\n /// error: character literal may only contain one codepoint: '\u2764\n /// let heart = '\u2764\ufe0f';\n ///             ^~\n /// ```\n ///\n-/// Another implication of this is that if you want to do per-`char`acter\n-/// processing, it can end up using a lot more memory:\n+/// Another implication of the 4-byte fixed size of a `char`, is that\n+/// per-`char`acter processing can end up using a lot more memory:\n ///\n /// ```\n /// let s = String::from(\"love: \u2764\ufe0f\");\n@@ -79,19 +82,6 @@ mod prim_bool { }\n /// assert_eq!(12, s.len() * std::mem::size_of::<u8>());\n /// assert_eq!(32, v.len() * std::mem::size_of::<char>());\n /// ```\n-///\n-/// Or may give you results you may not expect:\n-///\n-/// ```\n-/// let s = String::from(\"\u2764\ufe0f\");\n-///\n-/// let mut iter = s.chars();\n-///\n-/// // we get two chars out of a single \u2764\ufe0f\n-/// assert_eq!(Some('\\u{2764}'), iter.next());\n-/// assert_eq!(Some('\\u{fe0f}'), iter.next());\n-/// assert_eq!(None, iter.next());\n-/// ```\n mod prim_char { }\n \n #[doc(primitive = \"unit\")]"}]}