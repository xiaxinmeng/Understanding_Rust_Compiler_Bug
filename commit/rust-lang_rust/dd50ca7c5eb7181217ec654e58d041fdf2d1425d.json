{"sha": "dd50ca7c5eb7181217ec654e58d041fdf2d1425d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNTBjYTdjNWViNzE4MTIxN2VjNjU0ZTU4ZDA0MWZkZjJkMTQyNWQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-22T18:00:34Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-22T18:23:56Z"}, "message": "Refactor SubtreeSource", "tree": {"sha": "6693a3b6589c172e986a27d0d77834fe3fd860b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6693a3b6589c172e986a27d0d77834fe3fd860b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd50ca7c5eb7181217ec654e58d041fdf2d1425d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd50ca7c5eb7181217ec654e58d041fdf2d1425d", "html_url": "https://github.com/rust-lang/rust/commit/dd50ca7c5eb7181217ec654e58d041fdf2d1425d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd50ca7c5eb7181217ec654e58d041fdf2d1425d/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d7a567bc56d7254178394788b6f9de22eb8cb2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d7a567bc56d7254178394788b6f9de22eb8cb2c", "html_url": "https://github.com/rust-lang/rust/commit/4d7a567bc56d7254178394788b6f9de22eb8cb2c"}], "stats": {"total": 289, "additions": 88, "deletions": 201}, "files": [{"sha": "709b87a38494acff19ab69cf584b2194ce5cc5d5", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd50ca7c5eb7181217ec654e58d041fdf2d1425d/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd50ca7c5eb7181217ec654e58d041fdf2d1425d/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=dd50ca7c5eb7181217ec654e58d041fdf2d1425d", "patch": "@@ -2,6 +2,7 @@ use crate::subtree_source::SubtreeTokenSource;\n \n use ra_parser::{TokenSource, TreeSink};\n use ra_syntax::{SyntaxKind};\n+use tt::buffer::TokenBuffer;\n \n struct OffsetTokenSink {\n     token_pos: usize,\n@@ -69,7 +70,8 @@ impl<'a> Parser<'a> {\n     where\n         F: FnOnce(&dyn TokenSource, &mut dyn TreeSink),\n     {\n-        let mut src = SubtreeTokenSource::new(&self.subtree.token_trees[*self.cur_pos..]);\n+        let buffer = TokenBuffer::new(&self.subtree.token_trees[*self.cur_pos..]);\n+        let mut src = SubtreeTokenSource::new(&buffer);\n         let mut sink = OffsetTokenSink { token_pos: 0, error: false };\n \n         f(&src, &mut sink);\n@@ -85,7 +87,7 @@ impl<'a> Parser<'a> {\n         let res = src.bump_n(parsed_token);\n         *self.cur_pos += res.len();\n \n-        let res: Vec<_> = res.into_iter().cloned().collect();\n+        let res: Vec<_> = res.into_iter().collect();\n \n         match res.len() {\n             0 => None,"}, {"sha": "c9cbf4a204b6757f56f21eef68f846b49d029206", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 70, "deletions": 192, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/dd50ca7c5eb7181217ec654e58d041fdf2d1425d/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd50ca7c5eb7181217ec654e58d041fdf2d1425d/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=dd50ca7c5eb7181217ec654e58d041fdf2d1425d", "patch": "@@ -1,50 +1,10 @@\n use ra_parser::{TokenSource};\n use ra_syntax::{classify_literal, SmolStr, SyntaxKind, SyntaxKind::*, T};\n-use std::cell::{RefCell};\n+use std::cell::{RefCell, Cell};\n+use tt::buffer::{TokenBuffer, Cursor};\n \n-// A Sequece of Token,\n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub(super) enum TokenSeq<'a> {\n-    Subtree(&'a tt::Subtree),\n-    Seq(&'a [tt::TokenTree]),\n-}\n-\n-impl<'a> From<&'a tt::Subtree> for TokenSeq<'a> {\n-    fn from(s: &'a tt::Subtree) -> TokenSeq<'a> {\n-        TokenSeq::Subtree(s)\n-    }\n-}\n-\n-impl<'a> From<&'a [tt::TokenTree]> for TokenSeq<'a> {\n-    fn from(s: &'a [tt::TokenTree]) -> TokenSeq<'a> {\n-        TokenSeq::Seq(s)\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum DelimToken<'a> {\n-    Delim(&'a tt::Delimiter, bool),\n-    Token(&'a tt::TokenTree),\n-    End,\n-}\n-\n-impl<'a> TokenSeq<'a> {\n-    fn get(&self, pos: usize) -> DelimToken<'a> {\n-        match self {\n-            TokenSeq::Subtree(subtree) => {\n-                let len = subtree.token_trees.len() + 2;\n-                match pos {\n-                    p if p >= len => DelimToken::End,\n-                    p if p == len - 1 => DelimToken::Delim(&subtree.delimiter, true),\n-                    0 => DelimToken::Delim(&subtree.delimiter, false),\n-                    p => DelimToken::Token(&subtree.token_trees[p - 1]),\n-                }\n-            }\n-            TokenSeq::Seq(tokens) => {\n-                tokens.get(pos).map(DelimToken::Token).unwrap_or(DelimToken::End)\n-            }\n-        }\n-    }\n+pub(crate) trait Querier {\n+    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool);\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -54,183 +14,101 @@ struct TtToken {\n     pub text: SmolStr,\n }\n \n-#[derive(Debug, Clone, Eq, PartialEq)]\n-enum WalkCursor {\n-    Token(usize, TtToken),\n-    Eof,\n-}\n-\n-#[derive(Debug)]\n-struct SubTreeWalker<'a> {\n-    pos: usize,\n-    stack: Vec<(TokenSeq<'a>, usize)>,\n-    cursor: WalkCursor,\n-    ts: TokenSeq<'a>,\n-}\n-\n-impl<'a> SubTreeWalker<'a> {\n-    fn new(ts: TokenSeq<'a>) -> SubTreeWalker {\n-        let mut res = SubTreeWalker { pos: 0, stack: vec![], cursor: WalkCursor::Eof, ts };\n-\n-        res.reset();\n-        res\n-    }\n-\n-    fn is_eof(&self) -> bool {\n-        self.cursor == WalkCursor::Eof\n-    }\n-\n-    fn reset(&mut self) {\n-        self.pos = 0;\n-        self.stack = vec![];\n-\n-        self.cursor = match self.ts.get(0) {\n-            DelimToken::Token(token) => match token {\n-                tt::TokenTree::Subtree(subtree) => {\n-                    let ts = TokenSeq::from(subtree);\n-                    self.stack.push((ts, 0));\n-                    WalkCursor::Token(0, convert_delim(subtree.delimiter, false))\n-                }\n-                tt::TokenTree::Leaf(leaf) => WalkCursor::Token(0, convert_leaf(leaf)),\n-            },\n-            DelimToken::Delim(delim, is_end) => {\n-                assert!(!is_end);\n-                WalkCursor::Token(0, convert_delim(*delim, false))\n-            }\n-            DelimToken::End => WalkCursor::Eof,\n-        }\n-    }\n-\n-    fn current(&self) -> Option<&TtToken> {\n-        match &self.cursor {\n-            WalkCursor::Token(_, t) => Some(t),\n-            WalkCursor::Eof => None,\n-        }\n-    }\n-\n-    fn top(&self) -> &TokenSeq {\n-        self.stack.last().map(|(t, _)| t).unwrap_or(&self.ts)\n-    }\n-\n-    /// Move cursor forward by 1 step        \n-    fn forward(&mut self) {\n-        if self.is_eof() {\n-            return;\n-        }\n-        self.pos += 1;\n-\n-        if let WalkCursor::Token(u, _) = self.cursor {\n-            self.cursor = self.walk_token(u)\n-        }\n-    }\n-\n-    /// Traversal child token\n-    fn walk_token(&mut self, pos: usize) -> WalkCursor {\n-        let top = self.stack.last().map(|(t, _)| t).unwrap_or(&self.ts);\n-        let pos = pos + 1;\n-\n-        match top.get(pos) {\n-            DelimToken::Token(token) => match token {\n-                tt::TokenTree::Subtree(subtree) => {\n-                    let ts = TokenSeq::from(subtree);\n-                    self.stack.push((ts, pos));\n-                    WalkCursor::Token(0, convert_delim(subtree.delimiter, false))\n-                }\n-                tt::TokenTree::Leaf(leaf) => WalkCursor::Token(pos, convert_leaf(leaf)),\n-            },\n-            DelimToken::Delim(delim, is_end) => {\n-                WalkCursor::Token(pos, convert_delim(*delim, is_end))\n-            }\n-            DelimToken::End => {\n-                // it is the top level\n-                if let Some((_, last_idx)) = self.stack.pop() {\n-                    self.walk_token(last_idx)\n-                } else {\n-                    WalkCursor::Eof\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub(crate) trait Querier {\n-    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool);\n-}\n-\n // A wrapper class for ref cell\n #[derive(Debug)]\n-pub(crate) struct WalkerOwner<'a> {\n-    walker: RefCell<SubTreeWalker<'a>>,\n+pub(crate) struct SubtreeWalk<'a> {\n+    start: Cursor<'a>,\n+    cursor: Cell<Cursor<'a>>,\n     cached: RefCell<Vec<Option<TtToken>>>,\n }\n \n-impl<'a> WalkerOwner<'a> {\n-    fn new<I: Into<TokenSeq<'a>>>(ts: I) -> Self {\n-        WalkerOwner {\n-            walker: RefCell::new(SubTreeWalker::new(ts.into())),\n+impl<'a> SubtreeWalk<'a> {\n+    fn new(cursor: Cursor<'a>) -> Self {\n+        SubtreeWalk {\n+            start: cursor,\n+            cursor: Cell::new(cursor),\n             cached: RefCell::new(Vec::with_capacity(10)),\n         }\n     }\n \n-    fn get<'b>(&self, pos: usize) -> Option<TtToken> {\n+    fn get(&self, pos: usize) -> Option<TtToken> {\n         let mut cached = self.cached.borrow_mut();\n         if pos < cached.len() {\n             return cached[pos].clone();\n         }\n \n         while pos >= cached.len() {\n-            self.set_pos(cached.len());\n-            let walker = self.walker.borrow();\n-            cached.push(walker.current().cloned());\n+            let cursor = self.cursor.get();\n+            if cursor.eof() {\n+                cached.push(None);\n+                continue;\n+            }\n+            \n+            match cursor.token_tree() {\n+                Some(tt::TokenTree::Leaf(leaf)) => {\n+                    cached.push(Some(convert_leaf(&leaf)));\n+                    self.cursor.set(cursor.bump());\n+                }\n+                Some(tt::TokenTree::Subtree(subtree)) => {\n+                    self.cursor.set(cursor.subtree().unwrap());\n+                    cached.push(Some(convert_delim(subtree.delimiter, false)));\n+                }\n+                None => {\n+                    if let Some(subtree) = cursor.end() {\n+                        cached.push(Some(convert_delim(subtree.delimiter, true)));\n+                        self.cursor.set(cursor.bump());\n+                    }\n+                }\n+            }\n         }\n \n         return cached[pos].clone();\n     }\n \n-    fn set_pos(&self, pos: usize) {\n-        let mut walker = self.walker.borrow_mut();\n-        assert!(walker.pos <= pos);\n+    fn collect_token_trees(&mut self, n: usize) -> Vec<tt::TokenTree> {\n+        let mut res = vec![];\n \n-        while pos > walker.pos && !walker.is_eof() {\n-            walker.forward();\n-        }\n-    }\n+        let mut pos = 0;\n+        let mut cursor = self.start;\n+        let mut level = 0;\n \n-    fn collect_token_trees(&mut self, n: usize) -> Vec<&tt::TokenTree> {\n-        let mut res = vec![];\n-        let mut walker = self.walker.borrow_mut();\n-        walker.reset();\n+        while pos < n {\n+            if cursor.eof() {\n+                break;\n+            }\n \n-        while walker.pos < n {\n-            if let WalkCursor::Token(u, _) = &walker.cursor {\n-                // We only collect the topmost child\n-                if walker.stack.len() == 0 {\n-                    if let DelimToken::Token(token) = walker.ts.get(*u) {\n-                        res.push(token);\n+            match cursor.token_tree() {\n+                Some(tt::TokenTree::Leaf(leaf)) => {\n+                    if level == 0 {\n+                        res.push(leaf.into());\n                     }\n+                    cursor = cursor.bump();\n+                    pos += 1;\n                 }\n-                // Check whether the second level is a subtree\n-                // if so, collect its parent which is topmost child\n-                else if walker.stack.len() == 1 {\n-                    if let DelimToken::Delim(_, is_end) = walker.top().get(*u) {\n-                        if !is_end {\n-                            let (_, last_idx) = &walker.stack[0];\n-                            if let DelimToken::Token(token) = walker.ts.get(*last_idx) {\n-                                res.push(token);\n-                            }\n-                        }\n+                Some(tt::TokenTree::Subtree(subtree)) => {\n+                    if level == 0 {\n+                        res.push(subtree.into());\n                     }\n+                    pos += 1;\n+                    level += 1;\n+                    cursor = cursor.subtree().unwrap();\n                 }\n-            }\n \n-            walker.forward();\n+                None => {\n+                    if let Some(_) = cursor.end() {\n+                        level -= 1;\n+                        pos += 1;\n+                        cursor = cursor.bump();\n+                    }\n+                }\n+            }\n         }\n \n         res\n     }\n }\n \n-impl<'a> Querier for WalkerOwner<'a> {\n+impl<'a> Querier for SubtreeWalk<'a> {\n     fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool) {\n         self.get(uidx)\n             .map(|tkn| (tkn.kind, tkn.text, tkn.is_joint_to_next))\n@@ -239,22 +117,22 @@ impl<'a> Querier for WalkerOwner<'a> {\n }\n \n pub(crate) struct SubtreeTokenSource<'a> {\n-    walker: WalkerOwner<'a>,\n+    walker: SubtreeWalk<'a>,\n }\n \n impl<'a> SubtreeTokenSource<'a> {\n-    pub fn new<I: Into<TokenSeq<'a>>>(ts: I) -> SubtreeTokenSource<'a> {\n-        SubtreeTokenSource { walker: WalkerOwner::new(ts) }\n+    pub fn new(buffer: &'a TokenBuffer) -> SubtreeTokenSource<'a> {\n+        SubtreeTokenSource { walker: SubtreeWalk::new(buffer.begin()) }\n     }\n \n-    pub fn querier<'b>(&'a self) -> &'b WalkerOwner<'a>\n+    pub fn querier<'b>(&'a self) -> &'b SubtreeWalk<'a>\n     where\n         'a: 'b,\n     {\n         &self.walker\n     }\n \n-    pub(crate) fn bump_n(&mut self, parsed_tokens: usize) -> Vec<&tt::TokenTree> {\n+    pub(crate) fn bump_n(&mut self, parsed_tokens: usize) -> Vec<tt::TokenTree> {\n         let res = self.walker.collect_token_trees(parsed_tokens);\n         res\n     }"}, {"sha": "0a75305b478ec871b684ba8a0d414a4ccbfcdfc9", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dd50ca7c5eb7181217ec654e58d041fdf2d1425d/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd50ca7c5eb7181217ec654e58d041fdf2d1425d/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=dd50ca7c5eb7181217ec654e58d041fdf2d1425d", "patch": "@@ -47,7 +47,8 @@ pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> Option<(tt::Subtree, Toke\n \n /// Parses the token tree (result of macro expansion) to an expression\n pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<TreeArc<ast::Expr>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_expr(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -62,7 +63,8 @@ pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<TreeArc<ast::Expr>, Expand\n \n /// Parses the token tree (result of macro expansion) to a Pattern\n pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<TreeArc<ast::Pat>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_pat(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -75,7 +77,8 @@ pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<TreeArc<ast::Pat>, ExpandEr\n \n /// Parses the token tree (result of macro expansion) to a Type\n pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<TreeArc<ast::TypeRef>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_ty(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -89,7 +92,8 @@ pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<TreeArc<ast::TypeRef>, Expan\n pub fn token_tree_to_macro_stmts(\n     tt: &tt::Subtree,\n ) -> Result<TreeArc<ast::MacroStmts>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_macro_stmts(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -103,7 +107,8 @@ pub fn token_tree_to_macro_stmts(\n pub fn token_tree_to_macro_items(\n     tt: &tt::Subtree,\n ) -> Result<TreeArc<ast::MacroItems>, ExpandError> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse_macro_items(&token_source, &mut tree_sink);\n     if tree_sink.roots.len() != 1 {\n@@ -115,7 +120,8 @@ pub fn token_tree_to_macro_items(\n \n /// Parses the token tree (result of macro expansion) as a sequence of items\n pub fn token_tree_to_ast_item_list(tt: &tt::Subtree) -> TreeArc<ast::SourceFile> {\n-    let token_source = SubtreeTokenSource::new(tt);\n+    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n+    let token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(token_source.querier());\n     ra_parser::parse(&token_source, &mut tree_sink);\n     let syntax = tree_sink.inner.finish();\n@@ -381,7 +387,8 @@ mod tests {\n             \"#,\n         );\n         let expansion = expand(&rules, \"literals!(foo)\");\n-        let tt_src = SubtreeTokenSource::new(&expansion);\n+        let buffer = tt::buffer::TokenBuffer::new(&[expansion.clone().into()]);\n+        let tt_src = SubtreeTokenSource::new(&buffer);\n \n         let query = tt_src.querier();\n "}]}