{"sha": "f1e698c838defa9535750312d3fc11ebf3a830e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZTY5OGM4MzhkZWZhOTUzNTc1MDMxMmQzZmMxMWViZjNhODMwZTk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-02-02T08:59:03Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-02-02T08:59:03Z"}, "message": "Save changes in the rope.\n\nAlso changes to using the new rustc interface", "tree": {"sha": "4f0598da7db4eba36d9674a7494ce0454aa335c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f0598da7db4eba36d9674a7494ce0454aa335c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1e698c838defa9535750312d3fc11ebf3a830e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1e698c838defa9535750312d3fc11ebf3a830e9", "html_url": "https://github.com/rust-lang/rust/commit/f1e698c838defa9535750312d3fc11ebf3a830e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1e698c838defa9535750312d3fc11ebf3a830e9/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0", "html_url": "https://github.com/rust-lang/rust/commit/5caf49ff63ef84961f0b489706d6fcf3bcc0c6f0"}], "stats": {"total": 749, "additions": 540, "deletions": 209}, "files": [{"sha": "22fdc0ff51dbe420b35b97780d959f4e21012426", "filename": "src/changes.rs", "status": "modified", "additions": 19, "deletions": 139, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f1e698c838defa9535750312d3fc11ebf3a830e9/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e698c838defa9535750312d3fc11ebf3a830e9/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=f1e698c838defa9535750312d3fc11ebf3a830e9", "patch": "@@ -15,9 +15,8 @@\n // docs\n \n use rope::{Rope, RopeSlice};\n-use std::collections::{HashMap, BTreeMap};\n-use std::collections::Bound::{Included, Unbounded};\n-use syntax::codemap::{CodeMap, Span, Pos};\n+use std::collections::HashMap;\n+use syntax::codemap::{CodeMap, Span, Pos, BytePos};\n use std::fmt;\n \n pub struct ChangeSet<'a> {\n@@ -27,34 +26,6 @@ pub struct ChangeSet<'a> {\n     // out into an adaptor.\n     codemap: &'a CodeMap,\n     pub count: u64,\n-    // TODO we need to map the start and end of spans differently\n-    // TODO needs to be per file\n-    adjusts: BTreeMap<usize, Adjustment>,\n-}\n-\n-// An extent over which we must adjust the position values.\n-#[derive(Show, Clone, Eq, PartialEq)]\n-struct Adjustment {\n-    // Start is implicit, given by its position in the map.\n-    end: usize,\n-    delta: isize,\n-}\n-\n-impl Adjustment {\n-    fn chop_left(&self, new_end: usize) -> Adjustment {\n-        Adjustment {\n-            end: new_end,\n-            delta: self.delta,\n-        }\n-    }\n-\n-    fn move_left(&self, mov: usize) -> Adjustment {\n-        assert!(self.delta > mov);\n-        Adjustment {\n-            end: self.end,\n-            delta: self.delta - mov,\n-        }\n-    }\n }\n \n pub struct FileIterator<'c, 'a: 'c> {\n@@ -69,7 +40,6 @@ impl<'a> ChangeSet<'a> {\n             file_map: HashMap::new(),\n             codemap: codemap,\n             count: 0,\n-            adjusts: BTreeMap::new(),\n         };\n \n         for f in codemap.files.borrow().iter() {\n@@ -84,100 +54,21 @@ impl<'a> ChangeSet<'a> {\n     pub fn change(&mut self, file_name: &str, start: usize, end: usize, text: String) {\n         println!(\"change: {}:{}-{} \\\"{}\\\"\", file_name, start, end, text);\n \n-        let new_len = text.len();\n         self.count += 1;\n \n-        let (key_start, adj_start, abs_start): (Option<usize>, Option<Adjustment>, usize) = {\n-            let before_start = self.adjusts.range(Unbounded, Included(&start)).next_back();\n-            match before_start {\n-                Some((k, a)) if a.end > start => (Some(*k), Some(a.clone()), (start as isize + a.delta) as usize),\n-                _ => (None, None, start)\n-            }\n-        };\n-        let (key_end, adj_end, abs_end) = {\n-            let before_end = self.adjusts.range(Unbounded, Included(&end)).next_back();\n-            match before_end {\n-                Some((k, a)) if a.end > end => (Some(*k), Some(a.clone()), (end as isize + a.delta) as usize),\n-                _ => (None, None, end)\n-            }\n-        };\n-\n-        {\n-            let file = &mut self.file_map[*file_name];\n-\n-            println!(\"change: absolute values {}-{}, replaces \\\"{}\\\"\",\n-                   abs_start, abs_end, file.slice(abs_start..abs_end));\n-\n-            file.remove(abs_start, abs_end);\n-            file.insert(abs_start, text);\n-\n-            // Record the changed locations.\n-            // TODO what if there is a change to the right of end? - need to iterate over all changes to the right :-(\n-            match (key_start, key_end) {\n-                (None, None) => {\n-                    // Factor this out?\n-                    let old_len = end as isize - start as isize;\n-                    let delta = new_len as isize - old_len;\n-                    self.adjusts.insert(end, Adjustment { end: file.len(), delta: delta });\n-                }\n-                (Some(k), None) => {\n-                    // Adjust the old change.\n-                    self.adjusts[k] = adj_start.unwrap().chop_left(end);\n-\n-                    // Add the new one.\n-                    let old_len = end as isize - start as isize;\n-                    let delta = new_len as isize - old_len;\n-                    self.adjusts.insert(end, Adjustment { end: file.len(), delta: delta });\n-                }\n-                (None, Some(k)) => {\n-                    let old_len = end as isize - start as isize;\n-                    let delta = new_len as isize - old_len;\n-\n-                    // Adjust the old change.\n-                    // TODO only if we move left, but what if moving right?\n-                    self.adjusts[abs_end] = adj_end.unwrap().move_left(TODO);\n-                    self.adjusts.remove(&k);\n-\n-                    // Add the new one.\n-                    self.adjusts.insert(end, Adjustment { end: file.len(), delta: delta });\n-                }\n-                _ => {\n-                    println!(\"{}\", file);\n-                    panic!();\n-                }\n-            }\n-        }\n-\n-        debug_assert!(self.verify_adjustments(), \"Bad change, created an overlapping adjustment\");\n-    }\n+        let file = &mut self.file_map[*file_name];\n \n-    // Intended for debugging.\n-    fn verify_adjustments(&self) -> bool {\n-        let mut prev_end = 0;\n-        let mut prev_delta = 0;\n-        for (&k, a) in self.adjusts.iter() {\n-            if k < prev_end {\n-                debug!(\"Found bad adjustment at start {}, overlaps with previous adjustment\", k);\n-                return false;\n-            }\n-            if k as isize + a.delta < 0 {\n-                debug!(\"Found bad adjustment at start {}, absolute start < 0\", k);\n-                return false;\n-            }\n-            if k as isize + a.delta < prev_end as isize + prev_delta {\n-                debug!(\"Found bad adjustment at start {}, \\\n-                        projection overlaps with previous projection\", k);\n-                return false;\n-            }\n-            // TODO Check end + delta <= file.len - needs per file\n-\n-            prev_end = a.end;\n-            prev_delta = a.delta;\n+        if end - start == text.len() {\n+            // TODO\n+            panic!();\n+            file.replace_str(start, &text[]);\n+        } else {\n+            // TODO if we do this in one op, could we get better change info?\n+            file.src_remove(start, end);\n+            file.src_insert(start, text);\n         }\n-        true\n     }\n \n-    // span is unadjusted.\n     pub fn change_span(&mut self, span: Span, text: String) {\n         let l_loc = self.codemap.lookup_char_pos(span.lo);\n         let file_offset = l_loc.file.start_pos.0;\n@@ -187,29 +78,11 @@ impl<'a> ChangeSet<'a> {\n                     text)\n     }\n \n-    // start and end are unadjusted.\n     pub fn slice(&self, file_name: &str, start: usize, end: usize) -> RopeSlice {\n-        // TODO refactor with change?\n-        let abs_start = {\n-            let before_start = self.adjusts.range(Unbounded, Included(&start)).next_back();\n-            match before_start {\n-                Some((k, ref a)) if a.end > start => (start as isize + a.delta) as usize,\n-                _ => start\n-            }\n-        };\n-        let abs_end = {\n-            let before_end = self.adjusts.range(Unbounded, Included(&end)).next_back();\n-            match before_end {\n-                Some((k, ref a)) if a.end > end => (end as isize + a.delta) as usize,\n-                _ => end\n-            }\n-        };\n-\n         let file = &self.file_map[*file_name];\n-        file.slice(abs_start..abs_end)\n+        file.src_slice(start..end)\n     }\n \n-    // span is unadjusted.\n     pub fn slice_span(&self, span:Span) -> RopeSlice {\n         let l_loc = self.codemap.lookup_char_pos(span.lo);\n         let file_offset = l_loc.file.start_pos.0;\n@@ -225,6 +98,13 @@ impl<'a> ChangeSet<'a> {\n             cur_key: 0,\n         }\n     }\n+\n+    pub fn col(&self, loc: BytePos) -> usize {\n+        let l_loc = self.codemap.lookup_char_pos(loc);\n+        let file_offset = l_loc.file.start_pos.0;\n+        let file = &self.file_map[l_loc.file.name[]];\n+        file.col_for_src_loc(loc.0 as usize - file_offset as usize)\n+    }\n }\n \n impl<'c, 'a> Iterator for FileIterator<'c, 'a> {"}, {"sha": "150e51b4bd3bcaeafcff35c6683ebe07094df955", "filename": "src/rope.rs", "status": "modified", "additions": 521, "deletions": 70, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/f1e698c838defa9535750312d3fc11ebf3a830e9/src%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1e698c838defa9535750312d3fc11ebf3a830e9/src%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frope.rs?ref=f1e698c838defa9535750312d3fc11ebf3a830e9", "patch": "@@ -28,6 +28,7 @@ use std::ops::Range;\n pub struct Rope {\n     root: Node,\n     len: usize,\n+    src_len: usize,\n     // FIXME: Allocation is very dumb at the moment, we always add another buffer for every inserted string and we never resuse or collect old memory\n     storage: Vec<Vec<u8>>\n }\n@@ -54,6 +55,7 @@ impl Rope {\n         Rope {\n             root: Node::empty_inner(),\n             len: 0,\n+            src_len: 0,\n             storage: vec![],\n         }\n     }\n@@ -64,9 +66,15 @@ impl Rope {\n \n         let mut result = Rope::new();\n         result.insert(0, text);\n+        result.fix_src();\n         result\n     }\n \n+    fn fix_src(&mut self) {\n+        self.root.fix_src();\n+        self.src_len = self.len;\n+    }\n+\n     pub fn len(&self) -> usize {\n         self.len\n     }\n@@ -80,10 +88,10 @@ impl Rope {\n \n         let len = text.len();\n         let storage = text.into_bytes();\n-        let new_node = box Node::new_leaf(&storage[][0] as *const u8, len);\n+        let new_node = box Node::new_leaf(&storage[][0] as *const u8, len, 0);\n         self.storage.push(storage);\n \n-        match self.root.insert(new_node, start) {\n+        match self.root.insert(new_node, start, start) {\n             NodeAction::Change(n, adj) => {\n                 assert!(adj as usize == len);\n                 self.root = *n;\n@@ -101,6 +109,32 @@ impl Rope {\n         self.insert(start, text.to_string());\n     }\n \n+    pub fn src_insert(&mut self, start: usize, text: String) {\n+        // TODO refactor with insert\n+        if text.len() == 0 {\n+            return;\n+        }\n+\n+        debug_assert!(start <= self.src_len, \"insertion out of bounds of rope\");\n+\n+        let len = text.len();\n+        let storage = text.into_bytes();\n+        let new_node = box Node::new_leaf(&storage[][0] as *const u8, len, 0);\n+        self.storage.push(storage);\n+\n+        match self.root.src_insert(new_node, start, start) {\n+            NodeAction::Change(n, adj) => {\n+                assert!(adj as usize == len);\n+                self.root = *n;\n+            }\n+            NodeAction::Adjust(adj) => {\n+                assert!(adj as usize == len);\n+            }\n+            _ => panic!(\"Unexpected action\")\n+        }\n+        self.len += len;\n+    }\n+\n     pub fn push(&mut self, text: String) {\n         let len = self.len();\n         self.insert(len, text);\n@@ -118,7 +152,7 @@ impl Rope {\n             return;\n         }\n \n-        let action = self.root.remove(start, end, 0);\n+        let action = self.root.remove(start, end, start);\n         match action {\n             NodeAction::None => {}\n             NodeAction::Remove => {\n@@ -133,6 +167,30 @@ impl Rope {\n         }\n     }\n \n+    pub fn src_remove(&mut self, start: usize, end: usize) {\n+        // TODO refactor with remove\n+        assert!(end >= start);\n+        if start == end {\n+            return;\n+        }\n+\n+        let action = self.root.src_remove(start, end, start);\n+        match action {\n+            NodeAction::None => {}\n+            NodeAction::Remove => {\n+                self.root = Node::empty_inner();\n+                self.len = 0;\n+            }\n+            NodeAction::Adjust(adj) => self.len = (self.len as isize + adj) as usize,\n+            NodeAction::Change(node, adj) => {\n+                self.root = *node;\n+                self.len = (self.len as isize + adj) as usize;\n+            }\n+        }\n+    }\n+\n+    // TODO src_replace\n+\n     // This can go horribly wrong if you overwrite a grapheme of different size.\n     // It is the callers responsibility to ensure that the grapheme at point start\n     // has the same size as new_char.\n@@ -150,6 +208,14 @@ impl Rope {\n         self.root.replace(start, new_str);\n     }\n \n+    // Note, this is not necessarily cheap.\n+    pub fn col_for_src_loc(&self, src_loc: usize) -> usize {\n+        assert!(src_loc <= self.src_len);\n+        match self.root.col_for_src_loc(src_loc) {\n+            Search::Done(c) | Search::Continue(c) => c\n+        }\n+    }\n+\n     pub fn slice(&self, Range { start, end }: Range<usize>) -> RopeSlice {\n         debug_assert!(end > start && start <= self.len && end <= self.len);\n         if start == end {\n@@ -165,6 +231,17 @@ impl Rope {\n         self.slice(0..self.len)\n     }\n \n+    pub fn src_slice(&self, Range { start, end }: Range<usize>) -> RopeSlice {\n+        debug_assert!(end > start && start <= self.src_len && end <= self.src_len);\n+        if start == end {\n+            return RopeSlice::empty();\n+        }\n+\n+        let mut result = RopeSlice::empty();\n+        self.root.find_src_slice(start, end, &mut result);\n+        result\n+    }\n+\n     pub fn chars(&self) -> RopeChars {\n         RopeChars {\n             data: self.full_slice(),\n@@ -242,12 +319,14 @@ impl<'rope> RopeChars<'rope> {\n }\n \n impl ::std::str::FromStr for Rope {\n-    fn from_str(text: &str) -> Option<Rope> {\n+    type Err = ();\n+    fn from_str(text: &str) -> Result<Rope, ()> {\n         // TODO should split large texts into segments as we insert\n \n         let mut result = Rope::new();\n         result.insert_copy(0, text);\n-        Some(result)\n+        result.fix_src();\n+        Ok(result)\n     }\n }\n \n@@ -325,7 +404,7 @@ impl fmt::Display for Node {\n                     Ok(())\n                 })\n             }\n-            Node::LeafNode(Lnode{ ref text, len }) => {\n+            Node::LeafNode(Lnode{ ref text, len, .. }) => {\n                 unsafe {\n                     write!(fmt,\n                            \"{}\",\n@@ -339,7 +418,7 @@ impl fmt::Display for Node {\n impl fmt::Debug for Node {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         match *self {\n-            Node::InnerNode(Inode { ref left, ref right, weight }) => {\n+            Node::InnerNode(Inode { ref left, ref right, weight, .. }) => {\n                 try!(write!(fmt, \"(\"));\n                 if let Some(ref left) = *left {\n                     try!(write!(fmt, \"left: {:?}\", &**left));\n@@ -354,10 +433,10 @@ impl fmt::Debug for Node {\n                 }\n                 write!(fmt, \"; {})\", weight)\n             }\n-            Node::LeafNode(Lnode{ ref text, len }) => {\n+            Node::LeafNode(Lnode{ ref text, len, .. }) => {\n                 unsafe {\n                     write!(fmt,\n-                           \"\\\"{}\\\"; {}\",\n+                           \"(\\\"{}\\\"; {})\",\n                            ::std::str::from_utf8(::std::slice::from_raw_buf(text, len)).unwrap(),\n                            len)\n                 }\n@@ -375,6 +454,7 @@ enum Node {\n #[derive(Clone, Eq, PartialEq)]\n struct Inode {\n     weight: usize,\n+    src_weight: usize,\n     left: Option<Box<Node>>,\n     right: Option<Box<Node>>,\n }\n@@ -383,32 +463,38 @@ struct Inode {\n struct Lnode {\n     text: *const u8,\n     len: usize,\n+    // text + src_offset = src text (src_offset should always be <= 0)\n+    src_offset: isize,\n }\n \n impl Node {\n     fn empty_inner() -> Node {\n         Node::InnerNode(Inode {\n             left: None,\n             right: None,\n-            weight: 0\n+            weight: 0,\n+            src_weight: 0,\n         })\n     }\n \n     fn new_inner(left: Option<Box<Node>>,\n                  right: Option<Box<Node>>,\n-                 weight: usize)\n+                 weight: usize,\n+                 src_weight: usize)\n     -> Node {\n         Node::InnerNode(Inode {\n             left: left,\n             right: right,\n-            weight: weight\n+            weight: weight,\n+            src_weight: src_weight,\n         })\n     }\n \n-    fn new_leaf(text: *const u8, len: usize) -> Node {\n+    fn new_leaf(text: *const u8, len: usize, src_offset: isize) -> Node {\n         Node::LeafNode(Lnode {\n             text: text,\n-            len: len\n+            len: len,\n+            src_offset: src_offset,\n         })\n     }\n \n@@ -424,23 +510,77 @@ impl Node {\n         }\n     }\n \n+    fn fix_src(&mut self) {\n+        match *self {\n+            Node::InnerNode(ref mut i) => i.fix_src(),\n+            Node::LeafNode(ref mut l) => {\n+                l.src_offset = 0;\n+            },\n+        }\n+    }\n+\n+    // All these methods are just doing dynamic dispatch, TODO use a macro\n+\n     // precond: start < end\n-    fn remove(&mut self, start: usize, end: usize, offset: usize) -> NodeAction {\n-        if end < offset {\n-            // The span to remove is to the left of this node.\n-            return NodeAction::None;\n+    fn remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n+        match *self {\n+            Node::InnerNode(ref mut i) => i.remove(start, end, src_start),\n+            Node::LeafNode(ref mut l) => l.remove(start, end, src_start),\n+        }\n+    }\n+\n+    fn src_remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n+        match *self {\n+            Node::InnerNode(ref mut i) => i.src_remove(start, end, src_start),\n+            Node::LeafNode(ref mut l) => {\n+                debug!(\"src_remove: pre-adjust {}-{}; {}\", start, end, l.src_offset);\n+                let mut start = start as isize + l.src_offset;\n+                if start < 0 {\n+                    start = 0;\n+                }\n+                let mut end = end as isize + l.src_offset;\n+                if end < 0 {\n+                    end = 0;\n+                }\n+                // TODO src_start?\n+                let mut src_start = src_start as isize + l.src_offset;\n+                if src_start < 0 {\n+                    src_start = 0;\n+                }\n+                debug!(\"src_remove: post-adjust {}-{}, {}\", start, end, src_start);\n+                if end > start {\n+                    l.remove(start as usize, end as usize, src_start as usize)\n+                } else {\n+                    NodeAction::None\n+                }\n+            }\n         }\n+    }\n \n+    fn insert(&mut self, node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n         match *self {\n-            Node::InnerNode(ref mut i) => i.remove(start, end, offset),\n-            Node::LeafNode(ref mut l) => l.remove(start, end, offset),\n+            Node::InnerNode(ref mut i) => i.insert(node, start, src_start),\n+            Node::LeafNode(ref mut l) => l.insert(node, start, src_start),\n         }\n     }\n \n-    fn insert(&mut self, node: Box<Node>, start: usize) -> NodeAction {\n+    fn src_insert(&mut self, node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n         match *self {\n-            Node::InnerNode(ref mut i) => i.insert(node, start),\n-            Node::LeafNode(ref mut l) => l.insert(node, start),\n+            Node::InnerNode(ref mut i) => i.src_insert(node, start, src_start),\n+            Node::LeafNode(ref mut l) => {\n+                debug!(\"src_insert: pre-adjust {}, {}; {}\", start, src_start, l.src_offset);\n+                let mut start = start as isize + l.src_offset;\n+                if start < 0 {\n+                    start = 0;\n+                }\n+                // TODO src_start?\n+                let mut src_start = src_start as isize + l.src_offset;\n+                if src_start < 0 {\n+                    src_start = 0;\n+                }\n+                debug!(\"src_insert: post-adjust {}, {}\", start, src_start);\n+                l.insert(node, start as usize, src_start as usize)\n+            }\n         }\n     }\n \n@@ -451,15 +591,50 @@ impl Node {\n         }\n     }\n \n+    fn find_src_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n+        match *self {\n+            Node::InnerNode(ref i) => i.find_src_slice(start, end, slice),\n+            Node::LeafNode(ref l) => {\n+                debug!(\"find_src_slice: pre-adjust {}-{}; {}\", start, end, l.src_offset);\n+                let mut start = start as isize + l.src_offset;\n+                if start < 0 {\n+                    start = 0;\n+                }\n+                let mut end = end as isize + l.src_offset;\n+                if end < 0 {\n+                    end = 0;\n+                }\n+                debug!(\"find_src_slice: post-adjust {}-{}\", start, end);\n+                if end > start {\n+                    l.find_slice(start as usize, end as usize, slice);\n+                }\n+            }\n+        }\n+    }\n+\n     fn replace(&mut self, start: usize, new_str: &str) {\n         match *self {\n             Node::InnerNode(ref mut i) => i.replace(start, new_str),\n             Node::LeafNode(ref mut l) => l.replace(start, new_str),\n         }        \n     }\n+\n+    fn col_for_src_loc(&self, src_loc: usize) -> Search {\n+        match *self {\n+            Node::InnerNode(ref i) => i.col_for_src_loc(src_loc),\n+            Node::LeafNode(ref l) => l.col_for_src_loc(src_loc),\n+        }\n+    }\n+\n+    fn find_last_char(&self, c: char) -> Option<usize> {\n+        match *self {\n+            Node::InnerNode(ref i) => i.find_last_char(c),\n+            Node::LeafNode(ref l) => l.find_last_char(c),\n+        }\n+    }\n }\n \n-#[derive(Show, Clone, Eq, PartialEq)]\n+#[derive(Debug, Clone, Eq, PartialEq)]\n enum NodeAction {\n     None,\n     Remove,\n@@ -468,28 +643,113 @@ enum NodeAction {\n }\n \n impl Inode {\n-    // precond: start < end && end >= offset\n-    fn remove(&mut self, start: usize, end: usize, offset: usize) -> NodeAction {\n-        debug!(\"Inode::remove: {}, {}, {}, {}\", start, end, offset, self.weight);\n-        if start >= offset + self.weight {\n-            // The removal cannot affect our left side.\n-            match self.right {\n-                Some(_) => {}\n-                None => {}\n+    fn remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n+        debug!(\"Inode::remove: {}, {}, {}\", start, end, self.weight);\n+\n+        let left_action = if start <= self.weight {\n+            if let Some(ref mut left) = self.left {\n+                left.remove(start, end, src_start)\n+            } else {\n+                panic!();\n             }\n+        } else {\n+            NodeAction::None\n+        };\n+\n+        let right_action = if end > self.weight {\n+            if let Some(ref mut right) = self.right {\n+                let start = if start < self.weight {\n+                    0\n+                } else {\n+                    start - self.weight\n+                };\n+                let src_start = if src_start < self.src_weight {\n+                    0\n+                } else {\n+                    src_start - self.src_weight\n+                };\n+                right.remove(start, end - self.weight, src_start)\n+            } else {\n+                panic!();\n+            }\n+        } else {\n+            NodeAction::None\n+        };\n+\n+\n+        if left_action == NodeAction::Remove && right_action == NodeAction::Remove ||\n+           left_action == NodeAction::Remove && self.right.is_none() ||\n+           right_action == NodeAction::Remove && self.left.is_none() {\n+            return NodeAction::Remove;\n         }\n \n-        let left_action = if let Some(ref mut left) = self.left {\n-            left.remove(start, end, offset)\n+        if left_action == NodeAction::Remove {\n+            return NodeAction::Change(self.right.clone().unwrap(),\n+                                      -(self.weight as isize));\n+        }\n+        if right_action == NodeAction::Remove {\n+            return NodeAction::Change(self.left.clone().unwrap(),\n+                                      -(self.right.as_ref().map(|n| n.len()).unwrap() as isize));\n+        }\n+\n+        let mut total_adj = 0;\n+        if let NodeAction::Change(ref n, adj) = left_action {\n+            self.left = Some(n.clone());\n+            self.weight = (self.weight as isize + adj) as usize;\n+            total_adj += adj;\n+        }\n+        if let NodeAction::Change(ref n, adj) = right_action {\n+            self.right = Some(n.clone());\n+            total_adj += adj;\n+        }\n+\n+        if let NodeAction::Adjust(adj) = left_action {\n+            self.weight = (self.weight as isize + adj) as usize;\n+            total_adj += adj;\n+        }\n+        if let NodeAction::Adjust(adj) = right_action {\n+            total_adj += adj;\n+        }\n+\n+        return NodeAction::Adjust(total_adj);\n+    }\n+\n+    fn src_remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n+        // TODO refactor with remove\n+\n+        debug!(\"Inode::src_remove: {}, {}, {}/{}\", start, end, self.src_weight, self.weight);\n+\n+        let left_action = if start <= self.src_weight {\n+            if let Some(ref mut left) = self.left {\n+                left.src_remove(start, end, src_start)\n+            } else {\n+                panic!();\n+            }\n         } else {\n             NodeAction::None\n         };\n-        let right_action = if let Some(ref mut right) = self.right {\n-            right.remove(start, end, offset + self.weight)\n+\n+        let right_action = if end > self.src_weight {\n+            if let Some(ref mut right) = self.right {\n+                let start = if start < self.src_weight {\n+                    0\n+                } else {\n+                    start - self.src_weight\n+                };\n+                let src_start = if src_start < self.src_weight {\n+                    0\n+                } else {\n+                    src_start - self.src_weight\n+                };\n+                right.src_remove(start, end - self.src_weight, src_start)\n+            } else {\n+                panic!();\n+            }\n         } else {\n             NodeAction::None\n         };\n \n+\n         if left_action == NodeAction::Remove && right_action == NodeAction::Remove ||\n            left_action == NodeAction::Remove && self.right.is_none() ||\n            right_action == NodeAction::Remove && self.left.is_none() {\n@@ -527,11 +787,11 @@ impl Inode {\n         return NodeAction::Adjust(total_adj);\n     }\n \n-    fn insert(&mut self, node: Box<Node>, start: usize) -> NodeAction {\n+    fn insert(&mut self, node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n         let mut total_adj = 0;\n-        if start < self.weight {\n+        if start <= self.weight {\n             let action = if let Some(ref mut left) = self.left {\n-                left.insert(node, start)\n+                left.insert(node, start, src_start)\n             } else {\n                 assert!(self.weight == 0);\n                 let len = node.len() as isize;\n@@ -553,7 +813,53 @@ impl Inode {\n         } else {\n             let action = if let Some(ref mut right) = self.right {\n                 assert!(start >= self.weight);\n-                right.insert(node, start - self.weight)\n+                assert!(src_start >= self.src_weight);\n+                right.insert(node, start - self.weight, src_start - self.src_weight)\n+            } else {\n+                let len = node.len() as isize;\n+                NodeAction::Change(node, len)\n+            };\n+\n+            match action {\n+                NodeAction::Change(n, adj) => {\n+                    self.right = Some(n);\n+                    total_adj += adj;\n+                }\n+                NodeAction::Adjust(adj) => total_adj += adj,\n+                _ => panic!(\"Unexpected action\"),\n+            }\n+        }\n+\n+        NodeAction::Adjust(total_adj)\n+    }\n+\n+    fn src_insert(&mut self, node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n+        let mut total_adj = 0;\n+        if start <= self.src_weight {\n+            let action = if let Some(ref mut left) = self.left {\n+                left.src_insert(node, start, src_start)\n+            } else {\n+                let len = node.len() as isize;\n+                NodeAction::Change(node, len)\n+            };\n+\n+            match action {\n+                NodeAction::Change(n, adj) => {\n+                    self.left = Some(n);\n+                    self.weight += adj as usize;\n+                    total_adj += adj;\n+                }\n+                NodeAction::Adjust(adj) => {\n+                    self.weight += adj as usize;\n+                    total_adj += adj;\n+                }\n+                _ => panic!(\"Unexpected action\"),\n+            }\n+        } else {\n+            let action = if let Some(ref mut right) = self.right {\n+                assert!(start >= self.src_weight);\n+                assert!(src_start >= self.src_weight);\n+                right.src_insert(node, start - self.src_weight, src_start - self.src_weight)\n             } else {\n                 let len = node.len() as isize;\n                 NodeAction::Change(node, len)\n@@ -587,6 +893,21 @@ impl Inode {\n         }\n     }\n \n+    fn find_src_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n+        debug!(\"Inode::find_src_slice: {}, {}, {}\", start, end, self.src_weight);\n+        if start < self.src_weight && self.left.is_some() {\n+            self.left.as_ref().unwrap().find_src_slice(start, end, slice);\n+        }\n+        if end > self.src_weight && self.right.is_some() {\n+            let start = if start < self.src_weight {\n+                0\n+            } else {\n+                start - self.src_weight\n+            };\n+            self.right.as_ref().unwrap().find_src_slice(start, end - self.src_weight, slice)\n+        }\n+    }\n+\n     fn replace(&mut self, start: usize, new_str: &str) {\n         debug!(\"Inode::replace: {}, {}, {}\", start, new_str, self.weight);\n         let end = start + new_str.len();\n@@ -610,86 +931,158 @@ impl Inode {\n             }\n         }\n     }\n+\n+    fn fix_src(&mut self) {\n+        self.src_weight = self.weight;\n+        if let Some(ref mut left) = self.left {\n+            left.fix_src();\n+        }\n+        if let Some(ref mut right) = self.right {\n+            right.fix_src();\n+        }\n+    }\n+\n+    fn col_for_src_loc(&self, src_loc: usize) -> Search {\n+        debug!(\"Inode::col_for_src_loc: {}, {}\", src_loc, self.src_weight);\n+        let result = if src_loc < self.src_weight {\n+            if self.left.is_some() {\n+                Some(self.left.as_ref().unwrap().col_for_src_loc(src_loc))\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        };\n+        if result.is_none() {\n+            if self.right.is_some() {\n+                match self.right.as_ref().unwrap().col_for_src_loc(src_loc - self.src_weight) {\n+                    Search::Continue(c) if self.left.is_some() => {\n+                        // TODO broken - need number of chars, not bytes\n+                        match self.left.as_ref().unwrap().find_last_char('\\n') {\n+                            Some(l) => {\n+                                Search::Done((self.weight - l - 1) + c)\n+                            }\n+                            None => {\n+                                Search::Continue(c + self.weight)\n+                            }\n+                        }\n+                    }\n+                    result => result,\n+                }\n+            } else {\n+                panic!(\"Can't look up source location\");\n+            }\n+        } else {\n+            // TODO don't do it this way\n+            result.unwrap()\n+        }\n+    }\n+\n+    fn find_last_char(&self, c: char) -> Option<usize> {\n+        // TODO use map or something\n+        match self.right {\n+            Some(ref right) => match right.find_last_char(c) {\n+                Some(x) => return Some(x),\n+                None => {},\n+            },\n+            None => {}\n+        }\n+        match self.left {\n+            Some(ref left) => match left.find_last_char(c) {\n+                Some(x) => return Some(x),\n+                None => {},\n+            },\n+            None => {}\n+        }\n+        None\n+    }\n }\n \n impl Lnode {\n-    // precond: start < end && end >= offset\n-    fn remove(&mut self, start: usize, end: usize, offset: usize) -> NodeAction {\n-        debug!(\"Lnode::remove: {}, {}, {}, {}\", start, end, offset, self.len);\n-        if start > offset + self.len {\n-            // The span to remove is to the right of this node.\n-            return NodeAction::None;\n-        }\n+    fn remove(&mut self, start: usize, end: usize, src_start: usize) -> NodeAction {\n+        debug!(\"Lnode::remove: {}, {}, {}\", start, end, self.len);\n+        assert!(start <= self.len);\n \n-        if start <= offset && end >= offset + self.len {\n+        if start == 0 && end >= self.len {\n             // The removal span includes us, remove ourselves.\n             return NodeAction::Remove;\n         }\n \n         let old_len = self.len;\n-        if start <= offset {\n+        if start == 0 {\n             // Truncate the left of the node.\n-            self.text = (self.text as usize + (end - offset)) as *const u8;\n-            self.len = old_len - (end - offset);\n-            return NodeAction::Adjust(self.len as isize - old_len as isize);\n+            self.text = (self.text as usize + end) as *const u8;\n+            self.len = old_len - end;\n+            let delta = self.len as isize - old_len as isize;\n+            self.src_offset += delta;\n+            return NodeAction::Adjust(delta);\n         }\n \n-        if end >= offset + self.len {\n+        if end >= self.len {\n             // Truncate the right of the node.\n-            self.len = start - offset;\n+            self.len = start;\n             return NodeAction::Adjust(self.len as isize - old_len as isize);\n         }\n \n+        let delta = -((end - start) as isize);\n         // Split the node (span to remove is in the middle of the node).\n         let new_node = Node::new_inner(\n-            Some(box Node::new_leaf(self.text, start - offset)),\n-            Some(box Node::new_leaf((self.text as usize + (end - offset)) as *const u8,\n-                                    old_len - (end - offset))),\n-            start - offset);\n-        return NodeAction::Change(box new_node, -((end - start) as isize));\n+            Some(box Node::new_leaf(self.text, start, self.src_offset)),\n+            Some(box Node::new_leaf((self.text as usize + end) as *const u8,\n+                                    old_len - end,\n+                                    self.src_offset + delta)),\n+            start,\n+            src_start);\n+        return NodeAction::Change(box new_node, delta);\n     }\n \n-    fn insert(&mut self, node: Box<Node>, start: usize) -> NodeAction {\n+    fn insert(&mut self, mut node: Box<Node>, start: usize, src_start: usize) -> NodeAction {\n+        match node {\n+            box Node::LeafNode(ref mut node) => node.src_offset = self.src_offset,\n+            _ => panic!()\n+        }\n+\n         let len = node.len();\n         if start == 0 {\n             // Insert at the start of the node\n             let new_node = box Node::new_inner(Some(node),\n                                                Some(box Node::LeafNode(self.clone())),\n-                                               len);\n+                                               len,\n+                                               0);\n             return NodeAction::Change(new_node, len as isize)\n         }\n \n         if start == self.len {\n             // Insert at the end of the node\n             let new_node = box Node::new_inner(Some(box Node::LeafNode(self.clone())),\n                                                Some(node),\n+                                               self.len,\n                                                self.len);\n             return NodeAction::Change(new_node, len as isize)\n         }\n \n         // Insert into the middle of the node\n-        let left = Some(box Node::new_leaf(self.text, start));\n-        let new_left = box Node::new_inner(left, Some(node), start);\n+        let left = Some(box Node::new_leaf(self.text, start, self.src_offset));\n+        let new_left = box Node::new_inner(left, Some(node), start, src_start);\n         let right = Some(box Node::new_leaf((self.text as usize + (start)) as *const u8,\n-                                            self.len - (start)));\n-        let new_node = box Node::new_inner(Some(new_left), right, start + len);\n+                                            self.len - start,\n+                                            self.src_offset));\n+        let new_node = box Node::new_inner(Some(new_left), right, start + len, src_start);\n \n         return NodeAction::Change(new_node, len as isize)        \n     }\n \n     fn find_slice<'a>(&'a self, start: usize, end: usize, slice: &mut RopeSlice<'a>) {\n-        debug!(\"Lnode::find_slice: {}, {}, {}\", start, end, self.len);\n+        debug!(\"Lnode::find_slice: {}, {}, {}, {}\", start, end, self.len, self.src_offset);\n         debug_assert!(start < self.len, \"Shouldn't have called this fn, we're out of bounds\");\n \n         slice.nodes.push(self);\n-        let mut len = end;\n+        let mut len = ::std::cmp::min(end, self.len);\n         if start > 0 {\n             slice.start = start;\n             len -= start;\n         }\n-        if end <= self.len {\n-            slice.len = len;\n-        }\n+        slice.len = len;\n     }\n \n     fn replace(&mut self, start: usize, new_str: &str) {\n@@ -700,4 +1093,62 @@ impl Lnode {\n             ::std::intrinsics::copy_nonoverlapping_memory(addr, &new_str.as_bytes()[0], new_str.len());\n         }\n     }\n+\n+    fn col_for_src_loc(&self, src_loc: usize) -> Search {\n+        debug!(\"Lnode::col_for_src_loc {}; {}; {}\", src_loc, self.len, self.src_offset);\n+        let loc = if (src_loc as isize) > (self.len as isize - self.src_offset) {\n+            // The source location we are looking up has been removed\n+            self.len as isize\n+        } else {\n+            (src_loc as isize + self.src_offset) \n+        };\n+\n+        // FIXME if '/n' as u8 is part of a multi-byte grapheme, then this will\n+        // cause false positives.\n+        let mut i = loc - 1;\n+        while i >= 0 {\n+            unsafe {\n+                let c = *((self.text as usize + i as usize) as *const u8);\n+                if c as char == '\\n' {\n+                    debug!(\"Lnode::col_for_src_loc, return Done({})\", loc - i - 1);\n+                    return Search::Done((loc - i - 1) as usize)\n+                }\n+            }\n+            i -= 1;\n+        }\n+\n+        let loc = if loc < 0 {\n+            0\n+        } else {\n+            loc as usize\n+        };\n+        debug!(\"Lnode::col_for_src_loc, return Continue({})\", loc);\n+        Search::Continue(loc)\n+    }\n+\n+    fn find_last_char(&self, needle: char) -> Option<usize> {\n+        // FIXME due to multi-byte chars, this will give false positives\n+        // I think we must search forwards from the start :-( Perhaps we could\n+        // track unicode vs ascii or something (I don't think there is an efficient\n+        // way to read unicode backwards, I might be wrong).\n+        // std::str::GraphemeIndices can do this!\n+        let mut loc = self.len as isize - 1;\n+        while loc >= 0 {\n+            unsafe {\n+                let c = *((self.text as usize + loc as usize) as *const u8);\n+                if c as char == needle {\n+                    return Some(loc as usize)\n+                }\n+            }\n+            loc -= 1;\n+        }\n+\n+        return None\n+    }\n+}\n+\n+//TODO comment etc.\n+enum Search {\n+    Continue(usize),\n+    Done(usize)\n }"}]}