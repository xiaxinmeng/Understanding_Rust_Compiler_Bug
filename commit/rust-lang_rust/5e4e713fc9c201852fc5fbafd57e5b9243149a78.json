{"sha": "5e4e713fc9c201852fc5fbafd57e5b9243149a78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNGU3MTNmYzljMjAxODUyZmM1ZmJhZmQ1N2U1YjkyNDMxNDlhNzg=", "commit": {"author": {"name": "Omer Ben-Amram", "email": "omerbenamram@gmail.com", "date": "2019-12-14T15:29:30Z"}, "committer": {"name": "Omer Ben-Amram", "email": "omerbenamram@gmail.com", "date": "2019-12-14T15:29:30Z"}, "message": "Merge branch 'refs/heads/master' into feature/granular-scopes", "tree": {"sha": "996b679a9ae1d07be1edd9eb04e93d433c6524a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/996b679a9ae1d07be1edd9eb04e93d433c6524a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e4e713fc9c201852fc5fbafd57e5b9243149a78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e4e713fc9c201852fc5fbafd57e5b9243149a78", "html_url": "https://github.com/rust-lang/rust/commit/5e4e713fc9c201852fc5fbafd57e5b9243149a78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e4e713fc9c201852fc5fbafd57e5b9243149a78/comments", "author": {"login": "omerbenamram", "id": 2467993, "node_id": "MDQ6VXNlcjI0Njc5OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2467993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/omerbenamram", "html_url": "https://github.com/omerbenamram", "followers_url": "https://api.github.com/users/omerbenamram/followers", "following_url": "https://api.github.com/users/omerbenamram/following{/other_user}", "gists_url": "https://api.github.com/users/omerbenamram/gists{/gist_id}", "starred_url": "https://api.github.com/users/omerbenamram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/omerbenamram/subscriptions", "organizations_url": "https://api.github.com/users/omerbenamram/orgs", "repos_url": "https://api.github.com/users/omerbenamram/repos", "events_url": "https://api.github.com/users/omerbenamram/events{/privacy}", "received_events_url": "https://api.github.com/users/omerbenamram/received_events", "type": "User", "site_admin": false}, "committer": {"login": "omerbenamram", "id": 2467993, "node_id": "MDQ6VXNlcjI0Njc5OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2467993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/omerbenamram", "html_url": "https://github.com/omerbenamram", "followers_url": "https://api.github.com/users/omerbenamram/followers", "following_url": "https://api.github.com/users/omerbenamram/following{/other_user}", "gists_url": "https://api.github.com/users/omerbenamram/gists{/gist_id}", "starred_url": "https://api.github.com/users/omerbenamram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/omerbenamram/subscriptions", "organizations_url": "https://api.github.com/users/omerbenamram/orgs", "repos_url": "https://api.github.com/users/omerbenamram/repos", "events_url": "https://api.github.com/users/omerbenamram/events{/privacy}", "received_events_url": "https://api.github.com/users/omerbenamram/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "083010f6339e558184f06ce76a18e1ad0b0ee936", "url": "https://api.github.com/repos/rust-lang/rust/commits/083010f6339e558184f06ce76a18e1ad0b0ee936", "html_url": "https://github.com/rust-lang/rust/commit/083010f6339e558184f06ce76a18e1ad0b0ee936"}, {"sha": "77db6177658b32f69ad7ebfdef96c1b3b2893fdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/77db6177658b32f69ad7ebfdef96c1b3b2893fdd", "html_url": "https://github.com/rust-lang/rust/commit/77db6177658b32f69ad7ebfdef96c1b3b2893fdd"}], "stats": {"total": 825, "additions": 494, "deletions": 331}, "files": [{"sha": "b2f946fac36b144413f2ddc9954f3c9cce08ed8e", "filename": "crates/ra_assists/src/assists/add_new.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -139,43 +139,40 @@ fn find_struct_impl(\n \n     let struct_ty = {\n         let src = InFile { file_id: ctx.frange.file_id.into(), value: strukt.clone() };\n-        hir::Struct::from_source(db, src).unwrap().ty(db)\n+        hir::Struct::from_source(db, src)?.ty(db)\n     };\n \n-    let mut found_new_fn = false;\n-\n-    let block = module.descendants().filter_map(ast::ImplBlock::cast).find(|impl_blk| {\n-        if found_new_fn {\n-            return false;\n-        }\n-\n+    let block = module.descendants().filter_map(ast::ImplBlock::cast).find_map(|impl_blk| {\n         let src = InFile { file_id: ctx.frange.file_id.into(), value: impl_blk.clone() };\n-        let blk = hir::ImplBlock::from_source(db, src).unwrap();\n+        let blk = hir::ImplBlock::from_source(db, src)?;\n \n         let same_ty = blk.target_ty(db) == struct_ty;\n         let not_trait_impl = blk.target_trait(db).is_none();\n \n         if !(same_ty && not_trait_impl) {\n-            return false;\n+            None\n+        } else {\n+            Some(impl_blk)\n         }\n-\n-        found_new_fn = has_new_fn(impl_blk);\n-        true\n     });\n \n-    if found_new_fn {\n-        None\n-    } else {\n-        Some(block)\n+    if let Some(ref impl_blk) = block {\n+        if has_new_fn(impl_blk) {\n+            return None;\n+        }\n     }\n+\n+    Some(block)\n }\n \n fn has_new_fn(imp: &ast::ImplBlock) -> bool {\n     if let Some(il) = imp.item_list() {\n         for item in il.impl_items() {\n             if let ast::ImplItem::FnDef(f) = item {\n-                if f.name().unwrap().text().eq_ignore_ascii_case(\"new\") {\n-                    return true;\n+                if let Some(name) = f.name() {\n+                    if name.text().eq_ignore_ascii_case(\"new\") {\n+                        return true;\n+                    }\n                 }\n             }\n         }"}, {"sha": "7744ba85a2402ccfbb63fa45b6bbed466e6f7f30", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -22,7 +22,7 @@ fn vfs_root_to_id(r: ra_vfs::VfsRoot) -> SourceRootId {\n \n pub fn load_cargo(root: &Path) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n     let root = std::env::current_dir()?.join(root);\n-    let ws = ProjectWorkspace::discover(root.as_ref())?;\n+    let ws = ProjectWorkspace::discover(root.as_ref(), &Default::default())?;\n     let project_roots = ws.to_roots();\n     let (sender, receiver) = unbounded();\n     let sender = Box::new(move |t| sender.send(t).unwrap());"}, {"sha": "7850ea9a7124a48bc33d476eccd60eb408a31712", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -17,7 +17,7 @@ use hir_def::{\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n-    name::{self, AsName},\n+    name::{name, AsName},\n     MacroDefId,\n };\n use hir_ty::{\n@@ -723,7 +723,7 @@ impl Local {\n     }\n \n     pub fn is_self(self, db: &impl HirDatabase) -> bool {\n-        self.name(db) == Some(name::SELF_PARAM)\n+        self.name(db) == Some(name![self])\n     }\n \n     pub fn is_mut(self, db: &impl HirDatabase) -> bool {"}, {"sha": "f82242c3a05a2190321c16bdb66551b2eb48afa2", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -15,7 +15,7 @@ use hir_def::{\n     },\n     expr::{ExprId, PatId},\n     nameres::ModuleSource,\n-    path::known,\n+    path::path,\n     resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n     AssocItemId, DefWithBodyId,\n };\n@@ -418,7 +418,7 @@ impl SourceAnalyzer {\n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_future(&self, db: &impl HirDatabase, ty: Type) -> bool {\n-        let std_future_path = known::std_future_future();\n+        let std_future_path = path![std::future::Future];\n \n         let std_future_trait = match self.resolver.resolve_known_trait(db, &std_future_path) {\n             Some(it) => it.into(),"}, {"sha": "61193b4d8040827e49fc742de0a2f60fb505cb35", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -2,7 +2,7 @@\n //! representation.\n \n use either::Either;\n-use hir_expand::name::{self, AsName, Name};\n+use hir_expand::name::{name, AsName, Name};\n use ra_arena::Arena;\n use ra_syntax::{\n     ast::{\n@@ -68,7 +68,7 @@ where\n                 let ptr = AstPtr::new(&self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n-                        name: name::SELF_PARAM,\n+                        name: name![self],\n                         mode: BindingAnnotation::Unannotated,\n                         subpat: None,\n                     },"}, {"sha": "d14901a9b49f8b809094d0d78f6c4b49d982c2b7", "filename": "crates/ra_hir_def/src/builtin_type.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbuiltin_type.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -5,7 +5,7 @@\n \n use std::fmt;\n \n-use hir_expand::name::{self, Name};\n+use hir_expand::name::{name, Name};\n \n #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n pub enum Signedness {\n@@ -52,26 +52,26 @@ pub enum BuiltinType {\n impl BuiltinType {\n     #[rustfmt::skip]\n     pub const ALL: &'static [(Name, BuiltinType)] = &[\n-        (name::CHAR, BuiltinType::Char),\n-        (name::BOOL, BuiltinType::Bool),\n-        (name::STR,  BuiltinType::Str ),\n-\n-        (name::ISIZE, BuiltinType::Int(BuiltinInt::ISIZE)),\n-        (name::I8,    BuiltinType::Int(BuiltinInt::I8)),\n-        (name::I16,   BuiltinType::Int(BuiltinInt::I16)),\n-        (name::I32,   BuiltinType::Int(BuiltinInt::I32)),\n-        (name::I64,   BuiltinType::Int(BuiltinInt::I64)),\n-        (name::I128,  BuiltinType::Int(BuiltinInt::I128)),\n-\n-        (name::USIZE, BuiltinType::Int(BuiltinInt::USIZE)),\n-        (name::U8,    BuiltinType::Int(BuiltinInt::U8)),\n-        (name::U16,   BuiltinType::Int(BuiltinInt::U16)),\n-        (name::U32,   BuiltinType::Int(BuiltinInt::U32)),\n-        (name::U64,   BuiltinType::Int(BuiltinInt::U64)),\n-        (name::U128,  BuiltinType::Int(BuiltinInt::U128)),\n-\n-        (name::F32, BuiltinType::Float(BuiltinFloat::F32)),\n-        (name::F64, BuiltinType::Float(BuiltinFloat::F64)),\n+        (name![char], BuiltinType::Char),\n+        (name![bool], BuiltinType::Bool),\n+        (name![str],  BuiltinType::Str),\n+\n+        (name![isize], BuiltinType::Int(BuiltinInt::ISIZE)),\n+        (name![i8],    BuiltinType::Int(BuiltinInt::I8)),\n+        (name![i16],   BuiltinType::Int(BuiltinInt::I16)),\n+        (name![i32],   BuiltinType::Int(BuiltinInt::I32)),\n+        (name![i64],   BuiltinType::Int(BuiltinInt::I64)),\n+        (name![i128],  BuiltinType::Int(BuiltinInt::I128)),\n+\n+        (name![usize], BuiltinType::Int(BuiltinInt::USIZE)),\n+        (name![u8],    BuiltinType::Int(BuiltinInt::U8)),\n+        (name![u16],   BuiltinType::Int(BuiltinInt::U16)),\n+        (name![u32],   BuiltinType::Int(BuiltinInt::U32)),\n+        (name![u64],   BuiltinType::Int(BuiltinInt::U64)),\n+        (name![u128],  BuiltinType::Int(BuiltinInt::U128)),\n+\n+        (name![f32], BuiltinType::Float(BuiltinFloat::F32)),\n+        (name![f64], BuiltinType::Float(BuiltinFloat::F64)),\n     ];\n }\n "}, {"sha": "4f4ef57cc0a4b0681cf1bfcf51e16273a3cb2933", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use hir_expand::{\n-    name::{self, AsName, Name},\n+    name::{name, AsName, Name},\n     AstId,\n };\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner};\n@@ -37,7 +37,7 @@ impl FunctionData {\n                 let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n                     TypeRef::from_ast(type_ref)\n                 } else {\n-                    let self_type = TypeRef::Path(name::SELF_TYPE.into());\n+                    let self_type = TypeRef::Path(name![Self].into());\n                     match self_param.kind() {\n                         ast::SelfParamKind::Owned => self_type,\n                         ast::SelfParamKind::Ref => {"}, {"sha": "e9c28c7309e673104249a2e83dcd822f6a017008", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -6,7 +6,7 @@ use std::sync::Arc;\n \n use either::Either;\n use hir_expand::{\n-    name::{self, AsName, Name},\n+    name::{name, AsName, Name},\n     InFile,\n };\n use ra_arena::{map::ArenaMap, Arena};\n@@ -90,11 +90,11 @@ impl GenericParams {\n \n                 // traits get the Self type as an implicit first type parameter\n                 let self_param_id =\n-                    generics.types.alloc(TypeParamData { name: name::SELF_TYPE, default: None });\n+                    generics.types.alloc(TypeParamData { name: name![Self], default: None });\n                 sm.insert(self_param_id, Either::Left(src.value.clone()));\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(name::SELF_TYPE.into());\n+                let self_param = TypeRef::Path(name![Self].into());\n                 generics.fill_bounds(&src.value, self_param);\n \n                 generics.fill(&mut sm, &src.value);"}, {"sha": "5d7469a6ecf3337fa04e02f1226b85b9ad473510", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -6,7 +6,7 @@\n use hir_expand::{\n     builtin_derive::find_builtin_derive,\n     builtin_macro::find_builtin_macro,\n-    name::{self, AsName, Name},\n+    name::{name, AsName, Name},\n     HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use ra_cfg::CfgOptions;\n@@ -918,7 +918,7 @@ where\n }\n \n fn is_macro_rules(path: &Path) -> bool {\n-    path.as_ident() == Some(&name::MACRO_RULES)\n+    path.as_ident() == Some(&name![macro_rules])\n }\n \n #[cfg(test)]"}, {"sha": "1e9eb14ea58838db99f66f95df76684b7678e6f0", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 34, "deletions": 62, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -6,7 +6,7 @@ use std::{iter, sync::Arc};\n use either::Either;\n use hir_expand::{\n     hygiene::Hygiene,\n-    name::{self, AsName, Name},\n+    name::{name, AsName, Name},\n };\n use ra_db::CrateId;\n use ra_syntax::{\n@@ -76,10 +76,7 @@ impl Path {\n         }\n     }\n \n-    pub(crate) fn from_simple_segments(\n-        kind: PathKind,\n-        segments: impl IntoIterator<Item = Name>,\n-    ) -> Path {\n+    pub fn from_simple_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> Path {\n         Path {\n             kind,\n             segments: segments\n@@ -276,7 +273,7 @@ impl GenericArgs {\n         }\n         if let Some(ret_type) = ret_type {\n             let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n-            bindings.push((name::OUTPUT_TYPE, type_ref))\n+            bindings.push((name![Output], type_ref))\n         }\n         if args.is_empty() && bindings.is_empty() {\n             None\n@@ -296,61 +293,36 @@ impl From<Name> for Path {\n     }\n }\n \n-pub mod known {\n-    use hir_expand::name;\n-\n-    use super::{Path, PathKind};\n-\n-    pub fn std_iter_into_iterator() -> Path {\n-        Path::from_simple_segments(\n-            PathKind::Abs,\n-            vec![name::STD, name::ITER, name::INTO_ITERATOR_TYPE],\n-        )\n-    }\n-\n-    pub fn std_ops_try() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::TRY_TYPE])\n-    }\n-\n-    pub fn std_ops_range() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_TYPE])\n-    }\n-\n-    pub fn std_ops_range_from() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_FROM_TYPE])\n-    }\n-\n-    pub fn std_ops_range_full() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_FULL_TYPE])\n-    }\n-\n-    pub fn std_ops_range_inclusive() -> Path {\n-        Path::from_simple_segments(\n-            PathKind::Abs,\n-            vec![name::STD, name::OPS, name::RANGE_INCLUSIVE_TYPE],\n-        )\n-    }\n-\n-    pub fn std_ops_range_to() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::OPS, name::RANGE_TO_TYPE])\n-    }\n-\n-    pub fn std_ops_range_to_inclusive() -> Path {\n-        Path::from_simple_segments(\n-            PathKind::Abs,\n-            vec![name::STD, name::OPS, name::RANGE_TO_INCLUSIVE_TYPE],\n-        )\n-    }\n-\n-    pub fn std_result_result() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::RESULT, name::RESULT_TYPE])\n-    }\n-\n-    pub fn std_future_future() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::FUTURE, name::FUTURE_TYPE])\n-    }\n+pub use hir_expand::name as __name;\n+\n+#[macro_export]\n+macro_rules! __known_path {\n+    (std::iter::IntoIterator) => {};\n+    (std::result::Result) => {};\n+    (std::ops::Range) => {};\n+    (std::ops::RangeFrom) => {};\n+    (std::ops::RangeFull) => {};\n+    (std::ops::RangeTo) => {};\n+    (std::ops::RangeToInclusive) => {};\n+    (std::ops::RangeInclusive) => {};\n+    (std::boxed::Box) => {};\n+    (std::future::Future) => {};\n+    (std::ops::Try) => {};\n+    (std::ops::Neg) => {};\n+    (std::ops::Not) => {};\n+    ($path:path) => {\n+        compile_error!(\"Please register your known path in the path module\")\n+    };\n+}\n \n-    pub fn std_boxed_box() -> Path {\n-        Path::from_simple_segments(PathKind::Abs, vec![name::STD, name::BOXED, name::BOX_TYPE])\n-    }\n+#[macro_export]\n+macro_rules! __path {\n+    ($start:ident $(:: $seg:ident)*) => ({\n+        $crate::__known_path!($start $(:: $seg)*);\n+        $crate::path::Path::from_simple_segments($crate::path::PathKind::Abs, vec![\n+            $crate::path::__name![$start], $($crate::path::__name![$seg],)*\n+        ])\n+    });\n }\n+\n+pub use crate::__path as path;"}, {"sha": "b6d595a2092d907343ed622f63e208c989993472", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -2,7 +2,7 @@\n use std::sync::Arc;\n \n use hir_expand::{\n-    name::{self, Name},\n+    name::{name, Name},\n     MacroDefId,\n };\n use ra_db::CrateId;\n@@ -163,13 +163,13 @@ impl Resolver {\n                     }\n                 }\n                 Scope::ImplBlockScope(impl_) => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &name![Self] {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::SelfType(*impl_), idx));\n                     }\n                 }\n                 Scope::AdtScope(adt) => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &name![Self] {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n                         return Some((TypeNs::AdtSelfType(*adt), idx));\n                     }\n@@ -223,7 +223,7 @@ impl Resolver {\n             return None;\n         }\n         let n_segments = path.segments.len();\n-        let tmp = name::SELF_PARAM;\n+        let tmp = name![self];\n         let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n         let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n         for scope in self.scopes.iter().rev() {\n@@ -259,13 +259,13 @@ impl Resolver {\n                 Scope::GenericParams { .. } => continue,\n \n                 Scope::ImplBlockScope(impl_) if n_segments > 1 => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &name![Self] {\n                         let ty = TypeNs::SelfType(*impl_);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n                 Scope::AdtScope(adt) if n_segments > 1 => {\n-                    if first_name == &name::SELF_TYPE {\n+                    if first_name == &name![Self] {\n                         let ty = TypeNs::AdtSelfType(*adt);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n@@ -439,10 +439,10 @@ impl Scope {\n                 }\n             }\n             Scope::ImplBlockScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::ImplSelfType((*i).into()));\n+                f(name![Self], ScopeDef::ImplSelfType((*i).into()));\n             }\n             Scope::AdtScope(i) => {\n-                f(name::SELF_TYPE, ScopeDef::AdtSelfType((*i).into()));\n+                f(name![Self], ScopeDef::AdtSelfType((*i).into()));\n             }\n             Scope::ExprScope(scope) => {\n                 scope.expr_scopes.entries(scope.scope_id).iter().for_each(|e| {"}, {"sha": "b2644125383ce4c1a149ea012321c6eaf411a2b2", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -12,10 +12,10 @@ use crate::db::AstDatabase;\n use crate::{name, quote, MacroCallId, MacroDefId, MacroDefKind};\n \n macro_rules! register_builtin {\n-    ( $(($name:ident, $kind: ident) => $expand:ident),* ) => {\n+    ( $($trait:ident => $expand:ident),* ) => {\n         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n         pub enum BuiltinDeriveExpander {\n-            $($kind),*\n+            $($trait),*\n         }\n \n         impl BuiltinDeriveExpander {\n@@ -26,15 +26,15 @@ macro_rules! register_builtin {\n                 tt: &tt::Subtree,\n             ) -> Result<tt::Subtree, mbe::ExpandError> {\n                 let expander = match *self {\n-                    $( BuiltinDeriveExpander::$kind => $expand, )*\n+                    $( BuiltinDeriveExpander::$trait => $expand, )*\n                 };\n                 expander(db, id, tt)\n             }\n         }\n \n         pub fn find_builtin_derive(ident: &name::Name) -> Option<MacroDefId> {\n             let kind = match ident {\n-                 $( id if id == &name::$name => BuiltinDeriveExpander::$kind, )*\n+                $( id if id == &name::name![$trait] => BuiltinDeriveExpander::$trait, )*\n                  _ => return None,\n             };\n \n@@ -44,15 +44,15 @@ macro_rules! register_builtin {\n }\n \n register_builtin! {\n-    (COPY_TRAIT, Copy) => copy_expand,\n-    (CLONE_TRAIT, Clone) => clone_expand,\n-    (DEFAULT_TRAIT, Default) => default_expand,\n-    (DEBUG_TRAIT, Debug) => debug_expand,\n-    (HASH_TRAIT, Hash) => hash_expand,\n-    (ORD_TRAIT, Ord) => ord_expand,\n-    (PARTIAL_ORD_TRAIT, PartialOrd) => partial_ord_expand,\n-    (EQ_TRAIT, Eq) => eq_expand,\n-    (PARTIAL_EQ_TRAIT, PartialEq) => partial_eq_expand\n+    Copy => copy_expand,\n+    Clone => clone_expand,\n+    Default => default_expand,\n+    Debug => debug_expand,\n+    Hash => hash_expand,\n+    Ord => ord_expand,\n+    PartialOrd => partial_ord_expand,\n+    Eq => eq_expand,\n+    PartialEq => partial_eq_expand\n }\n \n struct BasicAdtInfo {"}, {"sha": "d2b3d769e8e73064c61ee2ecfac5b24b6bf6c00f", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -34,7 +34,7 @@ macro_rules! register_builtin {\n             ast_id: AstId<ast::MacroCall>,\n         ) -> Option<MacroDefId> {\n             let kind = match ident {\n-                 $( id if id == &name::$name => BuiltinFnLikeExpander::$kind, )*\n+                 $( id if id == &name::name![$name] => BuiltinFnLikeExpander::$kind, )*\n                  _ => return None,\n             };\n \n@@ -44,15 +44,15 @@ macro_rules! register_builtin {\n }\n \n register_builtin! {\n-    (COLUMN_MACRO, Column) => column_expand,\n-    (COMPILE_ERROR_MACRO, CompileError) => compile_error_expand,\n-    (FILE_MACRO, File) => file_expand,\n-    (LINE_MACRO, Line) => line_expand,\n-    (STRINGIFY_MACRO, Stringify) => stringify_expand,\n-    (FORMAT_ARGS_MACRO, FormatArgs) => format_args_expand,\n+    (column, Column) => column_expand,\n+    (compile_error, CompileError) => compile_error_expand,\n+    (file, File) => file_expand,\n+    (line, Line) => line_expand,\n+    (stringify, Stringify) => stringify_expand,\n+    (format_args, FormatArgs) => format_args_expand,\n     // format_args_nl only differs in that it adds a newline in the end,\n     // so we use the same stub expansion for now\n-    (FORMAT_ARGS_NL_MACRO, FormatArgsNl) => format_args_expand\n+    (format_args_nl, FormatArgsNl) => format_args_expand\n }\n \n fn to_line_number(db: &dyn AstDatabase, file: HirFileId, pos: TextUnit) -> usize {"}, {"sha": "59d8214fde89f23b10a9d263ecfac6117a15511a", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 96, "deletions": 68, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -104,71 +104,99 @@ impl AsName for ra_db::Dependency {\n     }\n }\n \n-// Primitives\n-pub const ISIZE: Name = Name::new_inline_ascii(b\"isize\");\n-pub const I8: Name = Name::new_inline_ascii(b\"i8\");\n-pub const I16: Name = Name::new_inline_ascii(b\"i16\");\n-pub const I32: Name = Name::new_inline_ascii(b\"i32\");\n-pub const I64: Name = Name::new_inline_ascii(b\"i64\");\n-pub const I128: Name = Name::new_inline_ascii(b\"i128\");\n-pub const USIZE: Name = Name::new_inline_ascii(b\"usize\");\n-pub const U8: Name = Name::new_inline_ascii(b\"u8\");\n-pub const U16: Name = Name::new_inline_ascii(b\"u16\");\n-pub const U32: Name = Name::new_inline_ascii(b\"u32\");\n-pub const U64: Name = Name::new_inline_ascii(b\"u64\");\n-pub const U128: Name = Name::new_inline_ascii(b\"u128\");\n-pub const F32: Name = Name::new_inline_ascii(b\"f32\");\n-pub const F64: Name = Name::new_inline_ascii(b\"f64\");\n-pub const BOOL: Name = Name::new_inline_ascii(b\"bool\");\n-pub const CHAR: Name = Name::new_inline_ascii(b\"char\");\n-pub const STR: Name = Name::new_inline_ascii(b\"str\");\n-\n-// Special names\n-pub const SELF_PARAM: Name = Name::new_inline_ascii(b\"self\");\n-pub const SELF_TYPE: Name = Name::new_inline_ascii(b\"Self\");\n-pub const MACRO_RULES: Name = Name::new_inline_ascii(b\"macro_rules\");\n-\n-// Components of known path (value or mod name)\n-pub const STD: Name = Name::new_inline_ascii(b\"std\");\n-pub const ITER: Name = Name::new_inline_ascii(b\"iter\");\n-pub const OPS: Name = Name::new_inline_ascii(b\"ops\");\n-pub const FUTURE: Name = Name::new_inline_ascii(b\"future\");\n-pub const RESULT: Name = Name::new_inline_ascii(b\"result\");\n-pub const BOXED: Name = Name::new_inline_ascii(b\"boxed\");\n-\n-// Components of known path (type name)\n-pub const INTO_ITERATOR_TYPE: Name = Name::new_inline_ascii(b\"IntoIterator\");\n-pub const ITEM_TYPE: Name = Name::new_inline_ascii(b\"Item\");\n-pub const TRY_TYPE: Name = Name::new_inline_ascii(b\"Try\");\n-pub const OK_TYPE: Name = Name::new_inline_ascii(b\"Ok\");\n-pub const FUTURE_TYPE: Name = Name::new_inline_ascii(b\"Future\");\n-pub const RESULT_TYPE: Name = Name::new_inline_ascii(b\"Result\");\n-pub const OUTPUT_TYPE: Name = Name::new_inline_ascii(b\"Output\");\n-pub const TARGET_TYPE: Name = Name::new_inline_ascii(b\"Target\");\n-pub const BOX_TYPE: Name = Name::new_inline_ascii(b\"Box\");\n-pub const RANGE_FROM_TYPE: Name = Name::new_inline_ascii(b\"RangeFrom\");\n-pub const RANGE_FULL_TYPE: Name = Name::new_inline_ascii(b\"RangeFull\");\n-pub const RANGE_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(b\"RangeInclusive\");\n-pub const RANGE_TO_INCLUSIVE_TYPE: Name = Name::new_inline_ascii(b\"RangeToInclusive\");\n-pub const RANGE_TO_TYPE: Name = Name::new_inline_ascii(b\"RangeTo\");\n-pub const RANGE_TYPE: Name = Name::new_inline_ascii(b\"Range\");\n-\n-// Builtin Macros\n-pub const FILE_MACRO: Name = Name::new_inline_ascii(b\"file\");\n-pub const COLUMN_MACRO: Name = Name::new_inline_ascii(b\"column\");\n-pub const COMPILE_ERROR_MACRO: Name = Name::new_inline_ascii(b\"compile_error\");\n-pub const LINE_MACRO: Name = Name::new_inline_ascii(b\"line\");\n-pub const STRINGIFY_MACRO: Name = Name::new_inline_ascii(b\"stringify\");\n-pub const FORMAT_ARGS_MACRO: Name = Name::new_inline_ascii(b\"format_args\");\n-pub const FORMAT_ARGS_NL_MACRO: Name = Name::new_inline_ascii(b\"format_args_nl\");\n-\n-// Builtin derives\n-pub const COPY_TRAIT: Name = Name::new_inline_ascii(b\"Copy\");\n-pub const CLONE_TRAIT: Name = Name::new_inline_ascii(b\"Clone\");\n-pub const DEFAULT_TRAIT: Name = Name::new_inline_ascii(b\"Default\");\n-pub const DEBUG_TRAIT: Name = Name::new_inline_ascii(b\"Debug\");\n-pub const HASH_TRAIT: Name = Name::new_inline_ascii(b\"Hash\");\n-pub const ORD_TRAIT: Name = Name::new_inline_ascii(b\"Ord\");\n-pub const PARTIAL_ORD_TRAIT: Name = Name::new_inline_ascii(b\"PartialOrd\");\n-pub const EQ_TRAIT: Name = Name::new_inline_ascii(b\"Eq\");\n-pub const PARTIAL_EQ_TRAIT: Name = Name::new_inline_ascii(b\"PartialEq\");\n+pub mod known {\n+    macro_rules! known_names {\n+        ($($ident:ident),* $(,)?) => {\n+            $(\n+                #[allow(bad_style)]\n+                pub const $ident: super::Name =\n+                    super::Name::new_inline_ascii(stringify!($ident).as_bytes());\n+            )*\n+        };\n+    }\n+\n+    known_names!(\n+        // Primitives\n+        isize,\n+        i8,\n+        i16,\n+        i32,\n+        i64,\n+        i128,\n+        usize,\n+        u8,\n+        u16,\n+        u32,\n+        u64,\n+        u128,\n+        f32,\n+        f64,\n+        bool,\n+        char,\n+        str,\n+        // Special names\n+        macro_rules,\n+        // Components of known path (value or mod name)\n+        std,\n+        iter,\n+        ops,\n+        future,\n+        result,\n+        boxed,\n+        // Components of known path (type name)\n+        IntoIterator,\n+        Item,\n+        Try,\n+        Ok,\n+        Future,\n+        Result,\n+        Output,\n+        Target,\n+        Box,\n+        RangeFrom,\n+        RangeFull,\n+        RangeInclusive,\n+        RangeToInclusive,\n+        RangeTo,\n+        Range,\n+        Neg,\n+        Not,\n+        // Builtin macros\n+        file,\n+        column,\n+        compile_error,\n+        line,\n+        stringify,\n+        format_args,\n+        format_args_nl,\n+        // Builtin derives\n+        Copy,\n+        Clone,\n+        Default,\n+        Debug,\n+        Hash,\n+        Ord,\n+        PartialOrd,\n+        Eq,\n+        PartialEq,\n+    );\n+\n+    // self/Self cannot be used as an identifier\n+    pub const SELF_PARAM: super::Name = super::Name::new_inline_ascii(b\"self\");\n+    pub const SELF_TYPE: super::Name = super::Name::new_inline_ascii(b\"Self\");\n+\n+    #[macro_export]\n+    macro_rules! name {\n+        (self) => {\n+            $crate::name::known::SELF_PARAM\n+        };\n+        (Self) => {\n+            $crate::name::known::SELF_TYPE\n+        };\n+        ($ident:ident) => {\n+            $crate::name::known::$ident\n+        };\n+    }\n+}\n+\n+pub use crate::name;"}, {"sha": "ee48fa53700767cfc0d2e632b0b9448b6ef6b810", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -6,7 +6,7 @@\n use std::iter::successors;\n \n use hir_def::lang_item::LangItemTarget;\n-use hir_expand::name;\n+use hir_expand::name::name;\n use log::{info, warn};\n use ra_db::CrateId;\n \n@@ -52,7 +52,7 @@ fn deref_by_trait(\n         LangItemTarget::TraitId(it) => it,\n         _ => return None,\n     };\n-    let target = db.trait_data(deref_trait).associated_type_by_name(&name::TARGET_TYPE)?;\n+    let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let generic_params = generics(db, target.into());\n     if generic_params.len() != 1 {"}, {"sha": "f752a9f09ae7cc96d5f2c44c0639364042e7c1d1", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    path::{known, Path},\n+    path::{path, Path},\n     resolver::HasResolver,\n     AdtId, FunctionId,\n };\n@@ -124,7 +124,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        let std_result_path = known::std_result_result();\n+        let std_result_path = path![std::result::Result];\n \n         let resolver = self.func.resolver(db);\n         let std_result_enum = match resolver.resolve_known_enum(db, &std_result_path) {"}, {"sha": "f1b7e9442d30dba47e78721c8f879295303a82c1", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -24,20 +24,20 @@ use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData},\n     expr::{BindingAnnotation, ExprId, PatId},\n-    path::{known, Path},\n+    path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocItemId, DefWithBodyId, FunctionId, StructFieldId, TypeAliasId, VariantId,\n };\n-use hir_expand::{diagnostics::DiagnosticSink, name};\n+use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n \n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n-    Uncertain,\n+    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    TypeWalk, Uncertain,\n };\n use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n \n@@ -338,6 +338,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.table.resolve_ty_shallow(ty)\n     }\n \n+    fn resolve_associated_type(&mut self, inner_ty: Ty, assoc_ty: Option<TypeAliasId>) -> Ty {\n+        match assoc_ty {\n+            Some(res_assoc_ty) => {\n+                let ty = self.table.new_type_var();\n+                let projection = ProjectionPredicate {\n+                    ty: ty.clone(),\n+                    projection_ty: ProjectionTy {\n+                        associated_ty: res_assoc_ty,\n+                        parameters: Substs::single(inner_ty),\n+                    },\n+                };\n+                self.obligations.push(Obligation::Projection(projection));\n+                self.resolve_ty_as_possible(ty)\n+            }\n+            None => Ty::Unknown,\n+        }\n+    }\n+\n     /// Recurses through the given type, normalizing associated types mentioned\n     /// in it by replacing them by type variables and registering obligations to\n     /// resolve later. This should be done once for every type we get from some\n@@ -404,61 +422,73 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n-        let path = known::std_iter_into_iterator();\n+        let path = path![std::iter::IntoIterator];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        let path = known::std_ops_try();\n+        let path = path![std::ops::Try];\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Ok])\n+    }\n+\n+    fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n+        let path = path![std::ops::Neg];\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+    }\n+\n+    fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n+        let path = path![std::ops::Not];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n-        let path = known::std_future_future();\n+        let path = path![std::future::Future];\n         let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE)\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n-        let path = known::std_boxed_box();\n+        let path = path![std::boxed::Box];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_full(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_full();\n+        let path = path![std::ops::RangeFull];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range();\n+        let path = path![std::ops::Range];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_inclusive(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_inclusive();\n+        let path = path![std::ops::RangeInclusive];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_from(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_from();\n+        let path = path![std::ops::RangeFrom];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_to();\n+        let path = path![std::ops::RangeTo];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n-        let path = known::std_ops_range_to_inclusive();\n+        let path = path![std::ops::RangeToInclusive];\n         let struct_ = self.resolver.resolve_known_struct(self.db, &path)?;\n         Some(struct_.into())\n     }"}, {"sha": "2e3cdd53a00f9319a41db09e8c43234264c2cc63", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 35, "deletions": 70, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     resolver::resolver_for_expr,\n     AdtId, ContainerId, Lookup, StructFieldId,\n };\n-use hir_expand::name::{self, Name};\n+use hir_expand::name::{name, Name};\n use ra_syntax::ast::RangeOp;\n \n use crate::{\n@@ -19,8 +19,8 @@ use crate::{\n     method_resolution, op,\n     traits::InEnvironment,\n     utils::{generics, variant_data, Generics},\n-    CallableDef, InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n-    TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n+    ApplicationTy, CallableDef, InferTy, IntTy, Mutability, Obligation, Substs, TraitRef, Ty,\n+    TypeCtor, TypeWalk, Uncertain,\n };\n \n use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n@@ -95,21 +95,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                let pat_ty = match self.resolve_into_iter_item() {\n-                    Some(into_iter_item_alias) => {\n-                        let pat_ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: pat_ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: into_iter_item_alias,\n-                                parameters: Substs::single(iterable_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(pat_ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let pat_ty =\n+                    self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(*pat, &pat_ty, BindingMode::default());\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -284,40 +271,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let ty = match self.resolve_future_future_output() {\n-                    Some(future_future_output_alias) => {\n-                        let ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: future_future_output_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let ty =\n+                    self.resolve_associated_type(inner_ty, self.resolve_future_future_output());\n                 ty\n             }\n             Expr::Try { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let ty = match self.resolve_ops_try_ok() {\n-                    Some(ops_try_ok_alias) => {\n-                        let ty = self.table.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: ops_try_ok_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n+                let ty = self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok());\n                 ty\n             }\n             Expr::Cast { expr, type_ref } => {\n@@ -372,31 +332,36 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     },\n                     UnaryOp::Neg => {\n                         match &inner_ty {\n-                            Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Int(Uncertain::Unknown)\n-                                | TypeCtor::Int(Uncertain::Known(IntTy {\n-                                    signedness: Signedness::Signed,\n-                                    ..\n-                                }))\n-                                | TypeCtor::Float(..) => inner_ty,\n-                                _ => Ty::Unknown,\n-                            },\n-                            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => {\n-                                inner_ty\n-                            }\n-                            // FIXME: resolve ops::Neg trait\n-                            _ => Ty::Unknown,\n+                            // Fast path for builtins\n+                            Ty::Apply(ApplicationTy {\n+                                ctor:\n+                                    TypeCtor::Int(Uncertain::Known(IntTy {\n+                                        signedness: Signedness::Signed,\n+                                        ..\n+                                    })),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy {\n+                                ctor: TypeCtor::Int(Uncertain::Unknown),\n+                                ..\n+                            })\n+                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(_), .. })\n+                            | Ty::Infer(InferTy::IntVar(..))\n+                            | Ty::Infer(InferTy::FloatVar(..)) => inner_ty,\n+                            // Otherwise we resolve via the std::ops::Neg trait\n+                            _ => self\n+                                .resolve_associated_type(inner_ty, self.resolve_ops_neg_output()),\n                         }\n                     }\n                     UnaryOp::Not => {\n                         match &inner_ty {\n-                            Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Bool | TypeCtor::Int(_) => inner_ty,\n-                                _ => Ty::Unknown,\n-                            },\n-                            Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n-                            // FIXME: resolve ops::Not trait for inner_ty\n-                            _ => Ty::Unknown,\n+                            // Fast path for builtins\n+                            Ty::Apply(ApplicationTy { ctor: TypeCtor::Bool, .. })\n+                            | Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(_), .. })\n+                            | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n+                            // Otherwise we resolve via the std::ops::Not trait\n+                            _ => self\n+                                .resolve_associated_type(inner_ty, self.resolve_ops_not_output()),\n                         }\n                     }\n                 }\n@@ -666,7 +631,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // Parent arguments are unknown, except for the receiver type\n         if let Some(parent_generics) = def_generics.as_ref().map(|p| p.iter_parent()) {\n             for (_id, param) in parent_generics {\n-                if param.name == name::SELF_TYPE {\n+                if param.name == name![Self] {\n                     substs.push(receiver_ty.clone());\n                 } else {\n                     substs.push(Ty::Unknown);"}, {"sha": "6139adb72e501b5b64d49aa159d501c224f32c8e", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -115,6 +115,70 @@ mod collections {\n     assert_eq!(\"&str\", type_at_pos(&db, pos));\n }\n \n+#[test]\n+fn infer_ops_neg() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct Bar;\n+struct Foo;\n+\n+impl std::ops::Neg for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = -a;\n+    b<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    pub trait Neg {\n+        type Output;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n+}\n+\n+#[test]\n+fn infer_ops_not() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+\n+struct Bar;\n+struct Foo;\n+\n+impl std::ops::Not for Bar {\n+    type Output = Foo;\n+}\n+\n+fn test() {\n+    let a = Bar;\n+    let b = !a;\n+    b<|>;\n+}\n+\n+//- /std.rs crate:std\n+\n+#[prelude_import] use ops::*;\n+mod ops {\n+    pub trait Not {\n+        type Output;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn infer_from_bound_1() {\n     assert_snapshot!("}, {"sha": "cd587a3382808650742d5dfb35634d9f585a2e85", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -1,7 +1,7 @@\n //! This module provides the built-in trait implementations, e.g. to make\n //! closures implement `Fn`.\n use hir_def::{expr::Expr, lang_item::LangItemTarget, TraitId, TypeAliasId};\n-use hir_expand::name;\n+use hir_expand::name::name;\n use ra_db::CrateId;\n \n use super::{AssocTyValue, Impl};\n@@ -79,7 +79,7 @@ fn closure_fn_trait_impl_datum(\n     // and don't want to return a valid value only to find out later that FnOnce\n     // is broken\n     let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n-    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name::OUTPUT_TYPE)?;\n+    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n         Expr::Lambda { args, .. } => args.len() as u16,\n@@ -137,7 +137,7 @@ fn closure_fn_trait_output_assoc_ty_value(\n \n     let output_ty_id = db\n         .trait_data(fn_once_trait)\n-        .associated_type_by_name(&name::OUTPUT_TYPE)\n+        .associated_type_by_name(&name![Output])\n         .expect(\"assoc ty value should not exist\");\n \n     BuiltinImplAssocTyValueData {"}, {"sha": "0049d3c6fc01023cf6268483a9af70e56e082afd", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -10,10 +10,8 @@ use hir_def::{\n     type_ref::TypeRef,\n     ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId, TypeParamId, VariantId,\n };\n-use hir_expand::name::{self, Name};\n+use hir_expand::name::{name, Name};\n \n-// FIXME: this is wrong, b/c it can't express `trait T: PartialEq<()>`.\n-// We should return a `TraitREf` here.\n fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n     // returning the iterator directly doesn't easily work because of\n@@ -24,7 +22,7 @@ fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n         .where_predicates\n         .iter()\n         .filter_map(|pred| match &pred.type_ref {\n-            TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n+            TypeRef::Path(p) if p.as_ident() == Some(&name![Self]) => pred.bound.as_path(),\n             _ => None,\n         })\n         .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {"}, {"sha": "67942aa4147cd1f6bd273d87fe369dfdf04e142b", "filename": "crates/ra_lsp_server/src/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconfig.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -9,6 +9,7 @@\n \n use rustc_hash::FxHashMap;\n \n+use ra_project_model::CargoFeatures;\n use serde::{Deserialize, Deserializer};\n \n /// Client provided initialization options\n@@ -37,6 +38,9 @@ pub struct ServerConfig {\n \n     /// Fine grained feature flags to disable specific features.\n     pub feature_flags: FxHashMap<String, bool>,\n+\n+    /// Cargo feature configurations.\n+    pub cargo_features: CargoFeatures,\n }\n \n impl Default for ServerConfig {\n@@ -49,6 +53,7 @@ impl Default for ServerConfig {\n             max_inlay_hint_length: None,\n             with_sysroot: true,\n             feature_flags: FxHashMap::default(),\n+            cargo_features: Default::default(),\n         }\n     }\n }"}, {"sha": "5561f6270b6a6a72f433ac91987c54e92655c662", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -130,6 +130,11 @@ impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n             deprecated: Some(self.deprecated()),\n             ..Default::default()\n         };\n+\n+        if self.deprecated() {\n+            res.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n+        }\n+\n         res.insert_text_format = Some(match self.insert_text_format() {\n             InsertTextFormat::Snippet => lsp_types::InsertTextFormat::Snippet,\n             InsertTextFormat::PlainText => lsp_types::InsertTextFormat::PlainText,"}, {"sha": "965e7c53c146e0ca17dd64fe0d5f7780a403fc48", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -67,6 +67,7 @@ pub fn main_loop(\n                 let workspace = ra_project_model::ProjectWorkspace::discover_with_sysroot(\n                     ws_root.as_path(),\n                     config.with_sysroot,\n+                    &config.cargo_features,\n                 );\n                 match workspace {\n                     Ok(workspace) => loaded_workspaces.push(workspace),"}, {"sha": "4a0437da3200c7d220be09e2794ca213a8dc13c6", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -6,6 +6,7 @@ use cargo_metadata::{CargoOpt, MetadataCommand};\n use ra_arena::{impl_arena_id, Arena, RawId};\n use ra_db::Edition;\n use rustc_hash::FxHashMap;\n+use serde::Deserialize;\n \n use crate::Result;\n \n@@ -23,6 +24,20 @@ pub struct CargoWorkspace {\n     pub(crate) workspace_root: PathBuf,\n }\n \n+#[derive(Deserialize, Clone, Debug, PartialEq, Eq, Default)]\n+#[serde(rename_all = \"camelCase\", default)]\n+pub struct CargoFeatures {\n+    /// Do not activate the `default` feature.\n+    pub no_default_features: bool,\n+\n+    /// Activate all available features\n+    pub all_features: bool,\n+\n+    /// List of features to activate.\n+    /// This will be ignored if `cargo_all_features` is true.\n+    pub features: Vec<String>,\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Package(RawId);\n impl_arena_id!(Package);\n@@ -132,9 +147,21 @@ impl Target {\n }\n \n impl CargoWorkspace {\n-    pub fn from_cargo_metadata(cargo_toml: &Path) -> Result<CargoWorkspace> {\n+    pub fn from_cargo_metadata(\n+        cargo_toml: &Path,\n+        cargo_features: &CargoFeatures,\n+    ) -> Result<CargoWorkspace> {\n         let mut meta = MetadataCommand::new();\n-        meta.manifest_path(cargo_toml).features(CargoOpt::AllFeatures);\n+        meta.manifest_path(cargo_toml);\n+        if cargo_features.all_features {\n+            meta.features(CargoOpt::AllFeatures);\n+        } else if cargo_features.no_default_features {\n+            // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n+            // https://github.com/oli-obk/cargo_metadata/issues/79\n+            meta.features(CargoOpt::NoDefaultFeatures);\n+        } else {\n+            meta.features(CargoOpt::SomeFeatures(cargo_features.features.clone()));\n+        }\n         if let Some(parent) = cargo_toml.parent() {\n             meta.current_dir(parent);\n         }"}, {"sha": "d71b7031a8a70825d77e53a6f9f170248d751e55", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -18,7 +18,7 @@ use rustc_hash::FxHashMap;\n use serde_json::from_reader;\n \n pub use crate::{\n-    cargo_workspace::{CargoWorkspace, Package, Target, TargetKind},\n+    cargo_workspace::{CargoFeatures, CargoWorkspace, Package, Target, TargetKind},\n     json_project::JsonProject,\n     sysroot::Sysroot,\n };\n@@ -60,11 +60,15 @@ impl PackageRoot {\n }\n \n impl ProjectWorkspace {\n-    pub fn discover(path: &Path) -> Result<ProjectWorkspace> {\n-        ProjectWorkspace::discover_with_sysroot(path, true)\n+    pub fn discover(path: &Path, cargo_features: &CargoFeatures) -> Result<ProjectWorkspace> {\n+        ProjectWorkspace::discover_with_sysroot(path, true, cargo_features)\n     }\n \n-    pub fn discover_with_sysroot(path: &Path, with_sysroot: bool) -> Result<ProjectWorkspace> {\n+    pub fn discover_with_sysroot(\n+        path: &Path,\n+        with_sysroot: bool,\n+        cargo_features: &CargoFeatures,\n+    ) -> Result<ProjectWorkspace> {\n         match find_rust_project_json(path) {\n             Some(json_path) => {\n                 let file = File::open(json_path)?;\n@@ -73,7 +77,7 @@ impl ProjectWorkspace {\n             }\n             None => {\n                 let cargo_toml = find_cargo_toml(path)?;\n-                let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml)?;\n+                let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_features)?;\n                 let sysroot =\n                     if with_sysroot { Sysroot::discover(&cargo_toml)? } else { Sysroot::default() };\n                 Ok(ProjectWorkspace::Cargo { cargo, sysroot })"}, {"sha": "43db61a8bc0f82337d406e4e585086c081a8a085", "filename": "editors/code/package.json", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -278,6 +278,21 @@\n                     \"type\": \"number\",\n                     \"default\": 20,\n                     \"description\": \"Maximum length for inlay hints\"\n+                },\n+                \"rust-analyzer.cargoFeatures.noDefaultFeatures\": {\n+                    \"type\": \"boolean\",\n+                    \"default\": false,\n+                    \"description\": \"Do not activate the `default` feature\"\n+                },\n+                \"rust-analyzer.cargoFeatures.allFeatures\": {\n+                    \"type\": \"boolean\",\n+                    \"default\": true,\n+                    \"description\": \"Activate all available features\"\n+                },\n+                \"rust-analyzer.cargoFeatures.features\": {\n+                    \"type\": \"array\",\n+                    \"default\": [],\n+                    \"description\": \"List of features to activate\"\n                 }\n             }\n         },"}, {"sha": "defdfeb9c4bdca69d8d23467136041318ac9369d", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 64, "deletions": 13, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -15,6 +15,12 @@ export interface CargoWatchOptions {\n     ignore: string[];\n }\n \n+export interface CargoFeatures {\n+    noDefaultFeatures: boolean;\n+    allFeatures: boolean;\n+    features: string[];\n+}\n+\n export class Config {\n     public highlightingOn = true;\n     public rainbowHighlightingOn = false;\n@@ -35,8 +41,14 @@ export class Config {\n         command: '',\n         ignore: [],\n     };\n+    public cargoFeatures: CargoFeatures = {\n+        noDefaultFeatures: false,\n+        allFeatures: true,\n+        features: [],\n+    };\n \n     private prevEnhancedTyping: null | boolean = null;\n+    private prevCargoFeatures: null | CargoFeatures = null;\n \n     constructor() {\n         vscode.workspace.onDidChangeConfiguration(_ =>\n@@ -47,6 +59,8 @@ export class Config {\n \n     public userConfigChanged() {\n         const config = vscode.workspace.getConfiguration('rust-analyzer');\n+        let requireReloadMessage = null;\n+\n         if (config.has('highlightingOn')) {\n             this.highlightingOn = config.get('highlightingOn') as boolean;\n         }\n@@ -74,19 +88,8 @@ export class Config {\n         }\n \n         if (this.prevEnhancedTyping !== this.enableEnhancedTyping) {\n-            const reloadAction = 'Reload now';\n-            vscode.window\n-                .showInformationMessage(\n-                    'Changing enhanced typing setting requires a reload',\n-                    reloadAction,\n-                )\n-                .then(selectedAction => {\n-                    if (selectedAction === reloadAction) {\n-                        vscode.commands.executeCommand(\n-                            'workbench.action.reloadWindow',\n-                        );\n-                    }\n-                });\n+            requireReloadMessage =\n+                'Changing enhanced typing setting requires a reload';\n             this.prevEnhancedTyping = this.enableEnhancedTyping;\n         }\n \n@@ -153,5 +156,53 @@ export class Config {\n         if (config.has('withSysroot')) {\n             this.withSysroot = config.get('withSysroot') || false;\n         }\n+\n+        if (config.has('cargoFeatures.noDefaultFeatures')) {\n+            this.cargoFeatures.noDefaultFeatures = config.get(\n+                'cargoFeatures.noDefaultFeatures',\n+                false,\n+            );\n+        }\n+        if (config.has('cargoFeatures.allFeatures')) {\n+            this.cargoFeatures.allFeatures = config.get(\n+                'cargoFeatures.allFeatures',\n+                true,\n+            );\n+        }\n+        if (config.has('cargoFeatures.features')) {\n+            this.cargoFeatures.features = config.get(\n+                'cargoFeatures.features',\n+                [],\n+            );\n+        }\n+\n+        if (\n+            this.prevCargoFeatures !== null &&\n+            (this.cargoFeatures.allFeatures !==\n+                this.prevCargoFeatures.allFeatures ||\n+                this.cargoFeatures.noDefaultFeatures !==\n+                    this.prevCargoFeatures.noDefaultFeatures ||\n+                this.cargoFeatures.features.length !==\n+                    this.prevCargoFeatures.features.length ||\n+                this.cargoFeatures.features.some(\n+                    (v, i) => v !== this.prevCargoFeatures!.features[i],\n+                ))\n+        ) {\n+            requireReloadMessage = 'Changing cargo features requires a reload';\n+        }\n+        this.prevCargoFeatures = { ...this.cargoFeatures };\n+\n+        if (requireReloadMessage !== null) {\n+            const reloadAction = 'Reload now';\n+            vscode.window\n+                .showInformationMessage(requireReloadMessage, reloadAction)\n+                .then(selectedAction => {\n+                    if (selectedAction === reloadAction) {\n+                        vscode.commands.executeCommand(\n+                            'workbench.action.reloadWindow',\n+                        );\n+                    }\n+                });\n+        }\n     }\n }"}, {"sha": "5ace1d0faeb4c2b794e59276cc249748f84c6e43", "filename": "editors/code/src/server.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e4e713fc9c201852fc5fbafd57e5b9243149a78/editors%2Fcode%2Fsrc%2Fserver.ts", "raw_url": "https://github.com/rust-lang/rust/raw/5e4e713fc9c201852fc5fbafd57e5b9243149a78/editors%2Fcode%2Fsrc%2Fserver.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fserver.ts?ref=5e4e713fc9c201852fc5fbafd57e5b9243149a78", "patch": "@@ -59,6 +59,7 @@ export class Server {\n                 useClientWatching: Server.config.useClientWatching,\n                 featureFlags: Server.config.featureFlags,\n                 withSysroot: Server.config.withSysroot,\n+                cargoFeatures: Server.config.cargoFeatures,\n             },\n             traceOutputChannel,\n         };"}]}