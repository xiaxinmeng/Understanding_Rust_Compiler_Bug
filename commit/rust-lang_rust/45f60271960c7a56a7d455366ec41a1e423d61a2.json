{"sha": "45f60271960c7a56a7d455366ec41a1e423d61a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZjYwMjcxOTYwYzdhNTZhN2Q0NTUzNjZlYzQxYTFlNDIzZDYxYTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-17T18:28:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:51:13Z"}, "message": "break type-checking of aggregate-kind out into helper function", "tree": {"sha": "4e8653c6828143bfc711f7fea4a2d6031b128c5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8653c6828143bfc711f7fea4a2d6031b128c5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45f60271960c7a56a7d455366ec41a1e423d61a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45f60271960c7a56a7d455366ec41a1e423d61a2", "html_url": "https://github.com/rust-lang/rust/commit/45f60271960c7a56a7d455366ec41a1e423d61a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45f60271960c7a56a7d455366ec41a1e423d61a2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31d61f1f86789869c675d446f03c4d21f8623b57", "url": "https://api.github.com/repos/rust-lang/rust/commits/31d61f1f86789869c675d446f03c4d21f8623b57", "html_url": "https://github.com/rust-lang/rust/commit/31d61f1f86789869c675d446f03c4d21f8623b57"}], "stats": {"total": 97, "additions": 52, "deletions": 45}, "files": [{"sha": "fc2a51e27381922865cb756ecfda5d236149f7e3", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/45f60271960c7a56a7d455366ec41a1e423d61a2/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f60271960c7a56a7d455366ec41a1e423d61a2/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=45f60271960c7a56a7d455366ec41a1e423d61a2", "patch": "@@ -1031,13 +1031,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn aggregate_field_ty(\n         &mut self,\n-        ak: &Box<AggregateKind<'tcx>>,\n+        ak: &AggregateKind<'tcx>,\n         field_index: usize,\n         location: Location,\n     ) -> Result<Ty<'tcx>, FieldAccessError> {\n         let tcx = self.tcx();\n \n-        match **ak {\n+        match *ak {\n             AggregateKind::Adt(def, variant_index, substs, active_field_index) => {\n                 let variant = &def.variants[variant_index];\n                 let adj_field_index = active_field_index.unwrap_or(field_index);\n@@ -1069,56 +1069,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            AggregateKind::Array(ty) => {\n-                Ok(ty)\n-            }\n+            AggregateKind::Array(ty) => Ok(ty),\n             AggregateKind::Tuple => {\n                 unreachable!(\"This should have been covered in check_rvalues\");\n             }\n         }\n     }\n \n-    fn check_rvalue(&mut self, mir: &Mir<'tcx>, rv: &Rvalue<'tcx>, location: Location) {\n-        let tcx = self.tcx();\n-        match rv {\n+    fn check_rvalue(&mut self, mir: &Mir<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+        match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n-                match **ak {\n-                    // tuple rvalue field type is always the type of the op. Nothing to check here.\n-                    AggregateKind::Tuple => {}\n-                    _ => {\n-                        for (i, op) in ops.iter().enumerate() {\n-                            let field_ty = match self.aggregate_field_ty(ak, i, location) {\n-                                Ok(field_ty) => field_ty,\n-                                Err(FieldAccessError::OutOfRange { field_count }) => {\n-                                    span_mirbug!(\n-                                        self,\n-                                        rv,\n-                                        \"accessed field #{} but variant only has {}\",\n-                                        i,\n-                                        field_count\n-                                    );\n-                                    continue;\n-                                }\n-                            };\n-                            let op_ty = op.ty(mir, tcx);\n-                            if let Err(terr) = self.sub_types(\n-                                op_ty,\n-                                field_ty,\n-                                location.at_successor_within_block(),\n-                            )\n-                                {\n-                                    span_mirbug!(\n-                                    self,\n-                                    rv,\n-                                    \"{:?} is not a subtype of {:?}: {:?}\",\n-                                    op_ty,\n-                                    field_ty,\n-                                    terr\n-                                );\n-                                }\n-                        }\n-                    }\n-                }\n+                self.check_aggregate_rvalue(mir, rvalue, ak, ops, location)\n             }\n             // FIXME: These other cases have to be implemented in future PRs\n             Rvalue::Use(..) |\n@@ -1134,6 +1095,52 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn check_aggregate_rvalue(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        aggregate_kind: &AggregateKind<'tcx>,\n+        operands: &[Operand<'tcx>],\n+        location: Location,\n+    ) {\n+        match aggregate_kind {\n+            // tuple rvalue field type is always the type of the op. Nothing to check here.\n+            AggregateKind::Tuple => return,\n+            _ => {}\n+        }\n+\n+        let tcx = self.tcx();\n+\n+        for (i, operand) in operands.iter().enumerate() {\n+            let field_ty = match self.aggregate_field_ty(aggregate_kind, i, location) {\n+                Ok(field_ty) => field_ty,\n+                Err(FieldAccessError::OutOfRange { field_count }) => {\n+                    span_mirbug!(\n+                        self,\n+                        rvalue,\n+                        \"accessed field #{} but variant only has {}\",\n+                        i,\n+                        field_count\n+                    );\n+                    continue;\n+                }\n+            };\n+            let operand_ty = operand.ty(mir, tcx);\n+            if let Err(terr) =\n+                self.sub_types(operand_ty, field_ty, location.at_successor_within_block())\n+            {\n+                span_mirbug!(\n+                    self,\n+                    rvalue,\n+                    \"{:?} is not a subtype of {:?}: {:?}\",\n+                    operand_ty,\n+                    field_ty,\n+                    terr\n+                );\n+            }\n+        }\n+    }\n+\n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);"}]}