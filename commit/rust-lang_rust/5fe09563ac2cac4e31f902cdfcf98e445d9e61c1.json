{"sha": "5fe09563ac2cac4e31f902cdfcf98e445d9e61c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZTA5NTYzYWMyY2FjNGUzMWY5MDJjZGZjZjk4ZTQ0NWQ5ZTYxYzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-27T02:10:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-27T03:12:55Z"}, "message": "Remove `@mut Resolver`\n\nInstead use &mut everywhere as much as possible and then reorganize lots of code\nto get past the borrow checker.", "tree": {"sha": "88943a30e8c5d1a077b2ee393bda82ee4d2ce193", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88943a30e8c5d1a077b2ee393bda82ee4d2ce193"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fe09563ac2cac4e31f902cdfcf98e445d9e61c1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fe09563ac2cac4e31f902cdfcf98e445d9e61c1", "html_url": "https://github.com/rust-lang/rust/commit/5fe09563ac2cac4e31f902cdfcf98e445d9e61c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fe09563ac2cac4e31f902cdfcf98e445d9e61c1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48499c7494d47f505a640157816cea2690b8d407", "url": "https://api.github.com/repos/rust-lang/rust/commits/48499c7494d47f505a640157816cea2690b8d407", "html_url": "https://github.com/rust-lang/rust/commit/48499c7494d47f505a640157816cea2690b8d407"}], "stats": {"total": 661, "additions": 308, "deletions": 353}, "files": [{"sha": "a01f4f042462c4d2357d93d91799ba9af4b76cc2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 308, "deletions": 353, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/5fe09563ac2cac4e31f902cdfcf98e445d9e61c1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fe09563ac2cac4e31f902cdfcf98e445d9e61c1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5fe09563ac2cac4e31f902cdfcf98e445d9e61c1", "patch": "@@ -135,28 +135,24 @@ pub enum SelfBinding {\n     HasSelfBinding(NodeId)\n }\n \n-struct ResolveVisitor {\n-    resolver: @mut Resolver,\n-}\n-\n-impl Visitor<()> for ResolveVisitor {\n+impl Visitor<()> for Resolver {\n     fn visit_item(&mut self, item:@item, _:()) {\n-        self.resolver.resolve_item(item, self);\n+        self.resolve_item(item);\n     }\n     fn visit_arm(&mut self, arm:&Arm, _:()) {\n-        self.resolver.resolve_arm(arm, self);\n+        self.resolve_arm(arm);\n     }\n     fn visit_block(&mut self, block:&Block, _:()) {\n-        self.resolver.resolve_block(block, self);\n+        self.resolve_block(block);\n     }\n     fn visit_expr(&mut self, expr:@Expr, _:()) {\n-        self.resolver.resolve_expr(expr, self);\n+        self.resolve_expr(expr);\n     }\n     fn visit_local(&mut self, local:@Local, _:()) {\n-        self.resolver.resolve_local(local, self);\n+        self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty:&Ty, _:()) {\n-        self.resolver.resolve_type(ty, self);\n+        self.resolve_type(ty);\n     }\n }\n \n@@ -541,7 +537,7 @@ enum TraitReferenceType {\n \n impl NameBindings {\n     /// Creates a new module in this set of name bindings.\n-    pub fn define_module(@mut self,\n+    pub fn define_module(&mut self,\n                          privacy: Privacy,\n                          parent_link: ParentLink,\n                          def_id: Option<DefId>,\n@@ -571,7 +567,7 @@ impl NameBindings {\n     }\n \n     /// Sets the kind of the module, creating a new one if necessary.\n-    pub fn set_module_kind(@mut self,\n+    pub fn set_module_kind(&mut self,\n                            privacy: Privacy,\n                            parent_link: ParentLink,\n                            def_id: Option<DefId>,\n@@ -609,7 +605,7 @@ impl NameBindings {\n     }\n \n     /// Records a type definition.\n-    pub fn define_type(@mut self, privacy: Privacy, def: Def, sp: Span) {\n+    pub fn define_type(&mut self, privacy: Privacy, def: Def, sp: Span) {\n         // Merges the type with the existing type def or creates a new one.\n         match self.type_def {\n             None => {\n@@ -632,7 +628,7 @@ impl NameBindings {\n     }\n \n     /// Records a value definition.\n-    pub fn define_value(@mut self, privacy: Privacy, def: Def, sp: Span) {\n+    pub fn define_value(&mut self, privacy: Privacy, def: Def, sp: Span) {\n         self.value_def = Some(ValueNsDef { privacy: privacy, def: def, value_span: Some(sp) });\n     }\n \n@@ -648,7 +644,7 @@ impl NameBindings {\n      * Returns the module node. Fails if this node does not have a module\n      * definition.\n      */\n-    pub fn get_module(@mut self) -> @mut Module {\n+    pub fn get_module(&mut self) -> @mut Module {\n         match self.get_module_if_available() {\n             None => {\n                 fail!(\"get_module called on a node with no module \\\n@@ -921,39 +917,40 @@ pub struct Resolver {\n     used_imports: HashSet<NodeId>,\n }\n \n-struct BuildReducedGraphVisitor {\n-    resolver: @mut Resolver,\n+struct BuildReducedGraphVisitor<'self> {\n+    resolver: &'self mut Resolver,\n }\n \n-impl Visitor<ReducedGraphParent> for BuildReducedGraphVisitor {\n+impl<'self> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'self> {\n \n     fn visit_item(&mut self, item:@item, context:ReducedGraphParent) {\n-        self.resolver.build_reduced_graph_for_item(item, (context, self));\n+        let p = self.resolver.build_reduced_graph_for_item(item, context);\n+        visit::walk_item(self, item, p);\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item:@foreign_item, context:ReducedGraphParent) {\n-        self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                             (context,\n-                                                              self));\n+    fn visit_foreign_item(&mut self, foreign_item: @foreign_item,\n+                          context:ReducedGraphParent) {\n+        do self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n+                                                              context) |r, c| {\n+            let mut v = BuildReducedGraphVisitor{ resolver: r };\n+            visit::walk_foreign_item(&mut v, foreign_item, c);\n+        }\n     }\n \n     fn visit_view_item(&mut self, view_item:&view_item, context:ReducedGraphParent) {\n-        self.resolver.build_reduced_graph_for_view_item(view_item,\n-                                                          (context,\n-                                                           self));\n+        self.resolver.build_reduced_graph_for_view_item(view_item, context);\n     }\n \n     fn visit_block(&mut self, block:&Block, context:ReducedGraphParent) {\n-        self.resolver.build_reduced_graph_for_block(block,\n-                                                      (context,\n-                                                       self));\n+        let np = self.resolver.build_reduced_graph_for_block(block, context);\n+        visit::walk_block(self, block, np);\n     }\n \n }\n \n-struct UnusedImportCheckVisitor { resolver: @mut Resolver }\n+struct UnusedImportCheckVisitor<'self> { resolver: &'self Resolver }\n \n-impl Visitor<()> for UnusedImportCheckVisitor {\n+impl<'self> Visitor<()> for UnusedImportCheckVisitor<'self> {\n     fn visit_view_item(&mut self, vi:&view_item, _:()) {\n         self.resolver.check_for_item_unused_imports(vi);\n         visit::walk_view_item(self, vi, ());\n@@ -962,7 +959,7 @@ impl Visitor<()> for UnusedImportCheckVisitor {\n \n impl Resolver {\n     /// The main name resolution procedure.\n-    pub fn resolve(@mut self) {\n+    pub fn resolve(&mut self) {\n         self.build_reduced_graph();\n         self.session.abort_if_errors();\n \n@@ -986,7 +983,7 @@ impl Resolver {\n     //\n \n     /// Constructs the reduced graph for the entire crate.\n-    pub fn build_reduced_graph(@mut self) {\n+    pub fn build_reduced_graph(&mut self) {\n         let initial_parent =\n             ModuleReducedGraphParent(self.graph_root.get_module());\n \n@@ -995,7 +992,7 @@ impl Resolver {\n     }\n \n     /// Returns the current module tracked by the reduced graph parent.\n-    pub fn get_module_from_parent(@mut self,\n+    pub fn get_module_from_parent(&mut self,\n                                   reduced_graph_parent: ReducedGraphParent)\n                                   -> @mut Module {\n         match reduced_graph_parent {\n@@ -1015,7 +1012,7 @@ impl Resolver {\n      * If this node does not have a module definition and we are not inside\n      * a block, fails.\n      */\n-    pub fn add_child(@mut self,\n+    pub fn add_child(&mut self,\n                      name: Ident,\n                      reduced_graph_parent: ReducedGraphParent,\n                      duplicate_checking_mode: DuplicateCheckingMode,\n@@ -1121,7 +1118,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn block_needs_anonymous_module(@mut self, block: &Block) -> bool {\n+    pub fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If the block has view items, we need an anonymous module.\n         if block.view_items.len() > 0 {\n             return true;\n@@ -1152,7 +1149,7 @@ impl Resolver {\n         return false;\n     }\n \n-    pub fn get_parent_link(@mut self, parent: ReducedGraphParent, name: Ident)\n+    pub fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Ident)\n                            -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n@@ -1162,16 +1159,17 @@ impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    pub fn build_reduced_graph_for_item(@mut self,\n+    pub fn build_reduced_graph_for_item(&mut self,\n                                         item: @item,\n-                                        (parent, visitor): (ReducedGraphParent,\n-                                                            &mut BuildReducedGraphVisitor)) {\n+                                        parent: ReducedGraphParent)\n+                                            -> ReducedGraphParent\n+    {\n         let ident = item.ident;\n         let sp = item.span;\n         let privacy = visibility_to_privacy(item.vis);\n \n         match item.node {\n-            item_mod(ref module_) => {\n+            item_mod(*) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n@@ -1184,14 +1182,11 @@ impl Resolver {\n                                             false,\n                                             sp);\n \n-                let new_parent =\n-                    ModuleReducedGraphParent(name_bindings.get_module());\n-\n-                visit::walk_mod(visitor, module_, new_parent);\n+                ModuleReducedGraphParent(name_bindings.get_module())\n             }\n \n             item_foreign_mod(ref fm) => {\n-                let new_parent = match fm.sort {\n+                match fm.sort {\n                     named => {\n                         let (name_bindings, new_parent) =\n                             self.add_child(ident, parent,\n@@ -1213,9 +1208,7 @@ impl Resolver {\n                     // For anon foreign mods, the contents just go in the\n                     // current scope\n                     anonymous => parent\n-                };\n-\n-                visit::walk_item(visitor, item, new_parent);\n+                }\n             }\n \n             // These items live in the value namespace.\n@@ -1226,14 +1219,15 @@ impl Resolver {\n \n                 name_bindings.define_value\n                     (privacy, DefStatic(local_def(item.id), mutbl), sp);\n+                parent\n             }\n             item_fn(_, purity, _, _, _) => {\n               let (name_bindings, new_parent) =\n                 self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n                 let def = DefFn(local_def(item.id), purity);\n                 name_bindings.define_value(privacy, def, sp);\n-                visit::walk_item(visitor, item, new_parent);\n+                new_parent\n             }\n \n             // These items live in the type namespace.\n@@ -1243,6 +1237,7 @@ impl Resolver {\n \n                 name_bindings.define_type\n                     (privacy, DefTy(local_def(item.id)), sp);\n+                parent\n             }\n \n             item_enum(ref enum_definition, _) => {\n@@ -1259,8 +1254,9 @@ impl Resolver {\n                         // inherited => privacy of the enum item\n                         variant_visibility_to_privacy(variant.node.vis,\n                                                       privacy == Public),\n-                        new_parent, visitor);\n+                        new_parent);\n                 }\n+                parent\n             }\n \n             // These items live in both the type and value namespaces.\n@@ -1286,7 +1282,7 @@ impl Resolver {\n                 // Record the def ID of this struct.\n                 self.structs.insert(local_def(item.id));\n \n-                visit::walk_item(visitor, item, new_parent);\n+                new_parent\n             }\n \n             item_impl(_, None, ref ty, ref methods) => {\n@@ -1370,12 +1366,10 @@ impl Resolver {\n                     _ => {}\n                 }\n \n-                visit::walk_item(visitor, item, parent);\n+                parent\n             }\n \n-            item_impl(_, Some(_), _, _) => {\n-                visit::walk_item(visitor, item, parent);\n-            }\n+            item_impl(_, Some(_), _, _) => parent,\n \n             item_trait(_, _, ref methods) => {\n                 let (name_bindings, new_parent) =\n@@ -1442,7 +1436,7 @@ impl Resolver {\n                 }\n \n                 name_bindings.define_type(privacy, DefTrait(def_id), sp);\n-                visit::walk_item(visitor, item, new_parent);\n+                new_parent\n             }\n \n             item_mac(*) => {\n@@ -1453,12 +1447,11 @@ impl Resolver {\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n     // type and/or value namespaces.\n-    pub fn build_reduced_graph_for_variant(@mut self,\n+    pub fn build_reduced_graph_for_variant(&mut self,\n                                            variant: &variant,\n                                            item_id: DefId,\n                                            parent_privacy: Privacy,\n-                                           parent: ReducedGraphParent,\n-                                           _: &mut BuildReducedGraphVisitor) {\n+                                           parent: ReducedGraphParent) {\n         let ident = variant.node.name;\n \n         let privacy =\n@@ -1491,11 +1484,9 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one 'view item'. View items consist\n     /// of imports and use directives.\n-    pub fn build_reduced_graph_for_view_item(@mut self,\n+    pub fn build_reduced_graph_for_view_item(&mut self,\n                                              view_item: &view_item,\n-                                             (parent, _):\n-                                             (ReducedGraphParent,\n-                                              &mut BuildReducedGraphVisitor)) {\n+                                             parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(view_item.vis);\n         match view_item.node {\n             view_item_use(ref view_paths) => {\n@@ -1594,11 +1585,11 @@ impl Resolver {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    pub fn build_reduced_graph_for_foreign_item(@mut self,\n+    pub fn build_reduced_graph_for_foreign_item(&mut self,\n                                                 foreign_item: @foreign_item,\n-                                                (parent, visitor):\n-                                                (ReducedGraphParent,\n-                                                 &mut BuildReducedGraphVisitor)) {\n+                                                parent: ReducedGraphParent,\n+                                                f: &fn(&mut Resolver,\n+                                                       ReducedGraphParent)) {\n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n             self.add_child(name, parent, ForbidDuplicateValues,\n@@ -1611,26 +1602,25 @@ impl Resolver {\n \n                 do self.with_type_parameter_rib(\n                     HasTypeParameters(\n-                        generics, foreign_item.id, 0, NormalRibKind))\n+                        generics, foreign_item.id, 0, NormalRibKind)) |this|\n                 {\n-                    visit::walk_foreign_item(visitor, foreign_item, new_parent);\n+                    f(this, new_parent)\n                 }\n             }\n             foreign_item_static(_, m) => {\n                 let def = DefStatic(local_def(foreign_item.id), m);\n                 name_bindings.define_value(Public, def, foreign_item.span);\n \n-                visit::walk_foreign_item(visitor, foreign_item, new_parent);\n+                f(self, new_parent)\n             }\n         }\n     }\n \n-    pub fn build_reduced_graph_for_block(@mut self,\n+    pub fn build_reduced_graph_for_block(&mut self,\n                                          block: &Block,\n-                                         (parent, visitor):\n-                                         (ReducedGraphParent,\n-                                          &mut BuildReducedGraphVisitor)) {\n-        let new_parent;\n+                                         parent: ReducedGraphParent)\n+                                            -> ReducedGraphParent\n+    {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n@@ -1645,15 +1635,13 @@ impl Resolver {\n                 AnonymousModuleKind,\n                 false);\n             parent_module.anonymous_children.insert(block_id, new_module);\n-            new_parent = ModuleReducedGraphParent(new_module);\n+            ModuleReducedGraphParent(new_module)\n         } else {\n-            new_parent = parent;\n+            parent\n         }\n-\n-        visit::walk_block(visitor, block, new_parent);\n     }\n \n-    fn handle_external_def(@mut self,\n+    fn handle_external_def(&mut self,\n                            def: Def,\n                            visibility: ast::visibility,\n                            child_name_bindings: @mut NameBindings,\n@@ -1788,7 +1776,7 @@ impl Resolver {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(@mut self,\n+    fn build_reduced_graph_for_external_crate_def(&mut self,\n                                                   root: @mut Module,\n                                                   def_like: DefLike,\n                                                   ident: Ident,\n@@ -1924,7 +1912,7 @@ impl Resolver {\n     }\n \n     /// Builds the reduced graph rooted at the given external module.\n-    fn populate_external_module(@mut self, module: @mut Module) {\n+    fn populate_external_module(&mut self, module: @mut Module) {\n         debug!(\"(populating external module) attempting to populate %s\",\n                self.module_to_str(module));\n \n@@ -1950,7 +1938,7 @@ impl Resolver {\n \n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n-    fn populate_module_if_necessary(@mut self, module: @mut Module) {\n+    fn populate_module_if_necessary(&mut self, module: @mut Module) {\n         if !module.populated {\n             self.populate_external_module(module)\n         }\n@@ -1959,7 +1947,7 @@ impl Resolver {\n \n     /// Builds the reduced graph rooted at the 'use' directive for an external\n     /// crate.\n-    pub fn build_reduced_graph_for_external_crate(@mut self,\n+    pub fn build_reduced_graph_for_external_crate(&mut self,\n                                                   root: @mut Module) {\n         do csearch::each_top_level_item_of_crate(self.session.cstore,\n                                                  root.def_id.unwrap().crate)\n@@ -1972,7 +1960,7 @@ impl Resolver {\n     }\n \n     /// Creates and adds an import directive to the given module.\n-    pub fn build_import_directive(@mut self,\n+    pub fn build_import_directive(&mut self,\n                                   privacy: Privacy,\n                                   module_: @mut Module,\n                                   module_path: ~[Ident],\n@@ -2034,7 +2022,7 @@ impl Resolver {\n \n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n-    pub fn resolve_imports(@mut self) {\n+    pub fn resolve_imports(&mut self) {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n@@ -2061,7 +2049,7 @@ impl Resolver {\n \n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n-    pub fn resolve_imports_for_module_subtree(@mut self,\n+    pub fn resolve_imports_for_module_subtree(&mut self,\n                                               module_: @mut Module) {\n         debug!(\"(resolving imports for module subtree) resolving %s\",\n                self.module_to_str(module_));\n@@ -2085,7 +2073,7 @@ impl Resolver {\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    pub fn resolve_imports_for_module(@mut self, module: @mut Module) {\n+    pub fn resolve_imports_for_module(&mut self, module: @mut Module) {\n         if module.all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for \\\n                    %s\",\n@@ -2120,7 +2108,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn idents_to_str(@mut self, idents: &[Ident]) -> ~str {\n+    pub fn idents_to_str(&mut self, idents: &[Ident]) -> ~str {\n         let mut first = true;\n         let mut result = ~\"\";\n         for ident in idents.iter() {\n@@ -2134,15 +2122,15 @@ impl Resolver {\n         return result;\n     }\n \n-    fn path_idents_to_str(@mut self, path: &Path) -> ~str {\n+    fn path_idents_to_str(&mut self, path: &Path) -> ~str {\n         let identifiers: ~[ast::Ident] = path.segments\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n                                              .collect();\n         self.idents_to_str(identifiers)\n     }\n \n-    pub fn import_directive_subclass_to_str(@mut self,\n+    pub fn import_directive_subclass_to_str(&mut self,\n                                             subclass: ImportDirectiveSubclass)\n                                             -> @str {\n         match subclass {\n@@ -2151,7 +2139,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn import_path_to_str(@mut self,\n+    pub fn import_path_to_str(&mut self,\n                               idents: &[Ident],\n                               subclass: ImportDirectiveSubclass)\n                               -> @str {\n@@ -2169,7 +2157,7 @@ impl Resolver {\n     /// don't know whether the name exists at the moment due to other\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n-    pub fn resolve_import_for_module(@mut self,\n+    pub fn resolve_import_for_module(&mut self,\n                                      module_: @mut Module,\n                                      import_directive: @ImportDirective)\n                                      -> ResolveResult<()> {\n@@ -2272,7 +2260,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_single_import(@mut self,\n+    pub fn resolve_single_import(&mut self,\n                                  module_: @mut Module,\n                                  containing_module: @mut Module,\n                                  target: Ident,\n@@ -2346,7 +2334,7 @@ impl Resolver {\n                             if import_resolution.outstanding_references\n                                 == 0 => {\n \n-                        fn get_binding(this: @mut Resolver,\n+                        fn get_binding(this: &mut Resolver,\n                                        import_resolution:\n                                           @mut ImportResolution,\n                                        namespace: Namespace)\n@@ -2485,14 +2473,16 @@ impl Resolver {\n \n         let span = directive.span;\n         if resolve_fail {\n-            self.resolve_error(span, fmt!(\"unresolved import: there is no `%s` in `%s`\",\n-                                             self.session.str_of(source),\n-                                             self.module_to_str(containing_module)));\n+            let msg = fmt!(\"unresolved import: there is no `%s` in `%s`\",\n+                           self.session.str_of(source),\n+                           self.module_to_str(containing_module));\n+            self.resolve_error(span, msg);\n             return Failed;\n         } else if priv_fail {\n-            self.resolve_error(span, fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n-                                             private\", self.session.str_of(source),\n-                                             self.module_to_str(containing_module)));\n+            let msg = fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n+                           private\", self.session.str_of(source),\n+                           self.module_to_str(containing_module));\n+            self.resolve_error(span, msg);\n             return Failed;\n         }\n \n@@ -2526,7 +2516,7 @@ impl Resolver {\n     // Resolves a glob import. Note that this function cannot fail; it either\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid).\n-    pub fn resolve_glob_import(@mut self,\n+    pub fn resolve_glob_import(&mut self,\n                                privacy: Privacy,\n                                module_: @mut Module,\n                                containing_module: @mut Module,\n@@ -2659,7 +2649,7 @@ impl Resolver {\n     }\n \n     /// Resolves the given module path from the given root `module_`.\n-    pub fn resolve_module_path_from_root(@mut self,\n+    pub fn resolve_module_path_from_root(&mut self,\n                                          module_: @mut Module,\n                                          module_path: &[Ident],\n                                          index: uint,\n@@ -2768,7 +2758,7 @@ impl Resolver {\n \n     /// Attempts to resolve the module part of an import directive or path\n     /// rooted at the given module.\n-    pub fn resolve_module_path(@mut self,\n+    pub fn resolve_module_path(&mut self,\n                                module_: @mut Module,\n                                module_path: &[Ident],\n                                use_lexical_scope: UseLexicalScopeFlag,\n@@ -2861,7 +2851,7 @@ impl Resolver {\n \n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n-    pub fn resolve_item_in_lexical_scope(@mut self,\n+    pub fn resolve_item_in_lexical_scope(&mut self,\n                                          module_: @mut Module,\n                                          name: Ident,\n                                          namespace: Namespace,\n@@ -2990,7 +2980,7 @@ impl Resolver {\n     }\n \n     /// Resolves a module name in the current lexical scope.\n-    pub fn resolve_module_in_lexical_scope(@mut self,\n+    pub fn resolve_module_in_lexical_scope(&mut self,\n                                            module_: @mut Module,\n                                            name: Ident)\n                                            -> ResolveResult<@mut Module> {\n@@ -3036,7 +3026,7 @@ impl Resolver {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    pub fn get_nearest_normal_module_parent(@mut self, module_: @mut Module)\n+    pub fn get_nearest_normal_module_parent(&mut self, module_: @mut Module)\n                                             -> Option<@mut Module> {\n         let mut module_ = module_;\n         loop {\n@@ -3058,7 +3048,7 @@ impl Resolver {\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    pub fn get_nearest_normal_module_parent_or_self(@mut self,\n+    pub fn get_nearest_normal_module_parent_or_self(&mut self,\n                                                     module_: @mut Module)\n                                                     -> @mut Module {\n         match module_.kind {\n@@ -3078,7 +3068,7 @@ impl Resolver {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    pub fn resolve_module_prefix(@mut self,\n+    pub fn resolve_module_prefix(&mut self,\n                                  module_: @mut Module,\n                                  module_path: &[Ident])\n                                  -> ResolveResult<ModulePrefixResult> {\n@@ -3121,7 +3111,7 @@ impl Resolver {\n     /// Attempts to resolve the supplied name in the given module for the\n     /// given namespace. If successful, returns the target corresponding to\n     /// the name.\n-    pub fn resolve_name_in_module(@mut self,\n+    pub fn resolve_name_in_module(&mut self,\n                                   module_: @mut Module,\n                                   name: Ident,\n                                   namespace: Namespace,\n@@ -3206,7 +3196,7 @@ impl Resolver {\n         return Failed;\n     }\n \n-    pub fn report_unresolved_imports(@mut self, module_: @mut Module) {\n+    pub fn report_unresolved_imports(&mut self, module_: @mut Module) {\n         let index = module_.resolved_import_count;\n         let imports: &mut ~[@ImportDirective] = &mut *module_.imports;\n         let import_count = imports.len();\n@@ -3248,12 +3238,12 @@ impl Resolver {\n     // Then this operation can simply be performed as part of item (or import)\n     // processing.\n \n-    pub fn record_exports(@mut self) {\n+    pub fn record_exports(&mut self) {\n         let root_module = self.graph_root.get_module();\n         self.record_exports_for_module_subtree(root_module);\n     }\n \n-    pub fn record_exports_for_module_subtree(@mut self,\n+    pub fn record_exports_for_module_subtree(&mut self,\n                                              module_: @mut Module) {\n         // If this isn't a local crate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n@@ -3299,7 +3289,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn record_exports_for_module(@mut self, module_: @mut Module) {\n+    pub fn record_exports_for_module(&mut self, module_: @mut Module) {\n         let mut exports2 = ~[];\n \n         self.add_exports_for_module(&mut exports2, module_);\n@@ -3313,7 +3303,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn add_exports_of_namebindings(@mut self,\n+    pub fn add_exports_of_namebindings(&mut self,\n                                        exports2: &mut ~[Export2],\n                                        name: Name,\n                                        namebindings: @mut NameBindings,\n@@ -3341,7 +3331,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn add_exports_for_module(@mut self,\n+    pub fn add_exports_for_module(&mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n         for (name, importresolution) in module_.import_resolutions.iter() {\n@@ -3386,7 +3376,7 @@ impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    pub fn with_scope(@mut self, name: Option<Ident>, f: &fn()) {\n+    pub fn with_scope(&mut self, name: Option<Ident>, f: &fn(&mut Resolver)) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3419,14 +3409,14 @@ impl Resolver {\n             }\n         }\n \n-        f();\n+        f(self);\n \n         self.current_module = orig_module;\n     }\n \n     /// Wraps the given definition in the appropriate number of `def_upvar`\n     /// wrappers.\n-    pub fn upvarify(@mut self,\n+    pub fn upvarify(&mut self,\n                     ribs: &mut ~[@Rib],\n                     rib_index: uint,\n                     def_like: DefLike,\n@@ -3538,7 +3528,7 @@ impl Resolver {\n         return Some(DlDef(def));\n     }\n \n-    pub fn search_ribs(@mut self,\n+    pub fn search_ribs(&mut self,\n                        ribs: &mut ~[@Rib],\n                        name: Name,\n                        span: Span,\n@@ -3564,14 +3554,13 @@ impl Resolver {\n         return None;\n     }\n \n-    pub fn resolve_crate(@mut self) {\n+    pub fn resolve_crate(&mut self) {\n         debug!(\"(resolving crate) starting\");\n \n-        let mut visitor = ResolveVisitor{ resolver: self };\n-        visit::walk_crate(&mut visitor, self.crate, ());\n+        visit::walk_crate(self, self.crate, ());\n     }\n \n-    pub fn resolve_item(@mut self, item: @item, visitor: &mut ResolveVisitor) {\n+    pub fn resolve_item(&mut self, item: @item) {\n         debug!(\"(resolving item) resolving %s\",\n                self.session.str_of(item.ident));\n \n@@ -3591,8 +3580,8 @@ impl Resolver {\n                     for dis_expr in variant.node.disr_expr.iter() {\n                         // resolve the discriminator expr\n                         // as a constant\n-                        self.with_constant_rib(|| {\n-                            self.resolve_expr(*dis_expr, visitor);\n+                        self.with_constant_rib(|this| {\n+                            this.resolve_expr(*dis_expr);\n                         });\n                     }\n                 }\n@@ -3602,18 +3591,17 @@ impl Resolver {\n                 // error if there is one? -- tjc\n                 do self.with_type_parameter_rib(\n                     HasTypeParameters(\n-                        generics, item.id, 0, NormalRibKind)) {\n-                    visit::walk_item(visitor, item, ());\n+                        generics, item.id, 0, NormalRibKind)) |this| {\n+                    visit::walk_item(this, item, ());\n                 }\n             }\n \n             item_ty(_, ref generics) => {\n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(generics, item.id, 0,\n                                            NormalRibKind))\n-                        || {\n-\n-                    visit::walk_item(visitor, item, ());\n+                        |this| {\n+                    visit::walk_item(this, item, ());\n                 }\n             }\n \n@@ -3625,8 +3613,7 @@ impl Resolver {\n                                             generics,\n                                             implemented_traits,\n                                             self_type,\n-                                            *methods,\n-                                            visitor);\n+                                            *methods);\n             }\n \n             item_trait(ref generics, ref traits, ref methods) => {\n@@ -3641,14 +3628,13 @@ impl Resolver {\n                 // Create a new rib for the trait-wide type parameters.\n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(generics, item.id, 0,\n-                                           NormalRibKind)) {\n+                                           NormalRibKind)) |this| {\n \n-                    self.resolve_type_parameters(&generics.ty_params,\n-                                                 visitor);\n+                    this.resolve_type_parameters(&generics.ty_params);\n \n                     // Resolve derived traits.\n                     for trt in traits.iter() {\n-                        self.resolve_trait_reference(item.id, trt, visitor, TraitDerivation);\n+                        this.resolve_trait_reference(item.id, trt, TraitDerivation);\n                     }\n \n                     for method in (*methods).iter() {\n@@ -3659,31 +3645,29 @@ impl Resolver {\n \n                         match *method {\n                           required(ref ty_m) => {\n-                            do self.with_type_parameter_rib\n+                            do this.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.generics,\n                                                    item.id,\n                                                    generics.ty_params.len(),\n-                                        MethodRibKind(item.id, Required))) {\n+                                        MethodRibKind(item.id, Required))) |this| {\n \n                                 // Resolve the method-specific type\n                                 // parameters.\n-                                self.resolve_type_parameters(\n-                                    &ty_m.generics.ty_params,\n-                                    visitor);\n+                                this.resolve_type_parameters(\n+                                    &ty_m.generics.ty_params);\n \n                                 for argument in ty_m.decl.inputs.iter() {\n-                                    self.resolve_type(&argument.ty, visitor);\n+                                    this.resolve_type(&argument.ty);\n                                 }\n \n-                                self.resolve_type(&ty_m.decl.output, visitor);\n+                                this.resolve_type(&ty_m.decl.output);\n                             }\n                           }\n                           provided(m) => {\n-                              self.resolve_method(MethodRibKind(item.id,\n+                              this.resolve_method(MethodRibKind(item.id,\n                                                      Provided(m.id)),\n                                                   m,\n-                                                  generics.ty_params.len(),\n-                                                  visitor)\n+                                                  generics.ty_params.len())\n                           }\n                         }\n                     }\n@@ -3695,32 +3679,31 @@ impl Resolver {\n             item_struct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields,\n-                                    visitor);\n+                                    struct_def.fields);\n             }\n \n             item_mod(ref module_) => {\n-                do self.with_scope(Some(item.ident)) {\n-                    self.resolve_module(module_, item.span, item.ident,\n-                                        item.id, visitor);\n+                do self.with_scope(Some(item.ident)) |this| {\n+                    this.resolve_module(module_, item.span, item.ident,\n+                                        item.id);\n                 }\n             }\n \n             item_foreign_mod(ref foreign_module) => {\n-                do self.with_scope(Some(item.ident)) {\n+                do self.with_scope(Some(item.ident)) |this| {\n                     for foreign_item in foreign_module.items.iter() {\n                         match foreign_item.node {\n                             foreign_item_fn(_, ref generics) => {\n-                                self.with_type_parameter_rib(\n+                                this.with_type_parameter_rib(\n                                     HasTypeParameters(\n                                         generics, foreign_item.id, 0,\n                                         NormalRibKind),\n-                                    || visit::walk_foreign_item(visitor,\n+                                    |this| visit::walk_foreign_item(this,\n                                                                 *foreign_item,\n                                                                 ()));\n                             }\n                             foreign_item_static(*) => {\n-                                visit::walk_foreign_item(visitor,\n+                                visit::walk_foreign_item(this,\n                                                          *foreign_item,\n                                                          ());\n                             }\n@@ -3738,13 +3721,12 @@ impl Resolver {\n                                          0,\n                                          OpaqueFunctionRibKind),\n                                       block,\n-                                      NoSelfBinding,\n-                                      visitor);\n+                                      NoSelfBinding);\n             }\n \n             item_static(*) => {\n-                self.with_constant_rib(|| {\n-                    visit::walk_item(visitor, item, ());\n+                self.with_constant_rib(|this| {\n+                    visit::walk_item(this, item, ());\n                 });\n             }\n \n@@ -3756,9 +3738,9 @@ impl Resolver {\n         self.xray_context = orig_xray_flag;\n     }\n \n-    pub fn with_type_parameter_rib(@mut self,\n+    pub fn with_type_parameter_rib(&mut self,\n                                    type_parameters: TypeParameters,\n-                                   f: &fn()) {\n+                                   f: &fn(&mut Resolver)) {\n         match type_parameters {\n             HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n@@ -3787,7 +3769,7 @@ impl Resolver {\n             }\n         }\n \n-        f();\n+        f(self);\n \n         match type_parameters {\n             HasTypeParameters(*) => {\n@@ -3800,25 +3782,24 @@ impl Resolver {\n         }\n     }\n \n-    pub fn with_label_rib(@mut self, f: &fn()) {\n+    pub fn with_label_rib(&mut self, f: &fn(&mut Resolver)) {\n         self.label_ribs.push(@Rib::new(NormalRibKind));\n-        f();\n+        f(self);\n         self.label_ribs.pop();\n     }\n \n-    pub fn with_constant_rib(@mut self, f: &fn()) {\n+    pub fn with_constant_rib(&mut self, f: &fn(&mut Resolver)) {\n         self.value_ribs.push(@Rib::new(ConstantItemRibKind));\n-        f();\n+        f(self);\n         self.value_ribs.pop();\n     }\n \n-    pub fn resolve_function(@mut self,\n+    pub fn resolve_function(&mut self,\n                             rib_kind: RibKind,\n                             optional_declaration: Option<&fn_decl>,\n                             type_parameters: TypeParameters,\n                             block: &Block,\n-                            self_binding: SelfBinding,\n-                            visitor: &mut ResolveVisitor) {\n+                            self_binding: SelfBinding) {\n         // Create a value rib for the function.\n         let function_value_rib = @Rib::new(rib_kind);\n         self.value_ribs.push(function_value_rib);\n@@ -3828,15 +3809,14 @@ impl Resolver {\n         self.label_ribs.push(function_label_rib);\n \n         // If this function has type parameters, add them now.\n-        do self.with_type_parameter_rib(type_parameters) {\n+        do self.with_type_parameter_rib(type_parameters) |this| {\n             // Resolve the type parameters.\n             match type_parameters {\n                 NoTypeParameters => {\n                     // Continue.\n                 }\n                 HasTypeParameters(ref generics, _, _, _) => {\n-                    self.resolve_type_parameters(&generics.ty_params,\n-                                                 visitor);\n+                    this.resolve_type_parameters(&generics.ty_params);\n                 }\n             }\n \n@@ -3861,23 +3841,22 @@ impl Resolver {\n                         let binding_mode = ArgumentIrrefutableMode;\n                         let mutability =\n                             if argument.is_mutbl {Mutable} else {Immutable};\n-                        self.resolve_pattern(argument.pat,\n+                        this.resolve_pattern(argument.pat,\n                                              binding_mode,\n                                              mutability,\n-                                             None,\n-                                             visitor);\n+                                             None);\n \n-                        self.resolve_type(&argument.ty, visitor);\n+                        this.resolve_type(&argument.ty);\n \n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    self.resolve_type(&declaration.output, visitor);\n+                    this.resolve_type(&declaration.output);\n                 }\n             }\n \n             // Resolve the function body.\n-            self.resolve_block(block, visitor);\n+            this.resolve_block(block);\n \n             debug!(\"(resolving function) leaving function\");\n         }\n@@ -3886,34 +3865,31 @@ impl Resolver {\n         self.value_ribs.pop();\n     }\n \n-    pub fn resolve_type_parameters(@mut self,\n-                                   type_parameters: &OptVec<TyParam>,\n-                                   visitor: &mut ResolveVisitor) {\n+    pub fn resolve_type_parameters(&mut self,\n+                                   type_parameters: &OptVec<TyParam>) {\n         for type_parameter in type_parameters.iter() {\n             for bound in type_parameter.bounds.iter() {\n-                self.resolve_type_parameter_bound(type_parameter.id, bound, visitor);\n+                self.resolve_type_parameter_bound(type_parameter.id, bound);\n             }\n         }\n     }\n \n-    pub fn resolve_type_parameter_bound(@mut self,\n+    pub fn resolve_type_parameter_bound(&mut self,\n                                         id: NodeId,\n-                                        type_parameter_bound: &TyParamBound,\n-                                        visitor: &mut ResolveVisitor) {\n+                                        type_parameter_bound: &TyParamBound) {\n         match *type_parameter_bound {\n             TraitTyParamBound(ref tref) => {\n-                self.resolve_trait_reference(id, tref, visitor, TraitBoundingTypeParameter)\n+                self.resolve_trait_reference(id, tref, TraitBoundingTypeParameter)\n             }\n             RegionTyParamBound => {}\n         }\n     }\n \n-    pub fn resolve_trait_reference(@mut self,\n+    pub fn resolve_trait_reference(&mut self,\n                                    id: NodeId,\n                                    trait_reference: &trait_ref,\n-                                   visitor: &mut ResolveVisitor,\n                                    reference_type: TraitReferenceType) {\n-        match self.resolve_path(id, &trait_reference.path, TypeNS, true, visitor) {\n+        match self.resolve_path(id, &trait_reference.path, TypeNS, true) {\n             None => {\n                 let path_str = self.path_idents_to_str(&trait_reference.path);\n                 let usage_str = match reference_type {\n@@ -3932,11 +3908,10 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_struct(@mut self,\n+    pub fn resolve_struct(&mut self,\n                           id: NodeId,\n                           generics: &Generics,\n-                          fields: &[@struct_field],\n-                          visitor: &mut ResolveVisitor) {\n+                          fields: &[@struct_field]) {\n         let mut ident_map: HashMap<ast::Ident,@struct_field> = HashMap::new();\n         for &field in fields.iter() {\n             match field.node.kind {\n@@ -3961,25 +3936,24 @@ impl Resolver {\n         // If applicable, create a rib for the type parameters.\n         do self.with_type_parameter_rib(HasTypeParameters\n                                         (generics, id, 0,\n-                                         OpaqueFunctionRibKind)) {\n+                                         OpaqueFunctionRibKind)) |this| {\n \n             // Resolve the type parameters.\n-            self.resolve_type_parameters(&generics.ty_params, visitor);\n+            this.resolve_type_parameters(&generics.ty_params);\n \n             // Resolve fields.\n             for field in fields.iter() {\n-                self.resolve_type(&field.node.ty, visitor);\n+                this.resolve_type(&field.node.ty);\n             }\n         }\n     }\n \n     // Does this really need to take a RibKind or is it always going\n     // to be NormalRibKind?\n-    pub fn resolve_method(@mut self,\n+    pub fn resolve_method(&mut self,\n                           rib_kind: RibKind,\n                           method: @method,\n-                          outer_type_parameter_count: uint,\n-                          visitor: &mut ResolveVisitor) {\n+                          outer_type_parameter_count: uint) {\n         let method_generics = &method.generics;\n         let type_parameters =\n             HasTypeParameters(method_generics,\n@@ -3996,43 +3970,40 @@ impl Resolver {\n                               Some(&method.decl),\n                               type_parameters,\n                               &method.body,\n-                              self_binding,\n-                              visitor);\n+                              self_binding);\n     }\n \n-    pub fn resolve_implementation(@mut self,\n+    pub fn resolve_implementation(&mut self,\n                                   id: NodeId,\n                                   generics: &Generics,\n                                   opt_trait_reference: &Option<trait_ref>,\n                                   self_type: &Ty,\n-                                  methods: &[@method],\n-                                  visitor: &mut ResolveVisitor) {\n+                                  methods: &[@method]) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = generics.ty_params.len();\n         do self.with_type_parameter_rib(HasTypeParameters\n                                         (generics, id, 0,\n-                                         NormalRibKind)) {\n+                                         NormalRibKind)) |this| {\n             // Resolve the type parameters.\n-            self.resolve_type_parameters(&generics.ty_params,\n-                                         visitor);\n+            this.resolve_type_parameters(&generics.ty_params);\n \n             // Resolve the trait reference, if necessary.\n             let original_trait_refs;\n             match opt_trait_reference {\n                 &Some(ref trait_reference) => {\n-                    self.resolve_trait_reference(id, trait_reference, visitor,\n+                    this.resolve_trait_reference(id, trait_reference,\n                         TraitImplementation);\n \n                     // Record the current set of trait references.\n                     let mut new_trait_refs = ~[];\n                     {\n-                        let r = self.def_map.find(&trait_reference.ref_id);\n+                        let r = this.def_map.find(&trait_reference.ref_id);\n                         for &def in r.iter() {\n                             new_trait_refs.push(def_id_of_def(*def));\n                         }\n                     }\n                     original_trait_refs = Some(util::replace(\n-                        &mut self.current_trait_refs,\n+                        &mut this.current_trait_refs,\n                         Some(new_trait_refs)));\n                 }\n                 &None => {\n@@ -4041,17 +4012,16 @@ impl Resolver {\n             }\n \n             // Resolve the self type.\n-            self.resolve_type(self_type, visitor);\n+            this.resolve_type(self_type);\n \n             for method in methods.iter() {\n                 // We also need a new scope for the method-specific\n                 // type parameters.\n-                self.resolve_method(MethodRibKind(\n+                this.resolve_method(MethodRibKind(\n                     id,\n                     Provided(method.id)),\n                     *method,\n-                    outer_type_parameter_count,\n-                    visitor);\n+                    outer_type_parameter_count);\n /*\n                     let borrowed_type_parameters = &method.tps;\n                     self.resolve_function(MethodRibKind(\n@@ -4071,49 +4041,47 @@ impl Resolver {\n \n             // Restore the original trait references.\n             match original_trait_refs {\n-                Some(r) => { self.current_trait_refs = r; }\n+                Some(r) => { this.current_trait_refs = r; }\n                 None => ()\n             }\n         }\n     }\n \n-    pub fn resolve_module(@mut self,\n+    pub fn resolve_module(&mut self,\n                           module_: &_mod,\n                           _span: Span,\n                           _name: Ident,\n-                          id: NodeId,\n-                          visitor: &mut ResolveVisitor) {\n+                          id: NodeId) {\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID %d\", id);\n-        visit::walk_mod(visitor, module_, ());\n+        visit::walk_mod(self, module_, ());\n     }\n \n-    pub fn resolve_local(@mut self, local: @Local, visitor: &mut ResolveVisitor) {\n+    pub fn resolve_local(&mut self, local: @Local) {\n         let mutability = if local.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n-        self.resolve_type(&local.ty, visitor);\n+        self.resolve_type(&local.ty);\n \n         // Resolve the initializer, if necessary.\n         match local.init {\n             None => {\n                 // Nothing to do.\n             }\n             Some(initializer) => {\n-                self.resolve_expr(initializer, visitor);\n+                self.resolve_expr(initializer);\n             }\n         }\n \n         // Resolve the pattern.\n-        self.resolve_pattern(local.pat, LocalIrrefutableMode, mutability,\n-                             None, visitor);\n+        self.resolve_pattern(local.pat, LocalIrrefutableMode, mutability, None);\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n     // this is done hygienically. This could arise for a macro\n     // that expands into an or-pattern where one 'x' was from the\n     // user and one 'x' came from the macro.\n-    pub fn binding_mode_map(@mut self, pat: @Pat) -> BindingMap {\n+    pub fn binding_mode_map(&mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n         do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n             let name = mtwt_resolve(path_to_ident(path));\n@@ -4126,7 +4094,7 @@ impl Resolver {\n \n     // check that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n-    pub fn check_consistent_bindings(@mut self, arm: &Arm) {\n+    pub fn check_consistent_bindings(&mut self, arm: &Arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n         for (i, p) in arm.pats.iter().enumerate() {\n@@ -4165,26 +4133,26 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_arm(@mut self, arm: &Arm, visitor: &mut ResolveVisitor) {\n+    pub fn resolve_arm(&mut self, arm: &Arm) {\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n         let bindings_list = @mut HashMap::new();\n         for pattern in arm.pats.iter() {\n             self.resolve_pattern(*pattern, RefutableMode, Immutable,\n-                                 Some(bindings_list), visitor);\n+                                 Some(bindings_list));\n         }\n \n         // This has to happen *after* we determine which\n         // pat_idents are variants\n         self.check_consistent_bindings(arm);\n \n-        visit::walk_expr_opt(visitor, arm.guard, ());\n-        self.resolve_block(&arm.body, visitor);\n+        visit::walk_expr_opt(self, arm.guard, ());\n+        self.resolve_block(&arm.body);\n \n         self.value_ribs.pop();\n     }\n \n-    pub fn resolve_block(@mut self, block: &Block, visitor: &mut ResolveVisitor) {\n+    pub fn resolve_block(&mut self, block: &Block) {\n         debug!(\"(resolving block) entering block\");\n         self.value_ribs.push(@Rib::new(NormalRibKind));\n \n@@ -4200,7 +4168,7 @@ impl Resolver {\n         }\n \n         // Descend into the block.\n-        visit::walk_block(visitor, block, ());\n+        visit::walk_block(self, block, ());\n \n         // Move back up.\n         self.current_module = orig_module;\n@@ -4209,7 +4177,7 @@ impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    pub fn resolve_type(@mut self, ty: &Ty, visitor: &mut ResolveVisitor) {\n+    pub fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n@@ -4258,8 +4226,7 @@ impl Resolver {\n                         match self.resolve_path(ty.id,\n                                                 path,\n                                                 TypeNS,\n-                                                true,\n-                                                visitor) {\n+                                                true) {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n@@ -4287,44 +4254,42 @@ impl Resolver {\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n-                        self.resolve_error\n-                            (ty.span,\n-                             fmt!(\"use of undeclared type name `%s`\",\n-                                  self.path_idents_to_str(path)))\n+                        let msg = fmt!(\"use of undeclared type name `%s`\",\n+                                       self.path_idents_to_str(path));\n+                        self.resolve_error(ty.span, msg);\n                     }\n                 }\n \n                 do bounds.map |bound_vec| {\n                     for bound in bound_vec.iter() {\n-                        self.resolve_type_parameter_bound(ty.id, bound, visitor);\n+                        self.resolve_type_parameter_bound(ty.id, bound);\n                     }\n                 };\n             }\n \n             ty_closure(c) => {\n                 do c.bounds.map |bounds| {\n                     for bound in bounds.iter() {\n-                        self.resolve_type_parameter_bound(ty.id, bound, visitor);\n+                        self.resolve_type_parameter_bound(ty.id, bound);\n                     }\n                 };\n-                visit::walk_ty(visitor, ty, ());\n+                visit::walk_ty(self, ty, ());\n             }\n \n             _ => {\n                 // Just resolve embedded types.\n-                visit::walk_ty(visitor, ty, ());\n+                visit::walk_ty(self, ty, ());\n             }\n         }\n     }\n \n-    pub fn resolve_pattern(@mut self,\n+    pub fn resolve_pattern(&mut self,\n                            pattern: @Pat,\n                            mode: PatternBindingMode,\n                            mutability: Mutability,\n                            // Maps idents to the node ID for the (outermost)\n                            // pattern that binds them\n-                           bindings_list: Option<@mut HashMap<Name,NodeId>>,\n-                           visitor: &mut ResolveVisitor) {\n+                           bindings_list: Option<@mut HashMap<Name,NodeId>>) {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n             match pattern.node {\n@@ -4453,13 +4418,13 @@ impl Resolver {\n                     for ty in path.segments\n                                   .iter()\n                                   .flat_map(|seg| seg.types.iter()) {\n-                        self.resolve_type(ty, visitor);\n+                        self.resolve_type(ty);\n                     }\n                 }\n \n                 PatIdent(binding_mode, ref path, _) => {\n                     // This must be an enum variant, struct, or constant.\n-                    match self.resolve_path(pat_id, path, ValueNS, false, visitor) {\n+                    match self.resolve_path(pat_id, path, ValueNS, false) {\n                         Some(def @ DefVariant(*)) |\n                                 Some(def @ DefStruct(*)) => {\n                             self.record_def(pattern.id, def);\n@@ -4488,13 +4453,13 @@ impl Resolver {\n                     for ty in path.segments\n                                   .iter()\n                                   .flat_map(|s| s.types.iter()) {\n-                        self.resolve_type(ty, visitor);\n+                        self.resolve_type(ty);\n                     }\n                 }\n \n                 PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n-                    match self.resolve_path(pat_id, path, ValueNS, false, visitor) {\n+                    match self.resolve_path(pat_id, path, ValueNS, false) {\n                         Some(def @ DefFn(*))      |\n                         Some(def @ DefVariant(*)) |\n                         Some(def @ DefStruct(*))  |\n@@ -4525,21 +4490,21 @@ impl Resolver {\n                     for ty in path.segments\n                                   .iter()\n                                   .flat_map(|s| s.types.iter()) {\n-                        self.resolve_type(ty, visitor);\n+                        self.resolve_type(ty);\n                     }\n                 }\n \n                 PatLit(expr) => {\n-                    self.resolve_expr(expr, visitor);\n+                    self.resolve_expr(expr);\n                 }\n \n                 PatRange(first_expr, last_expr) => {\n-                    self.resolve_expr(first_expr, visitor);\n-                    self.resolve_expr(last_expr, visitor);\n+                    self.resolve_expr(first_expr);\n+                    self.resolve_expr(last_expr);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n-                    match self.resolve_path(pat_id, path, TypeNS, false, visitor) {\n+                    match self.resolve_path(pat_id, path, TypeNS, false) {\n                         Some(DefTy(class_id))\n                                 if self.structs.contains(&class_id) => {\n                             let class_def = DefStruct(class_id);\n@@ -4556,10 +4521,9 @@ impl Resolver {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: %?\", result);\n-                            self.resolve_error(\n-                                path.span,\n-                                fmt!(\"`%s` does not name a structure\",\n-                                     self.path_idents_to_str(path)));\n+                            let msg = fmt!(\"`%s` does not name a structure\",\n+                                           self.path_idents_to_str(path));\n+                            self.resolve_error(path.span, msg);\n                         }\n                     }\n                 }\n@@ -4572,7 +4536,7 @@ impl Resolver {\n         };\n     }\n \n-    pub fn resolve_bare_identifier_pattern(@mut self, name: Ident)\n+    pub fn resolve_bare_identifier_pattern(&mut self, name: Ident)\n                                            ->\n                                            BareIdentifierPatternResolution {\n         match self.resolve_item_in_lexical_scope(self.current_module,\n@@ -4613,16 +4577,15 @@ impl Resolver {\n \n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n-    pub fn resolve_path(@mut self,\n+    pub fn resolve_path(&mut self,\n                         id: NodeId,\n                         path: &Path,\n                         namespace: Namespace,\n-                        check_ribs: bool,\n-                        visitor: &mut ResolveVisitor)\n+                        check_ribs: bool)\n                         -> Option<Def> {\n         // First, resolve the types.\n         for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n-            self.resolve_type(ty, visitor);\n+            self.resolve_type(ty);\n         }\n \n         if path.global {\n@@ -4659,7 +4622,7 @@ impl Resolver {\n     }\n \n     // resolve a single identifier (used as a varref)\n-    pub fn resolve_identifier(@mut self,\n+    pub fn resolve_identifier(&mut self,\n                               identifier: Ident,\n                               namespace: Namespace,\n                               check_ribs: bool,\n@@ -4683,7 +4646,7 @@ impl Resolver {\n     }\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n-    pub fn resolve_definition_of_name_in_module(@mut self,\n+    pub fn resolve_definition_of_name_in_module(&mut self,\n                                                 containing_module: @mut Module,\n                                                 name: Ident,\n                                                 namespace: Namespace,\n@@ -4759,7 +4722,7 @@ impl Resolver {\n     }\n \n     // resolve a \"module-relative\" path, e.g. a::b::c\n-    pub fn resolve_module_relative_path(@mut self,\n+    pub fn resolve_module_relative_path(&mut self,\n                                         path: &Path,\n                                         xray: XrayFlag,\n                                         namespace: Namespace)\n@@ -4773,10 +4736,9 @@ impl Resolver {\n                                        path.span,\n                                        PathPublicOnlySearch) {\n             Failed => {\n-                self.resolve_error(path.span,\n-                                      fmt!(\"use of undeclared module `%s`\",\n-                                           self.idents_to_str(\n-                                               module_path_idents)));\n+                let msg = fmt!(\"use of undeclared module `%s`\",\n+                               self.idents_to_str(module_path_idents));\n+                self.resolve_error(path.span, msg);\n                 return None;\n             }\n \n@@ -4825,7 +4787,7 @@ impl Resolver {\n \n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n-    pub fn resolve_crate_relative_path(@mut self,\n+    pub fn resolve_crate_relative_path(&mut self,\n                                        path: &Path,\n                                        xray: XrayFlag,\n                                        namespace: Namespace)\n@@ -4841,10 +4803,9 @@ impl Resolver {\n                                                  path.span,\n                                                  PathPublicOrPrivateSearch) {\n             Failed => {\n-                self.resolve_error(path.span,\n-                                      fmt!(\"use of undeclared module `::%s`\",\n-                                            self.idents_to_str(\n-                                              module_path_idents)));\n+                let msg = fmt!(\"use of undeclared module `::%s`\",\n+                               self.idents_to_str(module_path_idents));\n+                self.resolve_error(path.span, msg);\n                 return None;\n             }\n \n@@ -4872,7 +4833,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_identifier_in_local_ribs(@mut self,\n+    pub fn resolve_identifier_in_local_ribs(&mut self,\n                                             ident: Ident,\n                                             namespace: Namespace,\n                                             span: Span)\n@@ -4907,16 +4868,15 @@ impl Resolver {\n         }\n     }\n \n-    pub fn resolve_self_value_in_local_ribs(@mut self, span: Span)\n+    pub fn resolve_self_value_in_local_ribs(&mut self, span: Span)\n                                             -> Option<Def> {\n         // FIXME #4950: This should not use a while loop.\n-        let ribs = &mut self.value_ribs;\n-        let mut i = ribs.len();\n+        let mut i = self.value_ribs.len();\n         while i != 0 {\n             i -= 1;\n-            match *ribs[i].self_binding {\n+            match *self.value_ribs[i].self_binding {\n                 Some(def_like) => {\n-                    match self.upvarify(*ribs,\n+                    match self.upvarify(self.value_ribs,\n                                         i,\n                                         def_like,\n                                         span,\n@@ -4940,7 +4900,7 @@ impl Resolver {\n         None\n     }\n \n-    pub fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n+    pub fn resolve_item_by_identifier_in_lexical_scope(&mut self,\n                                                        ident: Ident,\n                                                        namespace: Namespace)\n                                                        -> Option<Def> {\n@@ -4973,20 +4933,20 @@ impl Resolver {\n         }\n     }\n \n-    fn with_no_errors<T>(@mut self, f: &fn() -> T) -> T {\n+    fn with_no_errors<T>(&mut self, f: &fn(&mut Resolver) -> T) -> T {\n         self.emit_errors = false;\n-        let rs = f();\n+        let rs = f(self);\n         self.emit_errors = true;\n         rs\n     }\n \n-    fn resolve_error(@mut self, span: Span, s: &str) {\n+    fn resolve_error(&mut self, span: Span, s: &str) {\n         if self.emit_errors {\n             self.session.span_err(span, s);\n         }\n     }\n \n-    pub fn find_best_match_for_name(@mut self,\n+    pub fn find_best_match_for_name(&mut self,\n                                     name: &str,\n                                     max_distance: uint)\n                                     -> Option<@str> {\n@@ -5026,7 +4986,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn name_exists_in_scope_struct(@mut self, name: &str) -> bool {\n+    pub fn name_exists_in_scope_struct(&mut self, name: &str) -> bool {\n         let this = &mut *self;\n \n         let mut i = this.type_ribs.len();\n@@ -5060,7 +5020,7 @@ impl Resolver {\n       return false;\n     }\n \n-    pub fn resolve_expr(@mut self, expr: @Expr, visitor: &mut ResolveVisitor) {\n+    pub fn resolve_expr(&mut self, expr: @Expr) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n@@ -5075,7 +5035,7 @@ impl Resolver {\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n \n-                match self.resolve_path(expr.id, path, ValueNS, true, visitor) {\n+                match self.resolve_path(expr.id, path, ValueNS, true) {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n@@ -5112,8 +5072,8 @@ impl Resolver {\n                             // (The pattern matching def_tys where the id is in self.structs\n                             // matches on regular structs while excluding tuple- and enum-like\n                             // structs, which wouldn't result in this error.)\n-                            match self.with_no_errors(||\n-                                self.resolve_path(expr.id, path, TypeNS, false, visitor)) {\n+                            match self.with_no_errors(|this|\n+                                this.resolve_path(expr.id, path, TypeNS, false)) {\n                                 Some(DefTy(struct_id))\n                                   if self.structs.contains(&struct_id) => {\n                                     self.resolve_error(expr.span,\n@@ -5145,21 +5105,20 @@ impl Resolver {\n                     }\n                 }\n \n-                visit::walk_expr(visitor, expr, ());\n+                visit::walk_expr(self, expr, ());\n             }\n \n             ExprFnBlock(ref fn_decl, ref block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n                                       Some(fn_decl),\n                                       NoTypeParameters,\n                                       block,\n-                                      NoSelfBinding,\n-                                      visitor);\n+                                      NoSelfBinding);\n             }\n \n             ExprStruct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n-                match self.resolve_path(expr.id, path, TypeNS, false, visitor) {\n+                match self.resolve_path(expr.id, path, TypeNS, false) {\n                     Some(DefTy(class_id)) | Some(DefStruct(class_id))\n                             if self.structs.contains(&class_id) => {\n                         let class_def = DefStruct(class_id);\n@@ -5172,27 +5131,23 @@ impl Resolver {\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n                                 def: %?\", result);\n-                        self.resolve_error(\n-                            path.span,\n-                            fmt!(\"`%s` does not name a structure\",\n-                                 self.path_idents_to_str(path)));\n+                        let msg = fmt!(\"`%s` does not name a structure\",\n+                                       self.path_idents_to_str(path));\n+                        self.resolve_error(path.span, msg);\n                     }\n                 }\n \n-                visit::walk_expr(visitor, expr, ());\n+                visit::walk_expr(self, expr, ());\n             }\n \n             ExprLoop(_, Some(label)) => {\n-                do self.with_label_rib {\n-                    {\n-                        let this = &mut *self;\n-                        let def_like = DlDef(DefLabel(expr.id));\n-                        let rib = this.label_ribs[this.label_ribs.len() - 1];\n-                        // plain insert (no renaming)\n-                        rib.bindings.insert(label.name, def_like);\n-                    }\n+                do self.with_label_rib |this| {\n+                    let def_like = DlDef(DefLabel(expr.id));\n+                    let rib = this.label_ribs[this.label_ribs.len() - 1];\n+                    // plain insert (no renaming)\n+                    rib.bindings.insert(label.name, def_like);\n \n-                    visit::walk_expr(visitor, expr, ());\n+                    visit::walk_expr(this, expr, ());\n                 }\n             }\n \n@@ -5229,12 +5184,12 @@ impl Resolver {\n             }\n \n             _ => {\n-                visit::walk_expr(visitor, expr, ());\n+                visit::walk_expr(self, expr, ());\n             }\n         }\n     }\n \n-    pub fn record_candidate_traits_for_expr_if_necessary(@mut self,\n+    pub fn record_candidate_traits_for_expr_if_necessary(&mut self,\n                                                          expr: @Expr) {\n         match expr.node {\n             ExprField(_, ident, _) => {\n@@ -5253,73 +5208,73 @@ impl Resolver {\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n             ExprBinary(_, BiAdd, _, _) | ExprAssignOp(_, BiAdd, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.add_trait());\n+                let i = self.lang_items.add_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiSub, _, _) | ExprAssignOp(_, BiSub, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.sub_trait());\n+                let i = self.lang_items.sub_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiMul, _, _) | ExprAssignOp(_, BiMul, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.mul_trait());\n+                let i = self.lang_items.mul_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiDiv, _, _) | ExprAssignOp(_, BiDiv, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.div_trait());\n+                let i = self.lang_items.div_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiRem, _, _) | ExprAssignOp(_, BiRem, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.rem_trait());\n+                let i = self.lang_items.rem_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiBitXor, _, _) | ExprAssignOp(_, BiBitXor, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.bitxor_trait());\n+                let i = self.lang_items.bitxor_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiBitAnd, _, _) | ExprAssignOp(_, BiBitAnd, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.bitand_trait());\n+                let i = self.lang_items.bitand_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiBitOr, _, _) | ExprAssignOp(_, BiBitOr, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.bitor_trait());\n+                let i = self.lang_items.bitor_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiShl, _, _) | ExprAssignOp(_, BiShl, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.shl_trait());\n+                let i = self.lang_items.shl_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiShr, _, _) | ExprAssignOp(_, BiShr, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.shr_trait());\n+                let i = self.lang_items.shr_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiLt, _, _) | ExprBinary(_, BiLe, _, _) |\n             ExprBinary(_, BiGe, _, _) | ExprBinary(_, BiGt, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.ord_trait());\n+                let i = self.lang_items.ord_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprBinary(_, BiEq, _, _) | ExprBinary(_, BiNe, _, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.eq_trait());\n+                let i = self.lang_items.eq_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprUnary(_, UnNeg, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.neg_trait());\n+                let i = self.lang_items.neg_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprUnary(_, UnNot, _) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.not_trait());\n+                let i = self.lang_items.not_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             ExprIndex(*) => {\n-                self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.index_trait());\n+                let i = self.lang_items.index_trait();\n+                self.add_fixed_trait_for_expr(expr.id, i);\n             }\n             _ => {\n                 // Nothing to do.\n             }\n         }\n     }\n \n-    pub fn search_for_traits_containing_method(@mut self, name: Ident)\n+    pub fn search_for_traits_containing_method(&mut self, name: Ident)\n                                                -> ~[DefId] {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                self.session.str_of(name));\n@@ -5430,7 +5385,7 @@ impl Resolver {\n         found_traits.push(trait_def_id);\n     }\n \n-    pub fn add_fixed_trait_for_expr(@mut self,\n+    pub fn add_fixed_trait_for_expr(&mut self,\n                                     expr_id: NodeId,\n                                     trait_id: Option<DefId>) {\n         match trait_id {\n@@ -5441,7 +5396,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn record_def(@mut self, node_id: NodeId, def: Def) {\n+    pub fn record_def(&mut self, node_id: NodeId, def: Def) {\n         debug!(\"(recording def) recording %? for %?\", def, node_id);\n         do self.def_map.insert_or_update_with(node_id, def) |_, old_value| {\n             // Resolve appears to \"resolve\" the same ID multiple\n@@ -5454,7 +5409,7 @@ impl Resolver {\n         };\n     }\n \n-    pub fn enforce_default_binding_mode(@mut self,\n+    pub fn enforce_default_binding_mode(&mut self,\n                                         pat: @Pat,\n                                         pat_binding_mode: BindingMode,\n                                         descr: &str) {\n@@ -5476,12 +5431,12 @@ impl Resolver {\n     // resolve data structures.\n     //\n \n-    pub fn check_for_unused_imports(@mut self) {\n+    pub fn check_for_unused_imports(&self) {\n         let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n         visit::walk_crate(&mut visitor, self.crate, ());\n     }\n \n-    pub fn check_for_item_unused_imports(&mut self, vi: &view_item) {\n+    pub fn check_for_item_unused_imports(&self, vi: &view_item) {\n         // Ignore public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n@@ -5525,7 +5480,7 @@ impl Resolver {\n     //\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n-    pub fn module_to_str(@mut self, module_: @mut Module) -> ~str {\n+    pub fn module_to_str(&mut self, module_: @mut Module) -> ~str {\n         let mut idents = ~[];\n         let mut current_module = module_;\n         loop {\n@@ -5550,7 +5505,7 @@ impl Resolver {\n         return self.idents_to_str(idents.move_rev_iter().collect::<~[ast::Ident]>());\n     }\n \n-    pub fn dump_module(@mut self, module_: @mut Module) {\n+    pub fn dump_module(&mut self, module_: @mut Module) {\n         debug!(\"Dump of module `%s`:\", self.module_to_str(module_));\n \n         debug!(\"Children:\");\n@@ -5596,7 +5551,7 @@ pub fn resolve_crate(session: Session,\n                      lang_items: LanguageItems,\n                      crate: @Crate)\n                   -> CrateMap {\n-    let resolver = @mut Resolver(session, lang_items, crate);\n+    let mut resolver = Resolver(session, lang_items, crate);\n     resolver.resolve();\n     CrateMap {\n         def_map: resolver.def_map,"}]}