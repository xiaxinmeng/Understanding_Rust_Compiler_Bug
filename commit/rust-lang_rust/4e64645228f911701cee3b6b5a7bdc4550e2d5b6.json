{"sha": "4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNjQ2NDUyMjhmOTExNzAxY2VlM2I2YjVhN2JkYzQ1NTBlMmQ1YjY=", "commit": {"author": {"name": "Jose Narvaez", "email": "jnarvaez@zendesk.com", "date": "2015-11-10T20:48:44Z"}, "committer": {"name": "Jose Narvaez", "email": "jnarvaez@zendesk.com", "date": "2015-11-10T20:48:44Z"}, "message": "Rustfmting librustc_driver.", "tree": {"sha": "8b11ad38e89403cf5c9263d926a5600f4542fc45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b11ad38e89403cf5c9263d926a5600f4542fc45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "html_url": "https://github.com/rust-lang/rust/commit/4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/comments", "author": null, "committer": null, "parents": [{"sha": "ea422eb4de1720d7bcfdc0fd850dc2d048da52ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea422eb4de1720d7bcfdc0fd850dc2d048da52ed", "html_url": "https://github.com/rust-lang/rust/commit/ea422eb4de1720d7bcfdc0fd850dc2d048da52ed"}], "stats": {"total": 1540, "additions": 797, "deletions": 743}, "files": [{"sha": "c8d0425dfc5aca965ab63f4494f6d6bfe487a4de", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 356, "deletions": 339, "changes": 695, "blob_url": "https://github.com/rust-lang/rust/blob/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "patch": "@@ -80,27 +80,17 @@ pub fn compile_input(sess: Session,\n \n             controller_entry_point!(after_parse,\n                                     sess,\n-                                    CompileState::state_after_parse(input,\n-                                                                    &sess,\n-                                                                    outdir,\n-                                                                    &krate));\n-\n-            let outputs = build_output_filenames(input,\n-                                                 outdir,\n-                                                 output,\n-                                                 &krate.attrs,\n-                                                 &sess);\n-            let id = link::find_crate_name(Some(&sess),\n-                                           &krate.attrs,\n-                                           input);\n-            let expanded_crate\n-                = match phase_2_configure_and_expand(&sess,\n-                                                     krate,\n-                                                     &id[..],\n-                                                     addl_plugins) {\n-                    None => return,\n-                    Some(k) => k\n-                };\n+                                    CompileState::state_after_parse(input, &sess, outdir, &krate));\n+\n+            let outputs = build_output_filenames(input, outdir, output, &krate.attrs, &sess);\n+            let id = link::find_crate_name(Some(&sess), &krate.attrs, input);\n+            let expanded_crate = match phase_2_configure_and_expand(&sess,\n+                                                                    krate,\n+                                                                    &id[..],\n+                                                                    addl_plugins) {\n+                None => return,\n+                Some(k) => k,\n+            };\n \n             (outputs, expanded_crate, id)\n         };\n@@ -139,9 +129,9 @@ pub fn compile_input(sess: Session,\n             front::check_attr::check_crate(&sess, &expanded_crate);\n         });\n \n-        time(sess.time_passes(), \"early lint checks\", || {\n-            lint::check_ast_crate(&sess, &expanded_crate)\n-        });\n+        time(sess.time_passes(),\n+             \"early lint checks\",\n+             || lint::check_ast_crate(&sess, &expanded_crate));\n \n         phase_3_run_analysis_passes(&sess,\n                                     ast_map,\n@@ -150,40 +140,43 @@ pub fn compile_input(sess: Session,\n                                     control.make_glob_map,\n                                     |tcx, mir_map, analysis| {\n \n-            {\n-                let state = CompileState::state_after_analysis(input,\n-                                                               &tcx.sess,\n-                                                               outdir,\n-                                                               &expanded_crate,\n-                                                               tcx.map.krate(),\n-                                                               &analysis,\n-                                                               tcx,\n-                                                               &lcx,\n-                                                               &id);\n-                (control.after_analysis.callback)(state);\n-\n-                tcx.sess.abort_if_errors();\n-                if control.after_analysis.stop == Compilation::Stop {\n-                    return Err(());\n-                }\n-            }\n-\n-            if log_enabled!(::log::INFO) {\n-                println!(\"Pre-trans\");\n-                tcx.print_debug_stats();\n-            }\n-            let trans = phase_4_translate_to_llvm(tcx, &mir_map, analysis);\n-\n-            if log_enabled!(::log::INFO) {\n-                println!(\"Post-trans\");\n-                tcx.print_debug_stats();\n-            }\n-\n-            // Discard interned strings as they are no longer required.\n-            token::get_ident_interner().clear();\n-\n-            Ok((outputs, trans))\n-        })\n+                                        {\n+                                            let state =\n+                                                CompileState::state_after_analysis(input,\n+                                                                                   &tcx.sess,\n+                                                                                   outdir,\n+                                                                                   &expanded_crate,\n+                                                                                   tcx.map.krate(),\n+                                                                                   &analysis,\n+                                                                                   tcx,\n+                                                                                   &lcx,\n+                                                                                   &id);\n+                                            (control.after_analysis.callback)(state);\n+\n+                                            tcx.sess.abort_if_errors();\n+                                            if control.after_analysis.stop == Compilation::Stop {\n+                                                return Err(());\n+                                            }\n+                                        }\n+\n+                                        if log_enabled!(::log::INFO) {\n+                                            println!(\"Pre-trans\");\n+                                            tcx.print_debug_stats();\n+                                        }\n+                                        let trans = phase_4_translate_to_llvm(tcx,\n+                                                                              &mir_map,\n+                                                                              analysis);\n+\n+                                        if log_enabled!(::log::INFO) {\n+                                            println!(\"Post-trans\");\n+                                            tcx.print_debug_stats();\n+                                        }\n+\n+                                        // Discard interned strings as they are no longer required.\n+                                        token::get_ident_interner().clear();\n+\n+                                        Ok((outputs, trans))\n+                                    })\n     };\n \n     let (outputs, trans) = if let Ok(out) = result {\n@@ -196,10 +189,7 @@ pub fn compile_input(sess: Session,\n \n     controller_entry_point!(after_llvm,\n                             sess,\n-                            CompileState::state_after_llvm(input,\n-                                                           &sess,\n-                                                           outdir,\n-                                                           &trans));\n+                            CompileState::state_after_llvm(input, &sess, outdir, &trans));\n \n     phase_6_link_output(&sess, &trans, &outputs);\n }\n@@ -214,7 +204,7 @@ pub fn source_name(input: &Input) -> String {\n     match *input {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         Input::File(ref ifile) => ifile.to_str().unwrap().to_string(),\n-        Input::Str(_) => anon_src()\n+        Input::Str(_) => anon_src(),\n     }\n }\n \n@@ -247,7 +237,7 @@ impl<'a> CompileController<'a> {\n         CompileController {\n             after_parse: PhaseController::basic(),\n             after_expand: PhaseController::basic(),\n-            after_write_deps:  PhaseController::basic(),\n+            after_write_deps: PhaseController::basic(),\n             after_analysis: PhaseController::basic(),\n             after_llvm: PhaseController::basic(),\n             make_glob_map: resolve::MakeGlobMap::No,\n@@ -317,10 +307,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                          out_dir: &'a Option<PathBuf>,\n                          krate: &'a ast::Crate)\n                          -> CompileState<'a, 'ast, 'tcx> {\n-        CompileState {\n-            krate: Some(krate),\n-            .. CompileState::empty(input, session, out_dir)\n-        }\n+        CompileState { krate: Some(krate), ..CompileState::empty(input, session, out_dir) }\n     }\n \n     fn state_after_expand(input: &'a Input,\n@@ -332,7 +319,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n             expanded_crate: Some(expanded_crate),\n-            .. CompileState::empty(input, session, out_dir)\n+            ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n@@ -351,7 +338,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n             krate: Some(krate),\n             hir_crate: Some(hir_crate),\n             lcx: Some(lcx),\n-            .. CompileState::empty(input, session, out_dir)\n+            ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n@@ -372,7 +359,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n             hir_crate: Some(hir_crate),\n             lcx: Some(lcx),\n             crate_name: Some(crate_name),\n-            .. CompileState::empty(input, session, out_dir)\n+            ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n@@ -382,15 +369,11 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                         out_dir: &'a Option<PathBuf>,\n                         trans: &'a trans::CrateTranslation)\n                         -> CompileState<'a, 'ast, 'tcx> {\n-        CompileState {\n-            trans: Some(trans),\n-            .. CompileState::empty(input, session, out_dir)\n-        }\n+        CompileState { trans: Some(trans), ..CompileState::empty(input, session, out_dir) }\n     }\n }\n \n-pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n-    -> ast::Crate {\n+pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input) -> ast::Crate {\n     // These may be left in an incoherent state after a previous compile.\n     // `clear_tables` and `get_ident_interner().clear()` can be used to free\n     // memory, but they do not restore the initial state.\n@@ -448,52 +431,51 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // baz! should not use this definition unless foo is enabled.\n \n     let mut feature_gated_cfgs = vec![];\n-    krate = time(time_passes, \"configuration 1\", ||\n-                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate,\n-                                                          &mut feature_gated_cfgs));\n+    krate = time(time_passes, \"configuration 1\", || {\n+        syntax::config::strip_unconfigured_items(sess.diagnostic(), krate, &mut feature_gated_cfgs)\n+    });\n \n-    *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, &krate.attrs);\n-    *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, &krate.attrs);\n+    *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n+    *sess.crate_metadata.borrow_mut() = collect_crate_metadata(sess, &krate.attrs);\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n     });\n \n     time(time_passes, \"gated macro checking\", || {\n-        let features =\n-            syntax::feature_gate::check_crate_macros(sess.codemap(),\n-                                                     &sess.parse_sess.span_diagnostic,\n-                                                     &krate);\n+        let features = syntax::feature_gate::check_crate_macros(sess.codemap(),\n+                                                                &sess.parse_sess.span_diagnostic,\n+                                                                &krate);\n \n         // these need to be set \"early\" so that expansion sees `quote` if enabled.\n         *sess.features.borrow_mut() = features;\n         sess.abort_if_errors();\n     });\n \n \n-    krate = time(time_passes, \"crate injection\", ||\n-                 syntax::std_inject::maybe_inject_crates_ref(krate,\n-                                                             sess.opts.alt_std_name.clone()));\n+    krate = time(time_passes, \"crate injection\", || {\n+        syntax::std_inject::maybe_inject_crates_ref(krate, sess.opts.alt_std_name.clone())\n+    });\n \n-    let macros = time(time_passes, \"macro loading\", ||\n-        metadata::macro_import::read_macro_defs(sess, &krate));\n+    let macros = time(time_passes,\n+                      \"macro loading\",\n+                      || metadata::macro_import::read_macro_defs(sess, &krate));\n \n     let mut addl_plugins = Some(addl_plugins);\n-    let registrars = time(time_passes, \"plugin loading\", ||\n-        plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n+    let registrars = time(time_passes, \"plugin loading\", || {\n+        plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap())\n+    });\n \n     let mut registry = Registry::new(sess, &krate);\n \n     time(time_passes, \"plugin registration\", || {\n         if sess.features.borrow().rustc_diagnostic_macros {\n             registry.register_macro(\"__diagnostic_used\",\n-                diagnostics::plugin::expand_diagnostic_used);\n+                                    diagnostics::plugin::expand_diagnostic_used);\n             registry.register_macro(\"__register_diagnostic\",\n-                diagnostics::plugin::expand_register_diagnostic);\n+                                    diagnostics::plugin::expand_register_diagnostic);\n             registry.register_macro(\"__build_diagnostic_array\",\n-                diagnostics::plugin::expand_build_diagnostic_array);\n+                                    diagnostics::plugin::expand_build_diagnostic_array);\n         }\n \n         for registrar in registrars {\n@@ -554,11 +536,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n         };\n         let ret = syntax::ext::expand::expand_crate(&sess.parse_sess,\n-                                          cfg,\n-                                          macros,\n-                                          syntax_exts,\n-                                          &mut feature_gated_cfgs,\n-                                          krate);\n+                                                    cfg,\n+                                                    macros,\n+                                                    syntax_exts,\n+                                                    &mut feature_gated_cfgs,\n+                                                    krate);\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &_old_path);\n         }\n@@ -570,21 +552,21 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // much as possible (e.g. help the programmer avoid platform\n     // specific differences)\n     time(time_passes, \"complete gated feature checking 1\", || {\n-        let features =\n-            syntax::feature_gate::check_crate(sess.codemap(),\n-                                              &sess.parse_sess.span_diagnostic,\n-                                              &krate, &attributes,\n-                                              sess.opts.unstable_features);\n+        let features = syntax::feature_gate::check_crate(sess.codemap(),\n+                                                         &sess.parse_sess.span_diagnostic,\n+                                                         &krate,\n+                                                         &attributes,\n+                                                         sess.opts.unstable_features);\n         *sess.features.borrow_mut() = features;\n         sess.abort_if_errors();\n     });\n \n     // JBC: make CFG processing part of expansion to avoid this problem:\n \n     // strip again, in case expansion added anything with a #[cfg].\n-    krate = time(time_passes, \"configuration 2\", ||\n-                 syntax::config::strip_unconfigured_items(sess.diagnostic(), krate,\n-                                                          &mut feature_gated_cfgs));\n+    krate = time(time_passes, \"configuration 2\", || {\n+        syntax::config::strip_unconfigured_items(sess.diagnostic(), krate, &mut feature_gated_cfgs)\n+    });\n \n     time(time_passes, \"gated configuration checking\", || {\n         let features = sess.features.borrow();\n@@ -595,41 +577,41 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         }\n     });\n \n-    krate = time(time_passes, \"maybe building test harness\", ||\n-                 syntax::test::modify_for_testing(&sess.parse_sess,\n-                                                  &sess.opts.cfg,\n-                                                  krate,\n-                                                  sess.diagnostic()));\n+    krate = time(time_passes, \"maybe building test harness\", || {\n+        syntax::test::modify_for_testing(&sess.parse_sess, &sess.opts.cfg, krate, sess.diagnostic())\n+    });\n \n-    krate = time(time_passes, \"prelude injection\", ||\n-                 syntax::std_inject::maybe_inject_prelude(&sess.parse_sess, krate));\n+    krate = time(time_passes,\n+                 \"prelude injection\",\n+                 || syntax::std_inject::maybe_inject_prelude(&sess.parse_sess, krate));\n \n-    time(time_passes, \"checking that all macro invocations are gone\", ||\n-         syntax::ext::expand::check_for_macros(&sess.parse_sess, &krate));\n+    time(time_passes,\n+         \"checking that all macro invocations are gone\",\n+         || syntax::ext::expand::check_for_macros(&sess.parse_sess, &krate));\n \n-    time(time_passes, \"checking for inline asm in case the target doesn't support it\", ||\n-         middle::check_no_asm::check_crate(sess, &krate));\n+    time(time_passes,\n+         \"checking for inline asm in case the target doesn't support it\",\n+         || middle::check_no_asm::check_crate(sess, &krate));\n \n     // One final feature gating of the true AST that gets compiled\n     // later, to make sure we've got everything (e.g. configuration\n     // can insert new attributes via `cfg_attr`)\n     time(time_passes, \"complete gated feature checking 2\", || {\n-        let features =\n-            syntax::feature_gate::check_crate(sess.codemap(),\n-                                              &sess.parse_sess.span_diagnostic,\n-                                              &krate, &attributes,\n-                                              sess.opts.unstable_features);\n+        let features = syntax::feature_gate::check_crate(sess.codemap(),\n+                                                         &sess.parse_sess.span_diagnostic,\n+                                                         &krate,\n+                                                         &attributes,\n+                                                         sess.opts.unstable_features);\n         *sess.features.borrow_mut() = features;\n         sess.abort_if_errors();\n     });\n \n     Some(krate)\n }\n \n-pub fn assign_node_ids(sess: &Session,\n-                       krate: ast::Crate) -> ast::Crate {\n+pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     struct NodeIdAssigner<'a> {\n-        sess: &'a Session\n+        sess: &'a Session,\n     }\n \n     impl<'a> Folder for NodeIdAssigner<'a> {\n@@ -671,18 +653,18 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n                                                -> R\n-                                               where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>,\n-                                                                       MirMap<'tcx>,\n-                                                                       ty::CrateAnalysis) -> R\n+    where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>, MirMap<'tcx>, ty::CrateAnalysis) -> R\n {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n \n-    time(time_passes, \"external crate/lib resolution\", ||\n-         LocalCrateReader::new(sess, &ast_map).read_crates(krate));\n+    time(time_passes,\n+         \"external crate/lib resolution\",\n+         || LocalCrateReader::new(sess, &ast_map).read_crates(krate));\n \n-    let lang_items = time(time_passes, \"language item collection\", ||\n-                          middle::lang_items::collect_language_items(&sess, &ast_map));\n+    let lang_items = time(time_passes,\n+                          \"language item collection\",\n+                          || middle::lang_items::collect_language_items(&sess, &ast_map));\n \n     let resolve::CrateMap {\n         def_map,\n@@ -691,34 +673,38 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         trait_map,\n         external_exports,\n         glob_map,\n-    } =\n-        time(time_passes, \"resolution\",\n+    } = time(time_passes,\n+             \"resolution\",\n              || resolve::resolve_crate(sess, &ast_map, make_glob_map));\n \n     // Discard MTWT tables that aren't required past resolution.\n     if !sess.opts.debugging_opts.keep_mtwt_tables {\n         syntax::ext::mtwt::clear_tables();\n     }\n \n-    let named_region_map = time(time_passes, \"lifetime resolution\", ||\n-                                middle::resolve_lifetime::krate(sess, krate, &def_map.borrow()));\n+    let named_region_map = time(time_passes,\n+                                \"lifetime resolution\",\n+                                || middle::resolve_lifetime::krate(sess, krate, &def_map.borrow()));\n \n-    time(time_passes, \"looking for entry point\",\n+    time(time_passes,\n+         \"looking for entry point\",\n          || middle::entry::find_entry_point(sess, &ast_map));\n \n-    sess.plugin_registrar_fn.set(\n-        time(time_passes, \"looking for plugin registrar\", ||\n-            plugin::build::find_plugin_registrar(\n-                sess.diagnostic(), krate)));\n+    sess.plugin_registrar_fn.set(time(time_passes, \"looking for plugin registrar\", || {\n+        plugin::build::find_plugin_registrar(sess.diagnostic(), krate)\n+    }));\n \n-    let region_map = time(time_passes, \"region resolution\", ||\n-                          middle::region::resolve_crate(sess, krate));\n+    let region_map = time(time_passes,\n+                          \"region resolution\",\n+                          || middle::region::resolve_crate(sess, krate));\n \n-    time(time_passes, \"loop checking\", ||\n-         middle::check_loop::check_crate(sess, krate));\n+    time(time_passes,\n+         \"loop checking\",\n+         || middle::check_loop::check_crate(sess, krate));\n \n-    time(time_passes, \"static item recursion checking\", ||\n-         middle::check_static_recursion::check_crate(sess, krate, &def_map.borrow(), &ast_map));\n+    time(time_passes,\n+         \"static item recursion checking\",\n+         || middle::check_static_recursion::check_crate(sess, krate, &def_map.borrow(), &ast_map));\n \n     ty::ctxt::create_and_enter(sess,\n                                arenas,\n@@ -731,91 +717,110 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                stability::Index::new(krate),\n                                |tcx| {\n \n-        // passes are timed inside typeck\n-        typeck::check_crate(tcx, trait_map);\n-\n-        time(time_passes, \"const checking\", ||\n-            middle::check_const::check_crate(tcx));\n-\n-        let (exported_items, public_items) =\n-                time(time_passes, \"privacy checking\", ||\n-                    rustc_privacy::check_crate(tcx, &export_map, external_exports));\n-\n-        // Do not move this check past lint\n-        time(time_passes, \"stability index\", ||\n-            tcx.stability.borrow_mut().build(tcx, krate, &public_items));\n-\n-        time(time_passes, \"intrinsic checking\", ||\n-            middle::intrinsicck::check_crate(tcx));\n-\n-        time(time_passes, \"effect checking\", ||\n-            middle::effect::check_crate(tcx));\n-\n-        time(time_passes, \"match checking\", ||\n-            middle::check_match::check_crate(tcx));\n-\n-        let mir_map = match tcx.sess.opts.unstable_features {\n-            UnstableFeatures::Disallow => {\n-                // use this as a shorthand for beta/stable, and skip\n-                // MIR construction there until known regressions are\n-                // addressed\n-                NodeMap()\n-            }\n-            UnstableFeatures::Allow | UnstableFeatures::Cheat => {\n-                time(time_passes, \"MIR dump\", ||\n-                     mir::mir_map::build_mir_for_crate(tcx))\n-            }\n-        };\n-\n-        time(time_passes, \"liveness checking\", ||\n-            middle::liveness::check_crate(tcx));\n-\n-        time(time_passes, \"borrow checking\", ||\n-            borrowck::check_crate(tcx));\n-\n-        time(time_passes, \"rvalue checking\", ||\n-            middle::check_rvalues::check_crate(tcx, krate));\n-\n-        // Avoid overwhelming user with errors if type checking failed.\n-        // I'm not sure how helpful this is, to be honest, but it avoids a\n-        // lot of annoying errors in the compile-fail tests (basically,\n-        // lint warnings and so on -- kindck used to do this abort, but\n-        // kindck is gone now). -nmatsakis\n-        tcx.sess.abort_if_errors();\n-\n-        let reachable_map =\n-            time(time_passes, \"reachability checking\", ||\n-                reachable::find_reachable(tcx, &exported_items));\n-\n-        time(time_passes, \"death checking\", || {\n-            middle::dead::check_crate(tcx,\n-                                      &exported_items,\n-                                      &reachable_map)\n-        });\n-\n-        let ref lib_features_used =\n-            time(time_passes, \"stability checking\", ||\n-                stability::check_unstable_api_usage(tcx));\n-\n-        time(time_passes, \"unused lib feature checking\", ||\n-            stability::check_unused_or_stable_features(\n-                &tcx.sess, lib_features_used));\n-\n-        time(time_passes, \"lint checking\", ||\n-            lint::check_crate(tcx, krate, &exported_items));\n-\n-        // The above three passes generate errors w/o aborting\n-        tcx.sess.abort_if_errors();\n-\n-        f(tcx, mir_map, ty::CrateAnalysis {\n-            export_map: export_map,\n-            exported_items: exported_items,\n-            public_items: public_items,\n-            reachable: reachable_map,\n-            name: name,\n-            glob_map: glob_map,\n-        })\n-    })\n+                                   // passes are timed inside typeck\n+                                   typeck::check_crate(tcx, trait_map);\n+\n+                                   time(time_passes,\n+                                        \"const checking\",\n+                                        || middle::check_const::check_crate(tcx));\n+\n+                                   let (exported_items, public_items) =\n+                                       time(time_passes, \"privacy checking\", || {\n+                                           rustc_privacy::check_crate(tcx,\n+                                                                      &export_map,\n+                                                                      external_exports)\n+                                       });\n+\n+                                   // Do not move this check past lint\n+                                   time(time_passes, \"stability index\", || {\n+                                       tcx.stability.borrow_mut().build(tcx, krate, &public_items)\n+                                   });\n+\n+                                   time(time_passes,\n+                                        \"intrinsic checking\",\n+                                        || middle::intrinsicck::check_crate(tcx));\n+\n+                                   time(time_passes,\n+                                        \"effect checking\",\n+                                        || middle::effect::check_crate(tcx));\n+\n+                                   time(time_passes,\n+                                        \"match checking\",\n+                                        || middle::check_match::check_crate(tcx));\n+\n+                                   let mir_map = match tcx.sess.opts.unstable_features {\n+                                       UnstableFeatures::Disallow => {\n+                                           // use this as a shorthand for beta/stable, and skip\n+                                           // MIR construction there until known regressions are\n+                                           // addressed\n+                                           NodeMap()\n+                                       }\n+                                       UnstableFeatures::Allow | UnstableFeatures::Cheat => {\n+                                           time(time_passes,\n+                                                \"MIR dump\",\n+                                                || mir::mir_map::build_mir_for_crate(tcx))\n+                                       }\n+                                   };\n+\n+                                   time(time_passes,\n+                                        \"liveness checking\",\n+                                        || middle::liveness::check_crate(tcx));\n+\n+                                   time(time_passes,\n+                                        \"borrow checking\",\n+                                        || borrowck::check_crate(tcx));\n+\n+                                   time(time_passes,\n+                                        \"rvalue checking\",\n+                                        || middle::check_rvalues::check_crate(tcx, krate));\n+\n+                                   // Avoid overwhelming user with errors if type checking failed.\n+                                   // I'm not sure how helpful this is, to be honest, but it avoids\n+                                   // a\n+                                   // lot of annoying errors in the compile-fail tests (basically,\n+                                   // lint warnings and so on -- kindck used to do this abort, but\n+                                   // kindck is gone now). -nmatsakis\n+                                   tcx.sess.abort_if_errors();\n+\n+                                   let reachable_map =\n+                                       time(time_passes,\n+                                            \"reachability checking\",\n+                                            || reachable::find_reachable(tcx, &exported_items));\n+\n+                                   time(time_passes, \"death checking\", || {\n+                                       middle::dead::check_crate(tcx,\n+                                                                 &exported_items,\n+                                                                 &reachable_map)\n+                                   });\n+\n+                                   let ref lib_features_used =\n+                                       time(time_passes,\n+                                            \"stability checking\",\n+                                            || stability::check_unstable_api_usage(tcx));\n+\n+                                   time(time_passes, \"unused lib feature checking\", || {\n+                                       stability::check_unused_or_stable_features(&tcx.sess,\n+                                                                                  lib_features_used)\n+                                   });\n+\n+                                   time(time_passes,\n+                                        \"lint checking\",\n+                                        || lint::check_crate(tcx, krate, &exported_items));\n+\n+                                   // The above three passes generate errors w/o aborting\n+                                   tcx.sess.abort_if_errors();\n+\n+                                   f(tcx,\n+                                     mir_map,\n+                                     ty::CrateAnalysis {\n+                                         export_map: export_map,\n+                                         exported_items: exported_items,\n+                                         public_items: public_items,\n+                                         reachable: reachable_map,\n+                                         name: name,\n+                                         glob_map: glob_map,\n+                                     })\n+                               })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n@@ -826,12 +831,14 @@ pub fn phase_4_translate_to_llvm<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                        -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n-    time(time_passes, \"resolving dependency formats\", ||\n-         dependency_format::calculate(&tcx.sess));\n+    time(time_passes,\n+         \"resolving dependency formats\",\n+         || dependency_format::calculate(&tcx.sess));\n \n     // Option dance to work around the lack of stack once closures.\n-    time(time_passes, \"translation\", move ||\n-         trans::trans_crate(tcx, mir_map, analysis))\n+    time(time_passes,\n+         \"translation\",\n+         move || trans::trans_crate(tcx, mir_map, analysis))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n@@ -842,8 +849,9 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n     if sess.opts.cg.no_integrated_as {\n         let mut map = HashMap::new();\n         map.insert(OutputType::Assembly, None);\n-        time(sess.time_passes(), \"LLVM passes\", ||\n-            write::run_passes(sess, trans, &map, outputs));\n+        time(sess.time_passes(),\n+             \"LLVM passes\",\n+             || write::run_passes(sess, trans, &map, outputs));\n \n         write::run_assembler(sess, outputs);\n \n@@ -852,11 +860,9 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n             fs::remove_file(&outputs.temp_path(OutputType::Assembly)).unwrap();\n         }\n     } else {\n-        time(sess.time_passes(), \"LLVM passes\", ||\n-            write::run_passes(sess,\n-                              trans,\n-                              &sess.opts.output_types,\n-                              outputs));\n+        time(sess.time_passes(),\n+             \"LLVM passes\",\n+             || write::run_passes(sess, trans, &sess.opts.output_types, outputs));\n     }\n \n     sess.abort_if_errors();\n@@ -867,17 +873,15 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    time(sess.time_passes(), \"linking\", ||\n-         link::link_binary(sess,\n-                           trans,\n-                           outputs,\n-                           &trans.link.crate_name));\n+    time(sess.time_passes(),\n+         \"linking\",\n+         || link::link_binary(sess, trans, outputs, &trans.link.crate_name));\n }\n \n fn escape_dep_filename(filename: &str) -> String {\n     // Apparently clang and gcc *only* escape spaces:\n     // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4\n-    filename.replace(\" \", \"\\\\ \")\n+    filename.replace(\" \", \"\\\")\n }\n \n fn write_out_deps(sess: &Session, outputs: &OutputFilenames, id: &str) {\n@@ -887,96 +891,101 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, id: &str) {\n         match *output_type {\n             OutputType::Exe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output, id,\n-                                                     outputs);\n+                    let p = link::filename_for_input(sess, *output, id, outputs);\n                     out_filenames.push(p);\n                 }\n             }\n-            _ => { out_filenames.push(file); }\n+            _ => {\n+                out_filenames.push(file);\n+            }\n         }\n     }\n \n     // Write out dependency rules to the dep-info file if requested\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n-        return\n+        return;\n     }\n     let deps_filename = outputs.path(OutputType::DepInfo);\n \n-    let result = (|| -> io::Result<()> {\n-        // Build a list of files used to compile the output and\n-        // write Makefile-compatible dependency rules\n-        let files: Vec<String> = sess.codemap().files.borrow()\n-                                   .iter()\n-                                   .filter(|fmap| fmap.is_real_file())\n-                                   .filter(|fmap| !fmap.is_imported())\n-                                   .map(|fmap| escape_dep_filename(&fmap.name))\n-                                   .collect();\n-        let mut file = try!(fs::File::create(&deps_filename));\n-        for path in &out_filenames {\n-            try!(write!(file,\n-                        \"{}: {}\\n\\n\", path.display(), files.join(\" \")));\n-        }\n+    let result =\n+        (|| -> io::Result<()> {\n+            // Build a list of files used to compile the output and\n+            // write Makefile-compatible dependency rules\n+            let files: Vec<String> = sess.codemap()\n+                                         .files\n+                                         .borrow()\n+                                         .iter()\n+                                         .filter(|fmap| fmap.is_real_file())\n+                                         .filter(|fmap| !fmap.is_imported())\n+                                         .map(|fmap| escape_dep_filename(&fmap.name))\n+                                         .collect();\n+            let mut file = try!(fs::File::create(&deps_filename));\n+            for path in &out_filenames {\n+                try!(write!(file, \"{}: {}\\n\\n\", path.display(), files.join(\" \")));\n+            }\n \n-        // Emit a fake target for each input file to the compilation. This\n-        // prevents `make` from spitting out an error if a file is later\n-        // deleted. For more info see #28735\n-        for path in files {\n-            try!(writeln!(file, \"{}:\", path));\n-        }\n-        Ok(())\n-    })();\n+            // Emit a fake target for each input file to the compilation. This\n+            // prevents `make` from spitting out an error if a file is later\n+            // deleted. For more info see #28735\n+            for path in files {\n+                try!(writeln!(file, \"{}:\", path));\n+            }\n+            Ok(())\n+        })();\n \n     match result {\n         Ok(()) => {}\n         Err(e) => {\n             sess.fatal(&format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e));\n+                                deps_filename.display(),\n+                                e));\n         }\n     }\n }\n \n-pub fn collect_crate_types(session: &Session,\n-                           attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n+pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n     // Unconditionally collect crate types from attributes to make them used\n-    let attr_types: Vec<config::CrateType> = attrs.iter().filter_map(|a| {\n-        if a.check_name(\"crate_type\") {\n-            match a.value_str() {\n-                Some(ref n) if *n == \"rlib\" => {\n-                    Some(config::CrateTypeRlib)\n-                }\n-                Some(ref n) if *n == \"dylib\" => {\n-                    Some(config::CrateTypeDylib)\n-                }\n-                Some(ref n) if *n == \"lib\" => {\n-                    Some(config::default_lib_output())\n-                }\n-                Some(ref n) if *n == \"staticlib\" => {\n-                    Some(config::CrateTypeStaticlib)\n-                }\n-                Some(ref n) if *n == \"bin\" => Some(config::CrateTypeExecutable),\n-                Some(_) => {\n-                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                     ast::CRATE_NODE_ID,\n-                                     a.span,\n-                                     \"invalid `crate_type` \\\n-                                      value\".to_string());\n-                    None\n-                }\n-                _ => {\n-                    session.span_err(a.span, \"`crate_type` requires a value\");\n-                    session.note(\"for example: `#![crate_type=\\\"lib\\\"]`\");\n-                    None\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }).collect();\n+    let attr_types: Vec<config::CrateType> =\n+        attrs.iter()\n+             .filter_map(|a| {\n+                 if a.check_name(\"crate_type\") {\n+                     match a.value_str() {\n+                         Some(ref n) if *n == \"rlib\" => {\n+                             Some(config::CrateTypeRlib)\n+                         }\n+                         Some(ref n) if *n == \"dylib\" => {\n+                             Some(config::CrateTypeDylib)\n+                         }\n+                         Some(ref n) if *n == \"lib\" => {\n+                             Some(config::default_lib_output())\n+                         }\n+                         Some(ref n) if *n == \"staticlib\" => {\n+                             Some(config::CrateTypeStaticlib)\n+                         }\n+                         Some(ref n) if *n == \"bin\" => Some(config::CrateTypeExecutable),\n+                         Some(_) => {\n+                             session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n+                                              ast::CRATE_NODE_ID,\n+                                              a.span,\n+                                              \"invalid `crate_type` value\".to_string());\n+                             None\n+                         }\n+                         _ => {\n+                             session.span_err(a.span, \"`crate_type` requires a value\");\n+                             session.note(\"for example: `#![crate_type=\\\"lib\\\"]`\");\n+                             None\n+                         }\n+                     }\n+                 } else {\n+                     None\n+                 }\n+             })\n+             .collect();\n \n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     if session.opts.test {\n-        return vec!(config::CrateTypeExecutable)\n+        return vec![config::CrateTypeExecutable];\n     }\n \n     // Only check command line flags if present. If no types are specified by\n@@ -992,21 +1001,22 @@ pub fn collect_crate_types(session: &Session,\n         base.dedup();\n     }\n \n-    base.into_iter().filter(|crate_type| {\n-        let res = !link::invalid_output_for_target(session, *crate_type);\n+    base.into_iter()\n+        .filter(|crate_type| {\n+            let res = !link::invalid_output_for_target(session, *crate_type);\n \n-        if !res {\n-            session.warn(&format!(\"dropping unsupported crate type `{}` \\\n-                                   for target `{}`\",\n-                                 *crate_type, session.opts.target_triple));\n-        }\n+            if !res {\n+                session.warn(&format!(\"dropping unsupported crate type `{}` for target `{}`\",\n+                                      *crate_type,\n+                                      session.opts.target_triple));\n+            }\n \n-        res\n-    }).collect()\n+            res\n+        })\n+        .collect()\n }\n \n-pub fn collect_crate_metadata(session: &Session,\n-                              _attrs: &[ast::Attribute]) -> Vec<String> {\n+pub fn collect_crate_metadata(session: &Session, _attrs: &[ast::Attribute]) -> Vec<String> {\n     session.opts.cg.metadata.clone()\n }\n \n@@ -1015,21 +1025,23 @@ pub fn build_output_filenames(input: &Input,\n                               ofile: &Option<PathBuf>,\n                               attrs: &[ast::Attribute],\n                               sess: &Session)\n-                           -> OutputFilenames {\n+                              -> OutputFilenames {\n     match *ofile {\n         None => {\n             // \"-\" as input file will cause the parser to read from stdin so we\n             // have to make up a name\n             // We want to toss everything after the final '.'\n             let dirpath = match *odir {\n                 Some(ref d) => d.clone(),\n-                None => PathBuf::new()\n+                None => PathBuf::new(),\n             };\n \n             // If a crate name is present, we use it as the link name\n-            let stem = sess.opts.crate_name.clone().or_else(|| {\n-                attr::find_crate_name(attrs).map(|n| n.to_string())\n-            }).unwrap_or(input.filestem());\n+            let stem = sess.opts\n+                           .crate_name\n+                           .clone()\n+                           .or_else(|| attr::find_crate_name(attrs).map(|n| n.to_string()))\n+                           .unwrap_or(input.filestem());\n \n             OutputFilenames {\n                 out_directory: dirpath,\n@@ -1041,12 +1053,14 @@ pub fn build_output_filenames(input: &Input,\n         }\n \n         Some(ref out_file) => {\n-            let unnamed_output_types = sess.opts.output_types.values()\n+            let unnamed_output_types = sess.opts\n+                                           .output_types\n+                                           .values()\n                                            .filter(|a| a.is_none())\n                                            .count();\n             let ofile = if unnamed_output_types > 1 {\n-                sess.warn(\"ignoring specified output filename because multiple \\\n-                           outputs were requested\");\n+                sess.warn(\"ignoring specified output filename because multiple outputs were \\\n+                           requested\");\n                 None\n             } else {\n                 Some(out_file.clone())\n@@ -1059,8 +1073,11 @@ pub fn build_output_filenames(input: &Input,\n \n             OutputFilenames {\n                 out_directory: out_file.parent().unwrap_or(cur_dir).to_path_buf(),\n-                out_filestem: out_file.file_stem().unwrap_or(OsStr::new(\"\"))\n-                                      .to_str().unwrap().to_string(),\n+                out_filestem: out_file.file_stem()\n+                                      .unwrap_or(OsStr::new(\"\"))\n+                                      .to_str()\n+                                      .unwrap()\n+                                      .to_string(),\n                 single_output_file: ofile,\n                 extra: sess.opts.cg.extra_filename.clone(),\n                 outputs: sess.opts.output_types.clone(),"}, {"sha": "63326c538c915be215e66302c068bdf0e3ae2648", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 155, "deletions": 125, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "patch": "@@ -51,8 +51,10 @@ extern crate rustc_trans;\n extern crate rustc_typeck;\n extern crate serialize;\n extern crate rustc_llvm as llvm;\n-#[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate syntax;\n \n pub use syntax::diagnostic;\n \n@@ -94,8 +96,8 @@ pub mod pretty;\n pub mod target_features;\n \n \n-const BUG_REPORT_URL: &'static str =\n-    \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\";\n+const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n+                                      md#bug-reports\";\n \n \n pub fn run(args: Vec<String>) -> isize {\n@@ -105,8 +107,7 @@ pub fn run(args: Vec<String>) -> isize {\n \n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n-pub fn run_compiler<'a>(args: &[String],\n-                        callbacks: &mut CompilerCalls<'a>) {\n+pub fn run_compiler<'a>(args: &[String], callbacks: &mut CompilerCalls<'a>) {\n     macro_rules! do_or_return {($expr: expr) => {\n         match $expr {\n             Compilation::Stop => return,\n@@ -116,7 +117,7 @@ pub fn run_compiler<'a>(args: &[String],\n \n     let matches = match handle_options(args.to_vec()) {\n         Some(matches) => matches,\n-        None => return\n+        None => return,\n     };\n \n     let sopts = config::build_session_options(&matches);\n@@ -130,8 +131,8 @@ pub fn run_compiler<'a>(args: &[String],\n         Some((input, input_file_path)) => callbacks.some_input(input, input_file_path),\n         None => match callbacks.no_input(&matches, &sopts, &odir, &ofile, &descriptions) {\n             Some((input, input_file_path)) => (input, input_file_path),\n-            None => return\n-        }\n+            None => return,\n+        },\n     };\n \n     let mut sess = build_session(sopts, input_file_path, descriptions);\n@@ -152,7 +153,9 @@ pub fn run_compiler<'a>(args: &[String],\n             pretty::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n             return;\n         }\n-        None => {/* continue */ }\n+        None => {\n+            // continue\n+        }\n     }\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n@@ -176,7 +179,8 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n             io::stdin().read_to_string(&mut src).unwrap();\n             Some((Input::Str(src), None))\n         } else {\n-            Some((Input::File(PathBuf::from(ifile)), Some(PathBuf::from(ifile))))\n+            Some((Input::File(PathBuf::from(ifile)),\n+                  Some(PathBuf::from(ifile))))\n         }\n     } else {\n         None\n@@ -194,7 +198,7 @@ impl Compilation {\n     pub fn and_then<F: FnOnce() -> Compilation>(self, next: F) -> Compilation {\n         match self {\n             Compilation::Stop => Compilation::Stop,\n-            Compilation::Continue => next()\n+            Compilation::Continue => next(),\n         }\n     }\n }\n@@ -229,7 +233,9 @@ pub trait CompilerCalls<'a> {\n     // Called after we extract the input from the arguments. Gives the implementer\n     // an opportunity to change the inputs or to add some custom input handling.\n     // The default behaviour is to simply pass through the inputs.\n-    fn some_input(&mut self, input: Input, input_path: Option<PathBuf>)\n+    fn some_input(&mut self,\n+                  input: Input,\n+                  input_path: Option<PathBuf>)\n                   -> (Input, Option<PathBuf>) {\n         (input, input_path)\n     }\n@@ -269,7 +275,8 @@ pub trait CompilerCalls<'a> {\n         None\n     }\n \n-    // Create a CompilController struct for controlling the behaviour of compilation.\n+    // Create a CompilController struct for controlling the behaviour of\n+    // compilation.\n     fn build_controller(&mut self, &Session) -> CompileController<'a>;\n }\n \n@@ -300,8 +307,8 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     }\n                 }\n                 return Compilation::Stop;\n-            },\n-            None => ()\n+            }\n+            None => (),\n         }\n \n         return Compilation::Continue;\n@@ -331,7 +338,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                 early_error(sopts.color, \"no input filename given\");\n             }\n             1 => panic!(\"make_input should have provided valid inputs\"),\n-            _ => early_error(sopts.color, \"multiple input filenames provided\")\n+            _ => early_error(sopts.color, \"multiple input filenames provided\"),\n         }\n \n         None\n@@ -366,15 +373,14 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                      odir: &Option<PathBuf>,\n                      ofile: &Option<PathBuf>)\n                      -> Compilation {\n-        RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile).and_then(\n-            || RustcDefaultCalls::list_metadata(sess, matches, input))\n+        RustcDefaultCalls::print_crate_info(sess, Some(input), odir, ofile)\n+            .and_then(|| RustcDefaultCalls::list_metadata(sess, matches, input))\n     }\n \n     fn build_controller(&mut self, sess: &Session) -> CompileController<'a> {\n         let mut control = CompileController::basic();\n \n-        if sess.opts.parse_only ||\n-           sess.opts.show_span.is_some() ||\n+        if sess.opts.parse_only || sess.opts.show_span.is_some() ||\n            sess.opts.debugging_opts.ast_json_noexpand {\n             control.after_parse.stop = Compilation::Stop;\n         }\n@@ -393,14 +399,14 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n \n         if sess.opts.debugging_opts.save_analysis {\n             control.after_analysis.callback = box |state| {\n-                time(state.session.time_passes(),\n-                     \"save analysis\",\n-                     || save::process_crate(state.tcx.unwrap(),\n-                                            state.lcx.unwrap(),\n-                                            state.krate.unwrap(),\n-                                            state.analysis.unwrap(),\n-                                            state.crate_name.unwrap(),\n-                                            state.out_dir));\n+                time(state.session.time_passes(), \"save analysis\", || {\n+                    save::process_crate(state.tcx.unwrap(),\n+                                        state.lcx.unwrap(),\n+                                        state.krate.unwrap(),\n+                                        state.analysis.unwrap(),\n+                                        state.crate_name.unwrap(),\n+                                        state.out_dir)\n+                });\n             };\n             control.make_glob_map = resolve::MakeGlobMap::Yes;\n         }\n@@ -410,19 +416,15 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n }\n \n impl RustcDefaultCalls {\n-    pub fn list_metadata(sess: &Session,\n-                         matches: &getopts::Matches,\n-                         input: &Input)\n-                         -> Compilation {\n+    pub fn list_metadata(sess: &Session, matches: &getopts::Matches, input: &Input) -> Compilation {\n         let r = matches.opt_strs(\"Z\");\n         if r.contains(&(\"ls\".to_string())) {\n             match input {\n                 &Input::File(ref ifile) => {\n                     let path = &(*ifile);\n                     let mut v = Vec::new();\n-                    metadata::loader::list_file_metadata(&sess.target.target,\n-                                                         path,\n-                                                         &mut v).unwrap();\n+                    metadata::loader::list_file_metadata(&sess.target.target, path, &mut v)\n+                        .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());\n                 }\n                 &Input::Str(_) => {\n@@ -456,26 +458,21 @@ impl RustcDefaultCalls {\n                         None => early_error(sess.opts.color, \"no input file provided\"),\n                     };\n                     let attrs = attrs.as_ref().unwrap();\n-                    let t_outputs = driver::build_output_filenames(input,\n-                                                                   odir,\n-                                                                   ofile,\n-                                                                   attrs,\n-                                                                   sess);\n-                    let id = link::find_crate_name(Some(sess),\n-                                                   attrs,\n-                                                   input);\n+                    let t_outputs = driver::build_output_filenames(input, odir, ofile, attrs, sess);\n+                    let id = link::find_crate_name(Some(sess), attrs, input);\n                     if *req == PrintRequest::CrateName {\n                         println!(\"{}\", id);\n-                        continue\n+                        continue;\n                     }\n                     let crate_types = driver::collect_crate_types(sess, attrs);\n                     let metadata = driver::collect_crate_metadata(sess, attrs);\n                     *sess.crate_metadata.borrow_mut() = metadata;\n                     for &style in &crate_types {\n-                        let fname = link::filename_for_input(sess, style, &id,\n-                                                             &t_outputs);\n-                        println!(\"{}\", fname.file_name().unwrap()\n-                                            .to_string_lossy());\n+                        let fname = link::filename_for_input(sess, style, &id, &t_outputs);\n+                        println!(\"{}\",\n+                                 fname.file_name()\n+                                      .unwrap()\n+                                      .to_string_lossy());\n                     }\n                 }\n             }\n@@ -503,9 +500,13 @@ pub fn commit_date_str() -> Option<&'static str> {\n pub fn version(binary: &str, matches: &getopts::Matches) {\n     let verbose = matches.opt_present(\"verbose\");\n \n-    println!(\"{} {}\", binary, option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"));\n+    println!(\"{} {}\",\n+             binary,\n+             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"));\n     if verbose {\n-        fn unw(x: Option<&str>) -> &str { x.unwrap_or(\"unknown\") }\n+        fn unw(x: Option<&str>) -> &str {\n+            x.unwrap_or(\"unknown\")\n+        }\n         println!(\"binary: {}\", binary);\n         println!(\"commit-hash: {}\", unw(commit_hash_str()));\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n@@ -520,32 +521,35 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     } else {\n         config::rustc_short_optgroups()\n     };\n-    let groups : Vec<_> = groups.into_iter()\n-        .filter(|x| include_unstable_options || x.is_stable())\n-        .map(|x|x.opt_group)\n-        .collect();\n+    let groups: Vec<_> = groups.into_iter()\n+                               .filter(|x| include_unstable_options || x.is_stable())\n+                               .map(|x| x.opt_group)\n+                               .collect();\n     let message = format!(\"Usage: rustc [OPTIONS] INPUT\");\n     let extra_help = if verbose {\n         \"\"\n     } else {\n         \"\\n    --help -v           Print the full set of options rustc accepts\"\n     };\n-    println!(\"{}\\n\\\n-Additional help:\n+    println!(\"{}\\nAdditional help:\n     -C help             Print codegen options\n-    -W help             Print 'lint' options and default settings\n-    -Z help             Print internal options for debugging rustc{}\\n\",\n-              getopts::usage(&message, &groups),\n-              extra_help);\n+    -W help             \\\n+              Print 'lint' options and default settings\n+    -Z help             Print internal \\\n+              options for debugging rustc{}\\n\",\n+             getopts::usage(&message, &groups),\n+             extra_help);\n }\n \n fn describe_lints(lint_store: &lint::LintStore, loaded_plugins: bool) {\n     println!(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n-    -A <foo>           Allow <foo>\n+    -A <foo>           \\\n+              Allow <foo>\n     -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> (deny, and deny all overrides)\n+    -F <foo>           Forbid <foo> \\\n+              (deny, and deny all overrides)\n \n \");\n \n@@ -562,7 +566,7 @@ Available lint options:\n     }\n \n     fn sort_lint_groups(lints: Vec<(&'static str, Vec<lint::LintId>, bool)>)\n-                     -> Vec<(&'static str, Vec<lint::LintId>)> {\n+                        -> Vec<(&'static str, Vec<lint::LintId>)> {\n         let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n         lints.sort_by(|&(x, _): &(&'static str, Vec<lint::LintId>),\n                        &(y, _): &(&'static str, Vec<lint::LintId>)| {\n@@ -572,21 +576,28 @@ Available lint options:\n     }\n \n     let (plugin, builtin): (Vec<_>, _) = lint_store.get_lints()\n-        .iter().cloned().partition(|&(_, p)| p);\n+                                                   .iter()\n+                                                   .cloned()\n+                                                   .partition(|&(_, p)| p);\n     let plugin = sort_lints(plugin);\n     let builtin = sort_lints(builtin);\n \n     let (plugin_groups, builtin_groups): (Vec<_>, _) = lint_store.get_lint_groups()\n-        .iter().cloned().partition(|&(_, _, p)| p);\n+                                                                 .iter()\n+                                                                 .cloned()\n+                                                                 .partition(|&(_, _, p)| p);\n     let plugin_groups = sort_lint_groups(plugin_groups);\n     let builtin_groups = sort_lint_groups(builtin_groups);\n \n-    let max_name_len = plugin.iter().chain(&builtin)\n-        .map(|&s| s.name.chars().count())\n-        .max().unwrap_or(0);\n+    let max_name_len = plugin.iter()\n+                             .chain(&builtin)\n+                             .map(|&s| s.name.chars().count())\n+                             .max()\n+                             .unwrap_or(0);\n     let padded = |x: &str| {\n-        let mut s = repeat(\" \").take(max_name_len - x.chars().count())\n-                               .collect::<String>();\n+        let mut s = repeat(\" \")\n+                        .take(max_name_len - x.chars().count())\n+                        .collect::<String>();\n         s.push_str(x);\n         s\n     };\n@@ -599,7 +610,9 @@ Available lint options:\n         for lint in lints {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(&name[..]), lint.default_level.as_str(), lint.desc);\n+                     padded(&name[..]),\n+                     lint.default_level.as_str(),\n+                     lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -608,12 +621,15 @@ Available lint options:\n \n \n \n-    let max_name_len = plugin_groups.iter().chain(&builtin_groups)\n-        .map(|&(s, _)| s.chars().count())\n-        .max().unwrap_or(0);\n+    let max_name_len = plugin_groups.iter()\n+                                    .chain(&builtin_groups)\n+                                    .map(|&(s, _)| s.chars().count())\n+                                    .max()\n+                                    .unwrap_or(0);\n     let padded = |x: &str| {\n-        let mut s = repeat(\" \").take(max_name_len - x.chars().count())\n-                               .collect::<String>();\n+        let mut s = repeat(\" \")\n+                        .take(max_name_len - x.chars().count())\n+                        .collect::<String>();\n         s.push_str(x);\n         s\n     };\n@@ -625,10 +641,11 @@ Available lint options:\n     let print_lint_groups = |lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n         for (name, to) in lints {\n             let name = name.to_lowercase().replace(\"_\", \"-\");\n-            let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n-                         .collect::<Vec<String>>().join(\", \");\n-            println!(\"    {}  {}\",\n-                     padded(&name[..]), desc);\n+            let desc = to.into_iter()\n+                         .map(|x| x.as_str().replace(\"_\", \"-\"))\n+                         .collect::<Vec<String>>()\n+                         .join(\", \");\n+            println!(\"    {}  {}\", padded(&name[..]), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -667,21 +684,28 @@ fn describe_codegen_flags() {\n \n fn print_flag_list<T>(cmdline_opt: &str,\n                       flag_list: &[(&'static str, T, Option<&'static str>, &'static str)]) {\n-    let max_len = flag_list.iter().map(|&(name, _, opt_type_desc, _)| {\n-        let extra_len = match opt_type_desc {\n-            Some(..) => 4,\n-            None => 0\n-        };\n-        name.chars().count() + extra_len\n-    }).max().unwrap_or(0);\n+    let max_len = flag_list.iter()\n+                           .map(|&(name, _, opt_type_desc, _)| {\n+                               let extra_len = match opt_type_desc {\n+                                   Some(..) => 4,\n+                                   None => 0,\n+                               };\n+                               name.chars().count() + extra_len\n+                           })\n+                           .max()\n+                           .unwrap_or(0);\n \n     for &(name, _, opt_type_desc, desc) in flag_list {\n         let (width, extra) = match opt_type_desc {\n             Some(..) => (max_len - 4, \"=val\"),\n-            None => (max_len, \"\")\n+            None => (max_len, \"\"),\n         };\n-        println!(\"    {} {:>width$}{} -- {}\", cmdline_opt, name.replace(\"_\", \"-\"),\n-                 extra, desc, width=width);\n+        println!(\"    {} {:>width$}{} -- {}\",\n+                 cmdline_opt,\n+                 name.replace(\"_\", \"-\"),\n+                 extra,\n+                 desc,\n+                 width = width);\n     }\n }\n \n@@ -705,8 +729,10 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     fn parse_all_options(args: &Vec<String>) -> getopts::Matches {\n-        let all_groups : Vec<getopts::OptGroup>\n-            = config::rustc_optgroups().into_iter().map(|x|x.opt_group).collect();\n+        let all_groups: Vec<getopts::OptGroup> = config::rustc_optgroups()\n+                                                     .into_iter()\n+                                                     .map(|x| x.opt_group)\n+                                                     .collect();\n         match getopts::getopts(&args[..], &all_groups) {\n             Ok(m) => {\n                 if !allows_unstable_options(&m) {\n@@ -719,15 +745,16 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n                             &opt.opt_group.short_name\n                         };\n                         if m.opt_present(opt_name) {\n-                            early_error(diagnostic::Auto, &format!(\"use of unstable option '{}' \\\n-                                                                    requires -Z unstable-options\",\n-                                                                   opt_name));\n+                            early_error(diagnostic::Auto,\n+                                        &format!(\"use of unstable option '{}' requires -Z \\\n+                                                  unstable-options\",\n+                                                 opt_name));\n                         }\n                     }\n                 }\n                 m\n             }\n-            Err(f) => early_error(diagnostic::Auto, &f.to_string())\n+            Err(f) => early_error(diagnostic::Auto, &f.to_string()),\n         }\n     }\n \n@@ -750,7 +777,8 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        usage(matches.opt_present(\"verbose\"), allows_unstable_options(&matches));\n+        usage(matches.opt_present(\"verbose\"),\n+              allows_unstable_options(&matches));\n         return None;\n     }\n \n@@ -769,7 +797,9 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n-        unsafe { ::llvm::LLVMRustPrintPasses(); }\n+        unsafe {\n+            ::llvm::LLVMRustPrintPasses();\n+        }\n         return None;\n     }\n \n@@ -781,20 +811,16 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     Some(matches)\n }\n \n-fn parse_crate_attrs(sess: &Session, input: &Input) ->\n-                     Vec<ast::Attribute> {\n+fn parse_crate_attrs(sess: &Session, input: &Input) -> Vec<ast::Attribute> {\n     let result = match *input {\n         Input::File(ref ifile) => {\n-            parse::parse_crate_attrs_from_file(ifile,\n-                                               Vec::new(),\n-                                               &sess.parse_sess)\n+            parse::parse_crate_attrs_from_file(ifile, Vec::new(), &sess.parse_sess)\n         }\n         Input::Str(ref src) => {\n-            parse::parse_crate_attrs_from_source_str(\n-                driver::anon_src().to_string(),\n-                src.to_string(),\n-                Vec::new(),\n-                &sess.parse_sess)\n+            parse::parse_crate_attrs_from_source_str(driver::anon_src().to_string(),\n+                                                     src.to_string(),\n+                                                     Vec::new(),\n+                                                     &sess.parse_sess)\n         }\n     };\n     result.into_iter().collect()\n@@ -805,15 +831,17 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n-pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n+pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n     const STACK_SIZE: usize = 8 * 1024 * 1024; // 8MB\n \n     struct Sink(Arc<Mutex<Vec<u8>>>);\n     impl Write for Sink {\n         fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n             Write::write(&mut *self.0.lock().unwrap(), data)\n         }\n-        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+        fn flush(&mut self) -> io::Result<()> {\n+            Ok(())\n+        }\n     }\n \n     let data = Arc::new(Mutex::new(Vec::new()));\n@@ -827,8 +855,15 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    match cfg.spawn(move || { io::set_panic(box err); f() }).unwrap().join() {\n-        Ok(()) => { /* fallthrough */ }\n+    match cfg.spawn(move || {\n+                 io::set_panic(box err);\n+                 f()\n+             })\n+             .unwrap()\n+             .join() {\n+        Ok(()) => {\n+            // fallthrough\n+        }\n         Err(value) => {\n             // Thread panicked without emitting a fatal diagnostic\n             if !value.is::<diagnostic::FatalError>() {\n@@ -837,24 +872,19 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n                 // a .span_bug or .bug call has already printed what\n                 // it wants to print.\n                 if !value.is::<diagnostic::ExplicitBug>() {\n-                    emitter.emit(\n-                        None,\n-                        \"unexpected panic\",\n-                        None,\n-                        diagnostic::Bug);\n+                    emitter.emit(None, \"unexpected panic\", None, diagnostic::Bug);\n                 }\n \n-                let xs = [\n-                    \"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n-                    format!(\"we would appreciate a bug report: {}\",\n-                            BUG_REPORT_URL),\n-                ];\n+                let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n+                          format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n                 for note in &xs {\n                     emitter.emit(None, &note[..], None, diagnostic::Note)\n                 }\n                 if let None = env::var_os(\"RUST_BACKTRACE\") {\n-                    emitter.emit(None, \"run with `RUST_BACKTRACE=1` for a backtrace\",\n-                                 None, diagnostic::Note);\n+                    emitter.emit(None,\n+                                 \"run with `RUST_BACKTRACE=1` for a backtrace\",\n+                                 None,\n+                                 diagnostic::Note);\n                 }\n \n                 println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());"}, {"sha": "bdad13526b8821378f1486869b33c755930d849e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 173, "deletions": 136, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "patch": "@@ -79,33 +79,34 @@ pub enum PpMode {\n \n pub fn parse_pretty(sess: &Session,\n                     name: &str,\n-                    extended: bool) -> (PpMode, Option<UserIdentifiedItem>) {\n+                    extended: bool)\n+                    -> (PpMode, Option<UserIdentifiedItem>) {\n     let mut split = name.splitn(2, '=');\n     let first = split.next().unwrap();\n     let opt_second = split.next();\n     let first = match (first, extended) {\n-        (\"normal\", _)       => PpmSource(PpmNormal),\n-        (\"identified\", _)   => PpmSource(PpmIdentified),\n+        (\"normal\", _) => PpmSource(PpmNormal),\n+        (\"identified\", _) => PpmSource(PpmIdentified),\n         (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n-        (\"expanded\", _)     => PpmSource(PpmExpanded),\n+        (\"expanded\", _) => PpmSource(PpmExpanded),\n         (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n         (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n-        (\"hir\", true)       => PpmHir(PpmNormal),\n+        (\"hir\", true) => PpmHir(PpmNormal),\n         (\"hir,identified\", true) => PpmHir(PpmIdentified),\n-        (\"hir,typed\", true)        => PpmHir(PpmTyped),\n-        (\"flowgraph\", true)    => PpmFlowGraph(PpFlowGraphMode::Default),\n-        (\"flowgraph,unlabelled\", true)    => PpmFlowGraph(PpFlowGraphMode::UnlabelledEdges),\n+        (\"hir,typed\", true) => PpmHir(PpmTyped),\n+        (\"flowgraph\", true) => PpmFlowGraph(PpFlowGraphMode::Default),\n+        (\"flowgraph,unlabelled\", true) => PpmFlowGraph(PpFlowGraphMode::UnlabelledEdges),\n         _ => {\n             if extended {\n-                sess.fatal(&format!(\n-                    \"argument to `unpretty` must be one of `normal`, \\\n-                     `expanded`, `flowgraph[,unlabelled]=<nodeid>`, `identified`, \\\n-                     `expanded,identified`, `everybody_loops`, `hir`, \\\n-                     `hir,identified`, or `hir,typed`; got {}\", name));\n+                sess.fatal(&format!(\"argument to `unpretty` must be one of `normal`, \\\n+                                     `expanded`, `flowgraph[,unlabelled]=<nodeid>`, \\\n+                                     `identified`, `expanded,identified`, `everybody_loops`, \\\n+                                     `hir`, `hir,identified`, or `hir,typed`; got {}\",\n+                                    name));\n             } else {\n-                sess.fatal(&format!(\n-                    \"argument to `pretty` must be one of `normal`, `expanded`, \\\n-                     `identified`, or `expanded,identified`; got {}\", name));\n+                sess.fatal(&format!(\"argument to `pretty` must be one of `normal`, `expanded`, \\\n+                                     `identified`, or `expanded,identified`; got {}\",\n+                                    name));\n             }\n         }\n     };\n@@ -134,21 +135,31 @@ impl PpSourceMode {\n                                            sess: &'tcx Session,\n                                            ast_map: Option<hir_map::Map<'tcx>>,\n                                            payload: B,\n-                                           f: F) -> A where\n-        F: FnOnce(&PrinterSupport, B) -> A,\n+                                           f: F)\n+                                           -> A\n+        where F: FnOnce(&PrinterSupport, B) -> A\n     {\n         match *self {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n-                let annotation = NoAnn { sess: sess, ast_map: ast_map };\n+                let annotation = NoAnn {\n+                    sess: sess,\n+                    ast_map: ast_map,\n+                };\n                 f(&annotation, payload)\n             }\n \n             PpmIdentified | PpmExpandedIdentified => {\n-                let annotation = IdentifiedAnnotation { sess: sess, ast_map: ast_map };\n+                let annotation = IdentifiedAnnotation {\n+                    sess: sess,\n+                    ast_map: ast_map,\n+                };\n                 f(&annotation, payload)\n             }\n             PpmExpandedHygiene => {\n-                let annotation = HygieneAnnotation { sess: sess, ast_map: ast_map };\n+                let annotation = HygieneAnnotation {\n+                    sess: sess,\n+                    ast_map: ast_map,\n+                };\n                 f(&annotation, payload)\n             }\n             _ => panic!(\"Should use call_with_pp_support_hir\"),\n@@ -160,19 +171,23 @@ impl PpSourceMode {\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: &str,\n                                                payload: B,\n-                                               f: F) -> A where\n-        F: FnOnce(&HirPrinterSupport, B, &hir::Crate) -> A,\n+                                               f: F)\n+                                               -> A\n+        where F: FnOnce(&HirPrinterSupport, B, &hir::Crate) -> A\n     {\n         match *self {\n             PpmNormal => {\n-                let annotation = NoAnn { sess: sess, ast_map: Some(ast_map.clone()) };\n+                let annotation = NoAnn {\n+                    sess: sess,\n+                    ast_map: Some(ast_map.clone()),\n+                };\n                 f(&annotation, payload, &ast_map.forest.krate)\n             }\n \n             PpmIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess: sess,\n-                    ast_map: Some(ast_map.clone())\n+                    ast_map: Some(ast_map.clone()),\n                 };\n                 f(&annotation, payload, &ast_map.forest.krate)\n             }\n@@ -183,9 +198,13 @@ impl PpSourceMode {\n                                                     id,\n                                                     resolve::MakeGlobMap::No,\n                                                     |tcx, _, _| {\n-                    let annotation = TypedAnnotation { tcx: tcx };\n-                    f(&annotation, payload, &ast_map.forest.krate)\n-                })\n+                                                        let annotation = TypedAnnotation {\n+                                                            tcx: tcx,\n+                                                        };\n+                                                        f(&annotation,\n+                                                          payload,\n+                                                          &ast_map.forest.krate)\n+                                                    })\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n         }\n@@ -226,27 +245,35 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n \n struct NoAnn<'ast> {\n     sess: &'ast Session,\n-    ast_map: Option<hir_map::Map<'ast>>\n+    ast_map: Option<hir_map::Map<'ast>>,\n }\n \n impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session {\n+        self.sess\n+    }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n \n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn {\n+        self\n+    }\n }\n \n impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session {\n+        self.sess\n+    }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n \n-    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn {\n+        self\n+    }\n }\n \n impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n@@ -258,27 +285,27 @@ struct IdentifiedAnnotation<'ast> {\n }\n \n impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session {\n+        self.sess\n+    }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n \n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn {\n+        self\n+    }\n }\n \n impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n-    fn pre(&self,\n-           s: &mut pprust::State,\n-           node: pprust::AnnNode) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeExpr(_) => s.popen(),\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n-    fn post(&self,\n-            s: &mut pprust::State,\n-            node: pprust::AnnNode) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeIdent(_) | pprust::NodeName(_) => Ok(()),\n \n@@ -308,27 +335,27 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n }\n \n impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session {\n+        self.sess\n+    }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n \n-    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn {\n+        self\n+    }\n }\n \n impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n-    fn pre(&self,\n-           s: &mut pprust_hir::State,\n-           node: pprust_hir::AnnNode) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(_) => s.popen(),\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n-    fn post(&self,\n-            s: &mut pprust_hir::State,\n-            node: pprust_hir::AnnNode) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeName(_) => Ok(()),\n             pprust_hir::NodeItem(item) => {\n@@ -362,19 +389,21 @@ struct HygieneAnnotation<'ast> {\n }\n \n impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n+    fn sess<'a>(&'a self) -> &'a Session {\n+        self.sess\n+    }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n \n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn {\n+        self\n+    }\n }\n \n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n-    fn post(&self,\n-            s: &mut pprust::State,\n-            node: pprust::AnnNode) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeIdent(&ast::Ident { name: ast::Name(nm), ctxt }) => {\n                 try!(pp::space(&mut s.s));\n@@ -386,7 +415,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n                 try!(pp::space(&mut s.s));\n                 s.synth_comment(nm.to_string())\n             }\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n }\n@@ -397,37 +426,36 @@ struct TypedAnnotation<'a, 'tcx: 'a> {\n }\n \n impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.tcx.sess }\n+    fn sess<'a>(&'a self) -> &'a Session {\n+        &self.tcx.sess\n+    }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'tcx>> {\n         Some(&self.tcx.map)\n     }\n \n-    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n+    fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn {\n+        self\n+    }\n }\n \n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n-    fn pre(&self,\n-           s: &mut pprust_hir::State,\n-           node: pprust_hir::AnnNode) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(_) => s.popen(),\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n-    fn post(&self,\n-            s: &mut pprust_hir::State,\n-            node: pprust_hir::AnnNode) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n-                try!(pp::word(&mut s.s,\n-                              &self.tcx.expr_ty(expr).to_string()));\n+                try!(pp::word(&mut s.s, &self.tcx.expr_ty(expr).to_string()));\n                 s.pclose()\n             }\n-            _ => Ok(())\n+            _ => Ok(()),\n         }\n     }\n }\n@@ -459,9 +487,9 @@ pub enum UserIdentifiedItem {\n impl FromStr for UserIdentifiedItem {\n     type Err = ();\n     fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n-        Ok(s.parse().map(ItemViaNode).unwrap_or_else(|_| {\n-            ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())\n-        }))\n+        Ok(s.parse()\n+            .map(ItemViaNode)\n+            .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n     }\n }\n \n@@ -489,24 +517,22 @@ impl UserIdentifiedItem {\n         }\n     }\n \n-    fn all_matching_node_ids<'a, 'ast>(&'a self, map: &'a hir_map::Map<'ast>)\n+    fn all_matching_node_ids<'a, 'ast>(&'a self,\n+                                       map: &'a hir_map::Map<'ast>)\n                                        -> NodesMatchingUII<'a, 'ast> {\n         match *self {\n-            ItemViaNode(node_id) =>\n-                NodesMatchingDirect(Some(node_id).into_iter()),\n-            ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(&parts[..])),\n+            ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n+            ItemViaPath(ref parts) => NodesMatchingSuffix(map.nodes_matching_suffix(&parts[..])),\n         }\n     }\n \n     fn to_one_node_id(self, user_option: &str, sess: &Session, map: &hir_map::Map) -> ast::NodeId {\n         let fail_because = |is_wrong_because| -> ast::NodeId {\n-            let message =\n-                format!(\"{} needs NodeId (int) or unique \\\n-                         path suffix (b::c::d); got {}, which {}\",\n-                        user_option,\n-                        self.reconstructed_input(),\n-                        is_wrong_because);\n+            let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n+                                   {}, which {}\",\n+                                  user_option,\n+                                  self.reconstructed_input(),\n+                                  is_wrong_because);\n             sess.fatal(&message[..])\n         };\n \n@@ -608,12 +634,13 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     }\n \n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n-        fn expr_to_block(rules: ast::BlockCheckMode,\n-                         e: Option<P<ast::Expr>>) -> P<ast::Block> {\n+        fn expr_to_block(rules: ast::BlockCheckMode, e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                 expr: e,\n-                stmts: vec![], rules: rules,\n-                id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP,\n+                stmts: vec![],\n+                rules: rules,\n+                id: ast::DUMMY_NODE_ID,\n+                span: codemap::DUMMY_SP,\n             })\n         }\n \n@@ -622,7 +649,8 @@ impl fold::Folder for ReplaceBodyWithLoop {\n             let empty_block = expr_to_block(ast::DefaultBlock, None);\n             let loop_expr = P(ast::Expr {\n                 node: ast::ExprLoop(empty_block, None),\n-                id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP\n+                id: ast::DUMMY_NODE_ID,\n+                span: codemap::DUMMY_SP,\n             });\n \n             expr_to_block(b.rules, Some(loop_expr))\n@@ -661,7 +689,7 @@ pub fn pretty_print_input(sess: Session,\n     let krate = if compute_ast_map {\n         match driver::phase_2_configure_and_expand(&sess, krate, &id[..], None) {\n             None => return,\n-            Some(k) => driver::assign_node_ids(&sess, k)\n+            Some(k) => driver::assign_node_ids(&sess, k),\n         }\n     } else {\n         krate\n@@ -681,12 +709,13 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(&src_name[..])\n-                            .src\n-                            .as_ref()\n-                            .unwrap()\n-                            .as_bytes()\n-                            .to_vec();\n+    let src = sess.codemap()\n+                  .get_filemap(&src_name[..])\n+                  .src\n+                  .as_ref()\n+                  .unwrap()\n+                  .as_bytes()\n+                  .to_vec();\n     let mut rdr = &src[..];\n \n     let mut out = Vec::new();\n@@ -695,36 +724,39 @@ pub fn pretty_print_input(sess: Session,\n         (PpmSource(s), _) => {\n             // Silently ignores an identified node.\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support(\n-                &sess, ast_map, box out, |annotation, out| {\n-                    debug!(\"pretty printing source code {:?}\", s);\n-                    let sess = annotation.sess();\n-                    pprust::print_crate(sess.codemap(),\n-                                        sess.diagnostic(),\n-                                        &krate,\n-                                        src_name.to_string(),\n-                                        &mut rdr,\n-                                        out,\n-                                        annotation.pp_ann(),\n-                                        is_expanded)\n+            s.call_with_pp_support(&sess, ast_map, box out, |annotation, out| {\n+                debug!(\"pretty printing source code {:?}\", s);\n+                let sess = annotation.sess();\n+                pprust::print_crate(sess.codemap(),\n+                                    sess.diagnostic(),\n+                                    &krate,\n+                                    src_name.to_string(),\n+                                    &mut rdr,\n+                                    out,\n+                                    annotation.pp_ann(),\n+                                    is_expanded)\n             })\n         }\n \n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(\n-                &sess, &ast_map.unwrap(), &arenas, &id, box out, |annotation, out, krate| {\n-                    debug!(\"pretty printing source code {:?}\", s);\n-                    let sess = annotation.sess();\n-                    pprust_hir::print_crate(sess.codemap(),\n-                                            sess.diagnostic(),\n-                                            krate,\n-                                            src_name.to_string(),\n-                                            &mut rdr,\n-                                            out,\n-                                            annotation.pp_ann(),\n-                                            is_expanded)\n-            })\n+            s.call_with_pp_support_hir(&sess,\n+                                       &ast_map.unwrap(),\n+                                       &arenas,\n+                                       &id,\n+                                       box out,\n+                                       |annotation, out, krate| {\n+                                           debug!(\"pretty printing source code {:?}\", s);\n+                                           let sess = annotation.sess();\n+                                           pprust_hir::print_crate(sess.codemap(),\n+                                                                   sess.diagnostic(),\n+                                                                   krate,\n+                                                                   src_name.to_string(),\n+                                                                   &mut rdr,\n+                                                                   out,\n+                                                                   annotation.pp_ann(),\n+                                                                   is_expanded)\n+                                       })\n         }\n \n         (PpmHir(s), Some(uii)) => {\n@@ -761,15 +793,15 @@ pub fn pretty_print_input(sess: Session,\n             debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(&format!(\"`pretty flowgraph=..` needs NodeId (int) or\n+                                     \\\n                                      unique path suffix (b::c::d)\"))\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n-                sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid))\n+                sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n             });\n \n             let code = blocks::Code::from_node(node);\n@@ -783,32 +815,36 @@ pub fn pretty_print_input(sess: Session,\n                                                         &id,\n                                                         resolve::MakeGlobMap::No,\n                                                         |tcx, _, _| {\n-                        print_flowgraph(variants, tcx, code, mode, out)\n-                    })\n+                                                            print_flowgraph(variants,\n+                                                                            tcx,\n+                                                                            code,\n+                                                                            mode,\n+                                                                            out)\n+                                                        })\n                 }\n                 None => {\n-                    let message = format!(\"--pretty=flowgraph needs \\\n-                                           block, fn, or method; got {:?}\",\n+                    let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\\n+                                           {:?}\",\n                                           node);\n \n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n                         Some(sp) => sess.span_fatal(sp, &message[..]),\n-                        None => sess.fatal(&message[..])\n+                        None => sess.fatal(&message[..]),\n                     }\n                 }\n             }\n         }\n-    }.unwrap();\n+    }\n+    .unwrap();\n \n     match ofile {\n         None => print!(\"{}\", String::from_utf8(out).unwrap()),\n         Some(p) => {\n             match File::create(&p) {\n                 Ok(mut w) => w.write_all(&out).unwrap(),\n-                Err(e) => panic!(\"print-print failed to open {} due to {}\",\n-                                p.display(), e),\n+                Err(e) => panic!(\"print-print failed to open {} due to {}\", p.display(), e),\n             }\n         }\n     }\n@@ -818,7 +854,8 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n                              tcx: &ty::ctxt,\n                              code: blocks::Code,\n                              mode: PpFlowGraphMode,\n-                             mut out: W) -> io::Result<()> {\n+                             mut out: W)\n+                             -> io::Result<()> {\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(tcx, &*block),\n         blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &*fn_like.body()),\n@@ -837,14 +874,14 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n             return expand_err_details(r);\n         }\n         blocks::BlockCode(_) => {\n-            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print \\\n-                          annotations requires fn-like node id.\");\n-            return Ok(())\n+            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n+                          fn-like node id.\");\n+            return Ok(());\n         }\n         blocks::FnLikeCode(fn_like) => {\n             let fn_parts = borrowck::FnPartsWithCFG::from_fn_like(&fn_like, &cfg);\n-            let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_parts);\n+            let (bccx, analysis_data) = borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n+                                                                                      fn_parts);\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,"}, {"sha": "27ffb595a40510d54e410943bb707106c0894ebf", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "patch": "@@ -48,51 +48,40 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n \n \n fn features_contain(sess: &Session, s: &str) -> bool {\n-    sess.target.target.options.features.contains(s) ||\n-        sess.opts.cg.target_feature.contains(s)\n+    sess.target.target.options.features.contains(s) || sess.opts.cg.target_feature.contains(s)\n }\n \n pub fn has_sse(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse\") ||\n-        has_sse2(sess)\n+    features_contain(sess, \"+sse\") || has_sse2(sess)\n }\n pub fn has_sse2(sess: &Session) -> bool {\n     // x86-64 requires at least SSE2 support\n-    sess.target.target.arch == \"x86_64\" ||\n-        features_contain(sess, \"+sse2\") ||\n-        has_sse3(sess)\n+    sess.target.target.arch == \"x86_64\" || features_contain(sess, \"+sse2\") || has_sse3(sess)\n }\n pub fn has_sse3(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse3\") ||\n-        has_ssse3(sess)\n+    features_contain(sess, \"+sse3\") || has_ssse3(sess)\n }\n pub fn has_ssse3(sess: &Session) -> bool {\n-    features_contain(sess, \"+ssse3\") ||\n-        has_sse41(sess)\n+    features_contain(sess, \"+ssse3\") || has_sse41(sess)\n }\n pub fn has_sse41(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse4.1\") ||\n-        has_sse42(sess)\n+    features_contain(sess, \"+sse4.1\") || has_sse42(sess)\n }\n pub fn has_sse42(sess: &Session) -> bool {\n-    features_contain(sess, \"+sse4.2\") ||\n-        has_avx(sess)\n+    features_contain(sess, \"+sse4.2\") || has_avx(sess)\n }\n pub fn has_avx(sess: &Session) -> bool {\n-    features_contain(sess, \"+avx\") ||\n-        has_avx2(sess)\n+    features_contain(sess, \"+avx\") || has_avx2(sess)\n }\n pub fn has_avx2(sess: &Session) -> bool {\n     features_contain(sess, \"+avx2\")\n }\n \n pub fn has_neon(sess: &Session) -> bool {\n     // AArch64 requires NEON support\n-    sess.target.target.arch == \"aarch64\" ||\n-        features_contain(sess, \"+neon\")\n+    sess.target.target.arch == \"aarch64\" || features_contain(sess, \"+neon\")\n }\n pub fn has_vfp(sess: &Session) -> bool {\n     // AArch64 requires VFP support\n-    sess.target.target.arch == \"aarch64\" ||\n-        features_contain(sess, \"+vfp\")\n+    sess.target.target.arch == \"aarch64\" || features_contain(sess, \"+vfp\")\n }"}, {"sha": "fe9cf7cc3875f5505406df3eac990929778a859c", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 103, "deletions": 122, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e64645228f911701cee3b6b5a7bdc4550e2d5b6/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=4e64645228f911701cee3b6b5a7bdc4550e2d5b6", "patch": "@@ -30,7 +30,7 @@ use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n use rustc_typeck::middle::infer::sub::Sub;\n use rustc::front::map as hir_map;\n-use rustc::session::{self,config};\n+use rustc::session::{self, config};\n use syntax::{abi, ast};\n use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n@@ -47,19 +47,21 @@ struct Env<'a, 'tcx: 'a> {\n \n struct RH<'a> {\n     id: ast::NodeId,\n-    sub: &'a [RH<'a>]\n+    sub: &'a [RH<'a>],\n }\n \n const EMPTY_SOURCE_STR: &'static str = \"#![feature(no_core)] #![no_core]\";\n \n struct ExpectErrorEmitter {\n-    messages: Vec<String>\n+    messages: Vec<String>,\n }\n \n fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     match lvl {\n-        Bug | Fatal | Error => { }\n-        Warning | Note | Help => { return; }\n+        Bug | Fatal | Error => {}\n+        Warning | Note | Help => {\n+            return;\n+        }\n     }\n \n     debug!(\"Error: {}\", msg);\n@@ -68,8 +70,7 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n             e.messages.remove(i);\n         }\n         None => {\n-            panic!(\"Unexpected error: {} Expected: {:?}\",\n-                  msg, e.messages);\n+            panic!(\"Unexpected error: {} Expected: {:?}\", msg, e.messages);\n         }\n     }\n }\n@@ -79,41 +80,32 @@ impl Emitter for ExpectErrorEmitter {\n             _cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             _: Option<&str>,\n-            lvl: Level)\n-    {\n+            lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n \n-    fn custom_emit(&mut self,\n-                   _cm: &codemap::CodeMap,\n-                   _sp: RenderSpan,\n-                   msg: &str,\n-                   lvl: Level)\n-    {\n+    fn custom_emit(&mut self, _cm: &codemap::CodeMap, _sp: RenderSpan, msg: &str, lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n }\n \n-fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, usize) {\n+fn errors(msgs: &[&str]) -> (Box<Emitter + Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n-    (box ExpectErrorEmitter { messages: v } as Box<Emitter+Send>, msgs.len())\n+    (box ExpectErrorEmitter { messages: v } as Box<Emitter + Send>,\n+     msgs.len())\n }\n \n fn test_env<F>(source_string: &str,\n-               (emitter, expected_err_count): (Box<Emitter+Send>, usize),\n-               body: F) where\n-    F: FnOnce(Env),\n+               (emitter, expected_err_count): (Box<Emitter + Send>, usize),\n+               body: F)\n+    where F: FnOnce(Env)\n {\n-    let mut options =\n-        config::basic_options();\n+    let mut options = config::basic_options();\n     options.debugging_opts.verbose = true;\n     options.unstable_features = UnstableFeatures::Allow;\n-    let codemap =\n-        CodeMap::new();\n-    let diagnostic_handler =\n-        diagnostic::Handler::with_emitter(true, emitter);\n-    let span_diagnostic_handler =\n-        diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n+    let codemap = CodeMap::new();\n+    let diagnostic_handler = diagnostic::Handler::with_emitter(true, emitter);\n+    let span_diagnostic_handler = diagnostic::SpanHandler::new(diagnostic_handler, codemap);\n \n     let sess = session::build_session_(options, None, span_diagnostic_handler);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n@@ -146,12 +138,13 @@ fn test_env<F>(source_string: &str,\n                                lang_items,\n                                stability::Index::new(krate),\n                                |tcx| {\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n-        body(Env { infcx: &infcx });\n-        let free_regions = FreeRegionMap::new();\n-        infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n-        assert_eq!(tcx.sess.err_count(), expected_err_count);\n-    });\n+                                   let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+                                   body(Env { infcx: &infcx });\n+                                   let free_regions = FreeRegionMap::new();\n+                                   infcx.resolve_regions_and_report_errors(&free_regions,\n+                                                                           ast::CRATE_NODE_ID);\n+                                   assert_eq!(tcx.sess.err_count(), expected_err_count);\n+                               });\n }\n \n impl<'a, 'tcx> Env<'a, 'tcx> {\n@@ -169,15 +162,16 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn create_simple_region_hierarchy(&self) {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n-        let dscope = self.infcx.tcx.region_maps.intern_code_extent(\n-            CodeExtentData::DestructionScope(1), region::ROOT_CODE_EXTENT);\n-        self.create_region_hierarchy(\n-            &RH {id: 1,\n-                 sub: &[RH {id: 10,\n-                            sub: &[]},\n-                        RH {id: 11,\n-                            sub: &[]}]},\n-            dscope);\n+        let dscope = self.infcx\n+                         .tcx\n+                         .region_maps\n+                         .intern_code_extent(CodeExtentData::DestructionScope(1),\n+                                             region::ROOT_CODE_EXTENT);\n+        self.create_region_hierarchy(&RH {\n+                                         id: 1,\n+                                         sub: &[RH { id: 10, sub: &[] }, RH { id: 11, sub: &[] }],\n+                                     },\n+                                     dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -197,30 +191,32 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             assert!(idx < names.len());\n             for item in &m.items {\n                 if item.name.to_string() == names[idx] {\n-                    return search(this, &**item, idx+1, names);\n+                    return search(this, &**item, idx + 1, names);\n                 }\n             }\n             return None;\n         }\n \n-        fn search(this: &Env,\n-                  it: &hir::Item,\n-                  idx: usize,\n-                  names: &[String])\n-                  -> Option<ast::NodeId> {\n+        fn search(this: &Env, it: &hir::Item, idx: usize, names: &[String]) -> Option<ast::NodeId> {\n             if idx == names.len() {\n                 return Some(it.id);\n             }\n \n             return match it.node {\n-                hir::ItemUse(..) | hir::ItemExternCrate(..) |\n-                hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n-                hir::ItemForeignMod(..) | hir::ItemTy(..) => {\n+                hir::ItemUse(..) |\n+                hir::ItemExternCrate(..) |\n+                hir::ItemConst(..) |\n+                hir::ItemStatic(..) |\n+                hir::ItemFn(..) |\n+                hir::ItemForeignMod(..) |\n+                hir::ItemTy(..) => {\n                     None\n                 }\n \n-                hir::ItemEnum(..) | hir::ItemStruct(..) |\n-                hir::ItemTrait(..) | hir::ItemImpl(..) |\n+                hir::ItemEnum(..) |\n+                hir::ItemStruct(..) |\n+                hir::ItemTrait(..) |\n+                hir::ItemImpl(..) |\n                 hir::ItemDefaultImpl(..) => {\n                     None\n                 }\n@@ -235,14 +231,14 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n-            Err(ref e) => panic!(\"Encountered error: {}\", e)\n+            Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }\n     }\n \n     pub fn is_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match infer::can_mk_subty(self.infcx, a, b) {\n             Ok(_) => true,\n-            Err(_) => false\n+            Err(_) => false,\n         }\n     }\n \n@@ -257,22 +253,18 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn t_fn(&self,\n-                input_tys: &[Ty<'tcx>],\n-                output_ty: Ty<'tcx>)\n-                -> Ty<'tcx>\n-    {\n+    pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n         let input_args = input_tys.iter().cloned().collect();\n         self.infcx.tcx.mk_fn(None,\n-            self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n-                unsafety: hir::Unsafety::Normal,\n-                abi: abi::Rust,\n-                sig: ty::Binder(ty::FnSig {\n-                    inputs: input_args,\n-                    output: ty::FnConverging(output_ty),\n-                    variadic: false\n-                })\n-            }))\n+                             self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n+                                 unsafety: hir::Unsafety::Normal,\n+                                 abi: abi::Rust,\n+                                 sig: ty::Binder(ty::FnSig {\n+                                     inputs: input_args,\n+                                     output: ty::FnConverging(output_ty),\n+                                     variadic: false,\n+                                 }),\n+                             }))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n@@ -292,14 +284,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                           space: subst::ParamSpace,\n                           index: u32,\n                           name: &'static str)\n-                          -> ty::Region\n-    {\n+                          -> ty::Region {\n         let name = token::intern(name);\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n             def_id: self.infcx.tcx.map.local_def_id(ast::DUMMY_NODE_ID),\n             space: space,\n             index: index,\n-            name: name\n+            name: name,\n         })\n     }\n \n@@ -308,52 +299,47 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n-                                   self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n-                                   self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n                                            id: u32,\n                                            debruijn: ty::DebruijnIndex)\n                                            -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n-                                   self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(self.tcx().region_maps.node_extent(id));\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n-                                   self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n         ty::ReFree(ty::FreeRegion {\n             scope: self.tcx().region_maps.item_extent(nid),\n-            bound_region: ty::BrAnon(id)\n+            bound_region: ty::BrAnon(id),\n         })\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n         let r = self.re_free(nid, id);\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n-                                   self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReStatic),\n-                                   self.tcx().types.isize)\n+                                  self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_empty(&self) -> Ty<'tcx> {\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReEmpty),\n-                                   self.tcx().types.isize)\n+                                  self.tcx().types.isize)\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n@@ -378,20 +364,17 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n         match self.lub().relate(&t1, &t2) {\n             Ok(t) => t,\n-            Err(ref e) => panic!(\"unexpected error computing LUB: {}\", e)\n+            Err(ref e) => panic!(\"unexpected error computing LUB: {}\", e),\n         }\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub().relate(&t1, &t2) {\n-            Ok(_) => { }\n+            Ok(_) => {}\n             Err(ref e) => {\n-                panic!(\"unexpected error computing sub({:?},{:?}): {}\",\n-                       t1,\n-                       t2,\n-                       e);\n+                panic!(\"unexpected error computing sub({:?},{:?}): {}\", t1, t2, e);\n             }\n         }\n     }\n@@ -400,11 +383,9 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// region checks).\n     pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub().relate(&t1, &t2) {\n-            Err(_) => { }\n+            Err(_) => {}\n             Ok(_) => {\n-                panic!(\"unexpected success computing sub({:?},{:?})\",\n-                       t1,\n-                       t2);\n+                panic!(\"unexpected success computing sub({:?},{:?})\", t1, t2);\n             }\n         }\n     }\n@@ -453,18 +434,16 @@ fn contravariant_region_ptr_ok() {\n \n #[test]\n fn contravariant_region_ptr_err() {\n-    test_env(EMPTY_SOURCE_STR,\n-             errors(&[\"lifetime mismatch\"]),\n-             |env| {\n-                 env.create_simple_region_hierarchy();\n-                 let t_rptr1 = env.t_rptr_scope(1);\n-                 let t_rptr10 = env.t_rptr_scope(10);\n-                 env.assert_eq(t_rptr1, t_rptr1);\n-                 env.assert_eq(t_rptr10, t_rptr10);\n-\n-                 // will cause an error when regions are resolved\n-                 env.make_subtype(t_rptr10, t_rptr1);\n-             })\n+    test_env(EMPTY_SOURCE_STR, errors(&[\"lifetime mismatch\"]), |env| {\n+        env.create_simple_region_hierarchy();\n+        let t_rptr1 = env.t_rptr_scope(1);\n+        let t_rptr10 = env.t_rptr_scope(10);\n+        env.assert_eq(t_rptr1, t_rptr1);\n+        env.assert_eq(t_rptr10, t_rptr10);\n+\n+        // will cause an error when regions are resolved\n+        env.make_subtype(t_rptr10, t_rptr1);\n+    })\n }\n \n #[test]\n@@ -661,8 +640,10 @@ fn glb_bound_free_infer() {\n         // `&'_ isize`\n         let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n         match t_resolve1.sty {\n-            ty::TyRef(..) => { }\n-            _ => { panic!(\"t_resolve1={:?}\", t_resolve1); }\n+            ty::TyRef(..) => {}\n+            _ => {\n+                panic!(\"t_resolve1={:?}\", t_resolve1);\n+            }\n         }\n     })\n }\n@@ -819,15 +800,13 @@ fn walk_ty() {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n         let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.mk_tup(vec!(int_ty, uint_ty, int_ty, uint_ty));\n-        let tup2_ty = tcx.mk_tup(vec!(tup1_ty, tup1_ty, uint_ty));\n+        let tup1_ty = tcx.mk_tup(vec![int_ty, uint_ty, int_ty, uint_ty]);\n+        let tup2_ty = tcx.mk_tup(vec![tup1_ty, tup1_ty, uint_ty]);\n         let uniq_ty = tcx.mk_box(tup2_ty);\n         let walked: Vec<_> = uniq_ty.walk().collect();\n-        assert_eq!(walked, [uniq_ty,\n-                            tup2_ty,\n-                            tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                            tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                            uint_ty]);\n+        assert_eq!(walked,\n+                   [uniq_ty, tup2_ty, tup1_ty, int_ty, uint_ty, int_ty, uint_ty, tup1_ty, int_ty,\n+                    uint_ty, int_ty, uint_ty, uint_ty]);\n     })\n }\n \n@@ -837,29 +816,31 @@ fn walk_ty_skip_subtree() {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n         let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.mk_tup(vec!(int_ty, uint_ty, int_ty, uint_ty));\n-        let tup2_ty = tcx.mk_tup(vec!(tup1_ty, tup1_ty, uint_ty));\n+        let tup1_ty = tcx.mk_tup(vec![int_ty, uint_ty, int_ty, uint_ty]);\n+        let tup2_ty = tcx.mk_tup(vec![tup1_ty, tup1_ty, uint_ty]);\n         let uniq_ty = tcx.mk_box(tup2_ty);\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree.\n-        let mut expected = vec!((uniq_ty, false),\n+        let mut expected = vec![(uniq_ty, false),\n                                 (tup2_ty, false),\n                                 (tup1_ty, false),\n                                 (int_ty, false),\n                                 (uint_ty, false),\n                                 (int_ty, false),\n                                 (uint_ty, false),\n                                 (tup1_ty, true), // skip the isize/usize/isize/usize\n-                                (uint_ty, false));\n+                                (uint_ty, false)];\n         expected.reverse();\n \n         let mut walker = uniq_ty.walk();\n         while let Some(t) = walker.next() {\n             debug!(\"walked to {:?}\", t);\n             let (expected_ty, skip) = expected.pop().unwrap();\n             assert_eq!(t, expected_ty);\n-            if skip { walker.skip_current_subtree(); }\n+            if skip {\n+                walker.skip_current_subtree();\n+            }\n         }\n \n         assert!(expected.is_empty());"}]}