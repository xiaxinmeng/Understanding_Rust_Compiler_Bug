{"sha": "039ab2e820defdee3b547c765739614ccbfd3c44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzOWFiMmU4MjBkZWZkZWUzYjU0N2M3NjU3Mzk2MTRjY2JmZDNjNDQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-16T17:47:59Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-17T01:31:53Z"}, "message": "Simpliy code", "tree": {"sha": "8c919e0fbc7875611c8d2674d6f5995a58908eec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c919e0fbc7875611c8d2674d6f5995a58908eec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/039ab2e820defdee3b547c765739614ccbfd3c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/039ab2e820defdee3b547c765739614ccbfd3c44", "html_url": "https://github.com/rust-lang/rust/commit/039ab2e820defdee3b547c765739614ccbfd3c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/039ab2e820defdee3b547c765739614ccbfd3c44/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0edb5ce97a000c3da1e0eb1792d031d945ce5dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/0edb5ce97a000c3da1e0eb1792d031d945ce5dba", "html_url": "https://github.com/rust-lang/rust/commit/0edb5ce97a000c3da1e0eb1792d031d945ce5dba"}], "stats": {"total": 92, "additions": 32, "deletions": 60}, "files": [{"sha": "d426d275e1817269d8450efc3056e2017907cc69", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 32, "deletions": 60, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/039ab2e820defdee3b547c765739614ccbfd3c44/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/039ab2e820defdee3b547c765739614ccbfd3c44/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=039ab2e820defdee3b547c765739614ccbfd3c44", "patch": "@@ -469,38 +469,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     let typable: Option<TypableDef> = def.into();\n                     let typable = typable?;\n \n-                    // For example, this substs will take `Gen::make::*<u32>*`\n-                    let mut substs =\n-                        Ty::substs_from_path_segment(self.db, &self.resolver, segment, typable);\n+                    let mut ty = self.db.type_for_def(typable, Namespace::Types);\n \n                     if remaining_index > 0 {\n                         // For example, this substs will take `Gen::*<u32>*::make`\n-                        let parent_substs = Ty::substs_from_path_segment(\n+                        let substs = Ty::substs_from_path_segment(\n                             self.db,\n                             &self.resolver,\n                             &path.segments[remaining_index - 1],\n                             typable,\n                         );\n \n-                        // merge parent and child substs\n-                        let max_len = std::cmp::max(substs.len(), parent_substs.len());\n-                        let mut merged = vec![];\n-                        for i in 0..max_len {\n-                            let s = match (substs.0.get(i), parent_substs.0.get(i)) {\n-                                (Some(s @ Ty::Apply(_)), _) => s,\n-                                (_, Some(s @ Ty::Apply(_))) => s,\n-                                (Some(s), _) => s,\n-                                (_, Some(s)) => s,\n-                                _ => unreachable!(),\n-                            };\n-                            merged.push(s.clone());\n-                        }\n-\n-                        substs = Substs(merged.into());\n+                        ty = ty.subst(&substs);\n                     }\n \n-                    let ty = self.db.type_for_def(typable, Namespace::Types);\n-                    ty.subst(&substs)\n+                    ty\n                 }\n                 Resolution::LocalBinding(_) => {\n                     // can't have a local binding in an associated item path\n@@ -558,16 +541,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         match resolved {\n             Resolution::Def(def) => {\n-                let typable: Option<TypableDef> = def.into();\n-                let typable = typable?;\n-\n-                let ty = self.db.type_for_def(typable, Namespace::Values);\n-                let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-                let ty = ty.subst(&substs);\n-                let ty = self.insert_type_vars(ty);\n-\n-                // plug the old parent_ty in\n-                let plug_self_types = || -> Option<()> {\n+                // Helpper function for finding self types\n+                let find_self_types = || -> Option<Substs> {\n                     let actual_def_ty = actual_def_ty?;\n \n                     if let crate::ModuleDef::Function(func) = def {\n@@ -577,43 +552,40 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             return None;\n                         }\n \n-                        let impl_block = func.impl_block(self.db)?;\n-                        let impl_block = impl_block.target_ty(self.db);\n+                        let impl_block = func.impl_block(self.db)?.target_ty(self.db);\n+                        let impl_block_substs = impl_block.substs()?;\n+                        let actual_substs = actual_def_ty.substs()?;\n \n-                        // We save the impl block type params for later use\n-                        let old_params = impl_block.substs().unwrap().clone();\n+                        let mut new_substs = vec![Ty::Unknown; gen.count_parent_params()];\n \n-                        // Turn the impl block generic params to unknown\n-                        let mut subst = vec![];\n-                        for _ in 0..impl_block.substs().map(|x| x.len()).unwrap_or(0) {\n-                            subst.push(Ty::Unknown);\n-                        }\n-                        let impl_block = impl_block.subst(&Substs(subst.into()));\n-                        let impl_block = self.insert_type_vars(impl_block);\n-\n-                        // Unify *self type* and impl_block\n-                        // e.g. Gen::<u32,u64> <=> Gen::<u64, T>\n-                        self.unify(&impl_block, &actual_def_ty);\n-\n-                        // The following code *link up* the function parent generic param\n-                        // and the impl_block generic param by unify them one by one\n-                        if let Ty::Apply(ty) = &ty {\n-                            old_params.iter().zip(impl_block.substs()?.iter()).for_each(\n-                                |(param, pty)| {\n-                                    if let Ty::Param { idx, .. } = param {\n-                                        self.unify(pty, &ty.parameters.0[*idx as usize]);\n+                        // The following code *link up* the function actual parma type\n+                        // and impl_block type param index\n+                        impl_block_substs.iter().zip(actual_substs.iter()).for_each(\n+                            |(param, pty)| {\n+                                if let Ty::Param { idx, .. } = param {\n+                                    if let Some(s) = new_substs.get_mut(*idx as usize) {\n+                                        *s = pty.clone();\n                                     }\n-                                },\n-                            );\n-                        }\n+                                }\n+                            },\n+                        );\n \n-                        return Some(());\n+                        Some(Substs(new_substs.into()))\n+                    } else {\n+                        None\n                     }\n-                    None\n                 };\n \n-                plug_self_types();\n+                let typable: Option<TypableDef> = def.into();\n+                let typable = typable?;\n+                let mut ty = self.db.type_for_def(typable, Namespace::Values);\n+                if let Some(sts) = find_self_types() {\n+                    ty = ty.subst(&sts);\n+                }\n \n+                let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+                let ty = ty.subst(&substs);\n+                let ty = self.insert_type_vars(ty);\n                 Some(ty)\n             }\n             Resolution::LocalBinding(pat) => {"}]}