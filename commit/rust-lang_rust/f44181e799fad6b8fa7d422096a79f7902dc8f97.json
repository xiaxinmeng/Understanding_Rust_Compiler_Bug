{"sha": "f44181e799fad6b8fa7d422096a79f7902dc8f97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NDE4MWU3OTlmYWQ2YjhmYTdkNDIyMDk2YTc5Zjc5MDJkYzhmOTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-03T11:32:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-03T11:32:51Z"}, "message": "Auto merge of #5047 - flip1995:use_debug, r=phansch\n\nDon't trigger use_debug lint in Debug impl\n\nFixes #5039\n\nchangelog: Don't trigger [`use_debug`] lint in Debug impl", "tree": {"sha": "3428e6db1c53948699d5e3196389a5693108ec30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3428e6db1c53948699d5e3196389a5693108ec30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f44181e799fad6b8fa7d422096a79f7902dc8f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f44181e799fad6b8fa7d422096a79f7902dc8f97", "html_url": "https://github.com/rust-lang/rust/commit/f44181e799fad6b8fa7d422096a79f7902dc8f97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f44181e799fad6b8fa7d422096a79f7902dc8f97/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d3e3e1a9ea9968bdb6474fe8106850dbf645480", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3e3e1a9ea9968bdb6474fe8106850dbf645480", "html_url": "https://github.com/rust-lang/rust/commit/5d3e3e1a9ea9968bdb6474fe8106850dbf645480"}, {"sha": "a540b5ca2e4128857ac271f1aea26fe3023764ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/a540b5ca2e4128857ac271f1aea26fe3023764ee", "html_url": "https://github.com/rust-lang/rust/commit/a540b5ca2e4128857ac271f1aea26fe3023764ee"}], "stats": {"total": 286, "additions": 158, "deletions": 128}, "files": [{"sha": "4157d33079ca77451e863e7c7d0623907fff51c3", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44181e799fad6b8fa7d422096a79f7902dc8f97/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44181e799fad6b8fa7d422096a79f7902dc8f97/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f44181e799fad6b8fa7d422096a79f7902dc8f97", "patch": "@@ -330,7 +330,7 @@ mod reexport {\n ///\n /// Used in `./src/driver.rs`.\n pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, conf: &Conf) {\n-    store.register_pre_expansion_pass(|| box write::Write);\n+    store.register_pre_expansion_pass(|| box write::Write::default());\n     store.register_pre_expansion_pass(|| box redundant_field_names::RedundantFieldNames);\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n     store.register_pre_expansion_pass(move || box non_expressive_names::NonExpressiveNames {"}, {"sha": "d772427889ed04f68c13b76f590f6ab3d0877ed9", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 156, "deletions": 120, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/f44181e799fad6b8fa7d422096a79f7902dc8f97/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44181e799fad6b8fa7d422096a79f7902dc8f97/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=f44181e799fad6b8fa7d422096a79f7902dc8f97", "patch": "@@ -2,14 +2,14 @@ use std::borrow::Cow;\n use std::ops::Range;\n \n use crate::utils::{snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then};\n-use rustc_ast::ast::{Expr, ExprKind, Mac, StrLit, StrStyle};\n+use rustc_ast::ast::{Expr, ExprKind, Item, ItemKind, Mac, StrLit, StrStyle};\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_errors::Applicability;\n use rustc_lexer::unescape::{self, EscapeError};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_parse::parser;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::Symbol;\n use rustc_span::{BytePos, Span};\n \n@@ -175,7 +175,12 @@ declare_clippy_lint! {\n     \"writing a literal with a format string\"\n }\n \n-declare_lint_pass!(Write => [\n+#[derive(Default)]\n+pub struct Write {\n+    in_debug_impl: bool,\n+}\n+\n+impl_lint_pass!(Write => [\n     PRINT_WITH_NEWLINE,\n     PRINTLN_EMPTY_STRING,\n     PRINT_STDOUT,\n@@ -187,10 +192,34 @@ declare_lint_pass!(Write => [\n ]);\n \n impl EarlyLintPass for Write {\n+    fn check_item(&mut self, _: &EarlyContext<'_>, item: &Item) {\n+        if let ItemKind::Impl {\n+            of_trait: Some(trait_ref),\n+            ..\n+        } = &item.kind\n+        {\n+            let trait_name = trait_ref\n+                .path\n+                .segments\n+                .iter()\n+                .last()\n+                .expect(\"path has at least one segment\")\n+                .ident\n+                .name;\n+            if trait_name == sym!(Debug) {\n+                self.in_debug_impl = true;\n+            }\n+        }\n+    }\n+\n+    fn check_item_post(&mut self, _: &EarlyContext<'_>, _: &Item) {\n+        self.in_debug_impl = false;\n+    }\n+\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &Mac) {\n         if mac.path == sym!(println) {\n             span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `println!`\");\n-            if let (Some(fmt_str), _) = check_tts(cx, &mac.args.inner_tokens(), false) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), false) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     span_lint_and_sugg(\n                         cx,\n@@ -205,7 +234,7 @@ impl EarlyLintPass for Write {\n             }\n         } else if mac.path == sym!(print) {\n             span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `print!`\");\n-            if let (Some(fmt_str), _) = check_tts(cx, &mac.args.inner_tokens(), false) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), false) {\n                 if check_newlines(&fmt_str) {\n                     span_lint_and_then(\n                         cx,\n@@ -226,7 +255,7 @@ impl EarlyLintPass for Write {\n                 }\n             }\n         } else if mac.path == sym!(write) {\n-            if let (Some(fmt_str), _) = check_tts(cx, &mac.args.inner_tokens(), true) {\n+            if let (Some(fmt_str), _) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n                 if check_newlines(&fmt_str) {\n                     span_lint_and_then(\n                         cx,\n@@ -247,7 +276,7 @@ impl EarlyLintPass for Write {\n                 }\n             }\n         } else if mac.path == sym!(writeln) {\n-            if let (Some(fmt_str), expr) = check_tts(cx, &mac.args.inner_tokens(), true) {\n+            if let (Some(fmt_str), expr) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n                     let suggestion = expr.map_or_else(\n@@ -296,129 +325,136 @@ fn newline_span(fmtstr: &StrLit) -> Span {\n     sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi)\n }\n \n-/// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n-/// `Option`s. The first `Option` of the tuple is the macro's format string. It includes\n-/// the contents of the string, whether it's a raw string, and the span of the literal in the\n-/// source. The second `Option` in the tuple is, in the `write[ln]!` case, the expression the\n-/// `format_str` should be written to.\n-///\n-/// Example:\n-///\n-/// Calling this function on\n-/// ```rust\n-/// # use std::fmt::Write;\n-/// # let mut buf = String::new();\n-/// # let something = \"something\";\n-/// writeln!(buf, \"string to write: {}\", something);\n-/// ```\n-/// will return\n-/// ```rust,ignore\n-/// (Some(\"string to write: {}\"), Some(buf))\n-/// ```\n-#[allow(clippy::too_many_lines)]\n-fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n-    use fmt_macros::{\n-        AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, Parser, Piece,\n-    };\n-    let tts = tts.clone();\n-\n-    let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, None, false, false, None);\n-    let mut expr: Option<Expr> = None;\n-    if is_write {\n-        expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n-            Ok(p) => Some(p.into_inner()),\n-            Err(_) => return (None, None),\n+impl Write {\n+    /// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n+    /// `Option`s. The first `Option` of the tuple is the macro's format string. It includes\n+    /// the contents of the string, whether it's a raw string, and the span of the literal in the\n+    /// source. The second `Option` in the tuple is, in the `write[ln]!` case, the expression the\n+    /// `format_str` should be written to.\n+    ///\n+    /// Example:\n+    ///\n+    /// Calling this function on\n+    /// ```rust\n+    /// # use std::fmt::Write;\n+    /// # let mut buf = String::new();\n+    /// # let something = \"something\";\n+    /// writeln!(buf, \"string to write: {}\", something);\n+    /// ```\n+    /// will return\n+    /// ```rust,ignore\n+    /// (Some(\"string to write: {}\"), Some(buf))\n+    /// ```\n+    #[allow(clippy::too_many_lines)]\n+    fn check_tts<'a>(\n+        &self,\n+        cx: &EarlyContext<'a>,\n+        tts: &TokenStream,\n+        is_write: bool,\n+    ) -> (Option<StrLit>, Option<Expr>) {\n+        use fmt_macros::{\n+            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, Parser, Piece,\n         };\n-        // might be `writeln!(foo)`\n-        if parser.expect(&token::Comma).map_err(|mut err| err.cancel()).is_err() {\n-            return (None, expr);\n-        }\n-    }\n+        let tts = tts.clone();\n \n-    let fmtstr = match parser.parse_str_lit() {\n-        Ok(fmtstr) => fmtstr,\n-        Err(_) => return (None, expr),\n-    };\n-    let tmp = fmtstr.symbol.as_str();\n-    let mut args = vec![];\n-    let mut fmt_parser = Parser::new(&tmp, None, Vec::new(), false);\n-    while let Some(piece) = fmt_parser.next() {\n-        if !fmt_parser.errors.is_empty() {\n-            return (None, expr);\n-        }\n-        if let Piece::NextArgument(arg) = piece {\n-            if arg.format.ty == \"?\" {\n-                // FIXME: modify rustc's fmt string parser to give us the current span\n-                span_lint(cx, USE_DEBUG, parser.prev_token.span, \"use of `Debug`-based formatting\");\n+        let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, None, false, false, None);\n+        let mut expr: Option<Expr> = None;\n+        if is_write {\n+            expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n+                Ok(p) => Some(p.into_inner()),\n+                Err(_) => return (None, None),\n+            };\n+            // might be `writeln!(foo)`\n+            if parser.expect(&token::Comma).map_err(|mut err| err.cancel()).is_err() {\n+                return (None, expr);\n             }\n-            args.push(arg);\n         }\n-    }\n-    let lint = if is_write { WRITE_LITERAL } else { PRINT_LITERAL };\n-    let mut idx = 0;\n-    loop {\n-        const SIMPLE: FormatSpec<'_> = FormatSpec {\n-            fill: None,\n-            align: AlignUnknown,\n-            flags: 0,\n-            precision: CountImplied,\n-            precision_span: None,\n-            width: CountImplied,\n-            width_span: None,\n-            ty: \"\",\n-            ty_span: None,\n+\n+        let fmtstr = match parser.parse_str_lit() {\n+            Ok(fmtstr) => fmtstr,\n+            Err(_) => return (None, expr),\n         };\n-        if !parser.eat(&token::Comma) {\n-            return (Some(fmtstr), expr);\n+        let tmp = fmtstr.symbol.as_str();\n+        let mut args = vec![];\n+        let mut fmt_parser = Parser::new(&tmp, None, Vec::new(), false);\n+        while let Some(piece) = fmt_parser.next() {\n+            if !fmt_parser.errors.is_empty() {\n+                return (None, expr);\n+            }\n+            if let Piece::NextArgument(arg) = piece {\n+                if !self.in_debug_impl && arg.format.ty == \"?\" {\n+                    // FIXME: modify rustc's fmt string parser to give us the current span\n+                    span_lint(cx, USE_DEBUG, parser.prev_token.span, \"use of `Debug`-based formatting\");\n+                }\n+                args.push(arg);\n+            }\n         }\n-        let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|mut err| err.cancel()) {\n-            expr\n-        } else {\n-            return (Some(fmtstr), None);\n-        };\n-        match &token_expr.kind {\n-            ExprKind::Lit(_) => {\n-                let mut all_simple = true;\n-                let mut seen = false;\n-                for arg in &args {\n-                    match arg.position {\n-                        ArgumentImplicitlyIs(n) | ArgumentIs(n) => {\n-                            if n == idx {\n-                                all_simple &= arg.format == SIMPLE;\n-                                seen = true;\n-                            }\n-                        },\n-                        ArgumentNamed(_) => {},\n+        let lint = if is_write { WRITE_LITERAL } else { PRINT_LITERAL };\n+        let mut idx = 0;\n+        loop {\n+            const SIMPLE: FormatSpec<'_> = FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountImplied,\n+                precision_span: None,\n+                width: CountImplied,\n+                width_span: None,\n+                ty: \"\",\n+                ty_span: None,\n+            };\n+            if !parser.eat(&token::Comma) {\n+                return (Some(fmtstr), expr);\n+            }\n+            let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|mut err| err.cancel()) {\n+                expr\n+            } else {\n+                return (Some(fmtstr), None);\n+            };\n+            match &token_expr.kind {\n+                ExprKind::Lit(_) => {\n+                    let mut all_simple = true;\n+                    let mut seen = false;\n+                    for arg in &args {\n+                        match arg.position {\n+                            ArgumentImplicitlyIs(n) | ArgumentIs(n) => {\n+                                if n == idx {\n+                                    all_simple &= arg.format == SIMPLE;\n+                                    seen = true;\n+                                }\n+                            },\n+                            ArgumentNamed(_) => {},\n+                        }\n                     }\n-                }\n-                if all_simple && seen {\n-                    span_lint(cx, lint, token_expr.span, \"literal with an empty format string\");\n-                }\n-                idx += 1;\n-            },\n-            ExprKind::Assign(lhs, rhs, _) => {\n-                if let ExprKind::Lit(_) = rhs.kind {\n-                    if let ExprKind::Path(_, p) = &lhs.kind {\n-                        let mut all_simple = true;\n-                        let mut seen = false;\n-                        for arg in &args {\n-                            match arg.position {\n-                                ArgumentImplicitlyIs(_) | ArgumentIs(_) => {},\n-                                ArgumentNamed(name) => {\n-                                    if *p == name {\n-                                        seen = true;\n-                                        all_simple &= arg.format == SIMPLE;\n-                                    }\n-                                },\n+                    if all_simple && seen {\n+                        span_lint(cx, lint, token_expr.span, \"literal with an empty format string\");\n+                    }\n+                    idx += 1;\n+                },\n+                ExprKind::Assign(lhs, rhs, _) => {\n+                    if let ExprKind::Lit(_) = rhs.kind {\n+                        if let ExprKind::Path(_, p) = &lhs.kind {\n+                            let mut all_simple = true;\n+                            let mut seen = false;\n+                            for arg in &args {\n+                                match arg.position {\n+                                    ArgumentImplicitlyIs(_) | ArgumentIs(_) => {},\n+                                    ArgumentNamed(name) => {\n+                                        if *p == name {\n+                                            seen = true;\n+                                            all_simple &= arg.format == SIMPLE;\n+                                        }\n+                                    },\n+                                }\n+                            }\n+                            if all_simple && seen {\n+                                span_lint(cx, lint, rhs.span, \"literal with an empty format string\");\n                             }\n-                        }\n-                        if all_simple && seen {\n-                            span_lint(cx, lint, rhs.span, \"literal with an empty format string\");\n                         }\n                     }\n-                }\n-            },\n-            _ => idx += 1,\n+                },\n+                _ => idx += 1,\n+            }\n         }\n     }\n }"}, {"sha": "208d95326285133812d440de7d0740216a34ee6e", "filename": "tests/ui/print.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44181e799fad6b8fa7d422096a79f7902dc8f97/tests%2Fui%2Fprint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f44181e799fad6b8fa7d422096a79f7902dc8f97/tests%2Fui%2Fprint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint.stderr?ref=f44181e799fad6b8fa7d422096a79f7902dc8f97", "patch": "@@ -6,12 +6,6 @@ LL |         write!(f, \"{:?}\", 43.1415)\n    |\n    = note: `-D clippy::use-debug` implied by `-D warnings`\n \n-error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:18:19\n-   |\n-LL |         write!(f, \"{:?}\", 42.718)\n-   |                   ^^^^^^\n-\n error: use of `println!`\n   --> $DIR/print.rs:23:5\n    |\n@@ -56,5 +50,5 @@ error: use of `Debug`-based formatting\n LL |     print!(\"Hello {:#?}\", \"#orld\");\n    |            ^^^^^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}]}