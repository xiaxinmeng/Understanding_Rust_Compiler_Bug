{"sha": "61a999a531d03c73626716e2b48d259e13f3b6af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYTk5OWE1MzFkMDNjNzM2MjY3MTZlMmI0OGQyNTllMTNmM2I2YWY=", "commit": {"author": {"name": "Bruno Dutra", "email": "brunocodutra@gmail.com", "date": "2018-09-01T19:16:22Z"}, "committer": {"name": "Bruno Dutra", "email": "brunocodutra@gmail.com", "date": "2018-09-03T18:02:35Z"}, "message": "Move InfiniteLoopDetector to snapshot.rs", "tree": {"sha": "6eb11b0f93a4570584759b6184a8b98dbf1a760f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eb11b0f93a4570584759b6184a8b98dbf1a760f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61a999a531d03c73626716e2b48d259e13f3b6af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61a999a531d03c73626716e2b48d259e13f3b6af", "html_url": "https://github.com/rust-lang/rust/commit/61a999a531d03c73626716e2b48d259e13f3b6af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61a999a531d03c73626716e2b48d259e13f3b6af/comments", "author": {"login": "brunocodutra", "id": 4043663, "node_id": "MDQ6VXNlcjQwNDM2NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4043663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunocodutra", "html_url": "https://github.com/brunocodutra", "followers_url": "https://api.github.com/users/brunocodutra/followers", "following_url": "https://api.github.com/users/brunocodutra/following{/other_user}", "gists_url": "https://api.github.com/users/brunocodutra/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunocodutra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunocodutra/subscriptions", "organizations_url": "https://api.github.com/users/brunocodutra/orgs", "repos_url": "https://api.github.com/users/brunocodutra/repos", "events_url": "https://api.github.com/users/brunocodutra/events{/privacy}", "received_events_url": "https://api.github.com/users/brunocodutra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brunocodutra", "id": 4043663, "node_id": "MDQ6VXNlcjQwNDM2NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4043663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunocodutra", "html_url": "https://github.com/brunocodutra", "followers_url": "https://api.github.com/users/brunocodutra/followers", "following_url": "https://api.github.com/users/brunocodutra/following{/other_user}", "gists_url": "https://api.github.com/users/brunocodutra/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunocodutra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunocodutra/subscriptions", "organizations_url": "https://api.github.com/users/brunocodutra/orgs", "repos_url": "https://api.github.com/users/brunocodutra/repos", "events_url": "https://api.github.com/users/brunocodutra/events{/privacy}", "received_events_url": "https://api.github.com/users/brunocodutra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a26ceb3be4e771799b58383116f4d70f15e7c937", "url": "https://api.github.com/repos/rust-lang/rust/commits/a26ceb3be4e771799b58383116f4d70f15e7c937", "html_url": "https://github.com/rust-lang/rust/commit/a26ceb3be4e771799b58383116f4d70f15e7c937"}], "stats": {"total": 148, "additions": 75, "deletions": 73}, "files": [{"sha": "f7277f8d27610b3fb5ac780e62caf498210da9d1", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 69, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/61a999a531d03c73626716e2b48d259e13f3b6af/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61a999a531d03c73626716e2b48d259e13f3b6af/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=61a999a531d03c73626716e2b48d259e13f3b6af", "patch": "@@ -14,15 +14,14 @@ use std::mem;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n-use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n+use rustc::ich::StableHashingContext;\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n };\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc::mir::interpret::{\n@@ -39,7 +38,7 @@ use super::{\n     Memory, Machine\n };\n \n-use super::snapshot::EvalSnapshot;\n+use super::snapshot::InfiniteLoopDetector;\n \n pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n@@ -189,72 +188,6 @@ impl_stable_hash_for!(enum self::LocalValue {\n     Live(x),\n });\n \n-pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n-    /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n-    ///\n-    /// When a collision occurs in this table, we store the full snapshot in\n-    /// `snapshots`.\n-    hashes: FxHashSet<u64>,\n-\n-    /// The set of all `EvalSnapshot`s observed by this detector.\n-    ///\n-    /// An `EvalSnapshot` will only be fully cloned once it has caused a\n-    /// collision in `hashes`. As a result, the detector must observe at least\n-    /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn default() -> Self {\n-        InfiniteLoopDetector {\n-            hashes: FxHashSet::default(),\n-            snapshots: FxHashSet::default(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    /// Returns `true` if the loop detector has not yet observed a snapshot.\n-    pub fn is_empty(&self) -> bool {\n-        self.hashes.is_empty()\n-    }\n-\n-    pub fn observe_and_analyze(\n-        &mut self,\n-        tcx: &TyCtxt<'b, 'tcx, 'tcx>,\n-        machine: &M,\n-        memory: &Memory<'a, 'mir, 'tcx, M>,\n-        stack: &[Frame<'mir, 'tcx>],\n-    ) -> EvalResult<'tcx, ()> {\n-\n-        let mut hcx = tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::<u64>::new();\n-        (machine, stack).hash_stable(&mut hcx, &mut hasher);\n-        let hash = hasher.finish();\n-\n-        if self.hashes.insert(hash) {\n-            // No collision\n-            return Ok(())\n-        }\n-\n-        info!(\"snapshotting the state of the interpreter\");\n-\n-        if self.snapshots.insert(EvalSnapshot::new(machine, memory, stack)) {\n-            // Spurious collision or first cycle\n-            return Ok(())\n-        }\n-\n-        // Second cycle\n-        Err(EvalErrorKind::InfiniteLoop.into())\n-    }\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {"}, {"sha": "316c80d18c11cb567afe779dd3c0d1f2f92fd43e", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/61a999a531d03c73626716e2b48d259e13f3b6af/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61a999a531d03c73626716e2b48d259e13f3b6af/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=61a999a531d03c73626716e2b48d259e13f3b6af", "patch": "@@ -3,11 +3,14 @@ use std::hash::{Hash, Hasher};\n use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n use rustc::mir;\n use rustc::mir::interpret::{\n-    AllocId, Pointer, Scalar, ScalarMaybeUndef, Relocations, Allocation, UndefMask\n+    AllocId, Pointer, Scalar, ScalarMaybeUndef,\n+    Relocations, Allocation, UndefMask,\n+    EvalResult, EvalErrorKind,\n };\n \n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::Align;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use syntax::ast::Mutability;\n@@ -16,6 +19,72 @@ use syntax::source_map::Span;\n use super::eval_context::{LocalValue, StackPopCleanup};\n use super::{Frame, Memory, Machine, Operand, MemPlace, Place, Value};\n \n+pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+    /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n+    ///\n+    /// When a collision occurs in this table, we store the full snapshot in\n+    /// `snapshots`.\n+    hashes: FxHashSet<u64>,\n+\n+    /// The set of all `EvalSnapshot`s observed by this detector.\n+    ///\n+    /// An `EvalSnapshot` will only be fully cloned once it has caused a\n+    /// collision in `hashes`. As a result, the detector must observe at least\n+    /// *two* full cycles of an infinite loop before it triggers.\n+    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n+}\n+\n+impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    fn default() -> Self {\n+        InfiniteLoopDetector {\n+            hashes: FxHashSet::default(),\n+            snapshots: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>,\n+          'tcx: 'a + 'mir,\n+{\n+    /// Returns `true` if the loop detector has not yet observed a snapshot.\n+    pub fn is_empty(&self) -> bool {\n+        self.hashes.is_empty()\n+    }\n+\n+    pub fn observe_and_analyze(\n+        &mut self,\n+        tcx: &TyCtxt<'b, 'tcx, 'tcx>,\n+        machine: &M,\n+        memory: &Memory<'a, 'mir, 'tcx, M>,\n+        stack: &[Frame<'mir, 'tcx>],\n+    ) -> EvalResult<'tcx, ()> {\n+\n+        let mut hcx = tcx.get_stable_hashing_context();\n+        let mut hasher = StableHasher::<u64>::new();\n+        (machine, stack).hash_stable(&mut hcx, &mut hasher);\n+        let hash = hasher.finish();\n+\n+        if self.hashes.insert(hash) {\n+            // No collision\n+            return Ok(())\n+        }\n+\n+        info!(\"snapshotting the state of the interpreter\");\n+\n+        if self.snapshots.insert(EvalSnapshot::new(machine, memory, stack)) {\n+            // Spurious collision or first cycle\n+            return Ok(())\n+        }\n+\n+        // Second cycle\n+        Err(EvalErrorKind::InfiniteLoop.into())\n+    }\n+}\n+\n trait SnapshotContext<'a> {\n     fn resolve(&'a self, id: &AllocId) -> Option<&'a Allocation>;\n }\n@@ -269,7 +338,7 @@ impl<'a, 'b, 'mir, 'tcx, M> SnapshotContext<'b> for Memory<'a, 'mir, 'tcx, M>\n }\n \n /// The virtual machine state during const-evaluation at a given point in time.\n-pub struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     machine: M,\n     memory: Memory<'a, 'mir, 'tcx, M>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n@@ -278,7 +347,7 @@ pub struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n impl<'a, 'mir, 'tcx, M> EvalSnapshot<'a, 'mir, 'tcx, M>\n     where M: Machine<'mir, 'tcx>,\n {\n-    pub fn new(\n+    fn new(\n         machine: &M,\n         memory: &Memory<'a, 'mir, 'tcx, M>,\n         stack: &[Frame<'mir, 'tcx>]) -> Self {"}]}