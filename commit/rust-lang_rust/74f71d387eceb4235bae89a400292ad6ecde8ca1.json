{"sha": "74f71d387eceb4235bae89a400292ad6ecde8ca1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZjcxZDM4N2VjZWI0MjM1YmFlODlhNDAwMjkyYWQ2ZWNkZThjYTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-08T19:47:53Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-08T19:47:53Z"}, "message": "Overhaul ABI. All retptrs, all the time.", "tree": {"sha": "dd939bfccf18f850faa7aad6d3f5175c60162fcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd939bfccf18f850faa7aad6d3f5175c60162fcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74f71d387eceb4235bae89a400292ad6ecde8ca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74f71d387eceb4235bae89a400292ad6ecde8ca1", "html_url": "https://github.com/rust-lang/rust/commit/74f71d387eceb4235bae89a400292ad6ecde8ca1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74f71d387eceb4235bae89a400292ad6ecde8ca1/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d576993f31349f2a7dbf8e40ccdaff9cf66144d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d576993f31349f2a7dbf8e40ccdaff9cf66144d", "html_url": "https://github.com/rust-lang/rust/commit/9d576993f31349f2a7dbf8e40ccdaff9cf66144d"}], "stats": {"total": 478, "additions": 224, "deletions": 254}, "files": [{"sha": "9e59cf5799ba5ecd53c67a737394ec10b43e9f6c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 224, "deletions": 254, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/74f71d387eceb4235bae89a400292ad6ecde8ca1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f71d387eceb4235bae89a400292ad6ecde8ca1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=74f71d387eceb4235bae89a400292ad6ecde8ca1", "patch": "@@ -83,9 +83,9 @@ state type crate_ctxt = rec(session.session sess,\n \n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n-                         ValueRef llclosure,\n+                         ValueRef llenv,\n+                         ValueRef llretptr,\n                          mutable option.t[ValueRef] llself,\n-                         mutable option.t[ValueRef] llretptr,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n@@ -239,13 +239,23 @@ fn T_task() -> TypeRef {\n                      ));\n }\n \n+fn T_glue_fn() -> TypeRef {\n+    // Bit of a kludge: pick the fn typeref out of the tydesc..\n+    let vec[TypeRef] tydesc_elts = _vec.init_elt[TypeRef](T_nil(), 10u);\n+    llvm.LLVMGetStructElementTypes(T_tydesc(),\n+                                   _vec.buf[TypeRef](tydesc_elts));\n+    ret llvm.LLVMGetElementType(tydesc_elts.(abi.tydesc_field_drop_glue_off));\n+}\n+\n fn T_tydesc() -> TypeRef {\n \n     auto th = mk_type_handle();\n     auto abs_tydesc = llvm.LLVMResolveTypeHandle(th.llth);\n     auto tydescpp = T_ptr(T_ptr(abs_tydesc));\n     auto pvoid = T_ptr(T_i8());\n-    auto glue_fn_ty = T_ptr(T_fn(vec(T_taskptr(),\n+    auto glue_fn_ty = T_ptr(T_fn(vec(T_ptr(T_nil()),\n+                                     T_taskptr(),\n+                                     T_ptr(T_nil()),\n                                      tydescpp,\n                                      pvoid), T_void()));\n     auto tydesc = T_struct(vec(tydescpp,          // first_param\n@@ -354,25 +364,31 @@ fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     ret llty;\n }\n \n-// NB: this must match trans_args and create_llargs_for_fn_args.\n+\n+// NB: must keep 4 fns in sync:\n+//\n+//  - type_of_fn_full\n+//  - create_llargs_for_fn_args.\n+//  - new_fn_ctxt\n+//  - trans_args\n+\n fn type_of_fn_full(@crate_ctxt cx,\n                    option.t[TypeRef] obj_self,\n                    vec[ty.arg] inputs,\n                    @ty.t output) -> TypeRef {\n-    let vec[TypeRef] atys = vec(T_taskptr());\n-\n-    auto fn_ty = plain_ty(ty.ty_fn(inputs, output));\n-    auto ty_param_count = ty.count_ty_params(fn_ty);\n-    auto i = 0u;\n-    while (i < ty_param_count) {\n-        atys += T_ptr(T_tydesc());\n-        i += 1u;\n-    }\n+    let vec[TypeRef] atys = vec();\n \n+    // Arg 0: Output pointer.\n     if (ty.type_has_dynamic_size(output)) {\n         atys += T_typaram_ptr();\n+    } else {\n+        atys += T_ptr(type_of(cx, output));\n     }\n \n+    // Arg 1: Task pointer.\n+    atys += T_taskptr();\n+\n+    // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n         case (some[TypeRef](?t)) {\n             check (t as int != 0);\n@@ -383,6 +399,16 @@ fn type_of_fn_full(@crate_ctxt cx,\n         }\n     }\n \n+    // Args >3: ty params ...\n+    auto ty_param_count =\n+        ty.count_ty_params(plain_ty(ty.ty_fn(inputs, output)));\n+    auto i = 0u;\n+    while (i < ty_param_count) {\n+        atys += T_ptr(T_tydesc());\n+        i += 1u;\n+    }\n+\n+    // ... then explicit args.\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(arg.ty)) {\n             check (arg.mode == ast.alias);\n@@ -399,14 +425,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n         }\n     }\n \n-    auto ret_ty;\n-    if (ty.type_is_nil(output) || ty.type_has_dynamic_size(output)) {\n-        ret_ty = llvm.LLVMVoidType();\n-    } else {\n-        ret_ty = type_of(cx, output);\n-    }\n-\n-    ret T_fn(atys, ret_ty);\n+    ret T_fn(atys, llvm.LLVMVoidType());\n }\n \n fn type_of_fn(@crate_ctxt cx, vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n@@ -663,9 +682,11 @@ fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n \n     let ValueRef llglue = cx.fcx.ccx.glues.upcall_glues.(n);\n     let vec[ValueRef] call_args = vec(cx.fcx.lltaskptr, llupcall);\n+\n     for (ValueRef a in args) {\n         call_args += cx.build.ZExtOrBitCast(a, T_int());\n     }\n+\n     ret res(cx, cx.build.FastCall(llglue, call_args));\n }\n \n@@ -1044,10 +1065,7 @@ fn make_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n     auto drop_glue = make_generic_glue(cx, t, \"drop\", dg, typaram_defs);\n \n     auto llty = type_of(cx, t);\n-    auto pvoid = T_ptr(T_i8());\n-    auto glue_fn_ty = T_ptr(T_fn(vec(T_taskptr(),\n-                                     T_ptr(T_ptr(T_tydesc())),\n-                                     pvoid), T_void()));\n+    auto glue_fn_ty = T_ptr(T_glue_fn());\n \n     // FIXME: this adjustment has to do with the ridiculous encoding of\n     // glue-pointer-constants in the tydesc records: They are tydesc-relative\n@@ -1082,9 +1100,7 @@ fn make_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n fn make_generic_glue(@crate_ctxt cx, @ty.t t, str name,\n                      val_and_ty_fn helper,\n                      vec[ast.def_id] typaram_defs) -> ValueRef {\n-    auto llfnty = T_fn(vec(T_taskptr(),\n-                           T_ptr(T_ptr(T_tydesc())),\n-                           T_ptr(T_i8())), T_void());\n+    auto llfnty = T_glue_fn();\n \n     auto fn_name = cx.names.next(\"_rust_\" + name) + \".\" + ty.ty_to_str(t);\n     fn_name = sanitize(fn_name);\n@@ -1102,7 +1118,7 @@ fn make_generic_glue(@crate_ctxt cx, @ty.t t, str name,\n             llty = type_of(cx, t);\n         }\n \n-        auto lltyparams = llvm.LLVMGetParam(llfn, 1u);\n+        auto lltyparams = llvm.LLVMGetParam(llfn, 3u);\n         auto p = 0;\n         for (ast.def_id d in typaram_defs) {\n             auto llparam = bcx.build.GEP(lltyparams, vec(C_int(p)));\n@@ -1111,7 +1127,7 @@ fn make_generic_glue(@crate_ctxt cx, @ty.t t, str name,\n             p += 1;\n         }\n \n-        auto llrawptr = llvm.LLVMGetParam(llfn, 2u);\n+        auto llrawptr = llvm.LLVMGetParam(llfn, 4u);\n         auto llval = bcx.build.BitCast(llrawptr, llty);\n \n         re = helper(bcx, llval, t);\n@@ -1582,7 +1598,11 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n                                           cx.build.PtrToInt(tydesc, T_int())),\n                              val_ty(llfn));\n \n-    cx.build.FastCall(llfn, vec(cx.fcx.lltaskptr, lltydescs, llrawptr));\n+    cx.build.FastCall(llfn, vec(C_null(T_ptr(T_nil())),\n+                                cx.fcx.lltaskptr,\n+                                C_null(T_ptr(T_nil())),\n+                                lltydescs,\n+                                llrawptr));\n }\n \n fn call_tydesc_glue(@block_ctxt cx, ValueRef v, @ty.t t, int field) {\n@@ -2467,103 +2487,6 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     ret e_res;\n }\n \n-\n-// NB: this must match type_of_fn_full and create_llargs_for_fn_args.\n-fn trans_args(@block_ctxt cx,\n-              ValueRef llclosure,\n-              option.t[ValueRef] llobj,\n-              option.t[generic_info] gen,\n-              &vec[@ast.expr] es,\n-              @ty.t fn_ty)\n-    -> tup(@block_ctxt, vec[ValueRef], option.t[ValueRef]) {\n-    let vec[ValueRef] vs = vec(cx.fcx.lltaskptr);\n-    let @block_ctxt bcx = cx;\n-\n-    let vec[ty.arg] args = ty.ty_fn_args(fn_ty);\n-\n-    let option.t[ValueRef] llretslot_opt = none[ValueRef];\n-\n-    alt (gen) {\n-        case (some[generic_info](?g)) {\n-            for (ValueRef t in g.tydescs) {\n-                vs += t;\n-            }\n-            args = ty.ty_fn_args(g.item_type);\n-            if (ty.type_has_dynamic_size(ty.ty_fn_ret(g.item_type))) {\n-                auto retty = ty.ty_fn_ret(fn_ty);\n-                auto llretty = type_of(cx.fcx.ccx, retty);\n-                auto llretslot = cx.build.Alloca(llretty);\n-                vs += cx.build.PointerCast(llretslot, T_ptr(T_i8()));\n-                llretslot_opt = some[ValueRef](llretslot);\n-            }\n-        }\n-        case (_) { }\n-    }\n-\n-    alt (llobj) {\n-        case (some[ValueRef](?ob)) {\n-            // Every object is always found in memory,\n-            // and not-yet-loaded (as part of an lval x.y\n-            // doted method-call).\n-            vs += cx.build.Load(ob);\n-        }\n-        case (_) {\n-            vs += llclosure;\n-        }\n-    }\n-\n-    auto i = 0u;\n-    for (@ast.expr e in es) {\n-        auto mode = args.(i).mode;\n-\n-        auto val;\n-        if (ty.type_is_structural(ty.expr_ty(e))) {\n-            auto re = trans_expr(bcx, e);\n-            val = re.val;\n-            bcx = re.bcx;\n-            if (mode == ast.val) {\n-                // Until here we've been treating structures by pointer;\n-                // we are now passing it as an arg, so need to load it.\n-                val = bcx.build.Load(val);\n-            }\n-        } else if (mode == ast.alias) {\n-            let lval_result lv;\n-            if (ty.is_lval(e)) {\n-                lv = trans_lval(bcx, e);\n-            } else {\n-                auto r = trans_expr(bcx, e);\n-                lv = lval_val(r.bcx, r.val);\n-            }\n-            bcx = lv.res.bcx;\n-\n-            if (lv.is_mem) {\n-                val = lv.res.val;\n-            } else {\n-                // Non-mem but we're trying to alias; synthesize an\n-                // alloca, spill to it and pass its address.\n-                auto llty = val_ty(lv.res.val);\n-                auto llptr = lv.res.bcx.build.Alloca(llty);\n-                lv.res.bcx.build.Store(lv.res.val, llptr);\n-                val = llptr;\n-            }\n-\n-        } else {\n-            auto re = trans_expr(bcx, e);\n-            val = re.val;\n-            bcx = re.bcx;\n-        }\n-\n-        if (ty.type_has_dynamic_size(args.(i).ty)) {\n-            val = bcx.build.PointerCast(val, T_typaram_ptr());\n-        }\n-\n-        vs += val;\n-        i += 1u;\n-    }\n-\n-    ret tup(bcx, vs, llretslot_opt);\n-}\n-\n fn trans_bind_thunk(@crate_ctxt cx,\n                     @ty.t incoming_fty,\n                     @ty.t outgoing_fty,\n@@ -2577,15 +2500,13 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx, incoming_fty));\n     let ValueRef llthunk = decl_fastcall_fn(cx.llmod, s, llthunk_ty);\n \n-    let @ty.t rty = ret_ty_of_fn_ty(incoming_fty);\n-\n     // FIXME: handle ty params properly.\n     let vec[ast.ty_param] ty_params = vec();\n \n     auto fcx = new_fn_ctxt(cx, s, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n \n-    auto llclosure = bcx.build.PointerCast(fcx.llclosure, llclosure_ty);\n+    auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ty);\n \n     auto llbody = bcx.build.GEP(llclosure,\n                                 vec(C_int(0),\n@@ -2603,7 +2524,8 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                                          vec(C_int(0),\n                                              C_int(abi.fn_field_box)));\n     lltargetclosure = bcx.build.Load(lltargetclosure);\n-    let vec[ValueRef] llargs = vec(fcx.lltaskptr,\n+    let vec[ValueRef] llargs = vec(fcx.llretptr,\n+                                   fcx.lltaskptr,\n                                    lltargetclosure);\n     let uint a = 0u;\n     let int b = 0;\n@@ -2635,20 +2557,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                                         C_int(abi.fn_field_code)));\n     lltargetfn = bcx.build.Load(lltargetfn);\n     auto r = bcx.build.FastCall(lltargetfn, llargs);\n-\n-    alt (fcx.llretptr) {\n-        case (some[ValueRef](?llptr)) {\n-            bcx.build.Store(bcx.build.Load(r), llptr);\n-            bcx.build.RetVoid();\n-        }\n-        case (none[ValueRef]) {\n-            if (ty.type_is_nil(rty)) {\n-                bcx.build.RetVoid();\n-            } else {\n-                bcx.build.Ret(r);\n-            }\n-        }\n-    }\n+    bcx.build.RetVoid();\n \n     ret llthunk;\n }\n@@ -2766,11 +2675,123 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n     }\n }\n \n+// NB: must keep 4 fns in sync:\n+//\n+//  - type_of_fn_full\n+//  - create_llargs_for_fn_args.\n+//  - new_fn_ctxt\n+//  - trans_args\n+\n+fn trans_args(@block_ctxt cx,\n+              ValueRef llenv,\n+              option.t[ValueRef] llobj,\n+              option.t[generic_info] gen,\n+              &vec[@ast.expr] es,\n+              @ty.t fn_ty)\n+    -> tup(@block_ctxt, vec[ValueRef], ValueRef) {\n+\n+    let vec[ty.arg] args = ty.ty_fn_args(fn_ty);\n+    let vec[ValueRef] llargs = vec();\n+    let vec[ValueRef] lltydescs = vec();\n+    let @block_ctxt bcx = cx;\n+\n+\n+    // Arg 0: Output pointer.\n+    auto retty = ty.ty_fn_ret(fn_ty);\n+    auto llretslot = cx.build.Alloca(type_of(cx.fcx.ccx, retty));\n+    alt (gen) {\n+        case (some[generic_info](?g)) {\n+            lltydescs = g.tydescs;\n+            args = ty.ty_fn_args(g.item_type);\n+            retty = ty.ty_fn_ret(g.item_type);\n+        }\n+        case (_) {\n+        }\n+    }\n+    if (ty.type_has_dynamic_size(retty)) {\n+        llargs += cx.build.PointerCast(llretslot, T_typaram_ptr());\n+    } else {\n+        llargs += llretslot;\n+    }\n+\n+\n+    // Arg 1: Task pointer.\n+    llargs += cx.fcx.lltaskptr;\n+\n+    // Arg 2: Env (closure-bindings / self-obj)\n+    alt (llobj) {\n+        case (some[ValueRef](?ob)) {\n+            // Every object is always found in memory,\n+            // and not-yet-loaded (as part of an lval x.y\n+            // doted method-call).\n+            llargs += cx.build.Load(ob);\n+        }\n+        case (_) {\n+            llargs += llenv;\n+        }\n+    }\n+\n+    // Args >3: ty_params ...\n+    llargs += lltydescs;\n+\n+    // ... then explicit args.\n+    auto i = 0u;\n+    for (@ast.expr e in es) {\n+        auto mode = args.(i).mode;\n+\n+        auto val;\n+        if (ty.type_is_structural(ty.expr_ty(e))) {\n+            auto re = trans_expr(bcx, e);\n+            val = re.val;\n+            bcx = re.bcx;\n+            if (mode == ast.val) {\n+                // Until here we've been treating structures by pointer;\n+                // we are now passing it as an arg, so need to load it.\n+                val = bcx.build.Load(val);\n+            }\n+        } else if (mode == ast.alias) {\n+            let lval_result lv;\n+            if (ty.is_lval(e)) {\n+                lv = trans_lval(bcx, e);\n+            } else {\n+                auto r = trans_expr(bcx, e);\n+                lv = lval_val(r.bcx, r.val);\n+            }\n+            bcx = lv.res.bcx;\n+\n+            if (lv.is_mem) {\n+                val = lv.res.val;\n+            } else {\n+                // Non-mem but we're trying to alias; synthesize an\n+                // alloca, spill to it and pass its address.\n+                auto llty = val_ty(lv.res.val);\n+                auto llptr = lv.res.bcx.build.Alloca(llty);\n+                lv.res.bcx.build.Store(lv.res.val, llptr);\n+                val = llptr;\n+            }\n+\n+        } else {\n+            auto re = trans_expr(bcx, e);\n+            val = re.val;\n+            bcx = re.bcx;\n+        }\n+\n+        if (ty.type_has_dynamic_size(args.(i).ty)) {\n+            val = bcx.build.PointerCast(val, T_typaram_ptr());\n+        }\n+\n+        llargs += val;\n+        i += 1u;\n+    }\n+\n+    ret tup(bcx, llargs, llretslot);\n+}\n+\n fn trans_call(@block_ctxt cx, @ast.expr f,\n               vec[@ast.expr] args, &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     auto faddr = f_res.res.val;\n-    auto llclosure = C_null(T_opaque_closure_ptr());\n+    auto llenv = C_null(T_opaque_closure_ptr());\n \n     alt (f_res.llobj) {\n         case (some[ValueRef](_)) {\n@@ -2785,52 +2806,34 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n                                             C_int(abi.fn_field_code)));\n             faddr = bcx.build.Load(faddr);\n \n-            llclosure = bcx.build.GEP(pair, vec(C_int(0),\n-                                                C_int(abi.fn_field_box)));\n-            llclosure = bcx.build.Load(llclosure);\n+            auto llclosure = bcx.build.GEP(pair,\n+                                           vec(C_int(0),\n+                                               C_int(abi.fn_field_box)));\n+            llenv = bcx.build.Load(llclosure);\n         }\n     }\n     auto fn_ty = ty.expr_ty(f);\n     auto ret_ty = ty.ann_to_type(ann);\n     auto args_res = trans_args(f_res.res.bcx,\n-                               llclosure, f_res.llobj,\n+                               llenv, f_res.llobj,\n                                f_res.generic,\n                                args, fn_ty);\n \n     auto bcx = args_res._0;\n-    auto real_retval = bcx.build.FastCall(faddr, args_res._1);\n-    auto retval = real_retval;\n-\n-    if (ty.type_is_nil(ret_ty)) {\n-        retval = C_nil();\n+    auto llargs = args_res._1;\n+    auto llretslot = args_res._2;\n+\n+    bcx.build.FastCall(faddr, llargs);\n+    auto retval = C_nil();\n+\n+    if (!ty.type_is_nil(ret_ty)) {\n+        retval = load_scalar_or_boxed(bcx, llretslot, ret_ty);\n+        // Retval doesn't correspond to anything really tangible in the frame,\n+        // but it's a ref all the same, so we put a note here to drop it when\n+        // we're done in this scope.\n+        find_scope_cx(cx).cleanups += clean(bind drop_ty(_, retval, ret_ty));\n     }\n \n-    // Check for a generic retslot.\n-    alt (args_res._2) {\n-\n-        case (some[ValueRef](?llretslot)) {\n-            retval = load_scalar_or_boxed(bcx, llretslot, ret_ty);\n-        }\n-\n-        case (none[ValueRef]) {\n-            if (! (ty.type_is_scalar(ret_ty) ||\n-                   ty.type_is_boxed(ret_ty))) {\n-                // Structured returns come back as first-class values. This is\n-                // nice for LLVM but wrong for us; we treat structured values\n-                // by pointer in most of our code here. So spill it to an\n-                // alloca.\n-                auto local = bcx.build.Alloca(type_of(cx.fcx.ccx, ret_ty));\n-                bcx.build.Store(retval, local);\n-                retval = local;\n-            }\n-        }\n-    }\n-\n-    // Retval doesn't correspond to anything really tangible in the frame, but\n-    // it's a ref all the same, so we put a note here to drop it when we're\n-    // done in this scope.\n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, retval, ret_ty));\n-\n     ret res(bcx, retval);\n }\n \n@@ -3091,18 +3094,7 @@ fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n             auto r = trans_expr(cx, x);\n             bcx = r.bcx;\n             val = r.val;\n-\n-            // A return is an implicit copy into a newborn anonymous\n-            // 'return value' in the caller frame.\n-            bcx = incr_all_refcnts(bcx, val, t).bcx;\n-\n-            if (ty.type_is_structural(t)) {\n-                // We usually treat structurals by-pointer; in particular,\n-                // trans_expr will have given us a structure pointer. But in\n-                // this case we're about to return. LLVM wants a first-class\n-                // value here (which makes sense; the frame is going away!)\n-                val = r.bcx.build.Load(val);\n-            }\n+            bcx = copy_ty(bcx, INIT, cx.fcx.llretptr, val, t).bcx;\n         }\n         case (_) { /* fall through */  }\n     }\n@@ -3122,34 +3114,6 @@ fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n         }\n     }\n \n-    alt (e) {\n-        case (some[@ast.expr](?ex)) {\n-            auto t = ty.expr_ty(ex);\n-\n-            if (ty.type_is_nil(t)) {\n-                bcx.build.RetVoid();\n-                val = C_nil();\n-                ret res(bcx, val);  // FIXME: early return needed due to\n-                                    // typestate bug\n-            }\n-\n-            alt (cx.fcx.llretptr) {\n-                case (some[ValueRef](?llptr)) {\n-                    // Generic return via tydesc + retptr.\n-                    bcx = copy_ty(bcx, INIT, llptr, val, t).bcx;\n-                    bcx.build.RetVoid();\n-                }\n-                case (none[ValueRef]) {\n-                    val = bcx.build.Ret(val);\n-                }\n-            }\n-            ret res(bcx, val);\n-        }\n-        case (_) { /* fall through */  }\n-    }\n-\n-    // FIXME: until LLVM has a unit type, we are moving around\n-    // C_nil values rather than their void type.\n     bcx.build.RetVoid();\n     ret res(bcx, C_nil());\n }\n@@ -3360,12 +3324,20 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     ret res(bcx, r.val);\n }\n \n+// NB: must keep 4 fns in sync:\n+//\n+//  - type_of_fn_full\n+//  - create_llargs_for_fn_args.\n+//  - new_fn_ctxt\n+//  - trans_args\n+\n fn new_fn_ctxt(@crate_ctxt cx,\n                str name,\n                ValueRef llfndecl) -> @fn_ctxt {\n \n-    let ValueRef lltaskptr = llvm.LLVMGetParam(llfndecl, 0u);\n-    let ValueRef llclosure = llvm.LLVMGetParam(llfndecl, 1u);\n+    let ValueRef llretptr = llvm.LLVMGetParam(llfndecl, 0u);\n+    let ValueRef lltaskptr = llvm.LLVMGetParam(llfndecl, 1u);\n+    let ValueRef llenv = llvm.LLVMGetParam(llfndecl, 2u);\n \n     let hashmap[ast.def_id, ValueRef] llargs = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] llobjfields = new_def_hash[ValueRef]();\n@@ -3374,23 +3346,38 @@ fn new_fn_ctxt(@crate_ctxt cx,\n \n     ret @rec(llfn=llfndecl,\n              lltaskptr=lltaskptr,\n-             llclosure=llclosure,\n+             llenv=llenv,\n+             llretptr=llretptr,\n              mutable llself=none[ValueRef],\n-             mutable llretptr=none[ValueRef],\n              llargs=llargs,\n              llobjfields=llobjfields,\n              lllocals=lllocals,\n              lltydescs=lltydescs,\n              ccx=cx);\n }\n \n-// NB: this must match trans_args and type_of_fn_full.\n+// NB: must keep 4 fns in sync:\n+//\n+//  - type_of_fn_full\n+//  - create_llargs_for_fn_args.\n+//  - new_fn_ctxt\n+//  - trans_args\n+\n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n                              option.t[TypeRef] ty_self,\n                              @ty.t ret_ty,\n                              &vec[ast.arg] args,\n                              &vec[ast.ty_param] ty_params) {\n-    let uint arg_n = 1u;\n+\n+    alt (ty_self) {\n+        case (some[TypeRef](_)) {\n+            cx.llself = some[ValueRef](cx.llenv);\n+        }\n+        case (_) {\n+        }\n+    }\n+\n+    auto arg_n = 3u;\n \n     for (ast.ty_param tp in ty_params) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n@@ -3399,23 +3386,6 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n         arg_n += 1u;\n     }\n \n-    if (ty.type_has_dynamic_size(ret_ty)) {\n-        cx.llretptr = some[ValueRef](llvm.LLVMGetParam(cx.llfn, arg_n));\n-        arg_n += 1u;\n-    }\n-\n-    alt (ty_self) {\n-        case (some[TypeRef](_)) {\n-            auto llself = llvm.LLVMGetParam(cx.llfn, arg_n);\n-            check (llself as int != 0);\n-            cx.llself = some[ValueRef](llself);\n-            arg_n += 1u;\n-        }\n-        case (_) {\n-            // llclosure, we don't know what it is.\n-            arg_n += 1u;\n-        }\n-    }\n \n     for (ast.arg arg in args) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n@@ -3645,7 +3615,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     copy_args_to_allocas(bcx, none[TypeRef], fn_args, arg_tys);\n \n     auto llself_ty = type_of(cx, ret_ty_of_fn(ann));\n-    auto pair = bcx.build.Alloca(llself_ty);\n+    auto pair = bcx.fcx.llretptr;\n     auto vtbl = trans_vtbl(cx, llself_ty, ob, ty_params);\n     auto pair_vtbl = bcx.build.GEP(pair,\n                                    vec(C_int(0),\n@@ -3740,7 +3710,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         auto p = bcx.build.PointerCast(box.val, llbox_ty);\n         bcx.build.Store(p, pair_box);\n     }\n-    bcx.build.Ret(bcx.build.Load(pair));\n+    bcx.build.RetVoid();\n }\n \n fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n@@ -3779,11 +3749,12 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     // FIXME: better name.\n     llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"tag\"), lltagty);\n \n-    auto lltagptr = bcx.build.Alloca(lltagty);\n-    auto lldiscrimptr = bcx.build.GEP(lltagptr, vec(C_int(0), C_int(0)));\n+    auto lldiscrimptr = bcx.build.GEP(fcx.llretptr,\n+                                      vec(C_int(0), C_int(0)));\n     bcx.build.Store(C_int(index), lldiscrimptr);\n \n-    auto llblobptr = bcx.build.GEP(lltagptr, vec(C_int(0), C_int(1)));\n+    auto llblobptr = bcx.build.GEP(fcx.llretptr,\n+                                   vec(C_int(0), C_int(1)));\n \n     // First, generate the union type.\n     let vec[TypeRef] llargtys = vec();\n@@ -3804,9 +3775,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n         i += 1u;\n     }\n \n-    auto lltagval = bcx.build.Load(lltagptr);\n     bcx = trans_block_cleanups(bcx, find_scope_cx(bcx));\n-    bcx.build.Ret(lltagval);\n+    bcx.build.RetVoid();\n }\n \n // FIXME: this should do some structural hash-consing to avoid\n@@ -4142,9 +4112,9 @@ fn trans_exit_task_glue(@crate_ctxt cx) {\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 0u);\n     auto fcx = @rec(llfn=llfn,\n                     lltaskptr=lltaskptr,\n-                    llclosure=C_null(T_opaque_closure_ptr()),\n+                    llenv=C_null(T_opaque_closure_ptr()),\n+                    llretptr=C_null(T_ptr(T_nil())),\n                     mutable llself=none[ValueRef],\n-                    mutable llretptr=none[ValueRef],\n                     llargs=new_def_hash[ValueRef](),\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),"}]}