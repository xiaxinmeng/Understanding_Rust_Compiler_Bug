{"sha": "caa564bea3d5f5a24d0797c4769184c1ea0abaff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYTU2NGJlYTNkNWY1YTI0ZDA3OTdjNDc2OTE4NGMxZWEwYWJhZmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-22T03:54:28Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-25T01:58:12Z"}, "message": "librustc: Stop desugaring `for` expressions and translate them directly.\n\nThis makes edge cases in which the `Iterator` trait was not in scope\nand/or `Option` or its variants were not in scope work properly.\n\nThis breaks code that looks like:\n\n    struct MyStruct { ... }\n\n    impl MyStruct {\n        fn next(&mut self) -> Option<int> { ... }\n    }\n\n    for x in MyStruct { ... } { ... }\n\nChange ad-hoc `next` methods like the above to implementations of the\n`Iterator` trait. For example:\n\n    impl Iterator<int> for MyStruct {\n        fn next(&mut self) -> Option<int> { ... }\n    }\n\nCloses #15392.\n\n[breaking-change]", "tree": {"sha": "f0f1b5d284efe24018586e85fb5b442e8b578283", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0f1b5d284efe24018586e85fb5b442e8b578283"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caa564bea3d5f5a24d0797c4769184c1ea0abaff", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caa564bea3d5f5a24d0797c4769184c1ea0abaff", "html_url": "https://github.com/rust-lang/rust/commit/caa564bea3d5f5a24d0797c4769184c1ea0abaff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caa564bea3d5f5a24d0797c4769184c1ea0abaff/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f2e63ec3f6f03ac9273a9f166a4ce8deff48097", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2e63ec3f6f03ac9273a9f166a4ce8deff48097", "html_url": "https://github.com/rust-lang/rust/commit/7f2e63ec3f6f03ac9273a9f166a4ce8deff48097"}], "stats": {"total": 777, "additions": 614, "deletions": 163}, "files": [{"sha": "26baf96a8bc86ae6d217ebc55c88726c975d3f7b", "filename": "src/libcore/char.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -17,7 +17,10 @@\n \n use mem::transmute;\n use option::{None, Option, Some};\n-use iter::{Iterator, range_step};\n+use iter::range_step;\n+\n+#[cfg(stage0)]\n+use iter::Iterator; // NOTE(stage0): Remove after snapshot.\n \n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: u8    = 0b1000_0000u8;"}, {"sha": "386fc28119a3e1607d6e039a4c2d210dc339d9f4", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -13,15 +13,19 @@\n use char;\n use collections::Collection;\n use fmt;\n-use iter::{Iterator, range, DoubleEndedIterator};\n+use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n use num::{Zero, One, cast};\n-use option::{None, Some};\n use result::Ok;\n use slice::{ImmutableVector, MutableVector};\n use slice;\n use str::StrSlice;\n \n+#[cfg(stage0)]\n+use iter::Iterator;         // NOTE(stage0): Remove after snapshot.\n+#[cfg(stage0)]\n+use option::{Some, None};   // NOTE(stage0): Remove after snapshot.\n+\n /// A flag that specifies whether to use exponential (scientific) notation.\n pub enum ExponentFormat {\n     /// Do not use exponential notation."}, {"sha": "81e84c447e796e2b6aff0dc2e726b072c3f093f5", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -16,11 +16,15 @@\n \n use collections::Collection;\n use fmt;\n-use iter::{Iterator, DoubleEndedIterator};\n+use iter::DoubleEndedIterator;\n use num::{Int, cast, zero};\n-use option::{Some, None};\n use slice::{ImmutableVector, MutableVector};\n \n+#[cfg(stage0)]\n+use iter::Iterator;         // NOTE(stage0): Remove after snapshot.\n+#[cfg(stage0)]\n+use option::{Some, None};   // NOTE(stage0): Remove after snapshot.\n+\n /// A type that represents a specific radix\n trait GenericRadix {\n     /// The number of digits."}, {"sha": "b0660230c2ce6923efe3f10409f0555baf936a22", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -95,6 +95,7 @@ pub trait Extendable<A>: FromIterator<A> {\n /// is returned. A concrete Iterator implementation may choose to behave however\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n+#[lang=\"iterator\"]\n pub trait Iterator<A> {\n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n     fn next(&mut self) -> Option<A>;"}, {"sha": "84b402a68dd120100226eb29358c5268de1bfcbc", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -147,7 +147,12 @@ use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use mem;\n use slice;\n \n-/// The `Option`\n+// Note that this is not a lang item per se, but it has a hidden dependency on\n+// `Iterator`, which is one. The compiler assumes that the `next` method of\n+// `Iterator` is an enumeration with one type parameter and two variants,\n+// which basically means it must be `Option`.\n+\n+/// The `Option` type.\n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Show)]\n pub enum Option<T> {\n     /// No value"}, {"sha": "4921802ba732eea4022f0ff63e42cbfd7d4f6800", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -90,11 +90,14 @@\n use mem;\n use clone::Clone;\n use intrinsics;\n-use iter::{range, Iterator};\n+use iter::range;\n use option::{Some, None, Option};\n \n use cmp::{PartialEq, Eq, PartialOrd, Equiv, Ordering, Less, Equal, Greater};\n \n+#[cfg(stage0)]\n+use iter::Iterator; // NOTE(stage0): Remove after snapshot.\n+\n pub use intrinsics::copy_memory;\n pub use intrinsics::copy_nonoverlapping_memory;\n pub use intrinsics::set_memory;"}, {"sha": "2ba51eb98fca040086020ce5e6bf38824981194c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -28,7 +28,7 @@ use iter::{Map, Iterator};\n use iter::{DoubleEndedIterator, ExactSize};\n use iter::range;\n use num::{CheckedMul, Saturating};\n-use option::{None, Option, Some};\n+use option::{Option, None, Some};\n use raw::Repr;\n use slice::ImmutableVector;\n use slice;\n@@ -1027,9 +1027,12 @@ pub mod traits {\n     use cmp::{Ord, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, Eq};\n     use collections::Collection;\n     use iter::Iterator;\n-    use option::{Option, Some, None};\n+    use option::{Option, Some};\n     use str::{Str, StrSlice, eq_slice};\n \n+    #[cfg(stage0)]\n+    use option::None;   // NOTE(stage0): Remove after snapshot.\n+\n     impl<'a> Ord for &'a str {\n         #[inline]\n         fn cmp(&self, other: & &'a str) -> Ordering {"}, {"sha": "cadbc238e679ad1d7144a2f9629f6a87b4946e8a", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -137,8 +137,8 @@ fn test_iterator_take_while() {\n     let ys = [0u, 1, 2, 3, 5, 13];\n     let mut it = xs.iter().take_while(|&x| *x < 15u);\n     let mut i = 0;\n-    for &x in it {\n-        assert_eq!(x, ys[i]);\n+    for x in it {\n+        assert_eq!(*x, ys[i]);\n         i += 1;\n     }\n     assert_eq!(i, ys.len());\n@@ -150,8 +150,8 @@ fn test_iterator_skip_while() {\n     let ys = [15, 16, 17, 19];\n     let mut it = xs.iter().skip_while(|&x| *x < 15u);\n     let mut i = 0;\n-    for &x in it {\n-        assert_eq!(x, ys[i]);\n+    for x in it {\n+        assert_eq!(*x, ys[i]);\n         i += 1;\n     }\n     assert_eq!(i, ys.len());"}, {"sha": "b570cb43f164e1d92267f028c9aa593b7cf59d4f", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -440,6 +440,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 euv::AddrOf(..) |\n                 euv::AutoRef(..) |\n                 euv::ClosureInvocation(..) |\n+                euv::ForLoop(..) |\n                 euv::RefBinding(..) => {\n                     format!(\"previous borrow of `{}` occurs here\",\n                             self.bccx.loan_path_to_string(&*old_loan.loan_path))\n@@ -668,6 +669,11 @@ impl<'a> CheckLoanCtxt<'a> {\n             return;\n         }\n \n+        // Initializations are OK.\n+        if mode == euv::Init {\n+            return\n+        }\n+\n         // For immutable local variables, assignments are legal\n         // if they cannot already have been assigned\n         if self.is_local_variable_or_arg(assignee_cmt.clone()) {"}, {"sha": "3ed0f61a8f0646c16212a7c0a64d1002f2e9a73a", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -651,7 +651,8 @@ impl<'a> BorrowckCtxt<'a> {\n                     euv::OverloadedOperator |\n                     euv::AddrOf |\n                     euv::RefBinding |\n-                    euv::AutoRef => {\n+                    euv::AutoRef |\n+                    euv::ForLoop => {\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n                     euv::ClosureInvocation => {\n@@ -712,6 +713,10 @@ impl<'a> BorrowckCtxt<'a> {\n             BorrowViolation(euv::ClosureInvocation) => {\n                 \"closure invocation\"\n             }\n+\n+            BorrowViolation(euv::ForLoop) => {\n+                \"`for` loop\"\n+            }\n         };\n \n         match cause {"}, {"sha": "4f6885f05ed16c87176f204397e514337ca3b484", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -240,7 +240,7 @@ impl<'a> CFGBuilder<'a> {\n                 //   v 3\n                 // [expr]\n                 //\n-                // Note that `break` and `loop` statements\n+                // Note that `break` and `continue` statements\n                 // may cause additional edges.\n \n                 // Is the condition considered part of the loop?\n@@ -258,7 +258,44 @@ impl<'a> CFGBuilder<'a> {\n                 expr_exit\n             }\n \n-            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n+                //\n+                //          [pred]\n+                //            |\n+                //            v 1\n+                //          [head]\n+                //            |\n+                //            v 2\n+                //        [loopback] <--+ 7\n+                //            |         |\n+                //            v 3       |\n+                //   +------[cond]      |\n+                //   |        |         |\n+                //   |        v 5       |\n+                //   |       [pat]      |\n+                //   |        |         |\n+                //   |        v 6       |\n+                //   v 4    [body] -----+\n+                // [expr]\n+                //\n+                // Note that `break` and `continue` statements\n+                // may cause additional edges.\n+\n+                let head = self.expr(head.clone(), pred);       // 1\n+                let loopback = self.add_dummy_node([head]);     // 2\n+                let cond = self.add_dummy_node([loopback]);     // 3\n+                let expr_exit = self.add_node(expr.id, [cond]); // 4\n+                self.loop_scopes.push(LoopScope {\n+                    loop_id: expr.id,\n+                    continue_index: loopback,\n+                    break_index: expr_exit,\n+                });\n+                let pat = self.pat(&**pat, cond);               // 5\n+                let body = self.block(&**body, pat);            // 6\n+                self.add_contained_edge(body, loopback);        // 7\n+                self.loop_scopes.pop();\n+                expr_exit\n+            }\n \n             ast::ExprLoop(ref body, _) => {\n                 //"}, {"sha": "61a2e8407303b730c6ae88ac076e5e293720b666", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -42,6 +42,10 @@ impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n             ast::ExprLoop(ref b, _) => {\n                 self.visit_block(&**b, Loop);\n             }\n+            ast::ExprForLoop(_, ref e, ref b, _) => {\n+                self.visit_expr(&**e, cx);\n+                self.visit_block(&**b, Loop);\n+            }\n             ast::ExprFnBlock(_, ref b) |\n             ast::ExprProc(_, ref b) |\n             ast::ExprUnboxedFn(_, ref b) => {"}, {"sha": "e458b82f03634359ef1f561fd1ff5f5c58d83dbb", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -170,6 +170,24 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix);\n         },\n+        ExprForLoop(ref pat, _, _, _) => {\n+            let mut static_inliner = StaticInliner {\n+                tcx: cx.tcx\n+            };\n+            match is_refutable(cx, static_inliner.fold_pat(*pat)) {\n+                Some(uncovered_pat) => {\n+                    cx.tcx.sess.span_err(\n+                        pat.span,\n+                        format!(\"refutable pattern in `for` loop binding: \\\n+                                 `{}` not covered\",\n+                                pat_to_string(&*uncovered_pat)).as_slice());\n+                },\n+                None => {}\n+            }\n+\n+            // Check legality of move bindings.\n+            check_legality_of_move_bindings(cx, false, [ *pat ]);\n+        }\n         _ => ()\n     }\n }"}, {"sha": "108bd35424aece8203ed05a12e4faef1cbb21fba", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -354,11 +354,11 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n     // depending on whether a crate is built as bin or lib, and we want\n     // the warning to be consistent, we also seed the worklist with\n     // exported symbols.\n-    for &id in exported_items.iter() {\n-        worklist.push(id);\n+    for id in exported_items.iter() {\n+        worklist.push(*id);\n     }\n-    for &id in reachable_symbols.iter() {\n-        worklist.push(id);\n+    for id in reachable_symbols.iter() {\n+        worklist.push(*id);\n     }\n \n     // Seed entry point"}, {"sha": "7995317d49fd160c160a3fb245f82c7d7a7cc4c5", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -79,7 +79,8 @@ pub enum LoanCause {\n     AutoRef,\n     RefBinding,\n     OverloadedOperator,\n-    ClosureInvocation\n+    ClosureInvocation,\n+    ForLoop,\n }\n \n #[deriving(PartialEq,Show)]\n@@ -395,7 +396,16 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                 self.walk_block(&**blk);\n             }\n \n-            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n+                // The pattern lives as long as the block.\n+                debug!(\"walk_expr for loop case: blk id={}\", blk.id);\n+                self.walk_expr(&**head);\n+\n+                let head_cmt = return_if_err!(self.mc.cat_expr(&**head));\n+                self.walk_pat(head_cmt, pat.clone());\n+\n+                self.walk_block(&**blk);\n+            }\n \n             ast::ExprUnary(_, ref lhs) => {\n                 if !self.walk_overloaded_operator(expr, &**lhs, []) {"}, {"sha": "f59909bd138b25b1274d5dd8709c5d73bba03c38", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -299,5 +299,7 @@ lets_do_this! {\n     NoShareItem,                     \"no_share_bound\",          no_share_bound;\n     ManagedItem,                     \"managed_bound\",           managed_bound;\n \n+    IteratorItem,                    \"iterator\",                iterator;\n+\n     StackExhaustedLangItem,          \"stack_exhausted\",         stack_exhausted;\n }"}, {"sha": "1c31b671a947bafe1118999bdafb28b32e937686", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -125,6 +125,17 @@ use syntax::print::pprust::{expr_to_string, block_to_string};\n use syntax::{visit, ast_util};\n use syntax::visit::{Visitor, FnKind};\n \n+/// For use with `propagate_through_loop`.\n+#[deriving(PartialEq, Eq)]\n+enum LoopKind {\n+    /// An endless `loop` loop.\n+    LoopLoop,\n+    /// A `while` loop, with the given expression as condition.\n+    WhileLoop(Gc<Expr>),\n+    /// A `for` loop.\n+    ForLoop,\n+}\n+\n #[deriving(PartialEq)]\n struct Variable(uint);\n #[deriving(PartialEq)]\n@@ -480,7 +491,20 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr, ());\n       }\n-      ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n+      ExprForLoop(ref pat, _, _, _) => {\n+        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n+            debug!(\"adding local variable {} from for loop with bm {:?}\",\n+                   p_id, bm);\n+            let name = path1.node;\n+            ir.add_live_node_for_node(p_id, VarDefNode(sp));\n+            ir.add_variable(Local(LocalInfo {\n+                id: p_id,\n+                ident: name\n+            }));\n+        });\n+        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        visit::walk_expr(ir, expr, ());\n+      }\n       ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr, ());\n@@ -994,15 +1018,21 @@ impl<'a> Liveness<'a> {\n           }\n \n           ExprWhile(ref cond, ref blk) => {\n-            self.propagate_through_loop(expr, Some(cond.clone()), &**blk, succ)\n+            self.propagate_through_loop(expr,\n+                                        WhileLoop(cond.clone()),\n+                                        &**blk,\n+                                        succ)\n           }\n \n-          ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n+          ExprForLoop(_, ref head, ref blk, _) => {\n+            let ln = self.propagate_through_loop(expr, ForLoop, &**blk, succ);\n+            self.propagate_through_expr(&**head, ln)\n+          }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n           ExprLoop(ref blk, _) => {\n-            self.propagate_through_loop(expr, None, &**blk, succ)\n+            self.propagate_through_loop(expr, LoopLoop, &**blk, succ)\n           }\n \n           ExprMatch(ref e, ref arms) => {\n@@ -1281,7 +1311,7 @@ impl<'a> Liveness<'a> {\n \n     fn propagate_through_loop(&mut self,\n                               expr: &Expr,\n-                              cond: Option<Gc<Expr>>,\n+                              kind: LoopKind,\n                               body: &Block,\n                               succ: LiveNode)\n                               -> LiveNode {\n@@ -1309,26 +1339,35 @@ impl<'a> Liveness<'a> {\n         let mut first_merge = true;\n         let ln = self.live_node(expr.id, expr.span);\n         self.init_empty(ln, succ);\n-        if cond.is_some() {\n-            // if there is a condition, then it's possible we bypass\n-            // the body altogether.  otherwise, the only way is via a\n-            // break in the loop body.\n+        if kind != LoopLoop {\n+            // If this is not a `loop` loop, then it's possible we bypass\n+            // the body altogether. Otherwise, the only way is via a `break`\n+            // in the loop body.\n             self.merge_from_succ(ln, succ, first_merge);\n             first_merge = false;\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, block_to_string(body));\n \n-        let cond_ln = self.propagate_through_opt_expr(cond, ln);\n+        let cond_ln = match kind {\n+            LoopLoop | ForLoop => ln,\n+            WhileLoop(ref cond) => self.propagate_through_expr(&**cond, ln),\n+        };\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n             this.propagate_through_block(body, cond_ln)\n         });\n \n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n-            assert!(cond_ln == self.propagate_through_opt_expr(cond,\n-                                                                    ln));\n+\n+            let new_cond_ln = match kind {\n+                LoopLoop | ForLoop => ln,\n+                WhileLoop(ref cond) => {\n+                    self.propagate_through_expr(&**cond, ln)\n+                }\n+            };\n+            assert!(cond_ln == new_cond_ln);\n             assert!(body_ln == self.with_loop_nodes(expr.id, succ, ln,\n             |this| this.propagate_through_block(body, cond_ln)));\n         }\n@@ -1415,10 +1454,9 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n       ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) |\n-      ExprPath(..) | ExprBox(..) => {\n+      ExprPath(..) | ExprBox(..) | ExprForLoop(..) => {\n         visit::walk_expr(this, expr, ());\n       }\n-      ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")\n     }\n }\n "}, {"sha": "317fdb5c387e2ee62b7b80e63bce79035339b642", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -482,11 +482,10 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n           ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n-          ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n+          ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n+          ast::ExprForLoop(..) => {\n             Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n-\n-          ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")\n         }\n     }\n \n@@ -1113,7 +1112,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n-            // @p1, ~p1\n+            // @p1, ~p1, ref p1\n             let subcmt = self.cat_deref(pat, cmt, 0, false);\n             if_ok!(self.cat_pattern(subcmt, &**subpat, op));\n           }"}, {"sha": "7ed1209bdf75097485a6f2043565948230e65479", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -365,8 +365,8 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     //         other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    for &id in exported_items.iter() {\n-        reachable_context.worklist.push(id);\n+    for id in exported_items.iter() {\n+        reachable_context.worklist.push(*id);\n     }\n     for (_, item) in tcx.lang_items.items() {\n         match *item {"}, {"sha": "5f5a324857ab975dd61a7a9f0c0d8722cf8ca6c2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -208,7 +208,9 @@ impl RegionMaps {\n     pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n         //! Returns the lifetime of the variable `id`.\n \n-        ty::ReScope(self.var_scope(id))\n+        let scope = ty::ReScope(self.var_scope(id));\n+        debug!(\"var_region({}) = {:?}\", id, scope);\n+        scope\n     }\n \n     pub fn scopes_intersect(&self, scope1: ast::NodeId, scope2: ast::NodeId)\n@@ -524,6 +526,14 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n             visitor.region_maps.mark_as_terminating_scope(body.id);\n         }\n \n+        ast::ExprForLoop(ref _pat, ref _head, ref body, _) => {\n+            visitor.region_maps.mark_as_terminating_scope(body.id);\n+\n+            // The variable parent of everything inside (most importantly, the\n+            // pattern) is the body.\n+            new_cx.var_parent = Some(body.id);\n+        }\n+\n         ast::ExprMatch(..) => {\n             new_cx.var_parent = Some(expr.id);\n         }"}, {"sha": "95c04ad6607d66ead0852153c3689e4b233ee014", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -5329,7 +5329,42 @@ impl<'a> Resolver<'a> {\n                 })\n             }\n \n-            ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(ref pattern, ref head, ref body, optional_label) => {\n+                self.resolve_expr(&**head);\n+\n+                self.value_ribs.borrow_mut().push(Rib::new(NormalRibKind));\n+\n+                self.resolve_pattern(&**pattern,\n+                                     LocalIrrefutableMode,\n+                                     &mut HashMap::new());\n+\n+                match optional_label {\n+                    None => {}\n+                    Some(label) => {\n+                        self.label_ribs\n+                            .borrow_mut()\n+                            .push(Rib::new(NormalRibKind));\n+                        let def_like = DlDef(DefLabel(expr.id));\n+\n+                        {\n+                            let label_ribs = self.label_ribs.borrow();\n+                            let length = label_ribs.len();\n+                            let rib = label_ribs.get(length - 1);\n+                            let renamed = mtwt::resolve(label);\n+                            rib.bindings.borrow_mut().insert(renamed,\n+                                                             def_like);\n+                        }\n+                    }\n+                }\n+\n+                self.resolve_block(&**body);\n+\n+                if optional_label.is_some() {\n+                    drop(self.label_ribs.borrow_mut().pop())\n+                }\n+\n+                self.value_ribs.borrow_mut().pop();\n+            }\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 let renamed = mtwt::resolve(label);"}, {"sha": "0b181d2cf367a2f2ab62262e8a4c37528728ae03", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -1543,6 +1543,31 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n     }\n }\n \n+/// Generates code for the pattern binding in a `for` loop like\n+/// `for <pat> in <expr> { ... }`.\n+pub fn store_for_loop_binding<'a>(\n+                              bcx: &'a Block<'a>,\n+                              pat: Gc<ast::Pat>,\n+                              llvalue: ValueRef,\n+                              body_scope: cleanup::ScopeId)\n+                              -> &'a Block<'a> {\n+    let _icx = push_ctxt(\"match::store_for_loop_binding\");\n+\n+    if simple_identifier(&*pat).is_some() {\n+        // Generate nicer LLVM for the common case of a `for` loop pattern\n+        // like `for x in blahblah { ... }`.\n+        let binding_type = node_id_type(bcx, pat.id);\n+        bcx.fcx.lllocals.borrow_mut().insert(pat.id,\n+                                             Datum::new(llvalue,\n+                                                        binding_type,\n+                                                        Lvalue));\n+        return bcx\n+    }\n+\n+    // General path. Copy out the values that are used in the pattern.\n+    bind_irrefutable_pat(bcx, pat, llvalue, BindLocal, body_scope)\n+}\n+\n fn mk_binding_alloca<'a,A>(bcx: &'a Block<'a>,\n                            p_id: ast::NodeId,\n                            ident: &ast::Ident,"}, {"sha": "d8a8cc1c561a902178a4d486bcb16f29115db5f2", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -12,16 +12,23 @@ use llvm::*;\n use driver::config::FullDebugInfo;\n use middle::def;\n use middle::lang_items::{FailFnLangItem, FailBoundsCheckFnLangItem};\n+use middle::trans::_match;\n+use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::cleanup;\n use middle::trans::common::*;\n+use middle::trans::datum;\n use middle::trans::debuginfo;\n use middle::trans::expr;\n+use middle::trans::meth;\n+use middle::trans::type_::Type;\n use middle::ty;\n+use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n+use util::ppaux;\n \n use syntax::ast;\n use syntax::ast::Ident;\n@@ -237,6 +244,129 @@ pub fn trans_while<'a>(bcx: &'a Block<'a>,\n     return next_bcx_in;\n }\n \n+/// Translates a `for` loop.\n+pub fn trans_for<'a>(\n+                 mut bcx: &'a Block<'a>,\n+                 loop_info: NodeInfo,\n+                 pat: Gc<ast::Pat>,\n+                 head: &ast::Expr,\n+                 body: &ast::Block)\n+                 -> &'a Block<'a> {\n+    let _icx = push_ctxt(\"trans_for\");\n+\n+    //            bcx\n+    //             |\n+    //      loopback_bcx_in  <-------+\n+    //             |                 |\n+    //      loopback_bcx_out         |\n+    //           |      |            |\n+    //           |    body_bcx_in    |\n+    // cleanup_blk      |            |\n+    //    |           body_bcx_out --+\n+    // next_bcx_in\n+\n+    // Codegen the head to create the iterator value.\n+    let iterator_datum =\n+        unpack_datum!(bcx, expr::trans_to_lvalue(bcx, head, \"for_head\"));\n+    let iterator_type = node_id_type(bcx, head.id);\n+    debug!(\"iterator type is {}, datum type is {}\",\n+           ppaux::ty_to_string(bcx.tcx(), iterator_type),\n+           ppaux::ty_to_string(bcx.tcx(), iterator_datum.ty));\n+    let lliterator = load_ty(bcx, iterator_datum.val, iterator_datum.ty);\n+\n+    // Create our basic blocks and set up our loop cleanups.\n+    let next_bcx_in = bcx.fcx.new_id_block(\"for_exit\", loop_info.id);\n+    let loopback_bcx_in = bcx.fcx.new_id_block(\"for_loopback\", head.id);\n+    let body_bcx_in = bcx.fcx.new_id_block(\"for_body\", body.id);\n+    bcx.fcx.push_loop_cleanup_scope(loop_info.id,\n+                                    [next_bcx_in, loopback_bcx_in]);\n+    Br(bcx, loopback_bcx_in.llbb);\n+    let cleanup_llbb = bcx.fcx.normal_exit_block(loop_info.id,\n+                                                 cleanup::EXIT_BREAK);\n+\n+    // Set up the method call (to `.next()`).\n+    let method_call = MethodCall::expr(loop_info.id);\n+    let method_type = loopback_bcx_in.tcx()\n+                                     .method_map\n+                                     .borrow()\n+                                     .get(&method_call)\n+                                     .ty;\n+    let method_type = monomorphize_type(loopback_bcx_in, method_type);\n+    let method_result_type = ty::ty_fn_ret(method_type);\n+    let option_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n+    let option_cleanup_scope_id = cleanup::CustomScope(option_cleanup_scope);\n+\n+    // Compile the method call (to `.next()`).\n+    let mut loopback_bcx_out = loopback_bcx_in;\n+    let option_datum =\n+        unpack_datum!(loopback_bcx_out,\n+                      datum::lvalue_scratch_datum(loopback_bcx_out,\n+                                                  method_result_type,\n+                                                  \"loop_option\",\n+                                                  false,\n+                                                  option_cleanup_scope_id,\n+                                                  (),\n+                                                  |(), bcx, lloption| {\n+        let Result {\n+            bcx: bcx,\n+            val: _\n+        } = callee::trans_call_inner(bcx,\n+                                     Some(loop_info),\n+                                     method_type,\n+                                     |bcx, arg_cleanup_scope| {\n+                                         meth::trans_method_callee(\n+                                             bcx,\n+                                             method_call,\n+                                             None,\n+                                             arg_cleanup_scope)\n+                                     },\n+                                     callee::ArgVals([lliterator]),\n+                                     Some(expr::SaveIn(lloption)));\n+        bcx\n+    }));\n+\n+    // Check the discriminant; if the `None` case, exit the loop.\n+    let option_representation = adt::represent_type(loopback_bcx_out.ccx(),\n+                                                    method_result_type);\n+    let i8_type = Type::i8(loopback_bcx_out.ccx());\n+    let lldiscriminant = adt::trans_get_discr(loopback_bcx_out,\n+                                              &*option_representation,\n+                                              option_datum.val,\n+                                              Some(i8_type));\n+    let llzero = C_u8(loopback_bcx_out.ccx(), 0);\n+    let llcondition = ICmp(loopback_bcx_out, IntNE, lldiscriminant, llzero);\n+    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb);\n+\n+    // Now we're in the body. Unpack the `Option` value into the programmer-\n+    // supplied pattern.\n+    let llpayload = adt::trans_field_ptr(body_bcx_in,\n+                                         &*option_representation,\n+                                         option_datum.val,\n+                                         1,\n+                                         0);\n+    let binding_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n+    let binding_cleanup_scope_id =\n+        cleanup::CustomScope(binding_cleanup_scope);\n+    let mut body_bcx_out =\n+        _match::store_for_loop_binding(body_bcx_in,\n+                                       pat,\n+                                       llpayload,\n+                                       binding_cleanup_scope_id);\n+\n+    // Codegen the body.\n+    body_bcx_out = trans_block(body_bcx_out, body, expr::Ignore);\n+    body_bcx_out.fcx.pop_custom_cleanup_scope(binding_cleanup_scope);\n+    body_bcx_out =\n+        body_bcx_out.fcx\n+                    .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n+                                                        option_cleanup_scope);\n+    Br(body_bcx_out, loopback_bcx_in.llbb);\n+\n+    // Codegen cleanups and leave.\n+    next_bcx_in.fcx.pop_loop_cleanup_scope(loop_info.id);\n+    next_bcx_in\n+}\n+\n pub fn trans_loop<'a>(bcx:&'a Block<'a>,\n                       loop_id: ast::NodeId,\n                       body: &ast::Block)"}, {"sha": "6fe3ee5d29b5839235ddd2e959fe499a7b335901", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -3582,9 +3582,24 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            ast::ExprForLoop(_, _, _, _) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n-                                              Found unexpanded for-loop.\");\n+            ast::ExprForLoop(ref pattern, ref head, ref body, _) => {\n+                walk_expr(cx, &**head, scope_stack, scope_map);\n+\n+                with_new_scope(cx,\n+                               exp.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n+                    scope_map.insert(exp.id,\n+                                     scope_stack.last()\n+                                                .unwrap()\n+                                                .scope_metadata);\n+                    walk_pattern(cx,\n+                                 *pattern,\n+                                 scope_stack,\n+                                 scope_map);\n+                    walk_block(cx, &**body, scope_stack, scope_map);\n+                })\n             }\n \n             ast::ExprMac(_) => {"}, {"sha": "9d970b1a393c512a3dd042279deda0c31b10b925", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -665,6 +665,13 @@ fn trans_rvalue_stmt_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprWhile(ref cond, ref body) => {\n             controlflow::trans_while(bcx, expr.id, &**cond, &**body)\n         }\n+        ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n+            controlflow::trans_for(bcx,\n+                                   expr_info(expr),\n+                                   *pat,\n+                                   &**head,\n+                                   &**body)\n+        }\n         ast::ExprLoop(ref body, _) => {\n             controlflow::trans_loop(bcx, expr.id, &**body)\n         }"}, {"sha": "8f60fe340e4d61ae122f4ed0c4a1ce6ff1948e45", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -3090,7 +3090,7 @@ pub enum ExprKind {\n pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n     if tcx.method_map.borrow().contains_key(&typeck::MethodCall::expr(expr.id)) {\n         // Overloaded operations are generally calls, and hence they are\n-        // generated via DPS, but there are two exceptions:\n+        // generated via DPS, but there are a few exceptions:\n         return match expr.node {\n             // `a += b` has a unit result.\n             ast::ExprAssignOp(..) => RvalueStmtExpr,\n@@ -3101,6 +3101,9 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // the index method invoked for `a[i]` always yields an `&T`\n             ast::ExprIndex(..) => LvalueExpr,\n \n+            // `for` loops are statements\n+            ast::ExprForLoop(..) => RvalueStmtExpr,\n+\n             // in the general case, result could be any type, use DPS\n             _ => RvalueDpsExpr\n         };\n@@ -3209,12 +3212,11 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprLoop(..) |\n         ast::ExprAssign(..) |\n         ast::ExprInlineAsm(..) |\n-        ast::ExprAssignOp(..) => {\n+        ast::ExprAssignOp(..) |\n+        ast::ExprForLoop(..) => {\n             RvalueStmtExpr\n         }\n \n-        ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n-\n         ast::ExprLit(_) | // Note: LitStr is carved out above\n         ast::ExprUnary(..) |\n         ast::ExprAddrOf(..) |"}, {"sha": "3f54677c08b2456c38ad95c5a588038bed88bdf8", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -21,6 +21,7 @@ use middle::typeck::check::{instantiate_path, lookup_def};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n use middle::typeck::infer;\n use middle::typeck::require_same_types;\n+use util::ppaux;\n \n use std::collections::{HashMap, HashSet};\n use std::gc::Gc;\n@@ -484,7 +485,10 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, typ);\n \n-        debug!(\"(checking match) writing type for pat id {}\", pat.id);\n+        debug!(\"(checking match) writing type {} (expected {}) for pat id {}\",\n+               ppaux::ty_to_string(tcx, typ),\n+               ppaux::ty_to_string(tcx, expected),\n+               pat.id);\n \n         match sub {\n           Some(ref p) => check_pat(pcx, &**p, expected),"}, {"sha": "fd6b3a20a1936d1408fbb9d6545d1e0d07e32092", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 89, "deletions": 2, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -79,6 +79,7 @@ type parameter).\n \n use middle::const_eval;\n use middle::def;\n+use middle::lang_items::IteratorItem;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::subst;\n@@ -1708,6 +1709,80 @@ fn try_overloaded_index(fcx: &FnCtxt,\n     }\n }\n \n+/// Given the head of a `for` expression, looks up the `next` method in the\n+/// `Iterator` trait. Fails if the expression does not implement `next`.\n+///\n+/// The return type of this function represents the concrete element type\n+/// `A` in the type `Iterator<A>` that the method returns.\n+fn lookup_method_for_for_loop(fcx: &FnCtxt,\n+                              iterator_expr: Gc<ast::Expr>,\n+                              loop_id: ast::NodeId)\n+                              -> ty::t {\n+    let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n+        Ok(trait_did) => trait_did,\n+        Err(ref err_string) => {\n+            fcx.tcx().sess.span_err(iterator_expr.span,\n+                                    err_string.as_slice());\n+            return ty::mk_err()\n+        }\n+    };\n+\n+    let method = method::lookup_in_trait(fcx,\n+                                         iterator_expr.span,\n+                                         Some(&*iterator_expr),\n+                                         token::intern(\"next\"),\n+                                         trait_did,\n+                                         fcx.expr_ty(&*iterator_expr),\n+                                         [],\n+                                         DontAutoderefReceiver,\n+                                         IgnoreStaticMethods);\n+\n+    // Regardless of whether the lookup succeeds, check the method arguments\n+    // so that we have *some* type for each argument.\n+    let method_type = match method {\n+        Some(ref method) => method.ty,\n+        None => {\n+            fcx.tcx().sess.span_err(iterator_expr.span,\n+                                    \"`for` loop expression does not \\\n+                                     implement the `Iterator` trait\");\n+            ty::mk_err()\n+        }\n+    };\n+    let return_type = check_method_argument_types(fcx,\n+                                                  iterator_expr.span,\n+                                                  method_type,\n+                                                  &*iterator_expr,\n+                                                  [iterator_expr],\n+                                                  DontDerefArgs,\n+                                                  DontTupleArguments);\n+\n+    match method {\n+        Some(method) => {\n+            fcx.inh.method_map.borrow_mut().insert(MethodCall::expr(loop_id),\n+                                                   method);\n+\n+            // We expect the return type to be `Option` or something like it.\n+            // Grab the first parameter of its type substitution.\n+            let return_type = structurally_resolved_type(fcx,\n+                                                         iterator_expr.span,\n+                                                         return_type);\n+            match ty::get(return_type).sty {\n+                ty::ty_enum(_, ref substs)\n+                        if !substs.types.is_empty_in(subst::TypeSpace) => {\n+                    *substs.types.get(subst::TypeSpace, 0)\n+                }\n+                _ => {\n+                    fcx.tcx().sess.span_err(iterator_expr.span,\n+                                            \"`next` method of the `Iterator` \\\n+                                             trait has an unexpected type\");\n+                    ty::mk_err()\n+                }\n+            }\n+        }\n+        None => ty::mk_err()\n+    }\n+}\n+\n fn check_method_argument_types(fcx: &FnCtxt,\n                                sp: Span,\n                                method_fn_ty: ty::t,\n@@ -3273,8 +3348,20 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprForLoop(..) =>\n-          fail!(\"non-desugared expr_for_loop\"),\n+      ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n+        check_expr(fcx, &**head);\n+        let typ = lookup_method_for_for_loop(fcx, *head, expr.id);\n+        vtable::early_resolve_expr(expr, fcx, true);\n+\n+        let pcx = pat_ctxt {\n+            fcx: fcx,\n+            map: pat_id_map(&tcx.def_map, &**pat),\n+        };\n+        _match::check_pat(&pcx, &**pat, typ);\n+\n+        check_block_no_value(fcx, &**block);\n+        fcx.write_nil(id);\n+      }\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, &**body);\n         if !may_break(tcx, expr.id, body.clone()) {"}, {"sha": "d0431de81a359543d4daa30baca6952bacd0024d", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -609,6 +609,22 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n+        ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n+            constrain_bindings_in_pat(&**pat, rcx);\n+\n+            {\n+                let mc = mc::MemCategorizationContext::new(rcx);\n+                let head_cmt = ignore_err!(mc.cat_expr(&**head));\n+                link_pattern(rcx, mc, head_cmt, &**pat);\n+            }\n+\n+            rcx.visit_expr(&**head, ());\n+\n+            let repeating_scope = rcx.set_repeating_scope(body.id);\n+            rcx.visit_block(&**body, ());\n+            rcx.set_repeating_scope(repeating_scope);\n+        }\n+\n         _ => {\n             visit::walk_expr(rcx, expr, ());\n         }"}, {"sha": "565b88b74939b9505e6f42a02a6bf9f30684e7a4", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -756,7 +756,8 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n       ast::ExprUnary(_, _) |\n       ast::ExprAssignOp(_, _, _) |\n       ast::ExprIndex(_, _) |\n-      ast::ExprMethodCall(_, _, _) => {\n+      ast::ExprMethodCall(_, _, _) |\n+      ast::ExprForLoop(..) => {\n         match fcx.inh.method_map.borrow().find(&MethodCall::expr(ex.id)) {\n           Some(method) => {\n               debug!(\"vtable resolution on parameter bounds for method call {}\","}, {"sha": "dc0f2a9ffff73a0ba0608bcd9a2459c57e17f483", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -419,8 +419,8 @@ impl<'a> CoherenceChecker<'a> {\n     }\n \n     fn check_implementation_coherence(&self) {\n-        for &trait_id in self.crate_context.tcx.trait_impls.borrow().keys() {\n-            self.check_implementation_coherence_of(trait_id);\n+        for trait_id in self.crate_context.tcx.trait_impls.borrow().keys() {\n+            self.check_implementation_coherence_of(*trait_id);\n         }\n     }\n "}, {"sha": "9c9942d2628eb31efc67d1a26146be9ffe0413a2", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -66,7 +66,7 @@ impl<'a> Visitor<()> for LoopQueryVisitor<'a> {\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n-          ast::ExprLoop(..) | ast::ExprWhile(..) => {}\n+          ast::ExprLoop(..) | ast::ExprWhile(..) | ast::ExprForLoop(..) => {}\n           _ => visit::walk_expr(self, e, ())\n         }\n     }"}, {"sha": "94dea6cb540e330f48176a1d5b4e408754a3dc68", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -252,6 +252,7 @@ mod svh_visitor {\n         SawExprStruct,\n         SawExprRepeat,\n         SawExprParen,\n+        SawExprForLoop,\n     }\n \n     fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n@@ -287,9 +288,9 @@ mod svh_visitor {\n             ExprStruct(..)           => SawExprStruct,\n             ExprRepeat(..)           => SawExprRepeat,\n             ExprParen(..)            => SawExprParen,\n+            ExprForLoop(..)          => SawExprForLoop,\n \n             // just syntactic artifacts, expanded away by time of SVH.\n-            ExprForLoop(..)          => unreachable!(),\n             ExprMac(..)              => unreachable!(),\n         }\n     }"}, {"sha": "f580dfd80f0ce668a8a25ed9a4f3c496cfa64e61", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -12,7 +12,7 @@\n \n use io::{fs, IoResult};\n use io;\n-use iter::{Iterator, range};\n+use iter::range;\n use libc;\n use ops::Drop;\n use option::{Option, None, Some};\n@@ -21,6 +21,9 @@ use path::{Path, GenericPath};\n use result::{Ok, Err};\n use sync::atomics;\n \n+#[cfg(stage0)]\n+use iter::Iterator; // NOTE(stage0): Remove after snapshot.\n+\n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-based deletion.\n pub struct TempDir {"}, {"sha": "f82796b480a4eff429082fffd1c5a45b747123ea", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 97, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -62,108 +62,18 @@ fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n             }\n         }\n \n-        // Desugar expr_for_loop\n-        // From: `['<ident>:] for <src_pat> in <src_expr> <src_loop_block>`\n-        // FIXME #6993: change type of opt_ident to Option<Name>\n-        ast::ExprForLoop(src_pat, src_expr, src_loop_block, opt_ident) => {\n-\n-            let span = e.span;\n-\n-            // to:\n-            //\n-            //   match &mut <src_expr> {\n-            //     i => {\n-            //       ['<ident>:] loop {\n-            //         match i.next() {\n-            //           None => break ['<ident>],\n-            //           Some(mut value) => {\n-            //             let <src_pat> = value;\n-            //             <src_loop_block>\n-            //           }\n-            //         }\n-            //       }\n-            //     }\n-            //   }\n-            //\n-            // (The use of the `let` is to give better error messages\n-            // when the pattern is refutable.)\n-\n-            let local_ident = token::gensym_ident(\"i\");\n-            let next_ident = fld.cx.ident_of(\"next\");\n-            let none_ident = fld.cx.ident_of(\"None\");\n-\n-            let local_path = fld.cx.path_ident(span, local_ident);\n-            let some_path = fld.cx.path_ident(span, fld.cx.ident_of(\"Some\"));\n-\n-            // `None => break ['<ident>],`\n-            let none_arm = {\n-                let break_expr = fld.cx.expr(span, ast::ExprBreak(opt_ident));\n-                let none_pat = fld.cx.pat_ident(span, none_ident);\n-                fld.cx.arm(span, vec!(none_pat), break_expr)\n-            };\n-\n-            // let <src_pat> = value;\n-            // use underscore to suppress lint error:\n-            let value_ident = token::gensym_ident(\"_value\");\n-            // this is careful to use src_pat.span so that error\n-            // messages point exact at that.\n-            let local = box(GC) ast::Local {\n-                ty: fld.cx.ty_infer(src_pat.span),\n-                pat: src_pat,\n-                init: Some(fld.cx.expr_ident(src_pat.span, value_ident)),\n-                id: ast::DUMMY_NODE_ID,\n-                span: src_pat.span,\n-                source: ast::LocalFor\n-            };\n-            let local = codemap::respan(src_pat.span, ast::DeclLocal(local));\n-            let local = box(GC) codemap::respan(span, ast::StmtDecl(box(GC) local,\n-                                                            ast::DUMMY_NODE_ID));\n-\n-            // { let ...; <src_loop_block> }\n-            let block = fld.cx.block(span, vec![local],\n-                                     Some(fld.cx.expr_block(src_loop_block)));\n-\n-            // `Some(mut value) => { ... }`\n-            // Note the _'s in the name will stop any unused mutability warnings.\n-            let value_pat = fld.cx.pat_ident_binding_mode(span, value_ident,\n-                                                          ast::BindByValue(ast::MutMutable));\n-            let some_arm =\n-                fld.cx.arm(span,\n-                           vec!(fld.cx.pat_enum(span, some_path, vec!(value_pat))),\n-                           fld.cx.expr_block(block));\n-\n-            // `match i.next() { ... }`\n-            let match_expr = {\n-                let next_call_expr =\n-                    fld.cx.expr_method_call(span,\n-                                            fld.cx.expr_path(local_path),\n-                                            next_ident,\n-                                            Vec::new());\n-\n-                fld.cx.expr_match(span, next_call_expr, vec!(none_arm, some_arm))\n-            };\n-\n-            // ['ident:] loop { ... }\n-            let loop_expr = fld.cx.expr(span,\n-                                        ast::ExprLoop(fld.cx.block_expr(match_expr),\n-                                                      opt_ident));\n-\n-            // `i => loop { ... }`\n-\n-            // `match &mut <src_expr> { i => loop { ... } }`\n-            let discrim = fld.cx.expr_mut_addr_of(span, src_expr);\n-            let i_pattern = fld.cx.pat_ident(span, local_ident);\n-            let arm = fld.cx.arm(span, vec!(i_pattern), loop_expr);\n-            // why these clone()'s everywhere? I guess I'll follow the pattern....\n-            let match_expr = fld.cx.expr_match(span, discrim, vec!(arm));\n-            fld.fold_expr(match_expr).clone()\n-        }\n-\n         ast::ExprLoop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n             fld.cx.expr(e.span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n+        ast::ExprForLoop(pat, head, body, opt_ident) => {\n+            let pat = fld.fold_pat(pat);\n+            let head = fld.fold_expr(head);\n+            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n+            fld.cx.expr(e.span, ast::ExprForLoop(pat, head, body, opt_ident))\n+        }\n+\n         ast::ExprFnBlock(fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(&*fn_decl, block, fld);"}, {"sha": "25e06bf7c13f0d61f52165b8bdb7888ac36d6711", "filename": "src/libunicode/decompose.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibunicode%2Fdecompose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Flibunicode%2Fdecompose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fdecompose.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -39,6 +39,7 @@ pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n \n fn d(c: char, i: |char|, k: bool) {\n+    #[cfg(stage0)]\n     use core::iter::Iterator;\n \n     // 7-bit ASCII never decomposes"}, {"sha": "615dd1d69d501ba18df36bc3a638c26e79f0906b", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -297,10 +297,10 @@ fn search(\n     // for every unused piece\n     for id in range(0u, 10).filter(|id| board & (1 << (id + 50)) == 0) {\n         // for each mask that fits on the board\n-        for &m in masks_at.get(id).iter().filter(|&m| board & *m == 0) {\n+        for m in masks_at.get(id).iter().filter(|&m| board & *m == 0) {\n             // This check is too costy.\n             //if is_board_unfeasible(board | m, masks) {continue;}\n-            search(masks, board | m, i + 1, Cons(m, &cur), data);\n+            search(masks, board | *m, i + 1, Cons(*m, &cur), data);\n         }\n     }\n }\n@@ -311,9 +311,10 @@ fn par_search(masks: Vec<Vec<Vec<u64>>>) -> Data {\n \n     // launching the search in parallel on every masks at minimum\n     // coordinate (0,0)\n-    for &m in masks.get(0).iter().flat_map(|masks_pos| masks_pos.iter()) {\n+    for m in masks.get(0).iter().flat_map(|masks_pos| masks_pos.iter()) {\n         let masks = masks.clone();\n         let tx = tx.clone();\n+        let m = *m;\n         spawn(proc() {\n             let mut data = Data::new();\n             search(&*masks, m, 1, Cons(m, &Nil), &mut data);"}, {"sha": "ba268cf3d64792920bb790516e41391f6515a5f6", "filename": "src/test/compile-fail/for-loop-bogosity.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-bogosity.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct MyStruct {\n+    x: int,\n+    y: int,\n+}\n+\n+impl MyStruct {\n+    fn next(&mut self) -> Option<int> {\n+        Some(self.x)\n+    }\n+}\n+\n+pub fn main() {\n+    let mut bogus = MyStruct {\n+        x: 1,\n+        y: 2,\n+    };\n+    for x in bogus {    //~ ERROR does not implement the `Iterator` trait\n+        drop(x);\n+    }\n+}\n+"}, {"sha": "300831b100773f0976fb6bf0dee16cdcbeaec0af", "filename": "src/test/compile-fail/issue-15167.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -9,13 +9,18 @@\n // except according to those terms.\n \n // macro f should not be able to inject a reference to 'n'.\n+//\n+// Ignored because `for` loops are not hygienic yet; they will require special\n+// handling since they introduce a new pattern binding position.\n+\n+// ignore-test\n \n #![feature(macro_rules)]\n \n macro_rules! f(() => (n))\n \n fn main() -> (){\n-    for n in range(0, 1) {\n+    for n in range(0i, 1) {\n         println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n     }\n }"}, {"sha": "9060ed7495ee535982ada58fc0a7a690fe2fdc4f", "filename": "src/test/compile-fail/vec-mut-iter-borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n fn main() {\n-    let mut xs = vec!(1i, 2, 3, 4);\n+    let mut xs: Vec<int> = vec!();\n \n     for x in xs.mut_iter() {\n-        xs.push(1) //~ ERROR cannot borrow `xs`\n+        xs.push(1i) //~ ERROR cannot borrow `xs`\n     }\n }"}, {"sha": "74d54624318224b09f20e04306a9f90cff6703d1", "filename": "src/test/debuginfo/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // ignore-android: FIXME(#10381)\n+// ignore-test: Not sure what is going on here --pcwalton\n \n // compile-flags:-g\n "}, {"sha": "73f4cdd252e6f0577dc694fbaa00a3af7de40118", "filename": "src/test/run-pass/for-loop-goofiness.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Frun-pass%2Ffor-loop-goofiness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa564bea3d5f5a24d0797c4769184c1ea0abaff/src%2Ftest%2Frun-pass%2Ffor-loop-goofiness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-loop-goofiness.rs?ref=caa564bea3d5f5a24d0797c4769184c1ea0abaff", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum BogusOption<T> {\n+    None,\n+    Some(T),\n+}\n+\n+type Iterator = int;\n+\n+pub fn main() {\n+    let x = [ 3i, 3, 3 ];\n+    for i in x.iter() {\n+        assert_eq!(*i, 3);\n+    }\n+}\n+"}]}