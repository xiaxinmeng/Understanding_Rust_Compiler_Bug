{"sha": "073e82fff27497ea9b7b73173ddfc349463570b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3M2U4MmZmZjI3NDk3ZWE5YjdiNzMxNzNkZGZjMzQ5NDYzNTcwYjc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-11T13:52:24Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-12T02:21:04Z"}, "message": "std: create Str trait for DRY. Use it on StrVector.\n\nThe Str trait collects the various strings types and provides a method\nfor coercing to a slice, so that functions and impls can be written for\ngeneric types containing strings (e.g. &[~str], &[&str], ...) without\nhaving to write one for each string type (assuming that the impl only\nneeds a slice).", "tree": {"sha": "20b77711bc0728cea9b468083725e795e801617d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20b77711bc0728cea9b468083725e795e801617d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/073e82fff27497ea9b7b73173ddfc349463570b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/073e82fff27497ea9b7b73173ddfc349463570b7", "html_url": "https://github.com/rust-lang/rust/commit/073e82fff27497ea9b7b73173ddfc349463570b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/073e82fff27497ea9b7b73173ddfc349463570b7/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a1e13c7a00cd5cc90385d1fc577a992a155bd34", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1e13c7a00cd5cc90385d1fc577a992a155bd34", "html_url": "https://github.com/rust-lang/rust/commit/3a1e13c7a00cd5cc90385d1fc577a992a155bd34"}], "stats": {"total": 117, "additions": 32, "deletions": 85}, "files": [{"sha": "ef3d77ee5e7c7a78af01d13c9c2c491e77066a9b", "filename": "src/libstd/str.rs", "status": "modified", "additions": 32, "deletions": 85, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/073e82fff27497ea9b7b73173ddfc349463570b7/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073e82fff27497ea9b7b73173ddfc349463570b7/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=073e82fff27497ea9b7b73173ddfc349463570b7", "patch": "@@ -26,7 +26,7 @@ use clone::Clone;\n use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n use iter::Times;\n-use iterator::{Iterator, IteratorUtil, FilterIterator};\n+use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator};\n use libc;\n use option::{None, Option, Some};\n use old_iter::{BaseIter, EqIter};\n@@ -160,96 +160,22 @@ pub trait StrVector {\n     pub fn connect(&self, sep: &str) -> ~str;\n }\n \n-impl<'self> StrVector for &'self [~str] {\n+impl<'self, S: Str> StrVector for &'self [S] {\n     /// Concatenate a vector of strings.\n     pub fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n-        let mut len = 0;\n-        for self.each |ss| {\n-            len += ss.len();\n-        }\n-        let mut s = ~\"\";\n+        let len = self.iter().transform(|s| s.as_slice().len()).sum();\n \n-        s.reserve(len);\n-\n-        unsafe {\n-            do as_buf(s) |buf, _| {\n-                let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                for self.each |ss| {\n-                    do as_buf(*ss) |ssbuf, sslen| {\n-                        let sslen = sslen - 1;\n-                        ptr::copy_memory(buf, ssbuf, sslen);\n-                        buf = buf.offset(sslen);\n-                    }\n-                }\n-            }\n-            raw::set_len(&mut s, len);\n-        }\n-        s\n-    }\n-\n-    /// Concatenate a vector of strings, placing a given separator between each.\n-    pub fn connect(&self, sep: &str) -> ~str {\n-        if self.is_empty() { return ~\"\"; }\n-\n-        // concat is faster\n-        if sep.is_empty() { return self.concat(); }\n-\n-        // this is wrong without the guarantee that `self` is non-empty\n-        let mut len = sep.len() * (self.len() - 1);\n-        for self.each |ss| {\n-            len += ss.len();\n-        }\n-        let mut s = ~\"\";\n-        let mut first = true;\n-\n-        s.reserve(len);\n-\n-        unsafe {\n-            do as_buf(s) |buf, _| {\n-                do as_buf(sep) |sepbuf, seplen| {\n-                    let seplen = seplen - 1;\n-                    let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                    for self.each |ss| {\n-                        do as_buf(*ss) |ssbuf, sslen| {\n-                            let sslen = sslen - 1;\n-                            if first {\n-                                first = false;\n-                            } else {\n-                                ptr::copy_memory(buf, sepbuf, seplen);\n-                                buf = buf.offset(seplen);\n-                            }\n-                            ptr::copy_memory(buf, ssbuf, sslen);\n-                            buf = buf.offset(sslen);\n-                        }\n-                    }\n-                }\n-            }\n-            raw::set_len(&mut s, len);\n-        }\n-        s\n-    }\n-}\n-\n-impl<'self> StrVector for &'self [&'self str] {\n-    /// Concatenate a vector of strings.\n-    pub fn concat(&self) -> ~str {\n-        if self.is_empty() { return ~\"\"; }\n-\n-        let mut len = 0;\n-        for self.each |ss| {\n-            len += ss.len();\n-        }\n         let mut s = ~\"\";\n \n         s.reserve(len);\n \n         unsafe {\n             do as_buf(s) |buf, _| {\n                 let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                for self.each |ss| {\n-                    do as_buf(*ss) |ssbuf, sslen| {\n+                for self.iter().advance |ss| {\n+                    do as_buf(ss.as_slice()) |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n                         ptr::copy_memory(buf, ssbuf, sslen);\n                         buf = buf.offset(sslen);\n@@ -269,10 +195,8 @@ impl<'self> StrVector for &'self [&'self str] {\n         if sep.is_empty() { return self.concat(); }\n \n         // this is wrong without the guarantee that `self` is non-empty\n-        let mut len = sep.len() * (self.len() - 1);\n-        for self.each |ss| {\n-            len += ss.len();\n-        }\n+        let len = sep.len() * (self.len() - 1)\n+            + self.iter().transform(|s| s.as_slice().len()).sum();\n         let mut s = ~\"\";\n         let mut first = true;\n \n@@ -283,8 +207,8 @@ impl<'self> StrVector for &'self [&'self str] {\n                 do as_buf(sep) |sepbuf, seplen| {\n                     let seplen = seplen - 1;\n                     let mut buf = ::cast::transmute_mut_unsafe(buf);\n-                    for self.each |ss| {\n-                        do as_buf(*ss) |ssbuf, sslen| {\n+                    for self.iter().advance |ss| {\n+                        do as_buf(ss.as_slice()) |ssbuf, sslen| {\n                             let sslen = sslen - 1;\n                             if first {\n                                 first = false;\n@@ -1267,6 +1191,29 @@ pub mod traits {\n #[cfg(test)]\n pub mod traits {}\n \n+/// Any string that can be represented as a slice\n+pub trait Str {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a str;\n+}\n+\n+impl<'self> Str for &'self str {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a str { *self }\n+}\n+impl<'self> Str for ~str {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        let s: &'a str = *self; s\n+    }\n+}\n+impl<'self> Str for @str {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        let s: &'a str = *self; s\n+    }\n+}\n+\n #[allow(missing_doc)]\n pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;"}]}