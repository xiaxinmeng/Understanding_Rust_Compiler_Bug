{"sha": "c2f9278b402e91c40902ca77473264ae801e8f0e", "node_id": "C_kwDOAAsO6NoAKGMyZjkyNzhiNDAyZTkxYzQwOTAyY2E3NzQ3MzI2NGFlODAxZThmMGU", "commit": {"author": {"name": "Carl Scherer", "email": "carl.scherer@49nord.de", "date": "2022-03-11T14:52:58Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-03-23T16:50:42Z"}, "message": "remove optimizations from const_prop_lint", "tree": {"sha": "f44ba6ff3cbc2ce5b53909ca98bda01789f674bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f44ba6ff3cbc2ce5b53909ca98bda01789f674bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2f9278b402e91c40902ca77473264ae801e8f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f9278b402e91c40902ca77473264ae801e8f0e", "html_url": "https://github.com/rust-lang/rust/commit/c2f9278b402e91c40902ca77473264ae801e8f0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2f9278b402e91c40902ca77473264ae801e8f0e/comments", "author": {"login": "Lireer", "id": 23488661, "node_id": "MDQ6VXNlcjIzNDg4NjYx", "avatar_url": "https://avatars.githubusercontent.com/u/23488661?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lireer", "html_url": "https://github.com/Lireer", "followers_url": "https://api.github.com/users/Lireer/followers", "following_url": "https://api.github.com/users/Lireer/following{/other_user}", "gists_url": "https://api.github.com/users/Lireer/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lireer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lireer/subscriptions", "organizations_url": "https://api.github.com/users/Lireer/orgs", "repos_url": "https://api.github.com/users/Lireer/repos", "events_url": "https://api.github.com/users/Lireer/events{/privacy}", "received_events_url": "https://api.github.com/users/Lireer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e4ff266187e2049a5810f0580bd37dcafc2334d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e4ff266187e2049a5810f0580bd37dcafc2334d", "html_url": "https://github.com/rust-lang/rust/commit/5e4ff266187e2049a5810f0580bd37dcafc2334d"}], "stats": {"total": 302, "additions": 21, "deletions": 281}, "files": [{"sha": "969d7178b86acada04af7df8765c2f8ffaa5e3b9", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 20, "deletions": 280, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/c2f9278b402e91c40902ca77473264ae801e8f0e/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f9278b402e91c40902ca77473264ae801e8f0e/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=c2f9278b402e91c40902ca77473264ae801e8f0e", "patch": "@@ -9,9 +9,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::visit::{\n-    MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n-};\n+use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{\n     AssertKind, BasicBlock, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind,\n     Location, Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n@@ -28,12 +26,12 @@ use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n \n-use crate::MirPass;\n+use crate::MirLint;\n use rustc_const_eval::const_eval::ConstEvalErr;\n use rustc_const_eval::interpret::{\n-    self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n-    ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, MemoryKind, OpTy,\n-    Operand as InterpOperand, PlaceTy, Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n+    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n+    LocalState, LocalValue, MemPlace, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Scalar,\n+    ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -61,15 +59,8 @@ macro_rules! throw_machine_stop_str {\n \n pub struct ConstProp;\n \n-impl<'tcx> MirPass<'tcx> for ConstProp {\n-    fn is_enabled(&self, _sess: &rustc_session::Session) -> bool {\n-        // FIXME(#70073): Unlike the other passes in \"optimizations\", this one emits errors, so it\n-        // runs even when MIR optimizations are disabled. We should separate the lint out from the\n-        // transform and move the lint as early in the pipeline as possible.\n-        true\n-    }\n-\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+impl<'tcx> MirLint<'tcx> for ConstProp {\n+    fn run_lint(&self, tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if body.source.promoted.is_some() {\n             return;\n@@ -630,32 +621,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n-    fn propagate_operand(&mut self, operand: &mut Operand<'tcx>) {\n-        match *operand {\n-            Operand::Copy(l) | Operand::Move(l) => {\n-                if let Some(value) = self.get_const(l) && self.should_const_prop(&value) {\n-                    // FIXME(felix91gr): this code only handles `Scalar` cases.\n-                    // For now, we're not handling `ScalarPair` cases because\n-                    // doing so here would require a lot of code duplication.\n-                    // We should hopefully generalize `Operand` handling into a fn,\n-                    // and use it to do const-prop here and everywhere else\n-                    // where it makes sense.\n-                    if let interpret::Operand::Immediate(interpret::Immediate::Scalar(\n-                        ScalarMaybeUninit::Scalar(scalar),\n-                    )) = *value\n-                    {\n-                        *operand = self.operand_from_scalar(\n-                            scalar,\n-                            value.layout.ty,\n-                            self.source_info.unwrap().span,\n-                        );\n-                    }\n-                }\n-            }\n-            Operand::Constant(_) => (),\n-        }\n-    }\n-\n     fn const_prop(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n@@ -728,191 +693,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        if self.tcx.sess.mir_opt_level() >= 4 {\n-            self.eval_rvalue_with_identities(rvalue, place)\n-        } else {\n-            self.use_ecx(|this| this.ecx.eval_rvalue_into_place(rvalue, place))\n-        }\n-    }\n-\n-    // Attempt to use albegraic identities to eliminate constant expressions\n-    fn eval_rvalue_with_identities(\n-        &mut self,\n-        rvalue: &Rvalue<'tcx>,\n-        place: Place<'tcx>,\n-    ) -> Option<()> {\n-        self.use_ecx(|this| match rvalue {\n-            Rvalue::BinaryOp(op, box (left, right))\n-            | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                let l = this.ecx.eval_operand(left, None);\n-                let r = this.ecx.eval_operand(right, None);\n-\n-                let const_arg = match (l, r) {\n-                    (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n-                    (Err(e), Err(_)) => return Err(e),\n-                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place),\n-                };\n-\n-                let arg_value = const_arg.to_scalar()?.to_bits(const_arg.layout.size)?;\n-                let dest = this.ecx.eval_place(place)?;\n-\n-                match op {\n-                    BinOp::BitAnd if arg_value == 0 => this.ecx.write_immediate(*const_arg, &dest),\n-                    BinOp::BitOr\n-                        if arg_value == const_arg.layout.size.truncate(u128::MAX)\n-                            || (const_arg.layout.ty.is_bool() && arg_value == 1) =>\n-                    {\n-                        this.ecx.write_immediate(*const_arg, &dest)\n-                    }\n-                    BinOp::Mul if const_arg.layout.ty.is_integral() && arg_value == 0 => {\n-                        if let Rvalue::CheckedBinaryOp(_, _) = rvalue {\n-                            let val = Immediate::ScalarPair(\n-                                const_arg.to_scalar()?.into(),\n-                                Scalar::from_bool(false).into(),\n-                            );\n-                            this.ecx.write_immediate(val, &dest)\n-                        } else {\n-                            this.ecx.write_immediate(*const_arg, &dest)\n-                        }\n-                    }\n-                    _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n-                }\n-            }\n-            _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n-        })\n-    }\n-\n-    /// Creates a new `Operand::Constant` from a `Scalar` value\n-    fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>, span: Span) -> Operand<'tcx> {\n-        Operand::Constant(Box::new(Constant {\n-            span,\n-            user_ty: None,\n-            literal: ty::Const::from_scalar(self.tcx, scalar, ty).into(),\n-        }))\n-    }\n-\n-    fn replace_with_const(\n-        &mut self,\n-        rval: &mut Rvalue<'tcx>,\n-        value: &OpTy<'tcx>,\n-        source_info: SourceInfo,\n-    ) {\n-        if let Rvalue::Use(Operand::Constant(c)) = rval {\n-            match c.literal {\n-                ConstantKind::Ty(c) if matches!(c.val(), ConstKind::Unevaluated(..)) => {}\n-                _ => {\n-                    trace!(\"skipping replace of Rvalue::Use({:?} because it is already a const\", c);\n-                    return;\n-                }\n-            }\n-        }\n-\n-        trace!(\"attempting to replace {:?} with {:?}\", rval, value);\n-        if let Err(e) = self.ecx.const_validate_operand(\n-            value,\n-            vec![],\n-            // FIXME: is ref tracking too expensive?\n-            // FIXME: what is the point of ref tracking if we do not even check the tracked refs?\n-            &mut interpret::RefTracking::empty(),\n-            CtfeValidationMode::Regular,\n-        ) {\n-            trace!(\"validation error, attempt failed: {:?}\", e);\n-            return;\n-        }\n-\n-        // FIXME> figure out what to do when try_read_immediate fails\n-        let imm = self.use_ecx(|this| this.ecx.try_read_immediate(value));\n-\n-        if let Some(Ok(imm)) = imm {\n-            match *imm {\n-                interpret::Immediate::Scalar(ScalarMaybeUninit::Scalar(scalar)) => {\n-                    *rval = Rvalue::Use(self.operand_from_scalar(\n-                        scalar,\n-                        value.layout.ty,\n-                        source_info.span,\n-                    ));\n-                }\n-                Immediate::ScalarPair(\n-                    ScalarMaybeUninit::Scalar(_),\n-                    ScalarMaybeUninit::Scalar(_),\n-                ) => {\n-                    // Found a value represented as a pair. For now only do const-prop if the type\n-                    // of `rvalue` is also a tuple with two scalars.\n-                    // FIXME: enable the general case stated above ^.\n-                    let ty = value.layout.ty;\n-                    // Only do it for tuples\n-                    if let ty::Tuple(types) = ty.kind() {\n-                        // Only do it if tuple is also a pair with two scalars\n-                        if let [ty1, ty2] = types[..] {\n-                            let alloc = self.use_ecx(|this| {\n-                                let ty_is_scalar = |ty| {\n-                                    this.ecx.layout_of(ty).ok().map(|layout| layout.abi.is_scalar())\n-                                        == Some(true)\n-                                };\n-                                if ty_is_scalar(ty1) && ty_is_scalar(ty2) {\n-                                    let alloc = this\n-                                        .ecx\n-                                        .intern_with_temp_alloc(value.layout, |ecx, dest| {\n-                                            ecx.write_immediate(*imm, dest)\n-                                        })\n-                                        .unwrap();\n-                                    Ok(Some(alloc))\n-                                } else {\n-                                    Ok(None)\n-                                }\n-                            });\n-\n-                            if let Some(Some(alloc)) = alloc {\n-                                // Assign entire constant in a single statement.\n-                                // We can't use aggregates, as we run after the aggregate-lowering `MirPhase`.\n-                                *rval = Rvalue::Use(Operand::Constant(Box::new(Constant {\n-                                    span: source_info.span,\n-                                    user_ty: None,\n-                                    literal: self\n-                                        .ecx\n-                                        .tcx\n-                                        .mk_const(ty::ConstS {\n-                                            ty,\n-                                            val: ty::ConstKind::Value(ConstValue::ByRef {\n-                                                alloc,\n-                                                offset: Size::ZERO,\n-                                            }),\n-                                        })\n-                                        .into(),\n-                                })));\n-                            }\n-                        }\n-                    }\n-                }\n-                // Scalars or scalar pairs that contain undef values are assumed to not have\n-                // successfully evaluated and are thus not propagated.\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    /// Returns `true` if and only if this `op` should be const-propagated into.\n-    fn should_const_prop(&mut self, op: &OpTy<'tcx>) -> bool {\n-        let mir_opt_level = self.tcx.sess.mir_opt_level();\n-\n-        if mir_opt_level == 0 {\n-            return false;\n-        }\n-\n-        if !self.tcx.consider_optimizing(|| format!(\"ConstantPropagation - OpTy: {:?}\", op)) {\n-            return false;\n-        }\n-\n-        match **op {\n-            interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUninit::Scalar(s))) => {\n-                s.try_to_int().is_ok()\n-            }\n-            interpret::Operand::Immediate(Immediate::ScalarPair(\n-                ScalarMaybeUninit::Scalar(l),\n-                ScalarMaybeUninit::Scalar(r),\n-            )) => l.try_to_int().is_ok() && r.try_to_int().is_ok(),\n-            _ => false,\n-        }\n+        self.use_ecx(|this| this.ecx.eval_rvalue_into_place(rvalue, place))\n     }\n }\n \n@@ -1047,52 +828,30 @@ impl Visitor<'_> for CanConstProp {\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn visit_body(&mut self, body: &mut Body<'tcx>) {\n-        for (bb, data) in body.basic_blocks_mut().iter_enumerated_mut() {\n+impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n+    fn visit_body(&mut self, body: &Body<'tcx>) {\n+        for (bb, data) in body.basic_blocks().iter_enumerated() {\n             self.visit_basic_block_data(bb, data);\n         }\n     }\n \n-    fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         self.super_operand(operand, location);\n-\n-        // Only const prop copies and moves on `mir_opt_level=3` as doing so\n-        // currently slightly increases compile time in some cases.\n-        if self.tcx.sess.mir_opt_level() >= 3 {\n-            self.propagate_operand(operand)\n-        }\n     }\n \n-    fn visit_constant(&mut self, constant: &mut Constant<'tcx>, location: Location) {\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n         self.eval_constant(constant, self.source_info.unwrap());\n     }\n \n-    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n-        if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n+        if let StatementKind::Assign(box (place, ref rval)) = statement.kind {\n             let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n             if let Some(()) = self.const_prop(rval, source_info, place) {\n-                // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                // type whose creation requires no write. E.g. a generator whose initial state\n-                // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n-                    trace!(\"replacing {:?} with {:?}\", rval, value);\n-                    self.replace_with_const(rval, value, source_info);\n-                    if can_const_prop == ConstPropMode::FullConstProp\n-                        || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                    {\n-                        trace!(\"propagated into {:?}\", place);\n-                    }\n-                }\n                 match can_const_prop {\n                     ConstPropMode::OnlyInsideOwnBlock => {\n                         trace!(\n@@ -1159,12 +918,12 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.super_statement(statement, location);\n     }\n \n-    fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         let source_info = terminator.source_info;\n         self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n-        match &mut terminator.kind {\n-            TerminatorKind::Assert { expected, ref msg, ref mut cond, .. } => {\n+        match &terminator.kind {\n+            TerminatorKind::Assert { expected, ref msg, ref cond, .. } => {\n                 if let Some(ref value) = self.eval_operand(&cond, source_info) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = ScalarMaybeUninit::from(Scalar::from_bool(*expected));\n@@ -1231,25 +990,9 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                                 msg,\n                             );\n                         }\n-                    } else {\n-                        if self.should_const_prop(value) {\n-                            if let ScalarMaybeUninit::Scalar(scalar) = value_const {\n-                                *cond = self.operand_from_scalar(\n-                                    scalar,\n-                                    self.tcx.types.bool,\n-                                    source_info.span,\n-                                );\n-                            }\n-                        }\n                     }\n                 }\n             }\n-            TerminatorKind::SwitchInt { ref mut discr, .. } => {\n-                // FIXME: This is currently redundant with `visit_operand`, but sadly\n-                // always visiting operands currently causes a perf regression in LLVM codegen, so\n-                // `visit_operand` currently only runs for propagates places for `mir_opt_level=4`.\n-                self.propagate_operand(discr)\n-            }\n             // None of these have Operands to const-propagate.\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n@@ -1262,12 +1005,9 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             | TerminatorKind::GeneratorDrop\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Call { .. }\n             | TerminatorKind::InlineAsm { .. } => {}\n-            // Every argument in our function calls have already been propagated in `visit_operand`.\n-            //\n-            // NOTE: because LLVM codegen gives slight performance regressions with it, so this is\n-            // gated on `mir_opt_level=3`.\n-            TerminatorKind::Call { .. } => {}\n         }\n \n         // We remove all Locals which are restricted in propagation to their containing blocks and"}, {"sha": "45b8febf9f63ccba263072d65932bd2d88fd97e3", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f9278b402e91c40902ca77473264ae801e8f0e/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f9278b402e91c40902ca77473264ae801e8f0e/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=c2f9278b402e91c40902ca77473264ae801e8f0e", "patch": "@@ -431,7 +431,7 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n         // `Deaggregator` is conceptually part of MIR building, some backends rely on it happening\n         // and it can help optimizations.\n         &deaggregator::Deaggregator,\n-        &const_prop_lint::ConstProp,\n+        &Lint(const_prop_lint::ConstProp),\n     ];\n \n     pm::run_passes(tcx, body, post_borrowck_cleanup);"}]}