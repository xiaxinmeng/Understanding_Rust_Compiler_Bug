{"sha": "f035b3d2463a0b1ddd4208b086094a6822d1388b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMzViM2QyNDYzYTBiMWRkZDQyMDhiMDg2MDk0YTY4MjJkMTM4OGI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-09-18T11:34:01Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-09-29T10:49:21Z"}, "message": "Remove all non-CTFE stuff from the miri repository", "tree": {"sha": "a047c5810004593964563ce0e5768b58bd08d7cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a047c5810004593964563ce0e5768b58bd08d7cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f035b3d2463a0b1ddd4208b086094a6822d1388b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlnOJTEACgkQpp+NIls6\n19kDTBAAr5Uv7Pr42NSfxCewxdYMvd4me78YSieiWSUbwGucuNTdeClZGYYf2SIK\ngWkJYT/K5QNdseUBmZIn5wEePBUSIFWMur7KJbf2ndPofkt7SWNUAKeR+07SzmOm\nf8BlfEX2cspxmXm7AxfFeipSQAD8FPY/ZtbXHlpnt2cIVgbqVP/94RBwuQQ/wcWh\n4hHLx7pwaneXfuY6ECDFdvBNg9s18vCYilxSfRrTbhkPVse4VvEjH4gDZYzzBQaE\nvn7e/1AWkS1kR4y/e9FRTALfZFE8gy0W+S88/H0Z4RLvRUAw4gwfjyF0Psg4t9jU\nfxconEKHHQVVCfYXIecMtqBLr82kvas+8x4s14Gj/vLCoazriNc+sJHFJdSh5M4N\nxO6yfUha7YDk9+Lgrrn0QrKDQKN5pEnNySF/LH2oaakWd4CYjbl0WLKDfOhxdeZ4\nBcySsH+S0VdR0F0VvhDpZAaT2BDc3i4qjDaFzmybckBiYg31NbPRzvsKoavdr4NR\nNAoXS6+yn0xZHhgyVhkek0jJ4ozoPfO7FZM5+EFgi7NqY5h+vUdvHbOjWqqJ96l4\n49453dVEgtyDw0ARtEsytIwk0Bv5r0gq4sp1/OTyvUyT1TnmhGD6YNSbroJ8WINb\nCEKKe4kYOgE7RF8NqubeP7S2JCSP7IhFxruNDS3TN4136TyQRsI=\n=tlZj\n-----END PGP SIGNATURE-----", "payload": "tree a047c5810004593964563ce0e5768b58bd08d7cf\nparent ed674f7cb3362d8f54f7baf29725ba66c88d037a\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1505734441 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1506682161 +0200\n\nRemove all non-CTFE stuff from the miri repository\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f035b3d2463a0b1ddd4208b086094a6822d1388b", "html_url": "https://github.com/rust-lang/rust/commit/f035b3d2463a0b1ddd4208b086094a6822d1388b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f035b3d2463a0b1ddd4208b086094a6822d1388b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed674f7cb3362d8f54f7baf29725ba66c88d037a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed674f7cb3362d8f54f7baf29725ba66c88d037a", "html_url": "https://github.com/rust-lang/rust/commit/ed674f7cb3362d8f54f7baf29725ba66c88d037a"}], "stats": {"total": 11610, "additions": 0, "deletions": 11610}, "files": [{"sha": "d32d9eb99afd2b7b242a2c6c62ed1b571c5cb10f", "filename": ".gitignore", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-target\n-/doc\n-tex/*/out\n-*.dot\n-*.mir\n-*.rs.bk"}, {"sha": "86577702e96d933dd50e8458b198030dcbe7fc82", "filename": ".travis.yml", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,45 +0,0 @@\n-language: rust\n-rust:\n-- nightly\n-before_script:\n-- export PATH=$HOME/.local/bin:$PATH\n-- rustup target add i686-unknown-linux-gnu\n-- rustup target add i686-pc-windows-gnu\n-- rustup target add i686-pc-windows-msvc\n-- rustup component add rust-src\n-- cargo install --git https://github.com/japaric/xargo.git\n-- export RUST_SYSROOT=$HOME/rust\n-script:\n-- set -e\n-- |\n-  # get ourselves a MIR-ful libstd\n-  xargo/build.sh\n-- |\n-  # Test plain miri\n-  cargo build --locked --release --all-features &&\n-  cargo test --locked --release --all-features --all &&\n-  cargo install --locked --all-features\n-- |\n-  # Test cargo miri\n-  cd cargo-miri-test &&\n-  cargo miri &&\n-  cargo miri test &&\n-  cd ..\n-- |\n-  # and run all tests with full mir\n-  MIRI_SYSROOT=~/.xargo/HOST cargo test --locked --release\n-- |\n-  # test that the rustc_tests binary compiles\n-  cd rustc_tests &&\n-  cargo build --locked --release &&\n-  cd ..\n-notifications:\n-  email:\n-    on_success: never\n-branches:\n-  only:\n-  - master\n-env:\n-  global:\n-  - RUST_TEST_NOCAPTURE=1\n-  - TRAVIS_CARGO_NIGHTLY_FEATURE=\"\""}, {"sha": "c84d79a089c3a981153c74aa29ccbe07a789aea2", "filename": "Cargo.lock", "status": "removed", "additions": 0, "deletions": 413, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,413 +0,0 @@\n-[root]\n-name = \"rustc_miri\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"aho-corasick\"\n-version = \"0.6.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"backtrace\"\n-version = \"0.3.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"backtrace-sys\"\n-version = \"0.1.12\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"bitflags\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"byteorder\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"cargo_metadata\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"compiletest_rs\"\n-version = \"0.3.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"conv\"\n-version = \"0.3.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"custom_derive 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"custom_derive\"\n-version = \"0.1.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"dbghelp-sys\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"diff\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"dtoa\"\n-version = \"0.4.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"env_logger\"\n-version = \"0.4.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"filetime\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"gcc\"\n-version = \"0.3.53\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"getopts\"\n-version = \"0.2.15\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"itoa\"\n-version = \"0.3.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"kernel32-sys\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"lazy_static\"\n-version = \"0.2.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"libc\"\n-version = \"0.2.30\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"log\"\n-version = \"0.3.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"log_settings\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"magenta\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"conv 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"magenta-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"magenta-sys\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"memchr\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"miri\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiletest_rs 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_miri 0.1.0\",\n-]\n-\n-[[package]]\n-name = \"num-traits\"\n-version = \"0.1.40\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"quote\"\n-version = \"0.3.15\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"rand\"\n-version = \"0.3.16\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"regex\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"regex-syntax\"\n-version = \"0.4.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"rustc-demangle\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"rustc-serialize\"\n-version = \"0.3.24\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"serde\"\n-version = \"1.0.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"serde_derive\"\n-version = \"1.0.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"serde_derive_internals\"\n-version = \"0.15.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"serde_json\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itoa 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"syn\"\n-version = \"0.11.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"synom\"\n-version = \"0.11.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"tempdir\"\n-version = \"0.3.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"rand 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"thread_local\"\n-version = \"0.3.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"unicode-xid\"\n-version = \"0.0.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"unreachable\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"utf8-ranges\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"void\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi\"\n-version = \"0.2.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[metadata]\n-\"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n-\"checksum backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99f2ce94e22b8e664d95c57fff45b98a966c2252b60691d0b7aeeccd88d70983\"\n-\"checksum backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afccc5772ba333abccdf60d55200fa3406f8c59dcf54d5f7998c9107d3799c7c\"\n-\"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n-\"checksum byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff81738b726f5d099632ceaffe7fb65b90212e8dce59d518729e7e8634032d3d\"\n-\"checksum cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be1057b8462184f634c3a208ee35b0f935cfd94b694b26deadccd98732088d7b\"\n-\"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n-\"checksum compiletest_rs 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86f4663adfd113e17109c35c2067194eca782a5baf9c90f4696ca13d04631adb\"\n-\"checksum conv 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"78ff10625fd0ac447827aa30ea8b861fead473bb60aeb73af6c1c58caf0d1299\"\n-\"checksum custom_derive 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef8ae57c4978a2acd8b869ce6b9ca1dfe817bff704c220209fdef2c0b75a01b9\"\n-\"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n-\"checksum diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a515461b6c8c08419850ced27bc29e86166dcdcde8fbe76f8b1f0589bb49472\"\n-\"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n-\"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n-\"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8310f7e9c890398b0e80e301c4f474e9918d2b27fca8f48486ca775fa9ffc5a\"\n-\"checksum getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"65922871abd2f101a2eb0eaebadc66668e54a87ad9c3dd82520b5f86ede5eff9\"\n-\"checksum itoa 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f74cf6ca1bdbc28496a2b9798ab7fccc2ca5a42cace95bb2b219577216a5fb90\"\n-\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n-\"checksum libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2370ca07ec338939e356443dac2296f581453c35fe1e3a3ed06023c49435f915\"\n-\"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n-\"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n-\"checksum magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4bf0336886480e671965f794bc9b6fce88503563013d1bfb7a502c81fe3ac527\"\n-\"checksum magenta-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40d014c7011ac470ae28e2f76a02bfea4a8480f73e701353b49ad7a8d75f4699\"\n-\"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n-\"checksum num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99843c856d68d8b4313b03a17e33c4bb42ae8f6610ea81b28abe076ac721b9b0\"\n-\"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n-\"checksum rand 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb250fd207a4729c976794d03db689c9be1d634ab5a1c9da9492a13d8fecbcdf\"\n-\"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n-\"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n-\"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n-\"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7726f29ddf9731b17ff113c461e362c381d9d69433f79de4f3dd572488823e9\"\n-\"checksum serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf823e706be268e73e7747b147aa31c8f633ab4ba31f115efb57e5047c3a76dd\"\n-\"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n-\"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n-\"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n-\"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n-\"checksum tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"87974a6f5c1dfb344d733055601650059a3363de2a6104819293baff662132d6\"\n-\"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\"\n-\"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n-\"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n-\"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n-\"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n-\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n-\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "b3db572871dacafabde4ffa24a3e95acf879f24b", "filename": "Cargo.toml", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,39 +0,0 @@\n-[package]\n-authors = [\"Scott Olson <scott@solson.me>\"]\n-description = \"An experimental interpreter for Rust MIR.\"\n-license = \"MIT/Apache-2.0\"\n-name = \"miri\"\n-repository = \"https://github.com/solson/miri\"\n-version = \"0.1.0\"\n-build = \"build.rs\"\n-\n-[[bin]]\n-doc = false\n-name = \"miri\"\n-path = \"miri/bin/miri.rs\"\n-\n-[[bin]]\n-doc = false\n-name = \"cargo-miri\"\n-path = \"miri/bin/cargo-miri.rs\"\n-required-features = [\"cargo_miri\"]\n-\n-[lib]\n-path = \"miri/lib.rs\"\n-\n-[dependencies]\n-byteorder = { version = \"1.1\", features = [\"i128\"]}\n-env_logger = \"0.4.3\"\n-log = \"0.3.6\"\n-log_settings = \"0.1.1\"\n-cargo_metadata = { version = \"0.2\", optional = true }\n-rustc_miri = { path = \"src/librustc_mir\" }\n-\n-[features]\n-cargo_miri = [\"cargo_metadata\"]\n-\n-[dev-dependencies]\n-compiletest_rs = { version = \"0.3\", features = [\"tmp\"] }\n-\n-[workspace]\n-exclude = [\"xargo\", \"cargo-miri-test\", \"rustc_tests\"]"}, {"sha": "a32595fa70bc14c1b8d8cd0358d3e67ca1572405", "filename": "LICENSE-APACHE", "status": "removed", "additions": 0, "deletions": 201, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/LICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/LICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSE-APACHE?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,201 +0,0 @@\n-                              Apache License\n-                        Version 2.0, January 2004\n-                     http://www.apache.org/licenses/\n-\n-TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n-\n-1. Definitions.\n-\n-   \"License\" shall mean the terms and conditions for use, reproduction,\n-   and distribution as defined by Sections 1 through 9 of this document.\n-\n-   \"Licensor\" shall mean the copyright owner or entity authorized by\n-   the copyright owner that is granting the License.\n-\n-   \"Legal Entity\" shall mean the union of the acting entity and all\n-   other entities that control, are controlled by, or are under common\n-   control with that entity. For the purposes of this definition,\n-   \"control\" means (i) the power, direct or indirect, to cause the\n-   direction or management of such entity, whether by contract or\n-   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n-   outstanding shares, or (iii) beneficial ownership of such entity.\n-\n-   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n-   exercising permissions granted by this License.\n-\n-   \"Source\" form shall mean the preferred form for making modifications,\n-   including but not limited to software source code, documentation\n-   source, and configuration files.\n-\n-   \"Object\" form shall mean any form resulting from mechanical\n-   transformation or translation of a Source form, including but\n-   not limited to compiled object code, generated documentation,\n-   and conversions to other media types.\n-\n-   \"Work\" shall mean the work of authorship, whether in Source or\n-   Object form, made available under the License, as indicated by a\n-   copyright notice that is included in or attached to the work\n-   (an example is provided in the Appendix below).\n-\n-   \"Derivative Works\" shall mean any work, whether in Source or Object\n-   form, that is based on (or derived from) the Work and for which the\n-   editorial revisions, annotations, elaborations, or other modifications\n-   represent, as a whole, an original work of authorship. For the purposes\n-   of this License, Derivative Works shall not include works that remain\n-   separable from, or merely link (or bind by name) to the interfaces of,\n-   the Work and Derivative Works thereof.\n-\n-   \"Contribution\" shall mean any work of authorship, including\n-   the original version of the Work and any modifications or additions\n-   to that Work or Derivative Works thereof, that is intentionally\n-   submitted to Licensor for inclusion in the Work by the copyright owner\n-   or by an individual or Legal Entity authorized to submit on behalf of\n-   the copyright owner. For the purposes of this definition, \"submitted\"\n-   means any form of electronic, verbal, or written communication sent\n-   to the Licensor or its representatives, including but not limited to\n-   communication on electronic mailing lists, source code control systems,\n-   and issue tracking systems that are managed by, or on behalf of, the\n-   Licensor for the purpose of discussing and improving the Work, but\n-   excluding communication that is conspicuously marked or otherwise\n-   designated in writing by the copyright owner as \"Not a Contribution.\"\n-\n-   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n-   on behalf of whom a Contribution has been received by Licensor and\n-   subsequently incorporated within the Work.\n-\n-2. Grant of Copyright License. Subject to the terms and conditions of\n-   this License, each Contributor hereby grants to You a perpetual,\n-   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n-   copyright license to reproduce, prepare Derivative Works of,\n-   publicly display, publicly perform, sublicense, and distribute the\n-   Work and such Derivative Works in Source or Object form.\n-\n-3. Grant of Patent License. Subject to the terms and conditions of\n-   this License, each Contributor hereby grants to You a perpetual,\n-   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n-   (except as stated in this section) patent license to make, have made,\n-   use, offer to sell, sell, import, and otherwise transfer the Work,\n-   where such license applies only to those patent claims licensable\n-   by such Contributor that are necessarily infringed by their\n-   Contribution(s) alone or by combination of their Contribution(s)\n-   with the Work to which such Contribution(s) was submitted. If You\n-   institute patent litigation against any entity (including a\n-   cross-claim or counterclaim in a lawsuit) alleging that the Work\n-   or a Contribution incorporated within the Work constitutes direct\n-   or contributory patent infringement, then any patent licenses\n-   granted to You under this License for that Work shall terminate\n-   as of the date such litigation is filed.\n-\n-4. Redistribution. You may reproduce and distribute copies of the\n-   Work or Derivative Works thereof in any medium, with or without\n-   modifications, and in Source or Object form, provided that You\n-   meet the following conditions:\n-\n-   (a) You must give any other recipients of the Work or\n-       Derivative Works a copy of this License; and\n-\n-   (b) You must cause any modified files to carry prominent notices\n-       stating that You changed the files; and\n-\n-   (c) You must retain, in the Source form of any Derivative Works\n-       that You distribute, all copyright, patent, trademark, and\n-       attribution notices from the Source form of the Work,\n-       excluding those notices that do not pertain to any part of\n-       the Derivative Works; and\n-\n-   (d) If the Work includes a \"NOTICE\" text file as part of its\n-       distribution, then any Derivative Works that You distribute must\n-       include a readable copy of the attribution notices contained\n-       within such NOTICE file, excluding those notices that do not\n-       pertain to any part of the Derivative Works, in at least one\n-       of the following places: within a NOTICE text file distributed\n-       as part of the Derivative Works; within the Source form or\n-       documentation, if provided along with the Derivative Works; or,\n-       within a display generated by the Derivative Works, if and\n-       wherever such third-party notices normally appear. The contents\n-       of the NOTICE file are for informational purposes only and\n-       do not modify the License. You may add Your own attribution\n-       notices within Derivative Works that You distribute, alongside\n-       or as an addendum to the NOTICE text from the Work, provided\n-       that such additional attribution notices cannot be construed\n-       as modifying the License.\n-\n-   You may add Your own copyright statement to Your modifications and\n-   may provide additional or different license terms and conditions\n-   for use, reproduction, or distribution of Your modifications, or\n-   for any such Derivative Works as a whole, provided Your use,\n-   reproduction, and distribution of the Work otherwise complies with\n-   the conditions stated in this License.\n-\n-5. Submission of Contributions. Unless You explicitly state otherwise,\n-   any Contribution intentionally submitted for inclusion in the Work\n-   by You to the Licensor shall be under the terms and conditions of\n-   this License, without any additional terms or conditions.\n-   Notwithstanding the above, nothing herein shall supersede or modify\n-   the terms of any separate license agreement you may have executed\n-   with Licensor regarding such Contributions.\n-\n-6. Trademarks. This License does not grant permission to use the trade\n-   names, trademarks, service marks, or product names of the Licensor,\n-   except as required for reasonable and customary use in describing the\n-   origin of the Work and reproducing the content of the NOTICE file.\n-\n-7. Disclaimer of Warranty. Unless required by applicable law or\n-   agreed to in writing, Licensor provides the Work (and each\n-   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n-   implied, including, without limitation, any warranties or conditions\n-   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n-   PARTICULAR PURPOSE. You are solely responsible for determining the\n-   appropriateness of using or redistributing the Work and assume any\n-   risks associated with Your exercise of permissions under this License.\n-\n-8. Limitation of Liability. In no event and under no legal theory,\n-   whether in tort (including negligence), contract, or otherwise,\n-   unless required by applicable law (such as deliberate and grossly\n-   negligent acts) or agreed to in writing, shall any Contributor be\n-   liable to You for damages, including any direct, indirect, special,\n-   incidental, or consequential damages of any character arising as a\n-   result of this License or out of the use or inability to use the\n-   Work (including but not limited to damages for loss of goodwill,\n-   work stoppage, computer failure or malfunction, or any and all\n-   other commercial damages or losses), even if such Contributor\n-   has been advised of the possibility of such damages.\n-\n-9. Accepting Warranty or Additional Liability. While redistributing\n-   the Work or Derivative Works thereof, You may choose to offer,\n-   and charge a fee for, acceptance of support, warranty, indemnity,\n-   or other liability obligations and/or rights consistent with this\n-   License. However, in accepting such obligations, You may act only\n-   on Your own behalf and on Your sole responsibility, not on behalf\n-   of any other Contributor, and only if You agree to indemnify,\n-   defend, and hold each Contributor harmless for any liability\n-   incurred by, or claims asserted against, such Contributor by reason\n-   of your accepting any such warranty or additional liability.\n-\n-END OF TERMS AND CONDITIONS\n-\n-APPENDIX: How to apply the Apache License to your work.\n-\n-   To apply the Apache License to your work, attach the following\n-   boilerplate notice, with the fields enclosed by brackets \"[]\"\n-   replaced with your own identifying information. (Don't include\n-   the brackets!)  The text should be enclosed in the appropriate\n-   comment syntax for the file format. We also recommend that a\n-   file or class name and description of purpose be included on the\n-   same \"printed page\" as the copyright notice for easier\n-   identification within third-party archives.\n-\n-Copyright 2016 The Miri Developers\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License."}, {"sha": "1f9d89a5862b55aacba85cd34aa1e28d4ca17d44", "filename": "LICENSE-MIT", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/LICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/LICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSE-MIT?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,25 +0,0 @@\n-Copyright (c) 2016 The Miri Developers\n-\n-Permission is hereby granted, free of charge, to any\n-person obtaining a copy of this software and associated\n-documentation files (the \"Software\"), to deal in the\n-Software without restriction, including without\n-limitation the rights to use, copy, modify, merge,\n-publish, distribute, sublicense, and/or sell copies of\n-the Software, and to permit persons to whom the Software\n-is furnished to do so, subject to the following\n-conditions:\n-\n-The above copyright notice and this permission notice\n-shall be included in all copies or substantial portions\n-of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n-ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n-TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n-PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n-SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n-IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n-DEALINGS IN THE SOFTWARE."}, {"sha": "22cb5aed79b1aa7dfca5964369a61a891ca2a1ba", "filename": "README.md", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,103 +0,0 @@\n-# Miri [[slides](https://solson.me/miri-slides.pdf)] [[report](https://solson.me/miri-report.pdf)] [![Build Status](https://travis-ci.org/solson/miri.svg?branch=master)](https://travis-ci.org/solson/miri) [![Windows build status](https://ci.appveyor.com/api/projects/status/github/solson/miri?svg=true)](https://ci.appveyor.com/project/solson63299/miri)\n-\n-\n-An experimental interpreter for [Rust][rust]'s [mid-level intermediate\n-representation][mir] (MIR). This project began as part of my work for the\n-undergraduate research course at the [University of Saskatchewan][usask].\n-\n-## Installing Rust\n-\n-I recommend that you install [rustup][rustup] and then use it to install the\n-current Rust nightly version:\n-\n-```sh\n-rustup update nightly\n-```\n-\n-You should also make `nightly` the default version for your Miri directory by\n-running the following command while you're in it. If you don't do this, you can\n-run the later `cargo` commands by using `cargo +nightly` instead.\n-\n-```sh\n-rustup override add nightly\n-```\n-\n-## Building Miri\n-\n-```sh\n-cargo build\n-```\n-\n-If Miri fails to build, it's likely because a change in the latest nightly\n-compiler broke it. You could try an older nightly with `rustup update\n-nightly-<date>` where `<date>` is a few days or weeks ago, e.g. `2016-05-20` for\n-May 20th. Otherwise, you could notify me in an issue or on IRC. Or, if you know\n-how to fix it, you could send a PR. :smile:\n-\n-## Running tests\n-\n-```sh\n-cargo run --bin miri tests/run-pass/vecs.rs # Or whatever test you like.\n-```\n-\n-## Debugging\n-\n-You can get detailed, statement-by-statement traces by setting the `MIRI_LOG`\n-environment variable to `trace`. These traces are indented based on call stack\n-depth. You can get a much less verbose set of information with other logging\n-levels such as `warn`.\n-\n-## Running miri on your own project('s test suite)\n-\n-Install miri as a cargo subcommand with `cargo install --debug`.\n-Then, inside your own project, use `cargo +nightly miri` to run your project, if it is\n-a bin project, or run `cargo +nightly miri test` to run all tests in your project\n-through miri.\n-\n-## Running miri with full libstd\n-\n-Per default libstd does not contain the MIR of non-polymorphic functions.  When\n-miri hits a call to such a function, execution terminates.  To fix this, it is\n-possible to compile libstd with full MIR:\n-\n-```sh\n-rustup component add rust-src\n-cargo install xargo\n-cd xargo/\n-RUSTFLAGS='-Zalways-encode-mir' xargo build\n-```\n-\n-Now you can run miri against the libstd compiled by xargo:\n-\n-```sh\n-MIRI_SYSROOT=~/.xargo/HOST cargo run --bin miri tests/run-pass-fullmir/vecs.rs\n-```\n-\n-Notice that you will have to re-run the last step of the preparations above when\n-your toolchain changes (e.g., when you update the nightly).\n-\n-## Contributing and getting help\n-\n-Check out the issues on this GitHub repository for some ideas. There's lots that\n-needs to be done that I haven't documented in the issues yet, however. For more\n-ideas or help with running or hacking on Miri, you can contact me (`scott`) on\n-Mozilla IRC in any of the Rust IRC channels (`#rust`, `#rust-offtopic`, etc).\n-\n-## License\n-\n-Licensed under either of\n-  * Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or\n-    http://www.apache.org/licenses/LICENSE-2.0)\n-  * MIT license ([LICENSE-MIT](LICENSE-MIT) or\n-    http://opensource.org/licenses/MIT) at your option.\n-\n-### Contribution\n-\n-Unless you explicitly state otherwise, any contribution intentionally submitted\n-for inclusion in the work by you shall be dual licensed as above, without any\n-additional terms or conditions.\n-\n-[rust]: https://www.rust-lang.org/\n-[mir]: https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md\n-[usask]: https://www.usask.ca/\n-[rustup]: https://www.rustup.rs"}, {"sha": "86f9b19af87f616d38ddd163da05257574b4a97e", "filename": "appveyor.yml", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,41 +0,0 @@\n-environment:\n-    global:\n-        PROJECT_NAME: miri\n-    matrix:\n-        - TARGET: i686-pc-windows-msvc\n-          MSYS2_BITS: 32\n-        - TARGET: x86_64-pc-windows-msvc\n-          MSYS2_BITS: 64\n-\n-# branches to build\n-branches:\n-  # whitelist\n-  only:\n-    - master\n-\n-install:\n-    - set PATH=C:\\Program Files\\Git\\mingw64\\bin;%PATH%\n-    - curl -sSf -o rustup-init.exe https://win.rustup.rs/\n-    - rustup-init.exe -y --default-host %TARGET% --default-toolchain nightly\n-    - set PATH=%PATH%;C:\\Users\\appveyor\\.cargo\\bin;C:\\Users\\appveyor\\.rustup\\toolchains\\nightly-%TARGET%\\bin\n-    - if defined MSYS2_BITS set PATH=%PATH%;C:\\msys64\\mingw%MSYS2_BITS%\\bin\n-    - rustc -V\n-    - cargo -V\n-    - rustup component add rust-src\n-    - cargo install --git https://github.com/japaric/xargo.git\n-    - cd xargo\n-    - set RUSTFLAGS=-Zalways-encode-mir -Zmir-emit-validate=1\n-    - xargo build\n-    - set RUSTFLAGS=\n-    - cd ..\n-\n-build: false\n-\n-test_script:\n-    - set RUST_BACKTRACE=1\n-    - cargo build --locked --release\n-    - cargo test --locked --release\n-\n-notifications:\n-    - provider: Email\n-      on_build_success: false"}, {"sha": "90b231a32bfb045b84e3d3537cdf02225f950f23", "filename": "benches/fibonacci.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Ffibonacci.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Ffibonacci.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Ffibonacci.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,26 +0,0 @@\n-#![feature(test, rustc_private)]\n-\n-extern crate test;\n-use test::Bencher;\n-mod helpers;\n-use helpers::*;\n-\n-#[bench]\n-fn fib(bencher: &mut Bencher) {\n-    bencher.iter(|| { fibonacci_helper::main(); })\n-}\n-\n-#[bench]\n-fn fib_miri(bencher: &mut Bencher) {\n-    miri_helper::run(\"fibonacci_helper\", bencher);\n-}\n-\n-#[bench]\n-fn fib_iter(bencher: &mut Bencher) {\n-    bencher.iter(|| { fibonacci_helper_iterative::main(); })\n-}\n-\n-#[bench]\n-fn fib_iter_miri(bencher: &mut Bencher) {\n-    miri_helper::run(\"fibonacci_helper_iterative\", bencher);\n-}"}, {"sha": "586f1ce7da4d4a122003dc7f75c4275e46da0993", "filename": "benches/helpers/fibonacci_helper.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Ffibonacci_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Ffibonacci_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Ffibonacci_helper.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-#[inline(never)]\n-pub fn main() {\n-    assert_eq!(fib(10), 55);\n-}\n-\n-fn fib(n: usize) -> usize {\n-    if n <= 2 { 1 } else { fib(n - 1) + fib(n - 2) }\n-}"}, {"sha": "59283be4820f718e0007d71b216a6ea1a3a1f4e5", "filename": "benches/helpers/fibonacci_helper_iterative.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Ffibonacci_helper_iterative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Ffibonacci_helper_iterative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Ffibonacci_helper_iterative.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-#[inline(never)]\n-pub fn main() {\n-    assert_eq!(fib(10), 55);\n-}\n-\n-fn fib(n: usize) -> usize {\n-    let mut a = 0;\n-    let mut b = 1;\n-    for _ in 0..n {\n-        let c = a;\n-        a = b;\n-        b = c + b;\n-    }\n-    a\n-}"}, {"sha": "6657ba119976583e8acb0a5a72b4a51422d43120", "filename": "benches/helpers/miri_helper.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,75 +0,0 @@\n-extern crate getopts;\n-extern crate miri;\n-extern crate rustc;\n-extern crate rustc_driver;\n-extern crate test;\n-\n-use self::miri::eval_main;\n-use self::rustc::session::Session;\n-use self::rustc_driver::{driver, CompilerCalls, Compilation};\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-use test::Bencher;\n-\n-pub struct MiriCompilerCalls<'a>(Rc<RefCell<&'a mut Bencher>>);\n-\n-fn find_sysroot() -> String {\n-    // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n-    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n-    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n-    match (home, toolchain) {\n-        (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n-        _ => {\n-            option_env!(\"RUST_SYSROOT\")\n-                .expect(\n-                    \"need to specify RUST_SYSROOT env var or use rustup or multirust\",\n-                )\n-                .to_owned()\n-        }\n-    }\n-}\n-\n-pub fn run(filename: &str, bencher: &mut Bencher) {\n-    let args = &[\n-        \"miri\".to_string(),\n-        format!(\"benches/helpers/{}.rs\", filename),\n-        \"--sysroot\".to_string(),\n-        find_sysroot(),\n-    ];\n-    let compiler_calls = &mut MiriCompilerCalls(Rc::new(RefCell::new(bencher)));\n-    rustc_driver::run_compiler(args, compiler_calls, None, None);\n-}\n-\n-impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n-    fn build_controller(\n-        &mut self,\n-        _: &Session,\n-        _: &getopts::Matches,\n-    ) -> driver::CompileController<'a> {\n-        let mut control: driver::CompileController<'a> = driver::CompileController::basic();\n-\n-        let bencher = self.0.clone();\n-\n-        control.after_analysis.stop = Compilation::Stop;\n-        control.after_analysis.callback = Box::new(move |state| {\n-            state.session.abort_if_errors();\n-\n-            let tcx = state.tcx.unwrap();\n-            let (entry_node_id, _) = state.session.entry_fn.borrow().expect(\n-                \"no main or start function found\",\n-            );\n-            let entry_def_id = tcx.map.local_def_id(entry_node_id);\n-\n-            let memory_size = 100 * 1024 * 1024; // 100MB\n-            let step_limit = 1000_000;\n-            let stack_limit = 100;\n-            bencher.borrow_mut().iter(|| {\n-                eval_main(tcx, entry_def_id, memory_size, step_limit, stack_limit);\n-            });\n-\n-            state.session.abort_if_errors();\n-        });\n-\n-        control\n-    }\n-}"}, {"sha": "27504a2cc034d7a308241e368a876be2de77b330", "filename": "benches/helpers/mod.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmod.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-// This module gets included in multiple crates, and they each only use part of it.\n-#![allow(dead_code)]\n-\n-pub mod fibonacci_helper;\n-pub mod fibonacci_helper_iterative;\n-pub mod miri_helper;\n-pub mod smoke_helper;"}, {"sha": "0e8c5980b82bdec0f7072a775997b0837f2d8b14", "filename": "benches/helpers/repeat.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Frepeat.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let data: [u8; 1024] = [42; 1024];\n-    assert_eq!(data.len(), 1024);\n-}"}, {"sha": "6ef6f724efceee8a04d50541dbee22f63c09e45c", "filename": "benches/helpers/repeat_manual.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Frepeat_manual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Frepeat_manual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Frepeat_manual.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let mut data: [u8; 1024] = unsafe { std::mem::uninitialized() };\n-    for i in 0..data.len() {\n-        unsafe { std::ptr::write(&mut data[i], 0); }\n-    }\n-    assert_eq!(data.len(), 1024);\n-}"}, {"sha": "e81db817aeace2cedf47574cf93b9f64c84bb0d3", "filename": "benches/helpers/smoke_helper.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Fsmoke_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fhelpers%2Fsmoke_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fsmoke_helper.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,2 +0,0 @@\n-#[inline(never)]\n-pub fn main() {}"}, {"sha": "f5920e83d9b07b1d2462072c02f67339ecb37375", "filename": "benches/repeat.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Frepeat.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-#![feature(test, rustc_private)]\n-\n-extern crate test;\n-use test::Bencher;\n-mod helpers;\n-use helpers::*;\n-\n-#[bench]\n-fn repeat(bencher: &mut Bencher) {\n-    miri_helper::run(\"repeat\", bencher);\n-}\n-\n-#[bench]\n-fn repeat_manual(bencher: &mut Bencher) {\n-    miri_helper::run(\"repeat_manual\", bencher);\n-}"}, {"sha": "1dbc4fed82f1c252df0a7fe0119e2065e0666be4", "filename": "benches/smoke.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/benches%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fsmoke.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,35 +0,0 @@\n-#![feature(test, rustc_private)]\n-\n-extern crate test;\n-use test::Bencher;\n-mod helpers;\n-use helpers::*;\n-\n-#[bench]\n-fn noop(bencher: &mut Bencher) {\n-    bencher.iter(|| { smoke_helper::main(); })\n-}\n-\n-/*\n-// really slow\n-#[bench]\n-fn noop_miri_full(bencher: &mut Bencher) {\n-    let path = std::env::var(\"RUST_SYSROOT\").expect(\"env variable `RUST_SYSROOT` not set\");\n-    bencher.iter(|| {\n-        let mut process = std::process::Command::new(\"target/release/miri\");\n-        process.arg(\"benches/smoke_helper.rs\")\n-               .arg(\"--sysroot\").arg(&path);\n-        let output = process.output().unwrap();\n-        if !output.status.success() {\n-            println!(\"{}\", String::from_utf8(output.stdout).unwrap());\n-            println!(\"{}\", String::from_utf8(output.stderr).unwrap());\n-            panic!(\"failed to run miri\");\n-        }\n-    })\n-}\n-*/\n-\n-#[bench]\n-fn noop_miri_interpreter(bencher: &mut Bencher) {\n-    miri_helper::run(\"smoke_helper\", bencher);\n-}"}, {"sha": "2f74f7f4f6162ae5e1d875873db78d7c772bd513", "filename": "build.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-use std::env;\n-\n-fn main() {\n-    // Forward the profile to the main compilation\n-    println!(\"cargo:rustc-env=PROFILE={}\", env::var(\"PROFILE\").unwrap());\n-    // Don't rebuild miri even if nothing changed\n-    println!(\"cargo:rerun-if-changed=build.rs\");\n-}"}, {"sha": "8b2387fa64109aeb99cf2efe390e10c62f3a71fa", "filename": "cargo-miri-test/Cargo.lock", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/cargo-miri-test%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/cargo-miri-test%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri-test%2FCargo.lock?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-[root]\n-name = \"cargo-miri-test\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"byteorder 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"byteorder\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[metadata]\n-\"checksum byteorder 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c40977b0ee6b9885c9013cd41d9feffdd22deb3bb4dc3a71d901cc7a77de18c8\""}, {"sha": "5fbe923f23d3ba0f407451a653c13897a27debb8", "filename": "cargo-miri-test/Cargo.toml", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/cargo-miri-test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/cargo-miri-test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri-test%2FCargo.toml?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-[package]\n-name = \"cargo-miri-test\"\n-version = \"0.1.0\"\n-authors = [\"Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\"]\n-\n-[dependencies]\n-byteorder = \"1.0\"\n\\ No newline at end of file"}, {"sha": "07b0e4cee4e5c596e6f6bfb5067cc682cebf3cfe", "filename": "cargo-miri-test/src/main.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/cargo-miri-test%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/cargo-miri-test%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri-test%2Fsrc%2Fmain.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-extern crate byteorder;\n-\n-use byteorder::{BigEndian, ByteOrder};\n-\n-fn main() {\n-    let buf = &[1,2,3,4];\n-    let n = <BigEndian as ByteOrder>::read_u32(buf);\n-    assert_eq!(n, 0x01020304);\n-}"}, {"sha": "fb7fad21c9db8fbdb017af27d962f5a7bde824d9", "filename": "cargo-miri-test/tests/foo.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/cargo-miri-test%2Ftests%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/cargo-miri-test%2Ftests%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri-test%2Ftests%2Ffoo.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-#[test]\n-fn bar() {\n-    assert_eq!(4, 4);\n-}"}, {"sha": "06d5b3e9971fe10499f35e9a88b865ec73feb2c4", "filename": "miri/bin/cargo-miri.rs", "status": "removed", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fcargo-miri.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,212 +0,0 @@\n-extern crate cargo_metadata;\n-\n-use std::path::{PathBuf, Path};\n-use std::io::Write;\n-use std::process::Command;\n-\n-\n-const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates\n-\n-Usage:\n-    cargo miri [options] [--] [<opts>...]\n-\n-Common options:\n-    -h, --help               Print this message\n-    --features               Features to compile for the package\n-    -V, --version            Print version info and exit\n-\n-Other options are the same as `cargo rustc`.\n-\n-The feature `cargo-miri` is automatically defined for convenience. You can use\n-it to configure the resource limits\n-\n-    #![cfg_attr(feature = \"cargo-miri\", memory_size = 42)]\n-\n-available resource limits are `memory_size`, `step_limit`, `stack_limit`\n-\"#;\n-\n-fn show_help() {\n-    println!(\"{}\", CARGO_MIRI_HELP);\n-}\n-\n-fn show_version() {\n-    println!(\"{}\", env!(\"CARGO_PKG_VERSION\"));\n-}\n-\n-fn main() {\n-    // Check for version and help flags even when invoked as 'cargo-miri'\n-    if std::env::args().any(|a| a == \"--help\" || a == \"-h\") {\n-        show_help();\n-        return;\n-    }\n-    if std::env::args().any(|a| a == \"--version\" || a == \"-V\") {\n-        show_version();\n-        return;\n-    }\n-\n-    if let Some(\"miri\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n-        // this arm is when `cargo miri` is called\n-\n-        let test = std::env::args().nth(2).map_or(false, |text| text == \"test\");\n-        let skip = if test { 3 } else { 2 };\n-\n-        let manifest_path_arg = std::env::args().skip(skip).find(|val| {\n-            val.starts_with(\"--manifest-path=\")\n-        });\n-\n-        let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(\n-            manifest_path_arg.as_ref().map(AsRef::as_ref),\n-        )\n-        {\n-            metadata\n-        } else {\n-            let _ = std::io::stderr().write_fmt(format_args!(\n-                \"error: Could not obtain cargo metadata.\"\n-            ));\n-            std::process::exit(101);\n-        };\n-\n-        let manifest_path = manifest_path_arg.map(|arg| {\n-            PathBuf::from(Path::new(&arg[\"--manifest-path=\".len()..]))\n-        });\n-\n-        let current_dir = std::env::current_dir();\n-\n-        let package_index = metadata\n-            .packages\n-            .iter()\n-            .position(|package| {\n-                let package_manifest_path = Path::new(&package.manifest_path);\n-                if let Some(ref manifest_path) = manifest_path {\n-                    package_manifest_path == manifest_path\n-                } else {\n-                    let current_dir = current_dir.as_ref().expect(\n-                        \"could not read current directory\",\n-                    );\n-                    let package_manifest_directory = package_manifest_path.parent().expect(\n-                        \"could not find parent directory of package manifest\",\n-                    );\n-                    package_manifest_directory == current_dir\n-                }\n-            })\n-            .expect(\"could not find matching package\");\n-        let package = metadata.packages.remove(package_index);\n-        for target in package.targets {\n-            let args = std::env::args().skip(skip);\n-            let kind = target.kind.get(0).expect(\n-                \"badly formatted cargo metadata: target::kind is an empty array\",\n-            );\n-            if test && kind == \"test\" {\n-                if let Err(code) = process(\n-                    vec![\"--test\".to_string(), target.name].into_iter().chain(\n-                        args,\n-                    ),\n-                )\n-                {\n-                    std::process::exit(code);\n-                }\n-            } else if !test && kind == \"bin\" {\n-                if let Err(code) = process(\n-                    vec![\"--bin\".to_string(), target.name].into_iter().chain(\n-                        args,\n-                    ),\n-                )\n-                {\n-                    std::process::exit(code);\n-                }\n-            }\n-        }\n-    } else {\n-        // this arm is executed when cargo-miri runs `cargo rustc` with the `RUSTC` env var set to itself\n-\n-        let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n-        let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n-        let sys_root = if let (Some(home), Some(toolchain)) = (home, toolchain) {\n-            format!(\"{}/toolchains/{}\", home, toolchain)\n-        } else {\n-            option_env!(\"RUST_SYSROOT\")\n-                .map(|s| s.to_owned())\n-                .or_else(|| {\n-                    Command::new(\"rustc\")\n-                        .arg(\"--print\")\n-                        .arg(\"sysroot\")\n-                        .output()\n-                        .ok()\n-                        .and_then(|out| String::from_utf8(out.stdout).ok())\n-                        .map(|s| s.trim().to_owned())\n-                })\n-                .expect(\"need to specify RUST_SYSROOT env var during miri compilation, or use rustup or multirust\")\n-        };\n-\n-        // this conditional check for the --sysroot flag is there so users can call `cargo-miri` directly\n-        // without having to pass --sysroot or anything\n-        let mut args: Vec<String> = if std::env::args().any(|s| s == \"--sysroot\") {\n-            std::env::args().skip(1).collect()\n-        } else {\n-            std::env::args()\n-                .skip(1)\n-                .chain(Some(\"--sysroot\".to_owned()))\n-                .chain(Some(sys_root))\n-                .collect()\n-        };\n-\n-        // this check ensures that dependencies are built but not interpreted and the final crate is\n-        // interpreted but not built\n-        let miri_enabled = std::env::args().any(|s| s == \"-Zno-trans\");\n-\n-        let mut command = if miri_enabled {\n-            let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n-            path.set_file_name(\"miri\");\n-            Command::new(path)\n-        } else {\n-            Command::new(\"rustc\")\n-        };\n-\n-        args.extend_from_slice(&[\"-Z\".to_owned(), \"always-encode-mir\".to_owned()]);\n-        args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-miri\"\"#.to_owned()]);\n-\n-        match command.args(&args).status() {\n-            Ok(exit) => {\n-                if !exit.success() {\n-                    std::process::exit(exit.code().unwrap_or(42));\n-                }\n-            }\n-            Err(ref e) if miri_enabled => panic!(\"error during miri run: {:?}\", e),\n-            Err(ref e) => panic!(\"error during rustc call: {:?}\", e),\n-        }\n-    }\n-}\n-\n-fn process<I>(old_args: I) -> Result<(), i32>\n-where\n-    I: Iterator<Item = String>,\n-{\n-    let mut args = vec![\"rustc\".to_owned()];\n-\n-    let mut found_dashes = false;\n-    for arg in old_args {\n-        found_dashes |= arg == \"--\";\n-        args.push(arg);\n-    }\n-    if !found_dashes {\n-        args.push(\"--\".to_owned());\n-    }\n-    args.push(\"-Zno-trans\".to_owned());\n-    args.push(\"--cfg\".to_owned());\n-    args.push(r#\"feature=\"cargo-miri\"\"#.to_owned());\n-\n-    let path = std::env::current_exe().expect(\"current executable path invalid\");\n-    let exit_status = std::process::Command::new(\"cargo\")\n-        .args(&args)\n-        .env(\"RUSTC\", path)\n-        .spawn()\n-        .expect(\"could not run cargo\")\n-        .wait()\n-        .expect(\"failed to wait for cargo?\");\n-\n-    if exit_status.success() {\n-        Ok(())\n-    } else {\n-        Err(exit_status.code().unwrap_or(-1))\n-    }\n-}"}, {"sha": "d38f63610a0e00f9a5b50003e0d9a7ea4b70f66f", "filename": "miri/bin/miri.rs", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fmiri.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,265 +0,0 @@\n-#![feature(rustc_private, i128_type)]\n-\n-extern crate getopts;\n-extern crate miri;\n-extern crate rustc;\n-extern crate rustc_driver;\n-extern crate rustc_errors;\n-extern crate env_logger;\n-extern crate log_settings;\n-extern crate syntax;\n-extern crate log;\n-\n-use rustc::session::Session;\n-use rustc::middle::cstore::CrateStore;\n-use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n-use rustc_driver::driver::{CompileState, CompileController};\n-use rustc::session::config::{self, Input, ErrorOutputType};\n-use rustc::hir::{self, itemlikevisit};\n-use rustc::ty::TyCtxt;\n-use syntax::ast::{self, MetaItemKind, NestedMetaItemKind};\n-use std::path::PathBuf;\n-\n-struct MiriCompilerCalls {\n-    default: RustcDefaultCalls,\n-}\n-\n-impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n-    fn early_callback(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        descriptions: &rustc_errors::registry::Registry,\n-        output: ErrorOutputType,\n-    ) -> Compilation {\n-        self.default.early_callback(\n-            matches,\n-            sopts,\n-            cfg,\n-            descriptions,\n-            output,\n-        )\n-    }\n-    fn no_input(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        descriptions: &rustc_errors::registry::Registry,\n-    ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default.no_input(\n-            matches,\n-            sopts,\n-            cfg,\n-            odir,\n-            ofile,\n-            descriptions,\n-        )\n-    }\n-    fn late_callback(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sess: &Session,\n-        cstore: &CrateStore,\n-        input: &Input,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-    ) -> Compilation {\n-        self.default.late_callback(matches, sess, cstore, input, odir, ofile)\n-    }\n-    fn build_controller(\n-        &mut self,\n-        sess: &Session,\n-        matches: &getopts::Matches,\n-    ) -> CompileController<'a> {\n-        let mut control = self.default.build_controller(sess, matches);\n-        control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        control.after_analysis.callback = Box::new(after_analysis);\n-        if sess.target.target != sess.host {\n-            // only fully compile targets on the host. linking will fail for cross-compilation.\n-            control.after_analysis.stop = Compilation::Stop;\n-        }\n-        control\n-    }\n-}\n-\n-fn after_hir_lowering(state: &mut CompileState) {\n-    let attr = (\n-        String::from(\"miri\"),\n-        syntax::feature_gate::AttributeType::Whitelisted,\n-    );\n-    state.session.plugin_attributes.borrow_mut().push(attr);\n-}\n-\n-fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n-    state.session.abort_if_errors();\n-\n-    let tcx = state.tcx.unwrap();\n-    let limits = resource_limits_from_attributes(state);\n-\n-    if std::env::args().any(|arg| arg == \"--test\") {\n-        struct Visitor<'a, 'tcx: 'a>(\n-            miri::ResourceLimits,\n-            TyCtxt<'a, 'tcx, 'tcx>,\n-            &'a CompileState<'a, 'tcx>\n-        );\n-        impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n-            fn visit_item(&mut self, i: &'hir hir::Item) {\n-                if let hir::Item_::ItemFn(_, _, _, _, _, body_id) = i.node {\n-                    if i.attrs.iter().any(|attr| {\n-                        attr.name().map_or(false, |n| n == \"test\")\n-                    })\n-                    {\n-                        let did = self.1.hir.body_owner_def_id(body_id);\n-                        println!(\n-                            \"running test: {}\",\n-                            self.1.hir.def_path(did).to_string(self.1)\n-                        );\n-                        miri::eval_main(self.1, did, None, self.0);\n-                        self.2.session.abort_if_errors();\n-                    }\n-                }\n-            }\n-            fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n-            fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n-        }\n-        state.hir_crate.unwrap().visit_all_item_likes(\n-            &mut Visitor(limits, tcx, state),\n-        );\n-    } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n-        let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        let start_wrapper = tcx.lang_items().start_fn().and_then(|start_fn| {\n-            if tcx.is_mir_available(start_fn) {\n-                Some(start_fn)\n-            } else {\n-                None\n-            }\n-        });\n-        miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n-\n-        state.session.abort_if_errors();\n-    } else {\n-        println!(\"no main function found, assuming auxiliary build\");\n-    }\n-}\n-\n-fn resource_limits_from_attributes(state: &CompileState) -> miri::ResourceLimits {\n-    let mut limits = miri::ResourceLimits::default();\n-    let krate = state.hir_crate.as_ref().unwrap();\n-    let err_msg = \"miri attributes need to be in the form `miri(key = value)`\";\n-    let extract_int = |lit: &syntax::ast::Lit| -> u128 {\n-        match lit.node {\n-            syntax::ast::LitKind::Int(i, _) => i,\n-            _ => {\n-                state.session.span_fatal(\n-                    lit.span,\n-                    \"expected an integer literal\",\n-                )\n-            }\n-        }\n-    };\n-\n-    for attr in krate.attrs.iter().filter(|a| {\n-        a.name().map_or(false, |n| n == \"miri\")\n-    })\n-    {\n-        if let Some(items) = attr.meta_item_list() {\n-            for item in items {\n-                if let NestedMetaItemKind::MetaItem(ref inner) = item.node {\n-                    if let MetaItemKind::NameValue(ref value) = inner.node {\n-                        match &inner.name().as_str()[..] {\n-                            \"memory_size\" => limits.memory_size = extract_int(value) as u64,\n-                            \"step_limit\" => limits.step_limit = extract_int(value) as u64,\n-                            \"stack_limit\" => limits.stack_limit = extract_int(value) as usize,\n-                            _ => state.session.span_err(item.span, \"unknown miri attribute\"),\n-                        }\n-                    } else {\n-                        state.session.span_err(inner.span, err_msg);\n-                    }\n-                } else {\n-                    state.session.span_err(item.span, err_msg);\n-                }\n-            }\n-        } else {\n-            state.session.span_err(attr.span, err_msg);\n-        }\n-    }\n-    limits\n-}\n-\n-fn init_logger() {\n-    let format = |record: &log::LogRecord| {\n-        if record.level() == log::LogLevel::Trace {\n-            // prepend spaces to indent the final string\n-            let indentation = log_settings::settings().indentation;\n-            format!(\n-                \"{lvl}:{module}:{indent:<indentation$} {text}\",\n-                lvl = record.level(),\n-                module = record.location().module_path(),\n-                indentation = indentation,\n-                indent = \"\",\n-                text = record.args(),\n-            )\n-        } else {\n-            format!(\n-                \"{lvl}:{module}: {text}\",\n-                lvl = record.level(),\n-                module = record.location().module_path(),\n-                text = record.args(),\n-            )\n-        }\n-    };\n-\n-    let mut builder = env_logger::LogBuilder::new();\n-    builder.format(format).filter(\n-        None,\n-        log::LogLevelFilter::Info,\n-    );\n-\n-    if std::env::var(\"MIRI_LOG\").is_ok() {\n-        builder.parse(&std::env::var(\"MIRI_LOG\").unwrap());\n-    }\n-\n-    builder.init().unwrap();\n-}\n-\n-fn find_sysroot() -> String {\n-    if let Ok(sysroot) = std::env::var(\"MIRI_SYSROOT\") {\n-        return sysroot;\n-    }\n-\n-    // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n-    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n-    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n-    match (home, toolchain) {\n-        (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n-        _ => {\n-            option_env!(\"RUST_SYSROOT\")\n-                .expect(\n-                    \"need to specify RUST_SYSROOT env var or use rustup or multirust\",\n-                )\n-                .to_owned()\n-        }\n-    }\n-}\n-\n-fn main() {\n-    init_logger();\n-    let mut args: Vec<String> = std::env::args().collect();\n-\n-    let sysroot_flag = String::from(\"--sysroot\");\n-    if !args.contains(&sysroot_flag) {\n-        args.push(sysroot_flag);\n-        args.push(find_sysroot());\n-    }\n-\n-    // Make sure we always have all the MIR (e.g. for auxilary builds in unit tests).\n-    args.push(\"-Zalways-encode-mir\".to_owned());\n-\n-    rustc_driver::run_compiler(&args, &mut MiriCompilerCalls {\n-        default: RustcDefaultCalls,\n-    }, None, None);\n-}"}, {"sha": "79ef3f97a9e9afcd420bbdfa463658c1b6f4937b", "filename": "miri/fn_call.rs", "status": "removed", "additions": 0, "deletions": 656, "changes": 656, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,656 +0,0 @@\n-use rustc::ty::{self, Ty};\n-use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n-use rustc::mir;\n-use syntax::attr;\n-use syntax::abi::Abi;\n-use syntax::codemap::Span;\n-\n-use std::mem;\n-\n-use rustc_miri::interpret::*;\n-\n-use super::{TlsKey, EvalContext};\n-\n-use tls::MemoryExt;\n-\n-use super::memory::MemoryKind;\n-\n-pub trait EvalContextExt<'tcx> {\n-    fn call_c_abi(\n-        &mut self,\n-        def_id: DefId,\n-        args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n-        dest_ty: Ty<'tcx>,\n-        dest_block: mir::BasicBlock,\n-    ) -> EvalResult<'tcx>;\n-\n-    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n-\n-    fn call_missing_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n-        sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx>;\n-\n-    fn eval_fn_call(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n-        span: Span,\n-        sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool>;\n-}\n-\n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n-    fn eval_fn_call(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n-        span: Span,\n-        sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        trace!(\"eval_fn_call: {:#?}, {:#?}\", instance, destination);\n-\n-        let mir = match self.load_mir(instance.def) {\n-            Ok(mir) => mir,\n-            Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n-                self.call_missing_fn(\n-                    instance,\n-                    destination,\n-                    args,\n-                    sig,\n-                    path,\n-                )?;\n-                return Ok(true);\n-            }\n-            Err(other) => return Err(other),\n-        };\n-\n-        let (return_lvalue, return_to_block) = match destination {\n-            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n-            None => (Lvalue::undef(), StackPopCleanup::None),\n-        };\n-\n-        self.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            return_lvalue,\n-            return_to_block,\n-        )?;\n-\n-        Ok(false)\n-    }\n-\n-    fn call_c_abi(\n-        &mut self,\n-        def_id: DefId,\n-        args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n-        dest_ty: Ty<'tcx>,\n-        dest_block: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        let attrs = self.tcx.get_attrs(def_id);\n-        let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n-            Some(name) => name.as_str(),\n-            None => self.tcx.item_name(def_id),\n-        };\n-\n-        match &link_name[..] {\n-            \"malloc\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n-                if size == 0 {\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align, MemoryKind::C.into())?;\n-                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-                }\n-            }\n-\n-            \"free\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n-                if !ptr.is_null()? {\n-                    self.memory.deallocate(\n-                        ptr.to_ptr()?,\n-                        None,\n-                        MemoryKind::C.into(),\n-                    )?;\n-                }\n-            }\n-\n-            \"syscall\" => {\n-                // TODO: read `syscall` ids like `sysconf` ids and\n-                // figure out some way to actually process some of them\n-                //\n-                // libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n-                // is called if a `HashMap` is created the regular way.\n-                match self.value_to_primval(args[0])?.to_u64()? {\n-                    318 | 511 => {\n-                        return err!(Unimplemented(\n-                            \"miri does not support random number generators\".to_owned(),\n-                        ))\n-                    }\n-                    id => {\n-                        return err!(Unimplemented(\n-                            format!(\"miri does not support syscall id {}\", id),\n-                        ))\n-                    }\n-                }\n-            }\n-\n-            \"dlsym\" => {\n-                let _handle = args[0].into_ptr(&mut self.memory)?;\n-                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let symbol_name = self.memory.read_c_str(symbol)?;\n-                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n-                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n-                return err!(Unimplemented(format!(\n-                    \"miri does not support dynamically loading libraries (requested symbol: {})\",\n-                    symbol_name\n-                )));\n-            }\n-\n-            \"__rust_maybe_catch_panic\" => {\n-                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n-                // We abort on panic, so not much is going on here, but we still have to call the closure\n-                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let data = args[1].into_ptr(&mut self.memory)?;\n-                let f_instance = self.memory.get_fn(f)?;\n-                self.write_null(dest, dest_ty)?;\n-\n-                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n-                // and of course eval_main.\n-                let mir = self.load_mir(f_instance.def)?;\n-                self.push_stack_frame(\n-                    f_instance,\n-                    mir.span,\n-                    mir,\n-                    Lvalue::undef(),\n-                    StackPopCleanup::Goto(dest_block),\n-                )?;\n-                let mut args = self.frame().mir.args_iter();\n-\n-                let arg_local = args.next().ok_or(\n-                    EvalErrorKind::AbiViolation(\n-                        \"Argument to __rust_maybe_catch_panic does not take enough arguments.\"\n-                            .to_owned(),\n-                    ),\n-                )?;\n-                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n-\n-                assert!(args.next().is_none(), \"__rust_maybe_catch_panic argument has more arguments than expected\");\n-\n-                // We ourselves return 0\n-                self.write_null(dest, dest_ty)?;\n-\n-                // Don't fall through\n-                return Ok(());\n-            }\n-\n-            \"__rust_start_panic\" => {\n-                return err!(Panic);\n-            }\n-\n-            \"memcmp\" => {\n-                let left = args[0].into_ptr(&mut self.memory)?;\n-                let right = args[1].into_ptr(&mut self.memory)?;\n-                let n = self.value_to_primval(args[2])?.to_u64()?;\n-\n-                let result = {\n-                    let left_bytes = self.memory.read_bytes(left, n)?;\n-                    let right_bytes = self.memory.read_bytes(right, n)?;\n-\n-                    use std::cmp::Ordering::*;\n-                    match left_bytes.cmp(right_bytes) {\n-                        Less => -1i8,\n-                        Equal => 0,\n-                        Greater => 1,\n-                    }\n-                };\n-\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::Bytes(result as u128),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"memrchr\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n-                let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2])?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(\n-                    |&c| c == val,\n-                )\n-                {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n-                    self.write_ptr(dest, new_ptr, dest_ty)?;\n-                } else {\n-                    self.write_null(dest, dest_ty)?;\n-                }\n-            }\n-\n-            \"memchr\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n-                let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2])?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(\n-                    |&c| c == val,\n-                )\n-                {\n-                    let new_ptr = ptr.offset(idx as u64, &self)?;\n-                    self.write_ptr(dest, new_ptr, dest_ty)?;\n-                } else {\n-                    self.write_null(dest, dest_ty)?;\n-                }\n-            }\n-\n-            \"getenv\" => {\n-                let result = {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                    let name = self.memory.read_c_str(name_ptr)?;\n-                    match self.machine_data.env_vars.get(name) {\n-                        Some(&var) => PrimVal::Ptr(var),\n-                        None => PrimVal::Bytes(0),\n-                    }\n-                };\n-                self.write_primval(dest, result, dest_ty)?;\n-            }\n-\n-            \"unsetenv\" => {\n-                let mut success = None;\n-                {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n-                    if !name_ptr.is_null()? {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(self.machine_data.env_vars.remove(name));\n-                        }\n-                    }\n-                }\n-                if let Some(old) = success {\n-                    if let Some(var) = old {\n-                        self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n-                    }\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n-                }\n-            }\n-\n-            \"setenv\" => {\n-                let mut new = None;\n-                {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n-                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n-                    let value = self.memory.read_c_str(value_ptr)?;\n-                    if !name_ptr.is_null()? {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            new = Some((name.to_owned(), value.to_owned()));\n-                        }\n-                    }\n-                }\n-                if let Some((name, value)) = new {\n-                    // +1 for the null terminator\n-                    let value_copy = self.memory.allocate(\n-                        (value.len() + 1) as u64,\n-                        1,\n-                        MemoryKind::Env.into(),\n-                    )?;\n-                    self.memory.write_bytes(value_copy.into(), &value)?;\n-                    let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n-                    self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n-                    if let Some(var) = self.machine_data.env_vars.insert(\n-                        name.to_owned(),\n-                        value_copy,\n-                    )\n-                    {\n-                        self.memory.deallocate(var, None, MemoryKind::Env.into())?;\n-                    }\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n-                }\n-            }\n-\n-            \"write\" => {\n-                let fd = self.value_to_primval(args[0])?.to_u64()?;\n-                let buf = args[1].into_ptr(&mut self.memory)?;\n-                let n = self.value_to_primval(args[2])?.to_u64()?;\n-                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n-                let result = if fd == 1 || fd == 2 {\n-                    // stdout/stderr\n-                    use std::io::{self, Write};\n-\n-                    let buf_cont = self.memory.read_bytes(buf, n)?;\n-                    let res = if fd == 1 {\n-                        io::stdout().write(buf_cont)\n-                    } else {\n-                        io::stderr().write(buf_cont)\n-                    };\n-                    match res {\n-                        Ok(n) => n as isize,\n-                        Err(_) => -1,\n-                    }\n-                } else {\n-                    warn!(\"Ignored output to FD {}\", fd);\n-                    n as isize // pretend it all went well\n-                }; // now result is the value we return back to the program\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::Bytes(result as u128),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"strlen\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let n = self.memory.read_c_str(ptr)?.len();\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n-            }\n-\n-            // Some things needed for sys::thread initialization to go through\n-            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n-            }\n-\n-            \"sysconf\" => {\n-                let name = self.value_to_primval(args[0])?.to_u64()?;\n-                trace!(\"sysconf() called with name {}\", name);\n-                // cache the sysconf integers via miri's global cache\n-                let paths = &[\n-                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n-                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n-                ];\n-                let mut result = None;\n-                for &(path, path_value) in paths {\n-                    if let Ok(instance) = self.resolve_path(path) {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None,\n-                        };\n-                        // compute global if not cached\n-                        let val = match self.globals.get(&cid).cloned() {\n-                            Some(ptr) => self.value_to_primval(ValTy { value: Value::ByRef(ptr), ty: args[0].ty })?.to_u64()?,\n-                            None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n-                        };\n-                        if val == name {\n-                            result = Some(path_value);\n-                            break;\n-                        }\n-                    }\n-                }\n-                if let Some(result) = result {\n-                    self.write_primval(dest, result, dest_ty)?;\n-                } else {\n-                    return err!(Unimplemented(\n-                        format!(\"Unimplemented sysconf name: {}\", name),\n-                    ));\n-                }\n-            }\n-\n-            // Hook pthread calls that go to the thread-local storage memory subsystem\n-            \"pthread_key_create\" => {\n-                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n-\n-                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n-                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n-                    PrimVal::Bytes(0) => None,\n-                    PrimVal::Bytes(_) => return err!(ReadBytesAsPointer),\n-                    PrimVal::Undef => return err!(ReadUndefBytes),\n-                };\n-\n-                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = args[0].ty.builtin_deref(true, ty::LvaluePreference::NoPreference)\n-                                   .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n-                let key_size = {\n-                    let layout = self.type_layout(key_type)?;\n-                    layout.size(&self.tcx.data_layout)\n-                };\n-\n-                // Create key and write it into the memory where key_ptr wants it\n-                let key = self.memory.create_tls_key(dtor) as u128;\n-                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n-                    return err!(OutOfTls);\n-                }\n-                self.memory.write_primval(\n-                    key_ptr.to_ptr()?,\n-                    PrimVal::Bytes(key),\n-                    key_size.bytes(),\n-                    false,\n-                )?;\n-\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-            \"pthread_key_delete\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n-                self.memory.delete_tls_key(key)?;\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-            \"pthread_getspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n-                let ptr = self.memory.load_tls(key)?;\n-                self.write_ptr(dest, ptr, dest_ty)?;\n-            }\n-            \"pthread_setspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n-                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n-                self.memory.store_tls(key, new_ptr)?;\n-\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-\n-            // Stub out all the other pthread calls to just return 0\n-            link_name if link_name.starts_with(\"pthread_\") => {\n-                info!(\"ignoring C ABI call: {}\", link_name);\n-                self.write_null(dest, dest_ty)?;\n-            }\n-\n-            _ => {\n-                return err!(Unimplemented(\n-                    format!(\"can't call C ABI function: {}\", link_name),\n-                ));\n-            }\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        self.dump_local(dest);\n-        self.goto_block(dest_block);\n-        Ok(())\n-    }\n-\n-    /// Get an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n-        self.tcx\n-            .crates()\n-            .iter()\n-            .find(|&&krate| self.tcx.original_crate_name(krate) == path[0])\n-            .and_then(|krate| {\n-                let krate = DefId {\n-                    krate: *krate,\n-                    index: CRATE_DEF_INDEX,\n-                };\n-                let mut items = self.tcx.item_children(krate);\n-                let mut path_it = path.iter().skip(1).peekable();\n-\n-                while let Some(segment) = path_it.next() {\n-                    for item in mem::replace(&mut items, Default::default()).iter() {\n-                        if item.ident.name == *segment {\n-                            if path_it.peek().is_none() {\n-                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n-                            }\n-\n-                            items = self.tcx.item_children(item.def.def_id());\n-                            break;\n-                        }\n-                    }\n-                }\n-                None\n-            })\n-            .ok_or_else(|| {\n-                let path = path.iter().map(|&s| s.to_owned()).collect();\n-                EvalErrorKind::PathNotFound(path).into()\n-            })\n-    }\n-\n-    fn call_missing_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n-        sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx> {\n-        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n-        match &path[..] {\n-            \"std::panicking::rust_panic_with_hook\" |\n-            \"core::panicking::panic_fmt::::panic_impl\" |\n-            \"std::rt::begin_panic_fmt\" => return err!(Panic),\n-            _ => {}\n-        }\n-\n-        let dest_ty = sig.output();\n-        let (dest, dest_block) = destination.ok_or_else(\n-            || EvalErrorKind::NoMirFor(path.clone()),\n-        )?;\n-\n-        if sig.abi == Abi::C {\n-            // An external C function\n-            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n-            // unify these two mechanisms for \"hooking into missing functions\".\n-            self.call_c_abi(\n-                instance.def_id(),\n-                args,\n-                dest,\n-                dest_ty,\n-                dest_block,\n-            )?;\n-            return Ok(());\n-        }\n-\n-        match &path[..] {\n-            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n-            \"alloc::heap::::__rust_alloc\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n-                let align = self.value_to_primval(args[1])?.to_u64()?;\n-                if size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, MemoryKind::Rust.into())?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n-                let align = self.value_to_primval(args[1])?.to_u64()?;\n-                if size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, MemoryKind::Rust.into())?;\n-                self.memory.write_repeat(ptr.into(), 0, size)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1])?.to_u64()?;\n-                let align = self.value_to_primval(args[2])?.to_u64()?;\n-                if old_size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                self.memory.deallocate(\n-                    ptr,\n-                    Some((old_size, align)),\n-                    MemoryKind::Rust.into(),\n-                )?;\n-            }\n-            \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1])?.to_u64()?;\n-                let old_align = self.value_to_primval(args[2])?.to_u64()?;\n-                let new_size = self.value_to_primval(args[3])?.to_u64()?;\n-                let new_align = self.value_to_primval(args[4])?.to_u64()?;\n-                if old_size == 0 || new_size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n-                }\n-                if !old_align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(old_align));\n-                }\n-                if !new_align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(new_align));\n-                }\n-                let new_ptr = self.memory.reallocate(\n-                    ptr,\n-                    old_size,\n-                    old_align,\n-                    new_size,\n-                    new_align,\n-                    MemoryKind::Rust.into(),\n-                )?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n-            }\n-\n-            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n-            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n-            \"std::io::_print\" => {\n-                warn!(\n-                    \"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\"\n-                );\n-            }\n-            \"std::thread::Builder::new\" => {\n-                return err!(Unimplemented(\"miri does not support threading\".to_owned()))\n-            }\n-            \"std::env::args\" => {\n-                return err!(Unimplemented(\n-                    \"miri does not support program arguments\".to_owned(),\n-                ))\n-            }\n-            \"std::panicking::panicking\" |\n-            \"std::rt::panicking\" => {\n-                // we abort on panic -> `std::rt::panicking` always returns false\n-                let bool = self.tcx.types.bool;\n-                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n-            }\n-            \"std::sys::imp::c::::AddVectoredExceptionHandler\" |\n-            \"std::sys::imp::c::::SetThreadStackGuarantee\" => {\n-                let usize = self.tcx.types.usize;\n-                // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n-                self.write_primval(dest, PrimVal::Bytes(1), usize)?;\n-            },\n-            _ => return err!(NoMirFor(path)),\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        self.dump_local(dest);\n-        self.goto_block(dest_block);\n-        return Ok(());\n-    }\n-}"}, {"sha": "809e5ebfacdb01dcbff976b5230d1a54cfee414c", "filename": "miri/helpers.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fhelpers.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,73 +0,0 @@\n-use rustc_miri::interpret::{Pointer, EvalResult, PrimVal, EvalContext};\n-\n-use rustc::ty::Ty;\n-\n-pub trait EvalContextExt<'tcx> {\n-    fn wrapping_pointer_offset(\n-        &self,\n-        ptr: Pointer,\n-        pointee_ty: Ty<'tcx>,\n-        offset: i64,\n-    ) -> EvalResult<'tcx, Pointer>;\n-\n-    fn pointer_offset(\n-        &self,\n-        ptr: Pointer,\n-        pointee_ty: Ty<'tcx>,\n-        offset: i64,\n-    ) -> EvalResult<'tcx, Pointer>;\n-}\n-\n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n-    fn wrapping_pointer_offset(\n-        &self,\n-        ptr: Pointer,\n-        pointee_ty: Ty<'tcx>,\n-        offset: i64,\n-    ) -> EvalResult<'tcx, Pointer> {\n-        // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\n-            \"cannot offset a pointer to an unsized type\",\n-        ) as i64;\n-        let offset = offset.overflowing_mul(pointee_size).0;\n-        ptr.wrapping_signed_offset(offset, self)\n-    }\n-\n-    fn pointer_offset(\n-        &self,\n-        ptr: Pointer,\n-        pointee_ty: Ty<'tcx>,\n-        offset: i64,\n-    ) -> EvalResult<'tcx, Pointer> {\n-        // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n-        // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n-        // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n-        // allocation.\n-\n-        if ptr.is_null()? {\n-            // NULL pointers must only be offset by 0\n-            return if offset == 0 {\n-                Ok(ptr)\n-            } else {\n-                err!(InvalidNullPointerUsage)\n-            };\n-        }\n-        // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\n-            \"cannot offset a pointer to an unsized type\",\n-        ) as i64;\n-        return if let Some(offset) = offset.checked_mul(pointee_size) {\n-            let ptr = ptr.signed_offset(offset, self)?;\n-            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n-            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n-                self.memory.check_bounds(ptr, false)?;\n-            } else if ptr.is_null()? {\n-                // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n-                return err!(InvalidNullPointerUsage);\n-            }\n-            Ok(ptr)\n-        } else {\n-            err!(OverflowingMath)\n-        };\n-    }\n-}"}, {"sha": "bcff3b4aa99191c9f450f08c1c66e434fb602190", "filename": "miri/intrinsic.rs", "status": "removed", "additions": 0, "deletions": 685, "changes": 685, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,685 +0,0 @@\n-use rustc::mir;\n-use rustc::traits::Reveal;\n-use rustc::ty::layout::Layout;\n-use rustc::ty::{self, Ty};\n-\n-use rustc_miri::interpret::{EvalResult, Lvalue, LvalueExtra, PrimVal, PrimValKind, Value, Pointer,\n-                            HasMemory, AccessKind, EvalContext, PtrAndAlign, ValTy};\n-\n-use helpers::EvalContextExt as HelperEvalContextExt;\n-\n-pub trait EvalContextExt<'tcx> {\n-    fn call_intrinsic(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n-        dest_ty: Ty<'tcx>,\n-        dest_layout: &'tcx Layout,\n-        target: mir::BasicBlock,\n-    ) -> EvalResult<'tcx>;\n-}\n-\n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n-    fn call_intrinsic(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n-        dest_ty: Ty<'tcx>,\n-        dest_layout: &'tcx Layout,\n-        target: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        let substs = instance.substs;\n-\n-        let intrinsic_name = &self.tcx.item_name(instance.def_id())[..];\n-        match intrinsic_name {\n-            \"align_offset\" => {\n-                // FIXME: return a real value in case the target allocation has an\n-                // alignment bigger than the one requested\n-                self.write_primval(dest, PrimVal::Bytes(u128::max_value()), dest_ty)?;\n-            },\n-\n-            \"add_with_overflow\" => {\n-                self.intrinsic_with_overflow(\n-                    mir::BinOp::Add,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?\n-            }\n-\n-            \"sub_with_overflow\" => {\n-                self.intrinsic_with_overflow(\n-                    mir::BinOp::Sub,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?\n-            }\n-\n-            \"mul_with_overflow\" => {\n-                self.intrinsic_with_overflow(\n-                    mir::BinOp::Mul,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?\n-            }\n-\n-            \"arith_offset\" => {\n-                let offset = self.value_to_primval(args[1])?.to_i128()? as i64;\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n-                self.write_ptr(dest, result_ptr, dest_ty)?;\n-            }\n-\n-            \"assume\" => {\n-                let cond = self.value_to_primval(args[0])?.to_bool()?;\n-                if !cond {\n-                    return err!(AssumptionNotHeld);\n-                }\n-            }\n-\n-            \"atomic_load\" |\n-            \"atomic_load_relaxed\" |\n-            \"atomic_load_acq\" |\n-            \"volatile_load\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let valty = ValTy {\n-                    value: Value::by_ref(ptr),\n-                    ty: substs.type_at(0),\n-                };\n-                self.write_value(valty, dest)?;\n-            }\n-\n-            \"atomic_store\" |\n-            \"atomic_store_relaxed\" |\n-            \"atomic_store_rel\" |\n-            \"volatile_store\" => {\n-                let ty = substs.type_at(0);\n-                let dest = args[0].into_ptr(&self.memory)?;\n-                self.write_value_to_ptr(args[1].value, dest, ty)?;\n-            }\n-\n-            \"atomic_fence_acq\" => {\n-                // we are inherently singlethreaded and singlecored, this is a nop\n-            }\n-\n-            _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let ty = substs.type_at(0);\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let change = self.value_to_primval(args[1])?;\n-                let old = self.read_value(ptr, ty)?;\n-                let old = match old {\n-                    Value::ByVal(val) => val,\n-                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n-                };\n-                self.write_primval(dest, old, ty)?;\n-                self.write_primval(\n-                    Lvalue::from_primval_ptr(ptr),\n-                    change,\n-                    ty,\n-                )?;\n-            }\n-\n-            _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let ty = substs.type_at(0);\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let expect_old = self.value_to_primval(args[1])?;\n-                let change = self.value_to_primval(args[2])?;\n-                let old = self.read_value(ptr, ty)?;\n-                let old = match old {\n-                    Value::ByVal(val) => val,\n-                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n-                };\n-                let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n-                let dest = self.force_allocation(dest)?.to_ptr()?;\n-                self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n-                self.write_primval(\n-                    Lvalue::from_primval_ptr(ptr),\n-                    change,\n-                    ty,\n-                )?;\n-            }\n-\n-            \"atomic_or\" |\n-            \"atomic_or_acq\" |\n-            \"atomic_or_rel\" |\n-            \"atomic_or_acqrel\" |\n-            \"atomic_or_relaxed\" |\n-            \"atomic_xor\" |\n-            \"atomic_xor_acq\" |\n-            \"atomic_xor_rel\" |\n-            \"atomic_xor_acqrel\" |\n-            \"atomic_xor_relaxed\" |\n-            \"atomic_and\" |\n-            \"atomic_and_acq\" |\n-            \"atomic_and_rel\" |\n-            \"atomic_and_acqrel\" |\n-            \"atomic_and_relaxed\" |\n-            \"atomic_xadd\" |\n-            \"atomic_xadd_acq\" |\n-            \"atomic_xadd_rel\" |\n-            \"atomic_xadd_acqrel\" |\n-            \"atomic_xadd_relaxed\" |\n-            \"atomic_xsub\" |\n-            \"atomic_xsub_acq\" |\n-            \"atomic_xsub_rel\" |\n-            \"atomic_xsub_acqrel\" |\n-            \"atomic_xsub_relaxed\" => {\n-                let ty = substs.type_at(0);\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let change = self.value_to_primval(args[1])?;\n-                let old = self.read_value(ptr, ty)?;\n-                let old = match old {\n-                    Value::ByVal(val) => val,\n-                    Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => {\n-                        bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\")\n-                    }\n-                };\n-                self.write_primval(dest, old, ty)?;\n-                let op = match intrinsic_name.split('_').nth(1).unwrap() {\n-                    \"or\" => mir::BinOp::BitOr,\n-                    \"xor\" => mir::BinOp::BitXor,\n-                    \"and\" => mir::BinOp::BitAnd,\n-                    \"xadd\" => mir::BinOp::Add,\n-                    \"xsub\" => mir::BinOp::Sub,\n-                    _ => bug!(),\n-                };\n-                // FIXME: what do atomics do on overflow?\n-                let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n-                self.write_primval(Lvalue::from_primval_ptr(ptr), val, ty)?;\n-            }\n-\n-            \"breakpoint\" => unimplemented!(), // halt miri\n-\n-            \"copy\" |\n-            \"copy_nonoverlapping\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n-                let count = self.value_to_primval(args[2])?.to_u64()?;\n-                if count * elem_size != 0 {\n-                    // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n-                    // Also see the write_bytes intrinsic.\n-                    let elem_align = self.type_align(elem_ty)?;\n-                    let src = args[0].into_ptr(&self.memory)?;\n-                    let dest = args[1].into_ptr(&self.memory)?;\n-                    self.memory.copy(\n-                        src,\n-                        dest,\n-                        count * elem_size,\n-                        elem_align,\n-                        intrinsic_name.ends_with(\"_nonoverlapping\"),\n-                    )?;\n-                }\n-            }\n-\n-            \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n-                let ty = substs.type_at(0);\n-                let num = self.value_to_primval(args[0])?.to_bytes()?;\n-                let kind = self.ty_to_primval_kind(ty)?;\n-                let num = if intrinsic_name.ends_with(\"_nonzero\") {\n-                    if num == 0 {\n-                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n-                    }\n-                    numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), num, kind)?\n-                } else {\n-                    numeric_intrinsic(intrinsic_name, num, kind)?\n-                };\n-                self.write_primval(dest, num, ty)?;\n-            }\n-\n-            \"discriminant_value\" => {\n-                let ty = substs.type_at(0);\n-                let adt_ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n-            }\n-\n-            \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n-            \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n-                let f = self.value_to_primval(args[0])?.to_f32()?;\n-                let f = match intrinsic_name {\n-                    \"sinf32\" => f.sin(),\n-                    \"fabsf32\" => f.abs(),\n-                    \"cosf32\" => f.cos(),\n-                    \"sqrtf32\" => f.sqrt(),\n-                    \"expf32\" => f.exp(),\n-                    \"exp2f32\" => f.exp2(),\n-                    \"logf32\" => f.ln(),\n-                    \"log10f32\" => f.log10(),\n-                    \"log2f32\" => f.log2(),\n-                    \"floorf32\" => f.floor(),\n-                    \"ceilf32\" => f.ceil(),\n-                    \"truncf32\" => f.trunc(),\n-                    _ => bug!(),\n-                };\n-                self.write_primval(dest, PrimVal::from_f32(f), dest_ty)?;\n-            }\n-\n-            \"sinf64\" | \"fabsf64\" | \"cosf64\" | \"sqrtf64\" | \"expf64\" | \"exp2f64\" | \"logf64\" |\n-            \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n-                let f = self.value_to_primval(args[0])?.to_f64()?;\n-                let f = match intrinsic_name {\n-                    \"sinf64\" => f.sin(),\n-                    \"fabsf64\" => f.abs(),\n-                    \"cosf64\" => f.cos(),\n-                    \"sqrtf64\" => f.sqrt(),\n-                    \"expf64\" => f.exp(),\n-                    \"exp2f64\" => f.exp2(),\n-                    \"logf64\" => f.ln(),\n-                    \"log10f64\" => f.log10(),\n-                    \"log2f64\" => f.log2(),\n-                    \"floorf64\" => f.floor(),\n-                    \"ceilf64\" => f.ceil(),\n-                    \"truncf64\" => f.trunc(),\n-                    _ => bug!(),\n-                };\n-                self.write_primval(dest, PrimVal::from_f64(f), dest_ty)?;\n-            }\n-\n-            \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n-                let ty = substs.type_at(0);\n-                let a = self.value_to_primval(args[0])?;\n-                let b = self.value_to_primval(args[1])?;\n-                let op = match intrinsic_name {\n-                    \"fadd_fast\" => mir::BinOp::Add,\n-                    \"fsub_fast\" => mir::BinOp::Sub,\n-                    \"fmul_fast\" => mir::BinOp::Mul,\n-                    \"fdiv_fast\" => mir::BinOp::Div,\n-                    \"frem_fast\" => mir::BinOp::Rem,\n-                    _ => bug!(),\n-                };\n-                let result = self.binary_op(op, a, ty, b, ty)?;\n-                self.write_primval(dest, result.0, dest_ty)?;\n-            }\n-\n-            \"likely\" | \"unlikely\" | \"forget\" => {}\n-\n-            \"init\" => {\n-                let size = self.type_size(dest_ty)?.expect(\"cannot zero unsized value\");\n-                let init = |this: &mut Self, val: Value| {\n-                    let zero_val = match val {\n-                        Value::ByRef(PtrAndAlign { ptr, .. }) => {\n-                            // These writes have no alignment restriction anyway.\n-                            this.memory.write_repeat(ptr, 0, size)?;\n-                            val\n-                        }\n-                        // TODO(solson): Revisit this, it's fishy to check for Undef here.\n-                        Value::ByVal(PrimVal::Undef) => {\n-                            match this.ty_to_primval_kind(dest_ty) {\n-                                Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n-                                Err(_) => {\n-                                    let ptr = this.alloc_ptr_with_substs(dest_ty, substs)?;\n-                                    let ptr = Pointer::from(PrimVal::Ptr(ptr));\n-                                    this.memory.write_repeat(ptr, 0, size)?;\n-                                    Value::by_ref(ptr)\n-                                }\n-                            }\n-                        }\n-                        Value::ByVal(_) => Value::ByVal(PrimVal::Bytes(0)),\n-                        Value::ByValPair(..) => {\n-                            Value::ByValPair(PrimVal::Bytes(0), PrimVal::Bytes(0))\n-                        }\n-                    };\n-                    Ok(zero_val)\n-                };\n-                match dest {\n-                    Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n-                    Lvalue::Ptr {\n-                        ptr: PtrAndAlign { ptr, aligned: true },\n-                        extra: LvalueExtra::None,\n-                    } => self.memory.write_repeat(ptr, 0, size)?,\n-                    Lvalue::Ptr { .. } => {\n-                        bug!(\"init intrinsic tried to write to fat or unaligned ptr target\")\n-                    }\n-                }\n-            }\n-\n-            \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_align = self.type_align(elem_ty)?;\n-                let align_val = PrimVal::from_u128(elem_align as u128);\n-                self.write_primval(dest, align_val, dest_ty)?;\n-            }\n-\n-            \"pref_align_of\" => {\n-                let ty = substs.type_at(0);\n-                let layout = self.type_layout(ty)?;\n-                let align = layout.align(&self.tcx.data_layout).pref();\n-                let align_val = PrimVal::from_u128(align as u128);\n-                self.write_primval(dest, align_val, dest_ty)?;\n-            }\n-\n-            \"move_val_init\" => {\n-                let ty = substs.type_at(0);\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                self.write_value_to_ptr(args[1].value, ptr, ty)?;\n-            }\n-\n-            \"needs_drop\" => {\n-                let ty = substs.type_at(0);\n-                let env = ty::ParamEnv::empty(Reveal::All);\n-                let needs_drop = ty.needs_drop(self.tcx, env);\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_bool(needs_drop),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"offset\" => {\n-                let offset = self.value_to_primval(args[1])?.to_i128()? as i64;\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n-                self.write_ptr(dest, result_ptr, dest_ty)?;\n-            }\n-\n-            \"overflowing_sub\" => {\n-                self.intrinsic_overflowing(\n-                    mir::BinOp::Sub,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"overflowing_mul\" => {\n-                self.intrinsic_overflowing(\n-                    mir::BinOp::Mul,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"overflowing_add\" => {\n-                self.intrinsic_overflowing(\n-                    mir::BinOp::Add,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"powf32\" => {\n-                let f = self.value_to_primval(args[0])?.to_f32()?;\n-                let f2 = self.value_to_primval(args[1])?.to_f32()?;\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_f32(f.powf(f2)),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"powf64\" => {\n-                let f = self.value_to_primval(args[0])?.to_f64()?;\n-                let f2 = self.value_to_primval(args[1])?.to_f64()?;\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_f64(f.powf(f2)),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"fmaf32\" => {\n-                let a = self.value_to_primval(args[0])?.to_f32()?;\n-                let b = self.value_to_primval(args[1])?.to_f32()?;\n-                let c = self.value_to_primval(args[2])?.to_f32()?;\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_f32(a * b + c),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"fmaf64\" => {\n-                let a = self.value_to_primval(args[0])?.to_f64()?;\n-                let b = self.value_to_primval(args[1])?.to_f64()?;\n-                let c = self.value_to_primval(args[2])?.to_f64()?;\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_f64(a * b + c),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"powif32\" => {\n-                let f = self.value_to_primval(args[0])?.to_f32()?;\n-                let i = self.value_to_primval(args[1])?.to_i128()?;\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_f32(f.powi(i as i32)),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"powif64\" => {\n-                let f = self.value_to_primval(args[0])?.to_f64()?;\n-                let i = self.value_to_primval(args[1])?.to_i128()?;\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_f64(f.powi(i as i32)),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"size_of\" => {\n-                let ty = substs.type_at(0);\n-                let size = self.type_size(ty)?.expect(\n-                    \"size_of intrinsic called on unsized value\",\n-                ) as u128;\n-                self.write_primval(dest, PrimVal::from_u128(size), dest_ty)?;\n-            }\n-\n-            \"size_of_val\" => {\n-                let ty = substs.type_at(0);\n-                let (size, _) = self.size_and_align_of_dst(ty, args[0].value)?;\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_u128(size as u128),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"min_align_of_val\" |\n-            \"align_of_val\" => {\n-                let ty = substs.type_at(0);\n-                let (_, align) = self.size_and_align_of_dst(ty, args[0].value)?;\n-                self.write_primval(\n-                    dest,\n-                    PrimVal::from_u128(align as u128),\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"type_name\" => {\n-                let ty = substs.type_at(0);\n-                let ty_name = ty.to_string();\n-                let value = self.str_to_value(&ty_name)?;\n-                self.write_value(ValTy { value, ty: dest_ty }, dest)?;\n-            }\n-            \"type_id\" => {\n-                let ty = substs.type_at(0);\n-                let n = self.tcx.type_id_hash(ty);\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n-            }\n-\n-            \"transmute\" => {\n-                let src_ty = substs.type_at(0);\n-                let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.write_maybe_aligned_mut(\n-                    /*aligned*/\n-                    false,\n-                    |ectx| {\n-                        ectx.write_value_to_ptr(args[0].value, ptr.into(), src_ty)\n-                    },\n-                )?;\n-            }\n-\n-            \"unchecked_shl\" => {\n-                let bits = self.type_size(dest_ty)?.expect(\n-                    \"intrinsic can't be called on unsized type\",\n-                ) as u128 * 8;\n-                let rhs = self.value_to_primval(args[1])?\n-                    .to_bytes()?;\n-                if rhs >= bits {\n-                    return err!(Intrinsic(\n-                        format!(\"Overflowing shift by {} in unchecked_shl\", rhs),\n-                    ));\n-                }\n-                self.intrinsic_overflowing(\n-                    mir::BinOp::Shl,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"unchecked_shr\" => {\n-                let bits = self.type_size(dest_ty)?.expect(\n-                    \"intrinsic can't be called on unsized type\",\n-                ) as u128 * 8;\n-                let rhs = self.value_to_primval(args[1])?\n-                    .to_bytes()?;\n-                if rhs >= bits {\n-                    return err!(Intrinsic(\n-                        format!(\"Overflowing shift by {} in unchecked_shr\", rhs),\n-                    ));\n-                }\n-                self.intrinsic_overflowing(\n-                    mir::BinOp::Shr,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"unchecked_div\" => {\n-                let rhs = self.value_to_primval(args[1])?\n-                    .to_bytes()?;\n-                if rhs == 0 {\n-                    return err!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n-                }\n-                self.intrinsic_overflowing(\n-                    mir::BinOp::Div,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"unchecked_rem\" => {\n-                let rhs = self.value_to_primval(args[1])?\n-                    .to_bytes()?;\n-                if rhs == 0 {\n-                    return err!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n-                }\n-                self.intrinsic_overflowing(\n-                    mir::BinOp::Rem,\n-                    args[0],\n-                    args[1],\n-                    dest,\n-                    dest_ty,\n-                )?;\n-            }\n-\n-            \"uninit\" => {\n-                let size = dest_layout.size(&self.tcx.data_layout).bytes();\n-                let uninit = |this: &mut Self, val: Value| match val {\n-                    Value::ByRef(PtrAndAlign { ptr, .. }) => {\n-                        this.memory.mark_definedness(ptr, size, false)?;\n-                        Ok(val)\n-                    }\n-                    _ => Ok(Value::ByVal(PrimVal::Undef)),\n-                };\n-                match dest {\n-                    Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n-                    Lvalue::Ptr {\n-                        ptr: PtrAndAlign { ptr, aligned: true },\n-                        extra: LvalueExtra::None,\n-                    } => self.memory.mark_definedness(ptr, size, false)?,\n-                    Lvalue::Ptr { .. } => {\n-                        bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\")\n-                    }\n-                }\n-            }\n-\n-            \"write_bytes\" => {\n-                let ty = substs.type_at(0);\n-                let ty_align = self.type_align(ty)?;\n-                let val_byte = self.value_to_primval(args[1])?.to_u128()? as u8;\n-                let size = self.type_size(ty)?.expect(\n-                    \"write_bytes() type must be sized\",\n-                );\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let count = self.value_to_primval(args[2])?.to_u64()?;\n-                if count > 0 {\n-                    // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n-                    // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n-                    self.memory.check_align(ptr, ty_align, Some(AccessKind::Write))?;\n-                    self.memory.write_repeat(ptr, val_byte, size * count)?;\n-                }\n-            }\n-\n-            name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n-        }\n-\n-        self.goto_block(target);\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        Ok(())\n-    }\n-}\n-\n-fn numeric_intrinsic<'tcx>(\n-    name: &str,\n-    bytes: u128,\n-    kind: PrimValKind,\n-) -> EvalResult<'tcx, PrimVal> {\n-    macro_rules! integer_intrinsic {\n-        ($method:ident) => ({\n-            use rustc_miri::interpret::PrimValKind::*;\n-            let result_bytes = match kind {\n-                I8 => (bytes as i8).$method() as u128,\n-                U8 => (bytes as u8).$method() as u128,\n-                I16 => (bytes as i16).$method() as u128,\n-                U16 => (bytes as u16).$method() as u128,\n-                I32 => (bytes as i32).$method() as u128,\n-                U32 => (bytes as u32).$method() as u128,\n-                I64 => (bytes as i64).$method() as u128,\n-                U64 => (bytes as u64).$method() as u128,\n-                I128 => (bytes as i128).$method() as u128,\n-                U128 => bytes.$method() as u128,\n-                _ => bug!(\"invalid `{}` argument: {:?}\", name, bytes),\n-            };\n-\n-            PrimVal::Bytes(result_bytes)\n-        });\n-    }\n-\n-    let result_val = match name {\n-        \"bswap\" => integer_intrinsic!(swap_bytes),\n-        \"ctlz\" => integer_intrinsic!(leading_zeros),\n-        \"ctpop\" => integer_intrinsic!(count_ones),\n-        \"cttz\" => integer_intrinsic!(trailing_zeros),\n-        _ => bug!(\"not a numeric intrinsic: {}\", name),\n-    };\n-\n-    Ok(result_val)\n-}"}, {"sha": "f6ecd6e0b00b71690991bb60d35e814686cc354c", "filename": "miri/lib.rs", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,311 +0,0 @@\n-#![feature(\n-    i128_type,\n-    rustc_private,\n-)]\n-\n-// From rustc.\n-#[macro_use]\n-extern crate log;\n-#[macro_use]\n-extern crate rustc;\n-extern crate syntax;\n-\n-use rustc::ty::{self, TyCtxt};\n-use rustc::ty::layout::Layout;\n-use rustc::hir::def_id::DefId;\n-use rustc::mir;\n-\n-use syntax::ast::Mutability;\n-use syntax::codemap::Span;\n-\n-use std::collections::{HashMap, BTreeMap};\n-\n-#[macro_use]\n-extern crate rustc_miri;\n-pub use rustc_miri::interpret::*;\n-\n-mod fn_call;\n-mod operator;\n-mod intrinsic;\n-mod helpers;\n-mod memory;\n-mod tls;\n-\n-use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n-use operator::EvalContextExt as OperatorEvalContextExt;\n-use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n-use tls::EvalContextExt as TlsEvalContextExt;\n-\n-pub fn eval_main<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    main_id: DefId,\n-    start_wrapper: Option<DefId>,\n-    limits: ResourceLimits,\n-) {\n-    fn run_main<'a, 'tcx: 'a>(\n-        ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Evaluator>,\n-        main_id: DefId,\n-        start_wrapper: Option<DefId>,\n-    ) -> EvalResult<'tcx> {\n-        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n-        let main_mir = ecx.load_mir(main_instance.def)?;\n-        let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n-\n-        if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n-            return err!(Unimplemented(\n-                \"miri does not support main functions without `fn()` type signatures\"\n-                    .to_owned(),\n-            ));\n-        }\n-\n-        if let Some(start_id) = start_wrapper {\n-            let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n-            let start_mir = ecx.load_mir(start_instance.def)?;\n-\n-            if start_mir.arg_count != 3 {\n-                return err!(AbiViolation(format!(\n-                    \"'start' lang item should have three arguments, but has {}\",\n-                    start_mir.arg_count\n-                )));\n-            }\n-\n-            // Return value\n-            let size = ecx.tcx.data_layout.pointer_size.bytes();\n-            let align = ecx.tcx.data_layout.pointer_align.abi();\n-            let ret_ptr = ecx.memory_mut().allocate(size, align, MemoryKind::Stack)?;\n-            cleanup_ptr = Some(ret_ptr);\n-\n-            // Push our stack frame\n-            ecx.push_stack_frame(\n-                start_instance,\n-                start_mir.span,\n-                start_mir,\n-                Lvalue::from_ptr(ret_ptr),\n-                StackPopCleanup::None,\n-            )?;\n-\n-            let mut args = ecx.frame().mir.args_iter();\n-\n-            // First argument: pointer to main()\n-            let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let main_ty = main_instance.def.def_ty(ecx.tcx);\n-            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n-            ecx.write_value(\n-                ValTy {\n-                    value: Value::ByVal(PrimVal::Ptr(main_ptr)),\n-                    ty: main_ptr_ty,\n-                },\n-                dest,\n-            )?;\n-\n-            // Second argument (argc): 1\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.types.isize;\n-            ecx.write_primval(dest, PrimVal::Bytes(1), ty)?;\n-\n-            // FIXME: extract main source file path\n-            // Third argument (argv): &[b\"foo\"]\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n-            let foo = ecx.memory.allocate_cached(b\"foo\\0\")?;\n-            let ptr_size = ecx.memory.pointer_size();\n-            let foo_ptr = ecx.memory.allocate(ptr_size * 1, ptr_size, MemoryKind::UninitializedStatic)?;\n-            ecx.memory.write_primval(foo_ptr.into(), PrimVal::Ptr(foo.into()), ptr_size, false)?;\n-            ecx.memory.mark_static_initalized(foo_ptr.alloc_id, Mutability::Immutable)?;\n-            ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n-\n-            assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n-        } else {\n-            ecx.push_stack_frame(\n-                main_instance,\n-                main_mir.span,\n-                main_mir,\n-                Lvalue::undef(),\n-                StackPopCleanup::None,\n-            )?;\n-\n-            // No arguments\n-            let mut args = ecx.frame().mir.args_iter();\n-            assert!(args.next().is_none(), \"main function must not have arguments\");\n-        }\n-\n-        while ecx.step()? {}\n-        ecx.run_tls_dtors()?;\n-        if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory_mut().deallocate(\n-                cleanup_ptr,\n-                None,\n-                MemoryKind::Stack,\n-            )?;\n-        }\n-        Ok(())\n-    }\n-\n-    let mut ecx = EvalContext::new(tcx, limits, Default::default(), Default::default());\n-    match run_main(&mut ecx, main_id, start_wrapper) {\n-        Ok(()) => {\n-            let leaks = ecx.memory().leak_report();\n-            if leaks != 0 {\n-                tcx.sess.err(\"the evaluated program leaked memory\");\n-            }\n-        }\n-        Err(mut e) => {\n-            ecx.report(&mut e);\n-        }\n-    }\n-}\n-\n-pub struct Evaluator;\n-#[derive(Default)]\n-pub struct EvaluatorData {\n-    /// Environment variables set by `setenv`\n-    /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n-}\n-\n-pub type TlsKey = usize;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct TlsEntry<'tcx> {\n-    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n-    dtor: Option<ty::Instance<'tcx>>,\n-}\n-\n-#[derive(Default)]\n-pub struct MemoryData<'tcx> {\n-    /// The Key to use for the next thread-local allocation.\n-    next_thread_local: TlsKey,\n-\n-    /// pthreads-style thread-local storage.\n-    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n-}\n-\n-impl<'tcx> Machine<'tcx> for Evaluator {\n-    type Data = EvaluatorData;\n-    type MemoryData = MemoryData<'tcx>;\n-    type MemoryKinds = memory::MemoryKind;\n-\n-    /// Returns Ok() when the function was handled, fail otherwise\n-    fn eval_fn_call<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n-        span: Span,\n-        sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        ecx.eval_fn_call(instance, destination, args, span, sig)\n-    }\n-\n-    fn call_intrinsic<'a>(\n-        ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        args: &[ValTy<'tcx>],\n-        dest: Lvalue,\n-        dest_ty: ty::Ty<'tcx>,\n-        dest_layout: &'tcx Layout,\n-        target: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        ecx.call_intrinsic(instance, args, dest, dest_ty, dest_layout, target)\n-    }\n-\n-    fn try_ptr_op<'a>(\n-        ecx: &rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n-        bin_op: mir::BinOp,\n-        left: PrimVal,\n-        left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n-        right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n-        ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n-    }\n-\n-    fn mark_static_initialized(m: memory::MemoryKind) -> EvalResult<'tcx> {\n-        use memory::MemoryKind::*;\n-        match m {\n-            // FIXME: This could be allowed, but not for env vars set during miri execution\n-            Env => err!(Unimplemented(\"statics can't refer to env vars\".to_owned())),\n-            _ => Ok(()),\n-        }\n-    }\n-\n-    fn box_alloc<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        ty: ty::Ty<'tcx>,\n-        dest: Lvalue,\n-    ) -> EvalResult<'tcx> {\n-        let size = ecx.type_size(ty)?.expect(\"box only works with sized types\");\n-        let align = ecx.type_align(ty)?;\n-\n-        // Call the `exchange_malloc` lang item\n-        let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n-        let malloc = ty::Instance::mono(ecx.tcx, malloc);\n-        let malloc_mir = ecx.load_mir(malloc.def)?;\n-        ecx.push_stack_frame(\n-            malloc,\n-            malloc_mir.span,\n-            malloc_mir,\n-            dest,\n-            // Don't do anything when we are done.  The statement() function will increment\n-            // the old stack frame's stmt counter to the next statement, which means that when\n-            // exchange_malloc returns, we go on evaluating exactly where we want to be.\n-            StackPopCleanup::None,\n-        )?;\n-\n-        let mut args = ecx.frame().mir.args_iter();\n-        let usize = ecx.tcx.types.usize;\n-\n-        // First argument: size\n-        let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-        ecx.write_value(\n-            ValTy {\n-                value: Value::ByVal(PrimVal::Bytes(size as u128)),\n-                ty: usize,\n-            },\n-            dest,\n-        )?;\n-\n-        // Second argument: align\n-        let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-        ecx.write_value(\n-            ValTy {\n-                value: Value::ByVal(PrimVal::Bytes(align as u128)),\n-                ty: usize,\n-            },\n-            dest,\n-        )?;\n-\n-        // No more arguments\n-        assert!(args.next().is_none(), \"exchange_malloc lang item has more arguments than expected\");\n-        Ok(())\n-    }\n-\n-    fn global_item_with_linkage<'a>(\n-        ecx: &mut EvalContext<'a, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        mutability: Mutability,\n-    ) -> EvalResult<'tcx> {\n-        // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n-        trace!(\"Initializing an extern global with NULL\");\n-        let ptr_size = ecx.memory.pointer_size();\n-        let ptr = ecx.memory.allocate(\n-            ptr_size,\n-            ptr_size,\n-            MemoryKind::UninitializedStatic,\n-        )?;\n-        ecx.memory.write_ptr_sized_unsigned(ptr, PrimVal::Bytes(0))?;\n-        ecx.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n-        ecx.globals.insert(\n-            GlobalId {\n-                instance,\n-                promoted: None,\n-            },\n-            PtrAndAlign {\n-                ptr: ptr.into(),\n-                aligned: true,\n-            },\n-        );\n-        Ok(())\n-    }\n-}"}, {"sha": "110540c0cf1d2555c7e9436ae3ffb7d7272d3f17", "filename": "miri/memory.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fmemory.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-\n-#[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum MemoryKind {\n-    /// Error if deallocated any other way than `rust_deallocate`\n-    Rust,\n-    /// Error if deallocated any other way than `free`\n-    C,\n-    /// Part of env var emulation\n-    Env,\n-}\n-\n-impl Into<::rustc_miri::interpret::MemoryKind<MemoryKind>> for MemoryKind {\n-    fn into(self) -> ::rustc_miri::interpret::MemoryKind<MemoryKind> {\n-        ::rustc_miri::interpret::MemoryKind::Machine(self)\n-    }\n-}"}, {"sha": "6d68aadf96cc724b3dd3201fa01f00510c56dc1a", "filename": "miri/operator.rs", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Foperator.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,175 +0,0 @@\n-use rustc::ty;\n-use rustc::mir;\n-\n-use rustc_miri::interpret::*;\n-\n-use helpers::EvalContextExt as HelperEvalContextExt;\n-\n-pub trait EvalContextExt<'tcx> {\n-    fn ptr_op(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: PrimVal,\n-        left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n-        right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n-\n-    fn ptr_int_arithmetic(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: MemoryPointer,\n-        right: i128,\n-        signed: bool,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)>;\n-}\n-\n-impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n-    fn ptr_op(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: PrimVal,\n-        left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n-        right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n-        use rustc_miri::interpret::PrimValKind::*;\n-        use rustc::mir::BinOp::*;\n-        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n-        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n-        let left_kind = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n-        match bin_op {\n-            Offset if left_kind == Ptr && right_kind == usize => {\n-                let pointee_ty = left_ty\n-                    .builtin_deref(true, ty::LvaluePreference::NoPreference)\n-                    .expect(\"Offset called on non-ptr type\")\n-                    .ty;\n-                let ptr = self.pointer_offset(\n-                    left.into(),\n-                    pointee_ty,\n-                    right.to_bytes()? as i64,\n-                )?;\n-                Ok(Some((ptr.into_inner_primval(), false)))\n-            }\n-            // These work on anything\n-            Eq if left_kind == right_kind => {\n-                let result = match (left, right) {\n-                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n-                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n-                    (PrimVal::Undef, _) |\n-                    (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n-                    _ => false,\n-                };\n-                Ok(Some((PrimVal::from_bool(result), false)))\n-            }\n-            Ne if left_kind == right_kind => {\n-                let result = match (left, right) {\n-                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n-                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n-                    (PrimVal::Undef, _) |\n-                    (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n-                    _ => true,\n-                };\n-                Ok(Some((PrimVal::from_bool(result), false)))\n-            }\n-            // These need both pointers to be in the same allocation\n-            Lt | Le | Gt | Ge | Sub\n-                if left_kind == right_kind &&\n-                       (left_kind == Ptr || left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_ptr() => {\n-                let left = left.to_ptr()?;\n-                let right = right.to_ptr()?;\n-                if left.alloc_id == right.alloc_id {\n-                    let res = match bin_op {\n-                        Lt => left.offset < right.offset,\n-                        Le => left.offset <= right.offset,\n-                        Gt => left.offset > right.offset,\n-                        Ge => left.offset >= right.offset,\n-                        Sub => {\n-                            return self.binary_op(\n-                                Sub,\n-                                PrimVal::Bytes(left.offset as u128),\n-                                self.tcx.types.usize,\n-                                PrimVal::Bytes(right.offset as u128),\n-                                self.tcx.types.usize,\n-                            ).map(Some)\n-                        }\n-                        _ => bug!(\"We already established it has to be one of these operators.\"),\n-                    };\n-                    Ok(Some((PrimVal::from_bool(res), false)))\n-                } else {\n-                    // Both are pointers, but from different allocations.\n-                    err!(InvalidPointerMath)\n-                }\n-            }\n-            // These work if one operand is a pointer, the other an integer\n-            Add | BitAnd | Sub\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_bytes() => {\n-                // Cast to i128 is fine as we checked the kind to be ptr-sized\n-                self.ptr_int_arithmetic(\n-                    bin_op,\n-                    left.to_ptr()?,\n-                    right.to_bytes()? as i128,\n-                    left_kind == isize,\n-                ).map(Some)\n-            }\n-            Add | BitAnd\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_bytes() && right.is_ptr() => {\n-                // This is a commutative operation, just swap the operands\n-                self.ptr_int_arithmetic(\n-                    bin_op,\n-                    right.to_ptr()?,\n-                    left.to_bytes()? as i128,\n-                    left_kind == isize,\n-                ).map(Some)\n-            }\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    fn ptr_int_arithmetic(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: MemoryPointer,\n-        right: i128,\n-        signed: bool,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        use rustc::mir::BinOp::*;\n-\n-        fn map_to_primval((res, over): (MemoryPointer, bool)) -> (PrimVal, bool) {\n-            (PrimVal::Ptr(res), over)\n-        }\n-\n-        Ok(match bin_op {\n-            Sub =>\n-                // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n-                map_to_primval(left.overflowing_signed_offset(-right, self)),\n-            Add if signed =>\n-                map_to_primval(left.overflowing_signed_offset(right, self)),\n-            Add if !signed =>\n-                map_to_primval(left.overflowing_offset(right as u64, self)),\n-\n-            BitAnd if !signed => {\n-                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n-                let right = right as u64;\n-                if right & base_mask == base_mask {\n-                    // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n-                } else if right & base_mask == 0 {\n-                    // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n-                    (PrimVal::from_u128((left.offset & right) as u128), false)\n-                } else {\n-                    return err!(ReadPointerAsBytes);\n-                }\n-            }\n-\n-            _ => {\n-                let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n-                return err!(Unimplemented(msg));\n-            }\n-        })\n-    }\n-}"}, {"sha": "e592478f6f9e69fa6cd1b1bea8deccfe1eb914b5", "filename": "miri/tls.rs", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/miri%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ftls.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,142 +0,0 @@\n-use rustc::{ty, mir};\n-\n-use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Pointer, Memory, Evaluator, Lvalue,\n-            StackPopCleanup, EvalContext};\n-\n-pub trait MemoryExt<'tcx> {\n-    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n-    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer>;\n-    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx>;\n-    fn fetch_tls_dtor(\n-        &mut self,\n-        key: Option<TlsKey>,\n-    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n-}\n-\n-pub trait EvalContextExt<'tcx> {\n-    fn run_tls_dtors(&mut self) -> EvalResult<'tcx>;\n-}\n-\n-impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n-    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n-        let new_key = self.data.next_thread_local;\n-        self.data.next_thread_local += 1;\n-        self.data.thread_local.insert(\n-            new_key,\n-            TlsEntry {\n-                data: Pointer::null(),\n-                dtor,\n-            },\n-        );\n-        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n-        return new_key;\n-    }\n-\n-    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.remove(&key) {\n-            Some(_) => {\n-                trace!(\"TLS key {} removed\", key);\n-                Ok(())\n-            }\n-            None => err!(TlsOutOfBounds),\n-        };\n-    }\n-\n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n-        return match self.data.thread_local.get(&key) {\n-            Some(&TlsEntry { data, .. }) => {\n-                trace!(\"TLS key {} loaded: {:?}\", key, data);\n-                Ok(data)\n-            }\n-            None => err!(TlsOutOfBounds),\n-        };\n-    }\n-\n-    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n-        return match self.data.thread_local.get_mut(&key) {\n-            Some(&mut TlsEntry { ref mut data, .. }) => {\n-                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n-                *data = new_data;\n-                Ok(())\n-            }\n-            None => err!(TlsOutOfBounds),\n-        };\n-    }\n-\n-    /// Returns a dtor, its argument and its index, if one is supposed to run\n-    ///\n-    /// An optional destructor function may be associated with each key value.\n-    /// At thread exit, if a key value has a non-NULL destructor pointer,\n-    /// and the thread has a non-NULL value associated with that key,\n-    /// the value of the key is set to NULL, and then the function pointed\n-    /// to is called with the previously associated value as its sole argument.\n-    /// The order of destructor calls is unspecified if more than one destructor\n-    /// exists for a thread when it exits.\n-    ///\n-    /// If, after all the destructors have been called for all non-NULL values\n-    /// with associated destructors, there are still some non-NULL values with\n-    /// associated destructors, then the process is repeated.\n-    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n-    /// calls for outstanding non-NULL values, there are still some non-NULL values\n-    /// with associated destructors, implementations may stop calling destructors,\n-    /// or they may continue calling destructors until no non-NULL values with\n-    /// associated destructors exist, even though this might result in an infinite loop.\n-    fn fetch_tls_dtor(\n-        &mut self,\n-        key: Option<TlsKey>,\n-    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n-        use std::collections::Bound::*;\n-        let start = match key {\n-            Some(key) => Excluded(key),\n-            None => Unbounded,\n-        };\n-        for (&key, &mut TlsEntry { ref mut data, dtor }) in\n-            self.data.thread_local.range_mut((start, Unbounded))\n-        {\n-            if !data.is_null()? {\n-                if let Some(dtor) = dtor {\n-                    let ret = Some((dtor, *data, key));\n-                    *data = Pointer::null();\n-                    return Ok(ret);\n-                }\n-            }\n-        }\n-        return Ok(None);\n-    }\n-}\n-\n-impl<'a, 'tcx: 'a> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n-    fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n-        let mut dtor = self.memory.fetch_tls_dtor(None)?;\n-        // FIXME: replace loop by some structure that works with stepping\n-        while let Some((instance, ptr, key)) = dtor {\n-            trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n-            // TODO: Potentially, this has to support all the other possible instances?\n-            // See eval_fn_call in interpret/terminator/mod.rs\n-            let mir = self.load_mir(instance.def)?;\n-            self.push_stack_frame(\n-                instance,\n-                mir.span,\n-                mir,\n-                Lvalue::undef(),\n-                StackPopCleanup::None,\n-            )?;\n-            let arg_local = self.frame().mir.args_iter().next().ok_or(\n-                EvalErrorKind::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n-            )?;\n-            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-            let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-            self.write_ptr(dest, ptr, ty)?;\n-\n-            // step until out of stackframes\n-            while self.step()? {}\n-\n-            dtor = match self.memory.fetch_tls_dtor(Some(key))? {\n-                dtor @ Some(_) => dtor,\n-                None => self.memory.fetch_tls_dtor(None)?,\n-            };\n-        }\n-        Ok(())\n-    }\n-}"}, {"sha": "a1e273a96bdb8a21440f880d2b27d3e402ae69f9", "filename": "rustc_tests/Cargo.lock", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/rustc_tests%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/rustc_tests%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2FCargo.lock?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,217 +0,0 @@\n-[root]\n-name = \"rustc_tests\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"miri 0.1.0\",\n-]\n-\n-[[package]]\n-name = \"aho-corasick\"\n-version = \"0.6.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"backtrace\"\n-version = \"0.3.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"backtrace-sys\"\n-version = \"0.1.12\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"byteorder\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"dbghelp-sys\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"env_logger\"\n-version = \"0.4.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"gcc\"\n-version = \"0.3.53\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"kernel32-sys\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"lazy_static\"\n-version = \"0.2.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"libc\"\n-version = \"0.2.30\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"log\"\n-version = \"0.3.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"log_settings\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"memchr\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"miri\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_miri 0.1.0\",\n-]\n-\n-[[package]]\n-name = \"regex\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"regex-syntax\"\n-version = \"0.4.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"rustc-demangle\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"rustc_miri\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"thread_local\"\n-version = \"0.3.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"unreachable\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"utf8-ranges\"\n-version = \"1.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"void\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi\"\n-version = \"0.2.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[metadata]\n-\"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n-\"checksum backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99f2ce94e22b8e664d95c57fff45b98a966c2252b60691d0b7aeeccd88d70983\"\n-\"checksum backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afccc5772ba333abccdf60d55200fa3406f8c59dcf54d5f7998c9107d3799c7c\"\n-\"checksum byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff81738b726f5d099632ceaffe7fb65b90212e8dce59d518729e7e8634032d3d\"\n-\"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n-\"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n-\"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n-\"checksum gcc 0.3.53 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8310f7e9c890398b0e80e301c4f474e9918d2b27fca8f48486ca775fa9ffc5a\"\n-\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n-\"checksum libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2370ca07ec338939e356443dac2296f581453c35fe1e3a3ed06023c49435f915\"\n-\"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n-\"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n-\"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n-\"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n-\"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n-\"checksum rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aee45432acc62f7b9a108cc054142dac51f979e69e71ddce7d6fc7adf29e817e\"\n-\"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\"\n-\"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n-\"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n-\"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n-\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n-\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "736f0629768f28cee37b812a3071ed2dedf7befa", "filename": "rustc_tests/Cargo.toml", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/rustc_tests%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/rustc_tests%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2FCargo.toml?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-[package]\n-name = \"rustc_tests\"\n-version = \"0.1.0\"\n-authors = [\"Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\"]\n-\n-[dependencies]\n-miri = { path = \"..\" }"}, {"sha": "819721c1cd0f990158a58af89f6321ea274ed751", "filename": "rustc_tests/src/main.rs", "status": "removed", "additions": 0, "deletions": 292, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/rustc_tests%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/rustc_tests%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2Fsrc%2Fmain.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,292 +0,0 @@\n-#![feature(rustc_private, i128_type)]\n-extern crate miri;\n-extern crate getopts;\n-extern crate rustc;\n-extern crate rustc_driver;\n-extern crate rustc_errors;\n-extern crate syntax;\n-\n-use std::path::{PathBuf, Path};\n-use std::io::Write;\n-use std::sync::{Mutex, Arc};\n-use std::io;\n-\n-\n-use rustc::session::Session;\n-use rustc::middle::cstore::CrateStore;\n-use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n-use rustc_driver::driver::{CompileState, CompileController};\n-use rustc::session::config::{self, Input, ErrorOutputType};\n-use rustc::hir::{self, itemlikevisit};\n-use rustc::ty::TyCtxt;\n-use syntax::ast;\n-\n-struct MiriCompilerCalls {\n-    default: RustcDefaultCalls,\n-    /// whether we are building for the host\n-    host_target: bool,\n-}\n-\n-impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n-    fn early_callback(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        descriptions: &rustc_errors::registry::Registry,\n-        output: ErrorOutputType\n-    ) -> Compilation {\n-        self.default.early_callback(matches, sopts, cfg, descriptions, output)\n-    }\n-    fn no_input(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        descriptions: &rustc_errors::registry::Registry\n-    ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n-    }\n-    fn late_callback(\n-        &mut self,\n-        matches: &getopts::Matches,\n-        sess: &Session,\n-        cstore: &CrateStore,\n-        input: &Input,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>\n-    ) -> Compilation {\n-        self.default.late_callback(matches, sess, cstore, input, odir, ofile)\n-    }\n-    fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n-        let mut control = self.default.build_controller(sess, matches);\n-        control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        control.after_analysis.callback = Box::new(after_analysis);\n-        if !self.host_target {\n-            // only fully compile targets on the host\n-            control.after_analysis.stop = Compilation::Stop;\n-        }\n-        control\n-    }\n-}\n-\n-fn after_hir_lowering(state: &mut CompileState) {\n-    let attr = (String::from(\"miri\"), syntax::feature_gate::AttributeType::Whitelisted);\n-    state.session.plugin_attributes.borrow_mut().push(attr);\n-}\n-\n-fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n-    state.session.abort_if_errors();\n-\n-    let tcx = state.tcx.unwrap();\n-    let limits = Default::default();\n-\n-    if std::env::args().any(|arg| arg == \"--test\") {\n-        struct Visitor<'a, 'tcx: 'a>(miri::ResourceLimits, TyCtxt<'a, 'tcx, 'tcx>, &'a CompileState<'a, 'tcx>);\n-        impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n-            fn visit_item(&mut self, i: &'hir hir::Item) {\n-                if let hir::Item_::ItemFn(_, _, _, _, _, body_id) = i.node {\n-                    if i.attrs.iter().any(|attr| attr.name().map_or(false, |n| n == \"test\")) {\n-                        let did = self.1.hir.body_owner_def_id(body_id);\n-                        println!(\"running test: {}\", self.1.hir.def_path(did).to_string(self.1));\n-                        miri::eval_main(self.1, did, None, self.0);\n-                        self.2.session.abort_if_errors();\n-                    }\n-                }\n-            }\n-            fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n-            fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n-        }\n-        state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(limits, tcx, state));\n-    } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n-        let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        let start_wrapper = tcx.lang_items().start_fn().and_then(|start_fn|\n-                                if tcx.is_mir_available(start_fn) { Some(start_fn) } else { None });\n-        miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n-\n-        state.session.abort_if_errors();\n-    } else {\n-        println!(\"no main function found, assuming auxiliary build\");\n-    }\n-}\n-\n-fn main() {\n-    let path = option_env!(\"MIRI_RUSTC_TEST\")\n-        .map(String::from)\n-        .unwrap_or_else(|| {\n-            std::env::var(\"MIRI_RUSTC_TEST\")\n-                .expect(\"need to set MIRI_RUSTC_TEST to path of rustc tests\")\n-        });\n-\n-    let mut mir_not_found = Vec::new();\n-    let mut crate_not_found = Vec::new();\n-    let mut success = 0;\n-    let mut failed = Vec::new();\n-    let mut c_abi_fns = Vec::new();\n-    let mut abi = Vec::new();\n-    let mut unsupported = Vec::new();\n-    let mut unimplemented_intrinsic = Vec::new();\n-    let mut limits = Vec::new();\n-    let mut files: Vec<_> = std::fs::read_dir(path).unwrap().collect();\n-    while let Some(file) = files.pop() {\n-        let file = file.unwrap();\n-        let path = file.path();\n-        if file.metadata().unwrap().is_dir() {\n-            if !path.to_str().unwrap().ends_with(\"auxiliary\") {\n-                // add subdirs recursively\n-                files.extend(std::fs::read_dir(path).unwrap());\n-            }\n-            continue;\n-        }\n-        if !file.metadata().unwrap().is_file() || !path.to_str().unwrap().ends_with(\".rs\") {\n-            continue;\n-        }\n-        let stderr = std::io::stderr();\n-        write!(stderr.lock(), \"test [miri-pass] {} ... \", path.display()).unwrap();\n-        let mut host_target = false;\n-        let mut args: Vec<String> = std::env::args().filter(|arg| {\n-            if arg == \"--miri_host_target\" {\n-                host_target = true;\n-                false // remove the flag, rustc doesn't know it\n-            } else {\n-                true\n-            }\n-        }).collect();\n-        // file to process\n-        args.push(path.display().to_string());\n-\n-        let sysroot_flag = String::from(\"--sysroot\");\n-        if !args.contains(&sysroot_flag) {\n-            args.push(sysroot_flag);\n-            args.push(Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\").display().to_string());\n-        }\n-\n-        args.push(\"-Zmir-opt-level=3\".to_owned());\n-        // for auxilary builds in unit tests\n-        args.push(\"-Zalways-encode-mir\".to_owned());\n-\n-        // A threadsafe buffer for writing.\n-        #[derive(Default, Clone)]\n-        struct BufWriter(Arc<Mutex<Vec<u8>>>);\n-\n-        impl Write for BufWriter {\n-            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-                self.0.lock().unwrap().write(buf)\n-            }\n-            fn flush(&mut self) -> io::Result<()> {\n-                self.0.lock().unwrap().flush()\n-            }\n-        }\n-        let buf = BufWriter::default();\n-        let output = buf.clone();\n-        let result = std::panic::catch_unwind(|| {\n-            rustc_driver::run_compiler(&args, &mut MiriCompilerCalls {\n-                default: RustcDefaultCalls,\n-                host_target,\n-            }, None, Some(Box::new(buf)));\n-        });\n-\n-        match result {\n-            Ok(()) => {\n-                success += 1;\n-                writeln!(stderr.lock(), \"ok\").unwrap()\n-            },\n-            Err(_) => {\n-                let output = output.0.lock().unwrap();\n-                let output_err = std::str::from_utf8(&output).unwrap();\n-                if let Some(text) = output_err.splitn(2, \"no mir for `\").nth(1) {\n-                    let end = text.find('`').unwrap();\n-                    mir_not_found.push(text[..end].to_string());\n-                    writeln!(stderr.lock(), \"NO MIR FOR `{}`\", &text[..end]).unwrap();\n-                } else if let Some(text) = output_err.splitn(2, \"can't find crate for `\").nth(1) {\n-                    let end = text.find('`').unwrap();\n-                    crate_not_found.push(text[..end].to_string());\n-                    writeln!(stderr.lock(), \"CAN'T FIND CRATE FOR `{}`\", &text[..end]).unwrap();\n-                } else {\n-                    for text in output_err.split(\"error: \").skip(1) {\n-                        let end = text.find('\\n').unwrap_or(text.len());\n-                        let c_abi = \"can't call C ABI function: \";\n-                        let unimplemented_intrinsic_s = \"unimplemented intrinsic: \";\n-                        let unsupported_s = \"miri does not support \";\n-                        let abi_s = \"can't handle function with \";\n-                        let limit_s = \"reached the configured maximum \";\n-                        if text.starts_with(c_abi) {\n-                            c_abi_fns.push(text[c_abi.len()..end].to_string());\n-                        } else if text.starts_with(unimplemented_intrinsic_s) {\n-                            unimplemented_intrinsic.push(text[unimplemented_intrinsic_s.len()..end].to_string());\n-                        } else if text.starts_with(unsupported_s) {\n-                            unsupported.push(text[unsupported_s.len()..end].to_string());\n-                        } else if text.starts_with(abi_s) {\n-                            abi.push(text[abi_s.len()..end].to_string());\n-                        } else if text.starts_with(limit_s) {\n-                            limits.push(text[limit_s.len()..end].to_string());\n-                        } else if text.find(\"aborting\").is_none() {\n-                            failed.push(text[..end].to_string());\n-                        }\n-                    }\n-                    writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n-                }\n-            }\n-        }\n-    }\n-    let stderr = std::io::stderr();\n-    let mut stderr = stderr.lock();\n-    writeln!(stderr, \"{} success, {} no mir, {} crate not found, {} failed, \\\n-                        {} C fn, {} ABI, {} unsupported, {} intrinsic\",\n-                        success, mir_not_found.len(), crate_not_found.len(), failed.len(),\n-                        c_abi_fns.len(), abi.len(), unsupported.len(), unimplemented_intrinsic.len()).unwrap();\n-    writeln!(stderr, \"# The \\\"other reasons\\\" errors\").unwrap();\n-    writeln!(stderr, \"(sorted, deduplicated)\").unwrap();\n-    print_vec(&mut stderr, failed);\n-\n-    writeln!(stderr, \"# can't call C ABI function\").unwrap();\n-    print_vec(&mut stderr, c_abi_fns);\n-\n-    writeln!(stderr, \"# unsupported ABI\").unwrap();\n-    print_vec(&mut stderr, abi);\n-\n-    writeln!(stderr, \"# unsupported\").unwrap();\n-    print_vec(&mut stderr, unsupported);\n-\n-    writeln!(stderr, \"# unimplemented intrinsics\").unwrap();\n-    print_vec(&mut stderr, unimplemented_intrinsic);\n-\n-    writeln!(stderr, \"# mir not found\").unwrap();\n-    print_vec(&mut stderr, mir_not_found);\n-\n-    writeln!(stderr, \"# crate not found\").unwrap();\n-    print_vec(&mut stderr, crate_not_found);\n-}\n-\n-fn print_vec<W: std::io::Write>(stderr: &mut W, v: Vec<String>) {\n-    writeln!(stderr, \"```\").unwrap();\n-    for (n, s) in vec_to_hist(v).into_iter().rev() {\n-        writeln!(stderr, \"{:4} {}\", n, s).unwrap();\n-    }\n-    writeln!(stderr, \"```\").unwrap();\n-}\n-\n-fn vec_to_hist<T: PartialEq + Ord>(mut v: Vec<T>) -> Vec<(usize, T)> {\n-    v.sort();\n-    let mut v = v.into_iter();\n-    let mut result = Vec::new();\n-    let mut current = v.next();\n-    'outer: while let Some(current_val) = current {\n-        let mut n = 1;\n-        for next in &mut v {\n-            if next == current_val {\n-                n += 1;\n-            } else {\n-                result.push((n, current_val));\n-                current = Some(next);\n-                continue 'outer;\n-            }\n-        }\n-        result.push((n, current_val));\n-        break;\n-    }\n-    result.sort();\n-    result\n-}"}, {"sha": "c72de828c8d2b813580d794f197bd75f251d15da", "filename": "src/librustc_mir/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,19 +0,0 @@\n-[package]\n-authors = [\"Scott Olson <scott@solson.me>\"]\n-description = \"An experimental interpreter for Rust MIR.\"\n-license = \"MIT/Apache-2.0\"\n-name = \"rustc_miri\"\n-repository = \"https://github.com/solson/miri\"\n-version = \"0.1.0\"\n-workspace = \"../..\"\n-\n-[lib]\n-path = \"lib.rs\"\n-\n-[dependencies]\n-byteorder = { version = \"1.1\", features = [\"i128\"]}\n-log = \"0.3.6\"\n-log_settings = \"0.1.1\"\n-lazy_static = \"0.2.8\"\n-regex = \"0.2.2\"\n-backtrace = \"0.3.3\""}, {"sha": "c640932e50e21953955b38c94f6bd5e83b423fa8", "filename": "src/librustc_mir/lib.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,26 +0,0 @@\n-#![feature(\n-    i128_type,\n-    rustc_private,\n-    conservative_impl_trait,\n-    never_type,\n-    catch_expr,\n-)]\n-\n-// From rustc.\n-#[macro_use]\n-extern crate log;\n-extern crate log_settings;\n-#[macro_use]\n-extern crate rustc;\n-extern crate rustc_const_math;\n-extern crate rustc_data_structures;\n-extern crate syntax;\n-\n-// From crates.io.\n-extern crate byteorder;\n-#[macro_use]\n-extern crate lazy_static;\n-extern crate regex;\n-extern crate backtrace;\n-\n-pub mod interpret;"}, {"sha": "99404b7d5f3f54e52f01b264a6cadb4008e6abfd", "filename": "tests/compile-fail-fullmir/undefined_byte_read.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail-fullmir%2Fundefined_byte_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail-fullmir%2Fundefined_byte_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fundefined_byte_read.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-// This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n-\n-fn main() {\n-    let v: Vec<u8> = Vec::with_capacity(10);\n-    let undef = unsafe { *v.get_unchecked(5) };\n-    let x = undef + 1; //~ ERROR: attempted to read undefined bytes\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "4faaa359df6244fe57a8d6c00301d735f0dfbafe", "filename": "tests/compile-fail/alignment.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Falignment.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,11 +0,0 @@\n-fn main() {\n-    // miri always gives allocations the worst possible alignment, so a `u8` array is guaranteed\n-    // to be at the virtual location 1 (so one byte offset from the ultimate alignemnt location 0)\n-    let mut x = [0u8; 20];\n-    let x_ptr: *mut u8 = &mut x[0];\n-    let y_ptr = x_ptr as *mut u64;\n-    unsafe {\n-        *y_ptr = 42; //~ ERROR tried to access memory with alignment 1, but alignment\n-    }\n-    panic!(\"unreachable in miri\");\n-}"}, {"sha": "69758a5d7fe8ceb8082ab9fbd5e9d7f9606f31e9", "filename": "tests/compile-fail/assume.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fassume.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fassume.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fassume.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-#![feature(core_intrinsics)]\n-\n-fn main() {\n-    let x = 5;\n-    unsafe {\n-        std::intrinsics::assume(x < 10);\n-        std::intrinsics::assume(x > 1);\n-        std::intrinsics::assume(x > 42); //~ ERROR: `assume` argument was false\n-    }\n-}"}, {"sha": "a30c054ab5d0486fd57255dd86bebc03a2918c25", "filename": "tests/compile-fail/bitop-beyond-alignment.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbitop-beyond-alignment.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-\n-use std::mem;\n-\n-enum Tag<A> {\n-    Tag2(A)\n-}\n-\n-struct Rec {\n-    c8: u8,\n-    t: Tag<u64>\n-}\n-\n-fn mk_rec() -> Rec {\n-    return Rec { c8:0, t:Tag::Tag2(0) };\n-}\n-\n-fn is_u64_aligned(u: &Tag<u64>) -> bool {\n-    let p: usize = unsafe { mem::transmute(u) };\n-    let u64_align = std::mem::align_of::<u64>();\n-    return (p & (u64_align + 1)) == 0; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n-}\n-\n-pub fn main() {\n-    let x = mk_rec();\n-    assert!(is_u64_aligned(&x.t));\n-}"}, {"sha": "912b1bd7d91f26ea2118a2eb8cabcb70ac16b1d3", "filename": "tests/compile-fail/cast_box_int_to_fn_ptr.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,11 +0,0 @@\n-// Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n-\n-fn main() {\n-    let b = Box::new(42);\n-    let g = unsafe {\n-        std::mem::transmute::<&usize, &fn(i32)>(&b)\n-    };\n-\n-    (*g)(42) //~ ERROR a memory access tried to interpret some bytes as a pointer\n-}"}, {"sha": "7509ae6ed77cb5de14fc77cc85aea86d432d7b60", "filename": "tests/compile-fail/cast_fn_ptr.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-fn main() {\n-    fn f() {}\n-\n-    let g = unsafe {\n-        std::mem::transmute::<fn(), fn(i32)>(f)\n-    };\n-\n-    g(42) //~ ERROR tried to call a function with sig fn() through a function pointer of type fn(i32)\n-}"}, {"sha": "5d902e1f9aaaf811f7729293bda0f9b1c69459dd", "filename": "tests/compile-fail/cast_fn_ptr2.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-fn main() {\n-    fn f(_ : (i32,i32)) {}\n-\n-    let g = unsafe {\n-        std::mem::transmute::<fn((i32,i32)), fn(i32)>(f)\n-    };\n-\n-    g(42) //~ ERROR tried to call a function with sig fn((i32, i32)) through a function pointer of type fn(i32)\n-}"}, {"sha": "568681da3c5d394244f00050cfb7e77f4aa51636", "filename": "tests/compile-fail/cast_fn_ptr_unsafe.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-// just making sure that fn -> unsafe fn casts are handled by rustc so miri doesn't have to\n-fn main() {\n-    fn f() {}\n-\n-    let g = f as fn() as unsafe fn(i32); //~ERROR: non-primitive cast: `fn()` as `unsafe fn(i32)`\n-\n-    unsafe {\n-        g(42);\n-    }\n-}"}, {"sha": "314365939fe8085834350276b6c4b176979837b1", "filename": "tests/compile-fail/cast_fn_ptr_unsafe2.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-// just making sure that fn -> unsafe fn casts are handled by rustc so miri doesn't have to\n-fn main() {\n-    fn f() {}\n-\n-    let g = f as fn() as fn(i32) as unsafe fn(i32); //~ERROR: non-primitive cast: `fn()` as `fn(i32)`\n-\n-    unsafe {\n-        g(42);\n-    }\n-}"}, {"sha": "23f85dbaf3ecbfd8715b50478e8d88ce63dc7e63", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-// Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n-\n-fn main() {\n-    let g = unsafe {\n-        std::mem::transmute::<usize, fn(i32)>(42)\n-    };\n-\n-    g(42) //~ ERROR a memory access tried to interpret some bytes as a pointer\n-}"}, {"sha": "f4acbadfd549d588a01bdec05f9a7acc480da62c", "filename": "tests/compile-fail/copy_nonoverlapping.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(core_intrinsics)]\n-\n-use std::intrinsics::*;\n-\n-//error-pattern: copy_nonoverlapping called on overlapping ranges\n-\n-fn main() {\n-    let mut data = [0u8; 16];\n-    unsafe {\n-        let a = &data[0] as *const _;\n-        let b = &mut data[1] as *mut _;\n-        std::ptr::copy_nonoverlapping(a, b, 2);\n-    }\n-}"}, {"sha": "704c4d4b7d462d79a86419ff50567374c7c49424", "filename": "tests/compile-fail/ctlz_nonzero.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fctlz_nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fctlz_nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fctlz_nonzero.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-#![feature(intrinsics)]\n-\n-mod rusti {\n-    extern \"rust-intrinsic\" {\n-        pub fn ctlz_nonzero<T>(x: T) -> T;\n-    }\n-}\n-\n-pub fn main() {\n-    unsafe {\n-        use rusti::*;\n-\n-        ctlz_nonzero(0u8); //~ ERROR: ctlz_nonzero called on 0\n-    }\n-}"}, {"sha": "eda25c66152146e3b482e98e5bb9af1688771303", "filename": "tests/compile-fail/cttz_nonzero.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcttz_nonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fcttz_nonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcttz_nonzero.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-#![feature(intrinsics)]\n-\n-mod rusti {\n-    extern \"rust-intrinsic\" {\n-        pub fn cttz_nonzero<T>(x: T) -> T;\n-    }\n-}\n-\n-pub fn main() {\n-    unsafe {\n-        use rusti::*;\n-\n-        cttz_nonzero(0u8); //~ ERROR: cttz_nonzero called on 0\n-    }\n-}"}, {"sha": "0ede7c96f004717d2224bbf9f10a1f1896af63a7", "filename": "tests/compile-fail/dangling_pointer_deref.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdangling_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdangling_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdangling_pointer_deref.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    let p = {\n-        let b = Box::new(42);\n-        &*b as *const i32\n-    };\n-    let x = unsafe { *p }; //~ ERROR: dangling pointer was dereferenced\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "c1ae7477c81a8adc22ff8a02eaef41c2dd04e19c", "filename": "tests/compile-fail/deallocate-bad-alignment.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-bad-alignment.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 2));\n-    }\n-}"}, {"sha": "5577f10736d2e39371df6848291140b809c57a34", "filename": "tests/compile-fail/deallocate-bad-size.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-bad-size.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(2, 1));\n-    }\n-}"}, {"sha": "e11df0eb4147d842a69617bf74405b4331b4fd77", "filename": "tests/compile-fail/deallocate-twice.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdeallocate-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdeallocate-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdeallocate-twice.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: tried to deallocate dangling pointer\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n-    }\n-}"}, {"sha": "c1eaf7eaa61d284c1ddb463375b389b752e5f513", "filename": "tests/compile-fail/deref_fn_ptr.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fderef_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fderef_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fderef_fn_ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn f() {}\n-\n-fn main() {\n-    let x: i32 = unsafe {\n-        *std::mem::transmute::<fn(), *const i32>(f) //~ ERROR: tried to dereference a function pointer\n-    };\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "3e869ad4a5078687497071ac400cbd6ed8c24801", "filename": "tests/compile-fail/div-by-zero-2.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdiv-by-zero-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdiv-by-zero-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdiv-by-zero-2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(const_err)]\n-\n-fn main() {\n-    let _n = 1 / 0; //~ ERROR: DivisionByZero\n-}"}, {"sha": "4ac6214d88abb12c139c63ae6a3f351faef47ea5", "filename": "tests/compile-fail/div-by-zero.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdiv-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fdiv-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdiv-by-zero.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(core_intrinsics)]\n-\n-use std::intrinsics::*;\n-\n-//error-pattern: Division by 0 in unchecked_div\n-\n-fn main() {\n-    unsafe {\n-        let _n = unchecked_div(1i64, 0);\n-    }\n-}"}, {"sha": "87d975e1f9d486ab389b00f8ab4906145076541c", "filename": "tests/compile-fail/execute_memory.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,12 +0,0 @@\n-// Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n-\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let x = box 42;\n-    unsafe {\n-        let f = std::mem::transmute::<Box<i32>, fn()>(x);\n-        f() //~ ERROR: tried to treat a memory pointer as a function pointer\n-    }\n-}"}, {"sha": "45e32142a8c44a2b723db5410bba8005a6b491a5", "filename": "tests/compile-fail/fn_ptr_offset.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffn_ptr_offset.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-// Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n-\n-use std::mem;\n-\n-fn f() {}\n-\n-fn main() {\n-    let x : fn() = f;\n-    let y : *mut u8 = unsafe { mem::transmute(x) };\n-    let y = y.wrapping_offset(1);\n-    let x : fn() = unsafe { mem::transmute(y) };\n-    x(); //~ ERROR: tried to use a function pointer after offsetting it\n-}"}, {"sha": "c30c9b439a46b495c1b91c6ccc8043abd137fbc6", "filename": "tests/compile-fail/invalid_bool.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_bool.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let b = unsafe { std::mem::transmute::<u8, bool>(2) }; //~ ERROR: invalid boolean value read\n-    if b { unreachable!() } else { unreachable!() }\n-}"}, {"sha": "9ce6d44ca460ff356dc0effbf20919fb43aaf653", "filename": "tests/compile-fail/invalid_enum_discriminant.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,17 +0,0 @@\n-// Validation makes this fail in the wrong place\n-// compile-flags: -Zmir-emit-validate=0\n-\n-#[repr(C)]\n-pub enum Foo {\n-    A, B, C, D\n-}\n-\n-fn main() {\n-    let f = unsafe { std::mem::transmute::<i32, Foo>(42) };\n-    match f {\n-        Foo::A => {}, //~ ERROR invalid enum discriminant value read\n-        Foo::B => {},\n-        Foo::C => {},\n-        Foo::D => {},\n-    }\n-}"}, {"sha": "4fee6e692bada0913b093aeb2892fac4f610d8ea", "filename": "tests/compile-fail/match_char.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fmatch_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fmatch_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_char.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    assert!(std::char::from_u32(-1_i32 as u32).is_none());\n-    match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ERROR tried to interpret an invalid 32-bit value as a char: 4294967295\n-        'a' => {},\n-        'b' => {},\n-        _ => {},\n-    }\n-}"}, {"sha": "71b4e2f442f31db02b4d710d3ede9917c51f9dcc", "filename": "tests/compile-fail/memleak.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fmemleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fmemleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,5 +0,0 @@\n-//error-pattern: the evaluated program leaked memory\n-\n-fn main() {\n-    std::mem::forget(Box::new(42));\n-}"}, {"sha": "b2bc6722afb04fd22c6a0bc4b546ecab3fe1e5ac", "filename": "tests/compile-fail/memleak_rc.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak_rc.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,12 +0,0 @@\n-//error-pattern: the evaluated program leaked memory\n-\n-use std::rc::Rc;\n-use std::cell::RefCell;\n-\n-struct Dummy(Rc<RefCell<Option<Dummy>>>);\n-\n-fn main() {\n-    let x = Dummy(Rc::new(RefCell::new(None)));\n-    let y = Dummy(x.0.clone());\n-    *x.0.borrow_mut() = Some(y);\n-}"}, {"sha": "cb2e7217d5797331be2918c8d39b66a9b1c3fc05", "filename": "tests/compile-fail/modifying_constants.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmodifying_constants.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is marked static, not the pointee\n-    let y = unsafe { &mut *(x as *const i32 as *mut i32) };\n-    *y = 42; //~ ERROR tried to modify constant memory\n-    assert_eq!(*x, 42);\n-}"}, {"sha": "6aa4e281818cabc41d7595bb2245c42802b3213b", "filename": "tests/compile-fail/never_say_never.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fnever_say_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fnever_say_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_say_never.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-// This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n-\n-#![feature(never_type)]\n-#![allow(unreachable_code)]\n-\n-fn main() {\n-    let y = &5;\n-    let x: ! = unsafe {\n-        *(y as *const _ as *const !) //~ ERROR tried to access a dead local variable\n-    };\n-    f(x)\n-}\n-\n-fn f(x: !) -> ! { x }"}, {"sha": "7390596cf7fa62f7fd524338c74ed2ebbaab67b5", "filename": "tests/compile-fail/never_transmute_humans.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fnever_transmute_humans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fnever_transmute_humans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_transmute_humans.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,17 +0,0 @@\n-// This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n-\n-#![feature(never_type)]\n-#![allow(unreachable_code)]\n-#![allow(unused_variables)]\n-\n-struct Human;\n-\n-fn main() {\n-    let x: ! = unsafe {\n-        std::mem::transmute::<Human, !>(Human) //~ ERROR entered unreachable code\n-    };\n-    f(x)\n-}\n-\n-fn f(x: !) -> ! { x }"}, {"sha": "0b0897644409e1e5e2e3bedb0c2e3ca04254c239", "filename": "tests/compile-fail/never_transmute_void.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fnever_transmute_void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fnever_transmute_void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnever_transmute_void.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,19 +0,0 @@\n-// This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n-\n-#![feature(never_type)]\n-#![allow(unreachable_code)]\n-#![allow(unused_variables)]\n-\n-enum Void {}\n-\n-fn f(v: Void) -> ! {\n-    match v {} //~ ERROR entered unreachable code\n-}\n-\n-fn main() {\n-    let v: Void = unsafe {\n-        std::mem::transmute::<(), Void>(())\n-    };\n-    f(v);\n-}"}, {"sha": "5a26856eba0879d8cd55f0b4f6d1b589844e174e", "filename": "tests/compile-fail/null_pointer_deref.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnull_pointer_deref.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: invalid use of NULL pointer\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "d4aebb912ee1707ef795f555cfa88497b1ff82e9", "filename": "tests/compile-fail/oom.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-#![feature(custom_attribute, attr_literals)]\n-#![miri(memory_size=4095)]\n-\n-fn main() {\n-    let _x = [42; 1024];\n-    //~^ERROR tried to allocate 4096 more bytes, but only\n-}"}, {"sha": "6c973bcf4016ddfba9b859b4ceaacaa35244c135", "filename": "tests/compile-fail/oom2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-// Validation forces more allocation; disable it.\n-// compile-flags: -Zmir-emit-validate=0\n-#![feature(box_syntax, custom_attribute, attr_literals)]\n-#![miri(memory_size=1024)]\n-\n-// On 64bit platforms, the allocator needs 32 bytes allocated to pass a return value, so that's the error we see.\n-// On 32bit platforms, it's just 16 bytes.\n-// error-pattern: tried to allocate\n-\n-fn main() {\n-    loop {\n-        ::std::mem::forget(box 42);\n-    }\n-}"}, {"sha": "8dce7e578626403647b5764d26387798a15420b4", "filename": "tests/compile-fail/out_of_bounds_ptr_1.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fout_of_bounds_ptr_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fout_of_bounds_ptr_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_ptr_1.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-// error-pattern: pointer computed at offset 5, outside bounds of allocation\n-fn main() {\n-    let v = [0i8; 4];\n-    let x = &v as *const i8;\n-    // The error is inside another function, so we cannot match it by line\n-    let x = unsafe { x.offset(5) };\n-    panic!(\"this should never print: {:?}\", x);\n-}"}, {"sha": "f7546494574b0d67f907c72d4d7cef416a997b2e", "filename": "tests/compile-fail/out_of_bounds_ptr_2.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fout_of_bounds_ptr_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fout_of_bounds_ptr_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_ptr_2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern: overflowing math\n-fn main() {\n-    let v = [0i8; 4];\n-    let x = &v as *const i8;\n-    let x = unsafe { x.offset(-1) };\n-    panic!(\"this should never print: {:?}\", x);\n-}"}, {"sha": "8c56b14bdf221f055cbfe2f82550b1788cfeb90c", "filename": "tests/compile-fail/out_of_bounds_read.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR: which has size 2\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "d29b22ffb2a6b633c29bc18115a675227b361c7f", "filename": "tests/compile-fail/out_of_bounds_read2.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.as_ptr().wrapping_offset(5) }; //~ ERROR: memory access at offset 6, outside bounds of allocation\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "3a889be741efdf159f05fc87134203ef7e5b92e1", "filename": "tests/compile-fail/overflowing-lsh-neg.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(exceeding_bitshifts)]\n-#![allow(const_err)]\n-\n-fn main() {\n-    let _n = 2i64 << -1; //~ Overflow(Shl)\n-}"}, {"sha": "ac09a1740c43e5b8d93138a6632b0ad7361831c2", "filename": "tests/compile-fail/overflowing-rsh-2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-rsh-2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(exceeding_bitshifts, const_err)]\n-\n-fn main() {\n-    // Make sure we catch overflows that would be hidden by first casting the RHS to u32\n-    let _n = 1i64 >> (u32::max_value() as i64 + 1); //~ Overflow(Shr)\n-}"}, {"sha": "a7ac9d1d50398d1f50fb9cd00152cf1808a3b77c", "filename": "tests/compile-fail/overflowing-rsh.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverflowing-rsh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverflowing-rsh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-rsh.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(exceeding_bitshifts)]\n-\n-fn main() {\n-    let _n = 1i64 >> 64; //~ Overflow(Shr)\n-}"}, {"sha": "b8291e1300edf0fbd8fe9e7664a4830fcfe6695c", "filename": "tests/compile-fail/overflowing-unchecked-rsh.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverflowing-unchecked-rsh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverflowing-unchecked-rsh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-unchecked-rsh.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(core_intrinsics)]\n-\n-use std::intrinsics::*;\n-\n-//error-pattern: Overflowing shift by 64 in unchecked_shr\n-\n-fn main() {\n-    unsafe {\n-        let _n = unchecked_shr(1i64, 64);\n-    }\n-}"}, {"sha": "50f51d0ba9cad066a94b634cffc2aaf23b20a98e", "filename": "tests/compile-fail/overwriting_part_of_relocation_makes_the_rest_undefined.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverwriting_part_of_relocation_makes_the_rest_undefined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Foverwriting_part_of_relocation_makes_the_rest_undefined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverwriting_part_of_relocation_makes_the_rest_undefined.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,11 +0,0 @@\n-fn main() {\n-    let mut p = &42;\n-    unsafe {\n-        let ptr: *mut _ = &mut p;\n-        *(ptr as *mut u8) = 123; // if we ever support 8 bit pointers, this is gonna cause\n-        // \"attempted to interpret some raw bytes as a pointer address\" instead of\n-        // \"attempted to read undefined bytes\"\n-    }\n-    let x = *p; //~ ERROR: attempted to read undefined bytes\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "80149eeffaa641c32a70dc2dc04645c2a426658e", "filename": "tests/compile-fail/panic.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-// FIXME: Something in panic handling fails validation with full-MIR\n-// compile-flags: -Zmir-emit-validate=0\n-//error-pattern: the evaluated program panicked\n-\n-fn main() {\n-    assert_eq!(5, 6);\n-}"}, {"sha": "342eb28a970fcebbe6f658eeb70a105681f7b3a5", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let x = 13;\n-    let y = &x;\n-    let z = &y as *const &i32 as *const usize;\n-    let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n-    let _ = ptr_bytes % 432; //~ ERROR: tried to access part of a pointer value as raw bytes\n-}"}, {"sha": "b0f619332e00c933cbe1502b1770d18f34222709", "filename": "tests/compile-fail/pointer_byte_read_2.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let x = 13;\n-    let y = &x;\n-    let z = &y as *const &i32 as *const u8;\n-    // the deref fails, because we are reading only a part of the pointer\n-    let _ = unsafe { *z }; //~ ERROR: tried to access part of a pointer value as raw bytes\n-}"}, {"sha": "245b7527c55b27a6234ebccd1d4aeaeed127019b", "filename": "tests/compile-fail/pointers_to_different_allocations_are_unorderable.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let x: *const u8 = &1;\n-    let y: *const u8 = &2;\n-    if x < y { //~ ERROR: attempted to do invalid arithmetic on pointers\n-        unreachable!()\n-    }\n-}"}, {"sha": "78fd8e912b5e73524f20475050a86478b0c864c1", "filename": "tests/compile-fail/ptr_bitops.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fptr_bitops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fptr_bitops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-    let one = bytes.as_ptr().wrapping_offset(1);\n-    let three = bytes.as_ptr().wrapping_offset(3);\n-    let res = (one as usize) | (three as usize); //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n-    println!(\"{}\", res);\n-}"}, {"sha": "396c71ebb03d18298eff130625e9b26d108a402c", "filename": "tests/compile-fail/ptr_int_cast.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fptr_int_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fptr_int_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_int_cast.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    let x = &1;\n-    // Casting down to u8 and back up to a pointer loses too much precision; this must not work.\n-    let x = x as *const i32;\n-    let x = x as u8; //~ ERROR: a raw memory access tried to access part of a pointer value as raw bytes\n-    let x = x as *const i32;\n-    let _ = unsafe { *x };\n-}"}, {"sha": "578468c3399bbd42ff48a8414c30646d868d6634", "filename": "tests/compile-fail/ptr_offset_overflow.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fptr_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fptr_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_overflow.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-//error-pattern: overflowing math\n-fn main() {\n-    let v = [1i8, 2];\n-    let x = &v[1] as *const i8;\n-    let _ = unsafe { x.offset(isize::min_value()) };\n-}"}, {"sha": "cc41b52f33372de36972a1b1dc1898d9bd841738", "filename": "tests/compile-fail/reading_half_a_pointer.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freading_half_a_pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freading_half_a_pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freading_half_a_pointer.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,29 +0,0 @@\n-#![allow(dead_code)]\n-\n-// We use packed structs to get around alignment restrictions\n-#[repr(packed)]\n-struct Data {\n-    pad: u8,\n-    ptr: &'static i32,\n-}\n-\n-// But we need to gurantee some alignment\n-struct Wrapper {\n-    align: u64,\n-    data: Data,\n-}\n-\n-static G : i32 = 0;\n-\n-fn main() {\n-    let mut w = Wrapper { align: 0, data: Data { pad: 0, ptr: &G } };\n-\n-    // Get a pointer to the beginning of the Data struct (one u8 byte, then the pointer bytes).\n-    // Thanks to the wrapper, we know this is aligned-enough to perform a load at ptr size.\n-    // We load at pointer type, so having a relocation is okay -- but here, the relocation\n-    // starts 1 byte to the right, so using it would actually be wrong!\n-    let d_alias = &mut w.data as *mut _ as *mut *const u8;\n-    unsafe {\n-        let _x = *d_alias; //~ ERROR: tried to access part of a pointer value as raw bytes\n-    }\n-}"}, {"sha": "cd6214440ff262e572a6a1e6acaa25f896dca906", "filename": "tests/compile-fail/reallocate-bad-alignment-2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-bad-alignment-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-bad-alignment-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-alignment-2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        // Try realloc with a too big alignment.\n-        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(1, 2), Layout::from_size_align_unchecked(1, 1)).unwrap();\n-    }\n-}"}, {"sha": "da5fe1d81909d4cc36b758b65aa8a6420b0af612", "filename": "tests/compile-fail/reallocate-bad-alignment.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-alignment.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 2)).unwrap();\n-        // Try realloc with a too small alignment.\n-        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(1, 1), Layout::from_size_align_unchecked(1, 2)).unwrap();\n-    }\n-}"}, {"sha": "953178742c46fb03e14bca2bf74cd93ce647ce3e", "filename": "tests/compile-fail/reallocate-bad-size.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-bad-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-bad-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-bad-size.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: tried to deallocate or reallocate using incorrect alignment or size\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(2, 1), Layout::from_size_align_unchecked(1, 1)).unwrap();\n-    }\n-}"}, {"sha": "290c966a2bc8a8acb3b3e440c5286a713444a554", "filename": "tests/compile-fail/reallocate-change-alloc.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-change-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-change-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-change-alloc.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        let _y = Heap.realloc(x, Layout::from_size_align_unchecked(1, 1), Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        let _z = *x; //~ ERROR: dangling pointer was dereferenced\n-    }\n-}"}, {"sha": "6225879a5a2a0faff4d9cdc4280997f1c3c05844", "filename": "tests/compile-fail/reallocate-dangling.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freallocate-dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freallocate-dangling.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-#![feature(alloc, allocator_api)]\n-\n-extern crate alloc;\n-\n-use alloc::heap::Heap;\n-use alloc::allocator::*;\n-\n-// error-pattern: dangling pointer was dereferenced\n-\n-fn main() {\n-    unsafe {\n-        let x = Heap.alloc(Layout::from_size_align_unchecked(1, 1)).unwrap();\n-        Heap.dealloc(x, Layout::from_size_align_unchecked(1, 1));\n-        Heap.realloc(x, Layout::from_size_align_unchecked(1, 1), Layout::from_size_align_unchecked(1, 1));\n-    }\n-}"}, {"sha": "cc927f879504a271a8897f7fc68195f3b6c56004", "filename": "tests/compile-fail/reference_to_packed.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freference_to_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Freference_to_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Freference_to_packed.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,19 +0,0 @@\n-// This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n-\n-#![allow(dead_code, unused_variables)]\n-\n-#[repr(packed)]\n-struct Foo {\n-    x: i32,\n-    y: i32,\n-}\n-\n-fn main() {\n-    let foo = Foo {\n-        x: 42,\n-        y: 99,\n-    };\n-    let p = &foo.x;\n-    let i = *p; //~ ERROR tried to access memory with alignment 1, but alignment 4 is required\n-}"}, {"sha": "abe89e233e7cd824849d93b527c3a176949aa8c4", "filename": "tests/compile-fail/repeat.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frepeat.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let data: [u8; std::usize::MAX] = [42; std::usize::MAX];\n-    //~^ ERROR: rustc layout computation failed: SizeOverflow([u8;\n-    assert_eq!(data.len(), 1024);\n-}"}, {"sha": "d489342b8599c3a8efa64ab86bb7e1897e9867b7", "filename": "tests/compile-fail/repeat2.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Frepeat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Frepeat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frepeat2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let data: [u8; 1024*1024*1024] = [42; 1024*1024*1024];\n-    //~^ ERROR: reached the configured maximum execution time\n-    assert_eq!(data.len(), 1024*1024*1024);\n-}"}, {"sha": "96006c884e5806b085aafc46e7fff5691108149b", "filename": "tests/compile-fail/stack_free.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_free.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern: tried to deallocate Stack memory but gave Machine(Rust) as the kind\n-\n-fn main() {\n-    let x = 42;\n-    let bad_box = unsafe { std::mem::transmute::<&i32, Box<i32>>(&x) };\n-    drop(bad_box);\n-}"}, {"sha": "c6aaf80e6ac00bc34febec7d704d105444bf8d97", "filename": "tests/compile-fail/stack_limit.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstack_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstack_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_limit.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-#![feature(custom_attribute, attr_literals)]\n-#![miri(stack_limit=16)]\n-\n-//error-pattern: reached the configured maximum number of stack frames\n-\n-fn bar() {\n-    foo();\n-}\n-\n-fn foo() {\n-    cake();\n-}\n-\n-fn cake() {\n-    bar();\n-}\n-\n-fn main() {\n-    bar();\n-}"}, {"sha": "11961becb246a2a0eae976af412a60941fb6cda3", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-static X: usize = 5;\n-\n-#[allow(mutable_transmutes)]\n-fn main() {\n-    unsafe {\n-        *std::mem::transmute::<&usize, &mut usize>(&X) = 6; //~ ERROR: tried to modify constant memory\n-        assert_eq!(X, 6);\n-    }\n-}"}, {"sha": "f030a9c281de7fff0b1501b0a21fb3a81c289f62", "filename": "tests/compile-fail/static_memory_modification2.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,12 +0,0 @@\n-// Validation detects that we are casting & to &mut and so it changes why we fail\n-// compile-flags: -Zmir-emit-validate=0\n-\n-use std::mem::transmute;\n-\n-#[allow(mutable_transmutes)]\n-fn main() {\n-    unsafe {\n-        let s = \"this is a test\";\n-        transmute::<&[u8], &mut [u8]>(s.as_bytes())[4] = 42; //~ ERROR: tried to modify constant memory\n-    }\n-}"}, {"sha": "743fbe60efff69c9e5197678bad7dc90c7ade13e", "filename": "tests/compile-fail/static_memory_modification3.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-use std::mem::transmute;\n-\n-#[allow(mutable_transmutes)]\n-fn main() {\n-    unsafe {\n-        let bs = b\"this is a test\";\n-        transmute::<&[u8], &mut [u8]>(bs)[4] = 42; //~ ERROR: tried to modify constant memory\n-    }\n-}"}, {"sha": "edd4c31866910642e97e6813084c7c27240367ec", "filename": "tests/compile-fail/timeout.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftimeout.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-//error-pattern: reached the configured maximum execution time\n-#![feature(custom_attribute, attr_literals)]\n-#![miri(step_limit=1000)]\n-\n-fn main() {\n-    for i in 0..1000000 {\n-        assert!(i < 1000);\n-    }\n-}"}, {"sha": "acc6098af7ee04a2c638d71b23fab120e9e91d78", "filename": "tests/compile-fail/transmute-pair-undef.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ftransmute-pair-undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ftransmute-pair-undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute-pair-undef.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-#![feature(core_intrinsics)]\n-\n-use std::mem;\n-\n-fn main() {\n-    let x: Option<Box<[u8]>> = unsafe {\n-        let z = std::intrinsics::add_with_overflow(0usize, 0usize);\n-        std::mem::transmute::<(usize, bool), Option<Box<[u8]>>>(z)\n-    };\n-    let y = &x;\n-    // Now read this bytewise.  There should be (ptr_size+1) def bytes followed by (ptr_size-1) undef bytes (the padding after the bool) in there.\n-    let z : *const u8 = y as *const _ as *const _;\n-    let first_undef = mem::size_of::<usize>() as isize + 1;\n-    for i in 0..first_undef {\n-        let byte = unsafe { *z.offset(i) };\n-        assert_eq!(byte, 0);\n-    }\n-    let v = unsafe { *z.offset(first_undef) };\n-    if v == 0 {} //~ ERROR attempted to read undefined bytes\n-}"}, {"sha": "7d5d95a1dc6da32b97b90f14a4a164a235a3b163", "filename": "tests/compile-fail/transmute_fat.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ftransmute_fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ftransmute_fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute_fat.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-// This should fail even without validation\n-// compile-flags: -Zmir-emit-validate=0\n-#![feature(i128_type)]\n-\n-fn main() {\n-    #[cfg(target_pointer_width=\"64\")]\n-    let bad = unsafe {\n-        std::mem::transmute::<&[u8], u128>(&[1u8])\n-    };\n-    #[cfg(target_pointer_width=\"32\")]\n-    let bad = unsafe {\n-        std::mem::transmute::<&[u8], u64>(&[1u8])\n-    };\n-    bad + 1; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n-}"}, {"sha": "028ed613eee71fb73f51277d1cf9182f9d8789b7", "filename": "tests/compile-fail/transmute_fat2.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ftransmute_fat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Ftransmute_fat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute_fat2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,13 +0,0 @@\n-#![feature(i128_type)]\n-\n-fn main() {\n-    #[cfg(target_pointer_width=\"64\")]\n-    let bad = unsafe {\n-        std::mem::transmute::<u128, &[u8]>(42)\n-    };\n-    #[cfg(target_pointer_width=\"32\")]\n-    let bad = unsafe {\n-        std::mem::transmute::<u64, &[u8]>(42)\n-    };\n-    bad[0]; //~ ERROR index out of bounds: the len is 0 but the index is 0\n-}"}, {"sha": "8ad1b323250c9b833e528bd6939d207b14f3cdf4", "filename": "tests/compile-fail/unaligned_ptr_cast.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    let x = &2u16;\n-    let x = x as *const _ as *const u32;\n-    // This must fail because alignment is violated\n-    let _x = unsafe { *x }; //~ ERROR: tried to access memory with alignment 2, but alignment 4 is required\n-}"}, {"sha": "15fb7dd31368bcce0b840b2611511a3d525b9514", "filename": "tests/compile-fail/unaligned_ptr_cast2.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let x = &2u16;\n-    let x = x as *const _ as *const *const u8;\n-    // This must fail because alignment is violated.  Test specifically for loading pointers, which have special code\n-    // in miri's memory.\n-    let _x = unsafe { *x }; //~ ERROR: tried to access memory with alignment 2, but alignment\n-}"}, {"sha": "fc603840684e8b0369274e0e37d197a0b1ac313d", "filename": "tests/compile-fail/unaligned_ptr_cast_zst.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast_zst.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    let x = &2u16;\n-    let x = x as *const _ as *const [u32; 0];\n-    // This must fail because alignment is violated.  Test specifically for loading ZST.\n-    let _x = unsafe { *x }; //~ ERROR: tried to access memory with alignment 2, but alignment 4 is required\n-}"}, {"sha": "86aa57447fe609ac60b1fbd4470c02cc30bf0a99", "filename": "tests/compile-fail/validation_aliasing_mut1.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    pub fn safe(x: &mut i32, y: &mut i32) {} //~ ERROR: in conflict with lock WriteLock\n-}\n-\n-fn main() {\n-    let x = &mut 0 as *mut _;\n-    unsafe { safe::safe(&mut *x, &mut *x) };\n-}"}, {"sha": "ed7497e5e546029b102b05a2a47abb07d1288225", "filename": "tests/compile-fail/validation_aliasing_mut2.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    pub fn safe(x: &i32, y: &mut i32) {} //~ ERROR: in conflict with lock ReadLock\n-}\n-\n-fn main() {\n-    let x = &mut 0 as *mut _;\n-    unsafe { safe::safe(&*x, &mut *x) };\n-}"}, {"sha": "69fbbc167ca0f49193399a3dce84b5fcabea62d9", "filename": "tests/compile-fail/validation_aliasing_mut3.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    pub fn safe(x: &mut i32, y: &i32) {} //~ ERROR: in conflict with lock WriteLock\n-}\n-\n-fn main() {\n-    let x = &mut 0 as *mut _;\n-    unsafe { safe::safe(&mut *x, &*x) };\n-}"}, {"sha": "3dac55aeaac952071a9c9f707bcbddc66ead875b", "filename": "tests/compile-fail/validation_aliasing_mut4.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,13 +0,0 @@\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    use std::cell::Cell;\n-\n-    // Make sure &mut UnsafeCell also has a lock to it\n-    pub fn safe(x: &mut Cell<i32>, y: &i32) {} //~ ERROR: in conflict with lock WriteLock\n-}\n-\n-fn main() {\n-    let x = &mut 0 as *mut _;\n-    unsafe { safe::safe(&mut *(x as *mut _), &*x) };\n-}"}, {"sha": "98eca8d3607f7b025e083808c5f8f07c4e0c5bad", "filename": "tests/compile-fail/validation_buggy_as_mut_slice.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_buggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_buggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_buggy_as_mut_slice.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-#![allow(unused_variables)]\n-\n-// For some reason, the error location is different when using fullmir\n-// error-pattern: in conflict with lock WriteLock\n-\n-mod safe {\n-    use std::slice::from_raw_parts_mut;\n-\n-    pub fn as_mut_slice<T>(self_: &Vec<T>) -> &mut [T] {\n-        unsafe {\n-            from_raw_parts_mut(self_.as_ptr() as *mut T, self_.len())\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let v = vec![0,1,2];\n-    let v1_ = safe::as_mut_slice(&v);\n-    let v2_ = safe::as_mut_slice(&v);\n-}"}, {"sha": "9e67b2a4ab18c9d48d84ad5f0b34090be915b88f", "filename": "tests/compile-fail/validation_buggy_split_at_mut.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,22 +0,0 @@\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    use std::slice::from_raw_parts_mut;\n-\n-    pub fn split_at_mut<T>(self_: &mut [T], mid: usize) -> (&mut [T], &mut [T]) {\n-        let len = self_.len();\n-        let ptr = self_.as_mut_ptr();\n-\n-        unsafe {\n-            assert!(mid <= len);\n-\n-            (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let mut array = [1,2,3,4];\n-    let _x = safe::split_at_mut(&mut array, 0); //~ ERROR: in conflict with lock WriteLock\n-}"}, {"sha": "1432f4cc9f1720f5565c784d0b5b7a537013ed8b", "filename": "tests/compile-fail/validation_illegal_write.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    pub(crate) fn safe(x: &u32) {\n-        let x : &mut u32 = unsafe { &mut *(x as *const _ as *mut _) };\n-        *x = 42; //~ ERROR: in conflict with lock ReadLock\n-    }\n-}\n-\n-fn main() {\n-    let target = &mut 42;\n-    let target_ref = &target;\n-    // do a reborrow, but we keep the lock\n-    safe::safe(&*target);\n-}"}, {"sha": "b352346114d7f2943bbc305431c168280007f68e", "filename": "tests/compile-fail/validation_lock_confusion.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,24 +0,0 @@\n-// Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n-#![allow(unused_variables)]\n-use std::cell::RefCell;\n-\n-fn evil(x: *mut i32) {\n-    unsafe { *x = 0; } //~ ERROR: in conflict with lock WriteLock\n-}\n-\n-fn test(r: &mut RefCell<i32>) {\n-    let x = &*r; // releasing write lock, first suspension recorded\n-    let mut x_ref = x.borrow_mut();\n-    let x_inner : &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n-    {\n-        let x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n-        let y = &*r; // second suspension for the outer write lock\n-        let x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock\n-    }\n-    // If the two locks are mixed up, here we should have a write lock, but we do not.\n-    evil(x_inner as *mut _);\n-}\n-\n-fn main() {\n-    test(&mut RefCell::new(0));\n-}"}, {"sha": "3320d2a89d3551699c18bc540f4ad1ba2ca408fc", "filename": "tests/compile-fail/validation_pointer_smuggling.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-#![allow(unused_variables)]\n-\n-static mut PTR: *mut u8 = 0 as *mut _;\n-\n-fn fun1(x: &mut u8) {\n-    unsafe {\n-        PTR = x;\n-    }\n-}\n-\n-fn fun2() {\n-    // Now we use a pointer we are not allowed to use\n-    let _x = unsafe { *PTR }; //~ ERROR: in conflict with lock WriteLock\n-}\n-\n-fn main() {\n-    let mut val = 0;\n-    fun1(&mut val);\n-    fun2();\n-}"}, {"sha": "55c38a694c55e04f61489081b0ee8af353124628", "filename": "tests/compile-fail/validation_recover1.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_recover1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_recover1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover1.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-#![allow(unused_variables)]\n-\n-#[repr(u32)]\n-enum Bool { True }\n-\n-mod safe {\n-    pub(crate) fn safe(x: &mut super::Bool) {\n-        let x = x as *mut _ as *mut u32;\n-        unsafe { *x = 44; } // out-of-bounds enum discriminant\n-    }\n-}\n-\n-fn main() {\n-    let mut x = Bool::True;\n-    safe::safe(&mut x); //~ ERROR: invalid enum discriminant\n-}"}, {"sha": "756be9fde6fc58d85dd44044d58d26e0d6f06d4f", "filename": "tests/compile-fail/validation_recover2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_recover2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_recover2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    // This makes a ref that was passed to us via &mut alias with things it should not alias with\n-    pub(crate) fn safe(x: &mut &u32, target: &mut u32) {\n-        unsafe { *x = &mut *(target as *mut _); }\n-    }\n-}\n-\n-fn main() {\n-    let target = &mut 42;\n-    let mut target_alias = &42; // initial dummy value\n-    safe::safe(&mut target_alias, target); //~ ERROR: in conflict with lock ReadLock\n-}"}, {"sha": "afe6fe7c0bb9f69fe2a209072c775c6b2f073731", "filename": "tests/compile-fail/validation_recover3.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_recover3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_recover3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover3.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-#![allow(unused_variables)]\n-\n-mod safe {\n-    pub(crate) fn safe(x: *mut u32) {\n-        unsafe { *x = 42; } //~ ERROR: in conflict with lock WriteLock\n-    }\n-}\n-\n-fn main() {\n-    let target = &mut 42u32;\n-    let target2 = target as *mut _;\n-    drop(&mut *target); // reborrow\n-    // Now make sure we still got the lock\n-    safe::safe(target2);\n-}"}, {"sha": "b889b1ea5317b8b1e3cff83e8707593047ef0d49", "filename": "tests/compile-fail/validation_undef.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fvalidation_undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_undef.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-#![allow(unused_variables)]\n-// error-pattern: attempted to read undefined bytes\n-\n-mod safe {\n-    use std::mem;\n-\n-    pub(crate) fn make_float() -> f32 {\n-        unsafe { mem::uninitialized() }\n-    }\n-}\n-\n-fn main() {\n-    let _x = safe::make_float();\n-}"}, {"sha": "57da8dfc01b27f2931f05c0bff5cf0bc18c58816", "filename": "tests/compile-fail/wild_pointer_deref.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwild_pointer_deref.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let p = 44 as *const i32;\n-    let x = unsafe { *p }; //~ ERROR: a memory access tried to interpret some bytes as a pointer\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "3439824047943c08b83493a6a0d25ed5bd90edcd", "filename": "tests/compile-fail/zst.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let x = &() as *const () as *const i32;\n-    let _ = unsafe { *x }; //~ ERROR: tried to access memory with alignment 1, but alignment 4 is required\n-}"}, {"sha": "b1ea3fc8b0d477a59bedd8aec902bac639993d3c", "filename": "tests/compiletest.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,213 +0,0 @@\n-#![feature(slice_concat_ext)]\n-\n-extern crate compiletest_rs as compiletest;\n-\n-use std::slice::SliceConcatExt;\n-use std::path::{PathBuf, Path};\n-use std::io::Write;\n-use std::env;\n-\n-macro_rules! eprintln {\n-    ($($arg:tt)*) => {\n-        let stderr = std::io::stderr();\n-        writeln!(stderr.lock(), $($arg)*).unwrap();\n-    }\n-}\n-\n-fn miri_path() -> PathBuf {\n-    if rustc_test_suite().is_some() {\n-        PathBuf::from(option_env!(\"MIRI_PATH\").unwrap())\n-    } else {\n-        PathBuf::from(concat!(\"target/\", env!(\"PROFILE\"), \"/miri\"))\n-    }\n-}\n-\n-fn rustc_test_suite() -> Option<PathBuf> {\n-    option_env!(\"RUSTC_TEST_SUITE\").map(PathBuf::from)\n-}\n-\n-fn rustc_lib_path() -> PathBuf {\n-    option_env!(\"RUSTC_LIB_PATH\").unwrap().into()\n-}\n-\n-fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, fullmir: bool) {\n-    eprintln!(\n-        \"## Running compile-fail tests in {} against miri for target {}\",\n-        path,\n-        target\n-    );\n-    let mut config = compiletest::Config::default().tempdir();\n-    config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n-    config.rustc_path = miri_path();\n-    let mut flags = Vec::new();\n-    if rustc_test_suite().is_some() {\n-        config.run_lib_path = rustc_lib_path();\n-        config.compile_lib_path = rustc_lib_path();\n-    }\n-    // if we are building as part of the rustc test suite, we already have fullmir for everything\n-    if fullmir && rustc_test_suite().is_none() {\n-        if host != target {\n-            // skip fullmir on nonhost\n-            return;\n-        }\n-        let sysroot = std::env::home_dir().unwrap()\n-            .join(\".xargo\")\n-            .join(\"HOST\");\n-        config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n-        config.src_base = PathBuf::from(path.to_string());\n-    } else {\n-        config.target_rustcflags = Some(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n-        config.src_base = PathBuf::from(path.to_string());\n-    }\n-    flags.push(\"-Zmir-emit-validate=1\".to_owned());\n-    config.target_rustcflags = Some(flags.join(\" \"));\n-    config.target = target.to_owned();\n-    compiletest::run_tests(&config);\n-}\n-\n-fn run_pass(path: &str) {\n-    eprintln!(\"## Running run-pass tests in {} against rustc\", path);\n-    let mut config = compiletest::Config::default().tempdir();\n-    config.mode = \"run-pass\".parse().expect(\"Invalid mode\");\n-    config.src_base = PathBuf::from(path);\n-    if let Some(rustc_path) = rustc_test_suite() {\n-        config.rustc_path = rustc_path;\n-        config.run_lib_path = rustc_lib_path();\n-        config.compile_lib_path = rustc_lib_path();\n-        config.target_rustcflags = Some(format!(\"-Dwarnings --sysroot {}\", get_sysroot().display()));\n-    } else {\n-        config.target_rustcflags = Some(\"-Dwarnings\".to_owned());\n-    }\n-    config.host_rustcflags = Some(\"-Dwarnings\".to_string());\n-    compiletest::run_tests(&config);\n-}\n-\n-fn miri_pass(path: &str, target: &str, host: &str, fullmir: bool, opt: bool) {\n-    let opt_str = if opt { \" with optimizations\" } else { \"\" };\n-    eprintln!(\n-        \"## Running run-pass tests in {} against miri for target {}{}\",\n-        path,\n-        target,\n-        opt_str\n-    );\n-    let mut config = compiletest::Config::default().tempdir();\n-    config.mode = \"ui\".parse().expect(\"Invalid mode\");\n-    config.src_base = PathBuf::from(path);\n-    config.target = target.to_owned();\n-    config.host = host.to_owned();\n-    config.rustc_path = miri_path();\n-    if rustc_test_suite().is_some() {\n-        config.run_lib_path = rustc_lib_path();\n-        config.compile_lib_path = rustc_lib_path();\n-    }\n-    let mut flags = Vec::new();\n-    // Control miri logging. This is okay despite concurrent test execution as all tests\n-    // will set this env var to the same value.\n-    env::set_var(\"MIRI_LOG\", \"warn\");\n-    // if we are building as part of the rustc test suite, we already have fullmir for everything\n-    if fullmir && rustc_test_suite().is_none() {\n-        if host != target {\n-            // skip fullmir on nonhost\n-            return;\n-        }\n-        let sysroot = std::env::home_dir().unwrap()\n-            .join(\".xargo\")\n-            .join(\"HOST\");\n-\n-        flags.push(format!(\"--sysroot {}\", sysroot.to_str().unwrap()));\n-    }\n-    if opt {\n-        flags.push(\"-Zmir-opt-level=3\".to_owned());\n-    } else {\n-        flags.push(\"-Zmir-opt-level=0\".to_owned());\n-        // For now, only validate without optimizations.  Inlining breaks validation.\n-        flags.push(\"-Zmir-emit-validate=1\".to_owned());\n-    }\n-    config.target_rustcflags = Some(flags.join(\" \"));\n-    compiletest::run_tests(&config);\n-}\n-\n-fn is_target_dir<P: Into<PathBuf>>(path: P) -> bool {\n-    let mut path = path.into();\n-    path.push(\"lib\");\n-    path.metadata().map(|m| m.is_dir()).unwrap_or(false)\n-}\n-\n-fn for_all_targets<F: FnMut(String)>(sysroot: &Path, mut f: F) {\n-    let target_dir = sysroot.join(\"lib\").join(\"rustlib\");\n-    for entry in std::fs::read_dir(target_dir).expect(\"invalid sysroot\") {\n-        let entry = entry.unwrap();\n-        if !is_target_dir(entry.path()) {\n-            continue;\n-        }\n-        let target = entry.file_name().into_string().unwrap();\n-        f(target);\n-    }\n-}\n-\n-fn get_sysroot() -> PathBuf {\n-    let sysroot = std::env::var(\"MIRI_SYSROOT\").unwrap_or_else(|_| {\n-        let sysroot = std::process::Command::new(\"rustc\")\n-            .arg(\"--print\")\n-            .arg(\"sysroot\")\n-            .output()\n-            .expect(\"rustc not found\")\n-            .stdout;\n-        String::from_utf8(sysroot).expect(\"sysroot is not utf8\")\n-    });\n-    PathBuf::from(sysroot.trim())\n-}\n-\n-fn get_host() -> String {\n-    let rustc = rustc_test_suite().unwrap_or(PathBuf::from(\"rustc\"));\n-    println!(\"using rustc at {}\", rustc.display());\n-    let host = std::process::Command::new(rustc)\n-        .arg(\"-vV\")\n-        .output()\n-        .expect(\"rustc not found for -vV\")\n-        .stdout;\n-    let host = std::str::from_utf8(&host).expect(\"sysroot is not utf8\");\n-    let host = host.split(\"\\nhost: \").nth(1).expect(\n-        \"no host: part in rustc -vV\",\n-    );\n-    let host = host.split('\\n').next().expect(\"no \\n after host\");\n-    String::from(host)\n-}\n-\n-fn run_pass_miri(opt: bool) {\n-    let sysroot = get_sysroot();\n-    let host = get_host();\n-\n-    for_all_targets(&sysroot, |target| {\n-        miri_pass(\"tests/run-pass\", &target, &host, false, opt);\n-    });\n-    miri_pass(\"tests/run-pass-fullmir\", &host, &host, true, opt);\n-}\n-\n-#[test]\n-fn run_pass_miri_noopt() {\n-    run_pass_miri(false);\n-}\n-\n-#[test]\n-#[ignore] // FIXME: Disabled for now, as the optimizer is pretty broken and crashes...\n-fn run_pass_miri_opt() {\n-    run_pass_miri(true);\n-}\n-\n-#[test]\n-fn run_pass_rustc() {\n-    run_pass(\"tests/run-pass\");\n-    run_pass(\"tests/run-pass-fullmir\");\n-}\n-\n-#[test]\n-fn compile_fail_miri() {\n-    let sysroot = get_sysroot();\n-    let host = get_host();\n-\n-    for_all_targets(&sysroot, |target| {\n-        compile_fail(&sysroot, \"tests/compile-fail\", &target, &host, false);\n-    });\n-    compile_fail(&sysroot, \"tests/compile-fail-fullmir\", &host, &host, true);\n-}"}, {"sha": "490f17d4cf4f52305f3a6d24d6b38ed55e64cd68", "filename": "tests/run-pass-fullmir/catch.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fcatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fcatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fcatch.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-//ignore-msvc\n-use std::panic::{catch_unwind, AssertUnwindSafe};\n-\n-fn main() {\n-    let mut i = 3;\n-    let _ = catch_unwind(AssertUnwindSafe(|| {i -= 2;} ));\n-    println!(\"{}\", i);\n-}"}, {"sha": "d00491fd7e5bb6fa28c517a0bb32b8b506539d4d", "filename": "tests/run-pass-fullmir/catch.stdout", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fcatch.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fcatch.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fcatch.stdout?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1 +0,0 @@\n-1"}, {"sha": "20cb713590c951c8be62b21945fee0f3ba4900eb", "filename": "tests/run-pass-fullmir/foreign-fn-linkname.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-msvc\n-#![feature(libc)]\n-\n-extern crate libc;\n-use std::ffi::CString;\n-\n-mod mlibc {\n-    use libc::{c_char, size_t};\n-\n-    extern {\n-        #[link_name = \"strlen\"]\n-        pub fn my_strlen(str: *const c_char) -> size_t;\n-    }\n-}\n-\n-fn strlen(str: String) -> usize {\n-    // C string is terminated with a zero\n-    let s = CString::new(str).unwrap();\n-    unsafe {\n-        mlibc::my_strlen(s.as_ptr()) as usize\n-    }\n-}\n-\n-pub fn main() {\n-    let len = strlen(\"Rust\".to_string());\n-    assert_eq!(len, 4);\n-}"}, {"sha": "a14d7054e72902011bc64282513b53065d132b6f", "filename": "tests/run-pass-fullmir/format.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fformat.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-//ignore-msvc\n-fn main() {\n-    println!(\"Hello {}\", 13);\n-}"}, {"sha": "e193b8ae89f8f1b03bf59f94b5198d7c7508cc67", "filename": "tests/run-pass-fullmir/format.stdout", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fformat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fformat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fformat.stdout?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1 +0,0 @@\n-Hello 13"}, {"sha": "c5d4abcfdaeff8711be11c2625b27baa3e46fb04", "filename": "tests/run-pass-fullmir/from_utf8.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Ffrom_utf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Ffrom_utf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Ffrom_utf8.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-//ignore-msvc\n-fn main() {\n-    let _ = ::std::str::from_utf8(b\"a\");\n-}"}, {"sha": "99f05e25985eea482580e4f1a41aaa28ca236b47", "filename": "tests/run-pass-fullmir/hashmap.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhashmap.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,26 +0,0 @@\n-//ignore-msvc\n-use std::collections::{self, HashMap};\n-use std::hash::BuildHasherDefault;\n-\n-fn main() {\n-    let mut map : HashMap<i32, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = Default::default();\n-    map.insert(0, 0);\n-    assert_eq!(map.values().fold(0, |x, y| x+y), 0);\n-\n-    let table_base = map.get(&0).unwrap() as *const _;\n-\n-    let num = 22; // large enough to trigger a resize\n-    for i in 1..num {\n-        map.insert(i, i);\n-    }\n-    assert!(table_base != map.get(&0).unwrap() as *const _); // make sure relocation happened\n-    assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2); // check the right things are in the table now\n-\n-    // Inserting again replaces the existing entries\n-    for i in 0..num {\n-        map.insert(i, num-1-i);\n-    }\n-    assert_eq!(map.values().fold(0, |x, y| x+y), num*(num-1)/2);\n-\n-    // TODO: Test Entry API\n-}"}, {"sha": "917d51d0e4b654b71de324efebf5fc2dac7c9053", "filename": "tests/run-pass-fullmir/heap.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fheap.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,35 +0,0 @@\n-//ignore-msvc\n-#![feature(box_syntax)]\n-\n-fn make_box() -> Box<(i16, i16)> {\n-    Box::new((1, 2))\n-}\n-\n-fn make_box_syntax() -> Box<(i16, i16)> {\n-    box (1, 2)\n-}\n-\n-fn allocate_reallocate() {\n-    let mut s = String::new();\n-\n-    // 6 byte heap alloc (__rust_allocate)\n-    s.push_str(\"foobar\");\n-    assert_eq!(s.len(), 6);\n-    assert_eq!(s.capacity(), 6);\n-\n-    // heap size doubled to 12 (__rust_reallocate)\n-    s.push_str(\"baz\");\n-    assert_eq!(s.len(), 9);\n-    assert_eq!(s.capacity(), 12);\n-\n-    // heap size reduced to 9  (__rust_reallocate)\n-    s.shrink_to_fit();\n-    assert_eq!(s.len(), 9);\n-    assert_eq!(s.capacity(), 9);\n-}\n-\n-fn main() {\n-    assert_eq!(*make_box(), (1, 2));\n-    assert_eq!(*make_box_syntax(), (1, 2));\n-    allocate_reallocate();\n-}"}, {"sha": "986efcaf9005a830817163df554b98800274178b", "filename": "tests/run-pass-fullmir/hello.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhello.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-//ignore-msvc\n-fn main() {\n-    println!(\"Hello, world!\");\n-}"}, {"sha": "af5626b4a114abcb82d63db7c8082c3c4756e51b", "filename": "tests/run-pass-fullmir/hello.stdout", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fhello.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fhello.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhello.stdout?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1 +0,0 @@\n-Hello, world!"}, {"sha": "97c694fd5674e3baa80da620d36198e00a5930cd", "filename": "tests/run-pass-fullmir/integer-ops.rs", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Finteger-ops.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,175 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME: remove -Zmir-opt-level once https://github.com/rust-lang/rust/issues/43359 is fixed\n-// compile-flags: -Zmir-opt-level=0\n-\n-//ignore-msvc\n-use std::i32;\n-\n-pub fn main() {\n-    // This tests that do (not) do sign extension properly when loading integers\n-    assert_eq!(u32::max_value() as i64, 4294967295);\n-    assert_eq!(i32::min_value() as i64, -2147483648);\n-\n-    assert_eq!(i8::min_value(), -128);\n-\n-    assert_eq!(i8::max_value(), 127);\n-\n-    assert_eq!(i32::from_str_radix(\"A\", 16), Ok(10));\n-\n-    let n = -0b1000_0000i8;\n-    assert_eq!(n.count_ones(), 1);\n-\n-    let n = -0b1000_0000i8;\n-    assert_eq!(n.count_zeros(), 7);\n-\n-    let n = -1i16;\n-    assert_eq!(n.leading_zeros(), 0);\n-\n-    let n = -4i8;\n-    assert_eq!(n.trailing_zeros(), 2);\n-\n-    let n = 0x0123456789ABCDEFi64;\n-    let m = -0x76543210FEDCBA99i64;\n-    assert_eq!(n.rotate_left(32), m);\n-\n-    let n = 0x0123456789ABCDEFi64;\n-    let m = -0xFEDCBA987654322i64;\n-    assert_eq!(n.rotate_right(4), m);\n-\n-    let n =  0x0123456789ABCDEFi64;\n-    let m = -0x1032547698BADCFFi64;\n-    assert_eq!(n.swap_bytes(), m);\n-\n-    let n = 0x0123456789ABCDEFi64;\n-    if cfg!(target_endian = \"big\") {\n-        assert_eq!(i64::from_be(n), n)\n-    } else {\n-        assert_eq!(i64::from_be(n), n.swap_bytes())\n-    }\n-\n-    let n = 0x0123456789ABCDEFi64;\n-    if cfg!(target_endian = \"little\") {\n-        assert_eq!(i64::from_le(n), n)\n-    } else {\n-        assert_eq!(i64::from_le(n), n.swap_bytes())\n-    }\n-\n-    let n = 0x0123456789ABCDEFi64;\n-    if cfg!(target_endian = \"big\") {\n-        assert_eq!(n.to_be(), n)\n-    } else {\n-        assert_eq!(n.to_be(), n.swap_bytes())\n-    }\n-\n-    let n = 0x0123456789ABCDEFi64;\n-    if cfg!(target_endian = \"little\") {\n-        assert_eq!(n.to_le(), n)\n-    } else {\n-        assert_eq!(n.to_le(), n.swap_bytes())\n-    }\n-\n-    assert_eq!(7i16.checked_add(32760), Some(32767));\n-    assert_eq!(8i16.checked_add(32760), None);\n-\n-    assert_eq!((-127i8).checked_sub(1), Some(-128));\n-    assert_eq!((-128i8).checked_sub(1), None);\n-\n-    assert_eq!(6i8.checked_mul(21), Some(126));\n-    assert_eq!(6i8.checked_mul(22), None);\n-\n-    assert_eq!((-127i8).checked_div(-1), Some(127));\n-    assert_eq!((-128i8).checked_div(-1), None);\n-    assert_eq!((1i8).checked_div(0), None);\n-\n-    assert_eq!(5i32.checked_rem(2), Some(1));\n-    assert_eq!(5i32.checked_rem(0), None);\n-    assert_eq!(i32::MIN.checked_rem(-1), None);\n-\n-    assert_eq!(5i32.checked_neg(), Some(-5));\n-    assert_eq!(i32::MIN.checked_neg(), None);\n-\n-    assert_eq!(0x10i32.checked_shl(4), Some(0x100));\n-    assert_eq!(0x10i32.checked_shl(33), None);\n-\n-    assert_eq!(0x10i32.checked_shr(4), Some(0x1));\n-    assert_eq!(0x10i32.checked_shr(33), None);\n-\n-    assert_eq!((-5i32).checked_abs(), Some(5));\n-    assert_eq!(i32::MIN.checked_abs(), None);\n-\n-    assert_eq!(100i8.saturating_add(1), 101);\n-    assert_eq!(100i8.saturating_add(127), 127);\n-\n-    assert_eq!(100i8.saturating_sub(127), -27);\n-    assert_eq!((-100i8).saturating_sub(127), -128);\n-\n-    assert_eq!(100i32.saturating_mul(127), 12700);\n-    assert_eq!((1i32 << 23).saturating_mul(1 << 23), i32::MAX);\n-    assert_eq!((-1i32 << 23).saturating_mul(1 << 23), i32::MIN);\n-\n-    assert_eq!(100i8.wrapping_add(27), 127);\n-    assert_eq!(100i8.wrapping_add(127), -29);\n-\n-    assert_eq!(0i8.wrapping_sub(127), -127);\n-    assert_eq!((-2i8).wrapping_sub(127), 127);\n-\n-    assert_eq!(10i8.wrapping_mul(12), 120);\n-    assert_eq!(11i8.wrapping_mul(12), -124);\n-\n-    assert_eq!(100u8.wrapping_div(10), 10);\n-    assert_eq!((-128i8).wrapping_div(-1), -128);\n-\n-    assert_eq!(100i8.wrapping_rem(10), 0);\n-    assert_eq!((-128i8).wrapping_rem(-1), 0);\n-\n-    assert_eq!(100i8.wrapping_neg(), -100);\n-    assert_eq!((-128i8).wrapping_neg(), -128);\n-\n-    assert_eq!((-1i8).wrapping_shl(7), -128);\n-    assert_eq!((-1i8).wrapping_shl(8), -1);\n-\n-    assert_eq!((-128i8).wrapping_shr(7), -1);\n-    assert_eq!((-128i8).wrapping_shr(8), -128);\n-\n-    assert_eq!(100i8.wrapping_abs(), 100);\n-    assert_eq!((-100i8).wrapping_abs(), 100);\n-    assert_eq!((-128i8).wrapping_abs(), -128);\n-    assert_eq!((-128i8).wrapping_abs() as u8, 128);\n-\n-    assert_eq!(5i32.overflowing_add(2), (7, false));\n-    assert_eq!(i32::MAX.overflowing_add(1), (i32::MIN, true));\n-\n-    assert_eq!(5i32.overflowing_sub(2), (3, false));\n-    assert_eq!(i32::MIN.overflowing_sub(1), (i32::MAX, true));\n-\n-    assert_eq!(5i32.overflowing_mul(2), (10, false));\n-    assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n-\n-    assert_eq!(5i32.overflowing_div(2), (2, false));\n-    assert_eq!(i32::MIN.overflowing_div(-1), (i32::MIN, true));\n-\n-    assert_eq!(5i32.overflowing_rem(2), (1, false));\n-    assert_eq!(i32::MIN.overflowing_rem(-1), (0, true));\n-\n-    assert_eq!(2i32.overflowing_neg(), (-2, false));\n-    assert_eq!(i32::MIN.overflowing_neg(), (i32::MIN, true));\n-\n-    assert_eq!(0x10i32.overflowing_shl(4), (0x100, false));\n-    assert_eq!(0x10i32.overflowing_shl(36), (0x100, true));\n-\n-    assert_eq!(0x10i32.overflowing_shr(4), (0x1, false));\n-    assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n-    \n-    assert_eq!(10i8.overflowing_abs(), (10,false));\n-    assert_eq!((-10i8).overflowing_abs(), (10,false));\n-    assert_eq!((-128i8).overflowing_abs(), (-128,true));\n-}"}, {"sha": "4a84f2bc5d62d60fa29453dc6eeef69450ad8be1", "filename": "tests/run-pass-fullmir/issue-15080.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fissue-15080.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-msvc\n-\n-#![feature(slice_patterns)]\n-\n-fn main() {\n-    let mut x: &[_] = &[1, 2, 3, 4];\n-\n-    let mut result = vec!();\n-    loop {\n-        x = match *x {\n-            [1, n, 3, ref rest..] => {\n-                result.push(n);\n-                rest\n-            }\n-            [n, ref rest..] => {\n-                result.push(n);\n-                rest\n-            }\n-            [] =>\n-                break\n-        }\n-    }\n-    assert_eq!(result, [2, 4]);\n-}"}, {"sha": "8d55af58eeca8c8087b58f16674eec3c9582c040", "filename": "tests/run-pass-fullmir/issue-3794.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fissue-3794.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-msvc\n-#![feature(box_syntax)]\n-\n-trait T {\n-    fn print(&self);\n-}\n-\n-#[derive(Debug)]\n-struct S {\n-    s: isize,\n-}\n-\n-impl T for S {\n-    fn print(&self) {\n-        println!(\"{:?}\", self);\n-    }\n-}\n-\n-fn print_t(t: &T) {\n-    t.print();\n-}\n-\n-fn print_s(s: &S) {\n-    s.print();\n-}\n-\n-pub fn main() {\n-    let s: Box<S> = box S { s: 5 };\n-    print_s(&*s);\n-    let t: Box<T> = s as Box<T>;\n-    print_t(&*t);\n-}"}, {"sha": "e4afe6fa55f15d1365fed3357bd886e509688029", "filename": "tests/run-pass-fullmir/issue-3794.stdout", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fissue-3794.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fissue-3794.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fissue-3794.stdout?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,2 +0,0 @@\n-S { s: 5 }\n-S { s: 5 }"}, {"sha": "8a0ea113c5d6250ea5ebb4277a35ecb4f583a119", "filename": "tests/run-pass-fullmir/loop-break-value.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Floop-break-value.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,143 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-msvc\n-\n-#![feature(never_type)]\n-#![allow(unreachable_code)]\n-\n-#[allow(unused)]\n-fn never_returns() {\n-    loop {\n-        break loop {};\n-    }\n-}\n-\n-pub fn main() {\n-    let value = 'outer: loop {\n-        if 1 == 1 {\n-            break 13;\n-        } else {\n-            let _never: ! = loop {\n-                break loop {\n-                    break 'outer panic!();\n-                }\n-            };\n-        }\n-    };\n-    assert_eq!(value, 13);\n-\n-    let x = [1, 3u32, 5];\n-    let y = [17];\n-    let z = [];\n-    let coerced: &[_] = loop {\n-        match 2 {\n-            1 => break &x,\n-            2 => break &y,\n-            3 => break &z,\n-            _ => (),\n-        }\n-    };\n-    assert_eq!(coerced, &[17u32]);\n-\n-    let trait_unified = loop {\n-        break if true {\n-            break Default::default()\n-        } else {\n-            break [13, 14]\n-        };\n-    };\n-    assert_eq!(trait_unified, [0, 0]);\n-\n-    let trait_unified_2 = loop {\n-        if false {\n-            break [String::from(\"Hello\")]\n-        } else {\n-            break Default::default()\n-        };\n-    };\n-    assert_eq!(trait_unified_2, [\"\"]);\n-\n-    let trait_unified_3 = loop {\n-        break if false {\n-            break [String::from(\"Hello\")]\n-        } else {\n-            [\"Yes\".into()]\n-        };\n-    };\n-    assert_eq!(trait_unified_3, [\"Yes\"]);\n-\n-    let regular_break = loop {\n-        if true {\n-            break;\n-        } else {\n-            break break Default::default();\n-        }\n-    };\n-    assert_eq!(regular_break, ());\n-\n-    let regular_break_2 = loop {\n-        if true {\n-            break Default::default();\n-        } else {\n-            break;\n-        }\n-    };\n-    assert_eq!(regular_break_2, ());\n-\n-    let regular_break_3 = loop {\n-        break if true {\n-            Default::default()\n-        } else {\n-            break;\n-        }\n-    };\n-    assert_eq!(regular_break_3, ());\n-\n-    let regular_break_4 = loop {\n-        break ();\n-        break;\n-    };\n-    assert_eq!(regular_break_4, ());\n-\n-    let regular_break_5 = loop {\n-        break;\n-        break ();\n-    };\n-    assert_eq!(regular_break_5, ());\n-\n-    let nested_break_value = 'outer2: loop {\n-        let _a: u32 = 'inner: loop {\n-            if true {\n-                break 'outer2 \"hello\";\n-            } else {\n-                break 'inner 17;\n-            }\n-        };\n-        panic!();\n-    };\n-    assert_eq!(nested_break_value, \"hello\");\n-\n-    let break_from_while_cond = loop {\n-        'inner_loop: while break 'inner_loop {\n-            panic!();\n-        }\n-        break 123;\n-    };\n-    assert_eq!(break_from_while_cond, 123);\n-\n-    let break_from_while_to_outer = 'outer_loop: loop {\n-        while break 'outer_loop 567 {\n-            panic!(\"from_inner\");\n-        }\n-        panic!(\"from outer\");\n-    };\n-    assert_eq!(break_from_while_to_outer, 567);\n-}"}, {"sha": "f3c656623765fedbdede95cfa23a62ad35ecffaa", "filename": "tests/run-pass-fullmir/move-arg-2-unique.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fmove-arg-2-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fmove-arg-2-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fmove-arg-2-unique.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-msvc\n-\n-#![allow(unused_features, unused_variables)]\n-#![feature(box_syntax)]\n-\n-fn test(foo: Box<Vec<isize>> ) { assert_eq!((*foo)[0], 10); }\n-\n-pub fn main() {\n-    let x = box vec![10];\n-    // Test forgetting a local by move-in\n-    test(x);\n-}"}, {"sha": "cef62e47a56c2a3756d521d2d864dfb0772c1ebf", "filename": "tests/run-pass-fullmir/regions-mock-trans.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fregions-mock-trans.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME: We handle uninitialzied storage here, which currently makes validation fail.\n-// compile-flags: -Zmir-emit-validate=0\n-\n-//ignore-msvc\n-\n-#![feature(libc)]\n-\n-#![allow(dead_code)]\n-\n-extern crate libc;\n-use std::mem;\n-\n-struct Arena(());\n-\n-struct Bcx<'a> {\n-    fcx: &'a Fcx<'a>\n-}\n-\n-struct Fcx<'a> {\n-    arena: &'a Arena,\n-    ccx: &'a Ccx\n-}\n-\n-struct Ccx {\n-    x: isize\n-}\n-\n-fn alloc<'a>(_bcx : &'a Arena) -> &'a Bcx<'a> {\n-    unsafe {\n-        mem::transmute(libc::malloc(mem::size_of::<Bcx<'a>>()\n-            as libc::size_t))\n-    }\n-}\n-\n-fn h<'a>(bcx : &'a Bcx<'a>) -> &'a Bcx<'a> {\n-    return alloc(bcx.fcx.arena);\n-}\n-\n-fn g(fcx : &Fcx) {\n-    let bcx = Bcx { fcx: fcx };\n-    let bcx2 = h(&bcx);\n-    unsafe {\n-        libc::free(mem::transmute(bcx2));\n-    }\n-}\n-\n-fn f(ccx : &Ccx) {\n-    let a = Arena(());\n-    let fcx = Fcx { arena: &a, ccx: ccx };\n-    return g(&fcx);\n-}\n-\n-pub fn main() {\n-    let ccx = Ccx { x: 0 };\n-    f(&ccx);\n-}"}, {"sha": "5b2efdd20517071732fda6c299716d36702ab4ed", "filename": "tests/run-pass-fullmir/u128.rs", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fu128.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,79 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-msvc\n-\n-#![feature(i128_type)]\n-\n-fn b<T>(t: T) -> T { t }\n-\n-fn main() {\n-    let x: u128 = 0xFFFF_FFFF_FFFF_FFFF__FFFF_FFFF_FFFF_FFFF;\n-    assert_eq!(0, !x);\n-    assert_eq!(0, !x);\n-    let y: u128 = 0xFFFF_FFFF_FFFF_FFFF__FFFF_FFFF_FFFF_FFFE;\n-    assert_eq!(!1, y);\n-    assert_eq!(x, y | 1);\n-    assert_eq!(0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFE,\n-               y &\n-               0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFF);\n-    let z: u128 = 0xABCD_EF;\n-    assert_eq!(z * z, 0x734C_C2F2_A521);\n-    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n-    assert_eq!(z + z + z + z, 0x2AF3_7BC);\n-    let k: u128 = 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210;\n-    assert_eq!(k + k, 0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n-    assert_eq!(0, k - k);\n-    assert_eq!(0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k - z);\n-    assert_eq!(0x1000_0000_0000_0000_0000_0000_0000_000,\n-               k - 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n-    assert_eq!(0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n-    assert_eq!(0, k % 42);\n-    assert_eq!(15, z % 42);\n-    assert_eq!(0x169D_A8020_CEC18, k % 0x3ACB_FE49_FF24_AC);\n-    assert_eq!(0x91A2_B3C4_D5E6_F7, k >> 65);\n-    assert_eq!(0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n-    assert!(k > z);\n-    assert!(y > k);\n-    assert!(y < x);\n-    assert_eq!(x as u64, !0);\n-    assert_eq!(z as u64, 0xABCD_EF);\n-    assert_eq!(k as u64, 0xFEDC_BA98_7654_3210);\n-    assert_eq!(k as i128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n-    assert_eq!((z as f64) as u128, z);\n-    assert_eq!((z as f32) as u128, z);\n-    assert_eq!((z as f64 * 16.0) as u128, z * 16);\n-    assert_eq!((z as f32 * 16.0) as u128, z * 16);\n-    let l :u128 = 432 << 100;\n-    assert_eq!((l as f32) as u128, l);\n-    assert_eq!((l as f64) as u128, l);\n-    // formatting\n-    let j: u128 = 1 << 67;\n-    assert_eq!(\"147573952589676412928\", format!(\"{}\", j));\n-    assert_eq!(\"80000000000000000\", format!(\"{:x}\", j));\n-    assert_eq!(\"20000000000000000000000\", format!(\"{:o}\", j));\n-    assert_eq!(\"10000000000000000000000000000000000000000000000000000000000000000000\",\n-               format!(\"{:b}\", j));\n-    assert_eq!(\"340282366920938463463374607431768211455\",\n-        format!(\"{}\", u128::max_value()));\n-    assert_eq!(\"147573952589676412928\", format!(\"{:?}\", j));\n-    // common traits\n-    assert_eq!(x, b(x.clone()));\n-    // overflow checks\n-    assert_eq!((z).checked_mul(z), Some(0x734C_C2F2_A521));\n-    assert_eq!((k).checked_mul(k), None);\n-    let l: u128 = b(u128::max_value() - 10);\n-    let o: u128 = b(17);\n-    assert_eq!(l.checked_add(b(11)), None);\n-    assert_eq!(l.checked_sub(l), Some(0));\n-    assert_eq!(o.checked_sub(b(18)), None);\n-    assert_eq!(b(1u128).checked_shl(b(127)), Some(1 << 127));\n-    assert_eq!(o.checked_shl(b(128)), None);\n-}"}, {"sha": "828e5c26927ec09ae81bb22b46a180f7f45f6ada", "filename": "tests/run-pass-fullmir/unsized-tuple-impls.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Funsized-tuple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Funsized-tuple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Funsized-tuple-impls.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-msvc\n-\n-#![feature(unsized_tuple_coercion)]\n-use std::mem;\n-\n-fn main() {\n-    let x : &(i32, i32, [i32]) = &(0, 1, [2, 3]);\n-    let y : &(i32, i32, [i32]) = &(0, 1, [2, 3, 4]);\n-    let mut a = [y, x];\n-    a.sort();\n-    assert_eq!(a, [x, y]);\n-\n-    assert_eq!(&format!(\"{:?}\", a), \"[(0, 1, [2, 3]), (0, 1, [2, 3, 4])]\");\n-    assert_eq!(mem::size_of_val(x), 16);\n-}"}, {"sha": "9a8912a6b98897cc527c2e2c5a85aef216e5f23e", "filename": "tests/run-pass-fullmir/vecs.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fvecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass-fullmir%2Fvecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fvecs.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,52 +0,0 @@\n-//ignore-msvc\n-\n-fn make_vec() -> Vec<u8> {\n-    let mut v = Vec::with_capacity(4);\n-    v.push(1);\n-    v.push(2);\n-    v\n-}\n-\n-fn make_vec_macro() -> Vec<u8> {\n-    vec![1, 2]\n-}\n-\n-fn make_vec_macro_repeat() -> Vec<u8> {\n-    vec![42; 5]\n-}\n-\n-fn make_vec_macro_repeat_zeroed() -> Vec<u8> {\n-    vec![0; 7]\n-}\n-\n-fn vec_into_iter() -> u8 {\n-    vec![1, 2, 3, 4]\n-        .into_iter()\n-        .map(|x| x * x)\n-        .fold(0, |x, y| x + y)\n-}\n-\n-fn vec_into_iter_zst() -> usize {\n-    vec![[0u64; 0], [0u64; 0]]\n-        .into_iter()\n-        .map(|x| x.len())\n-        .sum()\n-}\n-\n-fn vec_reallocate() -> Vec<u8> {\n-    let mut v = vec![1, 2];\n-    v.push(3);\n-    v.push(4);\n-    v.push(5);\n-    v\n-}\n-\n-fn main() {\n-    assert_eq!(vec_reallocate().len(), 5);\n-    assert_eq!(vec_into_iter(), 30);\n-    assert_eq!(vec_into_iter_zst(), 0);\n-    assert_eq!(make_vec().capacity(), 4);\n-    assert_eq!(make_vec_macro(), [1, 2]);\n-    assert_eq!(make_vec_macro_repeat(), [42; 5]);\n-    assert_eq!(make_vec_macro_repeat_zeroed(), [0; 7]);\n-}"}, {"sha": "469dde3091eb25993c7b4d69bc5f4fb12f437444", "filename": "tests/run-pass/arrays.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Farrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Farrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Farrays.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,45 +0,0 @@\n-fn empty_array() -> [u16; 0] {\n-    []\n-}\n-\n-fn mini_array() -> [u16; 1] {\n-    [42]\n-}\n-\n-fn big_array() -> [u16; 5] {\n-    [5, 4, 3, 2, 1]\n-}\n-\n-fn array_array() -> [[u8; 2]; 3] {\n-    [[5, 4], [3, 2], [1, 0]]\n-}\n-\n-fn index_unsafe() -> i32 {\n-    let a = [0, 10, 20, 30];\n-    unsafe { *a.get_unchecked(2) }\n-}\n-\n-fn index() -> i32 {\n-    let a = [0, 10, 20, 30];\n-    a[2]\n-}\n-\n-fn array_repeat() -> [u8; 8] {\n-    [42; 8]\n-}\n-\n-fn slice_index() -> u8 {\n-    let arr: &[_] = &[101, 102, 103, 104, 105, 106];\n-    arr[5]\n-}\n-\n-fn main() {\n-    assert_eq!(empty_array(), []);\n-    assert_eq!(index_unsafe(), 20);\n-    assert_eq!(index(), 20);\n-    assert_eq!(slice_index(), 106);\n-    assert_eq!(big_array(), [5, 4, 3, 2, 1]);\n-    assert_eq!(array_array(), [[5, 4], [3, 2], [1, 0]]);\n-    assert_eq!(array_repeat(), [42; 8]);\n-    assert_eq!(mini_array(), [42]);\n-}"}, {"sha": "fe5da49f807d57cb409f38fa4c9162c516f37a3d", "filename": "tests/run-pass/associated-const.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fassociated-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fassociated-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fassociated-const.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait Foo {\n-    const ID: i32;\n-}\n-\n-impl Foo for i32 {\n-    const ID: i32 = 1;\n-}\n-\n-fn main() {\n-    assert_eq!(1, <i32 as Foo>::ID);\n-}"}, {"sha": "e14f875c022e3fabd4a06ae5e1fd25551be267fe", "filename": "tests/run-pass/assume_bug.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fassume_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fassume_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fassume_bug.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,3 +0,0 @@\n-fn main() {\n-    vec![()].into_iter();\n-}"}, {"sha": "ada584705401f3dd3f71431c4b223e5b001a5838", "filename": "tests/run-pass/atomic-access-bool.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fatomic-access-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fatomic-access-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fatomic-access-bool.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT};\n-use std::sync::atomic::Ordering::*;\n-\n-static mut ATOMIC: AtomicBool = ATOMIC_BOOL_INIT;\n-\n-fn main() {\n-    unsafe {\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-        ATOMIC.store(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_or(false, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_and(false, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-        ATOMIC.fetch_nand(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_xor(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-    }\n-}"}, {"sha": "61e9a965889669556d36c798a322e28e3deda2f4", "filename": "tests/run-pass/atomic-compare_exchange.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fatomic-compare_exchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fatomic-compare_exchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fatomic-compare_exchange.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT};\n-use std::sync::atomic::Ordering::*;\n-\n-static ATOMIC: AtomicIsize = ATOMIC_ISIZE_INIT;\n-\n-fn main() {\n-    // Make sure trans can emit all the intrinsics correctly\n-    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();\n-    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();\n-    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n-    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n-}"}, {"sha": "beed82e058029681b73495548cea7c316098ba2c", "filename": "tests/run-pass/aux_test.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Faux_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Faux_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Faux_test.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-// aux-build:dep.rs\n-\n-// ignore-cross-compile\n-\n-extern crate dep;\n-\n-fn main() {\n-    dep::foo();\n-}"}, {"sha": "b76b4321d62aa8e066b24d213c79ccc8230b8d7b", "filename": "tests/run-pass/auxiliary/dep.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fauxiliary%2Fdep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fauxiliary%2Fdep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fauxiliary%2Fdep.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1 +0,0 @@\n-pub fn foo() {}"}, {"sha": "d8da2de5d6df9f5f6642a7ab957cd1f660f60c7b", "filename": "tests/run-pass/bad_substs.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbad_substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbad_substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbad_substs.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let f: fn(i32) -> Option<i32> = Some::<i32>;\n-    f(42);\n-}"}, {"sha": "a03b96fa499fdbae3deb52e2f1125a4da39fbbd9", "filename": "tests/run-pass/binops.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbinops.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Binop corner cases\n-\n-fn test_nil() {\n-    assert_eq!((), ());\n-    assert!((!(() != ())));\n-    assert!((!(() < ())));\n-    assert!((() <= ()));\n-    assert!((!(() > ())));\n-    assert!((() >= ()));\n-}\n-\n-fn test_bool() {\n-    assert!((!(true < false)));\n-    assert!((!(true <= false)));\n-    assert!((true > false));\n-    assert!((true >= false));\n-\n-    assert!((false < true));\n-    assert!((false <= true));\n-    assert!((!(false > true)));\n-    assert!((!(false >= true)));\n-\n-    // Bools support bitwise binops\n-    assert_eq!(false & false, false);\n-    assert_eq!(true & false, false);\n-    assert_eq!(true & true, true);\n-    assert_eq!(false | false, false);\n-    assert_eq!(true | false, true);\n-    assert_eq!(true | true, true);\n-    assert_eq!(false ^ false, false);\n-    assert_eq!(true ^ false, true);\n-    assert_eq!(true ^ true, false);\n-}\n-\n-fn test_ptr() {\n-    unsafe {\n-        let p1: *const u8 = ::std::mem::transmute(0_usize);\n-        let p2: *const u8 = ::std::mem::transmute(0_usize);\n-        let p3: *const u8 = ::std::mem::transmute(1_usize);\n-\n-        assert_eq!(p1, p2);\n-        assert!(p1 != p3);\n-        assert!(p1 < p3);\n-        assert!(p1 <= p3);\n-        assert!(p3 > p1);\n-        assert!(p3 >= p3);\n-        assert!(p1 <= p2);\n-        assert!(p1 >= p2);\n-    }\n-}\n-\n-#[derive(PartialEq, Debug)]\n-struct P {\n-    x: isize,\n-    y: isize,\n-}\n-\n-fn p(x: isize, y: isize) -> P {\n-    P {\n-        x: x,\n-        y: y\n-    }\n-}\n-\n-fn test_class() {\n-  let q = p(1, 2);\n-  let mut r = p(1, 2);\n-\n-  assert_eq!(q, r);\n-  r.y = 17;\n-  assert!((r.y != q.y));\n-  assert_eq!(r.y, 17);\n-  assert!((q != r));\n-}\n-\n-pub fn main() {\n-    test_nil();\n-    test_bool();\n-    test_ptr();\n-    test_class();\n-}"}, {"sha": "103d7eac27cde9971a0b8dd22ca5beee487db430", "filename": "tests/run-pass/bools.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbools.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,28 +0,0 @@\n-fn boolean() -> bool {\n-    true\n-}\n-\n-fn if_false() -> i64 {\n-    let c = false;\n-    if c { 1 } else { 0 }\n-}\n-\n-fn if_true() -> i64 {\n-    let c = true;\n-    if c { 1 } else { 0 }\n-}\n-\n-fn match_bool() -> i16 {\n-    let b = true;\n-    match b {\n-        true => 1,\n-        _ => 0,\n-    }\n-}\n-\n-fn main() {\n-    assert!(boolean());\n-    assert_eq!(if_false(), 0);\n-    assert_eq!(if_true(), 1);\n-    assert_eq!(match_bool(), 1);\n-}"}, {"sha": "57eef52d573b9e4c6b3acb3d1a8d910c5af3b6eb", "filename": "tests/run-pass/box_box_trait.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbox_box_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbox_box_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbox_box_trait.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,29 +0,0 @@\n-#![feature(box_syntax)]\n-\n-struct DroppableStruct;\n-\n-static mut DROPPED: bool = false;\n-\n-impl Drop for DroppableStruct {\n-    fn drop(&mut self) {\n-        unsafe { DROPPED = true; }\n-    }\n-}\n-\n-trait MyTrait { fn dummy(&self) { } }\n-impl MyTrait for Box<DroppableStruct> {}\n-\n-struct Whatever { w: Box<MyTrait+'static> }\n-impl  Whatever {\n-    fn new(w: Box<MyTrait+'static>) -> Whatever {\n-        Whatever { w: w }\n-    }\n-}\n-\n-fn main() {\n-    {\n-        let f: Box<_> = box DroppableStruct;\n-        let _a = Whatever::new(box f as Box<MyTrait>);\n-    }\n-    assert!(unsafe { DROPPED });\n-}"}, {"sha": "0fd28d6f1e8df607974629d87c80e3173d356c39", "filename": "tests/run-pass/btreemap.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbtreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fbtreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbtreemap.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,17 +0,0 @@\n-// mir validation can't cope with `mem::uninitialized()`, so this test fails with validation & full-MIR.\n-// compile-flags: -Zmir-emit-validate=0\n-\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-pub enum Foo {\n-    A(&'static str),\n-    _B,\n-    _C,\n-}\n-\n-pub fn main() {\n-    let mut b = std::collections::BTreeSet::new();\n-    b.insert(Foo::A(\"\\'\"));\n-    b.insert(Foo::A(\"/=\"));\n-    b.insert(Foo::A(\"#\"));\n-    b.insert(Foo::A(\"0o\"));\n-}"}, {"sha": "11897b73eb2ada620f0066518bdb78c471875c16", "filename": "tests/run-pass/c_enums.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fc_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fc_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fc_enums.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,32 +0,0 @@\n-enum Foo {\n-    Bar = 42,\n-    Baz,\n-    Quux = 100,\n-}\n-\n-enum Signed {\n-    Bar = -42,\n-    Baz,\n-    Quux = 100,\n-}\n-\n-fn foo() -> [u8; 3] {\n-    [Foo::Bar as u8, Foo::Baz as u8, Foo::Quux as u8]\n-}\n-\n-fn signed() -> [i8; 3] {\n-    [Signed::Bar as i8, Signed::Baz as i8, Signed::Quux as i8]\n-}\n-\n-fn unsafe_match() -> bool {\n-    match unsafe { std::mem::transmute::<u8, Foo>(43) } {\n-        Foo::Baz => true,\n-        _ => false,\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(foo(), [42, 43, 100]);\n-    assert_eq!(signed(), [-42, -41, 100]);\n-    assert!(unsafe_match());\n-}"}, {"sha": "c9b59f635e14506815a4d8f410b6d5fb47f5326e", "filename": "tests/run-pass/call_drop_on_array_elements.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,22 +0,0 @@\n-struct Bar(u16); // ZSTs are tested separately\n-\n-static mut DROP_COUNT: usize = 0;\n-\n-impl Drop for Bar {\n-    fn drop(&mut self) {\n-        assert_eq!(self.0 as usize, unsafe { DROP_COUNT }); // tests whether we are called at a valid address\n-        unsafe { DROP_COUNT += 1; }\n-    }\n-}\n-\n-fn main() {\n-    let b = [Bar(0), Bar(1), Bar(2), Bar(3)];\n-    assert_eq!(unsafe { DROP_COUNT }, 0);\n-    drop(b);\n-    assert_eq!(unsafe { DROP_COUNT }, 4);\n-\n-    // check empty case\n-    let b : [Bar; 0] = [];\n-    drop(b);\n-    assert_eq!(unsafe { DROP_COUNT }, 4);\n-}"}, {"sha": "a1ab5c45e358c84b60cdf043f3b8f151cc9b2e69", "filename": "tests/run-pass/call_drop_on_fat_ptr_array_elements.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_on_fat_ptr_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_on_fat_ptr_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_on_fat_ptr_array_elements.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-trait Foo {}\n-\n-struct Bar;\n-\n-impl Foo for Bar {}\n-\n-static mut DROP_COUNT: usize = 0;\n-\n-impl Drop for Bar {\n-    fn drop(&mut self) {\n-        unsafe { DROP_COUNT += 1; }\n-    }\n-}\n-\n-fn main() {\n-    let b: [Box<Foo>; 4] = [Box::new(Bar), Box::new(Bar), Box::new(Bar), Box::new(Bar)];\n-    assert_eq!(unsafe { DROP_COUNT }, 0);\n-    drop(b);\n-    assert_eq!(unsafe { DROP_COUNT }, 4);\n-}"}, {"sha": "1887130fdd8a4704b64990e5228e8c03ef0dd67f", "filename": "tests/run-pass/call_drop_on_zst_array_elements.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_on_zst_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_on_zst_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_on_zst_array_elements.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,21 +0,0 @@\n-struct Bar;\n-\n-static mut DROP_COUNT: usize = 0;\n-\n-impl Drop for Bar {\n-    fn drop(&mut self) {\n-        unsafe { DROP_COUNT += 1; }\n-    }\n-}\n-\n-fn main() {\n-    let b = [Bar, Bar, Bar, Bar];\n-    assert_eq!(unsafe { DROP_COUNT }, 0);\n-    drop(b);\n-    assert_eq!(unsafe { DROP_COUNT }, 4);\n-\n-    // check empty case\n-    let b : [Bar; 0] = [];\n-    drop(b);\n-    assert_eq!(unsafe { DROP_COUNT }, 4);\n-}"}, {"sha": "3ec6be65ed8b6f8bc8bb35d560a42ef3c2f0dfb5", "filename": "tests/run-pass/call_drop_through_owned_slice.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_through_owned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_through_owned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_through_owned_slice.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,16 +0,0 @@\n-struct Bar;\n-\n-static mut DROP_COUNT: usize = 0;\n-\n-impl Drop for Bar {\n-    fn drop(&mut self) {\n-        unsafe { DROP_COUNT += 1; }\n-    }\n-}\n-\n-fn main() {\n-    let b: Box<[Bar]> = vec![Bar, Bar, Bar, Bar].into_boxed_slice();\n-    assert_eq!(unsafe { DROP_COUNT }, 0);\n-    drop(b);\n-    assert_eq!(unsafe { DROP_COUNT }, 4);\n-}"}, {"sha": "9b6acf0b14746567e2d8aca45c6ae07a4720ec97", "filename": "tests/run-pass/call_drop_through_trait_object.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_through_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_through_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_through_trait_object.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-trait Foo {}\n-\n-struct Bar;\n-\n-static mut DROP_CALLED: bool = false;\n-\n-impl Drop for Bar {\n-    fn drop(&mut self) {\n-        unsafe { DROP_CALLED = true; }\n-    }\n-}\n-\n-impl Foo for Bar {}\n-\n-fn main() {\n-    let b: Box<Foo> = Box::new(Bar);\n-    assert!(unsafe { !DROP_CALLED });\n-    drop(b);\n-    assert!(unsafe { DROP_CALLED });\n-}"}, {"sha": "ce56ca6a1cafdd5d589f76e6e7ee12b16a106327", "filename": "tests/run-pass/call_drop_through_trait_object_rc.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_through_trait_object_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcall_drop_through_trait_object_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_through_trait_object_rc.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,22 +0,0 @@\n-trait Foo {}\n-\n-struct Bar;\n-\n-static mut DROP_CALLED: bool = false;\n-\n-impl Drop for Bar {\n-    fn drop(&mut self) {\n-        unsafe { DROP_CALLED = true; }\n-    }\n-}\n-\n-impl Foo for Bar {}\n-\n-use std::rc::Rc;\n-\n-fn main() {\n-    let b: Rc<Foo> = Rc::new(Bar);\n-    assert!(unsafe { !DROP_CALLED });\n-    drop(b);\n-    assert!(unsafe { DROP_CALLED });\n-}"}, {"sha": "c4ba4a9b701ff08ede7e8052aa4733bed92b3b08", "filename": "tests/run-pass/calls.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcalls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcalls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcalls.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,45 +0,0 @@\n-#![feature(const_fn)]\n-\n-fn call() -> i32 {\n-    fn increment(x: i32) -> i32 {\n-        x + 1\n-    }\n-    increment(1)\n-}\n-\n-fn factorial_recursive() -> i64 {\n-    fn fact(n: i64) -> i64 {\n-        if n == 0 {\n-            1\n-        } else {\n-            n * fact(n - 1)\n-        }\n-    }\n-    fact(10)\n-}\n-\n-fn call_generic() -> (i16, bool) {\n-    fn id<T>(t: T) -> T { t }\n-    (id(42), id(true))\n-}\n-\n-// Test calling a very simple function from the standard library.\n-fn cross_crate_fn_call() -> i64 {\n-    if 1i32.is_positive() { 1 } else { 0 }\n-}\n-\n-const fn foo(i: i64) -> i64 { *&i + 1 }\n-\n-fn const_fn_call() -> i64 {\n-    let x = 5 + foo(5);\n-    assert_eq!(x, 11);\n-    x\n-}\n-\n-fn main() {\n-    assert_eq!(call(), 2);\n-    assert_eq!(factorial_recursive(), 3628800);\n-    assert_eq!(call_generic(), (42, true));\n-    assert_eq!(cross_crate_fn_call(), 1);\n-    assert_eq!(const_fn_call(), 11);\n-}"}, {"sha": "afbd4760a3c9ba67703c00685b360cb630ec30bb", "filename": "tests/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,59 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// FIXME: remove the next line when https://github.com/rust-lang/rust/issues/43358 is resolved\n-// compile-flags: -Zmir-opt-level=0\n-\n-// Check that you can cast between different pointers to trait objects\n-// whose vtable have the same kind (both lengths, or both trait pointers).\n-\n-trait Foo<T> {\n-    fn foo(&self, _: T) -> u32 { 42 }\n-}\n-\n-trait Bar {\n-    fn bar(&self) { println!(\"Bar!\"); }\n-}\n-\n-impl<T> Foo<T> for () {}\n-impl Foo<u32> for u32 { fn foo(&self, _: u32) -> u32 { self+43 } }\n-impl Bar for () {}\n-\n-unsafe fn round_trip_and_call<'a>(t: *const (Foo<u32>+'a)) -> u32 {\n-    let foo_e : *const Foo<u16> = t as *const _;\n-    let r_1 = foo_e as *mut Foo<u32>;\n-\n-    (&*r_1).foo(0)\n-}\n-\n-#[repr(C)]\n-struct FooS<T:?Sized>(T);\n-#[repr(C)]\n-struct BarS<T:?Sized>(T);\n-\n-fn foo_to_bar<T:?Sized>(u: *const FooS<T>) -> *const BarS<T> {\n-    u as *const BarS<T>\n-}\n-\n-fn main() {\n-    let x = 4u32;\n-    let y : &Foo<u32> = &x;\n-    let fl = unsafe { round_trip_and_call(y as *const Foo<u32>) };\n-    assert_eq!(fl, (43+4));\n-\n-    let s = FooS([0,1,2]);\n-    let u: &FooS<[u32]> = &s;\n-    let u: *const FooS<[u32]> = u;\n-    let bar_ref : *const BarS<[u32]> = foo_to_bar(u);\n-    let z : &BarS<[u32]> = unsafe{&*bar_ref};\n-    assert_eq!(&z.0, &[0,1,2]);\n-    // If validation fails here, that's likely because an immutable suspension is recovered mutably.\n-}"}, {"sha": "109e8dfc2a02be11da01cf14bd84ca0ccd6f9842", "filename": "tests/run-pass/cast_fn_ptr.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast_fn_ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-fn main() {\n-    fn f(_: *const u8) {}\n-\n-    let g = unsafe {\n-        std::mem::transmute::<fn(*const u8), fn(*const i32)>(f)\n-    };\n-\n-    g(&42 as *const _);\n-}"}, {"sha": "0cabb369bfdd907ee6a5db31d4a307d1ec8896f9", "filename": "tests/run-pass/cast_fn_ptr_unsafe.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcast_fn_ptr_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fcast_fn_ptr_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast_fn_ptr_unsafe.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    fn f() {}\n-\n-    let g = f as fn() as unsafe fn();\n-    unsafe {\n-        g();\n-    }\n-}"}, {"sha": "505c09b0ad885a287d187a6731d9902b029e770f", "filename": "tests/run-pass/char.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fchar.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-fn main() {\n-    let c = 'x';\n-    assert_eq!(c, 'x');\n-    assert!('a' < 'z');\n-    assert!('1' < '9');\n-    assert_eq!(std::char::from_u32('x' as u32).unwrap(), 'x');\n-    // FIXME:\n-    // assert_eq!(std::char::from_u32('x' as u32), Some('x'));\n-}"}, {"sha": "f1bdafaeb1354a2619e2ed38ad5d810786010a86", "filename": "tests/run-pass/closure-drop.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fclosure-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fclosure-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fclosure-drop.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,25 +0,0 @@\n-struct Foo<'a>(&'a mut bool);\n-\n-impl<'a> Drop for Foo<'a> {\n-    fn drop(&mut self) {\n-        *self.0 = true;\n-    }\n-}\n-\n-fn f<T: FnOnce()>(t: T) {\n-    t()\n-}\n-\n-fn main() {\n-    let mut ran_drop = false;\n-    {\n-        let x = Foo(&mut ran_drop);\n-        // this closure never by val uses its captures\n-        // so it's basically a fn(&self)\n-        // the shim used to not drop the `x`\n-        let x = move || { let _ = x; };\n-        f(x);\n-    }\n-    assert!(ran_drop);\n-}\n-"}, {"sha": "0d27728d22322cc089653ad7f19835aec4b5c764", "filename": "tests/run-pass/closure-field-ty.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fclosure-field-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fclosure-field-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fclosure-field-ty.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-// miri issue #304\n-fn main() {\n-    let mut y = 0;\n-    {\n-        let mut box_maybe_closure = Box::new(None);\n-        *box_maybe_closure = Some(|| { y += 1; });\n-        (box_maybe_closure.unwrap())();\n-    }\n-    assert_eq!(y, 1);\n-}"}, {"sha": "9b379051eb774a88f12c75cd18520c89534c9be2", "filename": "tests/run-pass/closures.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fclosures.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,48 +0,0 @@\n-fn simple() -> i32 {\n-    let y = 10;\n-    let f = |x| x + y;\n-    f(2)\n-}\n-\n-fn crazy_closure() -> (i32, i32, i32) {\n-    fn inner<T: Copy>(t: T) -> (i32, T, T) {\n-        struct NonCopy;\n-        let x = NonCopy;\n-\n-        let a = 2;\n-        let b = 40;\n-        let f = move |y, z, asdf| {\n-            drop(x);\n-            (a + b + y + z, asdf, t)\n-        };\n-        f(a, b, t)\n-    }\n-\n-    inner(10)\n-}\n-\n-fn closure_arg_adjustment_problem() -> i64 {\n-    fn once<F: FnOnce(i64)>(f: F) { f(2); }\n-    let mut y = 1;\n-    {\n-        let f = |x| y += x;\n-        once(f);\n-    }\n-    y\n-}\n-\n-fn fn_once_closure_with_multiple_args() -> i64 {\n-    fn once<F: FnOnce(i64, i64) -> i64>(f: F) -> i64 { f(2, 3) }\n-    let y = 1;\n-    {\n-        let f = |x, z| x + y + z;\n-        once(f)\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(simple(), 12);\n-    assert_eq!(crazy_closure(), (84, 10, 10));\n-    assert_eq!(closure_arg_adjustment_problem(), 3);\n-    assert_eq!(fn_once_closure_with_multiple_args(), 6);\n-}"}, {"sha": "0338a766e26278ddc53ca9f6e5d1ed6d07b936e5", "filename": "tests/run-pass/const-vec-of-fns.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconst-vec-of-fns.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pretty-expanded FIXME #23616\n-\n-/*!\n- * Try to double-check that static fns have the right size (with or\n- * without dummy env ptr, as appropriate) by iterating a size-2 array.\n- * If the static size differs from the runtime size, the second element\n- * should be read as a null or otherwise wrong pointer and crash.\n- */\n-\n-fn f() { }\n-static mut CLOSURES: &'static mut [fn()] = &mut [f as fn(), f as fn()];\n-\n-pub fn main() {\n-    unsafe {\n-        for closure in &mut *CLOSURES {\n-            (*closure)()\n-        }\n-    }\n-}"}, {"sha": "718c8526014200135084e1eb367f52695ba59667", "filename": "tests/run-pass/constants.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fconstants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fconstants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconstants.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-const A: usize = *&5;\n-\n-fn foo() -> usize {\n-    A\n-}\n-\n-fn main() {\n-    assert_eq!(foo(), A);\n-}"}, {"sha": "b67ef85acf62d7f9f0c57b08197e6ed6481090e2", "filename": "tests/run-pass/deriving-associated-types.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fderiving-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fderiving-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fderiving-associated-types.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,208 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub trait DeclaredTrait {\n-    type Type;\n-}\n-\n-impl DeclaredTrait for i32 {\n-    type Type = i32;\n-}\n-\n-pub trait WhereTrait {\n-    type Type;\n-}\n-\n-impl WhereTrait for i32 {\n-    type Type = i32;\n-}\n-\n-// Make sure we don't add a bound that just shares a name with an associated\n-// type.\n-pub mod module {\n-    pub type Type = i32;\n-}\n-\n-#[derive(PartialEq, Debug)]\n-struct PrivateStruct<T>(T);\n-\n-#[derive(PartialEq, Debug)]\n-struct TupleStruct<A, B: DeclaredTrait, C>(\n-    module::Type,\n-    Option<module::Type>,\n-    A,\n-    PrivateStruct<A>,\n-    B,\n-    B::Type,\n-    Option<B::Type>,\n-    <B as DeclaredTrait>::Type,\n-    Option<<B as DeclaredTrait>::Type>,\n-    C,\n-    C::Type,\n-    Option<C::Type>,\n-    <C as WhereTrait>::Type,\n-    Option<<C as WhereTrait>::Type>,\n-    <i32 as DeclaredTrait>::Type,\n-) where C: WhereTrait;\n-\n-#[derive(PartialEq, Debug)]\n-pub struct Struct<A, B: DeclaredTrait, C> where C: WhereTrait {\n-    m1: module::Type,\n-    m2: Option<module::Type>,\n-    a1: A,\n-    a2: PrivateStruct<A>,\n-    b: B,\n-    b1: B::Type,\n-    b2: Option<B::Type>,\n-    b3: <B as DeclaredTrait>::Type,\n-    b4: Option<<B as DeclaredTrait>::Type>,\n-    c: C,\n-    c1: C::Type,\n-    c2: Option<C::Type>,\n-    c3: <C as WhereTrait>::Type,\n-    c4: Option<<C as WhereTrait>::Type>,\n-    d: <i32 as DeclaredTrait>::Type,\n-}\n-\n-#[derive(PartialEq, Debug)]\n-enum Enum<A, B: DeclaredTrait, C> where C: WhereTrait {\n-    Unit,\n-    Seq(\n-        module::Type,\n-        Option<module::Type>,\n-        A,\n-        PrivateStruct<A>,\n-        B,\n-        B::Type,\n-        Option<B::Type>,\n-        <B as DeclaredTrait>::Type,\n-        Option<<B as DeclaredTrait>::Type>,\n-        C,\n-        C::Type,\n-        Option<C::Type>,\n-        <C as WhereTrait>::Type,\n-        Option<<C as WhereTrait>::Type>,\n-        <i32 as DeclaredTrait>::Type,\n-    ),\n-    Map {\n-        m1: module::Type,\n-        m2: Option<module::Type>,\n-        a1: A,\n-        a2: PrivateStruct<A>,\n-        b: B,\n-        b1: B::Type,\n-        b2: Option<B::Type>,\n-        b3: <B as DeclaredTrait>::Type,\n-        b4: Option<<B as DeclaredTrait>::Type>,\n-        c: C,\n-        c1: C::Type,\n-        c2: Option<C::Type>,\n-        c3: <C as WhereTrait>::Type,\n-        c4: Option<<C as WhereTrait>::Type>,\n-        d: <i32 as DeclaredTrait>::Type,\n-    },\n-}\n-\n-fn main() {\n-\n-    let e: Enum<\n-        i32,\n-        i32,\n-        i32,\n-    > = Enum::Seq(\n-        0,\n-        None,\n-        0,\n-        PrivateStruct(0),\n-        0,\n-        0,\n-        None,\n-        0,\n-        None,\n-        0,\n-        0,\n-        None,\n-        0,\n-        None,\n-        0,\n-    );\n-    assert_eq!(e, e);\n-\n-    let e: Enum<\n-        i32,\n-        i32,\n-        i32,\n-    > = Enum::Map {\n-        m1: 0,\n-        m2: None,\n-        a1: 0,\n-        a2: PrivateStruct(0),\n-        b: 0,\n-        b1: 0,\n-        b2: None,\n-        b3: 0,\n-        b4: None,\n-        c: 0,\n-        c1: 0,\n-        c2: None,\n-        c3: 0,\n-        c4: None,\n-        d: 0,\n-    };\n-    assert_eq!(e, e);\n-        let e: TupleStruct<\n-            i32,\n-            i32,\n-            i32,\n-        > = TupleStruct(\n-            0,\n-            None,\n-            0,\n-            PrivateStruct(0),\n-            0,\n-            0,\n-            None,\n-            0,\n-            None,\n-            0,\n-            0,\n-            None,\n-            0,\n-            None,\n-            0,\n-        );\n-        assert_eq!(e, e);\n-\n-        let e: Struct<\n-            i32,\n-            i32,\n-            i32,\n-        > = Struct {\n-            m1: 0,\n-            m2: None,\n-            a1: 0,\n-            a2: PrivateStruct(0),\n-            b: 0,\n-            b1: 0,\n-            b2: None,\n-            b3: 0,\n-            b4: None,\n-            c: 0,\n-            c1: 0,\n-            c2: None,\n-            c3: 0,\n-            c4: None,\n-            d: 0,\n-        };\n-        assert_eq!(e, e);\n-\n-        let e = Enum::Unit::<i32, i32, i32>;\n-        assert_eq!(e, e);\n-}"}, {"sha": "b21c8a612c57b064a7dc6878cb04e6679eca6e54", "filename": "tests/run-pass/drop_empty_slice.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdrop_empty_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdrop_empty_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdrop_empty_slice.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    // With the nested Vec, this is calling Offset(Unique::empty(), 0) on drop.\n-    let args : Vec<Vec<i32>> = Vec::new();\n-    let _ = box args;\n-}"}, {"sha": "5631b65ed9d8a6dd60a0465fd9651e8965e7390d", "filename": "tests/run-pass/dst-field-align.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-field-align.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-\n-struct Foo<T: ?Sized> {\n-    a: u16,\n-    b: T\n-}\n-\n-trait Bar {\n-    fn get(&self) -> usize;\n-}\n-\n-impl Bar for usize {\n-    fn get(&self) -> usize { *self }\n-}\n-\n-struct Baz<T: ?Sized> {\n-    a: T\n-}\n-\n-struct HasDrop<T: ?Sized> {\n-    ptr: Box<usize>,\n-    data: T\n-}\n-\n-fn main() {\n-    // Test that zero-offset works properly\n-    let b : Baz<usize> = Baz { a: 7 };\n-    assert_eq!(b.a.get(), 7);\n-    let b : &Baz<Bar> = &b;\n-    assert_eq!(b.a.get(), 7);\n-\n-    // Test that the field is aligned properly\n-    let f : Foo<usize> = Foo { a: 0, b: 11 };\n-    assert_eq!(f.b.get(), 11);\n-    let ptr1 : *const u8 = &f.b as *const _ as *const u8;\n-\n-    let f : &Foo<Bar> = &f;\n-    let ptr2 : *const u8 = &f.b as *const _ as *const u8;\n-    assert_eq!(f.b.get(), 11);\n-\n-    // The pointers should be the same\n-    assert_eq!(ptr1, ptr2);\n-\n-    // Test that nested DSTs work properly\n-    let f : Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 }};\n-    assert_eq!(f.b.b.get(), 17);\n-    let f : &Foo<Foo<Bar>> = &f;\n-    assert_eq!(f.b.b.get(), 17);\n-\n-    // Test that get the pointer via destructuring works\n-\n-    let f : Foo<usize> = Foo { a: 0, b: 11 };\n-    let f : &Foo<Bar> = &f;\n-    let &Foo { a: _, b: ref bar } = f;\n-    assert_eq!(bar.get(), 11);\n-\n-    // Make sure that drop flags don't screw things up\n-\n-    let d : HasDrop<Baz<[i32; 4]>> = HasDrop {\n-        ptr: Box::new(0),\n-        data: Baz { a: [1,2,3,4] }\n-    };\n-    assert_eq!([1,2,3,4], d.data.a);\n-\n-    let d : &HasDrop<Baz<[i32]>> = &d;\n-    assert_eq!(&[1,2,3,4], &d.data.a);\n-}"}, {"sha": "9f8067f372aef89cae35b5d49d1c7e952b192510", "filename": "tests/run-pass/dst-irrefutable-bind.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-irrefutable-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-irrefutable-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-irrefutable-bind.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Test<T: ?Sized>(T);\n-\n-fn main() {\n-    let x = Test([1,2,3]);\n-    let x : &Test<[i32]> = &x;\n-\n-    let & ref _y = x;\n-\n-    // Make sure binding to a fat pointer behind a reference\n-    // still works\n-    let slice = &[1,2,3];\n-    let x = Test(&slice);\n-    let Test(&_slice) = x;\n-}"}, {"sha": "3a74626b0299f2be8af8229e70da2ad5ded479db", "filename": "tests/run-pass/dst-raw.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-raw.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,113 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test DST raw pointers\n-\n-\n-trait Trait {\n-    fn foo(&self) -> isize;\n-}\n-\n-struct A {\n-    f: isize\n-}\n-impl Trait for A {\n-    fn foo(&self) -> isize {\n-        self.f\n-    }\n-}\n-\n-struct Foo<T: ?Sized> {\n-    f: T\n-}\n-\n-pub fn main() {\n-    // raw trait object\n-    let x = A { f: 42 };\n-    let z: *const Trait = &x;\n-    let r = unsafe {\n-        (&*z).foo()\n-    };\n-    assert_eq!(r, 42);\n-\n-    // raw DST struct\n-    let p = Foo {f: A { f: 42 }};\n-    let o: *const Foo<Trait> = &p;\n-    let r = unsafe {\n-        (&*o).f.foo()\n-    };\n-    assert_eq!(r, 42);\n-\n-    // raw slice\n-    let a: *const [_] = &[1, 2, 3];\n-    unsafe {\n-        let b = (*a)[2];\n-        assert_eq!(b, 3);\n-        let len = (*a).len();\n-        assert_eq!(len, 3);\n-    }\n-\n-    // raw slice with explicit cast\n-    let a = &[1, 2, 3] as *const [i32];\n-    unsafe {\n-        let b = (*a)[2];\n-        assert_eq!(b, 3);\n-        let len = (*a).len();\n-        assert_eq!(len, 3);\n-    }\n-\n-    // raw DST struct with slice\n-    let c: *const Foo<[_]> = &Foo {f: [1, 2, 3]};\n-    unsafe {\n-        let b = (&*c).f[0];\n-        assert_eq!(b, 1);\n-        let len = (&*c).f.len();\n-        assert_eq!(len, 3);\n-    }\n-\n-    // all of the above with *mut\n-    let mut x = A { f: 42 };\n-    let z: *mut Trait = &mut x;\n-    let r = unsafe {\n-        (&*z).foo()\n-    };\n-    assert_eq!(r, 42);\n-\n-    let mut p = Foo {f: A { f: 42 }};\n-    let o: *mut Foo<Trait> = &mut p;\n-    let r = unsafe {\n-        (&*o).f.foo()\n-    };\n-    assert_eq!(r, 42);\n-\n-    let a: *mut [_] = &mut [1, 2, 3];\n-    unsafe {\n-        let b = (*a)[2];\n-        assert_eq!(b, 3);\n-        let len = (*a).len();\n-        assert_eq!(len, 3);\n-    }\n-\n-    let a = &mut [1, 2, 3] as *mut [i32];\n-    unsafe {\n-        let b = (*a)[2];\n-        assert_eq!(b, 3);\n-        let len = (*a).len();\n-        assert_eq!(len, 3);\n-    }\n-\n-    let c: *mut Foo<[_]> = &mut Foo {f: [1, 2, 3]};\n-    unsafe {\n-        let b = (&*c).f[0];\n-        assert_eq!(b, 1);\n-        let len = (&*c).f.len();\n-        assert_eq!(len, 3);\n-    }\n-}"}, {"sha": "58d7b35a5275cc2de0351d2e97ecd6342818c05d", "filename": "tests/run-pass/dst-struct-sole.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-struct-sole.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,85 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// As dst-struct.rs, but the unsized field is the only field in the struct.\n-\n-\n-struct Fat<T: ?Sized> {\n-    ptr: T\n-}\n-\n-// x is a fat pointer\n-fn foo(x: &Fat<[isize]>) {\n-    let y = &x.ptr;\n-    assert_eq!(x.ptr.len(), 3);\n-    assert_eq!(y[0], 1);\n-    assert_eq!(x.ptr[1], 2);\n-}\n-\n-fn foo2<T:ToBar>(x: &Fat<[T]>) {\n-    let y = &x.ptr;\n-    let bar = Bar;\n-    assert_eq!(x.ptr.len(), 3);\n-    assert_eq!(y[0].to_bar(), bar);\n-    assert_eq!(x.ptr[1].to_bar(), bar);\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-struct Bar;\n-\n-trait ToBar {\n-    fn to_bar(&self) -> Bar;\n-}\n-\n-impl ToBar for Bar {\n-    fn to_bar(&self) -> Bar {\n-        *self\n-    }\n-}\n-\n-pub fn main() {\n-    // With a vec of ints.\n-    let f1 = Fat { ptr: [1, 2, 3] };\n-    foo(&f1);\n-    let f2 = &f1;\n-    foo(f2);\n-    let f3: &Fat<[isize]> = f2;\n-    foo(f3);\n-    let f4: &Fat<[isize]> = &f1;\n-    foo(f4);\n-    let f5: &Fat<[isize]> = &Fat { ptr: [1, 2, 3] };\n-    foo(f5);\n-\n-    // With a vec of Bars.\n-    let bar = Bar;\n-    let f1 = Fat { ptr: [bar, bar, bar] };\n-    foo2(&f1);\n-    let f2 = &f1;\n-    foo2(f2);\n-    let f3: &Fat<[Bar]> = f2;\n-    foo2(f3);\n-    let f4: &Fat<[Bar]> = &f1;\n-    foo2(f4);\n-    let f5: &Fat<[Bar]> = &Fat { ptr: [bar, bar, bar] };\n-    foo2(f5);\n-\n-    // Assignment.\n-    let f5: &mut Fat<[isize]> = &mut Fat { ptr: [1, 2, 3] };\n-    f5.ptr[1] = 34;\n-    assert_eq!(f5.ptr[0], 1);\n-    assert_eq!(f5.ptr[1], 34);\n-    assert_eq!(f5.ptr[2], 3);\n-\n-    // Zero size vec.\n-    let f5: &Fat<[isize]> = &Fat { ptr: [] };\n-    assert!(f5.ptr.is_empty());\n-    let f5: &Fat<[Bar]> = &Fat { ptr: [] };\n-    assert!(f5.ptr.is_empty());\n-}"}, {"sha": "932b571eccdbb8551646ada388f6b9c5e1739ca7", "filename": "tests/run-pass/dst-struct.rs", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-struct.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,134 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![allow(unused_features)]\n-#![feature(box_syntax)]\n-\n-struct Fat<T: ?Sized> {\n-    f1: isize,\n-    f2: &'static str,\n-    ptr: T\n-}\n-\n-// x is a fat pointer\n-fn foo(x: &Fat<[isize]>) {\n-    let y = &x.ptr;\n-    assert_eq!(x.ptr.len(), 3);\n-    assert_eq!(y[0], 1);\n-    assert_eq!(x.ptr[1], 2);\n-    assert_eq!(x.f1, 5);\n-    assert_eq!(x.f2, \"some str\");\n-}\n-\n-fn foo2<T:ToBar>(x: &Fat<[T]>) {\n-    let y = &x.ptr;\n-    let bar = Bar;\n-    assert_eq!(x.ptr.len(), 3);\n-    assert_eq!(y[0].to_bar(), bar);\n-    assert_eq!(x.ptr[1].to_bar(), bar);\n-    assert_eq!(x.f1, 5);\n-    assert_eq!(x.f2, \"some str\");\n-}\n-\n-fn foo3(x: &Fat<Fat<[isize]>>) {\n-    let y = &x.ptr.ptr;\n-    assert_eq!(x.f1, 5);\n-    assert_eq!(x.f2, \"some str\");\n-    assert_eq!(x.ptr.f1, 8);\n-    assert_eq!(x.ptr.f2, \"deep str\");\n-    assert_eq!(x.ptr.ptr.len(), 3);\n-    assert_eq!(y[0], 1);\n-    assert_eq!(x.ptr.ptr[1], 2);\n-}\n-\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-struct Bar;\n-\n-trait ToBar {\n-    fn to_bar(&self) -> Bar;\n-}\n-\n-impl ToBar for Bar {\n-    fn to_bar(&self) -> Bar {\n-        *self\n-    }\n-}\n-\n-pub fn main() {\n-    // With a vec of ints.\n-    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n-    foo(&f1);\n-    let f2 = &f1;\n-    foo(f2);\n-    let f3: &Fat<[isize]> = f2;\n-    foo(f3);\n-    let f4: &Fat<[isize]> = &f1;\n-    foo(f4);\n-    let f5: &Fat<[isize]> = &Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n-    foo(f5);\n-\n-    // With a vec of Bars.\n-    let bar = Bar;\n-    let f1 = Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n-    foo2(&f1);\n-    let f2 = &f1;\n-    foo2(f2);\n-    let f3: &Fat<[Bar]> = f2;\n-    foo2(f3);\n-    let f4: &Fat<[Bar]> = &f1;\n-    foo2(f4);\n-    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [bar, bar, bar] };\n-    foo2(f5);\n-\n-    // Assignment.\n-    let f5: &mut Fat<[isize]> = &mut Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n-    f5.ptr[1] = 34;\n-    assert_eq!(f5.ptr[0], 1);\n-    assert_eq!(f5.ptr[1], 34);\n-    assert_eq!(f5.ptr[2], 3);\n-\n-    // Zero size vec.\n-    let f5: &Fat<[isize]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n-    assert!(f5.ptr.is_empty());\n-    let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n-    assert!(f5.ptr.is_empty());\n-\n-    // Deeply nested.\n-    let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n-    foo3(&f1);\n-    let f2 = &f1;\n-    foo3(f2);\n-    let f3: &Fat<Fat<[isize]>> = f2;\n-    foo3(f3);\n-    let f4: &Fat<Fat<[isize]>> = &f1;\n-    foo3(f4);\n-    let f5: &Fat<Fat<[isize]>> =\n-        &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };\n-    foo3(f5);\n-\n-    // Box.\n-    let f1 = Box::new([1, 2, 3]);\n-    assert_eq!((*f1)[1], 2);\n-    let f2: Box<[isize]> = f1;\n-    assert_eq!((*f2)[1], 2);\n-\n-    // Nested Box.\n-    let f1 : Box<Fat<[isize; 3]>> = box Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] };\n-    foo(&*f1);\n-    let f2 : Box<Fat<[isize]>> = f1;\n-    foo(&*f2);\n-\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    let f3 : Box<Fat<[isize]>> =\n-        Box::<Fat<[_; 3]>>::new(Fat { f1: 5, f2: \"some str\", ptr: [1, 2, 3] });\n-    foo(&*f3);\n-}"}, {"sha": "1342c4e104de5bf01f16f6375a90dfe87068ac65", "filename": "tests/run-pass/enum-nullable-const-null-with-fields.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fenum-nullable-const-null-with-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fenum-nullable-const-null-with-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fenum-nullable-const-null-with-fields.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use std::result::Result;\n-use std::result::Result::Ok;\n-\n-static C: Result<(), Box<isize>> = Ok(());\n-\n-// This is because of yet another bad assertion (ICE) about the null side of a nullable enum.\n-// So we won't actually compile if the bug is present, but we check the value in main anyway.\n-\n-pub fn main() {\n-    assert!(C.is_ok());\n-}"}, {"sha": "1f27292904f42a132889ee089b12cfc15778cf5b", "filename": "tests/run-pass/enums.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fenums.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,34 +0,0 @@\n-enum MyEnum {\n-    MyEmptyVariant,\n-    MyNewtypeVariant(i32),\n-    MyTupleVariant(i32, i32),\n-    MyStructVariant {\n-        my_first_field: i32,\n-        my_second_field: i32,\n-    }\n-}\n-\n-fn test(me: MyEnum) {\n-    match me {\n-        MyEnum::MyEmptyVariant => {},\n-        MyEnum::MyNewtypeVariant(ref val) => assert_eq!(val, &42),\n-        MyEnum::MyTupleVariant(ref a, ref b) => {\n-            assert_eq!(a, &43);\n-            assert_eq!(b, &44);\n-        },\n-        MyEnum::MyStructVariant { ref my_first_field, ref my_second_field } => {\n-            assert_eq!(my_first_field, &45);\n-            assert_eq!(my_second_field, &46);\n-        },\n-    }\n-}\n-\n-fn main() {\n-    test(MyEnum::MyEmptyVariant);\n-    test(MyEnum::MyNewtypeVariant(42));\n-    test(MyEnum::MyTupleVariant(43, 44));\n-    test(MyEnum::MyStructVariant{\n-        my_first_field: 45,\n-        my_second_field: 46,\n-    });\n-}"}, {"sha": "c1b4b55bd3723fca5f4c7ae882b6dac689c8823e", "filename": "tests/run-pass/float_fast_math.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffloat_fast_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffloat_fast_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffloat_fast_math.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(core_intrinsics)]\n-\n-use std::intrinsics::{fadd_fast, fsub_fast, fmul_fast, fdiv_fast, frem_fast};\n-\n-#[inline(never)]\n-pub fn test_operations(a: f64, b: f64) {\n-    // make sure they all map to the correct operation\n-    unsafe {\n-        assert_eq!(fadd_fast(a, b), a + b);\n-        assert_eq!(fsub_fast(a, b), a - b);\n-        assert_eq!(fmul_fast(a, b), a * b);\n-        assert_eq!(fdiv_fast(a, b), a / b);\n-        assert_eq!(frem_fast(a, b), a % b);\n-    }\n-}\n-\n-fn main() {\n-    test_operations(1., 2.);\n-    test_operations(10., 5.);\n-}"}, {"sha": "9c4d0594d1c9916dac909bcdd5087008a2b79e6c", "filename": "tests/run-pass/floats.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffloats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffloats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffloats.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,11 +0,0 @@\n-\n-fn main() {\n-    assert_eq!(6.0_f32*6.0_f32, 36.0_f32);\n-    assert_eq!(6.0_f64*6.0_f64, 36.0_f64);\n-    assert_eq!(-{5.0_f32}, -5.0_f32);\n-    assert!((5.0_f32/0.0).is_infinite());\n-    assert!((-5.0_f32).sqrt().is_nan());\n-    let x: u64 = unsafe { std::mem::transmute(42.0_f64) };\n-    let y: f64 = unsafe { std::mem::transmute(x) };\n-    assert_eq!(y, 42.0_f64);\n-}"}, {"sha": "799f97a4f6fdedd6a25bc64d26ae3c7522ad52db", "filename": "tests/run-pass/fn_item_as_closure_trait_object.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffn_item_as_closure_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffn_item_as_closure_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffn_item_as_closure_trait_object.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-fn foo() {}\n-\n-fn main() {\n-    let f: &Fn() = &foo;\n-    f();\n-}"}, {"sha": "79ece75c773bb2a7b6c26b07c8a79a8a82090c37", "filename": "tests/run-pass/fn_item_with_args_as_closure_trait_object.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffn_item_with_args_as_closure_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffn_item_with_args_as_closure_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffn_item_with_args_as_closure_trait_object.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn foo(i: i32) {\n-    assert_eq!(i, 42);\n-}\n-\n-fn main() {\n-    let f: &Fn(i32) = &foo;\n-    f(42);\n-}"}, {"sha": "f4b5b449aa587b1da36d06b8d9d5be8b5da9ba57", "filename": "tests/run-pass/fn_item_with_multiple_args_as_closure_trait_object.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffn_item_with_multiple_args_as_closure_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffn_item_with_multiple_args_as_closure_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffn_item_with_multiple_args_as_closure_trait_object.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,18 +0,0 @@\n-fn foo(i: i32, j: i32) {\n-    assert_eq!(i, 42);\n-    assert_eq!(j, 55);\n-}\n-\n-fn bar(i: i32, j: i32, k: f32) {\n-    assert_eq!(i, 42);\n-    assert_eq!(j, 55);\n-    assert_eq!(k, 3.14159)\n-}\n-\n-\n-fn main() {\n-    let f: &Fn(i32, i32) = &foo;\n-    f(42, 55);\n-    let f: &Fn(i32, i32, f32) = &bar;\n-    f(42, 55, 3.14159);\n-}"}, {"sha": "24ae1f35bb60ba828633354b687728b9fc69f7ac", "filename": "tests/run-pass/fn_ptr_as_closure_trait_object.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffn_ptr_as_closure_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffn_ptr_as_closure_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffn_ptr_as_closure_trait_object.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-fn foo() {}\n-fn bar(u: u32) { assert_eq!(u, 42); }\n-fn baa(u: u32, f: f32) {\n-    assert_eq!(u, 42);\n-    assert_eq!(f, 3.141);\n-}\n-\n-fn main() {\n-    let f: &Fn() = &(foo as fn());\n-    f();\n-    let f: &Fn(u32) = &(bar as fn(u32));\n-    f(42);\n-    let f: &Fn(u32, f32) = &(baa as fn(u32, f32));\n-    f(42, 3.141);\n-}"}, {"sha": "4f597d4a2e94ffca531f97d332668ddb32948e21", "filename": "tests/run-pass/function_pointers.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_pointers.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,46 +0,0 @@\n-fn f() -> i32 {\n-    42\n-}\n-\n-fn g(i: i32) -> i32 {\n-    i*42\n-}\n-\n-fn h(i: i32, j: i32) -> i32 {\n-    j * i * 7\n-}\n-\n-fn return_fn_ptr() -> fn() -> i32 {\n-    f\n-}\n-\n-fn call_fn_ptr() -> i32 {\n-    return_fn_ptr()()\n-}\n-\n-fn indirect<F: Fn() -> i32>(f: F) -> i32 { f() }\n-fn indirect_mut<F: FnMut() -> i32>(mut f: F) -> i32 { f() }\n-fn indirect_once<F: FnOnce() -> i32>(f: F) -> i32 { f() }\n-\n-fn indirect2<F: Fn(i32) -> i32>(f: F) -> i32 { f(10) }\n-fn indirect_mut2<F: FnMut(i32) -> i32>(mut f: F) -> i32 { f(10) }\n-fn indirect_once2<F: FnOnce(i32) -> i32>(f: F) -> i32 { f(10) }\n-\n-fn indirect3<F: Fn(i32, i32) -> i32>(f: F) -> i32 { f(10, 3) }\n-fn indirect_mut3<F: FnMut(i32, i32) -> i32>(mut f: F) -> i32 { f(10, 3) }\n-fn indirect_once3<F: FnOnce(i32, i32) -> i32>(f: F) -> i32 { f(10, 3) }\n-\n-fn main() {\n-    assert_eq!(call_fn_ptr(), 42);\n-    assert_eq!(indirect(f), 42);\n-    assert_eq!(indirect_mut(f), 42);\n-    assert_eq!(indirect_once(f), 42);\n-    assert_eq!(indirect2(g), 420);\n-    assert_eq!(indirect_mut2(g), 420);\n-    assert_eq!(indirect_once2(g), 420);\n-    assert_eq!(indirect3(h), 210);\n-    assert_eq!(indirect_mut3(h), 210);\n-    assert_eq!(indirect_once3(h), 210);\n-    assert!(return_fn_ptr() == f);\n-    assert!(return_fn_ptr() as unsafe fn() -> i32 == f as fn() -> i32 as unsafe fn() -> i32);\n-}"}, {"sha": "f15c7db9c2030020836a03fd23cfb06e0c907e21", "filename": "tests/run-pass/generator_control_flow.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fgenerator_control_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fgenerator_control_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fgenerator_control_flow.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,65 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(generators, generator_trait)]\n-\n-use std::ops::{GeneratorState, Generator};\n-\n-fn finish<T>(mut amt: usize, mut t: T) -> T::Return\n-    where T: Generator<Yield = ()>\n-{\n-    loop {\n-        match t.resume() {\n-            GeneratorState::Yielded(()) => amt -= 1,\n-            GeneratorState::Complete(ret) => {\n-                assert_eq!(amt, 0);\n-                return ret\n-            }\n-        }\n-    }\n-\n-}\n-\n-fn main() {\n-    finish(1, || yield);\n-    finish(3, || {\n-        let mut x = 0;\n-        yield;\n-        x += 1;\n-        yield;\n-        x += 1;\n-        yield;\n-        assert_eq!(x, 2);\n-    });\n-    finish(8, || {\n-        for _ in 0..8 {\n-            yield;\n-        }\n-    });\n-    finish(1, || {\n-        if true {\n-            yield;\n-        } else {\n-        }\n-    });\n-    finish(1, || {\n-        if false {\n-        } else {\n-            yield;\n-        }\n-    });\n-    finish(2, || {\n-        if { yield; false } {\n-            yield;\n-            panic!()\n-        }\n-        yield\n-    });\n-}"}, {"sha": "4896f02da20b0b280e6fde0dbd555a4e5c4c8c1e", "filename": "tests/run-pass/intrinsics-integer.rs", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintrinsics-integer.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,142 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(intrinsics)]\n-\n-mod rusti {\n-    extern \"rust-intrinsic\" {\n-        pub fn ctpop<T>(x: T) -> T;\n-        pub fn ctlz<T>(x: T) -> T;\n-        pub fn ctlz_nonzero<T>(x: T) -> T;\n-        pub fn cttz<T>(x: T) -> T;\n-        pub fn cttz_nonzero<T>(x: T) -> T;\n-        pub fn bswap<T>(x: T) -> T;\n-    }\n-}\n-\n-pub fn main() {\n-    unsafe {\n-        use rusti::*;\n-\n-        assert_eq!(ctpop(0u8), 0); assert_eq!(ctpop(0i8), 0);\n-        assert_eq!(ctpop(0u16), 0); assert_eq!(ctpop(0i16), 0);\n-        assert_eq!(ctpop(0u32), 0); assert_eq!(ctpop(0i32), 0);\n-        assert_eq!(ctpop(0u64), 0); assert_eq!(ctpop(0i64), 0);\n-\n-        assert_eq!(ctpop(1u8), 1); assert_eq!(ctpop(1i8), 1);\n-        assert_eq!(ctpop(1u16), 1); assert_eq!(ctpop(1i16), 1);\n-        assert_eq!(ctpop(1u32), 1); assert_eq!(ctpop(1i32), 1);\n-        assert_eq!(ctpop(1u64), 1); assert_eq!(ctpop(1i64), 1);\n-\n-        assert_eq!(ctpop(10u8), 2); assert_eq!(ctpop(10i8), 2);\n-        assert_eq!(ctpop(10u16), 2); assert_eq!(ctpop(10i16), 2);\n-        assert_eq!(ctpop(10u32), 2); assert_eq!(ctpop(10i32), 2);\n-        assert_eq!(ctpop(10u64), 2); assert_eq!(ctpop(10i64), 2);\n-\n-        assert_eq!(ctpop(100u8), 3); assert_eq!(ctpop(100i8), 3);\n-        assert_eq!(ctpop(100u16), 3); assert_eq!(ctpop(100i16), 3);\n-        assert_eq!(ctpop(100u32), 3); assert_eq!(ctpop(100i32), 3);\n-        assert_eq!(ctpop(100u64), 3); assert_eq!(ctpop(100i64), 3);\n-\n-        assert_eq!(ctpop(-1i8 as u8), 8); assert_eq!(ctpop(-1i8), 8);\n-        assert_eq!(ctpop(-1i16 as u16), 16); assert_eq!(ctpop(-1i16), 16);\n-        assert_eq!(ctpop(-1i32 as u32), 32); assert_eq!(ctpop(-1i32), 32);\n-        assert_eq!(ctpop(-1i64 as u64), 64); assert_eq!(ctpop(-1i64), 64);\n-\n-        assert_eq!(ctlz(0u8), 8); assert_eq!(ctlz(0i8), 8);\n-        assert_eq!(ctlz(0u16), 16); assert_eq!(ctlz(0i16), 16);\n-        assert_eq!(ctlz(0u32), 32); assert_eq!(ctlz(0i32), 32);\n-        assert_eq!(ctlz(0u64), 64); assert_eq!(ctlz(0i64), 64);\n-\n-        assert_eq!(ctlz(1u8), 7); assert_eq!(ctlz(1i8), 7);\n-        assert_eq!(ctlz(1u16), 15); assert_eq!(ctlz(1i16), 15);\n-        assert_eq!(ctlz(1u32), 31); assert_eq!(ctlz(1i32), 31);\n-        assert_eq!(ctlz(1u64), 63); assert_eq!(ctlz(1i64), 63);\n-\n-        assert_eq!(ctlz(10u8), 4); assert_eq!(ctlz(10i8), 4);\n-        assert_eq!(ctlz(10u16), 12); assert_eq!(ctlz(10i16), 12);\n-        assert_eq!(ctlz(10u32), 28); assert_eq!(ctlz(10i32), 28);\n-        assert_eq!(ctlz(10u64), 60); assert_eq!(ctlz(10i64), 60);\n-\n-        assert_eq!(ctlz(100u8), 1); assert_eq!(ctlz(100i8), 1);\n-        assert_eq!(ctlz(100u16), 9); assert_eq!(ctlz(100i16), 9);\n-        assert_eq!(ctlz(100u32), 25); assert_eq!(ctlz(100i32), 25);\n-        assert_eq!(ctlz(100u64), 57); assert_eq!(ctlz(100i64), 57);\n-\n-        assert_eq!(ctlz_nonzero(1u8), 7); assert_eq!(ctlz_nonzero(1i8), 7);\n-        assert_eq!(ctlz_nonzero(1u16), 15); assert_eq!(ctlz_nonzero(1i16), 15);\n-        assert_eq!(ctlz_nonzero(1u32), 31); assert_eq!(ctlz_nonzero(1i32), 31);\n-        assert_eq!(ctlz_nonzero(1u64), 63); assert_eq!(ctlz_nonzero(1i64), 63);\n-\n-        assert_eq!(ctlz_nonzero(10u8), 4); assert_eq!(ctlz_nonzero(10i8), 4);\n-        assert_eq!(ctlz_nonzero(10u16), 12); assert_eq!(ctlz_nonzero(10i16), 12);\n-        assert_eq!(ctlz_nonzero(10u32), 28); assert_eq!(ctlz_nonzero(10i32), 28);\n-        assert_eq!(ctlz_nonzero(10u64), 60); assert_eq!(ctlz_nonzero(10i64), 60);\n-\n-        assert_eq!(ctlz_nonzero(100u8), 1); assert_eq!(ctlz_nonzero(100i8), 1);\n-        assert_eq!(ctlz_nonzero(100u16), 9); assert_eq!(ctlz_nonzero(100i16), 9);\n-        assert_eq!(ctlz_nonzero(100u32), 25); assert_eq!(ctlz_nonzero(100i32), 25);\n-        assert_eq!(ctlz_nonzero(100u64), 57); assert_eq!(ctlz_nonzero(100i64), 57);\n-\n-        assert_eq!(cttz(-1i8 as u8), 0); assert_eq!(cttz(-1i8), 0);\n-        assert_eq!(cttz(-1i16 as u16), 0); assert_eq!(cttz(-1i16), 0);\n-        assert_eq!(cttz(-1i32 as u32), 0); assert_eq!(cttz(-1i32), 0);\n-        assert_eq!(cttz(-1i64 as u64), 0); assert_eq!(cttz(-1i64), 0);\n-\n-        assert_eq!(cttz(0u8), 8); assert_eq!(cttz(0i8), 8);\n-        assert_eq!(cttz(0u16), 16); assert_eq!(cttz(0i16), 16);\n-        assert_eq!(cttz(0u32), 32); assert_eq!(cttz(0i32), 32);\n-        assert_eq!(cttz(0u64), 64); assert_eq!(cttz(0i64), 64);\n-\n-        assert_eq!(cttz(1u8), 0); assert_eq!(cttz(1i8), 0);\n-        assert_eq!(cttz(1u16), 0); assert_eq!(cttz(1i16), 0);\n-        assert_eq!(cttz(1u32), 0); assert_eq!(cttz(1i32), 0);\n-        assert_eq!(cttz(1u64), 0); assert_eq!(cttz(1i64), 0);\n-\n-        assert_eq!(cttz(10u8), 1); assert_eq!(cttz(10i8), 1);\n-        assert_eq!(cttz(10u16), 1); assert_eq!(cttz(10i16), 1);\n-        assert_eq!(cttz(10u32), 1); assert_eq!(cttz(10i32), 1);\n-        assert_eq!(cttz(10u64), 1); assert_eq!(cttz(10i64), 1);\n-\n-        assert_eq!(cttz(100u8), 2); assert_eq!(cttz(100i8), 2);\n-        assert_eq!(cttz(100u16), 2); assert_eq!(cttz(100i16), 2);\n-        assert_eq!(cttz(100u32), 2); assert_eq!(cttz(100i32), 2);\n-        assert_eq!(cttz(100u64), 2); assert_eq!(cttz(100i64), 2);\n-\n-        assert_eq!(cttz_nonzero(-1i8 as u8), 0); assert_eq!(cttz_nonzero(-1i8), 0);\n-        assert_eq!(cttz_nonzero(-1i16 as u16), 0); assert_eq!(cttz_nonzero(-1i16), 0);\n-        assert_eq!(cttz_nonzero(-1i32 as u32), 0); assert_eq!(cttz_nonzero(-1i32), 0);\n-        assert_eq!(cttz_nonzero(-1i64 as u64), 0); assert_eq!(cttz_nonzero(-1i64), 0);\n-\n-        assert_eq!(cttz_nonzero(1u8), 0); assert_eq!(cttz_nonzero(1i8), 0);\n-        assert_eq!(cttz_nonzero(1u16), 0); assert_eq!(cttz_nonzero(1i16), 0);\n-        assert_eq!(cttz_nonzero(1u32), 0); assert_eq!(cttz_nonzero(1i32), 0);\n-        assert_eq!(cttz_nonzero(1u64), 0); assert_eq!(cttz_nonzero(1i64), 0);\n-\n-        assert_eq!(cttz_nonzero(10u8), 1); assert_eq!(cttz_nonzero(10i8), 1);\n-        assert_eq!(cttz_nonzero(10u16), 1); assert_eq!(cttz_nonzero(10i16), 1);\n-        assert_eq!(cttz_nonzero(10u32), 1); assert_eq!(cttz_nonzero(10i32), 1);\n-        assert_eq!(cttz_nonzero(10u64), 1); assert_eq!(cttz_nonzero(10i64), 1);\n-\n-        assert_eq!(cttz_nonzero(100u8), 2); assert_eq!(cttz_nonzero(100i8), 2);\n-        assert_eq!(cttz_nonzero(100u16), 2); assert_eq!(cttz_nonzero(100i16), 2);\n-        assert_eq!(cttz_nonzero(100u32), 2); assert_eq!(cttz_nonzero(100i32), 2);\n-        assert_eq!(cttz_nonzero(100u64), 2); assert_eq!(cttz_nonzero(100i64), 2);\n-\n-        assert_eq!(bswap(0x0Au8), 0x0A); // no-op\n-        assert_eq!(bswap(0x0Ai8), 0x0A); // no-op\n-        assert_eq!(bswap(0x0A0Bu16), 0x0B0A);\n-        assert_eq!(bswap(0x0A0Bi16), 0x0B0A);\n-        assert_eq!(bswap(0x0ABBCC0Du32), 0x0DCCBB0A);\n-        assert_eq!(bswap(0x0ABBCC0Di32), 0x0DCCBB0A);\n-        assert_eq!(bswap(0x0122334455667708u64), 0x0877665544332201);\n-        assert_eq!(bswap(0x0122334455667708i64), 0x0877665544332201);\n-    }\n-}"}, {"sha": "a2c55634749cbfef24f225727b07a2af0f74577a", "filename": "tests/run-pass/intrinsics-math.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintrinsics-math.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-macro_rules! assert_approx_eq {\n-    ($a:expr, $b:expr) => ({\n-        let (a, b) = (&$a, &$b);\n-        assert!((*a - *b).abs() < 1.0e-6,\n-                \"{} is not approximately equal to {}\", *a, *b);\n-    })\n-}\n-\n-pub fn main() {\n-    use std::f32;\n-    use std::f64;\n-\n-    assert_approx_eq!(64f32.sqrt(), 8f32);\n-    assert_approx_eq!(64f64.sqrt(), 8f64);\n-\n-    assert_approx_eq!(25f32.powi(-2), 0.0016f32);\n-    assert_approx_eq!(23.2f64.powi(2), 538.24f64);\n-\n-    assert_approx_eq!(0f32.sin(), 0f32);\n-    assert_approx_eq!((f64::consts::PI / 2f64).sin(), 1f64);\n-\n-    assert_approx_eq!(0f32.cos(), 1f32);\n-    assert_approx_eq!((f64::consts::PI * 2f64).cos(), 1f64);\n-\n-    assert_approx_eq!(25f32.powf(-2f32), 0.0016f32);\n-    assert_approx_eq!(400f64.powf(0.5f64), 20f64);\n-\n-    assert_approx_eq!((1f32.exp() - f32::consts::E).abs(), 0f32);\n-    assert_approx_eq!(1f64.exp(), f64::consts::E);\n-\n-    assert_approx_eq!(10f32.exp2(), 1024f32);\n-    assert_approx_eq!(50f64.exp2(), 1125899906842624f64);\n-\n-    assert_approx_eq!((f32::consts::E.ln() - 1f32).abs(), 0f32);\n-    assert_approx_eq!(1f64.ln(), 0f64);\n-\n-    assert_approx_eq!(10f32.log10(), 1f32);\n-    assert_approx_eq!(f64::consts::E.log10(), f64::consts::LOG10_E);\n-\n-    assert_approx_eq!(8f32.log2(), 3f32);\n-    assert_approx_eq!(f64::consts::E.log2(), f64::consts::LOG2_E);\n-\n-    assert_approx_eq!(1.0f32.mul_add(2.0f32, 5.0f32), 7.0f32);\n-    assert_approx_eq!(0.0f64.mul_add(-2.0f64, f64::consts::E), f64::consts::E);\n-\n-    assert_approx_eq!((-1.0f32).abs(), 1.0f32);\n-    assert_approx_eq!(34.2f64.abs(), 34.2f64);\n-\n-    assert_approx_eq!(3.8f32.floor(), 3.0f32);\n-    assert_approx_eq!((-1.1f64).floor(), -2.0f64);\n-\n-    assert_approx_eq!((-2.3f32).ceil(), -2.0f32);\n-    assert_approx_eq!(3.8f64.ceil(), 4.0f64);\n-\n-    assert_approx_eq!(0.1f32.trunc(), 0.0f32);\n-    assert_approx_eq!((-0.1f64).trunc(), 0.0f64);\n-}"}, {"sha": "3152737a601ca01648e553d93d6a2c8fecc7feae", "filename": "tests/run-pass/intrinsics.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintrinsics.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-use std::mem::{size_of, size_of_val};\n-\n-fn main() {\n-    assert_eq!(size_of::<Option<i32>>(), 8);\n-    assert_eq!(size_of_val(&()), 0);\n-    assert_eq!(size_of_val(&42), 4);\n-    assert_eq!(size_of_val(&[] as &[i32]), 0);\n-    assert_eq!(size_of_val(&[1, 2, 3] as &[i32]), 12);\n-    assert_eq!(size_of_val(\"foobar\"), 6);\n-}"}, {"sha": "4f23b5ec9c3816647be90d643b7cac4b8cd90481", "filename": "tests/run-pass/ints.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fints.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,58 +0,0 @@\n-fn ret() -> i64 {\n-    1\n-}\n-\n-fn neg() -> i64 {\n-    -1\n-}\n-\n-fn add() -> i64 {\n-    1 + 2\n-}\n-\n-fn indirect_add() -> i64 {\n-    let x = 1;\n-    let y = 2;\n-    x + y\n-}\n-\n-fn arith() -> i32 {\n-    3*3 + 4*4\n-}\n-\n-fn match_int() -> i16 {\n-    let n = 2;\n-    match n {\n-        0 => 0,\n-        1 => 10,\n-        2 => 20,\n-        3 => 30,\n-        _ => 100,\n-    }\n-}\n-\n-fn match_int_range() -> i64 {\n-    let n = 42;\n-    match n {\n-        0...9 => 0,\n-        10...19 => 1,\n-        20...29 => 2,\n-        30...39 => 3,\n-        40...49 => 4,\n-        _ => 5,\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(ret(), 1);\n-    assert_eq!(neg(), -1);\n-    assert_eq!(add(), 3);\n-    assert_eq!(indirect_add(), 3);\n-    assert_eq!(arith(), 5*5);\n-    assert_eq!(match_int(), 20);\n-    assert_eq!(match_int_range(), 4);\n-    assert_eq!(i64::min_value().overflowing_mul(-1), (i64::min_value(), true));\n-    assert_eq!(i32::min_value().overflowing_mul(-1), (i32::min_value(), true));\n-    assert_eq!(i16::min_value().overflowing_mul(-1), (i16::min_value(), true));\n-    assert_eq!(i8::min_value().overflowing_mul(-1), (i8::min_value(), true));\n-}"}, {"sha": "726aee283e2921494d45de44f04d271df40f137a", "filename": "tests/run-pass/issue-15063.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-15063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-15063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-15063.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-\n-enum Two { A, B }\n-impl Drop for Two {\n-    fn drop(&mut self) {\n-    }\n-}\n-fn main() {\n-    let _k = Two::A;\n-}"}, {"sha": "33c81cab3817bb6ba26c1260d27dbf1b4a514dba", "filename": "tests/run-pass/issue-15523-big.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-15523-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-15523-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-15523-big.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Issue 15523: derive(PartialOrd) should use the provided\n-// discriminant values for the derived ordering.\n-//\n-// This test is checking corner cases that arise when you have\n-// 64-bit values in the variants.\n-\n-#[derive(PartialEq, PartialOrd)]\n-#[repr(u64)]\n-enum Eu64 {\n-    Pos2 = 2,\n-    PosMax = !0,\n-    Pos1 = 1,\n-}\n-\n-#[derive(PartialEq, PartialOrd)]\n-#[repr(i64)]\n-enum Ei64 {\n-    Pos2 = 2,\n-    Neg1 = -1,\n-    NegMin = 1 << 63,\n-    PosMax = !(1 << 63),\n-    Pos1 = 1,\n-}\n-\n-fn main() {\n-    assert!(Eu64::Pos2 > Eu64::Pos1);\n-    assert!(Eu64::Pos2 < Eu64::PosMax);\n-    assert!(Eu64::Pos1 < Eu64::PosMax);\n-\n-\n-    assert!(Ei64::Pos2 > Ei64::Pos1);\n-    assert!(Ei64::Pos2 > Ei64::Neg1);\n-    assert!(Ei64::Pos1 > Ei64::Neg1);\n-    assert!(Ei64::Pos2 > Ei64::NegMin);\n-    assert!(Ei64::Pos1 > Ei64::NegMin);\n-    assert!(Ei64::Pos2 < Ei64::PosMax);\n-    assert!(Ei64::Pos1 < Ei64::PosMax);\n-}"}, {"sha": "b4b74b9905fbb60e14c03cfc140cced87bf43f76", "filename": "tests/run-pass/issue-17877.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-17877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-17877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-17877.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-msvc\n-\n-#![feature(slice_patterns)]\n-\n-fn main() {\n-    assert_eq!(match [0u8; 1024] {\n-        _ => 42_usize,\n-    }, 42_usize);\n-\n-    assert_eq!(match [0u8; 1024] {\n-        [1, _..] => 0_usize,\n-        [0, _..] => 1_usize,\n-        _ => 2_usize\n-    }, 1_usize);\n-}"}, {"sha": "7db7e3b28e8e66c3728d00ceccef0b4539f44da4", "filename": "tests/run-pass/issue-20575.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-20575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-20575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-20575.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that overloaded calls work with zero arity closures\n-\n-// pretty-expanded FIXME #23616\n-\n-fn main() {\n-    let functions: [Box<Fn() -> Option<()>>; 1] = [Box::new(|| None)];\n-\n-    let _: Option<Vec<()>> = functions.iter().map(|f| (*f)()).collect();\n-}"}, {"sha": "fc806f5429a47c320a9c55a37aa204b8f3bdcf5a", "filename": "tests/run-pass/issue-23261.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-23261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-23261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-23261.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,70 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Matching on a DST struct should not trigger an LLVM assertion.\n-\n-struct Foo<T: ?Sized> {\n-    a: i32,\n-    inner: T\n-}\n-\n-trait Get {\n-    fn get(&self) -> i32;\n-}\n-\n-impl Get for i32 {\n-    fn get(&self) -> i32 {\n-        *self\n-    }\n-}\n-\n-fn check_val(val: &Foo<[u8]>) {\n-    match *val {\n-        Foo { a, .. } => {\n-            assert_eq!(a, 32);\n-        }\n-    }\n-}\n-\n-fn check_dst_val(val: &Foo<[u8]>) {\n-    match *val {\n-        Foo { ref inner, .. } => {\n-            assert_eq!(inner, [1, 2, 3]);\n-        }\n-    }\n-}\n-\n-fn check_both(val: &Foo<[u8]>) {\n-    match *val {\n-        Foo { a, ref inner } => {\n-            assert_eq!(a, 32);\n-            assert_eq!(inner, [1, 2, 3]);\n-        }\n-    }\n-}\n-\n-fn check_trait_obj(val: &Foo<Get>) {\n-    match *val {\n-        Foo { a, ref inner } => {\n-            assert_eq!(a, 32);\n-            assert_eq!(inner.get(), 32);\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let foo: &Foo<[u8]> = &Foo { a: 32, inner: [1, 2, 3] };\n-    check_val(foo);\n-    check_dst_val(foo);\n-    check_both(foo);\n-\n-    let foo: &Foo<Get> = &Foo { a: 32, inner: 32 };\n-    check_trait_obj(foo);\n-}"}, {"sha": "62626d75865cfc87f424ae16bf1c01705b0cc716", "filename": "tests/run-pass/issue-26709.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-26709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-26709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-26709.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Wrapper<'a, T: ?Sized>(&'a mut i32, T);\n-\n-impl<'a, T: ?Sized> Drop for Wrapper<'a, T> {\n-    fn drop(&mut self) {\n-        *self.0 = 432;\n-    }\n-}\n-\n-fn main() {\n-    let mut x = 0;\n-    {\n-        let wrapper = Box::new(Wrapper(&mut x, 123));\n-        let _: Box<Wrapper<Send>> = wrapper;\n-    }\n-    assert_eq!(432, x)\n-}"}, {"sha": "b7a9daaf8abd4c2fdc3db971b8c2e14ffcf9554f", "filename": "tests/run-pass/issue-27901.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-27901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-27901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-27901.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait Stream { type Item; }\n-impl<'a> Stream for &'a str { type Item = u8; }\n-fn f<'s>(s: &'s str) -> (&'s str, <&'s str as Stream>::Item) {\n-    (s, 42)\n-}\n-\n-fn main() {\n-    let fx = f as for<'t> fn(&'t str) -> (&'t str, <&'t str as Stream>::Item);\n-    assert_eq!(fx(\"hi\"), (\"hi\", 42));\n-}"}, {"sha": "61c601ac6a903d887306a55d204b90d153a629b9", "filename": "tests/run-pass/issue-29746.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-29746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-29746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-29746.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// zip!(a1,a2,a3,a4) is equivalent to:\n-//  a1.zip(a2).zip(a3).zip(a4).map(|(((x1,x2),x3),x4)| (x1,x2,x3,x4))\n-macro_rules! zip {\n-    // Entry point\n-    ([$a:expr, $b:expr, $($rest:expr),*]) => {\n-        zip!([$($rest),*], $a.zip($b), (x,y), [x,y])\n-    };\n-\n-    // Intermediate steps to build the zipped expression, the match pattern, and\n-    //  and the output tuple of the closure, using macro hygene to repeatedly\n-    //  introduce new variables named 'x'.\n-    ([$a:expr, $($rest:expr),*], $zip:expr, $pat:pat, [$($flat:expr),*]) => {\n-        zip!([$($rest),*], $zip.zip($a), ($pat,x), [$($flat),*, x])\n-    };\n-\n-    // Final step\n-    ([], $zip:expr, $pat:pat, [$($flat:expr),+]) => {\n-        $zip.map(|$pat| ($($flat),+))\n-    };\n-\n-    // Comma\n-    ([$a:expr], $zip:expr, $pat:pat, [$($flat:expr),*]) => {\n-        zip!([$a,], $zip, $pat, [$($flat),*])\n-    };\n-}\n-\n-fn main() {\n-    let p1 = vec![1i32,    2].into_iter();\n-    let p2 = vec![\"10\",    \"20\"].into_iter();\n-    let p3 = vec![100u16,  200].into_iter();\n-    let p4 = vec![1000i64, 2000].into_iter();\n-\n-    let e = zip!([p1,p2,p3,p4]).collect::<Vec<_>>();\n-    assert_eq!(e[0], (1i32,\"10\",100u16,1000i64));\n-}"}, {"sha": "d5139c908bdac2ea2b743c7e354c398a5c7ec399", "filename": "tests/run-pass/issue-30530.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-30530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-30530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-30530.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Regression test for Issue #30530: alloca's created for storing\n-// intermediate scratch values during brace-less match arms need to be\n-// initialized with their drop-flag set to \"dropped\" (or else we end\n-// up running the destructors on garbage data at the end of the\n-// function).\n-\n-pub enum Handler {\n-    Default,\n-    #[allow(dead_code)]\n-    Custom(*mut Box<Fn()>),\n-}\n-\n-fn main() {\n-    take(Handler::Default, Box::new(main));\n-}\n-\n-#[inline(never)]\n-pub fn take(h: Handler, f: Box<Fn()>) -> Box<Fn()> {\n-    unsafe {\n-        match h {\n-            Handler::Custom(ptr) => *Box::from_raw(ptr),\n-            Handler::Default => f,\n-        }\n-    }\n-}"}, {"sha": "14e38f43c527bd2df3e69f09436e439e4c316cd0", "filename": "tests/run-pass/issue-31267-additional.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-31267-additional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-31267-additional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-31267-additional.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(unused_variables)]\n-\n-#[derive(Clone, Copy, Debug)]\n-struct Bar;\n-\n-const BAZ: Bar = Bar;\n-\n-#[derive(Debug)]\n-struct Foo([Bar; 1]);\n-\n-struct Biz;\n-\n-impl Biz {\n-    const BAZ: Foo = Foo([BAZ; 1]);\n-}\n-\n-fn main() {\n-    let foo = Biz::BAZ;\n-}"}, {"sha": "edbf2b81ce941e2ae140848723c64f36ae8b9462", "filename": "tests/run-pass/issue-33387.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-33387.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-33387.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-33387.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::sync::Arc;\n-\n-trait Foo {}\n-\n-impl Foo for [u8; 2] {}\n-\n-fn main() {\n-    let _: Arc<Foo + Send> = Arc::new([3, 4]);\n-}"}, {"sha": "7d804156576553419f09fe556c5f11c736939fe4", "filename": "tests/run-pass/issue-34571.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-34571.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-34571.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-34571.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[repr(u8)]\n-enum Foo {\n-    Foo(u8),\n-}\n-\n-fn main() {\n-    match Foo::Foo(1) {\n-        _ => ()\n-    }\n-}"}, {"sha": "216e06c0732c84ee22b9f4e77f4fbcd51d129c4c", "filename": "tests/run-pass/issue-35815.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-35815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-35815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-35815.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-\n-use std::mem;\n-\n-struct Foo<T: ?Sized> {\n-    a: i64,\n-    b: bool,\n-    c: T,\n-}\n-\n-fn main() {\n-    let foo: &Foo<i32> = &Foo { a: 1, b: false, c: 2i32 };\n-    let foo_unsized: &Foo<Send> = foo;\n-    assert_eq!(mem::size_of_val(foo), mem::size_of_val(foo_unsized));\n-}"}, {"sha": "95269d0569dec11e7fb6532ee671b799be609217", "filename": "tests/run-pass/issue-36278-prefix-nesting.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-36278-prefix-nesting.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Issue 36278: On an unsized struct with >1 level of nontrivial\n-// nesting, ensure we are computing dynamic size of prefix correctly.\n-\n-use std::mem;\n-\n-const SZ: usize = 100;\n-struct P<T: ?Sized>([u8; SZ], T);\n-\n-type Ack<T> = P<P<T>>;\n-\n-fn main() {\n-    let size_of_sized; let size_of_unsized;\n-    let x: Box<Ack<[u8; 0]>> = Box::new(P([0; SZ], P([0; SZ], [0; 0])));\n-    size_of_sized = mem::size_of_val::<Ack<_>>(&x);\n-    let y: Box<Ack<[u8   ]>> = x;\n-    size_of_unsized = mem::size_of_val::<Ack<_>>(&y);\n-    assert_eq!(size_of_sized, size_of_unsized);\n-}"}, {"sha": "69b95f2cd7e10a2b9efd34e8823680d4cf9749da", "filename": "tests/run-pass/issue-5917.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-5917.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-5917.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-5917.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-struct T (&'static [isize]);\n-static STATIC : T = T (&[5, 4, 3]);\n-pub fn main () {\n-    let T(ref v) = STATIC;\n-    assert_eq!(v[0], 5);\n-}"}, {"sha": "24775fe8a2d9df52dac1bb65ab614e17399e6eb1", "filename": "tests/run-pass/issue-miri-184.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-miri-184.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fissue-miri-184.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fissue-miri-184.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-pub fn main() {\n-    let bytes: [u8; 8] = unsafe { ::std::mem::transmute(0u64) };\n-    let _: &[u8] = &bytes;\n-}"}, {"sha": "fd7229c3455e4da6a491d289b056fad62c91282a", "filename": "tests/run-pass/iter_slice.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fiter_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fiter_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter_slice.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,12 +0,0 @@\n-fn main() {\n-    for _ in Vec::<u32>::new().iter() { // this iterates over a Unique::empty()\n-        panic!(\"We should never be here.\");\n-    }\n-\n-    // Iterate over a ZST (uses arith_offset internally)\n-    let mut count = 0;\n-    for _ in &[(), (), ()] {\n-        count += 1;\n-    }\n-    assert_eq!(count, 3);\n-}"}, {"sha": "de2d815ca54ebe5de160bf28cde817197e4f5c54", "filename": "tests/run-pass/last-use-in-cap-clause.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Make sure #1399 stays fixed\n-\n-#[allow(dead_code)]\n-struct A { a: Box<isize> }\n-\n-fn foo() -> Box<FnMut() -> isize + 'static> {\n-    let k: Box<_> = Box::new(22);\n-    let _u = A {a: k.clone()};\n-    let result  = || 22;\n-    Box::new(result)\n-}\n-\n-pub fn main() {\n-    assert_eq!(foo()(), 22);\n-}"}, {"sha": "222287cbe09adcf4ad2936ca28ff72baebdbf82f", "filename": "tests/run-pass/loops.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Floops.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,35 +0,0 @@\n-fn factorial_loop() -> i64 {\n-    let mut product = 1;\n-    let mut i = 1;\n-\n-    while i <= 10 {\n-        product *= i;\n-        i += 1;\n-    }\n-\n-    product\n-}\n-\n-fn index_for_loop() -> usize {\n-    let mut sum = 0;\n-    let a = [0, 10, 20, 30];\n-    for i in 0..a.len() {\n-        sum += a[i];\n-    }\n-    sum\n-}\n-\n-fn for_loop() -> usize {\n-    let mut sum = 0;\n-    let a = [0, 10, 20, 30];\n-    for &n in &a {\n-        sum += n;\n-    }\n-    sum\n-}\n-\n-fn main() {\n-    assert_eq!(factorial_loop(), 3628800);\n-    assert_eq!(index_for_loop(), 60);\n-    assert_eq!(for_loop(), 60);\n-}"}, {"sha": "91d183ee6af70f1362eb94e0a49d24d172c538db", "filename": "tests/run-pass/main_fn.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmain_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmain_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmain_fn.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,5 +0,0 @@\n-#![feature(main)]\n-\n-#[main]\n-fn foo() {\n-}"}, {"sha": "393bafebfe4d6cde0fb5bc832358d05fe208fdeb", "filename": "tests/run-pass/many_shr_bor.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmany_shr_bor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmany_shr_bor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmany_shr_bor.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,36 +0,0 @@\n-// Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n-#![allow(unused_variables)]\n-use std::cell::RefCell;\n-\n-struct Test {\n-    a: u32,\n-    b: u32,\n-}\n-\n-fn test1() {\n-    let t = &mut Test { a: 0, b: 0 };\n-    {\n-        let x;\n-        {\n-            let y = &t.a;\n-            x = &t;\n-            let _y = *y;\n-        }\n-        let _x = x.a;\n-    }\n-    t.b = 42;\n-}\n-\n-fn test2(r: &mut RefCell<i32>) {\n-    let x = &*r; // releasing write lock, first suspension recorded\n-    let mut x_ref = x.borrow_mut();\n-    let x_inner : &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n-    let x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n-    let y = &*r; // second suspension for the outer write lock\n-    let x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock\n-}\n-\n-fn main() {\n-    test1();\n-    test2(&mut RefCell::new(0));\n-}"}, {"sha": "568a1a1c881827779d837912424f78d57abb7acc", "filename": "tests/run-pass/match_slice.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmatch_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmatch_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmatch_slice.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    let x = \"hello\";\n-    match x {\n-        \"foo\" => {},\n-        \"bar\" => {},\n-        _ => {},\n-    }\n-}"}, {"sha": "36155297e32f0224f9d9ef637944b0b3497daf3c", "filename": "tests/run-pass/mir_coercions.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmir_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmir_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmir_coercions.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,80 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(coerce_unsized, unsize)]\n-\n-use std::ops::CoerceUnsized;\n-use std::marker::Unsize;\n-\n-fn identity_coercion(x: &(Fn(u32)->u32 + Send)) -> &Fn(u32)->u32 {\n-    x\n-}\n-fn fn_coercions(f: &fn(u32) -> u32) ->\n-    (unsafe fn(u32) -> u32,\n-     &(Fn(u32) -> u32+Send))\n-{\n-    (*f, f)\n-}\n-\n-fn simple_array_coercion(x: &[u8; 3]) -> &[u8] { x }\n-\n-fn square(a: u32) -> u32 { a * a }\n-\n-#[derive(PartialEq,Eq)]\n-struct PtrWrapper<'a, T: 'a+?Sized>(u32, u32, (), &'a T);\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n-    CoerceUnsized<PtrWrapper<'a, U>> for PtrWrapper<'a, T> {}\n-\n-struct TrivPtrWrapper<'a, T: 'a+?Sized>(&'a T);\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n-    CoerceUnsized<TrivPtrWrapper<'a, U>> for TrivPtrWrapper<'a, T> {}\n-\n-fn coerce_ptr_wrapper(p: PtrWrapper<[u8; 3]>) -> PtrWrapper<[u8]> {\n-    p\n-}\n-\n-fn coerce_triv_ptr_wrapper(p: TrivPtrWrapper<[u8; 3]>) -> TrivPtrWrapper<[u8]> {\n-    p\n-}\n-\n-fn coerce_fat_ptr_wrapper(p: PtrWrapper<Fn(u32) -> u32+Send>)\n-                          -> PtrWrapper<Fn(u32) -> u32> {\n-    p\n-}\n-\n-fn coerce_ptr_wrapper_poly<'a, T, Trait: ?Sized>(p: PtrWrapper<'a, T>)\n-                                                 -> PtrWrapper<'a, Trait>\n-    where PtrWrapper<'a, T>: CoerceUnsized<PtrWrapper<'a, Trait>>\n-{\n-    p\n-}\n-\n-fn main() {\n-    let a = [0,1,2];\n-    let square_local : fn(u32) -> u32 = square;\n-    let (f,g) = fn_coercions(&square_local);\n-    assert_eq!(f as *const (), square as *const());\n-    assert_eq!(g(4), 16);\n-    assert_eq!(identity_coercion(g)(5), 25);\n-\n-    assert_eq!(simple_array_coercion(&a), &a);\n-    let w = coerce_ptr_wrapper(PtrWrapper(2,3,(),&a));\n-    assert!(w == PtrWrapper(2,3,(),&a) as PtrWrapper<[u8]>);\n-\n-    let w = coerce_triv_ptr_wrapper(TrivPtrWrapper(&a));\n-    assert_eq!(&w.0, &a);\n-\n-    let z = coerce_fat_ptr_wrapper(PtrWrapper(2,3,(),&square_local));\n-    assert_eq!((z.3)(6), 36);\n-\n-    let z: PtrWrapper<Fn(u32) -> u32> =\n-        coerce_ptr_wrapper_poly(PtrWrapper(2,3,(),&square_local));\n-    assert_eq!((z.3)(6), 36);\n-}"}, {"sha": "e5c9e3577d1c302a1cd6458eccf6019e01e1845b", "filename": "tests/run-pass/mir_fat_ptr.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmir_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmir_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmir_fat_ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// test that ordinary fat pointer operations work.\n-\n-struct Wrapper<T: ?Sized>(u32, T);\n-\n-struct FatPtrContainer<'a> {\n-    ptr: &'a [u8]\n-}\n-\n-fn fat_ptr_project(a: &Wrapper<[u8]>) -> &[u8] {\n-    &a.1\n-}\n-\n-fn fat_ptr_simple(a: &[u8]) -> &[u8] {\n-    a\n-}\n-\n-fn fat_ptr_via_local(a: &[u8]) -> &[u8] {\n-    let x = a;\n-    x\n-}\n-\n-fn fat_ptr_from_struct(s: FatPtrContainer) -> &[u8] {\n-    s.ptr\n-}\n-\n-fn fat_ptr_to_struct(a: &[u8]) -> FatPtrContainer {\n-    FatPtrContainer { ptr: a }\n-}\n-\n-fn fat_ptr_store_to<'a>(a: &'a [u8], b: &mut &'a [u8]) {\n-    *b = a;\n-}\n-\n-fn fat_ptr_constant() -> &'static str {\n-    \"HELLO\"\n-}\n-\n-fn main() {\n-    let a = Wrapper(4, [7,6,5]);\n-\n-    let p = fat_ptr_project(&a);\n-    let p = fat_ptr_simple(p);\n-    let p = fat_ptr_via_local(p);\n-    let p = fat_ptr_from_struct(fat_ptr_to_struct(p));\n-\n-    let mut target : &[u8] = &[42];\n-    fat_ptr_store_to(p, &mut target);\n-    assert_eq!(target, &a.1);\n-\n-    assert_eq!(fat_ptr_constant(), \"HELLO\");\n-}"}, {"sha": "406b5e102c8b4b87d74880c37db927a6a909979c", "filename": "tests/run-pass/miri-issue-133.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmiri-issue-133.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmiri-issue-133.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmiri-issue-133.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,30 +0,0 @@\n-use std::mem::size_of;\n-\n-struct S<U, V> {\n-    _u: U,\n-    size_of_u: usize,\n-    _v: V,\n-    size_of_v: usize\n-}\n-\n-impl<U, V> S<U, V> {\n-    fn new(u: U, v: V) -> Self {\n-        S {\n-            _u: u,\n-            size_of_u: size_of::<U>(),\n-            _v: v,\n-            size_of_v: size_of::<V>()\n-        }\n-    }\n-}\n-\n-impl<V, U> Drop for S<U, V> {\n-    fn drop(&mut self) {\n-        assert_eq!(size_of::<U>(), self.size_of_u);\n-        assert_eq!(size_of::<V>(), self.size_of_v);\n-    }\n-}\n-\n-fn main() {\n-    S::new(0u8, 1u16);\n-}"}, {"sha": "2e6320eb8025725ac802390ccbe674e9068d6791", "filename": "tests/run-pass/move-arg-3-unique.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmove-arg-3-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmove-arg-3-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-arg-3-unique.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(unused_features, unused_variables)]\n-#![feature(box_syntax)]\n-\n-pub fn main() {\n-    let x = box 10;\n-    let y = x;\n-    assert_eq!(*y, 10);\n-}"}, {"sha": "2c18c2d3687a5f9b879154f2a3b8d297a0871bb4", "filename": "tests/run-pass/move-undef-primval.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmove-undef-primval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmove-undef-primval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmove-undef-primval.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-// Moving around undef is not allowed by validation\n-// compile-flags: -Zmir-emit-validate=0\n-\n-struct Foo {\n-    _inner: i32,\n-}\n-\n-fn main() {\n-    unsafe {\n-        let foo = Foo {\n-            _inner: std::mem::uninitialized(),\n-        };\n-        let _bar = foo;\n-    }\n-}"}, {"sha": "30cfb5b685b2098c4a901d67577250699c1bbe18", "filename": "tests/run-pass/multi_arg_closure.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmulti_arg_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fmulti_arg_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmulti_arg_closure.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn foo(f: &mut FnMut(isize, isize) -> isize) -> isize {\n-    f(1, 2)\n-}\n-\n-fn main() {\n-    let z = foo(&mut |x, y| x * 10 + y);\n-    assert_eq!(z, 12);\n-}"}, {"sha": "16f175e7dfc808b8236e2cc03868c84fc555e114", "filename": "tests/run-pass/negative_discriminant.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fnegative_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fnegative_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fnegative_discriminant.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,13 +0,0 @@\n-enum AB { A = -1, B = 1 }\n-\n-fn main() {\n-    match AB::A {\n-        AB::A => (),\n-        AB::B => panic!(),\n-    }\n-\n-    match AB::B {\n-        AB::A => panic!(),\n-        AB::B => (),\n-    }\n-}"}, {"sha": "c9daff9c9f46931c2fe3d718f0add767c0b5db84", "filename": "tests/run-pass/non_capture_closure_to_fn_ptr.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fnon_capture_closure_to_fn_ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-// allow(const_err) to work around a bug in warnings\n-#[allow(const_err)]\n-static FOO: fn() = || { assert_ne!(42, 43) };\n-#[allow(const_err)]\n-static BAR: fn(i32, i32) = |a, b| { assert_ne!(a, b) };\n-\n-fn main() {\n-    FOO();\n-    BAR(44, 45);\n-    let bar: unsafe fn(i32, i32) = BAR;\n-    unsafe { bar(46, 47) };\n-    let boo: &Fn(i32, i32) = &BAR;\n-    boo(48, 49);\n-}"}, {"sha": "a4ecf1e635d24d99fc5f967b3300c27360712819", "filename": "tests/run-pass/observed_local_mut.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fobserved_local_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fobserved_local_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fobserved_local_mut.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,21 +0,0 @@\n-// This test is intended to guard against the problem described in commit\n-// 39bb1254d1eaf74f45a4e741097e33fc942168d5.\n-//\n-// As written, it might be considered UB in compiled Rust, but of course Miri gives it a safe,\n-// deterministic behaviour (one that might not correspond with how an eventual Rust spec would\n-// defined this).\n-//\n-// An alternative way to write the test without `unsafe` would be to use `Cell<i32>`, but it would\n-// only surface the bug described by the above commit if `Cell<i32>` on the stack got represented\n-// as a primitive `PrimVal::I32` which is not yet the case.\n-\n-fn main() {\n-    let mut x = 0;\n-    let y: *const i32 = &x;\n-    x = 1;\n-\n-    // When the described bug is in place, this results in `0`, not observing the `x = 1` line.\n-    assert_eq!(unsafe { *y }, 1);\n-\n-    assert_eq!(x, 1);\n-}"}, {"sha": "0786db1ef895a431857758969dc03910e4de1c9b", "filename": "tests/run-pass/option_box_transmute_ptr.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Foption_box_transmute_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Foption_box_transmute_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Foption_box_transmute_ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,15 +0,0 @@\n-// This tests that the size of Option<Box<i32>> is the same as *const i32.\n-fn option_box_deref() -> i32 {\n-    let val = Some(Box::new(42));\n-    unsafe {\n-        let ptr: *const i32 = std::mem::transmute::<Option<Box<i32>>, *const i32>(val);\n-        let ret = *ptr;\n-        // unleak memory\n-        std::mem::transmute::<*const i32, Option<Box<i32>>>(ptr);\n-        ret\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(option_box_deref(), 42);\n-}"}, {"sha": "e698f8767746c27bc77efc96afbff56c5bdb6341", "filename": "tests/run-pass/option_eq.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Foption_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Foption_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Foption_eq.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,3 +0,0 @@\n-fn main() {\n-    assert_eq!(std::char::from_u32('x' as u32), Some('x'));\n-}"}, {"sha": "1eeda12ca06f8101abf9e0182c5c0baa46582e96", "filename": "tests/run-pass/overloaded-calls-simple.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Foverloaded-calls-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Foverloaded-calls-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Foverloaded-calls-simple.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![feature(lang_items, unboxed_closures, fn_traits)]\n-\n-struct S3 {\n-    x: i32,\n-    y: i32,\n-}\n-\n-impl FnOnce<(i32,i32)> for S3 {\n-    type Output = i32;\n-    extern \"rust-call\" fn call_once(self, (z,zz): (i32,i32)) -> i32 {\n-        self.x * self.y * z * zz\n-    }\n-}\n-\n-fn main() {\n-    let s = S3 {\n-        x: 3,\n-        y: 3,\n-    };\n-    let ans = s(3, 1);\n-    assert_eq!(ans, 27);\n-}"}, {"sha": "1fa3a369670bbc2512f063a5b158fc8394b88e27", "filename": "tests/run-pass/packed_static.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fpacked_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fpacked_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_static.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,10 +0,0 @@\n-#[repr(packed)]\n-struct Foo {\n-    i: i32\n-}\n-\n-fn main() {\n-    assert_eq!({FOO.i}, 42);\n-}\n-\n-static FOO: Foo = Foo { i: 42 };"}, {"sha": "e0387a5f405f35b7272fad2fb83e0c54e5b39098", "filename": "tests/run-pass/packed_struct.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_struct.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,69 +0,0 @@\n-// FIXME: We have to disable this, force_allocation fails.\n-// TODO: I think this can be triggered even without validation.\n-// compile-flags: -Zmir-emit-validate=0\n-#![allow(dead_code)]\n-#![feature(unsize, coerce_unsized)]\n-\n-#[repr(packed)]\n-struct S {\n-    a: i32,\n-    b: i64,\n-}\n-\n-#[repr(packed)]\n-struct Test1<'a> {\n-    x: u8,\n-    other: &'a u32,\n-}\n-\n-#[repr(packed)]\n-struct Test2<'a> {\n-    x: u8,\n-    other: &'a Test1<'a>,\n-}\n-\n-fn test(t: Test2) {\n-    let x = *t.other.other;\n-    assert_eq!(x, 42);\n-}\n-\n-fn test_unsizing() {\n-    #[repr(packed)]\n-    struct UnalignedPtr<'a, T: ?Sized>\n-    where T: 'a,\n-    {\n-        data: &'a T,\n-    }\n-\n-    impl<'a, T, U> std::ops::CoerceUnsized<UnalignedPtr<'a, U>> for UnalignedPtr<'a, T>\n-    where\n-        T: std::marker::Unsize<U> + ?Sized,\n-        U: ?Sized,\n-    { }\n-\n-    let arr = [1, 2, 3];\n-    let arr_unaligned: UnalignedPtr<[i32; 3]> = UnalignedPtr { data: &arr };\n-    let arr_unaligned: UnalignedPtr<[i32]> = arr_unaligned;\n-    let _unused = &arr_unaligned; // forcing an allocation, which could also yield \"unaligned write\"-errors\n-}\n-\n-fn main() {\n-    let mut x = S {\n-        a: 42,\n-        b: 99,\n-    };\n-    let a = x.a;\n-    let b = x.b;\n-    assert_eq!(a, 42);\n-    assert_eq!(b, 99);\n-    // can't do `assert_eq!(x.a, 42)`, because `assert_eq!` takes a reference\n-    assert_eq!({x.a}, 42);\n-    assert_eq!({x.b}, 99);\n-\n-    x.b = 77;\n-    assert_eq!({x.b}, 77);\n-\n-    test(Test2 { x: 0, other: &Test1 { x: 0, other: &42 }});\n-\n-    test_unsizing();\n-}"}, {"sha": "f3ae3ab913a36df74f639873103cb0784204e64a", "filename": "tests/run-pass/pointers.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpointers.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,60 +0,0 @@\n-fn one_line_ref() -> i16 {\n-    *&1\n-}\n-\n-fn basic_ref() -> i16 {\n-    let x = &1;\n-    *x\n-}\n-\n-fn basic_ref_mut() -> i16 {\n-    let x = &mut 1;\n-    *x += 2;\n-    *x\n-}\n-\n-fn basic_ref_mut_var() -> i16 {\n-    let mut a = 1;\n-    {\n-        let x = &mut a;\n-        *x += 2;\n-    }\n-    a\n-}\n-\n-fn tuple_ref_mut() -> (i8, i8) {\n-    let mut t = (10, 20);\n-    {\n-        let x = &mut t.1;\n-        *x += 2;\n-    }\n-    t\n-}\n-\n-fn match_ref_mut() -> i8 {\n-    let mut t = (20, 22);\n-    {\n-        let opt = Some(&mut t);\n-        match opt {\n-            Some(&mut (ref mut x, ref mut y)) => *x += *y,\n-            None => {},\n-        }\n-    }\n-    t.0\n-}\n-\n-fn dangling_pointer() -> *const i32 {\n-    let b = Box::new(42);\n-    &*b as *const i32\n-}\n-\n-fn main() {\n-    assert_eq!(one_line_ref(), 1);\n-    assert_eq!(basic_ref(), 1);\n-    assert_eq!(basic_ref_mut(), 3);\n-    assert_eq!(basic_ref_mut_var(), 3);\n-    assert_eq!(tuple_ref_mut(), (10, 22));\n-    assert_eq!(match_ref_mut(), 42);\n-    // FIXME: improve this test... how?\n-    assert!(dangling_pointer() != std::ptr::null());\n-}"}, {"sha": "86bb71a0be5606a8f419ddbdbe7177eaaa13004a", "filename": "tests/run-pass/products.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fproducts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fproducts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fproducts.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,32 +0,0 @@\n-fn tuple() -> (i16,) {\n-    (1,)\n-}\n-\n-fn tuple_2() -> (i16, i16) {\n-    (1, 2)\n-}\n-\n-fn tuple_5() -> (i16, i16, i16, i16, i16) {\n-    (1, 2, 3, 4, 5)\n-}\n-\n-#[derive(Debug, PartialEq)]\n-struct Pair { x: i8, y: i8 }\n-\n-fn pair() -> Pair {\n-    Pair { x: 10, y: 20 }\n-}\n-\n-fn field_access() -> (i8, i8) {\n-    let mut p = Pair { x: 10, y: 20 };\n-    p.x += 5;\n-    (p.x, p.y)\n-}\n-\n-fn main() {\n-    assert_eq!(tuple(), (1,));\n-    assert_eq!(tuple_2(), (1, 2));\n-    assert_eq!(tuple_5(), (1, 2, 3, 4, 5));\n-    assert_eq!(pair(), Pair { x: 10, y: 20} );\n-    assert_eq!(field_access(), (15, 20));\n-}"}, {"sha": "7912da9fd437ce45e8479b74bc13dedf78773af9", "filename": "tests/run-pass/ptr_arith_offset.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fptr_arith_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fptr_arith_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_arith_offset.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    let v = [1i16, 2];\n-    let x = &v as *const i16;\n-    let x = x.wrapping_offset(1);\n-    assert_eq!(unsafe { *x }, 2);\n-}"}, {"sha": "3383c3b80148209239c12898ad861fd58236b4c3", "filename": "tests/run-pass/ptr_arith_offset_overflow.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,9 +0,0 @@\n-fn main() {\n-    let v = [1i16, 2];\n-    let x = &v[1] as *const i16;\n-    // Adding 2*isize::max and then 1 is like substracting 1\n-    let x = x.wrapping_offset(isize::max_value());\n-    let x = x.wrapping_offset(isize::max_value());\n-    let x = x.wrapping_offset(1);\n-    assert_eq!(unsafe { *x }, 1);\n-}"}, {"sha": "b1b06263056d7da1c8c519b6b98bfb6ad93b2867", "filename": "tests/run-pass/ptr_int_casts.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_int_casts.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,35 +0,0 @@\n-use std::mem;\n-\n-fn eq_ref<T>(x: &T, y: &T) -> bool {\n-    x as *const _ == y as *const _\n-}\n-\n-fn f() -> i32 { 42 }\n-\n-fn main() {\n-    // int-ptr-int\n-    assert_eq!(1 as *const i32 as usize, 1);\n-    assert_eq!((1 as *const i32).wrapping_offset(4) as usize, 1 + 4*4);\n-\n-    {   // ptr-int-ptr\n-        let x = 13;\n-        let mut y = &x as &_ as *const _ as usize;\n-        y += 13;\n-        y -= 13;\n-        let y = y as *const _;\n-        assert!(eq_ref(&x, unsafe { &*y }));\n-    }\n-\n-    {   // fnptr-int-fnptr\n-        let x : fn() -> i32 = f;\n-        let y : *mut u8 = unsafe { mem::transmute(x as fn() -> i32) };\n-        let mut y = y as usize;\n-        y += 13;\n-        y -= 13;\n-        let x : fn() -> i32 = unsafe { mem::transmute(y as *mut u8) };\n-        assert_eq!(x(), 42);\n-    }\n-\n-    // involving types other than usize\n-    assert_eq!((-1i32) as usize as *const i32 as usize, (-1i32) as usize);\n-}"}, {"sha": "6add5212db9f6eef59c54f8fca1c20bb63863e18", "filename": "tests/run-pass/ptr_offset.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_offset.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    let v = [1i16, 2];\n-    let x = &v as *const i16;\n-    let x = unsafe { x.offset(1) };\n-    assert_eq!(unsafe { *x }, 2);\n-}"}, {"sha": "0bf707503112049b7ce706f3949a7ea096188a51", "filename": "tests/run-pass/rc.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frc.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,39 +0,0 @@\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-fn rc_refcell() {\n-    let r = Rc::new(RefCell::new(42));\n-    *r.borrow_mut() += 10;\n-    let x = *r.borrow();\n-    assert_eq!(x, 52);\n-}\n-\n-fn rc_raw() {\n-    let r = Rc::new(0);\n-    let r2 = Rc::into_raw(r.clone());\n-    let r2 = unsafe { Rc::from_raw(r2) };\n-    assert!(Rc::ptr_eq(&r, &r2));\n-    drop(r);\n-    assert!(Rc::try_unwrap(r2).is_ok());\n-}\n-\n-// Make sure this Rc doesn't fall apart when touched\n-fn check_unique_rc<T: ?Sized>(mut r: Rc<T>) {\n-    let r2 = r.clone();\n-    assert!(Rc::get_mut(&mut r).is_none());\n-    drop(r2);\n-    assert!(Rc::get_mut(&mut r).is_some());\n-}\n-\n-fn rc_from() {\n-    check_unique_rc::<[_]>(Rc::from(&[1,2,3] as &[_]));\n-    check_unique_rc::<[_]>(Rc::from(vec![1,2,3]));\n-    check_unique_rc::<[_]>(Rc::from(Box::new([1,2,3]) as Box<[_]>));\n-    check_unique_rc::<str>(Rc::from(\"Hello, World!\"));\n-}\n-\n-fn main() {\n-    rc_refcell();\n-    rc_raw();\n-    rc_from();\n-}"}, {"sha": "d259ca6361c978ed3bfa54e847b7226c50943d4d", "filename": "tests/run-pass/recursive_static.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Frecursive_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Frecursive_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frecursive_static.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,12 +0,0 @@\n-// FIXME: Disable validation until we figure out how to handle recursive statics.\n-// compile-flags: -Zmir-emit-validate=0\n-\n-struct S(&'static S);\n-static S1: S = S(&S2);\n-static S2: S = S(&S1);\n-\n-fn main() {\n-    let p: *const S = S2.0;\n-    let q: *const S = &S1;\n-    assert_eq!(p, q);\n-}"}, {"sha": "ebbbb77748d43c5332f2e22774acf1464f1b0fa6", "filename": "tests/run-pass/ref-invalid-ptr.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fref-invalid-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fref-invalid-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fref-invalid-ptr.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let x = 2usize as *const u32;\n-    let _y = unsafe { &*x as *const u32 };\n-\n-    let x = 0usize as *const u32;\n-    let _y = unsafe { &*x as *const u32 };\n-}"}, {"sha": "1aef95d8a3f30b4d5917ec80a574f360ac713440", "filename": "tests/run-pass/regions-lifetime-nonfree-late-bound.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fregions-lifetime-nonfree-late-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fregions-lifetime-nonfree-late-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fregions-lifetime-nonfree-late-bound.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This is a regression test for the ICE from issue #10846.\n-//\n-// The original issue causing the ICE: the LUB-computations during\n-// type inference were encountering late-bound lifetimes, and\n-// asserting that such lifetimes should have already been substituted\n-// with a concrete lifetime.\n-//\n-// However, those encounters were occurring within the lexical scope\n-// of the binding for the late-bound lifetime; that is, the late-bound\n-// lifetimes were perfectly valid.  The core problem was that the type\n-// folding code was over-zealously passing back all lifetimes when\n-// doing region-folding, when really all clients of the region-folding\n-// case only want to see FREE lifetime variables, not bound ones.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![allow(unused_features)]\n-#![feature(box_syntax)]\n-\n-pub fn main() {\n-    fn explicit() {\n-        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<for<'a> FnMut(&'a isize)>) {}\n-        test(Some(box |_f: Box<for<'a> FnMut(&'a isize)>| {}));\n-    }\n-\n-    // The code below is shorthand for the code above (and more likely\n-    // to represent what one encounters in practice).\n-    fn implicit() {\n-        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<        FnMut(&   isize)>) {}\n-        test(Some(box |_f: Box<        FnMut(&   isize)>| {}));\n-    }\n-\n-    explicit();\n-    implicit();\n-}"}, {"sha": "0ee523a5be00ac9ac8712633c20cec40399dc6ae", "filename": "tests/run-pass/rfc1623.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frfc1623.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-\n-// very simple test for a 'static static with default lifetime\n-static STATIC_STR: &str = \"&'static str\";\n-const CONST_STR: &str = \"&'static str\";\n-\n-// this should be the same as without default:\n-static EXPLICIT_STATIC_STR: &'static str = \"&'static str\";\n-const EXPLICIT_CONST_STR: &'static str = \"&'static str\";\n-\n-// a function that elides to an unbound lifetime for both in- and output\n-fn id_u8_slice(arg: &[u8]) -> &[u8] {\n-    arg\n-}\n-\n-// one with a function, argument elided\n-static STATIC_SIMPLE_FN: &fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n-const CONST_SIMPLE_FN: &fn(&[u8]) -> &[u8] = &(id_u8_slice as fn(&[u8]) -> &[u8]);\n-\n-// this should be the same as without elision\n-static STATIC_NON_ELIDED_FN: &for<'a> fn(&'a [u8]) -> &'a [u8] =\n-    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n-const CONST_NON_ELIDED_FN: &for<'a> fn(&'a [u8]) -> &'a [u8] =\n-    &(id_u8_slice as for<'a> fn(&'a [u8]) -> &'a [u8]);\n-\n-// another function that elides, each to a different unbound lifetime\n-fn multi_args(_a: &u8, _b: &u8, _c: &u8) {}\n-\n-static STATIC_MULTI_FN: &fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n-const CONST_MULTI_FN: &fn(&u8, &u8, &u8) = &(multi_args as fn(&u8, &u8, &u8));\n-\n-struct Foo<'a> {\n-    bools: &'a [bool],\n-}\n-\n-static STATIC_FOO: Foo = Foo { bools: &[true, false] };\n-const CONST_FOO: Foo = Foo { bools: &[true, false] };\n-\n-type Bar<'a> = Foo<'a>;\n-\n-static STATIC_BAR: Bar = Bar { bools: &[true, false] };\n-const CONST_BAR: Bar = Bar { bools: &[true, false] };\n-\n-type Baz<'a> = fn(&'a [u8]) -> Option<u8>;\n-\n-fn baz(e: &[u8]) -> Option<u8> {\n-    e.first().map(|x| *x)\n-}\n-\n-static STATIC_BAZ: &Baz = &(baz as Baz);\n-const CONST_BAZ: &Baz = &(baz as Baz);\n-\n-static BYTES: &[u8] = &[1, 2, 3];\n-\n-fn main() {\n-    // make sure that the lifetime is actually elided (and not defaulted)\n-    let x = &[1u8, 2, 3];\n-    STATIC_SIMPLE_FN(x);\n-    CONST_SIMPLE_FN(x);\n-\n-    STATIC_BAZ(BYTES); // neees static lifetime\n-    CONST_BAZ(BYTES);\n-\n-    // make sure this works with different lifetimes\n-    let a = &1;\n-    {\n-        let b = &2;\n-        let c = &3;\n-        CONST_MULTI_FN(a, b, c);\n-    }\n-}"}, {"sha": "7ba68e6b239c0f3fcf0efdf80f123b5c5bddb1c4", "filename": "tests/run-pass/rust-lang-org.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Frust-lang-org.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Frust-lang-org.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frust-lang-org.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,21 +0,0 @@\n-// This code is editable and runnable!\n-fn main() {\n-    // A simple integer calculator:\n-    // `+` or `-` means add or subtract by 1\n-    // `*` or `/` means multiply or divide by 2\n-\n-    let program = \"+ + * - /\";\n-    let mut accumulator = 0;\n-\n-    for token in program.chars() {\n-        match token {\n-            '+' => accumulator += 1,\n-            '-' => accumulator -= 1,\n-            '*' => accumulator *= 2,\n-            '/' => accumulator /= 2,\n-            _ => { /* ignore everything else */ }\n-        }\n-    }\n-\n-    assert_eq!(accumulator, 1);\n-}"}, {"sha": "4ac1b5436f522aad5f9538ec34b2facd7ff56d96", "filename": "tests/run-pass/send-is-not-static-par-for.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsend-is-not-static-par-for.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//ignore-windows\n-\n-use std::sync::Mutex;\n-\n-fn par_for<I, F>(iter: I, f: F)\n-    where I: Iterator,\n-          I::Item: Send,\n-          F: Fn(I::Item) + Sync\n-{\n-    for item in iter {\n-        f(item)\n-    }\n-}\n-\n-fn sum(x: &[i32]) {\n-    let sum_lengths = Mutex::new(0);\n-    par_for(x.windows(4), |x| {\n-        *sum_lengths.lock().unwrap() += x.len()\n-    });\n-\n-    assert_eq!(*sum_lengths.lock().unwrap(), (x.len() - 3) * 4);\n-}\n-\n-fn main() {\n-    let mut elements = [0; 20];\n-\n-    // iterators over references into this stack frame\n-    par_for(elements.iter_mut().enumerate(), |(i, x)| {\n-        *x = i as i32\n-    });\n-\n-    sum(&elements)\n-}"}, {"sha": "b3e07d00f010f0582b0d1647edc288f3e66b486e", "filename": "tests/run-pass/sendable-class.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsendable-class.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that a class with only sendable fields can be sent\n-\n-// pretty-expanded FIXME #23616\n-\n-use std::sync::mpsc::channel;\n-\n-#[allow(dead_code)]\n-struct Foo {\n-    i: isize,\n-    j: char,\n-}\n-\n-fn foo(i:isize, j: char) -> Foo {\n-    Foo {\n-        i: i,\n-        j: j\n-    }\n-}\n-\n-pub fn main() {\n-    let (tx, rx) = channel();\n-    let _ = tx.send(foo(42, 'c'));\n-    let _ = rx;\n-}"}, {"sha": "36567f4c03310b287fc836c184272b4811080659", "filename": "tests/run-pass/simd-intrinsic-generic-elements.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(repr_simd, platform_intrinsics)]\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-#[allow(non_camel_case_types)]\n-struct i32x2(i32, i32);\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-#[allow(non_camel_case_types)]\n-struct i32x3(i32, i32, i32);\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-#[allow(non_camel_case_types)]\n-struct i32x4(i32, i32, i32, i32);\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-#[allow(non_camel_case_types)]\n-struct i32x8(i32, i32, i32, i32,\n-             i32, i32, i32, i32);\n-\n-fn main() {\n-    let _x2 = i32x2(20, 21);\n-    let _x3 = i32x3(30, 31, 32);\n-    let _x4 = i32x4(40, 41, 42, 43);\n-    let _x8 = i32x8(80, 81, 82, 83, 84, 85, 86, 87);\n-\n-    let _y2 = i32x2(120, 121);\n-    let _y3 = i32x3(130, 131, 132);\n-    let _y4 = i32x4(140, 141, 142, 143);\n-    let _y8 = i32x8(180, 181, 182, 183, 184, 185, 186, 187);\n-\n-}"}, {"sha": "dbe8ec9addacc5f88ac0b269c0ead95a54b038da", "filename": "tests/run-pass/slice-of-zero-size-elements.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -C debug-assertions\n-\n-use std::slice;\n-\n-fn foo<T>(v: &[T]) -> Option<&[T]> {\n-    let mut it = v.iter();\n-    for _ in 0..5 {\n-        let _ = it.next();\n-    }\n-    Some(it.as_slice())\n-}\n-\n-fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n-    let mut it = v.iter_mut();\n-    for _ in 0..5 {\n-        let _ = it.next();\n-    }\n-    Some(it.into_slice())\n-}\n-\n-pub fn main() {\n-    // In a slice of zero-size elements the pointer is meaningless.\n-    // Ensure iteration still works even if the pointer is at the end of the address space.\n-    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n-    assert_eq!(slice.len(), 10);\n-    assert_eq!(slice.iter().count(), 10);\n-\n-    // .nth() on the iterator should also behave correctly\n-    let mut it = slice.iter();\n-    assert!(it.nth(5).is_some());\n-    assert_eq!(it.count(), 4);\n-\n-    // Converting Iter to a slice should never have a null pointer\n-    assert!(foo(slice).is_some());\n-\n-    // Test mutable iterators as well\n-    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n-    assert_eq!(slice.len(), 10);\n-    assert_eq!(slice.iter_mut().count(), 10);\n-\n-    {\n-        let mut it = slice.iter_mut();\n-        assert!(it.nth(5).is_some());\n-        assert_eq!(it.count(), 4);\n-    }\n-\n-    assert!(foo_mut(slice).is_some())\n-}"}, {"sha": "7576a97e36adf5715992b29a18b23754328654ee", "filename": "tests/run-pass/small_enum_size_bug.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsmall_enum_size_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsmall_enum_size_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsmall_enum_size_bug.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-#![allow(dead_code)]\n-\n-enum E {\n-    A = 1,\n-    B = 2,\n-    C = 3,\n-}\n-\n-fn main() {\n-    let enone = None::<E>;\n-    if let Some(..) = enone {\n-        panic!();\n-    }\n-}"}, {"sha": "13894926d36db81eb3645d798103822eea445f69", "filename": "tests/run-pass/specialization.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fspecialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fspecialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fspecialization.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,21 +0,0 @@\n-#![feature(specialization)]\n-\n-trait IsUnit {\n-    fn is_unit() -> bool;\n-}\n-\n-impl<T> IsUnit for T {\n-    default fn is_unit() -> bool { false }\n-}\n-\n-impl IsUnit for () {\n-    fn is_unit() -> bool { true }\n-}\n-\n-fn specialization() -> (bool, bool) {\n-    (i32::is_unit(), <()>::is_unit())\n-}\n-\n-fn main() {\n-    assert_eq!(specialization(), (false, true));\n-}"}, {"sha": "a68f727322e29910d4b72f01939dbcb02058189c", "filename": "tests/run-pass/static_memory_modification.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstatic_memory_modification.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-static mut X: usize = 5;\n-\n-fn main() {\n-    unsafe {\n-        X = 6;\n-        assert_eq!(X, 6);\n-    }\n-}"}, {"sha": "be5830698b2117c7c47420668428b236331ea754", "filename": "tests/run-pass/static_mut.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fstatic_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fstatic_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstatic_mut.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,17 +0,0 @@\n-#![allow(dead_code)]\n-\n-static mut FOO: i32 = 42;\n-static BAR: Foo = Foo(unsafe { &FOO as *const _} );\n-\n-struct Foo(*const i32);\n-\n-unsafe impl Sync for Foo {}\n-\n-fn main() {\n-    unsafe {\n-        assert_eq!(*BAR.0, 42);\n-        FOO = 5;\n-        assert_eq!(FOO, 5);\n-        assert_eq!(*BAR.0, 5);\n-    }\n-}"}, {"sha": "e0e23812d275e43e004e483f2b5381617a6a4a92", "filename": "tests/run-pass/std.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstd.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,33 +0,0 @@\n-use std::cell::{Cell, RefCell};\n-use std::rc::Rc;\n-use std::sync::Arc;\n-\n-fn rc_cell() -> Rc<Cell<i32>> {\n-    let r = Rc::new(Cell::new(42));\n-    let x = r.get();\n-    r.set(x + x);\n-    r\n-}\n-\n-fn rc_refcell() -> i32 {\n-    let r = Rc::new(RefCell::new(42));\n-    *r.borrow_mut() += 10;\n-    let x = *r.borrow();\n-    x\n-}\n-\n-fn arc() -> Arc<i32> {\n-    let a = Arc::new(42);\n-    a\n-}\n-\n-fn true_assert() {\n-    assert_eq!(1, 1);\n-}\n-\n-fn main() {\n-    assert_eq!(*arc(), 42);\n-    assert_eq!(rc_cell().get(), 84);\n-    assert_eq!(rc_refcell(), 52);\n-    true_assert();\n-}"}, {"sha": "d5fc80b41f012230d3f36f3fb6fa06865ba12cfa", "filename": "tests/run-pass/strings.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstrings.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,27 +0,0 @@\n-fn empty() -> &'static str {\n-    \"\"\n-}\n-\n-fn hello() -> &'static str {\n-    \"Hello, world!\"\n-}\n-\n-fn hello_bytes() -> &'static [u8; 13] {\n-    b\"Hello, world!\"\n-}\n-\n-fn hello_bytes_fat() -> &'static [u8] {\n-    b\"Hello, world!\"\n-}\n-\n-fn fat_pointer_on_32_bit() {\n-    Some(5).expect(\"foo\");\n-}\n-\n-fn main() {\n-    assert_eq!(empty(), \"\");\n-    assert_eq!(hello(), \"Hello, world!\");\n-    assert_eq!(hello_bytes(), b\"Hello, world!\");\n-    assert_eq!(hello_bytes_fat(), b\"Hello, world!\");\n-    fat_pointer_on_32_bit(); // Should run without crashing.\n-}"}, {"sha": "468cc9f094169422b3e5a077d599133319be4d78", "filename": "tests/run-pass/subslice_array.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsubslice_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsubslice_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsubslice_array.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,14 +0,0 @@\n-#![feature(advanced_slice_patterns)]\n-#![feature(slice_patterns)]\n-\n-fn bar(a: &'static str, b: &'static str) -> [&'static str; 4] {\n-    [a, b, b, a]\n-}\n-\n-fn main() {\n-    let out = bar(\"baz\", \"foo\");\n-    let [a, xs.., d] = out;\n-    assert_eq!(a, \"baz\");\n-    assert_eq!(xs, [\"foo\", \"foo\"]);\n-    assert_eq!(d, \"baz\");\n-}"}, {"sha": "a8dfd5ed66ae7ac5090fe22101278376d818697f", "filename": "tests/run-pass/sums.rs", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fsums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsums.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,59 +0,0 @@\n-// FIXME(solson): 32-bit mode doesn't test anything currently.\n-#![cfg_attr(target_pointer_width = \"32\", allow(dead_code))]\n-\n-#[derive(Debug, PartialEq)]\n-enum Unit { Unit(()) } // Force non-C-enum representation.\n-\n-fn return_unit() -> Unit {\n-    Unit::Unit(())\n-}\n-\n-#[derive(Debug, PartialEq)]\n-enum MyBool { False(()), True(()) } // Force non-C-enum representation.\n-\n-fn return_true() -> MyBool {\n-    MyBool::True(())\n-}\n-\n-fn return_false() -> MyBool {\n-    MyBool::False(())\n-}\n-\n-fn return_none() -> Option<i64> {\n-    None\n-}\n-\n-fn return_some() -> Option<i64> {\n-    Some(42)\n-}\n-\n-fn match_opt_none() -> i8 {\n-    let x = None;\n-    match x {\n-        Some(data) => data,\n-        None => 42,\n-    }\n-}\n-\n-fn match_opt_some() -> i8 {\n-    let x = Some(13);\n-    match x {\n-        Some(data) => data,\n-        None => 20,\n-    }\n-}\n-\n-fn two_nones() -> (Option<i16>, Option<i16>) {\n-    (None, None)\n-}\n-\n-fn main() {\n-    assert_eq!(two_nones(), (None, None));\n-    assert_eq!(match_opt_some(), 13);\n-    assert_eq!(match_opt_none(), 42);\n-    assert_eq!(return_some(), Some(42));\n-    assert_eq!(return_none(), None);\n-    assert_eq!(return_false(), MyBool::False(()));\n-    assert_eq!(return_true(), MyBool::True(()));\n-    assert_eq!(return_unit(), Unit::Unit(()));\n-}"}, {"sha": "81c19022ab080c4f1aa1be0107c24819ab67f910", "filename": "tests/run-pass/tag-align-dyn-u64.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftag-align-dyn-u64.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-\n-use std::mem;\n-\n-enum Tag<A> {\n-    Tag2(A)\n-}\n-\n-struct Rec {\n-    c8: u8,\n-    t: Tag<u64>\n-}\n-\n-fn mk_rec() -> Rec {\n-    return Rec { c8:0, t:Tag::Tag2(0) };\n-}\n-\n-fn is_u64_aligned(u: &Tag<u64>) -> bool {\n-    let p: usize = unsafe { mem::transmute(u) };\n-    let u64_align = std::mem::align_of::<u64>();\n-    return (p & (u64_align - 1)) == 0;\n-}\n-\n-pub fn main() {\n-    let x = mk_rec();\n-    assert!(is_u64_aligned(&x.t));\n-}"}, {"sha": "db00e42d99ac8f46c456826305f3fed71e8b8ce8", "filename": "tests/run-pass/thread-local.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fthread-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fthread-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthread-local.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,67 +0,0 @@\n-//ignore-windows\n-\n-#![feature(libc)]\n-extern crate libc;\n-\n-use std::mem;\n-\n-pub type Key = libc::pthread_key_t;\n-\n-static mut RECORD : usize = 0;\n-static mut KEYS : [Key; 2] = [0; 2];\n-static mut GLOBALS : [u64; 2] = [1, 0];\n-\n-static mut CANNARY : *mut u64 = 0 as *mut _; // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n-\n-pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    let mut key = 0;\n-    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n-    key\n-}\n-\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    let r = libc::pthread_setspecific(key, value as *mut _);\n-    assert_eq!(r, 0);\n-}\n-\n-pub fn record(r: usize) {\n-    assert!(r < 10);\n-    unsafe { RECORD = RECORD*10 + r };\n-}\n-\n-unsafe extern fn dtor(ptr: *mut u64) {\n-    assert!(CANNARY != 0 as *mut _); // make sure we do not get run too often\n-    let val = *ptr;\n-\n-    let which_key = GLOBALS.iter().position(|global| global as *const _ == ptr).expect(\"Should find my global\");\n-    record(which_key);\n-\n-    if val > 0 {\n-        *ptr = val-1;\n-        set(KEYS[which_key], ptr as *mut _);\n-    }\n-\n-    // Check if the records matches what we expect. If yes, clear the cannary.\n-    // If the record is wrong, the cannary will never get cleared, leading to a leak -> test fails.\n-    // If the record is incomplete (i.e., more dtor calls happen), the check at the beginning of this function will fail -> test fails.\n-    // The correct sequence is: First key 0, then key 1, then key 0.\n-    if RECORD == 0_1_0 {\n-        drop(Box::from_raw(CANNARY));\n-        CANNARY = 0 as *mut _;\n-    }\n-}\n-\n-fn main() {\n-    unsafe {\n-        create(None); // check that the no-dtor case works\n-\n-        // Initialize the keys we use to check destructor ordering\n-        for (key, global) in KEYS.iter_mut().zip(GLOBALS.iter()) {\n-            *key = create(Some(mem::transmute(dtor as unsafe extern fn(*mut u64))));\n-            set(*key, global as *const _ as *mut _);\n-        }\n-\n-        // Initialize cannary\n-        CANNARY = Box::into_raw(Box::new(0u64));\n-    }\n-}"}, {"sha": "1bbe45277c43f4573b2eac029643814d6fa078a8", "filename": "tests/run-pass/too-large-primval-write-problem.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftoo-large-primval-write-problem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftoo-large-primval-write-problem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftoo-large-primval-write-problem.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,23 +0,0 @@\n-// PrimVals in Miri are represented with 8 bytes (u64) and at the time of writing, the `-x`\n-// will sign extend into the entire 8 bytes. Then, if you tried to write the `-x` into\n-// something smaller than 8 bytes, like a 4 byte pointer, it would crash in byteorder crate\n-// code that assumed only the low 4 bytes would be set. Actually, we were masking properly for\n-// everything except pointers before I fixed it, so this was probably impossible to reproduce on\n-// 64-bit.\n-//\n-// This is just intended as a regression test to make sure we don't reintroduce this problem.\n-\n-#[cfg(target_pointer_width = \"32\")]\n-fn main() {\n-    use std::mem::transmute;\n-\n-    // Make the weird PrimVal.\n-    let x = 1i32;\n-    let bad = unsafe { transmute::<i32, *const u8>(-x) };\n-\n-    // Force it through the Memory::write_primval code.\n-    Box::new(bad);\n-}\n-\n-#[cfg(not(target_pointer_width = \"32\"))]\n-fn main() {}"}, {"sha": "b2eae5d04f41b8e504d9d199d3ef29c2201115a9", "filename": "tests/run-pass/traits.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftraits.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,30 +0,0 @@\n-struct Struct(i32);\n-\n-trait Trait {\n-    fn method(&self);\n-}\n-\n-impl Trait for Struct {\n-    fn method(&self) {\n-        assert_eq!(self.0, 42);\n-    }\n-}\n-\n-struct Foo<T: ?Sized>(T);\n-\n-fn main() {\n-    let y: &Trait = &Struct(42);\n-    y.method();\n-    let x: Foo<Struct> = Foo(Struct(42));\n-    let y: &Foo<Trait> = &x;\n-    y.0.method();\n-\n-    let x: Box<Fn(i32) -> i32> = Box::new(|x| x * 2);\n-    assert_eq!(x(21), 42);\n-    let mut i = 5;\n-    {\n-        let mut x: Box<FnMut()> = Box::new(|| i *= 2);\n-        x(); x();\n-    }\n-    assert_eq!(i, 20);\n-}"}, {"sha": "891d11520656160d13584d5a4eb14a056e47b71b", "filename": "tests/run-pass/trivial.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftrivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftrivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftrivial.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,11 +0,0 @@\n-fn empty() {}\n-\n-fn unit_var() {\n-    let x = ();\n-    x\n-}\n-\n-fn main() {\n-    empty();\n-    unit_var();\n-}"}, {"sha": "3b447f36ece1ef270bf8daf6741ff085b6ae91d9", "filename": "tests/run-pass/try-operator-custom.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftry-operator-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftry-operator-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftry-operator-custom.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    assert!(Ok::<i32, String>(42) == Ok(42));\n-}"}, {"sha": "5cf91b3f4d194eb188c8942cbb902709e7674c4c", "filename": "tests/run-pass/tuple_like_enum_variant_constructor.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,3 +0,0 @@\n-fn main() {\n-    assert_eq!(Some(42).map(Some), Some(Some(42)));\n-}"}, {"sha": "fb57d4f4c1652aa9782c0a713626f098cc11d23b", "filename": "tests/run-pass/tuple_like_enum_variant_constructor_pointer_opt.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_pointer_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_pointer_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_pointer_opt.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let x = 5;\n-    assert_eq!(Some(&x).map(Some), Some(Some(&x)));\n-}"}, {"sha": "44441ed1d36c88a548ce577949f72e5a75032815", "filename": "tests/run-pass/tuple_like_enum_variant_constructor_struct_pointer_opt.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_struct_pointer_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_struct_pointer_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftuple_like_enum_variant_constructor_struct_pointer_opt.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,33 +0,0 @@\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-struct A<'a> {\n-    x: i32,\n-    y: &'a i32,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-struct B<'a>(i32, &'a i32);\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-enum C<'a> {\n-    Value(i32, &'a i32),\n-    #[allow(dead_code)]\n-    NoValue,\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let a = A { x: 99, y: &x };\n-    assert_eq!(Some(a).map(Some), Some(Some(a)));\n-    let f = B;\n-    assert_eq!(Some(B(42, &x)), Some(f(42, &x)));\n-    // the following doesn't compile :(\n-    //let f: for<'a> fn(i32, &'a i32) -> B<'a> = B;\n-    //assert_eq!(Some(B(42, &x)), Some(f(42, &x)));\n-    assert_eq!(B(42, &x), foo(&x, B));\n-    let f = C::Value;\n-    assert_eq!(C::Value(42, &x), f(42, &x));\n-}\n-\n-fn foo<'a, F: Fn(i32, &'a i32) -> B<'a>>(i: &'a i32, f: F) -> B<'a> {\n-    f(42, i)\n-}"}, {"sha": "05e8893de178747782e2de4fdd4c56e6974e2003", "filename": "tests/run-pass/tuple_like_struct_constructor.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftuple_like_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Ftuple_like_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftuple_like_struct_constructor.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    #[derive(PartialEq, Eq, Debug)]\n-    struct A(i32);\n-    assert_eq!(Some(42).map(A), Some(A(42)));\n-}"}, {"sha": "df2ff6e51a593a64c98323bc6ea74c7719abfce5", "filename": "tests/run-pass/union-overwrite.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Funion-overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Funion-overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Funion-overwrite.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,81 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(untagged_unions)]\n-#![allow(unions_with_drop_fields)]\n-\n-#[repr(C)]\n-struct Pair<T, U>(T, U);\n-#[repr(C)]\n-struct Triple<T>(T, T, T);\n-\n-#[repr(C)]\n-union U<A, B> {\n-    a: Pair<A, A>,\n-    b: B,\n-}\n-\n-#[repr(C)]\n-union W<A, B> {\n-    a: A,\n-    b: B,\n-}\n-\n-#[cfg(target_endian = \"little\")]\n-unsafe fn check() {\n-    let mut u = U::<u8, u16> { b: 0xDE_DE };\n-    u.a.0 = 0xBE;\n-    assert_eq!(u.b, 0xDE_BE);\n-\n-    let mut u = U::<u16, u32> { b: 0xDEAD_DEAD };\n-    u.a.0 = 0xBEEF;\n-    assert_eq!(u.b, 0xDEAD_BEEF);\n-\n-    let mut u = U::<u32, u64> { b: 0xDEADBEEF_DEADBEEF };\n-    u.a.0 = 0xBAADF00D;\n-    assert_eq!(u.b, 0xDEADBEEF_BAADF00D);\n-\n-    let mut w = W::<Pair<Triple<u8>, u8>, u32> { b: 0xDEAD_DEAD };\n-    w.a.0 = Triple(0, 0, 0);\n-    assert_eq!(w.b, 0xDE00_0000);\n-\n-    let mut w = W::<Pair<u8, Triple<u8>>, u32> { b: 0xDEAD_DEAD };\n-    w.a.1 = Triple(0, 0, 0);\n-    assert_eq!(w.b, 0x0000_00AD);\n-}\n-\n-#[cfg(target_endian = \"big\")]\n-unsafe fn check() {\n-    let mut u = U::<u8, u16> { b: 0xDE_DE };\n-    u.a.0 = 0xBE;\n-    assert_eq!(u.b, 0xBE_DE);\n-\n-    let mut u = U::<u16, u32> { b: 0xDEAD_DEAD };\n-    u.a.0 = 0xBEEF;\n-    assert_eq!(u.b, 0xBEEF_DEAD);\n-\n-    let mut u = U::<u32, u64> { b: 0xDEADBEEF_DEADBEEF };\n-    u.a.0 = 0xBAADF00D;\n-    assert_eq!(u.b, 0xBAADF00D_DEADBEEF);\n-\n-    let mut w = W::<Pair<Triple<u8>, u8>, u32> { b: 0xDEAD_DEAD };\n-    w.a.0 = Triple(0, 0, 0);\n-    assert_eq!(w.b, 0x0000_00AD);\n-\n-    let mut w = W::<Pair<u8, Triple<u8>>, u32> { b: 0xDEAD_DEAD };\n-    w.a.1 = Triple(0, 0, 0);\n-    assert_eq!(w.b, 0xDE00_0000);\n-}\n-\n-fn main() {\n-    unsafe {\n-        check();\n-    }\n-}"}, {"sha": "342c94f3d4a34aa87901328153cf2704839e2fbc", "filename": "tests/run-pass/union.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Funion.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,88 +0,0 @@\n-#![feature(untagged_unions)]\n-#![allow(dead_code, unused_variables)]\n-\n-fn main() {\n-    a();\n-    b();\n-    c();\n-    d();\n-}\n-\n-fn a() {\n-    union U {\n-        f1: u32,\n-        f2: f32,\n-    }\n-    let mut u = U { f1: 1 };\n-    unsafe {\n-        let b1 = &mut u.f1;\n-        *b1 = 5;\n-    }\n-    assert_eq!(unsafe { u.f1 }, 5);\n-}\n-\n-fn b() {\n-    struct S {\n-        x: u32,\n-        y: u32,\n-    }\n-\n-    union U {\n-        s: S,\n-        both: u64,\n-    }\n-    let mut u = U { s: S { x: 1, y: 2 } };\n-    unsafe {\n-        let bx = &mut u.s.x;\n-        let by = &mut u.s.y;\n-        *bx = 5;\n-        *by = 10;\n-    }\n-    assert_eq!(unsafe { u.s.x }, 5);\n-    assert_eq!(unsafe { u.s.y }, 10);\n-}\n-\n-fn c() {\n-    #[repr(u32)]\n-    enum Tag { I, F }\n-\n-    #[repr(C)]\n-    union U {\n-        i: i32,\n-        f: f32,\n-    }\n-\n-    #[repr(C)]\n-    struct Value {\n-        tag: Tag,\n-        u: U,\n-    }\n-\n-    fn is_zero(v: Value) -> bool {\n-        unsafe {\n-            match v {\n-                Value { tag: Tag::I, u: U { i: 0 } } => true,\n-                Value { tag: Tag::F, u: U { f } } => f == 0.0,\n-                _ => false,\n-            }\n-        }\n-    }\n-    assert!(is_zero(Value { tag: Tag::I, u: U { i: 0 }}));\n-    assert!(is_zero(Value { tag: Tag::F, u: U { f: 0.0 }}));\n-    assert!(!is_zero(Value { tag: Tag::I, u: U { i: 1 }}));\n-    assert!(!is_zero(Value { tag: Tag::F, u: U { f: 42.0 }}));\n-}\n-\n-fn d() {\n-    union MyUnion {\n-        f1: u32,\n-        f2: f32,\n-    }\n-    let u = MyUnion { f1: 10 };\n-    unsafe {\n-        match u {\n-            MyUnion { f1: 10 } => { }\n-            MyUnion { f2 } => { panic!(\"foo\"); }\n-        }\n-    }\n-}"}, {"sha": "7644da08e4afa7cf144dbbb3a5b0142f687ac5c7", "filename": "tests/run-pass/unique-send.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Funique-send.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(box_syntax)]\n-\n-use std::sync::mpsc::channel;\n-\n-pub fn main() {\n-    let (tx, rx) = channel::<Box<_>>();\n-    tx.send(box 100).unwrap();\n-    let v = rx.recv().unwrap();\n-    assert_eq!(v, box 100);\n-}"}, {"sha": "4d919f735255d921264d17808b96fa3abe3b7552", "filename": "tests/run-pass/validation_lifetime_resolution.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fvalidation_lifetime_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fvalidation_lifetime_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvalidation_lifetime_resolution.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,30 +0,0 @@\n-trait Id {\n-    type Out;\n-\n-    fn id(self) -> Self::Out;\n-}\n-\n-impl<'a> Id for &'a mut i32 {\n-    type Out = &'a mut i32;\n-\n-    fn id(self) -> Self { self }\n-}\n-\n-impl<'a> Id for &'a mut u32 {\n-    type Out = &'a mut u32;\n-\n-    fn id(self) -> Self { self }\n-}\n-\n-fn foo<T>(mut x: T) where for<'a> &'a mut T: Id\n-{\n-    let x = &mut x;\n-    let _y = x.id();\n-    // Inspecting the trace should show that _y has a type involving a local lifetime, when it gets validated.\n-    // Unfortunately, there doesn't seem to be a way to actually have a test fail if it does not have the right\n-    // type.  Currently, this is NOT working correctly; see <https://github.com/solson/miri/issues/298>.\n-}\n-\n-fn main() {\n-    foo(3)\n-}"}, {"sha": "ac80a4211ada627fbfc0c0a2eb50dfda3d31f570", "filename": "tests/run-pass/vec-matching-fold.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fvec-matching-fold.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![feature(advanced_slice_patterns)]\n-#![feature(slice_patterns)]\n-\n-use std::fmt::Debug;\n-\n-fn foldl<T, U, F>(values: &[T],\n-                  initial: U,\n-                  mut function: F)\n-                  -> U where\n-    U: Clone+Debug, T:Debug,\n-    F: FnMut(U, &T) -> U,\n-{    match values {\n-        &[ref head, ref tail..] =>\n-            foldl(tail, function(initial, head), function),\n-        &[] => {\n-            // FIXME: call guards\n-            let res = initial.clone(); res\n-        }\n-    }\n-}\n-\n-fn foldr<T, U, F>(values: &[T],\n-                  initial: U,\n-                  mut function: F)\n-                  -> U where\n-    U: Clone,\n-    F: FnMut(&T, U) -> U,\n-{\n-    match values {\n-        &[ref head.., ref tail] =>\n-            foldr(head, function(tail, initial), function),\n-        &[] => {\n-            // FIXME: call guards\n-            let res = initial.clone(); res\n-        }\n-    }\n-}\n-\n-pub fn main() {\n-    let x = &[1, 2, 3, 4, 5];\n-\n-    let product = foldl(x, 1, |a, b| a * *b);\n-    assert_eq!(product, 120);\n-\n-    let sum = foldr(x, 0, |a, b| *a + b);\n-    assert_eq!(sum, 15);\n-}"}, {"sha": "7c9a38fca696dd3e9401c355cb79b5ad00233cc4", "filename": "tests/run-pass/write-bytes.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fwrite-bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fwrite-bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fwrite-bytes.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,45 +0,0 @@\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-struct Foo {\n-    a: u64,\n-    b: u64,\n-    c: u64,\n-}\n-\n-fn main() {\n-    const LENGTH: usize = 10;\n-    let mut v: [u64; LENGTH] = [0; LENGTH];\n-\n-    for idx in 0..LENGTH {\n-        assert_eq!(v[idx], 0);\n-    }\n-\n-    unsafe {\n-        let p = v.as_mut_ptr();\n-        ::std::ptr::write_bytes(p, 0xab, LENGTH);\n-    }\n-\n-    for idx in 0..LENGTH {\n-        assert_eq!(v[idx], 0xabababababababab);\n-    }\n-\n-    // -----\n-\n-    let mut w: [Foo; LENGTH] = [Foo { a: 0, b: 0, c: 0 }; LENGTH];\n-    for idx in 0..LENGTH {\n-        assert_eq!(w[idx].a, 0);\n-        assert_eq!(w[idx].b, 0);\n-        assert_eq!(w[idx].c, 0);\n-    }\n-\n-    unsafe {\n-        let p = w.as_mut_ptr();\n-        ::std::ptr::write_bytes(p, 0xcd, LENGTH);\n-    }\n-\n-    for idx in 0..LENGTH {\n-        assert_eq!(w[idx].a, 0xcdcdcdcdcdcdcdcd);\n-        assert_eq!(w[idx].b, 0xcdcdcdcdcdcdcdcd);\n-        assert_eq!(w[idx].c, 0xcdcdcdcdcdcdcdcd);\n-    }\n-}"}, {"sha": "63a0d65f017def8d603d05654eb20e97b97a1a87", "filename": "tests/run-pass/zero-sized-binary-heap-push.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzero-sized-binary-heap-push.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::collections::BinaryHeap;\n-use std::iter::Iterator;\n-\n-fn main() {\n-    const N: usize = 8;\n-\n-    for len in 0..N {\n-        let mut tester = BinaryHeap::with_capacity(len);\n-        assert_eq!(tester.len(), 0);\n-        assert!(tester.capacity() >= len);\n-        for _ in 0..len {\n-            tester.push(());\n-        }\n-        assert_eq!(tester.len(), len);\n-        assert_eq!(tester.iter().count(), len);\n-        tester.clear();\n-    }\n-}"}, {"sha": "c1c88875c5c80f8e514d64d2f1baa72f6e17d01b", "filename": "tests/run-pass/zst.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,18 +0,0 @@\n-#[derive(PartialEq, Debug)]\n-struct A;\n-\n-fn zst_ret() -> A {\n-    A\n-}\n-\n-fn use_zst() -> A {\n-    let a = A;\n-    a\n-}\n-\n-fn main() {\n-    assert_eq!(zst_ret(), A);\n-    assert_eq!(use_zst(), A);\n-    let x = 42 as *mut ();\n-    unsafe { *x = (); }\n-}"}, {"sha": "c2d7b88ea0757f99435e400cbe2fd1dc6d688d97", "filename": "tests/run-pass/zst2.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzst2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzst2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst2.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,12 +0,0 @@\n-#![allow(dead_code)]\n-\n-#[derive(Debug)]\n-struct A;\n-\n-fn main() {\n-    // can't use assert_eq, b/c that will try to print the pointer addresses with full MIR enabled\n-\n-    // FIXME: Test disabled for now, see <https://github.com/solson/miri/issues/131>.\n-    //assert!(&A as *const A as *const () == &() as *const _);\n-    //assert!(&A as *const A == &A as *const A);\n-}"}, {"sha": "12138be5af9768e6b39423995859dc5952d9e841", "filename": "tests/run-pass/zst_box.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzst_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzst_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst_box.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    let x = Box::new(());\n-    let y = Box::new(());\n-    drop(y);\n-    let z = Box::new(());\n-    drop(x);\n-    drop(z);\n-}"}, {"sha": "a76f64ce29df70aa267bf3a062e0f9717103330b", "filename": "tests/run-pass/zst_variant_drop.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzst_variant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tests%2Frun-pass%2Fzst_variant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst_variant_drop.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,23 +0,0 @@\n-struct Foo;\n-impl Drop for Foo {\n-    fn drop(&mut self) {\n-        unsafe {\n-            FOO = true;\n-        }\n-    }\n-}\n-\n-static mut FOO: bool = false;\n-\n-enum Bar {\n-    A(Box<i32>),\n-    B(Foo),\n-}\n-\n-fn main() {\n-    assert!(unsafe { !FOO });\n-    drop(Bar::A(Box::new(42)));\n-    assert!(unsafe { !FOO });\n-    drop(Bar::B(Foo));\n-    assert!(unsafe { FOO });\n-}"}, {"sha": "23aa1a481b3ebc8eb1358f31a6e49f08090bc5d9", "filename": "tex/final-presentation/latexmkrc", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Ffinal-presentation%2Flatexmkrc", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Ffinal-presentation%2Flatexmkrc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Ffinal-presentation%2Flatexmkrc?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,12 +0,0 @@\n-# vim: ft=perl\n-\n-$pdf_mode = 1;\n-$pdflatex = 'lualatex --shell-escape %O %S';\n-$out_dir = 'out';\n-\n-# This improves latexmk's detection of source files and generated files.\n-$recorder = 1;\n-\n-# Ignore always-regenerated *.pyg files from the minted package when considering\n-# whether to run pdflatex again.\n-$hash_calc_ignore_pattern{'pyg'} = '.*';"}, {"sha": "38484c670e01f3f355672d6c95f79f035a963a44", "filename": "tex/final-presentation/rust-logo-512x512.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Ffinal-presentation%2Frust-logo-512x512.png", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Ffinal-presentation%2Frust-logo-512x512.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Ffinal-presentation%2Frust-logo-512x512.png?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a"}, {"sha": "c5e1f51ba19c60f675e25dcb0cf3252db4585c3e", "filename": "tex/final-presentation/slides.tex", "status": "removed", "additions": 0, "deletions": 444, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Ffinal-presentation%2Fslides.tex", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Ffinal-presentation%2Fslides.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Ffinal-presentation%2Fslides.tex?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,444 +0,0 @@\n-\\documentclass{beamer}\n-\\usecolortheme{beaver}\n-\\beamertemplatenavigationsymbolsempty\n-\n-% Fonts\n-\\usepackage{fontspec}\n-\\setmainfont{Source Serif Pro}[Ligatures=TeX]\n-\\setsansfont{Source Sans Pro}[Ligatures=TeX]\n-\\setmonofont{Source Code Pro}[\n-  BoldFont={* Medium},\n-  BoldItalicFont={* Medium Italic},\n-]\n-\n-\\usepackage[outputdir=out]{minted}\n-\\usepackage{tikz}\n-\\usetikzlibrary{positioning, fit}\n-\n-\\tikzset{\n-  invisible/.style={opacity=0,text opacity=0},\n-  highlight/.style={color=red},\n-  intro/.code args={<#1>}{%\n-    \\only<#1>{\\pgfkeysalso{highlight}}\n-    \\alt<#1->{}{\\pgfkeysalso{invisible}}\n-  },\n-}\n-\n-\\title{Miri}\n-\\subtitle{An interpreter for Rust's mid-level intermediate representation}\n-\\author{\n-  Scott Olson\n-  \\texorpdfstring{\\\\ \\scriptsize{Supervisor: Christopher Dutchyn}}{}\n-}\n-\\institute{\n-  CMPT 400 \\\\\n-  University of Saskatchewan\n-}\n-\\date{}\n-\\titlegraphic{\n-  \\includegraphics[width=64px,height=64px]{rust-logo-512x512.png} \\\\\n-  \\scriptsize{\\url{https://www.rust-lang.org}}\n-}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-% Intro slides\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\begin{document}\n-\n-\\maketitle\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{What is Rust? \\small{[review]}}\n-\n-  According to the website\\dots\n-\n-  \\begin{quote}\n-    \\textbf{Rust} is a systems programming language that runs blazingly fast,\n-    prevents nearly all segfaults, and guarantees thread safety.\n-  \\end{quote}\n-\n-  It's a new programming language from Mozilla, and it looks like this:\n-\n-  \\begin{minted}[\n-    autogobble,\n-    fontsize=\\footnotesize,\n-    mathescape,\n-    xleftmargin=.3in,\n-  ]{rust}\n-    fn factorial(n: u64) -> u64 {\n-        (1..n).fold(1, |a, b| a * b)\n-    }\n-\n-    fn main() {\n-        for x in 1..6 {\n-            println!(\"{}\", factorial(x));\n-        }\n-        // $\\Rightarrow$ 1\n-        // $\\Rightarrow$ 1\n-        // $\\Rightarrow$ 2\n-        // $\\Rightarrow$ 6\n-        // $\\Rightarrow$ 24\n-    }\n-  \\end{minted}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{How does Rust compile code? \\onslide<-6>{\\small{[review]}}}\n-\n-  \\begin{center}\n-    \\begin{tikzpicture}[x=4cm, y=3.5cm, auto, rounded corners]\n-      \\tikzstyle{basic-stage}=[rectangle, draw, thick, align=center]\n-      \\tikzstyle{stage}=[basic-stage, font=\\tiny]\n-      \\tikzstyle{pass}=[thick, -stealth]\n-      \\tikzstyle{pass-label}=[font=\\footnotesize]\n-\n-      \\node[basic-stage] (src) at (0,0) {Source\\\\Code};\n-      \\node[basic-stage] (mach) at (2,-1) {Machine\\\\Code};\n-\n-      \\draw<1>[pass, out=0, in=180]\n-        (src.east) to node[font=\\Huge] {?} (mach.west);\n-\n-      \\node[stage, intro=<2>] (ast) at (1,0)\n-        {\\normalsize{AST} \\\\ Abstract Syntax Tree};\n-      \\draw[pass, intro=<2>]\n-        (src) -- node[pass-label] {Parse} (ast);\n-\n-      \\node[stage, intro=<3>] (hir) at (2,0)\n-        {\\normalsize{HIR} \\\\ High-level Intermediate\\\\Representation};\n-      \\draw[pass, intro=<3>]\n-        (ast) -- node[pass-label] {Simplify} (hir);\n-\n-      \\node[stage, intro=<4>] (mir) at (0,-1)\n-        {\\normalsize{MIR} \\\\ Mid-level Intermediate\\\\Representation};\n-      \\path (hir.south) -- coordinate (middle) (mir.north);\n-      \\draw[pass, intro=<4>]\n-        (hir.south) |- (middle) -| (mir.north);\n-      \\node[pass-label, above, intro=<4>] at (middle) {Lower};\n-\n-      \\node[stage, intro=<5>] (llvm) at (1,-1)\n-        {\\normalsize{LLVM IR} \\\\ Low-level Intermediate\\\\Representation};\n-      \\draw[pass, intro=<5>]\n-        (mir) -- node[pass-label] {Translate} (llvm);\n-\n-      \\draw<6->[pass, intro=<6>]\n-        (llvm) -- node[pass-label] {Magic} (mach);\n-\n-      \\node[stage, intro=<7>] (exec) at (1,-1.75)\n-        {\\normalsize{Execution}};\n-      \\draw[pass, intro=<7>]\n-        (mach) -- node[pass-label] {CPU} (exec);\n-\n-      \\draw[pass, intro=<8>]\n-        (mir) -- node[pass-label] {Miri} (exec);\n-    \\end{tikzpicture}\n-  \\end{center}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{Why build Miri?}\n-  \\begin{itemize}\n-    \\item For fun and learning.\n-\n-    \\item I originally planned to use it for testing the compiler and execution\n-      of unsafe code, but shifted my goals along the way. \\pause\n-\n-    \\item Now it serves as an experimental implementation of the upcoming\n-      compile-time function evaluation feature in Rust. \\pause\n-\n-      \\begin{itemize}\n-        \\item Similar to C++14's \\mintinline{cpp}{constexpr} feature.\n-\n-        \\item You can do complicated calculations at compile time and compile\n-          their \\emph{results} into the executable. \\pause\n-\n-        \\item For example, you can compute a ``perfect hash function'' for a\n-          statically-known map at compile-time and have guaranteed no-collision\n-          lookup at runtime. \\pause\n-\n-        \\item Miri actually supports far more of Rust than C++14's\n-          \\mintinline{cpp}{constexpr} does of C++ --- even heap allocation and\n-          unsafe code.\n-      \\end{itemize}\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{How was it built?}\n-\n-  At first I wrote a naive version with a number of downsides:\n-\n-  \\begin{itemize}\n-    \\item represented values in a traditional dynamic language format, where\n-      every value was the same size.\n-\n-    \\item didn't work well for aggregates (structs, enums, arrays, etc.).\n-\n-    \\item made unsafe programming tricks that make assumptions about low-level\n-      value layout essentially impossible.\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{How was it built?}\n-  \\begin{itemize}\n-    \\item Later, a Rust compiler team member proposed a ``Rust abstract\n-      machine'' with specialized value layout which solved my previous problems.\n-      \\pause\n-\n-    \\item His proposal was intended for a compile-time function evaluator in the\n-      Rust compiler, so I effectively implemented an experimental version of\n-      that. \\pause\n-\n-    \\item After this point, making Miri work well was primarily a software\n-      engineering problem.\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{Data layout}\n-  \\begin{itemize}\n-    \\item Memory in Miri is literally a HashMap from ``allocation IDs'' to\n-      ``abstract allocations''.\n-\n-    \\item Allocations are represented by: \\pause\n-      \\begin{enumerate}\n-        \\item An array of \\textbf{raw bytes} with a size based on the type of\n-          the value \\pause\n-        \\item A set of \\textbf{relocations} --- pointers into other abstract\n-          allocations \\pause\n-        \\item A mask determining which bytes are \\textbf{undefined}\n-      \\end{enumerate}\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{\\texttt{square} example}\n-  \\begin{center}\n-    \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n-      // Rust\n-      fn square(n: u64) -> u64 {\n-          n * n\n-      }\n-\n-      // Generated MIR\n-      fn square(arg0: u64) -> u64 {\n-          let var0: u64; // n           // On function entry, Miri creates\n-                                        // virtual allocations for all the\n-                                        // arguments, variables, and\n-                                        // temporaries.\n-\n-          bb0: {\n-              var0 = arg0;              // Copy the argument into `n`.\n-              return = Mul(var0, var0); // Multiply `n` with itself.\n-              goto -> bb1;              // Jump to basic block `bb1`.\n-          }\n-\n-          bb1: {\n-              return;                   // Return from the current fn.\n-          }\n-      }\n-    \\end{minted}\n-  \\end{center}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{\\texttt{sum} example}\n-  \\begin{center}\n-    \\begin{minted}[autogobble,fontsize=\\tiny]{rust}\n-      // Rust\n-      fn sum() -> u64 {\n-          let mut sum = 0; let mut i = 0;\n-          while i < 10 { sum += i; i += 1; }\n-          sum\n-      }\n-\n-      // Generated MIR\n-      fn sum() -> u64 {\n-          let mut var0: u64; // sum\n-          let mut var1: u64; // i\n-          let mut tmp0: bool;\n-\n-          bb0: {\n-              // sum = 0; i = 0;\n-              var0 = const 0u64; var1 = const 0u64; goto -> bb1;\n-          }\n-          bb1: {\n-              // if i < 10 { goto bb2; } else { goto bb3; }\n-              tmp0 = Lt(var1, const 10u64);\n-              if(tmp0) -> [true: bb2, false: bb3];\n-          }\n-          bb2: {\n-              var0 = Add(var0, var1);       // sum = sum + i;\n-              var1 = Add(var1, const 1u64); // i = i + 1;\n-              goto -> bb1;\n-          }\n-          bb3: {\n-              return = var0; goto -> bb4;\n-          }\n-          bb4: { return; }\n-      }\n-    \\end{minted}\n-  \\end{center}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{Heap allocations!}\n-  \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n-    fn make_vec() -> Vec<u8> {\n-        // Empty array with space for 4 bytes - allocated on the heap!\n-        let mut vec = Vec::with_capacity(4);\n-        // Initialize the first two slots.\n-        vec.push(1);\n-        vec.push(2);\n-        vec\n-    }\n-\n-    // For reference:\n-    //   struct Vec<T> { capacity: usize, data: *mut T, length: usize }\n-\n-    // Resulting allocations (on 32-bit little-endian architectures):\n-    //   Region A:\n-    //     04 00 00 00  00 00 00 00  02 00 00 00\n-    //                  \u2514\u2500\u2500\u2500(B)\u2500\u2500\u2500\u2518\n-    //\n-    //   Region B:\n-    //     01 02 __ __ (underscores denote undefined bytes)\n-  \\end{minted}\n-\n-  \\footnotesize{Evaluating the above involves a number of compiler built-ins,\n-  ``unsafe'' code blocks, and more inside the standard library,\n-  but Miri handles it all.}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{Unsafe code!}\n-  \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n-    fn out_of_bounds() -> u8 {\n-        let mut vec = vec![1, 2]\n-        unsafe { *vec.get_unchecked(5) }\n-    }\n-\n-    // test.rs:3: error: pointer offset outside bounds of allocation\n-    // test.rs:3:     unsafe { *vec.get_unchecked(5) }\n-    //                         ^~~~~~~~~~~~~~~~~~~~~\n-\n-    fn undefined_bytes() -> u8 {\n-        let mut vec = Vec::with_capacity(10);\n-        unsafe { *vec.get_unchecked(5) }\n-    }\n-\n-    // test.rs:3: error: attempted to read undefined bytes\n-    // test.rs:3:     unsafe { *vec.get_unchecked(5) }\n-    //                         ^~~~~~~~~~~~~~~~~~~~~\n-  \\end{minted}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\frametitle{What can't Miri do?}\n-  \\begin{itemize}\n-    \\item Miri can't do all the stuff I didn't implement yet. :)\n-      \\begin{itemize}\n-        \\item non-trivial casts\n-        \\item function pointers\n-        \\item calling destructors and freeing memory\n-        \\item taking target architecture endianess and alignment information\n-          into account when computing data layout\n-        \\item handling all constants properly (but, well, Miri might be\n-          replacing the old constants system)\n-      \\end{itemize}\n-      \\pause\n-\n-    \\item Miri can't do foreign function calls (e.g. calling functions defined\n-      in C or C++), but there is a reasonable way it could be done with libffi.\n-      \\begin{itemize}\n-        \\item On the other hand, for constant evaluation in the compiler, you\n-          want the evaluator to be deterministic and safe, so FFI calls might be\n-          banned anyway.\n-      \\end{itemize}\n-      \\pause\n-\n-    \\item Without quite some effort, Miri will probably never handle inline\n-      assembly...\n-  \\end{itemize}\n-\\end{frame}\n-\n-\\begin{frame}\n-  \\begin{center}\n-    \\LARGE{Questions?}\n-  \\end{center}\n-\\end{frame}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-% Extra slides\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{\\texttt{varN} vs. \\texttt{argN}}\n-  \\begin{center}\n-    \\begin{minted}[autogobble,fontsize=\\scriptsize]{rust}\n-      // Rust\n-      type Pair = (u64, u64);\n-      fn swap((a, b): Pair) -> Pair {\n-          (b, a)\n-      }\n-\n-      // Generated MIR\n-      fn swap(arg0: (u64, u64)) -> (u64, u64) {\n-          let var0: u64; // a\n-          let var1: u64; // b\n-\n-          bb0: {\n-              var0 = arg0.0;         // get the 1st part of the pair\n-              var1 = arg0.1;         // get the 2nd part of the pair\n-              return = (var1, var0); // build a new pair in the result\n-              goto -> bb1;\n-          }\n-\n-          bb1: {\n-              return;\n-          }\n-      }\n-    \\end{minted}\n-  \\end{center}\n-\\end{frame}\n-\n-\\begin{frame}[fragile]\n-  \\frametitle{\\texttt{factorial} example}\n-  \\begin{center}\n-    \\begin{minted}[autogobble,fontsize=\\tiny]{rust}\n-      // Rust\n-      fn factorial(n: u64) -> u64 {\n-          (1..n).fold(1, |a, b| a * b)\n-      }\n-\n-      // Generated MIR\n-      fn factorial(arg0: u64) -> u64 {\n-          let var0: u64; // n\n-          let mut tmp0: Range<u64>; // Miri calculates sizes for generics like Range<u64>.\n-          let mut tmp1: [closure];\n-\n-          bb0: {\n-              var0 = arg0;\n-\n-              // tmp0 = 1..n\n-              tmp0 = Range<u64> { start: const 1u64, end: var0 };\n-\n-              // tmp1 = |a, b| a * b\n-              tmp1 = [closure];\n-\n-              // This loads the MIR for the `fold` fn from the standard library.\n-              // In general, MIR for any function from any library can be loaded.\n-              // return tmp0.fold(1, tmp1)\n-              return = Range<u64>::fold(tmp0, const 1u64, tmp1) -> bb1;\n-          }\n-\n-          bb1: {\n-              return;\n-          }\n-      }\n-    \\end{minted}\n-  \\end{center}\n-\\end{frame}\n-\n-\\end{document}"}, {"sha": "23aa1a481b3ebc8eb1358f31a6e49f08090bc5d9", "filename": "tex/report/latexmkrc", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Freport%2Flatexmkrc", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Freport%2Flatexmkrc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Flatexmkrc?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,12 +0,0 @@\n-# vim: ft=perl\n-\n-$pdf_mode = 1;\n-$pdflatex = 'lualatex --shell-escape %O %S';\n-$out_dir = 'out';\n-\n-# This improves latexmk's detection of source files and generated files.\n-$recorder = 1;\n-\n-# Ignore always-regenerated *.pyg files from the minted package when considering\n-# whether to run pdflatex again.\n-$hash_calc_ignore_pattern{'pyg'} = '.*';"}, {"sha": "f8bb37b911330ad1d556fd363a0068a19329d21f", "filename": "tex/report/miri-report.tex", "status": "removed", "additions": 0, "deletions": 663, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Freport%2Fmiri-report.tex", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/tex%2Freport%2Fmiri-report.tex", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tex%2Freport%2Fmiri-report.tex?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,663 +0,0 @@\n-% vim: tw=100\n-\n-\\documentclass[twocolumn]{article}\n-\\usepackage{blindtext}\n-\\usepackage[hypcap]{caption}\n-\\usepackage{fontspec}\n-\\usepackage[colorlinks, urlcolor={blue!80!black}]{hyperref}\n-\\usepackage[outputdir=out]{minted}\n-\\usepackage{relsize}\n-\\usepackage{xcolor}\n-\n-\\setmonofont{Source Code Pro}[\n-  BoldFont={* Medium},\n-  BoldItalicFont={* Medium Italic},\n-  Scale=MatchLowercase,\n-]\n-\n-\\newcommand{\\rust}[1]{\\mintinline{rust}{#1}}\n-\n-\\begin{document}\n-\n-\\title{Miri: \\\\ \\smaller{An interpreter for Rust's mid-level intermediate representation}}\n-\\author{Scott Olson\\footnote{\\href{mailto:scott@solson.me}{scott@solson.me}} \\\\\n-  \\smaller{Supervised by Christopher Dutchyn}}\n-\\date{April 12th, 2016}\n-\\maketitle\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Abstract}\n-\n-The increasing need for safe low-level code in contexts like operating systems and browsers is\n-driving the development of Rust\\footnote{\\url{https://www.rust-lang.org}}, a programming language\n-promising high performance without the risk of memory unsafety. To make programming more convenient,\n-it's often desirable to be able to generate code or perform some computation at compile-time. The\n-former is mostly covered by Rust's existing macro feature or build-time code generation, but the\n-latter is currently restricted to a limited form of constant evaluation capable of little beyond\n-simple math.\n-\n-The architecture of the compiler at the time the existing constant evaluator was built limited its\n-potential for future extension. However, a new intermediate representation was recently\n-added\\footnote{\\href{https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md}{Rust RFC \\#1211: Mid-level IR (MIR)}}\n-to the Rust compiler between the abstract syntax tree and the back-end LLVM IR, called mid-level\n-intermediate representation, or MIR for short. This report will demonstrate that writing an\n-interpreter for MIR is a surprisingly effective approach for supporting a large proportion of Rust's\n-features in compile-time execution.\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Background}\n-\n-The Rust compiler generates an instance of \\rust{Mir} for each function [\\autoref{fig:mir}]. Each\n-\\rust{Mir} structure represents a control-flow graph for a given function, and contains a list of\n-``basic blocks'' which in turn contain a list of statements followed by a single terminator. Each\n-statement is of the form \\rust{lvalue = rvalue}. An \\rust{Lvalue} is used for referencing variables\n-and calculating addresses such as when dereferencing pointers, accessing fields, or indexing arrays.\n-An \\rust{Rvalue} represents the core set of operations possible in MIR, including reading a value\n-from an lvalue, performing math operations, creating new pointers, structures, and arrays, and so\n-on. Finally, a terminator decides where control will flow next, optionally based on the value of a\n-boolean or integer.\n-\n-\\begin{figure}[ht]\n-  \\begin{minted}[autogobble]{rust}\n-    struct Mir {\n-        basic_blocks: Vec<BasicBlockData>,\n-        // ...\n-    }\n-\n-    struct BasicBlockData {\n-        statements: Vec<Statement>,\n-        terminator: Terminator,\n-        // ...\n-    }\n-\n-    struct Statement {\n-        lvalue: Lvalue,\n-        rvalue: Rvalue\n-    }\n-\n-    enum Terminator {\n-        Goto { target: BasicBlock },\n-        If {\n-            cond: Operand,\n-            targets: [BasicBlock; 2]\n-        },\n-        // ...\n-    }\n-  \\end{minted}\n-  \\caption{MIR (simplified)}\n-  \\label{fig:mir}\n-\\end{figure}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{First implementation}\n-\n-\\subsection{Basic operation}\n-\n-To investigate the possibility of executing Rust at compile-time I wrote an interpreter for MIR\n-called Miri\\footnote{\\url{https://github.com/solson/miri}}. The structure of the interpreter closely\n-mirrors the structure of MIR itself. It starts executing a function by iterating the statement list\n-in the starting basic block, translating the lvalue into a pointer and using the rvalue to decide\n-what to write into that pointer. Evaluating the rvalue may involve reads (such as for the two sides\n-of a binary operation) or construction of new values. When the terminator is reached, it is used to\n-decide which basic block to jump to next. Finally, Miri repeats this entire process, reading\n-statements from the new block.\n-\n-\\subsection{Function calls}\n-\n-To handle function call terminators\\footnote{Calls occur only as terminators, never as rvalues.},\n-Miri is required to store some information in a virtual call stack so that it may pick up where it\n-left off when the callee returns. Each stack frame stores a reference to the \\rust{Mir} for the\n-function being executed, its local variables, its return value location\\footnote{Return value\n-pointers are passed in by callers.}, and the basic block where execution should resume. When Miri\n-encounters a \\rust{Return} terminator in the MIR, it pops one frame off the stack and resumes the\n-previous function. Miri's execution ends when the function it was initially invoked with returns,\n-leaving the call stack empty.\n-\n-It should be noted that Miri does not itself recurse when a function is called; it merely pushes a\n-virtual stack frame and jumps to the top of the interpreter loop. Consequently, Miri can interpret\n-deeply recursive programs without overflowing its native call stack. This approach would allow Miri\n-to set a virtual stack depth limit and report an error when a program exceeds it.\n-\n-\\subsection{Flaws}\n-\n-This version of Miri supported quite a bit of the Rust language, including booleans, integers,\n-if-conditions, while-loops, structures, enums, arrays, tuples, pointers, and function calls,\n-requiring approximately 400 lines of Rust code. However, it had a particularly naive value\n-representation with a number of downsides. It resembled the data layout of a dynamic language like\n-Ruby or Python, where every value has the same size\\footnote{An \\rust{enum} is a discriminated union\n-with a tag and space to fit the largest variant, regardless of which variant it contains.} in the\n-interpreter:\n-\n-\\begin{minted}[autogobble]{rust}\n-  enum Value {\n-      Uninitialized,\n-      Bool(bool),\n-      Int(i64),\n-      Pointer(Pointer), // index into stack\n-      Aggregate {\n-        variant: usize,\n-        data: Pointer,\n-      },\n-  }\n-\\end{minted}\n-\n-This representation did not work well for aggregate types\\footnote{That is, structures, enums,\n-arrays, tuples, and closures.} and required strange hacks to support them. Their contained values\n-were allocated elsewhere on the stack and pointed to by the aggregate value, which made it more\n-complicated to implement copying aggregate values from place to place.\n-\n-Moreover, while the aggregate issues could be worked around, this value representation made common\n-unsafe programming tricks (which make assumptions about the low-level value layout) fundamentally\n-impossible.\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Current implementation}\n-\n-Roughly halfway through my time working on Miri, Eduard\n-Burtescu\\footnote{\\href{https://github.com/eddyb}{eddyb on GitHub}} from the Rust compiler\n-team\\footnote{\\url{https://www.rust-lang.org/team.html\\#Compiler}} made a post on Rust's internal\n-forums about a ``Rust Abstract Machine''\n-specification\\footnote{\\href{https://internals.rust-lang.org/t/mir-constant-evaluation/3143/31}{Burtescu's\n-reply on ``MIR constant evaluation''}} which could be used to implement more powerful compile-time\n-function execution, similar to what is supported by C++14's \\mintinline{cpp}{constexpr} feature.\n-After clarifying some of the details of the data layout with Burtescu via IRC, I started\n-implementing it in Miri.\n-\n-\\subsection{Raw value representation}\n-\n-The main difference in the new value representation was to represent values by ``abstract\n-allocations'' containing arrays of raw bytes with different sizes depending on their types. This\n-mimics how Rust values are represented when compiled for physical machines. In addition to the raw\n-bytes, allocations carry information about pointers and undefined bytes.\n-\n-\\begin{minted}[autogobble]{rust}\n-  struct Memory {\n-      map: HashMap<AllocId, Allocation>,\n-      next_id: AllocId,\n-  }\n-\n-  struct Allocation {\n-      bytes: Vec<u8>,\n-      relocations: BTreeMap<usize, AllocId>,\n-      undef_mask: UndefMask,\n-  }\n-\\end{minted}\n-\n-\\subsubsection{Relocations}\n-\n-The abstract machine represents pointers through ``relocations'', which are analogous to relocations\n-in linkers\\footnote{\\href{https://en.wikipedia.org/wiki/Relocation_(computing)}{Relocation\n-(computing) - Wikipedia}}. Instead of storing a global memory address in the raw byte representation\n-like on a physical machine, we store an offset from the start of the target allocation and add an\n-entry to the relocation table which maps the index of the offset bytes to the target allocation.\n-\n-In \\autoref{fig:reloc}, the relocation stored at offset 0 in \\rust{y} points to offset 2 in \\rust{x}\n-(the 2nd 16-bit integer). Thus, the relocation table for \\rust{y} is \\texttt{\\{0 =>\n-x\\}}, meaning the next $N$ bytes after offset 0 denote an offset into allocation \\rust{x} where $N$\n-is the size of a pointer (4 in this example). The example shows this as a labelled line beneath the\n-offset bytes.\n-\n-In effect, the abstract machine represents pointers as \\rust{(allocation_id, offset)} pairs. This\n-makes it easy to detect when pointer accesses go out of bounds.\n-\n-\\begin{figure}[hb]\n-  \\begin{minted}[autogobble]{rust}\n-    let x: [i16; 3] = [0xAABB, 0xCCDD, 0xEEFF];\n-    let y = &x[1];\n-    // x: BB AA DD CC FF EE (6 bytes)\n-    // y: 02 00 00 00 (4 bytes)\n-    //    \u2514\u2500\u2500\u2500(x)\u2500\u2500\u2500\u2518\n-  \\end{minted}\n-  \\caption{Example relocation on 32-bit little-endian}\n-  \\label{fig:reloc}\n-\\end{figure}\n-\n-\\subsubsection{Undefined byte mask}\n-\n-The final piece of an abstract allocation is the undefined byte mask. Logically, we store a boolean\n-for the definedness of every byte in the allocation, but there are multiple ways to make the storage\n-more compact. I tried two implementations: one based on the endpoints of alternating ranges of\n-defined and undefined bytes and the other based on a bitmask. The former is more compact but I found\n-it surprisingly difficult to update cleanly. I currently use the much simpler bitmask system.\n-\n-See \\autoref{fig:undef} for an example of an undefined byte in a value, represented by underscores.\n-Note that there is a value for the second byte in the byte array, but it doesn't matter what it is.\n-The bitmask would be $10_2$, i.e.\\ \\rust{[true, false]}.\n-\n-\\begin{figure}[hb]\n-  \\begin{minted}[autogobble]{rust}\n-    let x: [u8; 2] = unsafe {\n-        [1, std::mem::uninitialized()]\n-    };\n-    // x: 01 __ (2 bytes)\n-  \\end{minted}\n-  \\caption{Example undefined byte}\n-  \\label{fig:undef}\n-\\end{figure}\n-\n-\\subsection{Computing data layout}\n-\n-Currently, the Rust compiler's data layouts for types are hidden from Miri, so it does its own data\n-layout computation which will not always match what the compiler does, since Miri doesn't take\n-target type alignments into account. In the future, the Rust compiler may be modified so that Miri\n-can use the exact same data layout.\n-\n-Miri's data layout calculation is a relatively simple transformation from Rust types to a structure\n-with constant size values for primitives and sets of fields with offsets for aggregate types. These\n-layouts are cached for performance.\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Deterministic execution}\n-\\label{sec:deterministic}\n-\n-In order to be effective as a compile-time evaluator, Miri must have \\emph{deterministic execution},\n-as explained by Burtescu in the ``Rust Abstract Machine'' post. That is, given a function and\n-arguments to that function, Miri should always produce identical results. This is important for\n-coherence in the type checker when constant evaluations are involved in types, such as for sizes of\n-array types:\n-\n-\\begin{minted}[autogobble,mathescape]{rust}\n-  const fn get_size() -> usize { /* $\\ldots$ */ }\n-  let array: [i32; get_size()];\n-\\end{minted}\n-\n-Since Miri allows execution of unsafe code\\footnote{In fact, the distinction between safe and unsafe\n-doesn't exist at the MIR level.}, it is specifically designed to remain safe while interpreting\n-potentially unsafe code. When Miri encounters an unrecoverable error, it reports it via the Rust\n-compiler's usual error reporting mechanism, pointing to the part of the original code where the\n-error occurred. Below is an example from Miri's\n-repository.\\footnote{\\href{https://github.com/solson/miri/blob/master/test/errors.rs}{miri/test/errors.rs}}\n-\n-\\begin{minted}[autogobble]{rust}\n-  let b = Box::new(42);\n-  let p: *const i32 = &*b;\n-  drop(b);\n-  unsafe { *p }\n-  //       ~~ error: dangling pointer\n-  //            was dereferenced\n-\\end{minted}\n-\\label{dangling-pointer}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Language support}\n-\n-In its current state, Miri supports a large proportion of the Rust language, detailed below. The\n-major exception is a lack of support for  FFI\\footnote{Foreign Function Interface, e.g.\\ calling\n-functions defined in Assembly, C, or C++.}, which eliminates possibilities like reading and writing\n-files, user input, graphics, and more. However, for compile-time evaluation in Rust, this limitation\n-is desired.\n-\n-\\subsection{Primitives}\n-\n-Miri supports booleans, integers of various sizes and signed-ness (i.e.\\ \\rust{i8}, \\rust{i16},\n-\\rust{i32}, \\rust{i64}, \\rust{isize}, \\rust{u8}, \\rust{u16}, \\rust{u32}, \\rust{u64}, \\rust{usize}),\n-and unary and binary operations over these types. The \\rust{isize} and \\rust{usize} types will be\n-sized according to the target machine's pointer size just like in compiled Rust. The \\rust{char} and\n-float types (\\rust{f32}, \\rust{f64}) are not supported yet, but there are no known barriers to doing\n-so.\n-\n-When examining a boolean in an \\rust{if} condition, Miri will report an error if its byte\n-representation is not precisely 0 or 1, since having any other value for a boolean is undefined\n-behaviour in Rust. The \\rust{char} type will have similar restrictions once it is implemented.\n-\n-\\subsection{Pointers}\n-\n-Both references and raw pointers are supported, with essentially no difference between them in Miri.\n-It is also possible to do pointer comparisons and math. However, a few operations are considered\n-errors and a few require special support.\n-\n-Firstly, pointers into the same allocations may be compared for ordering, but pointers into\n-different allocations are considered unordered and Miri will complain if you attempt this. The\n-reasoning is that different allocations may have different orderings in the global address space at\n-runtime, making this non-deterministic. However, pointers into different allocations \\emph{may} be\n-compared for direct equality (they are always unequal).\n-\n-Secondly, pointers represented using relocations may be compared against pointers casted from\n-integers (e.g.\\ \\rust{0 as *const i32}) for things like null pointer checks. To handle these cases,\n-Miri has a concept of ``integer pointers'' which are always unequal to abstract pointers. Integer\n-pointers can be compared and operated upon freely. However, note that it is impossible to go from an\n-integer pointer to an abstract pointer backed by a relocation. It is not valid to dereference an\n-integer pointer.\n-\n-\\subsubsection{Slice pointers}\n-\n-Rust supports pointers to ``dynamically-sized types'' such as \\rust{[T]} and \\rust{str} which\n-represent arrays of indeterminate size. Pointers to such types contain an address \\emph{and} the\n-length of the referenced array. Miri supports these fully.\n-\n-\\subsubsection{Trait objects}\n-\n-Rust also supports pointers to ``trait objects'' which represent some type that implements a trait,\n-with the specific type unknown at compile-time. These are implemented using virtual dispatch with a\n-vtable, similar to virtual methods in C++. Miri does not currently support these at all.\n-\n-\\subsection{Aggregates}\n-\n-Aggregates include types declared with \\rust{struct} or \\rust{enum} as well as tuples, arrays, and\n-closures. Miri supports all common usage of all of these types. The main missing piece is to handle\n-\\texttt{\\#[repr(..)]} annotations which adjust the layout of a \\rust{struct} or \\rust{enum}.\n-\n-\\subsection{Lvalue projections}\n-\n-This category includes field accesses, dereferencing, accessing data in an \\rust{enum} variant, and\n-indexing arrays. Miri supports all of these, including nested projections such as\n-\\rust{*foo.bar[2]}.\n-\n-\\subsection{Control flow}\n-\n-All of Rust's standard control flow features, including \\rust{loop}, \\rust{while}, \\rust{for},\n-\\rust{if}, \\rust{if let}, \\rust{while let}, \\rust{match}, \\rust{break}, \\rust{continue}, and\n-\\rust{return} are supported. In fact, supporting these was quite easy since the Rust compiler\n-reduces them all down to a small set of control-flow graph primitives in MIR.\n-\n-\\subsection{Function calls}\n-\n-As previously described, Miri supports arbitrary function calls without growing the native stack\n-(only its virtual call stack). It is somewhat limited by the fact that cross-crate\\footnote{A crate\n-is a single Rust library (or executable).} calls only work for functions whose MIR is stored in\n-crate metadata. This is currently true for \\rust{const}, generic, and inline functions.\n-A branch of the compiler could be made that stores MIR for all functions. This would be a non-issue\n-for a compile-time evaluator based on Miri, since it would only call \\rust{const fn}s.\n-\n-\\subsubsection{Method calls}\n-\n-Miri supports trait method calls, including invoking all the compiler-internal lookup needed to find\n-the correct implementation of the method.\n-\n-\\subsubsection{Closures}\n-\n-Calls to closures are also supported with the exception of one edge case\\footnote{Calling a closure\n-that takes a reference to its captures via a closure interface that passes the captures by value is\n-not yet supported.}. The value part of a closure that holds the captured variables is handled as an\n-aggregate and the function call part is mostly the same as a trait method call, but with the added\n-complication that closures use a separate calling convention within the compiler.\n-\n-\\subsubsection{Function pointers}\n-\n-Function pointers are not currently supported by Miri, but there is a relatively simple way they\n-could be encoded using a relocation with a special reserved allocation identifier. The offset of the\n-relocation would determine which function it points to in a special array of functions in the\n-interpreter.\n-\n-\\subsubsection{Intrinsics}\n-\n-To support unsafe code, and in particular to support Rust's standard library, it became clear that\n-Miri would have to support calls to compiler\n-intrinsics\\footnote{\\url{https://doc.rust-lang.org/stable/std/intrinsics/index.html}}. Intrinsics\n-are function calls which cause the Rust compiler to produce special-purpose code instead of a\n-regular function call. Miri simply recognizes intrinsic calls by their unique\n-ABI\\footnote{Application Binary Interface, which defines calling conventions. Includes ``C'',\n-``Rust'', and ``rust-intrinsic''.} and name and runs special-purpose code to handle them.\n-\n-An example of an important intrinsic is \\rust{size_of} which will cause Miri to write the size of\n-the type in question to the return value location. The Rust standard library uses intrinsics heavily\n-to implement various data structures, so this was a major step toward supporting them. Intrinsics\n-have been implemented on a case-by-case basis as tests which required them were written, and not all\n-intrinsics are supported yet.\n-\n-\\subsubsection{Generic function calls}\n-\n-Miri needs special support for generic function calls since Rust is a \\emph{monomorphizing}\n-compiler, meaning it generates a special version of each function for each distinct set of type\n-parameters it gets called with. Since functions in MIR are still polymorphic, Miri has to do the\n-same thing and substitute function type parameters into all types it encounters to get fully\n-concrete, monomorphized types. For example, in\\ldots\n-\n-\\begin{minted}[autogobble]{rust}\n-  fn some<T>(t: T) -> Option<T> { Some(t) }\n-\\end{minted}\n-\n-\\ldots{}Miri needs to know the size of \\rust{T} to copy the right amount of bytes from the argument\n-to the return value. If we call \\rust{some(10i32)} Miri will execute \\rust{some} knowing that\n-\\rust{T = i32} and generate a representation for \\rust{Option<i32>}.\n-\n-Miri currently does this monomorphization lazily on-demand unlike the Rust back-end which does it\n-all ahead of time.\n-\n-\\subsection{Heap allocations}\n-\n-The next piece of the puzzle for supporting interesting programs (and the standard library) was heap\n-allocations. There are two main interfaces for heap allocation in Rust: the built-in \\rust{Box}\n-rvalue in MIR and a set of C ABI foreign functions including \\rust{__rust_allocate},\n-\\rust{__rust_reallocate}, and \\rust{__rust_deallocate}. These correspond approximately to\n-\\mintinline{c}{malloc}, \\mintinline{c}{realloc}, and \\mintinline{c}{free} in C.\n-\n-The \\rust{Box} rvalue allocates enough space for a single value of a given type. This was easy to\n-support in Miri. It simply creates a new abstract allocation in the same manner as for\n-stack-allocated values, since there's no major difference between them in Miri.\n-\n-The allocator functions, which are used to implement things like Rust's standard \\rust{Vec<T>} type,\n-were a bit trickier. Rust declares them as \\rust{extern \"C\" fn} so that different allocator\n-libraries can be linked in at the user's option. Since Miri doesn't actually support FFI and wants\n-full control of allocations for safety, it ``cheats'' and recognizes these allocator functions in\n-essentially the same way it recognizes compiler intrinsics. Then, a call to \\rust{__rust_allocate}\n-simply creates another abstract allocation with the requested size and \\rust{__rust_reallocate}\n-grows one.\n-\n-In the future, Miri should also track which allocations came from \\rust{__rust_allocate} so it can\n-reject reallocate or deallocate calls on stack allocations.\n-\n-\\subsection{Destructors}\n-\n-When a value which ``owns'' some resource (like a heap allocation or file handle) goes out of scope,\n-Rust inserts \\emph{drop glue} that calls the user-defined destructor for the type if it has one, and\n-then drops all of the subfields. Destructors for types like \\rust{Box<T>} and \\rust{Vec<T>}\n-deallocate heap memory.\n-\n-Miri doesn't yet support calling user-defined destructors, but it has most of the machinery in place\n-to do so already. There \\emph{is} support for dropping \\rust{Box<T>} types, including deallocating\n-their associated allocations. This is enough to properly execute the dangling pointer example in\n-\\autoref{sec:deterministic}.\n-\n-\\subsection{Constants}\n-\n-Only basic integer, boolean, string, and byte-string literals are currently supported. Evaluating\n-more complicated constant expressions in their current form would be a somewhat pointless exercise\n-for Miri. Instead, we should lower constant expressions to MIR so Miri can run them directly, which\n-is precisely what would need be done to use Miri as the compiler's constant evaluator.\n-\n-\\subsection{Static variables}\n-\n-Miri doesn't currently support statics, but they would need support similar to constants. Also note\n-that while it would be invalid to write to static (i.e.\\ global) variables in Miri executions, it\n-would probably be fine to allow reads.\n-\n-\\subsection{Standard library}\n-\n-Throughout the implementation of the above features, I often followed this process:\n-\n-\\begin{enumerate}\n-  \\item Try using a feature from the standard library.\n-  \\item See where Miri runs into stuff it can't handle.\n-  \\item Fix the problem.\n-  \\item Go to 1.\n-\\end{enumerate}\n-\n-At present, Miri supports a number of major non-trivial features from the standard library along\n-with tons of minor features. Smart pointer types such as \\rust{Box}, \\rust{Rc}\\footnote{Reference\n-counted shared pointer} and \\rust{Arc}\\footnote{Atomically reference-counted thread-safe shared\n-pointer} all seem to work. I've also tested using the shared smart pointer types with \\rust{Cell}\n-and \\rust{RefCell}\\footnote{\\href{https://doc.rust-lang.org/stable/std/cell/index.html}{Rust\n-documentation for cell types}} for internal mutability, and that works as well, although\n-\\rust{RefCell} can't ever be borrowed twice until I implement destructor calls, since a destructor\n-is what releases the borrow.\n-\n-But the standard library collection I spent the most time on was \\rust{Vec}, the standard\n-dynamically-growable array type, similar to C++'s \\texttt{std::vector} or Java's\n-\\texttt{java.util.ArrayList}. In Rust, \\rust{Vec} is an extremely pervasive collection, so\n-supporting it is a big win for supporting a larger swath of Rust programs in Miri.\n-\n-See \\autoref{fig:vec} for an example (working in Miri today) of initializing a \\rust{Vec} with a\n-small amount of space on the heap and then pushing enough elements to force it to reallocate its\n-data array. This involves cross-crate generic function calls, unsafe code using raw pointers, heap\n-allocation, handling of uninitialized memory, compiler intrinsics, and more.\n-\n-\\begin{figure}[t]\n-  \\begin{minted}[autogobble]{rust}\n-    struct Vec<T> {\n-        data: *mut T,    // 4 byte pointer\n-        capacity: usize, // 4 byte integer\n-        length: usize,   // 4 byte integer\n-    }\n-\n-    let mut v: Vec<u8> =\n-        Vec::with_capacity(2);\n-    // v: 00 00 00 00 02 00 00 00 00 00 00 00\n-    //    \u2514\u2500(data)\u2500\u2500\u2518\n-    // data: __ __\n-\n-    v.push(1);\n-    // v: 00 00 00 00 02 00 00 00 01 00 00 00\n-    //    \u2514\u2500(data)\u2500\u2500\u2518\n-    // data: 01 __\n-\n-    v.push(2);\n-    // v: 00 00 00 00 02 00 00 00 02 00 00 00\n-    //    \u2514\u2500(data)\u2500\u2500\u2518\n-    // data: 01 02\n-\n-    v.push(3);\n-    // v: 00 00 00 00 04 00 00 00 03 00 00 00\n-    //    \u2514\u2500(data)\u2500\u2500\u2518\n-    // data: 01 02 03 __\n-  \\end{minted}\n-  \\caption{\\rust{Vec} example on 32-bit little-endian}\n-  \\label{fig:vec}\n-\\end{figure}\n-\n-Miri supports unsafe operations on \\rust{Vec} like \\rust{v.set_len(10)} or\n-\\rust{v.get_unchecked(2)}, provided that such calls do no invoke undefined behaviour. If a call\n-\\emph{does} invoke undefined behaviour, Miri will abort with an appropriate error message (see\n-\\autoref{fig:vec-error}).\n-\n-\\begin{figure}[t]\n-  \\begin{minted}[autogobble]{rust}\n-    fn out_of_bounds() -> u8 {\n-        let v = vec![1, 2];\n-        let p = unsafe { v.get_unchecked(5) };\n-        *p + 10\n-    //  ~~ error: pointer offset outside\n-    //       bounds of allocation\n-    }\n-\n-    fn undefined_bytes() -> u8 {\n-        let v = Vec::<u8>::with_capacity(10);\n-        let p = unsafe { v.get_unchecked(5) };\n-        *p + 10\n-    //  ~~~~~~~ error: attempted to read\n-    //            undefined bytes\n-    }\n-  \\end{minted}\n-  \\caption{\\rust{Vec} examples with undefined behaviour}\n-  \\label{fig:vec-error}\n-\\end{figure}\n-\n-\\newpage\n-\n-Here is one final code sample Miri can execute that demonstrates many features at once, including\n-vectors, heap allocation, iterators, closures, raw pointers, and math:\n-\n-\\begin{minted}[autogobble]{rust}\n-  let x: u8 = vec![1, 2, 3, 4]\n-      .into_iter()\n-      .map(|x| x * x)\n-      .fold(0, |x, y| x + y);\n-    // x: 1e (that is, the hex value\n-    //        0x1e = 30 = 1 + 4 + 9 + 16)\n-\\end{minted}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Future directions}\n-\n-\\subsection{Finishing the implementation}\n-\n-There are a number of pressing items on my to-do list for Miri, including:\n-\n-\\begin{itemize}\n-  \\item A much more comprehensive and automated test suite.\n-  \\item User-defined destructor calls.\n-  \\item Non-trivial casts between primitive types like integers and pointers.\n-  \\item Handling statics and global memory.\n-  \\item Reporting errors for all undefined behaviour.\\footnote{\\href{https://doc.rust-lang.org/reference.html\\#behavior-considered-undefined}{The Rust reference on what is considered undefined behaviour}}\n-  \\item Function pointers.\n-  \\item Accounting for target machine primitive type alignment and endianness.\n-  \\item Optimizations (undefined byte masks, tail-calls).\n-  \\item Benchmarking Miri vs. unoptimized Rust.\n-  \\item Various \\texttt{TODO}s and \\texttt{FIXME}s left in the code.\n-  \\item Integrating into the compiler proper.\n-\\end{itemize}\n-\n-\\subsection{Future projects}\n-\n-Other possible Miri-related projects include:\n-\n-\\begin{itemize}\n-  \\item A read-eval-print-loop (REPL) for Rust, which may be easier to implement on top of Miri than\n-    the usual LLVM back-end.\n-  \\item A graphical or text-mode debugger that steps through MIR execution one statement at a time,\n-    for figuring out why some compile-time execution is raising an error or simply learning how Rust\n-    works at a low level.\n-  \\item A less restricted version of Miri that is able to run foreign functions from C/C++ and\n-    generally has full access to the operating system. Such an interpreter could be used to more\n-    quickly prototype changes to the Rust language that would otherwise require changes to the LLVM\n-    back-end.\n-  \\item Unit-testing the compiler by comparing the results of Miri's execution against the results\n-    of LLVM-compiled machine code's execution. This would help to guarantee that compile-time\n-    execution works the same as runtime execution.\n-  \\item Some kind of Miri-based symbolic evaluator that examines multiple possible code paths at\n-    once to determine if undefined behaviour could be observed on any of them.\n-\\end{itemize}\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Final thoughts}\n-\n-Writing an interpreter which models values of varying sizes, stack and heap allocation, unsafe\n-memory operations, and more requires some unconventional techniques compared to conventional\n-interpreters targeting dynamically-typed languages. However, aside from the somewhat complicated\n-abstract memory model, making Miri work was primarily a software engineering problem, and not a\n-particularly tricky one. This is a testament to MIR's suitability as an intermediate representation\n-for Rust---removing enough unnecessary abstraction to keep it simple. For example, Miri doesn't even\n-need to know that there are different kinds of loops, or how to match patterns in a \\rust{match}\n-expression.\n-\n-Another advantage to targeting MIR is that any new features at the syntax-level or type-level\n-generally require little to no change in Miri. For example, when the new ``question mark'' syntax\n-for error handling\\footnote{\n-  \\href{https://github.com/rust-lang/rfcs/blob/master/text/0243-trait-based-exception-handling.md}\n-    {Question mark syntax RFC}}\n-was added to rustc, Miri required no change to support it.\n-When specialization\\footnote{\n-  \\href{https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md}\n-    {Specialization RFC}}\n-was added, Miri supported it with just minor changes to trait method lookup.\n-\n-Of course, Miri also has limitations. The inability to execute FFI and inline assembly reduces the\n-amount of Rust programs Miri could ever execute. The good news is that in the constant evaluator,\n-FFI can be stubbed out in cases where it makes sense, like I did with \\rust{__rust_allocate}. For a\n-version of Miri not intended for constant evaluation, it may be possible to use libffi to call C\n-functions from the interpreter.\n-\n-In conclusion, Miri is a surprisingly effective project, and a lot of fun to implement. Due to MIR's\n-tendency to collapse multiple source-level features into one, I often ended up supporting features I\n-hadn't explicitly intended to. I am excited to work with the compiler team going forward to try to\n-make Miri useful for constant evaluation in Rust.\n-\n-%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n-\n-\\section{Thanks}\n-\n-A big thanks goes to Eduard Burtescu for writing the abstract machine specification and answering my\n-incessant questions on IRC, to Niko Matsakis for coming up with the idea for Miri and supporting my\n-desire to work with the Rust compiler, and to my research supervisor Christopher Dutchyn. Thanks\n-also to everyone else on the compiler team and on Mozilla IRC who helped me figure stuff out.\n-Finally, thanks to Daniel Keep and everyone else who helped fix my numerous writing mistakes.\n-\n-\\end{document}"}, {"sha": "031ad9a8795491b7e05f2290d3063fa31ab808df", "filename": "xargo/Cargo.lock", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2FCargo.lock?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,4 +0,0 @@\n-[root]\n-name = \"miri-xargo\"\n-version = \"0.0.0\"\n-"}, {"sha": "9129c105b112bb1b3dd597b118e2ac13466b505b", "filename": "xargo/Cargo.toml", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2FCargo.toml?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,6 +0,0 @@\n-[package]\n-name = \"miri-xargo\"\n-description = \"A dummy project for building libstd with xargo.\"\n-version = \"0.0.0\"\n-\n-[dependencies]"}, {"sha": "4b650b97de56a2d7e21d0e4b879730725d415ac6", "filename": "xargo/Xargo.toml", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2FXargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2FXargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2FXargo.toml?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,2 +0,0 @@\n-[dependencies]\n-std = {features = [\"panic_unwind\", \"jemalloc\", \"backtrace\"]}"}, {"sha": "15a7c770910dd7dcd5dc5d9c743a4c703f00d91c", "filename": "xargo/build.sh", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2Fbuild.sh?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a", "patch": "@@ -1,3 +0,0 @@\n-#!/bin/sh\n-cd \"$(dirname \"$0\")\"\n-RUSTFLAGS='-Zalways-encode-mir -Zmir-emit-validate=1' xargo build"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "xargo/src/lib.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed674f7cb3362d8f54f7baf29725ba66c88d037a/xargo%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2Fsrc%2Flib.rs?ref=ed674f7cb3362d8f54f7baf29725ba66c88d037a"}]}