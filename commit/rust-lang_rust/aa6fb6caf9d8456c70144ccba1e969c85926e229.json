{"sha": "aa6fb6caf9d8456c70144ccba1e969c85926e229", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNmZiNmNhZjlkODQ1NmM3MDE0NGNjYmExZTk2OWM4NTkyNmUyMjk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-01-26T17:25:37Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-04-21T19:50:02Z"}, "message": "Enable migrate mode by default on the 2015 edition\n\nThis also fully stabilizes two-phase borrows on all editions", "tree": {"sha": "f3462bb442058c39ce2e6960e36d3180acc98565", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3462bb442058c39ce2e6960e36d3180acc98565"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa6fb6caf9d8456c70144ccba1e969c85926e229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa6fb6caf9d8456c70144ccba1e969c85926e229", "html_url": "https://github.com/rust-lang/rust/commit/aa6fb6caf9d8456c70144ccba1e969c85926e229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa6fb6caf9d8456c70144ccba1e969c85926e229/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31a75a172859d906d8e6a34af4afff9830af495c", "url": "https://api.github.com/repos/rust-lang/rust/commits/31a75a172859d906d8e6a34af4afff9830af495c", "html_url": "https://github.com/rust-lang/rust/commit/31a75a172859d906d8e6a34af4afff9830af495c"}], "stats": {"total": 511, "additions": 154, "deletions": 357}, "files": [{"sha": "747f0a6ae87238e777c9763da1892917789a1e70", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -92,8 +92,8 @@ impl SuppressRegionErrors {\n     /// enabled.\n     pub fn when_nll_is_enabled(tcx: TyCtxt<'_, '_, '_>) -> Self {\n         match tcx.borrowck_mode() {\n-            // If we're on AST or Migrate mode, report AST region errors\n-            BorrowckMode::Ast | BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n+            // If we're on Migrate mode, report AST region errors\n+            BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n \n             // If we're on MIR or Compare mode, don't report AST region errors as they should\n             // be reported by NLL"}, {"sha": "cb307800fcdc26b8f0a54d4941c2942679d436e4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -460,7 +460,6 @@ pub enum PrintRequest {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum BorrowckMode {\n-    Ast,\n     Mir,\n     Compare,\n     Migrate,\n@@ -471,7 +470,6 @@ impl BorrowckMode {\n     /// on the AST borrow check if the MIR-based one errors.\n     pub fn migrate(self) -> bool {\n         match self {\n-            BorrowckMode::Ast => false,\n             BorrowckMode::Compare => false,\n             BorrowckMode::Mir => false,\n             BorrowckMode::Migrate => true,\n@@ -481,21 +479,11 @@ impl BorrowckMode {\n     /// Should we emit the AST-based borrow checker errors?\n     pub fn use_ast(self) -> bool {\n         match self {\n-            BorrowckMode::Ast => true,\n             BorrowckMode::Compare => true,\n             BorrowckMode::Mir => false,\n             BorrowckMode::Migrate => false,\n         }\n     }\n-    /// Should we emit the MIR-based borrow checker errors?\n-    pub fn use_mir(self) -> bool {\n-        match self {\n-            BorrowckMode::Ast => false,\n-            BorrowckMode::Compare => true,\n-            BorrowckMode::Mir => true,\n-            BorrowckMode::Migrate => true,\n-        }\n-    }\n }\n \n pub enum Input {\n@@ -627,7 +615,7 @@ impl Default for Options {\n             incremental: None,\n             debugging_opts: basic_debugging_options(),\n             prints: Vec::new(),\n-            borrowck_mode: BorrowckMode::Ast,\n+            borrowck_mode: BorrowckMode::Migrate,\n             cg: basic_codegen_options(),\n             error_format: ErrorOutputType::default(),\n             externs: Externs(BTreeMap::new()),\n@@ -2326,10 +2314,9 @@ pub fn build_session_options_and_crate_config(\n     }));\n \n     let borrowck_mode = match debugging_opts.borrowck.as_ref().map(|s| &s[..]) {\n-        None | Some(\"ast\") => BorrowckMode::Ast,\n+        None | Some(\"migrate\") => BorrowckMode::Migrate,\n         Some(\"mir\") => BorrowckMode::Mir,\n         Some(\"compare\") => BorrowckMode::Compare,\n-        Some(\"migrate\") => BorrowckMode::Migrate,\n         Some(m) => early_error(error_format, &format!(\"unknown borrowck mode `{}`\", m)),\n     };\n "}, {"sha": "ed500d1ac3351d17f7fb4757f2c9509d8008771c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 53, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -70,7 +70,6 @@ use rustc_macros::HashStable;\n use syntax::ast;\n use syntax::attr;\n use syntax::source_map::MultiSpan;\n-use syntax::edition::Edition;\n use syntax::feature_gate;\n use syntax::symbol::{Symbol, keywords, InternedString};\n use syntax_pos::Span;\n@@ -1496,21 +1495,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// because that method has a narrower effect that can be toggled\n     /// off via a separate `-Z` flag, at least for the short term.\n     pub fn allow_bind_by_move_patterns_with_guards(self) -> bool {\n-        self.features().bind_by_move_pattern_guards && self.use_mir_borrowck()\n+        self.features().bind_by_move_pattern_guards\n     }\n \n     /// If true, we should use a naive AST walk to determine if match\n     /// guard could perform bad mutations (or mutable-borrows).\n     pub fn check_for_mutation_in_guard_via_ast_walk(self) -> bool {\n-        // If someone requests the feature, then be a little more\n-        // careful and ensure that MIR-borrowck is enabled (which can\n-        // happen via edition selection, via `feature(nll)`, or via an\n-        // appropriate `-Z` flag) before disabling the mutation check.\n-        if self.allow_bind_by_move_patterns_with_guards() {\n-            return false;\n-        }\n-\n-        return true;\n+        !self.allow_bind_by_move_patterns_with_guards()\n     }\n \n     /// If true, we should use the AST-based borrowck (we may *also* use\n@@ -1519,12 +1510,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.borrowck_mode().use_ast()\n     }\n \n-    /// If true, we should use the MIR-based borrowck (we may *also* use\n-    /// the AST-based borrowck).\n-    pub fn use_mir_borrowck(self) -> bool {\n-        self.borrowck_mode().use_mir()\n-    }\n-\n     /// If true, we should use the MIR-based borrow check, but also\n     /// fall back on the AST borrow check if the MIR-based one errors.\n     pub fn migrate_borrowck(self) -> bool {\n@@ -1541,38 +1526,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// statements (which simulate the maximal effect of executing the\n     /// patterns in a match arm).\n     pub fn emit_read_for_match(&self) -> bool {\n-        self.use_mir_borrowck() && !self.sess.opts.debugging_opts.nll_dont_emit_read_for_match\n-    }\n-\n-    /// If true, pattern variables for use in guards on match arms\n-    /// will be bound as references to the data, and occurrences of\n-    /// those variables in the guard expression will implicitly\n-    /// dereference those bindings. (See rust-lang/rust#27282.)\n-    pub fn all_pat_vars_are_implicit_refs_within_guards(self) -> bool {\n-        self.borrowck_mode().use_mir()\n-    }\n-\n-    /// If true, we should enable two-phase borrows checks. This is\n-    /// done with either: `-Ztwo-phase-borrows`, `#![feature(nll)]`,\n-    /// or by opting into an edition after 2015.\n-    pub fn two_phase_borrows(self) -> bool {\n-        self.sess.rust_2018() || self.features().nll ||\n-        self.sess.opts.debugging_opts.two_phase_borrows\n+        !self.sess.opts.debugging_opts.nll_dont_emit_read_for_match\n     }\n \n     /// What mode(s) of borrowck should we run? AST? MIR? both?\n     /// (Also considers the `#![feature(nll)]` setting.)\n     pub fn borrowck_mode(&self) -> BorrowckMode {\n         // Here are the main constraints we need to deal with:\n         //\n-        // 1. An opts.borrowck_mode of `BorrowckMode::Ast` is\n+        // 1. An opts.borrowck_mode of `BorrowckMode::Migrate` is\n         //    synonymous with no `-Z borrowck=...` flag at all.\n-        //    (This is arguably a historical accident.)\n-        //\n-        // 2. `BorrowckMode::Migrate` is the limited migration to\n-        //    NLL that we are deploying with the 2018 edition.\n         //\n-        // 3. We want to allow developers on the Nightly channel\n+        // 2. We want to allow developers on the Nightly channel\n         //    to opt back into the \"hard error\" mode for NLL,\n         //    (which they can do via specifying `#![feature(nll)]`\n         //    explicitly in their crate).\n@@ -1585,24 +1550,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //   a user's attempt to specify `-Z borrowck=compare`, which\n         //   we arguably do not need anymore and should remove.)\n         //\n-        // * Otherwise, if no `-Z borrowck=...` flag was given (or\n-        //   if `borrowck=ast` was specified), then use the default\n-        //   as required by the edition.\n+        // * Otherwise, if no `-Z borrowck=...` then use migrate mode\n         //\n         // * Otherwise, use the behavior requested via `-Z borrowck=...`\n \n         if self.features().nll { return BorrowckMode::Mir; }\n \n-        match self.sess.opts.borrowck_mode {\n-            mode @ BorrowckMode::Mir |\n-            mode @ BorrowckMode::Compare |\n-            mode @ BorrowckMode::Migrate => mode,\n-\n-            BorrowckMode::Ast => match self.sess.edition() {\n-                Edition::Edition2015 => BorrowckMode::Ast,\n-                Edition::Edition2018 => BorrowckMode::Migrate,\n-            },\n-        }\n+        self.sess.opts.borrowck_mode\n     }\n \n     #[inline]"}, {"sha": "540f374bcf9dc8d65dcd6fc235ef8a96d370d055", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -49,8 +49,6 @@ pub mod gather_loans;\n \n pub mod move_data;\n \n-mod unused;\n-\n #[derive(Clone, Copy)]\n pub struct LoanDataFlowOperator;\n \n@@ -138,10 +136,6 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n         check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n     }\n \n-    if !tcx.use_mir_borrowck() {\n-        unused::check(&mut bccx, body);\n-    }\n-\n     Lrc::new(BorrowCheckResult {\n         used_mut_nodes: bccx.used_mut_nodes.into_inner(),\n         signalled_any_error: bccx.signalled_any_error.into_inner(),"}, {"sha": "60a9c18e95ee9bac025839de33c8a1a3e6e50618", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/31a75a172859d906d8e6a34af4afff9830af495c/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31a75a172859d906d8e6a34af4afff9830af495c/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=31a75a172859d906d8e6a34af4afff9830af495c", "patch": "@@ -1,116 +0,0 @@\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-use rustc::hir::{self, HirId};\n-use rustc::lint::builtin::UNUSED_MUT;\n-use rustc::ty;\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use errors::Applicability;\n-use std::slice;\n-use syntax::ptr::P;\n-\n-use crate::borrowck::BorrowckCtxt;\n-\n-pub fn check<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, body: &'tcx hir::Body) {\n-    let mut used_mut = bccx.used_mut_nodes.borrow().clone();\n-    UsedMutFinder {\n-        bccx,\n-        set: &mut used_mut,\n-    }.visit_expr(&body.value);\n-    let mut cx = UnusedMutCx { bccx, used_mut };\n-    for arg in body.arguments.iter() {\n-        cx.check_unused_mut_pat(slice::from_ref(&arg.pat));\n-    }\n-    cx.visit_expr(&body.value);\n-}\n-\n-struct UsedMutFinder<'a, 'tcx: 'a> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    set: &'a mut FxHashSet<HirId>,\n-}\n-\n-struct UnusedMutCx<'a, 'tcx: 'a> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    used_mut: FxHashSet<HirId>,\n-}\n-\n-impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n-    fn check_unused_mut_pat(&self, pats: &[P<hir::Pat>]) {\n-        let tcx = self.bccx.tcx;\n-        let mut mutables: FxHashMap<_, Vec<_>> = Default::default();\n-        for p in pats {\n-            p.each_binding(|_, hir_id, span, ident| {\n-                // Skip anything that looks like `_foo`\n-                if ident.as_str().starts_with(\"_\") {\n-                    return;\n-                }\n-\n-                // Skip anything that looks like `&foo` or `&mut foo`, only look\n-                // for by-value bindings\n-                if let Some(&bm) = self.bccx.tables.pat_binding_modes().get(hir_id) {\n-                    match bm {\n-                        ty::BindByValue(hir::MutMutable) => {}\n-                        _ => return,\n-                    }\n-\n-                    mutables.entry(ident.name).or_default().push((hir_id, span));\n-                } else {\n-                    tcx.sess.delay_span_bug(span, \"missing binding mode\");\n-                }\n-            });\n-        }\n-\n-        for (_name, ids) in mutables {\n-            // If any id for this name was used mutably then consider them all\n-            // ok, so move on to the next\n-            if ids.iter().any(|&(ref hir_id, _)| self.used_mut.contains(hir_id)) {\n-                continue;\n-            }\n-\n-            let (hir_id, span) = ids[0];\n-            if span.compiler_desugaring_kind().is_some() {\n-                // If the `mut` arises as part of a desugaring, we should ignore it.\n-                continue;\n-            }\n-\n-            // Ok, every name wasn't used mutably, so issue a warning that this\n-            // didn't need to be mutable.\n-            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n-            tcx.struct_span_lint_hir(UNUSED_MUT,\n-                                     hir_id,\n-                                     span,\n-                                     \"variable does not need to be mutable\")\n-                .span_suggestion_short(\n-                    mut_span,\n-                    \"remove this `mut`\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for UnusedMutCx<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir())\n-    }\n-\n-    fn visit_arm(&mut self, arm: &hir::Arm) {\n-        self.check_unused_mut_pat(&arm.pats)\n-    }\n-\n-    fn visit_local(&mut self, local: &hir::Local) {\n-        self.check_unused_mut_pat(slice::from_ref(&local.pat));\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for UsedMutFinder<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir())\n-    }\n-\n-    fn visit_nested_body(&mut self, id: hir::BodyId) {\n-        let def_id = self.bccx.tcx.hir().body_owner_def_id(id);\n-        self.set.extend(self.bccx.tcx.borrowck(def_id).used_mut_nodes.iter().cloned());\n-        self.visit_body(self.bccx.tcx.hir().body(id));\n-    }\n-}"}, {"sha": "918192395c3f4eaa42f36c11af31c0638fb0de61", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -303,9 +303,8 @@ impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n     /// allowed to be split into separate Reservation and\n     /// Activation phases.\n     fn allow_two_phase_borrow(&self, kind: mir::BorrowKind) -> bool {\n-        self.tcx.two_phase_borrows()\n-            && (kind.allows_two_phase_borrow()\n-                || self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+        kind.allows_two_phase_borrow()\n+            || self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref\n     }\n \n     /// If this is a two-phase borrow, then we will record it"}, {"sha": "4a3159d8a9dc30d244d6bc3d238aa898c8044f06", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -74,37 +74,28 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowC\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n-    let mut return_early;\n-\n-    // Return early if we are not supposed to use MIR borrow checker for this function.\n-    return_early = !tcx.has_attr(def_id, \"rustc_mir\") && !tcx.use_mir_borrowck();\n-\n+    // We are not borrow checking the automatically generated struct/variant constructors\n+    // because we want to accept structs such as this (taken from the `linked-hash-map`\n+    // crate):\n+    // ```rust\n+    // struct Qey<Q: ?Sized>(Q);\n+    // ```\n+    // MIR of this struct constructor looks something like this:\n+    // ```rust\n+    // fn Qey(_1: Q) -> Qey<Q>{\n+    //     let mut _0: Qey<Q>;                  // return place\n+    //\n+    //     bb0: {\n+    //         (_0.0: Q) = move _1;             // bb0[0]: scope 0 at src/main.rs:1:1: 1:26\n+    //         return;                          // bb0[1]: scope 0 at src/main.rs:1:1: 1:26\n+    //     }\n+    // }\n+    // ```\n+    // The problem here is that `(_0.0: Q) = move _1;` is valid only if `Q` is\n+    // of statically known size, which is not known to be true because of the\n+    // `Q: ?Sized` constraint. However, it is true because the constructor can be\n+    // called only when `Q` is of statically known size.\n     if tcx.is_constructor(def_id) {\n-        // We are not borrow checking the automatically generated struct/variant constructors\n-        // because we want to accept structs such as this (taken from the `linked-hash-map`\n-        // crate):\n-        // ```rust\n-        // struct Qey<Q: ?Sized>(Q);\n-        // ```\n-        // MIR of this struct constructor looks something like this:\n-        // ```rust\n-        // fn Qey(_1: Q) -> Qey<Q>{\n-        //     let mut _0: Qey<Q>;                  // return place\n-        //\n-        //     bb0: {\n-        //         (_0.0: Q) = move _1;             // bb0[0]: scope 0 at src/main.rs:1:1: 1:26\n-        //         return;                          // bb0[1]: scope 0 at src/main.rs:1:1: 1:26\n-        //     }\n-        // }\n-        // ```\n-        // The problem here is that `(_0.0: Q) = move _1;` is valid only if `Q` is\n-        // of statically known size, which is not known to be true because of the\n-        // `Q: ?Sized` constraint. However, it is true because the constructor can be\n-        // called only when `Q` is of statically known size.\n-        return_early = true;\n-    }\n-\n-    if return_early {\n         return BorrowCheckResult {\n             closure_requirements: None,\n             used_mut_upvars: SmallVec::new(),\n@@ -1505,10 +1496,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         span: Span,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n-        if !self.infcx.tcx.two_phase_borrows() {\n-            return;\n-        }\n-\n         // Two-phase borrow support: For each activation that is newly\n         // generated at this statement, check if it interferes with\n         // another borrow."}, {"sha": "a5230e67b756a1f4c375116377fe1c28f890f700", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -474,10 +474,6 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n         &mut self,\n         location: Location,\n     ) {\n-        if !self.tcx.two_phase_borrows() {\n-            return;\n-        }\n-\n         // Two-phase borrow support: For each activation that is newly\n         // generated at this statement, check if it interferes with\n         // another borrow."}, {"sha": "0dee64db727631a9f2421f1da85ea4e9085d4966", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -2672,9 +2672,8 @@ impl MirPass for TypeckMir {\n         let def_id = src.def_id();\n         debug!(\"run_pass: {:?}\", def_id);\n \n-        // When NLL is enabled, the borrow checker runs the typeck\n-        // itself, so we don't need this MIR pass anymore.\n-        if tcx.use_mir_borrowck() {\n+        // FIXME: We don't need this MIR pass anymore.\n+        if true {\n             return;\n         }\n "}, {"sha": "c68dee29c5b1be14e6559e9f63470e40aace952e", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -15,9 +15,8 @@ pub(super) fn allow_two_phase_borrow<'a, 'tcx, 'gcx: 'tcx>(\n     tcx: &TyCtxt<'a, 'gcx, 'tcx>,\n     kind: BorrowKind\n ) -> bool {\n-    tcx.two_phase_borrows()\n-        && (kind.allows_two_phase_borrow()\n-            || tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+    kind.allows_two_phase_borrow()\n+        || tcx.sess.opts.debugging_opts.two_phase_beyond_autoref\n }\n \n /// Control for the path borrow checking code"}, {"sha": "713e3fe0218ba8a0a731886f67314caa92a4d52f", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -112,11 +112,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::SelfRef => block.and(Place::Base(PlaceBase::Local(Local::new(1)))),\n             ExprKind::VarRef { id } => {\n-                let place = if this.is_bound_var_in_guard(id) && this\n-                    .hir\n-                    .tcx()\n-                    .all_pat_vars_are_implicit_refs_within_guards()\n-                {\n+                let place = if this.is_bound_var_in_guard(id) {\n                     let index = this.var_local_id(id, RefWithinGuard);\n                     Place::Base(PlaceBase::Local(index)).deref()\n                 } else {"}, {"sha": "b5b2d78f1bd67bee0fa2de18226a441e9eff4a9a", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -1425,26 +1425,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //      the reference that we create for the arm.\n         //    * So we eagerly create the reference for the arm and then take a\n         //      reference to that.\n-        let tcx = self.hir.tcx();\n-        let autoref = tcx.all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = guard {\n-            if autoref {\n-                self.bind_matched_candidate_for_guard(\n-                    block,\n-                    &candidate.bindings,\n-                );\n-                let guard_frame = GuardFrame {\n-                    locals: candidate\n-                        .bindings\n-                        .iter()\n-                        .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n-                        .collect(),\n-                };\n-                debug!(\"Entering guard building context: {:?}\", guard_frame);\n-                self.guard_context.push(guard_frame);\n-            } else {\n-                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n-            }\n+            let tcx = self.hir.tcx();\n+\n+            self.bind_matched_candidate_for_guard(\n+                block,\n+                &candidate.bindings,\n+            );\n+            let guard_frame = GuardFrame {\n+                locals: candidate\n+                    .bindings\n+                    .iter()\n+                    .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n+                    .collect(),\n+            };\n+            debug!(\"Entering guard building context: {:?}\", guard_frame);\n+            self.guard_context.push(guard_frame);\n \n             let re_erased = tcx.types.re_erased;\n             let scrutinee_source_info = self.source_info(scrutinee_span);\n@@ -1470,13 +1466,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let source_info = self.source_info(guard.span);\n             let guard_end = self.source_info(tcx.sess.source_map().end_point(guard.span));\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n-            if autoref {\n-                let guard_frame = self.guard_context.pop().unwrap();\n-                debug!(\n-                    \"Exiting guard building context with locals: {:?}\",\n-                    guard_frame\n-                );\n-            }\n+            let guard_frame = self.guard_context.pop().unwrap();\n+            debug!(\n+                \"Exiting guard building context with locals: {:?}\",\n+                guard_frame\n+            );\n \n             for &(_, temp) in fake_borrows {\n                 self.cfg.push(block, Statement {\n@@ -1526,28 +1520,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ),\n             );\n \n-            if autoref {\n-                let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n-                    if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n-                });\n-                // Read all of the by reference bindings to ensure that the\n-                // place they refer to can't be modified by the guard.\n-                for binding in by_value_bindings.clone() {\n-                    let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n+            let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n+                if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n+            });\n+            // Read all of the by reference bindings to ensure that the\n+            // place they refer to can't be modified by the guard.\n+            for binding in by_value_bindings.clone() {\n+                let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n                     let place = Place::Base(PlaceBase::Local(local_id));\n-                    self.cfg.push(\n-                        block,\n-                        Statement {\n-                            source_info: guard_end,\n-                            kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, place),\n-                        },\n-                    );\n-                }\n-                self.bind_matched_candidate_for_arm_body(\n-                    post_guard_block,\n-                    by_value_bindings,\n+                self.cfg.push(\n+                    block,\n+                    Statement {\n+                        source_info: guard_end,\n+                        kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, place),\n+                    },\n                 );\n             }\n+            self.bind_matched_candidate_for_arm_body(\n+                post_guard_block,\n+                by_value_bindings,\n+            );\n \n             self.cfg.terminate(\n                 post_guard_block,\n@@ -1604,8 +1596,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Only called when all_pat_vars_are_implicit_refs_within_guards,\n-    // and thus all code/comments assume we are in that context.\n     fn bind_matched_candidate_for_guard(\n         &mut self,\n         block: BasicBlock,\n@@ -1739,7 +1729,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }))),\n         };\n         let for_arm_body = self.local_decls.push(local.clone());\n-        let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n+        let locals = if has_guard.0 {\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n                 // This variable isn't mutated but has a name, so has to be\n                 // immutable to avoid the unused mut lint."}, {"sha": "74a4278d5991b1c5f364457d869fe33b4fb91b4d", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 73, "deletions": 57, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -877,12 +877,14 @@ https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n \"##,\n \n E0383: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n This error occurs when an attempt is made to partially reinitialize a\n structure that is currently uninitialized.\n \n For example, this can happen when a drop has taken place:\n \n-```compile_fail,E0383\n+```compile_fail\n struct Foo {\n     a: u32,\n }\n@@ -966,10 +968,12 @@ y.set(2);\n \"##,*/\n \n E0387: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n This error occurs when an attempt is made to mutate or mutably reference data\n that a closure has captured immutably. Examples of this error are shown below:\n \n-```compile_fail,E0387\n+```compile_fail\n // Accepts a function or a closure that captures its environment immutably.\n // Closures passed to foo will not be able to mutate their closed-over state.\n fn foo<F: Fn()>(f: F) { }\n@@ -1026,13 +1030,15 @@ E0388 was removed and is no longer issued.\n \"##,\n \n E0389: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n An attempt was made to mutate data using a non-mutable reference. This\n commonly occurs when attempting to assign to a non-mutable reference of a\n mutable reference (`&(&mut T)`).\n \n Example of erroneous code:\n \n-```compile_fail,E0389\n+```compile_fail\n struct FancyNum {\n     num: u8,\n }\n@@ -1202,6 +1208,7 @@ A variable was borrowed as mutable more than once. Erroneous code example:\n let mut i = 0;\n let mut x = &mut i;\n let mut a = &mut i;\n+x;\n // error: cannot borrow `i` as mutable more than once at a time\n ```\n \n@@ -1220,35 +1227,33 @@ let mut i = 0;\n let a = &i; // ok!\n let b = &i; // still ok!\n let c = &i; // still ok!\n+b;\n+a;\n ```\n \"##,\n \n E0500: r##\"\n-A borrowed variable was used in another closure. Example of erroneous code:\n+A borrowed variable was used by a closure. Example of erroneous code:\n \n-```compile_fail\n+```compile_fail,E0500\n fn you_know_nothing(jon_snow: &mut i32) {\n-    let nights_watch = || {\n-        *jon_snow = 2;\n-    };\n+    let nights_watch = &jon_snow;\n     let starks = || {\n         *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n                        //        but it is already borrowed\n     };\n+    println!(\"{}\", nights_watch);\n }\n ```\n \n-In here, `jon_snow` is already borrowed by the `nights_watch` closure, so it\n+In here, `jon_snow` is already borrowed by the `nights_watch` reference, so it\n cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n-you can put the closure in its own scope:\n+you can create the closure after the borrow has ended:\n \n ```\n fn you_know_nothing(jon_snow: &mut i32) {\n-    {\n-        let nights_watch = || {\n-            *jon_snow = 2;\n-        };\n-    } // At this point, `jon_snow` is free.\n+    let nights_watch = &jon_snow;\n+    println!(\"{}\", nights_watch);\n     let starks = || {\n         *jon_snow = 3;\n     };\n@@ -1261,12 +1266,10 @@ closures:\n ```\n fn you_know_nothing(jon_snow: &mut i32) {\n     let mut jon_copy = jon_snow.clone();\n-    let nights_watch = || {\n-        jon_copy = 2;\n-    };\n     let starks = || {\n         *jon_snow = 3;\n     };\n+    println!(\"{}\", jon_copy);\n }\n ```\n \"##,\n@@ -1293,26 +1296,28 @@ fn outside_closure(x: &mut i32) {\n }\n \n fn foo(a: &mut i32) {\n-    let bar = || {\n+    let mut bar = || {\n         inside_closure(a)\n     };\n     outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n                         //        closure requires unique access.\n+    bar();\n }\n ```\n \n-To fix this error, you can place the closure in its own scope:\n+To fix this error, you can finish using the closure before using the captured\n+variable:\n \n ```\n fn inside_closure(x: &mut i32) {}\n fn outside_closure(x: &mut i32) {}\n \n fn foo(a: &mut i32) {\n-    {\n-        let bar = || {\n-            inside_closure(a)\n-        };\n-    } // borrow on `a` ends.\n+    let mut bar = || {\n+        inside_closure(a)\n+    };\n+    bar();\n+    // borrow on `a` ends.\n     outside_closure(a); // ok!\n }\n ```\n@@ -1324,7 +1329,7 @@ fn inside_closure(x: &mut i32) {}\n fn outside_closure(x: &mut i32) {}\n \n fn foo(a: &mut i32) {\n-    let bar = |s: &mut i32| {\n+    let mut bar = |s: &mut i32| {\n         inside_closure(s)\n     };\n     outside_closure(a);\n@@ -1340,9 +1345,10 @@ fn outside_closure(x: &mut i32) {}\n \n fn foo(a: &mut i32) {\n     outside_closure(a);\n-    let bar = || {\n+    let mut bar = || {\n         inside_closure(a)\n     };\n+    bar();\n }\n ```\n \"##,\n@@ -1359,6 +1365,7 @@ fn foo(a: &mut i32) {\n     let ref y = a; // a is borrowed as immutable.\n     bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n             //        as immutable\n+    println!(\"{}\", y);\n }\n ```\n \n@@ -1370,6 +1377,7 @@ fn bar(x: &mut i32) {}\n fn foo(a: &mut i32) {\n     bar(a);\n     let ref y = a; // ok!\n+    println!(\"{}\", y);\n }\n ```\n \n@@ -1385,28 +1393,26 @@ Example of erroneous code:\n ```compile_fail,E0503\n fn main() {\n     let mut value = 3;\n-    // Create a mutable borrow of `value`. This borrow\n-    // lives until the end of this function.\n-    let _borrow = &mut value;\n+    // Create a mutable borrow of `value`.\n+    let borrow = &mut value;\n     let _sum = value + 1; // error: cannot use `value` because\n                           //        it was mutably borrowed\n+    println!(\"{}\", borrow);\n }\n ```\n \n In this example, `value` is mutably borrowed by `borrow` and cannot be\n used to calculate `sum`. This is not possible because this would violate\n Rust's mutability rules.\n \n-You can fix this error by limiting the scope of the borrow:\n+You can fix this error by finishing using the borrow before the next use of\n+the value:\n \n ```\n fn main() {\n     let mut value = 3;\n-    // By creating a new block, you can limit the scope\n-    // of the reference.\n-    {\n-        let _borrow = &mut value; // Use `_borrow` inside this block.\n-    }\n+    let borrow = &mut value;\n+    println!(\"{}\", borrow);\n     // The block has ended and with it the borrow.\n     // You can now use `value` again.\n     let _sum = value + 1;\n@@ -1422,10 +1428,11 @@ fn main() {\n     let value_cloned = value.clone();\n     // The mutable borrow is a reference to `value` and\n     // not to `value_cloned`...\n-    let _borrow = &mut value;\n+    let borrow = &mut value;\n     // ... which means we can still use `value_cloned`,\n     let _sum = value_cloned + 1;\n     // even though the borrow only ends here.\n+    println!(\"{}\", borrow);\n }\n ```\n \n@@ -1434,12 +1441,14 @@ http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n \"##,\n \n E0504: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n This error occurs when an attempt is made to move a borrowed variable into a\n closure.\n \n Example of erroneous code:\n \n-```compile_fail,E0504\n+```compile_fail\n struct FancyNum {\n     num: u8,\n }\n@@ -1577,9 +1586,10 @@ fn eat(val: &Value) {}\n \n fn main() {\n     let x = Value{};\n-    let _ref_to_val: &Value = &x;\n+\n+    let ref_to_val: &Value = &x;\n     eat(&x); // pass by reference, if it's possible\n-    borrow(_ref_to_val);\n+    borrow(ref_to_val);\n }\n ```\n \n@@ -1594,11 +1604,11 @@ fn eat(val: Value) {}\n \n fn main() {\n     let x = Value{};\n-    {\n-        let _ref_to_val: &Value = &x;\n-        borrow(_ref_to_val);\n-    }\n-    eat(x); // release borrow and then move it.\n+\n+    let ref_to_val: &Value = &x;\n+    borrow(ref_to_val);\n+    // ref_to_val is no longer used.\n+    eat(x);\n }\n ```\n \n@@ -1614,9 +1624,9 @@ fn eat(val: Value) {}\n \n fn main() {\n     let x = Value{};\n-    let _ref_to_val: &Value = &x;\n+    let ref_to_val: &Value = &x;\n     eat(x); // it will be copied here.\n-    borrow(_ref_to_val);\n+    borrow(ref_to_val);\n }\n ```\n \n@@ -2053,11 +2063,13 @@ fn get_owned_iterator() -> IntoIter<i32> {\n \"##,\n \n E0595: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n Closures cannot mutate immutable captured variables.\n \n Erroneous code example:\n \n-```compile_fail,E0595\n+```compile_fail,E0594\n let x = 3; // error: closure cannot assign to immutable local variable `x`\n let mut c = || { x += 1 };\n ```\n@@ -2090,8 +2102,7 @@ let y = &mut x; // ok!\n \"##,\n \n E0597: r##\"\n-This error occurs because a borrow was made inside a variable which has a\n-greater lifetime than the borrowed one.\n+This error occurs because a value was dropped while it was still borrowed\n \n Example of erroneous code:\n \n@@ -2101,23 +2112,28 @@ struct Foo<'a> {\n }\n \n let mut x = Foo { x: None };\n-let y = 0;\n-x.x = Some(&y); // error: `y` does not live long enough\n+{\n+    let y = 0;\n+    x.x = Some(&y); // error: `y` does not live long enough\n+}\n+println!(\"{:?}\", x.x);\n ```\n \n-In here, `x` is created before `y` and therefore has a greater lifetime. Always\n-keep in mind that values in a scope are dropped in the opposite order they are\n-created. So to fix the previous example, just make the `y` lifetime greater than\n-the `x`'s one:\n+In here, `y` is dropped at the end of the inner scope, but it is borrowed by\n+`x` until the `println`. To fix the previous example, just remove the scope\n+so that `y` isn't dropped until after the println\n \n ```\n struct Foo<'a> {\n     x: Option<&'a u32>,\n }\n \n-let y = 0;\n let mut x = Foo { x: None };\n+\n+let y = 0;\n x.x = Some(&y);\n+\n+println!(\"{:?}\", x.x);\n ```\n \"##,\n "}, {"sha": "7bfb0a4475ec13bbecb91090672ea7f0fc2bf7d7", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -565,7 +565,7 @@ fn check_legality_of_move_bindings(\n             let mut err = struct_span_err!(cx.tcx.sess, p.span, E0008,\n                                            \"cannot bind by-move into a pattern guard\");\n             err.span_label(p.span, \"moves value into pattern guard\");\n-            if cx.tcx.sess.opts.unstable_features.is_nightly_build() && cx.tcx.use_mir_borrowck() {\n+            if cx.tcx.sess.opts.unstable_features.is_nightly_build() {\n                 err.help(\"add #![feature(bind_by_move_pattern_guards)] to the \\\n                           crate attributes to enable\");\n             }\n@@ -649,9 +649,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n                 let mut err = struct_span_err!(self.cx.tcx.sess, span, E0301,\n                           \"cannot mutably borrow in a pattern guard\");\n                 err.span_label(span, \"borrowed mutably in pattern guard\");\n-                if self.cx.tcx.sess.opts.unstable_features.is_nightly_build() &&\n-                    self.cx.tcx.use_mir_borrowck()\n-                {\n+                if self.cx.tcx.sess.opts.unstable_features.is_nightly_build() {\n                     err.help(\"add #![feature(bind_by_move_pattern_guards)] to the \\\n                               crate attributes to enable\");\n                 }"}, {"sha": "e334e27cc855663e12527bb4a009c0e78ac4c347", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -40,7 +40,7 @@ impl Origin {\n     pub fn should_emit_errors(self, mode: BorrowckMode) -> bool {\n         match self {\n             Origin::Ast => mode.use_ast(),\n-            Origin::Mir => mode.use_mir(),\n+            Origin::Mir => true,\n         }\n     }\n }"}, {"sha": "ba567a123aec12a5e8a63b3ed02d2612c6fae7b7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa6fb6caf9d8456c70144ccba1e969c85926e229/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=aa6fb6caf9d8456c70144ccba1e969c85926e229", "patch": "@@ -445,9 +445,7 @@ declare_features! (\n     (active, custom_inner_attributes, \"1.30.0\", Some(54726), None),\n \n     // Allow mixing of bind-by-move in patterns and references to\n-    // those identifiers in guards, *if* we are using MIR-borrowck\n-    // (aka NLL). Essentially this means you need to be using the\n-    // 2018 edition or later.\n+    // those identifiers in guards.\n     (active, bind_by_move_pattern_guards, \"1.30.0\", Some(15287), None),\n \n     // Allows `impl Trait` in bindings (`let`, `const`, `static`)."}]}