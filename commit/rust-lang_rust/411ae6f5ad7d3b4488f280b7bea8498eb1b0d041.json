{"sha": "411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "node_id": "C_kwDOAAsO6NoAKDQxMWFlNmY1YWQ3ZDNiNDQ4OGYyODBiN2JlYTg0OThlYjFiMGQwNDE", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-03-27T00:46:56Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-11T19:22:32Z"}, "message": "Address various comments and change some details around place to value conversions", "tree": {"sha": "9178040eb5dd4be7717d74564fcb86a06f2edcab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9178040eb5dd4be7717d74564fcb86a06f2edcab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "html_url": "https://github.com/rust-lang/rust/commit/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d318e42e75b959a45be28efcc5069408c228714", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d318e42e75b959a45be28efcc5069408c228714", "html_url": "https://github.com/rust-lang/rust/commit/1d318e42e75b959a45be28efcc5069408c228714"}], "stats": {"total": 73, "additions": 37, "deletions": 36}, "files": [{"sha": "f153c613f8c51f0f1f0aadebb69a7047ffcd1b9c", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "patch": "@@ -697,7 +697,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             TerminatorKind::Resume | TerminatorKind::Abort => {\n                 let bb = location.block;\n                 if !self.body.basic_blocks()[bb].is_cleanup {\n-                    self.fail(location, \"Cannot `Resume` from non-cleanup basic block\")\n+                    self.fail(location, \"Cannot `Resume` or `Abort` from non-cleanup basic block\")\n                 }\n             }\n             TerminatorKind::Return => {"}, {"sha": "0fd83942f20a44ed1a6c4b0a248badf1128d777a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "patch": "@@ -1653,16 +1653,15 @@ pub enum StatementKind<'tcx> {\n     /// statements are not required. If the entire MIR body contains no `StorageLive`/`StorageDead`\n     /// statements for a particular local, the local is always considered live.\n     ///\n-    /// More precisely, the MIR validator currently does a `MaybeLiveLocals` analysis to check\n-    /// validity of each use of a local. I believe this is equivalent to requiring for every use of\n-    /// a local, there exist at least one path from the root to that use that contains a\n+    /// More precisely, the MIR validator currently does a `MaybeStorageLiveLocals` analysis to\n+    /// check validity of each use of a local. I believe this is equivalent to requiring for every\n+    /// use of a local, there exist at least one path from the root to that use that contains a\n     /// `StorageLive` more recently than a `StorageDead`.\n     ///\n-    /// **Needs clarification**: Is it permitted to `StorageLive` a local for which we previously\n-    /// executed `StorageDead`? How about two `StorageLive`s without an intervening `StorageDead`?\n-    /// Two `StorageDead`s without an intervening `StorageLive`? LLVM says yes, poison, yes. If the\n-    /// answer to any of these is \"no,\" is breaking that rule UB or is it an error to have a path in\n-    /// the CFG that might do this?\n+    /// **Needs clarification**: Is it permitted to have two `StorageLive`s without an intervening\n+    /// `StorageDead`? Two `StorageDead`s without an intervening `StorageLive`? LLVM says poison,\n+    /// yes. If the answer to any of these is \"no,\" is breaking that rule UB or is it an error to\n+    /// have a path in the CFG that might do this?\n     StorageLive(Local),\n \n     /// See `StorageLive` above.\n@@ -1675,7 +1674,7 @@ pub enum StatementKind<'tcx> {\n     /// <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/> for\n     /// more details.\n     ///\n-    /// For code that is not specific to stacked borrows, you should consider statements to read\n+    /// For code that is not specific to stacked borrows, you should consider retags to read\n     /// and modify the place in an opaque way.\n     Retag(RetagKind, Box<Place<'tcx>>),\n \n@@ -1704,7 +1703,7 @@ pub enum StatementKind<'tcx> {\n     /// executed.\n     Coverage(Box<Coverage>),\n \n-    /// Denotes a call to the intrinsic function `copy_overlapping`.\n+    /// Denotes a call to the intrinsic function `copy_nonoverlapping`.\n     ///\n     /// First, all three operands are evaluated. `src` and `dest` must each be a reference, pointer,\n     /// or `Box` pointing to the same type `T`. `count` must evaluate to a `usize`. Then, `src` and\n@@ -1919,7 +1918,7 @@ pub struct CopyNonOverlapping<'tcx> {\n /// **Needs clarification**: What about metadata resulting from dereferencing wide pointers (and\n /// possibly from accessing unsized locals - not sure how those work)? That probably deserves to go\n /// on the list above and be discussed too. It is also probably necessary for making the indexing\n-/// stuff lass hand-wavey.\n+/// stuff less hand-wavey.\n ///\n /// **Needs clarification**: When it says \"part of memory\" what does that mean precisely, and how\n /// does it interact with the metadata?\n@@ -2334,13 +2333,13 @@ pub struct SourceScopeLocalData {\n ///\n /// The most common way to create values is via a place to value conversion. A place to value\n /// conversion is an operation which reads the memory of the place and converts it to a value. This\n-/// is a fundamentally *typed* operation. Different types will do different things. These are some\n-/// possible examples of what Rust may - but will not necessarily - decide to do on place to value\n-/// conversions:\n+/// is a fundamentally *typed* operation. The nature of the value produced depends on the type of\n+/// the conversion. Furthermore, there may be other effects: if the type has a validity constraint\n+/// the place to value conversion might be UB if the validity constraint is not met.\n ///\n-///  1. Types with validity constraints cause UB if the validity constraint is not met\n-///  2. References/pointers may have their provenance change or cause other provenance related\n-///     side-effects.\n+/// **Needs clarification:** Ralf proposes that place to value conversions not have side-effects.\n+/// This is what is implemented in miri today. Are these the semantics we want for MIR? Is this\n+/// something we can even decide without knowing more about Rust's memory model?\n ///\n /// A place to value conversion on a place that has its variant index set is not well-formed.\n /// However, note that this rule only applies to places appearing in MIR bodies. Many functions,\n@@ -2472,15 +2471,17 @@ impl<'tcx> Operand<'tcx> {\n ///\n /// Not all of these are allowed at every [`MirPhase`] - when this is the case, it's stated below.\n ///\n-/// Computing any rvalue begins by evaluating the places and operands in the rvalue in the order in\n-/// which they appear. These are then used to produce a \"value\" - the same kind of value that an\n-/// [`Operand`] is.\n+/// Computing any rvalue begins by evaluating the places and operands in some order (**Needs\n+/// clarification**: Which order?). These are then used to produce a \"value\" - the same kind of\n+/// value that an [`Operand`] is.\n pub enum Rvalue<'tcx> {\n     /// Yields the operand unchanged\n     Use(Operand<'tcx>),\n \n-    /// Creates an array where each element is the value of the operand. This currently does not\n-    /// drop the value even if the number of repetitions is zero, see [#74836].\n+    /// Creates an array where each element is the value of the operand.\n+    ///\n+    /// This is the cause of a bug in the case where the repetition count is zero because the value\n+    /// is not dropped, see [#74836].\n     ///\n     /// Corresponds to source code like `[x; 32]`.\n     ///\n@@ -2534,12 +2535,12 @@ pub enum Rvalue<'tcx> {\n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n \n     /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n-    ///   paramter may be a `usize` as well.\n+    ///   parameter may be a `usize` as well.\n     /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n     ///   raw pointers, or function pointers and return a `bool`.\n     /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n     ///   same type and return a value of the same type as their LHS. For all other operations, the\n-    ///   types of the operands must match.\n+    ///   types of the operands must match. Like in Rust, the RHS is truncated as needed.\n     /// * The `Bit*` operations accept signed integers, unsigned integers, or bools and return a\n     ///   value of that type.\n     /// * The remaining operations accept signed integers, unsigned integers, or floats of any\n@@ -2548,21 +2549,19 @@ pub enum Rvalue<'tcx> {\n \n     /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the\n     /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be\n-    /// unequal to the actual result and sets the `bool` if this is the case. `BinOp::Offset` is not\n-    /// allowed here.\n+    /// unequal to the actual result and sets the `bool` if this is the case.\n     ///\n-    /// **FIXME**: What about division/modulo? Are they allowed here at all? Are zero divisors still\n-    /// UB? Also, which other combinations of types are disallowed?\n+    /// This only supports addition, subtraction, multiplication, and shift operations.\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n \n-    /// Yields the size or alignment of the type as a `usize`.\n+    /// Computes a value as described by the operation.\n     NullaryOp(NullOp, Ty<'tcx>),\n \n     /// Exactly like `BinaryOp`, but less operands.\n     ///\n-    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float; binary\n-    /// not requires a signed integer, unsigned integer, or bool. Both operation kinds return a\n-    /// value with the same type as their operand.\n+    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;\n+    /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds\n+    /// return a value with the same type as their operand.\n     UnaryOp(UnOp, Operand<'tcx>),\n \n     /// Computes the discriminant of the place, returning it as an integer of type"}, {"sha": "cc08857463d5869301f8831865d10654fa01b573", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/411ae6f5ad7d3b4488f280b7bea8498eb1b0d041/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=411ae6f5ad7d3b4488f280b7bea8498eb1b0d041", "patch": "@@ -234,10 +234,12 @@ pub enum TerminatorKind<'tcx> {\n \n     /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n     /// the referred to function. The operand types must match the argument types of the function.\n-    /// The return place type must exactly match the return type. The type of the `func` operand\n-    /// must be callable, meaning either a function pointer, a function type, or a closure type.\n+    /// The return place type must match the return type. The type of the `func` operand must be\n+    /// callable, meaning either a function pointer, a function type, or a closure type.\n     ///\n-    /// **Needs clarification**: The exact semantics of this, see [#71117].\n+    /// **Needs clarification**: The exact semantics of this. Current backends rely on `move`\n+    /// operands not aliasing the return place. It is unclear how this is justified in MIR, see\n+    /// [#71117].\n     ///\n     /// [#71117]: https://github.com/rust-lang/rust/issues/71117\n     Call {"}]}