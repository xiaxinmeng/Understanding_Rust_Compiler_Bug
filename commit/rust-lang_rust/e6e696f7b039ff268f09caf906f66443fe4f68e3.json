{"sha": "e6e696f7b039ff268f09caf906f66443fe4f68e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZTY5NmY3YjAzOWZmMjY4ZjA5Y2FmOTA2ZjY2NDQzZmU0ZjY4ZTM=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-09-04T16:04:08Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-09-04T16:04:08Z"}, "message": "Avoid cloning String", "tree": {"sha": "4fbe83a7910675ef922f8de8b6cc30e8484599dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fbe83a7910675ef922f8de8b6cc30e8484599dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6e696f7b039ff268f09caf906f66443fe4f68e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e696f7b039ff268f09caf906f66443fe4f68e3", "html_url": "https://github.com/rust-lang/rust/commit/e6e696f7b039ff268f09caf906f66443fe4f68e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6e696f7b039ff268f09caf906f66443fe4f68e3/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f3d92506ac88a8320bfe5ec46a6d85f8d7aa3bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f3d92506ac88a8320bfe5ec46a6d85f8d7aa3bc", "html_url": "https://github.com/rust-lang/rust/commit/3f3d92506ac88a8320bfe5ec46a6d85f8d7aa3bc"}], "stats": {"total": 76, "additions": 48, "deletions": 28}, "files": [{"sha": "79a178dd363be926596acbb64ce435a969f6c2df", "filename": "src/items.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e6e696f7b039ff268f09caf906f66443fe4f68e3/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e696f7b039ff268f09caf906f66443fe4f68e3/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=e6e696f7b039ff268f09caf906f66443fe4f68e3", "patch": "@@ -2313,35 +2313,45 @@ fn rewrite_generics_inner(\n ) -> Option<String> {\n     // FIXME: convert bounds to where clauses where they get too big or if\n     // there is a where clause at all.\n-    let lifetimes: &[_] = &generics.lifetimes;\n-    let tys: &[_] = &generics.ty_params;\n-    if lifetimes.is_empty() && tys.is_empty() {\n-        return Some(String::new());\n-    }\n \n-    // Strings for the generics.\n-    let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(context, shape));\n-    let ty_strs = tys.iter().map(|ty_param| ty_param.rewrite(context, shape));\n+    // Wrapper type\n+    enum GenericsArg<'a> {\n+        Lifetime(&'a ast::LifetimeDef),\n+        TyParam(&'a ast::TyParam),\n+    }\n+    impl<'a> Rewrite for GenericsArg<'a> {\n+        fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+            match *self {\n+                GenericsArg::Lifetime(ref lifetime) => lifetime.rewrite(context, shape),\n+                GenericsArg::TyParam(ref ty) => ty.rewrite(context, shape),\n+            }\n+        }\n+    }\n+    impl<'a> Spanned for GenericsArg<'a> {\n+        fn span(&self) -> Span {\n+            match *self {\n+                GenericsArg::Lifetime(ref lifetime) => lifetime.span(),\n+                GenericsArg::TyParam(ref ty) => ty.span(),\n+            }\n+        }\n+    }\n \n-    // Extract comments between generics.\n-    let lt_spans = lifetimes.iter().map(|l| {\n-        let hi = if l.bounds.is_empty() {\n-            l.lifetime.span.hi()\n-        } else {\n-            l.bounds[l.bounds.len() - 1].span.hi()\n-        };\n-        mk_sp(l.lifetime.span.lo(), hi)\n-    });\n-    let ty_spans = tys.iter().map(|ty| ty.span());\n+    if generics.lifetimes.is_empty() && generics.ty_params.is_empty() {\n+        return Some(String::new());\n+    }\n \n+    let generics_args = generics\n+        .lifetimes\n+        .iter()\n+        .map(|lt| GenericsArg::Lifetime(lt))\n+        .chain(generics.ty_params.iter().map(|ty| GenericsArg::TyParam(ty)));\n     let items = itemize_list(\n         context.codemap,\n-        lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n+        generics_args,\n         \">\",\n-        |&(sp, _)| sp.lo(),\n-        |&(sp, _)| sp.hi(),\n-        // FIXME: don't clone\n-        |&(_, ref str)| str.clone(),\n+        |arg| arg.span().lo(),\n+        |arg| arg.span().hi(),\n+        |arg| arg.rewrite(context, shape),\n         context.codemap.span_after(span, \"<\"),\n         span.hi(),\n         false,"}, {"sha": "ee231e2e63c5b832e620681ac43ebfa0ce56af10", "filename": "src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e6e696f7b039ff268f09caf906f66443fe4f68e3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e696f7b039ff268f09caf906f66443fe4f68e3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e6e696f7b039ff268f09caf906f66443fe4f68e3", "patch": "@@ -217,6 +217,17 @@ impl Spanned for ast::TyParamBound {\n     }\n }\n \n+impl Spanned for ast::LifetimeDef {\n+    fn span(&self) -> Span {\n+        let hi = if self.bounds.is_empty() {\n+            self.lifetime.span.hi()\n+        } else {\n+            self.bounds[self.bounds.len() - 1].span.hi()\n+        };\n+        mk_sp(self.lifetime.span.lo(), hi)\n+    }\n+}\n+\n impl Spanned for MacroArg {\n     fn span(&self) -> Span {\n         match *self {"}, {"sha": "ceca0417aa8ef79c60676680fbc109076bda2de1", "filename": "src/types.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6e696f7b039ff268f09caf906f66443fe4f68e3/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e696f7b039ff268f09caf906f66443fe4f68e3/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=e6e696f7b039ff268f09caf906f66443fe4f68e3", "patch": "@@ -584,11 +584,10 @@ impl Rewrite for ast::TyParam {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let mut result = String::with_capacity(128);\n         // FIXME: If there are more than one attributes, this will force multiline.\n-        let attr_str = match (&*self.attrs).rewrite(context, shape) {\n-            Some(ref rw) if !rw.is_empty() => format!(\"{} \", rw),\n-            _ => String::new(),\n-        };\n-        result.push_str(&attr_str);\n+        match self.attrs.rewrite(context, shape) {\n+            Some(ref rw) if !rw.is_empty() => result.push_str(&format!(\"{} \", rw)),\n+            _ => (),\n+        }\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n             result.push_str(type_bound_colon(context));"}]}