{"sha": "e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0NTBkY2FmOGUxZjZjMWE0YjY0ZDNkMzE2MGNmNmVmNTc0M2NjYjc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T13:01:38Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T18:24:42Z"}, "message": "lowering: move lower_await -> expr.rs", "tree": {"sha": "540e75851e8fc037f707a7b5beb4f81b6a34895b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/540e75851e8fc037f707a7b5beb4f81b6a34895b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7", "html_url": "https://github.com/rust-lang/rust/commit/e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "548e3090c20c3353ac6f9b749315d885211ab699", "url": "https://api.github.com/repos/rust-lang/rust/commits/548e3090c20c3353ac6f9b749315d885211ab699", "html_url": "https://github.com/rust-lang/rust/commit/548e3090c20c3353ac6f9b749315d885211ab699"}], "stats": {"total": 323, "additions": 160, "deletions": 163}, "files": [{"sha": "5793dc019c37bd59e110f6773f6d2c4fca9dcd3c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7", "patch": "@@ -5125,168 +5125,6 @@ impl<'a> LoweringContext<'a> {\n                                             ThinVec::new()));\n         P(self.expr_call(e.span, from_err, hir_vec![e]))\n     }\n-\n-    fn lower_await(\n-        &mut self,\n-        await_span: Span,\n-        expr: &ast::Expr,\n-    ) -> hir::ExprKind {\n-        // to:\n-        //\n-        // {\n-        //     let mut pinned = <expr>;\n-        //     loop {\n-        //         match ::std::future::poll_with_tls_context(unsafe {\n-        //             ::std::pin::Pin::new_unchecked(&mut pinned)\n-        //         }) {\n-        //             ::std::task::Poll::Ready(result) => break result,\n-        //             ::std::task::Poll::Pending => {},\n-        //         }\n-        //         yield ();\n-        //     }\n-        // }\n-        match self.generator_kind {\n-            Some(hir::GeneratorKind::Async) => {},\n-            Some(hir::GeneratorKind::Gen) |\n-            None => {\n-                let mut err = struct_span_err!(\n-                    self.sess,\n-                    await_span,\n-                    E0728,\n-                    \"`await` is only allowed inside `async` functions and blocks\"\n-                );\n-                err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n-                if let Some(item_sp) = self.current_item {\n-                    err.span_label(item_sp, \"this is not `async`\");\n-                }\n-                err.emit();\n-            }\n-        }\n-        let span = self.mark_span_with_reason(\n-            DesugaringKind::Await,\n-            await_span,\n-            None,\n-        );\n-        let gen_future_span = self.mark_span_with_reason(\n-            DesugaringKind::Await,\n-            await_span,\n-            self.allow_gen_future.clone(),\n-        );\n-\n-        // let mut pinned = <expr>;\n-        let expr = P(self.lower_expr(expr));\n-        let pinned_ident = Ident::with_empty_ctxt(sym::pinned);\n-        let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n-            span,\n-            pinned_ident,\n-            hir::BindingAnnotation::Mutable,\n-        );\n-        let pinned_let = self.stmt_let_pat(\n-            ThinVec::new(),\n-            span,\n-            Some(expr),\n-            pinned_pat,\n-            hir::LocalSource::AwaitDesugar,\n-        );\n-\n-        // ::std::future::poll_with_tls_context(unsafe {\n-        //     ::std::pin::Pin::new_unchecked(&mut pinned)\n-        // })`\n-        let poll_expr = {\n-            let pinned = P(self.expr_ident(span, pinned_ident, pinned_pat_hid));\n-            let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n-            let pin_ty_id = self.next_id();\n-            let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n-                pin_ty_id,\n-                span,\n-                &[sym::pin, sym::Pin],\n-                \"new_unchecked\",\n-                hir_vec![ref_mut_pinned],\n-            );\n-            let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n-            let unsafe_expr = self.expr_unsafe(new_unchecked);\n-            P(self.expr_call_std_path(\n-                gen_future_span,\n-                &[sym::future, sym::poll_with_tls_context],\n-                hir_vec![unsafe_expr],\n-            ))\n-        };\n-\n-        // `::std::task::Poll::Ready(result) => break result`\n-        let loop_node_id = self.sess.next_node_id();\n-        let loop_hir_id = self.lower_node_id(loop_node_id);\n-        let ready_arm = {\n-            let x_ident = Ident::with_empty_ctxt(sym::result);\n-            let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n-            let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n-            let ready_pat = self.pat_std_enum(\n-                span,\n-                &[sym::task, sym::Poll, sym::Ready],\n-                hir_vec![x_pat],\n-            );\n-            let break_x = self.with_loop_scope(loop_node_id, |this| {\n-                let expr_break = hir::ExprKind::Break(\n-                    this.lower_loop_destination(None),\n-                    Some(x_expr),\n-                );\n-                P(this.expr(await_span, expr_break, ThinVec::new()))\n-            });\n-            self.arm(hir_vec![ready_pat], break_x)\n-        };\n-\n-        // `::std::task::Poll::Pending => {}`\n-        let pending_arm = {\n-            let pending_pat = self.pat_std_enum(\n-                span,\n-                &[sym::task, sym::Poll, sym::Pending],\n-                hir_vec![],\n-            );\n-            let empty_block = P(self.expr_block_empty(span));\n-            self.arm(hir_vec![pending_pat], empty_block)\n-        };\n-\n-        let match_stmt = {\n-            let match_expr = self.expr_match(\n-                span,\n-                poll_expr,\n-                hir_vec![ready_arm, pending_arm],\n-                hir::MatchSource::AwaitDesugar,\n-            );\n-            self.stmt_expr(span, match_expr)\n-        };\n-\n-        let yield_stmt = {\n-            let unit = self.expr_unit(span);\n-            let yield_expr = self.expr(\n-                span,\n-                hir::ExprKind::Yield(P(unit), hir::YieldSource::Await),\n-                ThinVec::new(),\n-            );\n-            self.stmt_expr(span, yield_expr)\n-        };\n-\n-        let loop_block = P(self.block_all(\n-            span,\n-            hir_vec![match_stmt, yield_stmt],\n-            None,\n-        ));\n-\n-        let loop_expr = P(hir::Expr {\n-            hir_id: loop_hir_id,\n-            node: hir::ExprKind::Loop(\n-                loop_block,\n-                None,\n-                hir::LoopSource::Loop,\n-            ),\n-            span,\n-            attrs: ThinVec::new(),\n-        });\n-\n-        hir::ExprKind::Block(\n-            P(self.block_all(span, hir_vec![pinned_let], Some(loop_expr))),\n-            None,\n-        )\n-    }\n }\n \n fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {"}, {"sha": "2ac8889e0040f3a3e386a32da1b9af7aa2b04512", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 160, "deletions": 1, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=e450dcaf8e1f6c1a4b64d3d3160cf6ef5743ccb7", "patch": "@@ -263,7 +263,7 @@ impl LoweringContext<'_> {\n                     })\n                 })\n             }\n-            ExprKind::Await(ref expr) => self.lower_await(e.span, expr),\n+            ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n             ExprKind::Closure(\n                 capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => if let IsAsync::Async { closure_id, .. } = asyncness {\n@@ -375,6 +375,165 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    /// Desugar `<expr>.await` into:\n+    /// ```rust\n+    /// {\n+    ///     let mut pinned = <expr>;\n+    ///     loop {\n+    ///         match ::std::future::poll_with_tls_context(unsafe {\n+    ///             ::std::pin::Pin::new_unchecked(&mut pinned)\n+    ///         }) {\n+    ///             ::std::task::Poll::Ready(result) => break result,\n+    ///             ::std::task::Poll::Pending => {},\n+    ///         }\n+    ///         yield ();\n+    ///     }\n+    /// }\n+    /// ```\n+    fn lower_expr_await(&mut self, await_span: Span, expr: &Expr) -> hir::ExprKind {\n+        match self.generator_kind {\n+            Some(hir::GeneratorKind::Async) => {},\n+            Some(hir::GeneratorKind::Gen) |\n+            None => {\n+                let mut err = struct_span_err!(\n+                    self.sess,\n+                    await_span,\n+                    E0728,\n+                    \"`await` is only allowed inside `async` functions and blocks\"\n+                );\n+                err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+                if let Some(item_sp) = self.current_item {\n+                    err.span_label(item_sp, \"this is not `async`\");\n+                }\n+                err.emit();\n+            }\n+        }\n+        let span = self.mark_span_with_reason(\n+            DesugaringKind::Await,\n+            await_span,\n+            None,\n+        );\n+        let gen_future_span = self.mark_span_with_reason(\n+            DesugaringKind::Await,\n+            await_span,\n+            self.allow_gen_future.clone(),\n+        );\n+\n+        // let mut pinned = <expr>;\n+        let expr = P(self.lower_expr(expr));\n+        let pinned_ident = Ident::with_empty_ctxt(sym::pinned);\n+        let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n+            span,\n+            pinned_ident,\n+            hir::BindingAnnotation::Mutable,\n+        );\n+        let pinned_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            span,\n+            Some(expr),\n+            pinned_pat,\n+            hir::LocalSource::AwaitDesugar,\n+        );\n+\n+        // ::std::future::poll_with_tls_context(unsafe {\n+        //     ::std::pin::Pin::new_unchecked(&mut pinned)\n+        // })`\n+        let poll_expr = {\n+            let pinned = P(self.expr_ident(span, pinned_ident, pinned_pat_hid));\n+            let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n+            let pin_ty_id = self.next_id();\n+            let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n+                pin_ty_id,\n+                span,\n+                &[sym::pin, sym::Pin],\n+                \"new_unchecked\",\n+                hir_vec![ref_mut_pinned],\n+            );\n+            let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n+            let unsafe_expr = self.expr_unsafe(new_unchecked);\n+            P(self.expr_call_std_path(\n+                gen_future_span,\n+                &[sym::future, sym::poll_with_tls_context],\n+                hir_vec![unsafe_expr],\n+            ))\n+        };\n+\n+        // `::std::task::Poll::Ready(result) => break result`\n+        let loop_node_id = self.sess.next_node_id();\n+        let loop_hir_id = self.lower_node_id(loop_node_id);\n+        let ready_arm = {\n+            let x_ident = Ident::with_empty_ctxt(sym::result);\n+            let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n+            let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n+            let ready_pat = self.pat_std_enum(\n+                span,\n+                &[sym::task, sym::Poll, sym::Ready],\n+                hir_vec![x_pat],\n+            );\n+            let break_x = self.with_loop_scope(loop_node_id, |this| {\n+                let expr_break = hir::ExprKind::Break(\n+                    this.lower_loop_destination(None),\n+                    Some(x_expr),\n+                );\n+                P(this.expr(await_span, expr_break, ThinVec::new()))\n+            });\n+            self.arm(hir_vec![ready_pat], break_x)\n+        };\n+\n+        // `::std::task::Poll::Pending => {}`\n+        let pending_arm = {\n+            let pending_pat = self.pat_std_enum(\n+                span,\n+                &[sym::task, sym::Poll, sym::Pending],\n+                hir_vec![],\n+            );\n+            let empty_block = P(self.expr_block_empty(span));\n+            self.arm(hir_vec![pending_pat], empty_block)\n+        };\n+\n+        let match_stmt = {\n+            let match_expr = self.expr_match(\n+                span,\n+                poll_expr,\n+                hir_vec![ready_arm, pending_arm],\n+                hir::MatchSource::AwaitDesugar,\n+            );\n+            self.stmt_expr(span, match_expr)\n+        };\n+\n+        let yield_stmt = {\n+            let unit = self.expr_unit(span);\n+            let yield_expr = self.expr(\n+                span,\n+                hir::ExprKind::Yield(P(unit), hir::YieldSource::Await),\n+                ThinVec::new(),\n+            );\n+            self.stmt_expr(span, yield_expr)\n+        };\n+\n+        let loop_block = P(self.block_all(\n+            span,\n+            hir_vec![match_stmt, yield_stmt],\n+            None,\n+        ));\n+\n+        let loop_expr = P(hir::Expr {\n+            hir_id: loop_hir_id,\n+            node: hir::ExprKind::Loop(\n+                loop_block,\n+                None,\n+                hir::LoopSource::Loop,\n+            ),\n+            span,\n+            attrs: ThinVec::new(),\n+        });\n+\n+        hir::ExprKind::Block(\n+            P(self.block_all(span, hir_vec![pinned_let], Some(loop_expr))),\n+            None,\n+        )\n+    }\n+\n     fn lower_expr_closure(\n         &mut self,\n         capture_clause: CaptureBy,"}]}