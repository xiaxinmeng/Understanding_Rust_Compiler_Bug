{"sha": "4d768bede000a01f9b8acfc8df80df3f6bb3f853", "node_id": "C_kwDOAAsO6NoAKDRkNzY4YmVkZTAwMGEwMWY5YjhhY2ZjOGRmODBkZjNmNmJiM2Y4NTM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-05T15:02:56Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-05T15:03:45Z"}, "message": "Short-circuit descend_into_macros_single", "tree": {"sha": "b7d3e9ed400ab8b4135d4d5da5bb738333064a66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7d3e9ed400ab8b4135d4d5da5bb738333064a66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d768bede000a01f9b8acfc8df80df3f6bb3f853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d768bede000a01f9b8acfc8df80df3f6bb3f853", "html_url": "https://github.com/rust-lang/rust/commit/4d768bede000a01f9b8acfc8df80df3f6bb3f853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d768bede000a01f9b8acfc8df80df3f6bb3f853/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "addd93ed9a63ed12027922dd16c0cb968caf969a", "url": "https://api.github.com/repos/rust-lang/rust/commits/addd93ed9a63ed12027922dd16c0cb968caf969a", "html_url": "https://github.com/rust-lang/rust/commit/addd93ed9a63ed12027922dd16c0cb968caf969a"}], "stats": {"total": 84, "additions": 57, "deletions": 27}, "files": [{"sha": "0f63de9e725c2533395b93c095bbe271aa7cf97d", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4d768bede000a01f9b8acfc8df80df3f6bb3f853/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d768bede000a01f9b8acfc8df80df3f6bb3f853/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=4d768bede000a01f9b8acfc8df80df3f6bb3f853", "patch": "@@ -178,10 +178,12 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.speculative_expand_attr(actual_macro_call, speculative_args, token_to_map)\n     }\n \n+    /// Descend the token into macrocalls to its first mapped counterpart.\n     pub fn descend_into_macros_single(&self, token: SyntaxToken) -> SyntaxToken {\n-        self.imp.descend_into_macros(token).pop().unwrap()\n+        self.imp.descend_into_macros_single(token)\n     }\n \n+    /// Descend the token into macrocalls to all its mapped counterparts.\n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SmallVec<[SyntaxToken; 1]> {\n         self.imp.descend_into_macros(token)\n     }\n@@ -509,47 +511,70 @@ impl<'db> SemanticsImpl<'db> {\n         };\n \n         if first == last {\n-            self.descend_into_macros_impl(first, |InFile { value, .. }| {\n-                if let Some(node) = value.ancestors().find_map(N::cast) {\n-                    res.push(node)\n-                }\n-            });\n+            self.descend_into_macros_impl(\n+                first,\n+                |InFile { value, .. }| {\n+                    if let Some(node) = value.ancestors().find_map(N::cast) {\n+                        res.push(node)\n+                    }\n+                },\n+                false,\n+            );\n         } else {\n             // Descend first and last token, then zip them to look for the node they belong to\n             let mut scratch: SmallVec<[_; 1]> = smallvec![];\n-            self.descend_into_macros_impl(first, |token| {\n-                scratch.push(token);\n-            });\n+            self.descend_into_macros_impl(\n+                first,\n+                |token| {\n+                    scratch.push(token);\n+                },\n+                false,\n+            );\n \n             let mut scratch = scratch.into_iter();\n-            self.descend_into_macros_impl(last, |InFile { value: last, file_id: last_fid }| {\n-                if let Some(InFile { value: first, file_id: first_fid }) = scratch.next() {\n-                    if first_fid == last_fid {\n-                        if let Some(p) = first.parent() {\n-                            let range = first.text_range().cover(last.text_range());\n-                            let node = find_root(&p)\n-                                .covering_element(range)\n-                                .ancestors()\n-                                .take_while(|it| it.text_range() == range)\n-                                .find_map(N::cast);\n-                            if let Some(node) = node {\n-                                res.push(node);\n+            self.descend_into_macros_impl(\n+                last,\n+                |InFile { value: last, file_id: last_fid }| {\n+                    if let Some(InFile { value: first, file_id: first_fid }) = scratch.next() {\n+                        if first_fid == last_fid {\n+                            if let Some(p) = first.parent() {\n+                                let range = first.text_range().cover(last.text_range());\n+                                let node = find_root(&p)\n+                                    .covering_element(range)\n+                                    .ancestors()\n+                                    .take_while(|it| it.text_range() == range)\n+                                    .find_map(N::cast);\n+                                if let Some(node) = node {\n+                                    res.push(node);\n+                                }\n                             }\n                         }\n                     }\n-                }\n-            });\n+                },\n+                false,\n+            );\n         }\n         res\n     }\n \n     fn descend_into_macros(&self, token: SyntaxToken) -> SmallVec<[SyntaxToken; 1]> {\n         let mut res = smallvec![];\n-        self.descend_into_macros_impl(token, |InFile { value, .. }| res.push(value));\n+        self.descend_into_macros_impl(token, |InFile { value, .. }| res.push(value), false);\n+        res\n+    }\n+\n+    fn descend_into_macros_single(&self, token: SyntaxToken) -> SyntaxToken {\n+        let mut res = token.clone();\n+        self.descend_into_macros_impl(token, |InFile { value, .. }| res = value, true);\n         res\n     }\n \n-    fn descend_into_macros_impl(&self, token: SyntaxToken, mut f: impl FnMut(InFile<SyntaxToken>)) {\n+    fn descend_into_macros_impl(\n+        &self,\n+        token: SyntaxToken,\n+        mut f: impl FnMut(InFile<SyntaxToken>),\n+        single: bool,\n+    ) {\n         let _p = profile::span(\"descend_into_macros\");\n         let parent = match token.parent() {\n             Some(it) => it,\n@@ -572,11 +597,16 @@ impl<'db> SemanticsImpl<'db> {\n                     self.cache(value, file_id);\n                 }\n \n-                let mapped_tokens = expansion_info.map_token_down(self.db.upcast(), item, token)?;\n+                let mut mapped_tokens =\n+                    expansion_info.map_token_down(self.db.upcast(), item, token)?;\n \n                 let len = stack.len();\n                 // requeue the tokens we got from mapping our current token down\n-                stack.extend(mapped_tokens);\n+                if single {\n+                    stack.extend(mapped_tokens.next());\n+                } else {\n+                    stack.extend(mapped_tokens);\n+                }\n                 // if the length changed we have found a mapping for the token\n                 (stack.len() != len).then(|| ())\n             };"}]}