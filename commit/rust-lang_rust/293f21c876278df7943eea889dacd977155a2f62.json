{"sha": "293f21c876278df7943eea889dacd977155a2f62", "node_id": "C_kwDOAAsO6NoAKDI5M2YyMWM4NzYyNzhkZjc5NDNlZWE4ODlkYWNkOTc3MTU1YTJmNjI", "commit": {"author": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-03-21T00:09:00Z"}, "committer": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-03-21T22:53:58Z"}, "message": "iat selection: erase regions in self type", "tree": {"sha": "f38e5c6d98ea8e2d6d96dfde3f6819aa5530ea59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f38e5c6d98ea8e2d6d96dfde3f6819aa5530ea59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/293f21c876278df7943eea889dacd977155a2f62", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXSQFaHGAjVoD5I3F0XoHIV9o5xMFAmQaNYgACgkQ0XoHIV9o\n5xOAXA/+NmeuWENTfgAdfjAtJtZB8+N7LK2pYr4qVmSRXdrXaTLYz6PS39Bvchkj\nfB8vEDMYdTdGWPv/O/bQ2MtAfgw6Ym870H0vrgkvCk0sOe/iuBXyIny2d02qJnyY\nWIgE8twYX4XE7sKhPSbIGOErItvxq5dGv7UUGPTI2Ej+OygJNKZa2agEC05BOrbn\nJ9hJ24cUVvZQIbD92IwljcEqiycM4Y3RLvRKHEUhMmpPmNHdPLX0KgSIVNeOzshD\noNklztjg/M771hC7hE86m8+nzahjqKHROCjbTcw/wP1du6wAiq5P0IC9ubyR029c\nHK2/pBZJ/jF35wjpqmGgWNjCRfVvbnKr6P6sA32tK9n5FpnXvEive9c1eMi4/1Cy\nOPDNxo2H69YvzMvrR4e38gWlIEi0nTE3kNJTfjapwE+tL0ZVaETjgGXKYhDlS6xi\nbIwC7IO3K/KZPEkK7vMtandNc1KZhEWjJKtB5QGZdzMKVBMzYNEEAErz2MkQWF2N\nD3qgnubyE4cgwJXQkcZL2hnzQ+/6OpY2sLUhCd06OU+un0ORw2t4N8ZJFYR74gzt\npI3wxYSWBF+W2eK89WNU/4KduICfh/0cMrpFvZL3mDTmhM8g7JDRbBqsKChxrHlr\nZjpRU+NJHMWQnvGmHx/2EFwQoKI+j4C+gkRJ/Mz+5sxK/ImzbyA=\n=Ccr9\n-----END PGP SIGNATURE-----", "payload": "tree f38e5c6d98ea8e2d6d96dfde3f6819aa5530ea59\nparent 44f5180584404d18058cbbf224c55255db4fdcbb\nauthor Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1679357340 +0100\ncommitter Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1679439238 +0100\n\niat selection: erase regions in self type\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/293f21c876278df7943eea889dacd977155a2f62", "html_url": "https://github.com/rust-lang/rust/commit/293f21c876278df7943eea889dacd977155a2f62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/293f21c876278df7943eea889dacd977155a2f62/comments", "author": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44f5180584404d18058cbbf224c55255db4fdcbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/44f5180584404d18058cbbf224c55255db4fdcbb", "html_url": "https://github.com/rust-lang/rust/commit/44f5180584404d18058cbbf224c55255db4fdcbb"}], "stats": {"total": 132, "additions": 101, "deletions": 31}, "files": [{"sha": "9d3f8c2b3e74f2b0e3febdbc6b7019628179a150", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/293f21c876278df7943eea889dacd977155a2f62/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293f21c876278df7943eea889dacd977155a2f62/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=293f21c876278df7943eea889dacd977155a2f62", "patch": "@@ -31,6 +31,7 @@ use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability::AllowUnstable;\n+use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n@@ -2226,47 +2227,66 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let param_env = tcx.param_env(block.owner.to_def_id());\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n+\n         let mut fulfillment_errors = Vec::new();\n-        let mut applicable_candidates: Vec<_> = candidates\n-            .iter()\n-            .filter_map(|&(impl_, (assoc_item, def_scope))| {\n-                infcx.probe(|_| {\n-                    let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n+        let mut applicable_candidates: Vec<_> = infcx.probe(|_| {\n+            let universe = infcx.create_next_universe();\n+\n+            // Regions are not considered during selection.\n+            let self_ty = tcx.replace_escaping_bound_vars_uncached(\n+                self_ty,\n+                FnMutDelegate {\n+                    regions: &mut |_| tcx.lifetimes.re_erased,\n+                    types: &mut |bv| {\n+                        tcx.mk_placeholder(ty::PlaceholderType { universe, name: bv.kind })\n+                    },\n+                    consts: &mut |bv, ty| {\n+                        tcx.mk_const(ty::PlaceholderConst { universe, name: bv }, ty)\n+                    },\n+                },\n+            );\n \n-                    let impl_ty = tcx.type_of(impl_);\n-                    let impl_substs = infcx.fresh_item_substs(impl_);\n-                    let impl_ty = impl_ty.subst(tcx, impl_substs);\n-                    let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n+            candidates\n+                .iter()\n+                .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                    infcx.probe(|_| {\n+                        let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n \n-                    // Check that the Self-types can be related.\n-                    // FIXME(fmease): Should we use `eq` here?\n-                    ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+                        let impl_ty = tcx.type_of(impl_);\n+                        let impl_substs = infcx.fresh_item_substs(impl_);\n+                        let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                        let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n-                    // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_bounds = tcx.predicates_of(impl_);\n-                    let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n+                        // Check that the Self-types can be related.\n+                        // FIXME(fmease): Should we use `eq` here?\n+                        ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n \n-                    let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n+                        // Check whether the impl imposes obligations we have to worry about.\n+                        let impl_bounds = tcx.predicates_of(impl_);\n+                        let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n \n-                    let impl_obligations = traits::predicates_for_generics(\n-                        |_, _| cause.clone(),\n-                        param_env,\n-                        impl_bounds,\n-                    );\n+                        let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n \n-                    ocx.register_obligations(impl_obligations);\n+                        let impl_obligations = traits::predicates_for_generics(\n+                            |_, _| cause.clone(),\n+                            param_env,\n+                            impl_bounds,\n+                        );\n \n-                    let mut errors = ocx.select_where_possible();\n-                    if !errors.is_empty() {\n-                        fulfillment_errors.append(&mut errors);\n-                        return None;\n-                    }\n+                        ocx.register_obligations(impl_obligations);\n+\n+                        let mut errors = ocx.select_where_possible();\n+                        if !errors.is_empty() {\n+                            fulfillment_errors.append(&mut errors);\n+                            return None;\n+                        }\n \n-                    // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n-                    Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                        // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n+                        Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                    })\n                 })\n-            })\n-            .collect();\n+                .collect()\n+        });\n \n         if applicable_candidates.len() > 1 {\n             return Err(self.complain_about_ambiguous_inherent_assoc_type("}, {"sha": "6f95273116b78af569216574bb78c975cede43e2", "filename": "tests/ui/associated-inherent-types/issue-109299-1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/293f21c876278df7943eea889dacd977155a2f62/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293f21c876278df7943eea889dacd977155a2f62/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.rs?ref=293f21c876278df7943eea889dacd977155a2f62", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types, non_lifetime_binders, type_alias_impl_trait)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<T>(T);\n+\n+impl Lexer<i32> {\n+    type Cursor = ();\n+}\n+\n+type X = impl for<T> Fn() -> Lexer<T>::Cursor; //~ ERROR associated type `Cursor` not found for `Lexer<T>` in the current scope\n+\n+fn main() {}"}, {"sha": "dc59b56ee207dc1fec88cca04487dd9af07e481a", "filename": "tests/ui/associated-inherent-types/issue-109299-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/293f21c876278df7943eea889dacd977155a2f62/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/293f21c876278df7943eea889dacd977155a2f62/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299-1.stderr?ref=293f21c876278df7943eea889dacd977155a2f62", "patch": "@@ -0,0 +1,15 @@\n+error[E0220]: associated type `Cursor` not found for `Lexer<T>` in the current scope\n+  --> $DIR/issue-109299-1.rs:10:40\n+   |\n+LL | struct Lexer<T>(T);\n+   | --------------- associated item `Cursor` not found for this struct\n+...\n+LL | type X = impl for<T> Fn() -> Lexer<T>::Cursor;\n+   |                                        ^^^^^^ associated item not found in `Lexer<T>`\n+   |\n+   = note: the associated type was found for\n+           - `Lexer<i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "84e4f9e72527aa21025ab3b061ceb17b1a47afbd", "filename": "tests/ui/associated-inherent-types/issue-109299.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/293f21c876278df7943eea889dacd977155a2f62/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293f21c876278df7943eea889dacd977155a2f62/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.rs?ref=293f21c876278df7943eea889dacd977155a2f62", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<'d>(&'d ());\n+\n+impl Lexer<'d> { //~ ERROR use of undeclared lifetime name `'d`\n+    type Cursor = ();\n+}\n+\n+fn test(_: Lexer::Cursor) {}\n+\n+fn main() {}"}, {"sha": "63f50732d3c50985b420dfa33b4686e6f88c97d5", "filename": "tests/ui/associated-inherent-types/issue-109299.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/293f21c876278df7943eea889dacd977155a2f62/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/293f21c876278df7943eea889dacd977155a2f62/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109299.stderr?ref=293f21c876278df7943eea889dacd977155a2f62", "patch": "@@ -0,0 +1,11 @@\n+error[E0261]: use of undeclared lifetime name `'d`\n+  --> $DIR/issue-109299.rs:6:12\n+   |\n+LL | impl Lexer<'d> {\n+   |     -      ^^ undeclared lifetime\n+   |     |\n+   |     help: consider introducing lifetime `'d` here: `<'d>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0261`."}]}