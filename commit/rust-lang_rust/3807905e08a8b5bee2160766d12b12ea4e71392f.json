{"sha": "3807905e08a8b5bee2160766d12b12ea4e71392f", "node_id": "C_kwDOAAsO6NoAKDM4MDc5MDVlMDhhOGI1YmVlMjE2MDc2NmQxMmIxMmVhNGU3MTM5MmY", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-12-13T10:49:43Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-12-13T12:04:57Z"}, "message": "Handle `to_vec` on for loop expression #8069", "tree": {"sha": "33e786774594b3aa35c7bec56f1efe38c96c82b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33e786774594b3aa35c7bec56f1efe38c96c82b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3807905e08a8b5bee2160766d12b12ea4e71392f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3807905e08a8b5bee2160766d12b12ea4e71392f", "html_url": "https://github.com/rust-lang/rust/commit/3807905e08a8b5bee2160766d12b12ea4e71392f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3807905e08a8b5bee2160766d12b12ea4e71392f/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "url": "https://api.github.com/repos/rust-lang/rust/commits/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697", "html_url": "https://github.com/rust-lang/rust/commit/290f74be4e83fc610ad99d9c1cc1d7d5d96f2697"}], "stats": {"total": 968, "additions": 829, "deletions": 139}, "files": [{"sha": "6a61e662698a12e7c4912f78a113e94a2c6670fb", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -56,6 +56,7 @@ mod suspicious_splitn;\n mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n+mod unnecessary_iter_cloned;\n mod unnecessary_lazy_eval;\n mod unnecessary_to_owned;\n mod unwrap_or_else_default;"}, {"sha": "8300df03e9935a9f0219364edc2ebc3a817cd2c4", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -0,0 +1,177 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::ForLoop;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n+use clippy_utils::{fn_def_id, get_parent_expr, path_to_local_id, usage};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, HirId, LangItem, Mutability, Pat};\n+use rustc_lint::LateContext;\n+use rustc_middle::{hir::map::Map, ty};\n+use rustc_span::{sym, Symbol};\n+\n+use super::UNNECESSARY_TO_OWNED;\n+\n+pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, receiver: &'tcx Expr<'tcx>) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let Some(callee_def_id) = fn_def_id(cx, parent);\n+        if is_into_iter(cx, callee_def_id);\n+        then {\n+            check_for_loop_iter(cx, parent, method_name, receiver)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Checks whether `expr` is an iterator in a `for` loop and, if so, determines whether the\n+/// iterated-over items could be iterated over by reference. The reason why `check` above does not\n+/// include this code directly is so that it can be called from\n+/// `unnecessary_into_owned::check_into_iter_call_arg`.\n+pub fn check_for_loop_iter(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(grandparent) = get_parent_expr(cx, expr).and_then(|parent| get_parent_expr(cx, parent));\n+        if let Some(ForLoop { pat, body, .. }) = ForLoop::hir(grandparent);\n+        let (clone_or_copy_needed, addr_of_exprs) = clone_or_copy_needed(cx, pat, body);\n+        if !clone_or_copy_needed;\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            let snippet = if_chain! {\n+                if let ExprKind::MethodCall(maybe_iter_method_name, _, [collection], _) = receiver.kind;\n+                if maybe_iter_method_name.ident.name == sym::iter;\n+\n+                if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+                if implements_trait(cx, receiver_ty, iterator_trait_id, &[]);\n+                if let Some(iter_item_ty) = get_iterator_item_ty(cx, receiver_ty);\n+\n+                if let Some(into_iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::IntoIterator);\n+                let collection_ty = cx.typeck_results().expr_ty(collection);\n+                if implements_trait(cx, collection_ty, into_iterator_trait_id, &[]);\n+                if let Some(into_iter_item_ty) = get_associated_type(cx, collection_ty, into_iterator_trait_id, \"Item\");\n+\n+                if iter_item_ty == into_iter_item_ty;\n+                if let Some(collection_snippet) = snippet_opt(cx, collection.span);\n+                then {\n+                    collection_snippet\n+                } else {\n+                    receiver_snippet\n+                }\n+            };\n+            span_lint_and_then(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                expr.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                |diag| {\n+                    diag.span_suggestion(expr.span, \"use\", snippet, Applicability::MachineApplicable);\n+                    for addr_of_expr in addr_of_exprs {\n+                        match addr_of_expr.kind {\n+                            ExprKind::AddrOf(_, _, referent) => {\n+                                let span = addr_of_expr.span.with_hi(referent.span.lo());\n+                                diag.span_suggestion(span, \"remove this `&`\", String::new(), Applicability::MachineApplicable);\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                    }\n+                }\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// The core logic of `check_for_loop_iter` above, this function wraps a use of\n+/// `CloneOrCopyVisitor`.\n+fn clone_or_copy_needed(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    body: &'tcx Expr<'tcx>,\n+) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n+    let mut visitor = CloneOrCopyVisitor {\n+        cx,\n+        binding_hir_ids: pat_bindings(pat),\n+        clone_or_copy_needed: false,\n+        addr_of_exprs: Vec::new(),\n+    };\n+    visitor.visit_expr(body);\n+    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n+}\n+\n+/// Returns a vector of all `HirId`s bound by the pattern.\n+fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n+    let mut collector = usage::ParamBindingIdCollector {\n+        binding_hir_ids: Vec::new(),\n+    };\n+    collector.visit_pat(pat);\n+    collector.binding_hir_ids\n+}\n+\n+/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n+/// operations performed on `binding_hir_ids` are:\n+/// * to take non-mutable references to them\n+/// * to use them as non-mutable `&self` in method calls\n+/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n+/// when `CloneOrCopyVisitor` is done visiting.\n+struct CloneOrCopyVisitor<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    binding_hir_ids: Vec<HirId>,\n+    clone_or_copy_needed: bool,\n+    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        walk_expr(self, expr);\n+        if self.is_binding(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n+                        self.addr_of_exprs.push(parent);\n+                        return;\n+                    },\n+                    ExprKind::MethodCall(_, _, args, _) => {\n+                        if_chain! {\n+                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n+                            let method_ty = self.cx.tcx.type_of(method_def_id);\n+                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n+                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n+                            then {\n+                                return;\n+                            }\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            self.clone_or_copy_needed = true;\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n+    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n+        self.binding_hir_ids\n+            .iter()\n+            .any(|hir_id| path_to_local_id(expr, *hir_id))\n+    }\n+}\n+\n+/// Returns true if the named method is `IntoIterator::into_iter`.\n+pub fn is_into_iter(cx: &LateContext<'_>, callee_def_id: DefId) -> bool {\n+    cx.tcx.lang_items().require(LangItem::IntoIterIntoIter) == Ok(callee_def_id)\n+}"}, {"sha": "c5af7483ae6f6a643f332c46ae098c9d4a58965d", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 99, "deletions": 50, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -1,8 +1,9 @@\n use super::implicit_clone::is_clone_like;\n+use super::unnecessary_iter_cloned::{self, is_into_iter};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{implements_trait, is_copy, peel_mid_ty_refs};\n-use clippy_utils::{get_parent_expr, is_diag_item_method, is_diag_trait_item};\n+use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -18,17 +19,23 @@ use super::UNNECESSARY_TO_OWNED;\n pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, args: &'tcx [Expr<'tcx>]) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-        if is_to_owned_like(cx, method_name, method_def_id);\n         if let [receiver] = args;\n         then {\n-            // At this point, we know the call is of a `to_owned`-like function. The functions\n-            // `check_addr_of_expr` and `check_call_arg` determine whether the call is unnecessary\n-            // based on its context, that is, whether it is a referent in an `AddrOf` expression or\n-            // an argument in a function call.\n-            if check_addr_of_expr(cx, expr, method_name, method_def_id, receiver) {\n-                return;\n+            if is_cloned_or_copied(cx, method_name, method_def_id) {\n+                unnecessary_iter_cloned::check(cx, expr, method_name, receiver);\n+            } else if is_to_owned_like(cx, method_name, method_def_id) {\n+                // At this point, we know the call is of a `to_owned`-like function. The functions\n+                // `check_addr_of_expr` and `check_call_arg` determine whether the call is unnecessary\n+                // based on its context, that is, whether it is a referent in an `AddrOf` expression, an\n+                // argument in a `into_iter` call, or an argument in the call of some other function.\n+                if check_addr_of_expr(cx, expr, method_name, method_def_id, receiver) {\n+                    return;\n+                }\n+                if check_into_iter_call_arg(cx, expr, method_name, receiver) {\n+                    return;\n+                }\n+                check_other_call_arg(cx, expr, method_name, receiver);\n             }\n-            check_call_arg(cx, expr, method_name, receiver);\n         }\n     }\n }\n@@ -116,29 +123,34 @@ fn check_addr_of_expr(\n                     return true;\n                 }\n             }\n-            if implements_deref_trait(cx, receiver_ty, target_ty) {\n-                if n_receiver_refs > 0 {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNNECESSARY_TO_OWNED,\n-                        parent.span,\n-                        &format!(\"unnecessary use of `{}`\", method_name),\n-                        \"use\",\n-                        receiver_snippet,\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNNECESSARY_TO_OWNED,\n-                        expr.span.with_lo(receiver.span.hi()),\n-                        &format!(\"unnecessary use of `{}`\", method_name),\n-                        \"remove this\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n+            if_chain! {\n+                if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n+                if implements_trait(cx, receiver_ty, deref_trait_id, &[]);\n+                if get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n+                then {\n+                    if n_receiver_refs > 0 {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_TO_OWNED,\n+                            parent.span,\n+                            &format!(\"unnecessary use of `{}`\", method_name),\n+                            \"use\",\n+                            receiver_snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_TO_OWNED,\n+                            expr.span.with_lo(receiver.span.hi()),\n+                            &format!(\"unnecessary use of `{}`\", method_name),\n+                            \"remove this\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    return true;\n                 }\n-                return true;\n             }\n             if_chain! {\n                 if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n@@ -161,9 +173,55 @@ fn check_addr_of_expr(\n     false\n }\n \n+/// Checks whether `expr` is an argument in an `into_iter` call and, if so, determines whether its\n+/// call of a `to_owned`-like function is unnecessary.\n+fn check_into_iter_call_arg(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let Some(callee_def_id) = fn_def_id(cx, parent);\n+        if is_into_iter(cx, callee_def_id);\n+        if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+        let parent_ty = cx.typeck_results().expr_ty(parent);\n+        if implements_trait(cx, parent_ty, iterator_trait_id, &[]);\n+        if let Some(item_ty) = get_iterator_item_ty(cx, parent_ty);\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            if unnecessary_iter_cloned::check_for_loop_iter(cx, parent, method_name, receiver) {\n+                return true;\n+            }\n+            let cloned_or_copied = if is_copy(cx, item_ty) {\n+                \"copied\"\n+            } else {\n+                \"cloned\"\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                parent.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                \"use\",\n+                format!(\"{}.iter().{}()\", receiver_snippet, cloned_or_copied),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n /// Checks whether `expr` is an argument in a function call and, if so, determines whether its call\n /// of a `to_owned`-like function is unnecessary.\n-fn check_call_arg(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, receiver: &'tcx Expr<'tcx>) {\n+fn check_other_call_arg(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n     if_chain! {\n         if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n         if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n@@ -186,7 +244,8 @@ fn check_call_arg(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: S\n             if let [projection_predicate] = projection_predicates[..] {\n                 let normalized_ty =\n                     cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.ty);\n-                implements_deref_trait(cx, receiver_ty, normalized_ty)\n+                implements_trait(cx, receiver_ty, deref_trait_id, &[])\n+                    && get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(normalized_ty)\n             } else {\n                 false\n             }\n@@ -215,8 +274,10 @@ fn check_call_arg(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: S\n                 format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_refs),\n                 Applicability::MachineApplicable,\n             );\n+            return true;\n         }\n     }\n+    false\n }\n \n /// Walks an expression's ancestors until it finds a non-`AddrOf` expression. Returns the first such\n@@ -315,22 +376,10 @@ fn compose_substs(cx: &LateContext<'tcx>, left: &[GenericArg<'tcx>], right: Subs\n         .collect()\n }\n \n-/// Helper function to check whether a type implements the `Deref` trait.\n-fn implements_deref_trait(cx: &LateContext<'tcx>, ty: Ty<'tcx>, deref_target_ty: Ty<'tcx>) -> bool {\n-    if_chain! {\n-        if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n-        if implements_trait(cx, ty, deref_trait_id, &[]);\n-        if let Some(deref_target_id) = cx.tcx.lang_items().deref_target();\n-        let substs = cx.tcx.mk_substs_trait(ty, &[]);\n-        let projection_ty = cx.tcx.mk_projection(deref_target_id, substs);\n-        let normalized_ty = cx.tcx.normalize_erasing_regions(cx.param_env, projection_ty);\n-        if normalized_ty == deref_target_ty;\n-        then {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n+/// Returns true if the named method is `Iterator::cloned` or `Iterator::copied`.\n+fn is_cloned_or_copied(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    (method_name.as_str() == \"cloned\" || method_name.as_str() == \"copied\")\n+        && is_diag_trait_item(cx, method_def_id, sym::Iterator)\n }\n \n /// Returns true if the named method can be used to convert the receiver to its \"owned\""}, {"sha": "6d191d4a59bde9948d4fa84e26aacc9ed5d7268c", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -58,14 +58,20 @@ pub fn contains_adt_constructor<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, adt: &'tc\n pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     cx.tcx\n         .get_diagnostic_item(sym::Iterator)\n-        .and_then(|iter_did| {\n-            cx.tcx.associated_items(iter_did).find_by_name_and_kind(\n-                cx.tcx,\n-                Ident::from_str(\"Item\"),\n-                ty::AssocKind::Type,\n-                iter_did,\n-            )\n-        })\n+        .and_then(|iter_did| get_associated_type(cx, ty, iter_did, \"Item\"))\n+}\n+\n+/// Returns the associated type `name` for `ty` as an implementation of `trait_id`.\n+/// Do not invoke without first verifying that the type implements the trait.\n+pub fn get_associated_type<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_id: DefId,\n+    name: &str,\n+) -> Option<Ty<'tcx>> {\n+    cx.tcx\n+        .associated_items(trait_id)\n+        .find_by_name_and_kind(cx.tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n         .map(|assoc| {\n             let proj = cx.tcx.mk_projection(assoc.def_id, cx.tcx.mk_substs_trait(ty, &[]));\n             cx.tcx.normalize_erasing_regions(cx.param_env, proj)"}, {"sha": "2066915e1d184a9d6d9d8c96256dddfd057f040c", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n }\n \n pub struct ParamBindingIdCollector {\n-    binding_hir_ids: Vec<hir::HirId>,\n+    pub binding_hir_ids: Vec<hir::HirId>,\n }\n impl<'tcx> ParamBindingIdCollector {\n     fn collect_binding_hir_ids(body: &'tcx hir::Body<'tcx>) -> Vec<hir::HirId> {"}, {"sha": "e01e9f07bafdaf28d8e2552a7e2110b5af69f736", "filename": "tests/ui/unnecessary_iter_cloned.fixed", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_iter_cloned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_iter_cloned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.fixed?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -0,0 +1,142 @@\n+// run-rustfix\n+\n+#![allow(unused_assignments)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+#[allow(dead_code)]\n+#[derive(Clone, Copy)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let path = std::path::Path::new(\"x\");\n+\n+    let _ = check_files(&[(FileType::Account, path)]);\n+    let _ = check_files_vec(vec![(FileType::Account, path)]);\n+\n+    // negative tests\n+    let _ = check_files_ref(&[(FileType::Account, path)]);\n+    let _ = check_files_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_ref_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_self_and_arg(&[(FileType::Account, path)]);\n+    let _ = check_files_mut_path_buf(&[(FileType::Account, std::path::PathBuf::new())]);\n+}\n+\n+// `check_files` and its variants are based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_vec(files: Vec<(FileType, &std::path::Path)>) -> bool {\n+    for (t, path) in files.iter() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref t, path) in files.iter().copied() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (mut t, path) in files.iter().copied() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref mut t, path) in files.iter().copied() {\n+        *t = FileType::PrivateKey;\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_self_and_arg(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.join(path).is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut_path_buf(files: &[(FileType, std::path::PathBuf)]) -> bool {\n+    for (mut t, path) in files.iter().cloned() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}"}, {"sha": "6ef2966c8b762d373060133bca21c4ab68ba5fd9", "filename": "tests/ui/unnecessary_iter_cloned.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.rs?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -0,0 +1,142 @@\n+// run-rustfix\n+\n+#![allow(unused_assignments)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+#[allow(dead_code)]\n+#[derive(Clone, Copy)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let path = std::path::Path::new(\"x\");\n+\n+    let _ = check_files(&[(FileType::Account, path)]);\n+    let _ = check_files_vec(vec![(FileType::Account, path)]);\n+\n+    // negative tests\n+    let _ = check_files_ref(&[(FileType::Account, path)]);\n+    let _ = check_files_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_ref_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_self_and_arg(&[(FileType::Account, path)]);\n+    let _ = check_files_mut_path_buf(&[(FileType::Account, std::path::PathBuf::new())]);\n+}\n+\n+// `check_files` and its variants are based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_vec(files: Vec<(FileType, &std::path::Path)>) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref t, path) in files.iter().copied() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (mut t, path) in files.iter().copied() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref mut t, path) in files.iter().copied() {\n+        *t = FileType::PrivateKey;\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_self_and_arg(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.join(path).is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut_path_buf(files: &[(FileType, std::path::PathBuf)]) -> bool {\n+    for (mut t, path) in files.iter().cloned() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}"}, {"sha": "e44379f8aa04783b35390018a3a5538e11a3c640", "filename": "tests/ui/unnecessary_iter_cloned.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_iter_cloned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_iter_cloned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.stderr?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -0,0 +1,35 @@\n+error: unnecessary use of `copied`\n+  --> $DIR/unnecessary_iter_cloned.rs:31:22\n+   |\n+LL |     for (t, path) in files.iter().copied() {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+help: use\n+   |\n+LL |     for (t, path) in files {\n+   |                      ~~~~~\n+help: remove this `&`\n+   |\n+LL -         let other = match get_file_path(&t) {\n+LL +         let other = match get_file_path(t) {\n+   | \n+\n+error: unnecessary use of `copied`\n+  --> $DIR/unnecessary_iter_cloned.rs:46:22\n+   |\n+LL |     for (t, path) in files.iter().copied() {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use\n+   |\n+LL |     for (t, path) in files.iter() {\n+   |                      ~~~~~~~~~~~~\n+help: remove this `&`\n+   |\n+LL -         let other = match get_file_path(&t) {\n+LL +         let other = match get_file_path(t) {\n+   | \n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "720138db137726cbf6c1844a6ba2d63b8aa0e7c6", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -1,10 +1,6 @@\n // run-rustfix\n \n #![allow(clippy::ptr_arg)]\n-// `needless_borrow` is to ensure there are no needles borrows in the fixed code.\n-#![warn(clippy::needless_borrow)]\n-// `redundant_clone` is to ensure there is no overlap between that lint and this one.\n-#![warn(clippy::redundant_clone)]\n #![warn(clippy::unnecessary_to_owned)]\n \n use std::borrow::Cow;\n@@ -41,6 +37,14 @@ impl X {\n     }\n }\n \n+#[allow(dead_code)]\n+#[derive(Clone)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n fn main() {\n     let c_str = CStr::from_bytes_with_nul(&[0]).unwrap();\n     let os_str = OsStr::new(\"x\");\n@@ -120,6 +124,18 @@ fn main() {\n \n     let _ = x.join(x_ref);\n \n+    let _ = slice.iter().copied();\n+    let _ = slice.iter().copied();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+\n+    let _ = slice.iter().copied();\n+    let _ = slice.iter().copied();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+\n+    let _ = check_files(&[FileType::Account]);\n+\n     // negative tests\n     require_string(&s.to_string());\n     require_string(&Cow::from(s).into_owned());\n@@ -174,4 +190,25 @@ fn require_impl_as_ref_slice<T>(_: impl AsRef<[T]>) {}\n fn require_as_ref_str_slice<T: AsRef<str>, U, V: AsRef<[U]>>(_: T, _: V) {}\n fn require_as_ref_slice_str<T, U: AsRef<[T]>, V: AsRef<str>>(_: U, _: V) {}\n \n+// `check_files` is based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(file_types: &[FileType]) -> bool {\n+    for t in file_types {\n+        let path = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}\n+\n fn require_string(_: &String) {}"}, {"sha": "60b2e718f5d499aefb887461737c0ab0ea42d68e", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -1,10 +1,6 @@\n // run-rustfix\n \n #![allow(clippy::ptr_arg)]\n-// `needless_borrow` is to ensure there are no needles borrows in the fixed code.\n-#![warn(clippy::needless_borrow)]\n-// `redundant_clone` is to ensure there is no overlap between that lint and this one.\n-#![warn(clippy::redundant_clone)]\n #![warn(clippy::unnecessary_to_owned)]\n \n use std::borrow::Cow;\n@@ -41,6 +37,14 @@ impl X {\n     }\n }\n \n+#[allow(dead_code)]\n+#[derive(Clone)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n fn main() {\n     let c_str = CStr::from_bytes_with_nul(&[0]).unwrap();\n     let os_str = OsStr::new(\"x\");\n@@ -120,6 +124,18 @@ fn main() {\n \n     let _ = x.join(&x_ref.to_string());\n \n+    let _ = slice.to_vec().into_iter();\n+    let _ = slice.to_owned().into_iter();\n+    let _ = [std::path::PathBuf::new()][..].to_vec().into_iter();\n+    let _ = [std::path::PathBuf::new()][..].to_owned().into_iter();\n+\n+    let _ = IntoIterator::into_iter(slice.to_vec());\n+    let _ = IntoIterator::into_iter(slice.to_owned());\n+    let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_vec());\n+    let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_owned());\n+\n+    let _ = check_files(&[FileType::Account]);\n+\n     // negative tests\n     require_string(&s.to_string());\n     require_string(&Cow::from(s).into_owned());\n@@ -174,4 +190,25 @@ fn require_impl_as_ref_slice<T>(_: impl AsRef<[T]>) {}\n fn require_as_ref_str_slice<T: AsRef<str>, U, V: AsRef<[U]>>(_: T, _: V) {}\n fn require_as_ref_slice_str<T, U: AsRef<[T]>, V: AsRef<str>>(_: U, _: V) {}\n \n+// `check_files` is based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(file_types: &[FileType]) -> bool {\n+    for t in file_types.to_vec() {\n+        let path = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}\n+\n fn require_string(_: &String) {}"}, {"sha": "1dfc65e22e2bc7c9d023389b9ba02ef74fd14f47", "filename": "tests/ui/unnecessary_to_owned.stderr", "status": "modified", "additions": 136, "deletions": 72, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3807905e08a8b5bee2160766d12b12ea4e71392f/tests%2Fui%2Funnecessary_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.stderr?ref=3807905e08a8b5bee2160766d12b12ea4e71392f", "patch": "@@ -1,431 +1,495 @@\n error: redundant clone\n-  --> $DIR/unnecessary_to_owned.rs:134:64\n+  --> $DIR/unnecessary_to_owned.rs:150:64\n    |\n LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n    |                                                                ^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::redundant-clone` implied by `-D warnings`\n note: this value is dropped without further use\n-  --> $DIR/unnecessary_to_owned.rs:134:20\n+  --> $DIR/unnecessary_to_owned.rs:150:20\n    |\n LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/unnecessary_to_owned.rs:135:40\n+  --> $DIR/unnecessary_to_owned.rs:151:40\n    |\n LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n    |                                        ^^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/unnecessary_to_owned.rs:135:21\n+  --> $DIR/unnecessary_to_owned.rs:151:21\n    |\n LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n    |                     ^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/unnecessary_to_owned.rs:136:48\n+  --> $DIR/unnecessary_to_owned.rs:152:48\n    |\n LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n    |                                                ^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/unnecessary_to_owned.rs:136:19\n+  --> $DIR/unnecessary_to_owned.rs:152:19\n    |\n LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/unnecessary_to_owned.rs:137:35\n+  --> $DIR/unnecessary_to_owned.rs:153:35\n    |\n LL |     require_str(&String::from(\"x\").to_string());\n    |                                   ^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/unnecessary_to_owned.rs:137:18\n+  --> $DIR/unnecessary_to_owned.rs:153:18\n    |\n LL |     require_str(&String::from(\"x\").to_string());\n    |                  ^^^^^^^^^^^^^^^^^\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:55:36\n+  --> $DIR/unnecessary_to_owned.rs:59:36\n    |\n LL |     require_c_str(&Cow::from(c_str).into_owned());\n    |                                    ^^^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:56:19\n+  --> $DIR/unnecessary_to_owned.rs:60:19\n    |\n LL |     require_c_str(&c_str.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_os_string`\n-  --> $DIR/unnecessary_to_owned.rs:58:20\n+  --> $DIR/unnecessary_to_owned.rs:62:20\n    |\n LL |     require_os_str(&os_str.to_os_string());\n    |                    ^^^^^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:59:38\n+  --> $DIR/unnecessary_to_owned.rs:63:38\n    |\n LL |     require_os_str(&Cow::from(os_str).into_owned());\n    |                                      ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:60:20\n+  --> $DIR/unnecessary_to_owned.rs:64:20\n    |\n LL |     require_os_str(&os_str.to_owned());\n    |                    ^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_path_buf`\n-  --> $DIR/unnecessary_to_owned.rs:62:18\n+  --> $DIR/unnecessary_to_owned.rs:66:18\n    |\n LL |     require_path(&path.to_path_buf());\n    |                  ^^^^^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:63:34\n+  --> $DIR/unnecessary_to_owned.rs:67:34\n    |\n LL |     require_path(&Cow::from(path).into_owned());\n    |                                  ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:64:18\n+  --> $DIR/unnecessary_to_owned.rs:68:18\n    |\n LL |     require_path(&path.to_owned());\n    |                  ^^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_string`\n-  --> $DIR/unnecessary_to_owned.rs:66:17\n+  --> $DIR/unnecessary_to_owned.rs:70:17\n    |\n LL |     require_str(&s.to_string());\n    |                 ^^^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:67:30\n+  --> $DIR/unnecessary_to_owned.rs:71:30\n    |\n LL |     require_str(&Cow::from(s).into_owned());\n    |                              ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:68:17\n+  --> $DIR/unnecessary_to_owned.rs:72:17\n    |\n LL |     require_str(&s.to_owned());\n    |                 ^^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_string`\n-  --> $DIR/unnecessary_to_owned.rs:69:17\n+  --> $DIR/unnecessary_to_owned.rs:73:17\n    |\n LL |     require_str(&x_ref.to_string());\n    |                 ^^^^^^^^^^^^^^^^^^ help: use: `x_ref.as_ref()`\n \n error: unnecessary use of `to_vec`\n-  --> $DIR/unnecessary_to_owned.rs:71:19\n+  --> $DIR/unnecessary_to_owned.rs:75:19\n    |\n LL |     require_slice(&slice.to_vec());\n    |                   ^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:72:36\n+  --> $DIR/unnecessary_to_owned.rs:76:36\n    |\n LL |     require_slice(&Cow::from(slice).into_owned());\n    |                                    ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:73:19\n+  --> $DIR/unnecessary_to_owned.rs:77:19\n    |\n LL |     require_slice(&array.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `array.as_ref()`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:74:19\n+  --> $DIR/unnecessary_to_owned.rs:78:19\n    |\n LL |     require_slice(&array_ref.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref.as_ref()`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:75:19\n+  --> $DIR/unnecessary_to_owned.rs:79:19\n    |\n LL |     require_slice(&slice.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:76:19\n+  --> $DIR/unnecessary_to_owned.rs:80:19\n    |\n LL |     require_slice(&x_ref.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:78:42\n+  --> $DIR/unnecessary_to_owned.rs:82:42\n    |\n LL |     require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n    |                                          ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:79:15\n+  --> $DIR/unnecessary_to_owned.rs:83:15\n    |\n LL |     require_x(&x_ref.to_owned());\n    |               ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:81:25\n+  --> $DIR/unnecessary_to_owned.rs:85:25\n    |\n LL |     require_deref_c_str(c_str.to_owned());\n    |                         ^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:82:26\n+  --> $DIR/unnecessary_to_owned.rs:86:26\n    |\n LL |     require_deref_os_str(os_str.to_owned());\n    |                          ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:83:24\n+  --> $DIR/unnecessary_to_owned.rs:87:24\n    |\n LL |     require_deref_path(path.to_owned());\n    |                        ^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:84:23\n+  --> $DIR/unnecessary_to_owned.rs:88:23\n    |\n LL |     require_deref_str(s.to_owned());\n    |                       ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:85:25\n+  --> $DIR/unnecessary_to_owned.rs:89:25\n    |\n LL |     require_deref_slice(slice.to_owned());\n    |                         ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:87:30\n+  --> $DIR/unnecessary_to_owned.rs:91:30\n    |\n LL |     require_impl_deref_c_str(c_str.to_owned());\n    |                              ^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:88:31\n+  --> $DIR/unnecessary_to_owned.rs:92:31\n    |\n LL |     require_impl_deref_os_str(os_str.to_owned());\n    |                               ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:89:29\n+  --> $DIR/unnecessary_to_owned.rs:93:29\n    |\n LL |     require_impl_deref_path(path.to_owned());\n    |                             ^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:90:28\n+  --> $DIR/unnecessary_to_owned.rs:94:28\n    |\n LL |     require_impl_deref_str(s.to_owned());\n    |                            ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:91:30\n+  --> $DIR/unnecessary_to_owned.rs:95:30\n    |\n LL |     require_impl_deref_slice(slice.to_owned());\n    |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:93:29\n+  --> $DIR/unnecessary_to_owned.rs:97:29\n    |\n LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n    |                             ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:93:43\n+  --> $DIR/unnecessary_to_owned.rs:97:43\n    |\n LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n    |                                           ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:94:29\n+  --> $DIR/unnecessary_to_owned.rs:98:29\n    |\n LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n    |                             ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:94:47\n+  --> $DIR/unnecessary_to_owned.rs:98:47\n    |\n LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n    |                                               ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:96:26\n+  --> $DIR/unnecessary_to_owned.rs:100:26\n    |\n LL |     require_as_ref_c_str(c_str.to_owned());\n    |                          ^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:97:27\n+  --> $DIR/unnecessary_to_owned.rs:101:27\n    |\n LL |     require_as_ref_os_str(os_str.to_owned());\n    |                           ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:98:25\n+  --> $DIR/unnecessary_to_owned.rs:102:25\n    |\n LL |     require_as_ref_path(path.to_owned());\n    |                         ^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:99:24\n+  --> $DIR/unnecessary_to_owned.rs:103:24\n    |\n LL |     require_as_ref_str(s.to_owned());\n    |                        ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:100:24\n+  --> $DIR/unnecessary_to_owned.rs:104:24\n    |\n LL |     require_as_ref_str(x.to_owned());\n    |                        ^^^^^^^^^^^^ help: use: `&x`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:101:26\n+  --> $DIR/unnecessary_to_owned.rs:105:26\n    |\n LL |     require_as_ref_slice(array.to_owned());\n    |                          ^^^^^^^^^^^^^^^^ help: use: `array`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:102:26\n+  --> $DIR/unnecessary_to_owned.rs:106:26\n    |\n LL |     require_as_ref_slice(array_ref.to_owned());\n    |                          ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:103:26\n+  --> $DIR/unnecessary_to_owned.rs:107:26\n    |\n LL |     require_as_ref_slice(slice.to_owned());\n    |                          ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:105:31\n+  --> $DIR/unnecessary_to_owned.rs:109:31\n    |\n LL |     require_impl_as_ref_c_str(c_str.to_owned());\n    |                               ^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:106:32\n+  --> $DIR/unnecessary_to_owned.rs:110:32\n    |\n LL |     require_impl_as_ref_os_str(os_str.to_owned());\n    |                                ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:107:30\n+  --> $DIR/unnecessary_to_owned.rs:111:30\n    |\n LL |     require_impl_as_ref_path(path.to_owned());\n    |                              ^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:108:29\n+  --> $DIR/unnecessary_to_owned.rs:112:29\n    |\n LL |     require_impl_as_ref_str(s.to_owned());\n    |                             ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:109:29\n+  --> $DIR/unnecessary_to_owned.rs:113:29\n    |\n LL |     require_impl_as_ref_str(x.to_owned());\n    |                             ^^^^^^^^^^^^ help: use: `&x`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:110:31\n+  --> $DIR/unnecessary_to_owned.rs:114:31\n    |\n LL |     require_impl_as_ref_slice(array.to_owned());\n    |                               ^^^^^^^^^^^^^^^^ help: use: `array`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:111:31\n+  --> $DIR/unnecessary_to_owned.rs:115:31\n    |\n LL |     require_impl_as_ref_slice(array_ref.to_owned());\n    |                               ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:112:31\n+  --> $DIR/unnecessary_to_owned.rs:116:31\n    |\n LL |     require_impl_as_ref_slice(slice.to_owned());\n    |                               ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:114:30\n+  --> $DIR/unnecessary_to_owned.rs:118:30\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n    |                              ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:114:44\n+  --> $DIR/unnecessary_to_owned.rs:118:44\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n    |                                            ^^^^^^^^^^^^^^^^ help: use: `array`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:115:30\n+  --> $DIR/unnecessary_to_owned.rs:119:30\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n    |                              ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:115:44\n+  --> $DIR/unnecessary_to_owned.rs:119:44\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n    |                                            ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:116:30\n+  --> $DIR/unnecessary_to_owned.rs:120:30\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n    |                              ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:116:44\n+  --> $DIR/unnecessary_to_owned.rs:120:44\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n    |                                            ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:117:30\n+  --> $DIR/unnecessary_to_owned.rs:121:30\n    |\n LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n    |                              ^^^^^^^^^^^^^^^^ help: use: `array`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:117:48\n+  --> $DIR/unnecessary_to_owned.rs:121:48\n    |\n LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n    |                                                ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:118:30\n+  --> $DIR/unnecessary_to_owned.rs:122:30\n    |\n LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n    |                              ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:118:52\n+  --> $DIR/unnecessary_to_owned.rs:122:52\n    |\n LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n    |                                                    ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:119:30\n+  --> $DIR/unnecessary_to_owned.rs:123:30\n    |\n LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n    |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:119:48\n+  --> $DIR/unnecessary_to_owned.rs:123:48\n    |\n LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n    |                                                ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_string`\n-  --> $DIR/unnecessary_to_owned.rs:121:20\n+  --> $DIR/unnecessary_to_owned.rs:125:20\n    |\n LL |     let _ = x.join(&x_ref.to_string());\n    |                    ^^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n-error: aborting due to 67 previous errors\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:127:13\n+   |\n+LL |     let _ = slice.to_vec().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:128:13\n+   |\n+LL |     let _ = slice.to_owned().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:129:13\n+   |\n+LL |     let _ = [std::path::PathBuf::new()][..].to_vec().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:130:13\n+   |\n+LL |     let _ = [std::path::PathBuf::new()][..].to_owned().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:132:13\n+   |\n+LL |     let _ = IntoIterator::into_iter(slice.to_vec());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:133:13\n+   |\n+LL |     let _ = IntoIterator::into_iter(slice.to_owned());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:134:13\n+   |\n+LL |     let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_vec());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:135:13\n+   |\n+LL |     let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_owned());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:196:14\n+   |\n+LL |     for t in file_types.to_vec() {\n+   |              ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use\n+   |\n+LL |     for t in file_types {\n+   |              ~~~~~~~~~~\n+help: remove this `&`\n+   |\n+LL -         let path = match get_file_path(&t) {\n+LL +         let path = match get_file_path(t) {\n+   | \n+\n+error: aborting due to 76 previous errors\n "}]}