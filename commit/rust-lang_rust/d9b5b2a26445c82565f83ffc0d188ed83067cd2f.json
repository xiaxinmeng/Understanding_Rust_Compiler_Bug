{"sha": "d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5YjViMmEyNjQ0NWM4MjU2NWY4M2ZmYzBkMTg4ZWQ4MzA2N2NkMmY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-09T05:56:44Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-09T05:56:44Z"}, "message": "Merge pull request #730 from mcarton/unused-labels\n\nLint unused labels and types with `fn new() -> Self` and no `Default` impl", "tree": {"sha": "c7d4fd6d66f27925fdcff102aaf8ef7bba40e246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7d4fd6d66f27925fdcff102aaf8ef7bba40e246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "html_url": "https://github.com/rust-lang/rust/commit/d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "878041bd7cef089305d646d2bff5872fc24a58b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/878041bd7cef089305d646d2bff5872fc24a58b7", "html_url": "https://github.com/rust-lang/rust/commit/878041bd7cef089305d646d2bff5872fc24a58b7"}, {"sha": "052f5984e772513654be815a1eac08997db6839c", "url": "https://api.github.com/repos/rust-lang/rust/commits/052f5984e772513654be815a1eac08997db6839c", "html_url": "https://github.com/rust-lang/rust/commit/052f5984e772513654be815a1eac08997db6839c"}], "stats": {"total": 351, "additions": 302, "deletions": 49}, "files": [{"sha": "9f3c30d39b3f35d8a04e0f238aaa258127ecd84c", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -8,7 +8,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 131 lints included in this crate:\n+There are 133 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -83,6 +83,7 @@ name\n [needless_return](https://github.com/Manishearth/rust-clippy/wiki#needless_return)                                   | warn    | using a return statement like `return expr;` where an expression would suffice\n [needless_update](https://github.com/Manishearth/rust-clippy/wiki#needless_update)                                   | warn    | using `{ ..base }` when there are no missing fields\n [new_ret_no_self](https://github.com/Manishearth/rust-clippy/wiki#new_ret_no_self)                                   | warn    | not returning `Self` in a `new` method\n+[new_without_default](https://github.com/Manishearth/rust-clippy/wiki#new_without_default)                           | warn    | `fn new() -> Self` method without `Default` implementation\n [no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                               | warn    | statements with no effect\n [non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                               | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n [nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)                 | warn    | nonsensical combination of options for opening a file\n@@ -131,6 +132,7 @@ name\n [unstable_as_mut_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_mut_slice)                       | warn    | as_mut_slice is not stable and can be replaced by &mut v[..]see https://github.com/rust-lang/rust/issues/27729\n [unstable_as_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice)                               | warn    | as_slice is not stable and can be replaced by & v[..]see https://github.com/rust-lang/rust/issues/27729\n [unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                                     | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n+[unused_label](https://github.com/Manishearth/rust-clippy/wiki#unused_label)                                         | warn    | unused label\n [unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                                 | warn    | unused lifetimes in function definitions\n [use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                               | allow   | use `Debug`-based formatting\n [used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)                   | warn    | using a binding which is prefixed with an underscore"}, {"sha": "8c619a1eaf72c546c22161619a24240c7947a043", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -77,6 +77,7 @@ pub mod mutex_atomic;\n pub mod needless_bool;\n pub mod needless_features;\n pub mod needless_update;\n+pub mod new_without_default;\n pub mod no_effect;\n pub mod open_options;\n pub mod overflow_check_conditional;\n@@ -94,6 +95,7 @@ pub mod temporary_assignment;\n pub mod transmute;\n pub mod types;\n pub mod unicode;\n+pub mod unused_label;\n pub mod vec;\n pub mod zero_div_zero;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n@@ -175,6 +177,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box swap::Swap);\n     reg.register_early_lint_pass(box if_not_else::IfNotElse);\n     reg.register_late_lint_pass(box overflow_check_conditional::OverflowCheckConditional);\n+    reg.register_late_lint_pass(box unused_label::UnusedLabel);\n+    reg.register_late_lint_pass(box new_without_default::NewWithoutDefault);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         enum_glob_use::ENUM_GLOB_USE,\n@@ -283,6 +287,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         needless_features::UNSTABLE_AS_MUT_SLICE,\n         needless_features::UNSTABLE_AS_SLICE,\n         needless_update::NEEDLESS_UPDATE,\n+        new_without_default::NEW_WITHOUT_DEFAULT,\n         no_effect::NO_EFFECT,\n         open_options::NONSENSICAL_OPEN_OPTIONS,\n         overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n@@ -309,6 +314,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         types::TYPE_COMPLEXITY,\n         types::UNIT_CMP,\n         unicode::ZERO_WIDTH_SPACE,\n+        unused_label::UNUSED_LABEL,\n         vec::USELESS_VEC,\n         zero_div_zero::ZERO_DIVIDED_BY_ZERO,\n     ]);"}, {"sha": "6d33f31d45c51009bbe1e2ab0ab85c5ec691245e", "filename": "src/methods.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -10,8 +10,8 @@ use std::{fmt, iter};\n use syntax::codemap::Span;\n use syntax::ptr::P;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n-            match_type, method_chain_args, snippet, snippet_opt, span_lint, span_lint_and_then, span_note_and_lint,\n-            walk_ptrs_ty, walk_ptrs_ty_depth};\n+            match_type, method_chain_args, return_ty, same_tys, snippet, snippet_opt, span_lint,\n+            span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::{BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH, RESULT_PATH, STRING_PATH,\n             VEC_PATH};\n use utils::MethodArgs;\n@@ -431,26 +431,12 @@ impl LateLintPass for MethodsPass {\n                         }\n                     }\n \n-                    if &name.as_str() == &\"new\" {\n-                        let returns_self = if let FunctionRetTy::Return(ref ret_ty) = sig.decl.output {\n-                            let ast_ty_to_ty_cache = cx.tcx.ast_ty_to_ty_cache.borrow();\n-                            let ret_ty = ast_ty_to_ty_cache.get(&ret_ty.id);\n-\n-                            if let Some(&ret_ty) = ret_ty {\n-                                ret_ty.walk().any(|t| t == ty)\n-                            } else {\n-                                false\n-                            }\n-                        } else {\n-                            false\n-                        };\n-\n-                        if !returns_self {\n-                            span_lint(cx,\n-                                      NEW_RET_NO_SELF,\n-                                      sig.explicit_self.span,\n-                                      \"methods called `new` usually return `Self`\");\n-                        }\n+                    let ret_ty = return_ty(cx.tcx.node_id_to_type(implitem.id));\n+                    if &name.as_str() == &\"new\" && !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty))) {\n+                        span_lint(cx,\n+                                  NEW_RET_NO_SELF,\n+                                  sig.explicit_self.span,\n+                                  \"methods called `new` usually return `Self`\");\n                     }\n                 }\n             }\n@@ -485,7 +471,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n                         return false;\n                     };\n \n-                    if implements_trait(cx, arg_ty, default_trait_id, None) {\n+                    if implements_trait(cx, arg_ty, default_trait_id, Vec::new()) {\n                         span_lint(cx,\n                                   OR_FUN_CALL,\n                                   span,\n@@ -869,7 +855,7 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n /// This checks whether a given type is known to implement Debug.\n fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     match cx.tcx.lang_items.debug_trait() {\n-        Some(debug) => implements_trait(cx, ty, debug, Some(vec![])),\n+        Some(debug) => implements_trait(cx, ty, debug, Vec::new()),\n         None => false,\n     }\n }"}, {"sha": "c7aeb7f9a2f606e0abb36f02f77b394f4f3ee84b", "filename": "src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -253,7 +253,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n         None => return,\n     };\n \n-    if !implements_trait(cx, arg_ty, partial_eq_trait_id, Some(vec![other_ty])) {\n+    if !implements_trait(cx, arg_ty, partial_eq_trait_id, vec![other_ty]) {\n         return;\n     }\n "}, {"sha": "d341afb4d92161b26344a12803d5ad6931042bd0", "filename": "src/new_without_default.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnew_without_default.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -0,0 +1,65 @@\n+use rustc::lint::*;\n+use rustc_front::hir;\n+use rustc_front::intravisit::FnKind;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, same_tys, span_lint,\n+            DEFAULT_TRAIT_PATH};\n+\n+/// **What it does:** This lints about type with a `fn new() -> Self` method and no `Default`\n+/// implementation.\n+///\n+/// **Why is this bad?** User might expect to be able to use `Default` is the type can be\n+/// constructed without arguments.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:**\n+///\n+/// ```rust,ignore\n+/// struct Foo;\n+///\n+/// impl Foo {\n+///     fn new() -> Self {\n+///         Foo\n+///     }\n+/// }\n+/// ```\n+declare_lint! {\n+    pub NEW_WITHOUT_DEFAULT,\n+    Warn,\n+    \"`fn new() -> Self` method without `Default` implementation\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct NewWithoutDefault;\n+\n+impl LintPass for NewWithoutDefault {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NEW_WITHOUT_DEFAULT)\n+    }\n+}\n+\n+impl LateLintPass for NewWithoutDefault {\n+    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, _: &hir::Block, span: Span, id: ast::NodeId) {\n+        if in_external_macro(cx, span) {\n+            return;\n+        }\n+\n+        if let FnKind::Method(name, _, _) = kind {\n+            if decl.inputs.is_empty() && name.as_str() == \"new\" {\n+                let self_ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(cx.tcx.map.get_parent(id))).ty;\n+\n+                if_let_chain!{[\n+                    let Some(ret_ty) = return_ty(cx.tcx.node_id_to_type(id)),\n+                    same_tys(cx, self_ty, ret_ty),\n+                    let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH),\n+                    !implements_trait(cx, self_ty, default_trait_id, Vec::new())\n+                ], {\n+                    span_lint(cx, NEW_WITHOUT_DEFAULT, span,\n+                              &format!(\"you should consider adding a `Default` implementation for `{}`\", self_ty));\n+                }}\n+            }\n+        }\n+    }\n+}"}, {"sha": "85baf3310c3d40f8c2afa7f5fbee0c88bf3b37de", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -6,6 +6,7 @@ use rustc::front::map::NodeItem;\n use rustc::lint::*;\n use rustc::middle::ty;\n use rustc_front::hir::*;\n+use syntax::ast::NodeId;\n use utils::{STRING_PATH, VEC_PATH};\n use utils::{span_lint, match_type};\n \n@@ -35,7 +36,7 @@ impl LintPass for PtrArg {\n impl LateLintPass for PtrArg {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemFn(ref decl, _, _, _, _, _) = item.node {\n-            check_fn(cx, decl);\n+            check_fn(cx, decl, item.id);\n         }\n     }\n \n@@ -46,34 +47,34 @@ impl LateLintPass for PtrArg {\n                     return; // ignore trait impls\n                 }\n             }\n-            check_fn(cx, &sig.decl);\n+            check_fn(cx, &sig.decl, item.id);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n-            check_fn(cx, &sig.decl);\n+            check_fn(cx, &sig.decl, item.id);\n         }\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl) {\n-    for arg in &decl.inputs {\n-        if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&arg.ty.id) {\n-            if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n-                if match_type(cx, ty, &VEC_PATH) {\n-                    span_lint(cx,\n-                              PTR_ARG,\n-                              arg.ty.span,\n-                              \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n-                               with non-Vec-based slices. Consider changing the type to `&[...]`\");\n-                } else if match_type(cx, ty, &STRING_PATH) {\n-                    span_lint(cx,\n-                              PTR_ARG,\n-                              arg.ty.span,\n-                              \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n-                               Consider changing the type to `&str`\");\n-                }\n+fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n+    let fn_ty = cx.tcx.node_id_to_type(fn_id).fn_sig().skip_binder();\n+\n+    for (arg, ty) in decl.inputs.iter().zip(&fn_ty.inputs) {\n+        if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n+            if match_type(cx, ty, &VEC_PATH) {\n+                span_lint(cx,\n+                          PTR_ARG,\n+                          arg.ty.span,\n+                          \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n+                           with non-Vec-based slices. Consider changing the type to `&[...]`\");\n+            } else if match_type(cx, ty, &STRING_PATH) {\n+                span_lint(cx,\n+                          PTR_ARG,\n+                          arg.ty.span,\n+                          \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n+                           Consider changing the type to `&str`\");\n             }\n         }\n     }"}, {"sha": "f2ecad7cc821344bbd36c549503f19c2d30227ad", "filename": "src/unused_label.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funused_label.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -0,0 +1,78 @@\n+use rustc::lint::*;\n+use rustc_front::hir;\n+use rustc_front::intravisit::{FnKind, Visitor, walk_expr, walk_fn};\n+use std::collections::HashMap;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+use utils::{in_macro, span_lint};\n+\n+/// **What it does:** This lint checks for unused labels.\n+///\n+/// **Why is this bad?** Maybe the label should be used in which case there is an error in the\n+/// code or it should be removed.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:**\n+/// ```rust,ignore\n+/// fn unused_label() {\n+///     'label: for i in 1..2 {\n+///         if i > 4 { continue }\n+///     }\n+/// ```\n+declare_lint! {\n+    pub UNUSED_LABEL,\n+    Warn,\n+    \"unused label\"\n+}\n+\n+pub struct UnusedLabel;\n+\n+#[derive(Default)]\n+struct UnusedLabelVisitor {\n+    labels: HashMap<InternedString, Span>,\n+}\n+\n+impl UnusedLabelVisitor {\n+    pub fn new() -> UnusedLabelVisitor {\n+        ::std::default::Default::default()\n+    }\n+}\n+\n+impl LintPass for UnusedLabel {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_LABEL)\n+    }\n+}\n+\n+impl LateLintPass for UnusedLabel {\n+    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, body: &hir::Block, span: Span, _: ast::NodeId) {\n+        if in_macro(cx, span) {\n+            return;\n+        }\n+\n+        let mut v = UnusedLabelVisitor::new();\n+        walk_fn(&mut v, kind, decl, body, span);\n+\n+        for (label, span) in v.labels {\n+            span_lint(cx, UNUSED_LABEL, span, &format!(\"unused label `{}`\", label));\n+        }\n+    }\n+}\n+\n+impl<'v> Visitor<'v> for UnusedLabelVisitor {\n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n+        match expr.node {\n+            hir::ExprBreak(Some(label)) | hir::ExprAgain(Some(label)) => {\n+                self.labels.remove(&label.node.name.as_str());\n+            }\n+            hir::ExprLoop(_, Some(label)) | hir::ExprWhile(_, _, Some(label)) => {\n+                self.labels.insert(label.name.as_str(), expr.span);\n+            }\n+            _ => (),\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+}"}, {"sha": "c626fcb8930c5684abade39faddd0c0f36c16dee", "filename": "src/utils/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -264,7 +264,7 @@ pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n /// Check whether a type implements a trait.\n /// See also `get_trait_def_id`.\n pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId,\n-                                  ty_params: Option<Vec<ty::Ty<'tcx>>>)\n+                                  ty_params: Vec<ty::Ty<'tcx>>)\n                                   -> bool {\n     cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n@@ -274,7 +274,7 @@ pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>,\n                                                      trait_id,\n                                                      0,\n                                                      ty,\n-                                                     ty_params.unwrap_or_default());\n+                                                     ty_params);\n \n     traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n }\n@@ -731,3 +731,20 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n         None\n     }\n }\n+\n+/// Convenience function to get the return type of a function or `None` if the function diverges.\n+pub fn return_ty(fun: ty::Ty) -> Option<ty::Ty> {\n+    if let ty::FnConverging(ret_ty) = fun.fn_sig().skip_binder().output {\n+        Some(ret_ty)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Check if two types are the same.\n+// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for <'b> Foo<'b>` but\n+// not for type parameters.\n+pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty<'tcx>) -> bool {\n+    let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, None);\n+    infcx.can_equate(&cx.tcx.erase_regions(&a), &cx.tcx.erase_regions(&b)).is_ok()\n+}"}, {"sha": "46f14d5d921c83d8f5c9e8f147bd4fce5ea7514e", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(clippy, clippy_pedantic)]\n-#![allow(unused, print_stdout, non_ascii_literal)]\n+#![allow(unused, print_stdout, non_ascii_literal, new_without_default)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;\n@@ -28,6 +28,25 @@ impl T {\n     //~| ERROR methods called `new` usually return `Self`\n }\n \n+struct Lt<'a> {\n+    foo: &'a u32,\n+}\n+\n+impl<'a> Lt<'a> {\n+    // The lifetime is different, but that\u2019s irrelevant, see #734\n+    #[allow(needless_lifetimes)]\n+    pub fn new<'b>(s: &'b str) -> Lt<'b> { unimplemented!() }\n+}\n+\n+struct Lt2<'a> {\n+    foo: &'a u32,\n+}\n+\n+impl<'a> Lt2<'a> {\n+    // The lifetime is different, but that\u2019s irrelevant, see #734\n+    pub fn new(s: &str) -> Lt2 { unimplemented!() }\n+}\n+\n #[derive(Clone,Copy)]\n struct U;\n "}, {"sha": "cc033043bc59c56ae0836f5f26cccf6ae563690e", "filename": "tests/compile-fail/new_without_default.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/tests%2Fcompile-fail%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/tests%2Fcompile-fail%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnew_without_default.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -0,0 +1,44 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![allow(dead_code)]\n+#![deny(new_without_default)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn new() -> Foo { Foo } //~ERROR: you should consider adding a `Default` implementation for `Foo`\n+}\n+\n+struct Bar;\n+\n+impl Bar {\n+    fn new() -> Self { Bar } //~ERROR: you should consider adding a `Default` implementation for `Bar`\n+}\n+\n+struct Ok;\n+\n+impl Ok {\n+    fn new() -> Self { Ok }\n+}\n+\n+impl Default for Ok {\n+    fn default() -> Self { Ok }\n+}\n+\n+struct Params;\n+\n+impl Params {\n+    fn new(_: u32) -> Self { Params }\n+}\n+\n+struct Generics<'a, T> {\n+    foo: &'a bool,\n+    bar: T,\n+}\n+\n+impl<'c, V> Generics<'c, V> {\n+    fn new<'b>() -> Generics<'b, V> { unimplemented!() } //~ERROR: you should consider adding a `Default` implementation for\n+}\n+\n+fn main() {}"}, {"sha": "26b4d4a2f3b28bd506bfd8ab026eded811a05d51", "filename": "tests/compile-fail/unused_labels.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/tests%2Fcompile-fail%2Funused_labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9b5b2a26445c82565f83ffc0d188ed83067cd2f/tests%2Fcompile-fail%2Funused_labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funused_labels.rs?ref=d9b5b2a26445c82565f83ffc0d188ed83067cd2f", "patch": "@@ -0,0 +1,35 @@\n+#![plugin(clippy)]\n+#![feature(plugin)]\n+\n+#![allow(dead_code, items_after_statements)]\n+#![deny(unused_label)]\n+\n+fn unused_label() {\n+    'label: for i in 1..2 { //~ERROR: unused label `'label`\n+        if i > 4 { continue }\n+    }\n+}\n+\n+fn foo() {\n+    'same_label_in_two_fns: loop {\n+        break 'same_label_in_two_fns;\n+    }\n+}\n+\n+\n+fn bla() {\n+    'a: loop { break } //~ERROR: unused label `'a`\n+    fn blub() {}\n+}\n+\n+fn main() {\n+    'a: for _ in 0..10 {\n+        while let Some(42) = None {\n+            continue 'a;\n+        }\n+    }\n+\n+    'same_label_in_two_fns: loop { //~ERROR: unused label `'same_label_in_two_fns`\n+        let _ = 1;\n+    }\n+}"}]}