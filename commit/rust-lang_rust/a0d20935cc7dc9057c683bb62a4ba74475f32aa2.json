{"sha": "a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwZDIwOTM1Y2M3ZGM5MDU3YzY4M2JiNjJhNGJhNzQ0NzVmMzJhYTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-03T15:38:34Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T21:53:40Z"}, "message": "introduce 'type AttrVec'", "tree": {"sha": "6f15df5680ea57750bfa7680ae19f5aff43ae758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f15df5680ea57750bfa7680ae19f5aff43ae758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "html_url": "https://github.com/rust-lang/rust/commit/a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d5dbcb44ad3e023e88959da0b301ee382b2f74f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5dbcb44ad3e023e88959da0b301ee382b2f74f", "html_url": "https://github.com/rust-lang/rust/commit/3d5dbcb44ad3e023e88959da0b301ee382b2f74f"}], "stats": {"total": 312, "additions": 136, "deletions": 176}, "files": [{"sha": "6b83788298e4d6a65b9bc4dee8cac189e51f1dee", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -53,7 +53,6 @@ use crate::util::nodemap::{DefIdMap, NodeMap};\n use errors::Applicability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::Lrc;\n \n use std::collections::BTreeMap;\n@@ -1205,7 +1204,7 @@ impl<'a> LoweringContext<'a> {\n                                 id: ty.id,\n                                 kind: ExprKind::Path(qself.clone(), path.clone()),\n                                 span: ty.span,\n-                                attrs: ThinVec::new(),\n+                                attrs: AttrVec::new(),\n                             };\n \n                             let ct = self.with_new_scopes(|this| {\n@@ -2751,7 +2750,7 @@ impl<'a> LoweringContext<'a> {\n     /// has no attributes and is not targeted by a `break`.\n     fn lower_block_expr(&mut self, b: &Block) -> hir::Expr {\n         let block = self.lower_block(b, false);\n-        self.expr_block(block, ThinVec::new())\n+        self.expr_block(block, AttrVec::new())\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n@@ -3102,7 +3101,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn stmt_let_pat(\n         &mut self,\n-        attrs: ThinVec<Attribute>,\n+        attrs: AttrVec,\n         span: Span,\n         init: Option<P<hir::Expr>>,\n         pat: P<hir::Pat>,"}, {"sha": "04031710dc5ea30e99285a573552af478390e936", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -1318,8 +1318,7 @@ impl LoweringContext<'_> {\n         &mut self,\n         span: Span,\n         expr: P<hir::Expr>,\n-        attrs: ThinVec<Attribute>\n-    ) -> hir::Expr {\n+        attrs: AttrVec) -> hir::Expr {\n         self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n     }\n \n@@ -1333,7 +1332,7 @@ impl LoweringContext<'_> {\n         self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n+    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> P<hir::Expr> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n         P(self.expr(span, expr_break, attrs))\n     }\n@@ -1404,7 +1403,7 @@ impl LoweringContext<'_> {\n         span: Span,\n         components: &[Symbol],\n         params: Option<P<hir::GenericArgs>>,\n-        attrs: ThinVec<Attribute>,\n+        attrs: AttrVec,\n     ) -> hir::Expr {\n         let path = self.std_path(span, components, params, true);\n         self.expr(\n@@ -1423,7 +1422,7 @@ impl LoweringContext<'_> {\n         span: Span,\n         ident: Ident,\n         binding: hir::HirId,\n-        attrs: ThinVec<Attribute>,\n+        attrs: AttrVec,\n     ) -> hir::Expr {\n         let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n             None,\n@@ -1459,16 +1458,11 @@ impl LoweringContext<'_> {\n         self.expr_block(P(blk), ThinVec::new())\n     }\n \n-    pub(super) fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> hir::Expr {\n+    pub(super) fn expr_block(&mut self, b: P<hir::Block>, attrs: AttrVec) -> hir::Expr {\n         self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n     }\n \n-    pub(super) fn expr(\n-        &mut self,\n-        span: Span,\n-        kind: hir::ExprKind,\n-        attrs: ThinVec<Attribute>\n-    ) -> hir::Expr {\n+    pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind, attrs: AttrVec) -> hir::Expr {\n         hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n     }\n "}, {"sha": "6cae8e2cc04e19941d0fa0438334aea8badd690d", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -11,7 +11,6 @@ use crate::hir::def_id::DefId;\n use crate::hir::def::{Res, DefKind};\n use crate::util::nodemap::NodeMap;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_target::spec::abi;\n \n use std::collections::BTreeSet;\n@@ -899,7 +898,7 @@ impl LoweringContext<'_> {\n \n     /// Construct `ExprKind::Err` for the given `span`.\n     fn expr_err(&mut self, span: Span) -> hir::Expr {\n-        self.expr(span, hir::ExprKind::Err, ThinVec::new())\n+        self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem {\n@@ -1182,7 +1181,7 @@ impl LoweringContext<'_> {\n                 //\n                 // If this is the simple case, this parameter will end up being the same as the\n                 // original parameter, but with a different pattern id.\n-                let mut stmt_attrs = ThinVec::new();\n+                let mut stmt_attrs = AttrVec::new();\n                 stmt_attrs.extend(parameter.attrs.iter().cloned());\n                 let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n                 let new_parameter = hir::Param {\n@@ -1226,7 +1225,7 @@ impl LoweringContext<'_> {\n                         desugared_span, ident, hir::BindingAnnotation::Mutable);\n                     let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n-                        ThinVec::new(),\n+                        AttrVec::new(),\n                         desugared_span,\n                         Some(P(move_expr)),\n                         move_pat,\n@@ -1271,7 +1270,7 @@ impl LoweringContext<'_> {\n                     let user_body = this.expr_drop_temps(\n                         desugared_span,\n                         P(user_body),\n-                        ThinVec::new(),\n+                        AttrVec::new(),\n                     );\n \n                     // As noted above, create the final block like\n@@ -1288,9 +1287,9 @@ impl LoweringContext<'_> {\n                         statements.into(),\n                         Some(P(user_body)),\n                     );\n-                    this.expr_block(P(body), ThinVec::new())\n+                    this.expr_block(P(body), AttrVec::new())\n                 });\n-            (HirVec::from(parameters), this.expr(body_span, async_expr, ThinVec::new()))\n+            (HirVec::from(parameters), this.expr(body_span, async_expr, AttrVec::new()))\n         })\n     }\n "}, {"sha": "17f4ec3444175e6f84447d9319b35706d7d08481", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -20,7 +20,7 @@ use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n-use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n+use syntax::ast::{AttrVec, Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy};\n pub use syntax::ast::{IsAuto, ImplPolarity, BorrowKind};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n@@ -29,7 +29,6 @@ use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::{BTreeSet, BTreeMap};\n@@ -1274,7 +1273,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     /// Can be `ForLoopDesugar` if the `let` statement is part of a `for` loop\n     /// desugaring. Otherwise will be `Normal`.\n     pub source: LocalSource,\n@@ -1459,7 +1458,7 @@ pub struct AnonConst {\n pub struct Expr {\n     pub hir_id: HirId,\n     pub kind: ExprKind,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub span: Span,\n }\n "}, {"sha": "a8800082c9a734d7d4957fbbed80e2306a6431e4", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -10,7 +10,6 @@ use rustc_data_structures::jobserver;\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_errors::registry::Registry;\n use rustc_metadata::dynamic_lib::DynamicLibrary;\n@@ -24,7 +23,7 @@ use std::ops::DerefMut;\n use smallvec::SmallVec;\n use syntax::ptr::P;\n use syntax::mut_visit::{*, MutVisitor, visit_clobber};\n-use syntax::ast::BlockCheckMode;\n+use syntax::ast::{AttrVec, BlockCheckMode};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::source_map::{FileLoader, RealFileLoader, SourceMap};\n use syntax::symbol::{Symbol, sym};\n@@ -741,7 +740,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n                 id: resolver.next_node_id(),\n                 kind: ast::ExprKind::Block(P(b), None),\n                 span: syntax_pos::DUMMY_SP,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n             });\n \n             ast::Stmt {\n@@ -756,7 +755,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n             kind: ast::ExprKind::Loop(P(empty_block), None),\n             id: self.resolver.next_node_id(),\n             span: syntax_pos::DUMMY_SP,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n         });\n \n         let loop_stmt = ast::Stmt {"}, {"sha": "16daefd1450ab70f34dd1c651e352f0d9b4177e6", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -4,11 +4,10 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{self, PResult, Applicability, DiagnosticBuilder, Handler, pluralize};\n use rustc_error_codes::*;\n use syntax::ast::{self, Param, BinOpKind, BindingMode, BlockCheckMode, Expr, ExprKind, Ident, Item};\n-use syntax::ast::{ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind, Attribute};\n+use syntax::ast::{ItemKind, Mutability, Pat, PatKind, PathSegment, QSelf, Ty, TyKind, AttrVec};\n use syntax::token::{self, TokenKind, token_can_begin_expr};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::ThinVec;\n use syntax::util::parser::AssocOp;\n use syntax::struct_span_err;\n use syntax_pos::symbol::kw;\n@@ -32,7 +31,7 @@ pub(super) fn dummy_arg(ident: Ident) -> Param {\n         id: ast::DUMMY_NODE_ID\n     };\n     Param {\n-        attrs: ThinVec::default(),\n+        attrs: AttrVec::default(),\n         id: ast::DUMMY_NODE_ID,\n         pat,\n         span: ident.span,\n@@ -164,7 +163,7 @@ impl RecoverQPath for Expr {\n         Self {\n             span: path.span,\n             kind: ExprKind::Path(qself, path),\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n             id: ast::DUMMY_NODE_ID,\n         }\n     }\n@@ -551,7 +550,7 @@ impl<'a> Parser<'a> {\n         );\n \n         let mk_err_expr = |this: &Self, span| {\n-            Ok(Some(this.mk_expr(span, ExprKind::Err, ThinVec::new())))\n+            Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())))\n         };\n \n         match lhs.kind {\n@@ -974,7 +973,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         await_sp: Span,\n-        attrs: ThinVec<Attribute>,\n+        attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         let (hi, expr, is_question) = if self.token == token::Not {\n             // Handle `await!(<expr>)`.\n@@ -1005,7 +1004,7 @@ impl<'a> Parser<'a> {\n                 None,\n                 self.token.span,\n                 BlockCheckMode::Default,\n-                ThinVec::new(),\n+                AttrVec::new(),\n             )\n         } else {\n             self.parse_expr()\n@@ -1126,7 +1125,7 @@ impl<'a> Parser<'a> {\n                 err.emit();\n                 // Recover from parse error, callers expect the closing delim to be consumed.\n                 self.consume_block(delim, ConsumeClosingDelim::Yes);\n-                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n+                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, AttrVec::new())\n             }\n         }\n     }"}, {"sha": "7afa3d665d695a78132f86ad6c0c363cc3b16b06", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 59, "deletions": 74, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -4,11 +4,10 @@ use super::pat::{GateOr, PARAM_EXPECTED};\n use super::diagnostics::Error;\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{PResult, Applicability};\n-use syntax::ast::{self, DUMMY_NODE_ID, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode};\n-use syntax::ast::{Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm, Ty, TyKind};\n-use syntax::ast::{FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst, Field, Lit};\n+use syntax::ast::{self, DUMMY_NODE_ID, AttrVec, AttrStyle, Ident, CaptureBy, Field, Lit};\n+use syntax::ast::{BlockCheckMode, Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm};\n+use syntax::ast::{Ty, TyKind, FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst};\n use syntax::token::{self, Token, TokenKind};\n use syntax::print::pprust;\n use syntax::ptr::P;\n@@ -37,14 +36,14 @@ macro_rules! maybe_whole_expr {\n                     let path = path.clone();\n                     $p.bump();\n                     return Ok($p.mk_expr(\n-                        $p.token.span, ExprKind::Path(None, path), ThinVec::new()\n+                        $p.token.span, ExprKind::Path(None, path), AttrVec::new()\n                     ));\n                 }\n                 token::NtBlock(block) => {\n                     let block = block.clone();\n                     $p.bump();\n                     return Ok($p.mk_expr(\n-                        $p.token.span, ExprKind::Block(block, None), ThinVec::new()\n+                        $p.token.span, ExprKind::Block(block, None), AttrVec::new()\n                     ));\n                 }\n                 // N.B., `NtIdent(ident)` is normalized to `Ident` in `fn bump`.\n@@ -57,16 +56,16 @@ macro_rules! maybe_whole_expr {\n #[derive(Debug)]\n pub(super) enum LhsExpr {\n     NotYetParsed,\n-    AttributesParsed(ThinVec<Attribute>),\n+    AttributesParsed(AttrVec),\n     AlreadyParsed(P<Expr>),\n }\n \n-impl From<Option<ThinVec<Attribute>>> for LhsExpr {\n+impl From<Option<AttrVec>> for LhsExpr {\n     /// Converts `Some(attrs)` into `LhsExpr::AttributesParsed(attrs)`\n     /// and `None` into `LhsExpr::NotYetParsed`.\n     ///\n     /// This conversion does not allocate.\n-    fn from(o: Option<ThinVec<Attribute>>) -> Self {\n+    fn from(o: Option<AttrVec>) -> Self {\n         if let Some(attrs) = o {\n             LhsExpr::AttributesParsed(attrs)\n         } else {\n@@ -103,7 +102,7 @@ impl<'a> Parser<'a> {\n                     err.emit();\n                     let sp = self.token.span;\n                     self.bump();\n-                    Ok(self.mk_expr(sp, ExprKind::Err, ThinVec::new()))\n+                    Ok(self.mk_expr(sp, ExprKind::Err, AttrVec::new()))\n                 }\n                 _ => Err(err),\n             },\n@@ -122,7 +121,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_expr_res(\n         &mut self,\n         r: Restrictions,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>\n+        already_parsed_attrs: Option<AttrVec>\n     ) -> PResult<'a, P<Expr>> {\n         self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n@@ -134,7 +133,7 @@ impl<'a> Parser<'a> {\n     #[inline]\n     fn parse_assoc_expr(\n         &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+        already_parsed_attrs: Option<AttrVec>,\n     ) -> PResult<'a, P<Expr>> {\n         self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n@@ -237,7 +236,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let r = self.mk_range(Some(lhs), rhs, limits)?;\n-                lhs = self.mk_expr(lhs_span.to(rhs_span), r, ThinVec::new());\n+                lhs = self.mk_expr(lhs_span.to(rhs_span), r, AttrVec::new());\n                 break\n             }\n \n@@ -271,9 +270,9 @@ impl<'a> Parser<'a> {\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n                     let binary = self.mk_binary(source_map::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(span, binary, ThinVec::new())\n+                    self.mk_expr(span, binary, AttrVec::new())\n                 }\n-                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n+                AssocOp::Assign => self.mk_expr(span, ExprKind::Assign(lhs, rhs), AttrVec::new()),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,\n@@ -288,7 +287,7 @@ impl<'a> Parser<'a> {\n                         token::Shr =>     BinOpKind::Shr,\n                     };\n                     let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(span, aopexpr, ThinVec::new())\n+                    self.mk_expr(span, aopexpr, AttrVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n                     self.bug(\"AssocOp should have been handled by special case\")\n@@ -398,7 +397,7 @@ impl<'a> Parser<'a> {\n     /// Parses prefix-forms of range notation: `..expr`, `..`, `..=expr`.\n     fn parse_prefix_range_expr(\n         &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>\n+        already_parsed_attrs: Option<AttrVec>\n     ) -> PResult<'a, P<Expr>> {\n         // Check for deprecated `...` syntax.\n         if self.token == token::DotDotDot {\n@@ -435,10 +434,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a prefix-unary-operator expr.\n-    fn parse_prefix_expr(\n-        &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_prefix_expr(&mut self, already_parsed_attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n@@ -549,7 +545,7 @@ impl<'a> Parser<'a> {\n                            expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n                            -> PResult<'a, P<Expr>> {\n         let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n-            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), ThinVec::new())\n+            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), AttrVec::new())\n         };\n \n         // Save the state of the parser before parsing type normally, in case there is a\n@@ -650,7 +646,7 @@ impl<'a> Parser<'a> {\n     /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n     fn parse_dot_or_call_expr(\n         &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>,\n+        already_parsed_attrs: Option<AttrVec>,\n     ) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n \n@@ -663,7 +659,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         e0: P<Expr>,\n         lo: Span,\n-        mut attrs: ThinVec<Attribute>,\n+        mut attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n@@ -692,7 +688,7 @@ impl<'a> Parser<'a> {\n             // expr?\n             while self.eat(&token::Question) {\n                 let hi = self.prev_span;\n-                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), ThinVec::new());\n+                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), AttrVec::new());\n             }\n \n             // expr.f\n@@ -705,7 +701,7 @@ impl<'a> Parser<'a> {\n                         let span = self.token.span;\n                         self.bump();\n                         let field = ExprKind::Field(e, Ident::new(symbol, span));\n-                        e = self.mk_expr(lo.to(span), field, ThinVec::new());\n+                        e = self.mk_expr(lo.to(span), field, AttrVec::new());\n \n                         self.expect_no_suffix(span, \"a tuple index\", suffix);\n                     }\n@@ -754,7 +750,7 @@ impl<'a> Parser<'a> {\n                     let seq = self.parse_paren_expr_seq().map(|es| {\n                         let nd = self.mk_call(e, es);\n                         let hi = self.prev_span;\n-                        self.mk_expr(lo.to(hi), nd, ThinVec::new())\n+                        self.mk_expr(lo.to(hi), nd, AttrVec::new())\n                     });\n                     e = self.recover_seq_parse_error(token::Paren, lo, seq);\n                 }\n@@ -767,7 +763,7 @@ impl<'a> Parser<'a> {\n                     hi = self.token.span;\n                     self.expect(&token::CloseDelim(token::Bracket))?;\n                     let index = self.mk_index(e, ix);\n-                    e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n+                    e = self.mk_expr(lo.to(hi), index, AttrVec::new())\n                 }\n                 _ => return Ok(e)\n             }\n@@ -791,7 +787,7 @@ impl<'a> Parser<'a> {\n                 args.insert(0, self_arg);\n \n                 let span = lo.to(self.prev_span);\n-                self.mk_expr(span, ExprKind::MethodCall(segment, args), ThinVec::new())\n+                self.mk_expr(span, ExprKind::MethodCall(segment, args), AttrVec::new())\n             }\n             _ => {\n                 // Field access `expr.f`\n@@ -801,7 +797,7 @@ impl<'a> Parser<'a> {\n                 }\n \n                 let span = lo.to(self.prev_span);\n-                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), ThinVec::new())\n+                self.mk_expr(span, ExprKind::Field(self_arg, segment.ident), AttrVec::new())\n             }\n         })\n     }\n@@ -820,7 +816,7 @@ impl<'a> Parser<'a> {\n         //\n         // Therefore, prevent sub-parser from parsing\n         // attributes by giving them a empty \"already-parsed\" list.\n-        let attrs = ThinVec::new();\n+        let attrs = AttrVec::new();\n \n         // Note: when adding new syntax here, don't forget to adjust `TokenKind::can_begin_expr()`.\n         let lo = self.token.span;\n@@ -909,7 +905,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_lit_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_lit_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         match self.parse_opt_lit() {\n             Some(literal) => {\n@@ -920,7 +916,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_tuple_parens_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_tuple_parens_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         let mut first = true;\n         let parse_leading_attr_expr = |p: &mut Self| {\n@@ -947,10 +943,7 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n-    fn parse_array_or_repeat_expr(\n-        &mut self,\n-        mut attrs: ThinVec<Attribute>,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_array_or_repeat_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.bump(); // `[`\n \n@@ -990,7 +983,7 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n-    fn parse_path_start_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_path_start_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         let path = self.parse_path(PathStyle::Expr)?;\n \n@@ -1017,11 +1010,7 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n-    fn parse_labeled_expr(\n-        &mut self,\n-        label: Label,\n-        attrs: ThinVec<Attribute>,\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_labeled_expr(&mut self, label: Label, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = label.ident.span;\n         self.expect(&token::Colon)?;\n         if self.eat_keyword(kw::While) {\n@@ -1046,7 +1035,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n-    fn recover_do_catch(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn recover_do_catch(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n@@ -1076,15 +1065,15 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"return\" expr?`.\n-    fn parse_return_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_return_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n         let expr = self.mk_expr(lo.to(self.prev_span), kind, attrs);\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n     /// Parse `\"('label \":\")? break expr?`.\n-    fn parse_break_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_break_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         let label = self.eat_label();\n         let kind = if self.token != token::OpenDelim(token::Brace)\n@@ -1099,7 +1088,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"yield\" expr?`.\n-    fn parse_yield_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_yield_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         let kind = ExprKind::Yield(self.parse_expr_opt()?);\n         let span = lo.to(self.prev_span);\n@@ -1307,12 +1296,12 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let literal = self.parse_lit()?;\n         let hi = self.prev_span;\n-        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n+        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), AttrVec::new());\n \n         if minus_present {\n             let minus_hi = self.prev_span;\n             let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, ThinVec::new()))\n+            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, AttrVec::new()))\n         } else {\n             Ok(expr)\n         }\n@@ -1324,7 +1313,7 @@ impl<'a> Parser<'a> {\n         opt_label: Option<Label>,\n         lo: Span,\n         blk_mode: BlockCheckMode,\n-        outer_attrs: ThinVec<Attribute>,\n+        outer_attrs: AttrVec,\n     ) -> PResult<'a, P<Expr>> {\n         if let Some(label) = opt_label {\n             self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n@@ -1340,7 +1329,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a closure expression (e.g., `move |args| expr`).\n-    fn parse_closure_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_closure_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         let movability = if self.eat_keyword(kw::Static) {\n@@ -1370,7 +1359,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 // If an explicit return type is given, require a block to appear (RFC 968).\n                 let body_lo = self.token.span;\n-                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, ThinVec::new())?\n+                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, AttrVec::new())?\n             }\n         };\n \n@@ -1440,7 +1429,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `if` expression (`if` token already eaten).\n-    fn parse_if_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_if_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         let cond = self.parse_cond_expr()?;\n \n@@ -1486,7 +1475,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `let $pat = $expr` pseudo-expression.\n     /// The `let` token has already been eaten.\n-    fn parse_let_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n         let pat = self.parse_top_pat(GateOr::No)?;\n         self.expect(&token::Eq)?;\n@@ -1502,10 +1491,10 @@ impl<'a> Parser<'a> {\n     /// Parses an `else { ... }` expression (`else` token already eaten).\n     fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n         if self.eat_keyword(kw::If) {\n-            return self.parse_if_expr(ThinVec::new());\n+            return self.parse_if_expr(AttrVec::new());\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), ThinVec::new()));\n+            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()));\n         }\n     }\n \n@@ -1514,7 +1503,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         opt_label: Option<Label>,\n         span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n+        mut attrs: AttrVec\n     ) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n@@ -1556,7 +1545,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         opt_label: Option<Label>,\n         span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n+        mut attrs: AttrVec\n     ) -> PResult<'a, P<Expr>> {\n         let cond = self.parse_cond_expr()?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n@@ -1570,7 +1559,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         opt_label: Option<Label>,\n         span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n+        mut attrs: AttrVec\n     ) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n@@ -1589,7 +1578,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n-    fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_match_expr(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n         let lo = self.prev_span;\n         let discriminant = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n@@ -1701,11 +1690,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `try {...}` expression (`try` token already eaten).\n-    fn parse_try_block(\n-        &mut self,\n-        span_lo: Span,\n-        mut attrs: ThinVec<Attribute>\n-    ) -> PResult<'a, P<Expr>> {\n+    fn parse_try_block(&mut self, span_lo: Span, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         if self.eat_keyword(kw::Catch) {\n@@ -1737,7 +1722,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `async move? {...}` expression.\n-    fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_async_block(&mut self, mut attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let span_lo = self.token.span;\n         self.expect_keyword(kw::Async)?;\n         let capture_clause = self.parse_capture_clause();\n@@ -1764,7 +1749,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         path: &ast::Path,\n-        attrs: &ThinVec<Attribute>,\n+        attrs: &AttrVec,\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n         let certainly_not_a_block = || self.look_ahead(1, |t| t.is_ident()) && (\n@@ -1805,7 +1790,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         pth: ast::Path,\n-        mut attrs: ThinVec<Attribute>\n+        mut attrs: AttrVec\n     ) -> PResult<'a, P<Expr>> {\n         let struct_sp = lo.to(self.prev_span);\n         self.bump();\n@@ -1851,9 +1836,9 @@ impl<'a> Parser<'a> {\n                     recovery_field = Some(ast::Field {\n                         ident: Ident::new(name, self.token.span),\n                         span: self.token.span,\n-                        expr: self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()),\n+                        expr: self.mk_expr(self.token.span, ExprKind::Err, AttrVec::new()),\n                         is_shorthand: false,\n-                        attrs: ThinVec::new(),\n+                        attrs: AttrVec::new(),\n                         id: DUMMY_NODE_ID,\n                         is_placeholder: false,\n                     });\n@@ -1932,7 +1917,7 @@ impl<'a> Parser<'a> {\n \n             // Mimic `x: x` for the `x` field shorthand.\n             let path = ast::Path::from_ident(fieldname);\n-            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), ThinVec::new());\n+            let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), AttrVec::new());\n             (fieldname, expr, true)\n         };\n         Ok(ast::Field {\n@@ -2009,16 +1994,16 @@ impl<'a> Parser<'a> {\n \n     fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let span = lo.to(self.prev_span);\n-        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), ThinVec::new());\n+        let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), AttrVec::new());\n         self.recover_from_await_method_call();\n         Ok(await_expr)\n     }\n \n-    crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+    crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n         P(Expr { kind, span, attrs, id: DUMMY_NODE_ID })\n     }\n \n     pub(super) fn mk_expr_err(&self, span: Span) -> P<Expr> {\n-        self.mk_expr(span, ExprKind::Err, ThinVec::new())\n+        self.mk_expr(span, ExprKind::Err, AttrVec::new())\n     }\n }"}, {"sha": "229ca07f13b51a4063610e4249f36c257b7ec986", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -5,15 +5,14 @@ use crate::maybe_whole;\n \n use rustc_errors::{PResult, Applicability, DiagnosticBuilder, StashKey};\n use rustc_error_codes::*;\n-use syntax::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n-use syntax::ast::{AssocItem, AssocItemKind, ItemKind, UseTree, UseTreeKind};\n+use syntax::ast::{self, DUMMY_NODE_ID, Ident, AttrVec, Attribute, AttrKind, AttrStyle, AnonConst};\n+use syntax::ast::{AssocItem, AssocItemKind, Item, ItemKind, UseTree, UseTreeKind};\n use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, Variant, VariantData, StructField};\n use syntax::ast::{Mac, MacArgs, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::ThinVec;\n use syntax::token;\n use syntax::tokenstream::{DelimSpan, TokenTree, TokenStream};\n use syntax::struct_span_err;\n@@ -2095,7 +2094,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let eself = source_map::respan(eself_lo.to(eself_hi), eself);\n-        Ok(Some(Param::from_self(ThinVec::default(), eself, eself_ident)))\n+        Ok(Some(Param::from_self(AttrVec::default(), eself, eself_ident)))\n     }\n \n     fn is_named_param(&self) -> bool {"}, {"sha": "938c2d89857db823e3a2b380a7891c1a1809332d", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -15,9 +15,8 @@ use crate::{Directory, DirectoryOwnership};\n use crate::lexer::UnmatchedBrace;\n \n use rustc_errors::{PResult, Applicability, DiagnosticBuilder, FatalError};\n-use rustc_data_structures::thin_vec::ThinVec;\n-use syntax::ast::{self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Extern, Ident, StrLit};\n-use syntax::ast::{IsAsync, MacArgs, MacDelimiter, Mutability, Visibility, VisibilityKind, Unsafety};\n+use syntax::ast::{self, DUMMY_NODE_ID, AttrVec, AttrStyle, CrateSugar, Extern, Ident, Unsafety};\n+use syntax::ast::{StrLit, IsAsync, MacArgs, MacDelimiter, Mutability, Visibility, VisibilityKind};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::token::{self, Token, TokenKind, DelimToken};\n@@ -1054,8 +1053,8 @@ impl<'a> Parser<'a> {\n \n     fn parse_or_use_outer_attributes(\n         &mut self,\n-        already_parsed_attrs: Option<ThinVec<Attribute>>,\n-    ) -> PResult<'a, ThinVec<Attribute>> {\n+        already_parsed_attrs: Option<AttrVec>,\n+    ) -> PResult<'a, AttrVec> {\n         if let Some(attrs) = already_parsed_attrs {\n             Ok(attrs)\n         } else {"}, {"sha": "593fb30bb752a540d779eb523130e820d299f75f", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -1,12 +1,11 @@\n use super::{Parser, PathStyle};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_errors::{PResult, Applicability, DiagnosticBuilder};\n-use syntax::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac};\n+use syntax::ast::{self, AttrVec, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac};\n use syntax::ast::{BindingMode, Ident, Mutability, Path, QSelf, Expr, ExprKind};\n use syntax::mut_visit::{noop_visit_pat, noop_visit_mac, MutVisitor};\n use syntax::ptr::P;\n use syntax::print::pprust;\n-use syntax::ThinVec;\n use syntax::token;\n use syntax_pos::source_map::{respan, Span, Spanned};\n use syntax_pos::symbol::{kw, sym};\n@@ -636,7 +635,7 @@ impl<'a> Parser<'a> {\n         let op_span = self.token.span;\n         // Parse range\n         let span = lo.to(self.prev_span);\n-        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n+        let begin = self.mk_expr(span, ExprKind::Path(qself, path), AttrVec::new());\n         self.bump();\n         let end = self.parse_pat_range_end_opt(&begin, form)?;\n         Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n@@ -693,7 +692,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_span;\n         let end = self.parse_pat_range_end()?;\n         let range_span = lo.to(end.span);\n-        let begin = self.mk_expr(range_span, ExprKind::Err, ThinVec::new());\n+        let begin = self.mk_expr(range_span, ExprKind::Err, AttrVec::new());\n \n         self.diagnostic()\n             .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n@@ -731,7 +730,7 @@ impl<'a> Parser<'a> {\n                 )\n                 .emit();\n \n-            Ok(self.mk_expr(range_span, ExprKind::Err, ThinVec::new()))\n+            Ok(self.mk_expr(range_span, ExprKind::Err, AttrVec::new()))\n         }\n     }\n \n@@ -747,7 +746,7 @@ impl<'a> Parser<'a> {\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n             let hi = self.prev_span;\n-            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), ThinVec::new()))\n+            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), AttrVec::new()))\n         } else {\n             self.parse_literal_maybe_minus()\n         }"}, {"sha": "802d38e2997128b2b7dcd57ce2ad745d6ff20dd7", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -3,7 +3,6 @@ use crate::maybe_whole;\n use rustc_errors::{PResult, Applicability, pluralize};\n use syntax::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n use syntax::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n-use syntax::ThinVec;\n use syntax::token::{self, Token};\n use syntax_pos::source_map::{Span, BytePos};\n use syntax_pos::symbol::{kw, sym};\n@@ -400,7 +399,7 @@ impl<'a> Parser<'a> {\n                 // Parse const argument.\n                 let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n                     self.parse_block_expr(\n-                        None, self.token.span, BlockCheckMode::Default, ThinVec::new()\n+                        None, self.token.span, BlockCheckMode::Default, ast::AttrVec::new()\n                     )?\n                 } else if self.token.is_ident() {\n                     // FIXME(const_generics): to distinguish between idents for types and consts,"}, {"sha": "a080806311613c861bb31c4475c3595013dbf9c8", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -7,11 +7,10 @@ use crate::maybe_whole;\n use crate::DirectoryOwnership;\n \n use rustc_errors::{PResult, Applicability};\n-use syntax::ThinVec;\n use syntax::ptr::P;\n use syntax::ast;\n use syntax::ast::{DUMMY_NODE_ID, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n-use syntax::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac};\n+use syntax::ast::{AttrVec, Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac};\n use syntax::util::classify;\n use syntax::token;\n use syntax_pos::source_map::{respan, Span};\n@@ -67,10 +66,10 @@ impl<'a> Parser<'a> {\n             }\n \n             let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-                self.parse_struct_expr(lo, path, ThinVec::new())?\n+                self.parse_struct_expr(lo, path, AttrVec::new())?\n             } else {\n                 let hi = self.prev_span;\n-                self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new())\n+                self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n             };\n \n             let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n@@ -104,7 +103,7 @@ impl<'a> Parser<'a> {\n             let kind = StmtKind::Semi(self.mk_expr(\n                 lo.to(last_semi),\n                 ExprKind::Tup(Vec::new()),\n-                ThinVec::new()\n+                AttrVec::new()\n             ));\n             return Ok(Some(self.mk_stmt(lo.to(last_semi), kind)));\n         }\n@@ -124,7 +123,7 @@ impl<'a> Parser<'a> {\n     fn parse_stmt_mac(\n         &mut self,\n         lo: Span,\n-        attrs: ThinVec<Attribute>,\n+        attrs: AttrVec,\n         path: ast::Path,\n         legacy_warnings: bool,\n     ) -> PResult<'a, Option<Stmt>> {\n@@ -169,7 +168,7 @@ impl<'a> Parser<'a> {\n             StmtKind::Mac(P((mac, style, attrs)))\n         } else {\n             // Since none of the above applied, this is an expression statement macro.\n-            let e = self.mk_expr(lo.to(hi), ExprKind::Mac(mac), ThinVec::new());\n+            let e = self.mk_expr(lo.to(hi), ExprKind::Mac(mac), AttrVec::new());\n             let e = self.maybe_recover_from_bad_qpath(e, true)?;\n             let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n@@ -191,7 +190,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a local variable declaration.\n-    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n+    fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n         let lo = self.prev_span;\n         let pat = self.parse_top_pat(GateOr::Yes)?;\n "}, {"sha": "c1458236788cb11b9f3b6a8b7b1b2c46dcd0a647", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -338,7 +338,7 @@ pub enum GenericParamKind {\n pub struct GenericParam {\n     pub id: NodeId,\n     pub ident: Ident,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub bounds: GenericBounds,\n     pub is_placeholder: bool,\n     pub kind: GenericParamKind,\n@@ -599,7 +599,7 @@ pub struct FieldPat {\n     /// The pattern the field is destructured to\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub id: NodeId,\n     pub span: Span,\n     pub is_placeholder: bool,\n@@ -911,7 +911,7 @@ pub enum StmtKind {\n     /// Expr with a trailing semi-colon.\n     Semi(P<Expr>),\n     /// Macro.\n-    Mac(P<(Mac, MacStmtStyle, ThinVec<Attribute>)>),\n+    Mac(P<(Mac, MacStmtStyle, AttrVec)>),\n }\n \n #[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n@@ -936,7 +936,7 @@ pub struct Local {\n     /// Initializer expression to set the value, if any.\n     pub init: Option<P<Expr>>,\n     pub span: Span,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n }\n \n /// An arm of a 'match'.\n@@ -966,7 +966,7 @@ pub struct Arm {\n /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Field {\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub id: NodeId,\n     pub span: Span,\n     pub ident: Ident,\n@@ -1004,7 +1004,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub kind: ExprKind,\n     pub span: Span,\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -1961,7 +1961,7 @@ pub struct InlineAsm {\n /// E.g., `bar: usize` as in `fn foo(bar: usize)`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Param {\n-    pub attrs: ThinVec<Attribute>,\n+    pub attrs: AttrVec,\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n@@ -2014,7 +2014,7 @@ impl Param {\n     }\n \n     /// Builds a `Param` object from `ExplicitSelf`.\n-    pub fn from_self(attrs: ThinVec<Attribute>, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n+    pub fn from_self(attrs: AttrVec, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n@@ -2332,6 +2332,9 @@ pub struct AttrItem {\n     pub args: MacArgs,\n }\n \n+/// A list of attributes.\n+pub type AttrVec = ThinVec<Attribute>;\n+\n /// Metadata associated with an item.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Attribute {"}, {"sha": "ae6d50ba083074adb83af7fbaaa9d0b22fa347bb", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -9,15 +9,14 @@ pub use StabilityLevel::*;\n pub use crate::ast::Attribute;\n \n use crate::ast;\n-use crate::ast::{AttrItem, AttrId, AttrKind, AttrStyle, Name, Ident, Path, PathSegment};\n+use crate::ast::{AttrVec, AttrItem, AttrId, AttrKind, AttrStyle, Name, Ident, Path, PathSegment};\n use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n use crate::source_map::{BytePos, Spanned};\n use crate::token::{self, Token};\n use crate::ptr::P;\n use crate::symbol::{sym, Symbol};\n-use crate::ThinVec;\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use crate::GLOBALS;\n \n@@ -665,7 +664,7 @@ impl HasAttrs for Vec<Attribute> {\n     }\n }\n \n-impl HasAttrs for ThinVec<Attribute> {\n+impl HasAttrs for AttrVec {\n     fn attrs(&self) -> &[Attribute] {\n         self\n     }"}, {"sha": "30fd23ea909acb375cca7ff0d6fb97a210efa6bb", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -24,7 +24,6 @@\n pub use errors;\n use rustc_data_structures::sync::Lock;\n use rustc_index::bit_set::GrowableBitSet;\n-pub use rustc_data_structures::thin_vec::ThinVec;\n use ast::AttrId;\n use syntax_pos::edition::Edition;\n "}, {"sha": "1d27f70f5a5443aa3d147024c1c668f4f534a48c", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -11,7 +11,6 @@ use crate::ast::*;\n use crate::source_map::{Spanned, respan};\n use crate::token::{self, Token};\n use crate::ptr::P;\n-use crate::ThinVec;\n use crate::tokenstream::*;\n use crate::util::map_in_place::MapInPlace;\n \n@@ -337,7 +336,7 @@ pub fn visit_attrs<T: MutVisitor>(attrs: &mut Vec<Attribute>, vis: &mut T) {\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_thin_attrs<T: MutVisitor>(attrs: &mut ThinVec<Attribute>, vis: &mut T) {\n+pub fn visit_thin_attrs<T: MutVisitor>(attrs: &mut AttrVec, vis: &mut T) {\n     for attr in attrs.iter_mut() {\n         vis.visit_attribute(attr);\n     }"}, {"sha": "2ad327e872e15f04cfc29c210b5641075640ba58", "filename": "src/libsyntax_expand/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbase.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -9,7 +9,6 @@ use syntax::mut_visit::{self, MutVisitor};\n use syntax::ptr::P;\n use syntax::sess::ParseSess;\n use syntax::symbol::{kw, sym, Ident, Symbol};\n-use syntax::ThinVec;\n use syntax::token;\n use syntax::tokenstream::{self, TokenStream};\n use syntax::visit::Visitor;\n@@ -552,7 +551,7 @@ impl DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             kind: if is_error { ast::ExprKind::Err } else { ast::ExprKind::Tup(Vec::new()) },\n             span: sp,\n-            attrs: ThinVec::new(),\n+            attrs: ast::AttrVec::new(),\n         })\n     }\n "}, {"sha": "4c539cad111a01ef3b60de6f8c07cb217ed3141c", "filename": "src/libsyntax_expand/build.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbuild.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -1,11 +1,10 @@\n use crate::base::ExtCtxt;\n \n-use syntax::ast::{self, Ident, Expr, BlockCheckMode, UnOp, PatKind};\n+use syntax::ast::{self, AttrVec, Ident, Expr, BlockCheckMode, UnOp, PatKind};\n use syntax::attr;\n use syntax::source_map::{respan, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n-use syntax::ThinVec;\n \n use syntax_pos::{Pos, Span};\n \n@@ -81,7 +80,7 @@ impl<'a> ExtCtxt<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 kind,\n                 span,\n-                attrs: ThinVec::new(),\n+                attrs: AttrVec::new(),\n             })\n         }\n     }\n@@ -190,7 +189,7 @@ impl<'a> ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -207,7 +206,7 @@ impl<'a> ExtCtxt<'a> {\n             init: None,\n             id: ast::DUMMY_NODE_ID,\n             span,\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -245,7 +244,7 @@ impl<'a> ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             kind,\n             span,\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n         })\n     }\n \n@@ -304,7 +303,7 @@ impl<'a> ExtCtxt<'a> {\n             expr: e,\n             span,\n             is_shorthand: false,\n-            attrs: ThinVec::new(),\n+            attrs: AttrVec::new(),\n             id: ast::DUMMY_NODE_ID,\n             is_placeholder: false,\n         }\n@@ -549,7 +548,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn param(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Param {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::Param {\n-            attrs: ThinVec::default(),\n+            attrs: AttrVec::default(),\n             id: ast::DUMMY_NODE_ID,\n             pat: arg_pat,\n             span,"}, {"sha": "4298e0e74b6e613f1b16a360fceb67c58556447c", "filename": "src/libsyntax_expand/placeholders.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fplaceholders.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -5,7 +5,6 @@ use syntax::ast;\n use syntax::source_map::{DUMMY_SP, dummy_spanned};\n use syntax::mut_visit::*;\n use syntax::ptr::P;\n-use syntax::ThinVec;\n \n use smallvec::{smallvec, SmallVec};\n \n@@ -28,7 +27,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId, vis: Option<ast::Visi\n     let span = DUMMY_SP;\n     let expr_placeholder = || P(ast::Expr {\n         id, span,\n-        attrs: ThinVec::new(),\n+        attrs: ast::AttrVec::new(),\n         kind: ast::ExprKind::Mac(mac_placeholder()),\n     });\n     let ty = || P(ast::Ty {\n@@ -75,7 +74,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId, vis: Option<ast::Visi\n             id, span, kind: ast::TyKind::Mac(mac_placeholder()),\n         })),\n         AstFragmentKind::Stmts => AstFragment::Stmts(smallvec![{\n-            let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ThinVec::new()));\n+            let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ast::AttrVec::new()));\n             ast::Stmt { id, span, kind: ast::StmtKind::Mac(mac) }\n         }]),\n         AstFragmentKind::Arms => AstFragment::Arms(smallvec!["}, {"sha": "5ec24b7a7acc5156ed968e2921f4ef747fccd559", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -3,7 +3,6 @@\n use State::*;\n \n use errors::{DiagnosticBuilder, PResult};\n-use rustc_data_structures::thin_vec::ThinVec;\n use rustc_parse::parser::Parser;\n use syntax_expand::base::*;\n use syntax_pos::Span;\n@@ -63,7 +62,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         id: ast::DUMMY_NODE_ID,\n         kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n         span: cx.with_def_site_ctxt(sp),\n-        attrs: ThinVec::new(),\n+        attrs: ast::AttrVec::new(),\n     }))\n }\n "}, {"sha": "7d8bc8b87bc2b83b3b802f4c6ea6f1a9c76fa1c1", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -1,5 +1,3 @@\n-use rustc_data_structures::thin_vec::ThinVec;\n-\n use syntax::ast;\n use syntax_expand::base::{self, *};\n use syntax::token::{self, Token};\n@@ -49,7 +47,7 @@ pub fn expand_concat_idents<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                 id: ast::DUMMY_NODE_ID,\n                 kind: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n-                attrs: ThinVec::new(),\n+                attrs: ast::AttrVec::new(),\n             }))\n         }\n "}, {"sha": "132ce76e1bb6dbcaa868e890e0680deac11d60d8", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -2,8 +2,6 @@ use crate::deriving::path_std;\n use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n-\n use syntax::ast::{self, Ident};\n use syntax::ast::{Expr, MetaItem};\n use syntax_expand::base::{Annotatable, ExtCtxt};\n@@ -127,7 +125,7 @@ fn stmt_let_undescore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast\n         init: Some(expr),\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n-        attrs: ThinVec::new(),\n+        attrs: ast::AttrVec::new(),\n     });\n     ast::Stmt {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "5158a5b3da217791af03505860f0591968b09130", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d20935cc7dc9057c683bb62a4ba74475f32aa2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=a0d20935cc7dc9057c683bb62a4ba74475f32aa2", "patch": "@@ -181,7 +181,6 @@ use std::cell::RefCell;\n use std::iter;\n use std::vec;\n \n-use rustc_data_structures::thin_vec::ThinVec;\n use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n@@ -919,7 +918,7 @@ impl<'a> MethodDef<'a> {\n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n                 let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(trait_.span);\n-                ast::Param::from_self(ThinVec::default(), explicit_self, ident)\n+                ast::Param::from_self(ast::AttrVec::default(), explicit_self, ident)\n             });\n             let nonself_args = arg_types.into_iter()\n                 .map(|(name, ty)| cx.param(trait_.span, name, ty));\n@@ -1608,7 +1607,7 @@ impl<'a> TraitDef<'a> {\n                         ast::FieldPat {\n                             ident: ident.unwrap(),\n                             is_shorthand: false,\n-                            attrs: ThinVec::new(),\n+                            attrs: ast::AttrVec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             span: pat.span.with_ctxt(self.span.ctxt()),\n                             pat,"}]}