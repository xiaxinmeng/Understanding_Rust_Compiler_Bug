{"sha": "9f9ac89d11a2afaeaa029738b38142124684c89b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOWFjODlkMTFhMmFmYWVhYTAyOTczOGIzODE0MjEyNDY4NGM4OWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-05T09:17:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-05T09:17:24Z"}, "message": "Auto merge of #52959 - matthewjasper:closure-spans, r=pnkfelix\n\n[NLL] Use smaller spans for errors involving closure captures\n\nCloses #51170\nCloses #46599\n\nError messages involving closures now point to the captured variable/closure args.\n\nr? @pnkfelix", "tree": {"sha": "0d9fcf71b1edf9f45ad14dd9c666dbccb5850444", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d9fcf71b1edf9f45ad14dd9c666dbccb5850444"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f9ac89d11a2afaeaa029738b38142124684c89b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f9ac89d11a2afaeaa029738b38142124684c89b", "html_url": "https://github.com/rust-lang/rust/commit/9f9ac89d11a2afaeaa029738b38142124684c89b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f9ac89d11a2afaeaa029738b38142124684c89b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b47c314c5652c8ecc3f086b0326f467b857b9d5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b47c314c5652c8ecc3f086b0326f467b857b9d5b", "html_url": "https://github.com/rust-lang/rust/commit/b47c314c5652c8ecc3f086b0326f467b857b9d5b"}, {"sha": "12af36a5c4638755be622c220efadffb1864f2ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/12af36a5c4638755be622c220efadffb1864f2ab", "html_url": "https://github.com/rust-lang/rust/commit/12af36a5c4638755be622c220efadffb1864f2ab"}], "stats": {"total": 1583, "additions": 1253, "deletions": 330}, "files": [{"sha": "aabed6686858fddf6fe579d235b019a4130454f0", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 359, "deletions": 160, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -10,13 +10,14 @@\n \n use borrow_check::WriteKind;\n use rustc::middle::region::ScopeTree;\n+use rustc::mir::VarBindingForm;\n use rustc::mir::{BindingForm, BorrowKind, ClearCrossCrate, Field, Local};\n use rustc::mir::{LocalDecl, LocalKind, Location, Operand, Place};\n use rustc::mir::{ProjectionElem, Rvalue, Statement, StatementKind};\n-use rustc::mir::VarBindingForm;\n use rustc::ty;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n+use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n use super::borrow_set::BorrowData;\n@@ -30,12 +31,17 @@ use util::borrowck_errors::{BorrowckErrors, Origin};\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_use_of_moved_or_uninitialized(\n         &mut self,\n-        _context: Context,\n+        context: Context,\n         desired_action: InitializationRequiringAction,\n         (place, span): (&Place<'tcx>, Span),\n         mpi: MovePathIndex,\n         curr_move_out: &FlowAtLocation<MovingOutStatements<'_, 'gcx, 'tcx>>,\n     ) {\n+        let use_spans = self\n+            .move_spans(place, context.loc)\n+            .or_else(|| self.borrow_spans(span, context.loc));\n+        let span = use_spans.args_or_use();\n+\n         let mois = self.move_data.path_map[mpi]\n             .iter()\n             .filter(|moi| curr_move_out.contains(moi))\n@@ -58,16 +64,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n-            let mut err = self.tcx\n-                .cannot_act_on_uninitialized_variable(\n-                    span,\n-                    desired_action.as_noun(),\n-                    &self\n-                        .describe_place_with_options(place, IncludingDowncast(true))\n-                        .unwrap_or(\"_\".to_owned()),\n-                    Origin::Mir,\n-                );\n+            let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n+                span,\n+                desired_action.as_noun(),\n+                &self\n+                    .describe_place_with_options(place, IncludingDowncast(true))\n+                    .unwrap_or(\"_\".to_owned()),\n+                Origin::Mir,\n+            );\n             err.span_label(span, format!(\"use of possibly uninitialized {}\", item_msg));\n+\n+            use_spans.var_span_label(\n+                &mut err,\n+                format!(\"{} occurs due to use in closure\", desired_action.as_noun()),\n+            );\n+\n             err.buffer(&mut self.errors_buffer);\n         } else {\n             let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n@@ -82,11 +93,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             let mut is_loop_move = false;\n             for moi in &mois {\n-                let move_msg = \"\"; //FIXME: add \" (into closure)\"\n-                let move_span = self\n-                    .mir\n-                    .source_info(self.move_data.moves[**moi].source)\n-                    .span;\n+                let move_out = self.move_data.moves[**moi];\n+                let moved_place = &self.move_data.move_paths[move_out.path].place;\n+\n+                let move_spans = self.move_spans(moved_place, move_out.source);\n+                let move_span = move_spans.args_or_use();\n+\n+                let move_msg = if move_spans.for_closure() {\n+                    \" into closure\"\n+                } else {\n+                    \"\"\n+                };\n+\n                 if span == move_span {\n                     err.span_label(\n                         span,\n@@ -95,8 +113,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     is_loop_move = true;\n                 } else {\n                     err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                    move_spans.var_span_label(&mut err, \"variable moved due to use in closure\");\n                 };\n             }\n+\n+            use_spans.var_span_label(\n+                &mut err,\n+                format!(\"{} occurs due to use in closure\", desired_action.as_noun()),\n+            );\n+\n             if !is_loop_move {\n                 err.span_label(\n                     span,\n@@ -150,7 +175,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_move_out_while_borrowed(\n         &mut self,\n         context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n         let tcx = self.tcx;\n@@ -162,109 +187,64 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.args_or_use();\n+\n+        let move_spans = self.move_spans(place, context.loc);\n+        let span = move_spans.args_or_use();\n+\n         let mut err = tcx.cannot_move_when_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n-        err.span_label(\n-            self.retrieve_borrow_span(borrow),\n-            format!(\"borrow of {} occurs here\", borrow_msg),\n-        );\n+        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n+\n+        borrow_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n+\n+        move_spans.var_span_label(&mut err, \"move occurs due to use in closure\");\n+\n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n     pub(super) fn report_use_while_mutably_borrowed(\n         &mut self,\n         context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n+        (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n         let tcx = self.tcx;\n+\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.args_or_use();\n+\n+        // Conflicting borrows are reported separately, so only check for move\n+        // captures.\n+        let use_spans = self.move_spans(place, context.loc);\n+        let span = use_spans.var_or_use();\n+\n         let mut err = tcx.cannot_use_when_mutably_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            self.retrieve_borrow_span(borrow),\n+            borrow_span,\n             &self\n                 .describe_place(&borrow.borrowed_place)\n                 .unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n \n-        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-        err.buffer(&mut self.errors_buffer);\n-    }\n-\n-    /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n-    /// the local assigned at `location`.\n-    /// This is done by searching in statements succeeding `location`\n-    /// and originating from `maybe_closure_span`.\n-    pub(super) fn find_closure_span(\n-        &self,\n-        maybe_closure_span: Span,\n-        location: Location,\n-    ) -> Option<(Span, Span)> {\n-        use rustc::hir::ExprKind::Closure;\n-        use rustc::mir::AggregateKind;\n-\n-        let local = match self.mir[location.block]\n-            .statements\n-            .get(location.statement_index)\n-        {\n-            Some(&Statement {\n-                kind: StatementKind::Assign(Place::Local(local), _),\n-                ..\n-            }) => local,\n-            _ => return None,\n-        };\n-\n-        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if maybe_closure_span != stmt.source_info.span {\n-                break;\n-            }\n+        borrow_spans.var_span_label(&mut err, {\n+            let place = &borrow.borrowed_place;\n+            let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n \n-            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n-                if let AggregateKind::Closure(def_id, _) = **kind {\n-                    debug!(\"find_closure_span: found closure {:?}\", places);\n+            format!(\"borrow occurs due to use of `{}` in closure\", desc_place)\n+        });\n \n-                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        let args_span = if let Closure(_, _, _, span, _) =\n-                            self.tcx.hir.expect_expr(node_id).node\n-                        {\n-                            span\n-                        } else {\n-                            return None;\n-                        };\n-\n-                        self.tcx\n-                            .with_freevars(node_id, |freevars| {\n-                                for (v, place) in freevars.iter().zip(places) {\n-                                    match *place {\n-                                        Operand::Copy(Place::Local(l))\n-                                        | Operand::Move(Place::Local(l)) if local == l =>\n-                                        {\n-                                            debug!(\n-                                                \"find_closure_span: found captured local {:?}\",\n-                                                l\n-                                            );\n-                                            return Some(v.span);\n-                                        }\n-                                        _ => {}\n-                                    }\n-                                }\n-                                None\n-                            })\n-                            .map(|var_span| (args_span, var_span))\n-                    } else {\n-                        None\n-                    };\n-                }\n-            }\n-        }\n-\n-        None\n+        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     pub(super) fn report_conflicting_borrow(\n@@ -274,14 +254,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData<'tcx>,\n     ) {\n-        let issued_span = self.retrieve_borrow_span(issued_borrow);\n+        let issued_spans = self.retrieve_borrow_spans(issued_borrow);\n+        let issued_span = issued_spans.args_or_use();\n \n-        let new_closure_span = self.find_closure_span(span, context.loc);\n-        let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n-        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.reserve_location);\n-        let issued_span = old_closure_span\n-            .map(|(args, _)| args)\n-            .unwrap_or(issued_span);\n+        let borrow_spans = self.borrow_spans(span, context.loc);\n+        let span = borrow_spans.args_or_use();\n \n         let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n         let tcx = self.tcx;\n@@ -368,23 +345,28 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n         };\n \n-        if let Some((_, var_span)) = old_closure_span {\n-            let place = &issued_borrow.borrowed_place;\n-            let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n-\n-            err.span_label(\n-                var_span,\n+        if issued_spans == borrow_spans {\n+            borrow_spans.var_span_label(\n+                &mut err,\n                 format!(\n-                    \"previous borrow occurs due to use of `{}` in closure\",\n+                    \"borrows occur due to use of `{}` in closure\",\n                     desc_place\n                 ),\n             );\n-        }\n+        } else {\n+            let borrow_place = &issued_borrow.borrowed_place;\n+            let borrow_place_desc = self.describe_place(borrow_place).unwrap_or(\"_\".to_owned());\n+            issued_spans.var_span_label(\n+                &mut err,\n+                format!(\n+                    \"first borrow occurs due to use of `{}` in closure\",\n+                    borrow_place_desc\n+                ),\n+            );\n \n-        if let Some((_, var_span)) = new_closure_span {\n-            err.span_label(\n-                var_span,\n-                format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n+            borrow_spans.var_span_label(\n+                &mut err,\n+                format!(\"second borrow occurs due to use of `{}` in closure\", desc_place),\n             );\n         }\n \n@@ -407,7 +389,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .last()\n             .unwrap();\n \n-        let borrow_span = self.mir.source_info(borrow.reserve_location).span;\n+        let borrow_spans = self.retrieve_borrow_spans(borrow);\n+        let borrow_span = borrow_spans.var_or_use();\n+\n         let proper_span = match *root_place {\n             Place::Local(local) => self.mir.local_decls[local].source_info.span,\n             _ => drop_span,\n@@ -427,30 +411,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.access_place_error_reported\n             .insert((root_place.clone(), borrow_span));\n \n-        match &self.describe_place(&borrow.borrowed_place) {\n-            Some(name) => {\n-                self.report_local_value_does_not_live_long_enough(\n-                    context,\n-                    name,\n-                    &scope_tree,\n-                    &borrow,\n-                    drop_span,\n-                    borrow_span,\n-                    proper_span,\n-                    kind.map(|k| (k, place_span.0)),\n-                );\n-            }\n-            None => {\n-                self.report_temporary_value_does_not_live_long_enough(\n-                    context,\n-                    &scope_tree,\n-                    &borrow,\n-                    drop_span,\n-                    borrow_span,\n-                    proper_span,\n-                );\n-            }\n-        }\n+        let mut err = match &self.describe_place(&borrow.borrowed_place) {\n+            Some(name) => self.report_local_value_does_not_live_long_enough(\n+                context,\n+                name,\n+                &scope_tree,\n+                &borrow,\n+                drop_span,\n+                borrow_span,\n+                proper_span,\n+                kind.map(|k| (k, place_span.0)),\n+            ),\n+            None => self.report_temporary_value_does_not_live_long_enough(\n+                context,\n+                &scope_tree,\n+                &borrow,\n+                drop_span,\n+                borrow_span,\n+                proper_span,\n+            ),\n+        };\n+\n+        borrow_spans.args_span_label(&mut err, \"value captured here\");\n+\n+        err.buffer(&mut self.errors_buffer);\n     }\n \n     fn report_local_value_does_not_live_long_enough(\n@@ -463,7 +447,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         borrow_span: Span,\n         _proper_span: Span,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n-    ) {\n+    ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n@@ -481,7 +465,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         self.explain_why_borrow_contains_point(context, borrow, kind_place, &mut err);\n-        err.buffer(&mut self.errors_buffer);\n+        err\n     }\n \n     fn report_temporary_value_does_not_live_long_enough(\n@@ -492,7 +476,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         _borrow_span: Span,\n         proper_span: Span,\n-    ) {\n+    ) -> DiagnosticBuilder<'cx> {\n         debug!(\n             \"report_temporary_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}\\\n@@ -507,7 +491,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n         self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n-        err.buffer(&mut self.errors_buffer);\n+        err\n     }\n \n     pub(super) fn report_illegal_mutation_of_borrowed(\n@@ -516,14 +500,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         loan: &BorrowData<'tcx>,\n     ) {\n+        let loan_spans = self.retrieve_borrow_spans(loan);\n+        let loan_span = loan_spans.args_or_use();\n+\n         let tcx = self.tcx;\n         let mut err = tcx.cannot_assign_to_borrowed(\n             span,\n-            self.retrieve_borrow_span(loan),\n+            loan_span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n \n+        loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n+\n         self.explain_why_borrow_contains_point(context, loan, None, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n@@ -556,12 +545,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // PATTERN;) then make the error refer to that local, rather than the\n         // place being assigned later.\n         let (place_description, assigned_span) = match local_decl {\n-            Some(LocalDecl { is_user_variable: Some(ClearCrossCrate::Clear), .. })\n-            | Some(LocalDecl { is_user_variable: Some(ClearCrossCrate::Set(\n-                BindingForm::Var(VarBindingForm {\n-                    opt_match_place: None, ..\n-            }))), ..})\n-            | Some(LocalDecl { is_user_variable: None, .. })\n+            Some(LocalDecl {\n+                is_user_variable: Some(ClearCrossCrate::Clear),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                is_user_variable:\n+                    Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                        opt_match_place: None,\n+                        ..\n+                    }))),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                is_user_variable: None,\n+                ..\n+            })\n             | None => (self.describe_place(place), assigned_span),\n             Some(decl) => (self.describe_place(err_place), decl.source_info.span),\n         };\n@@ -647,8 +646,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.tcx);\n+                        let upvar_field_projection =\n+                            place.is_upvar_field_projection(self.mir, &self.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n@@ -666,8 +665,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     &including_downcast,\n                                 )?;\n                             } else if let Place::Local(local) = proj.base {\n-                                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n-                                    = self.mir.local_decls[local].is_user_variable {\n+                                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n+                                    self.mir.local_decls[local].is_user_variable\n+                                {\n                                     self.append_place_to_string(\n                                         &proj.base,\n                                         buf,\n@@ -708,8 +708,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n \n-                        let upvar_field_projection = place.is_upvar_field_projection(\n-                            self.mir, &self.tcx);\n+                        let upvar_field_projection =\n+                            place.is_upvar_field_projection(self.mir, &self.tcx);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n@@ -810,7 +810,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 ty::TyAdt(def, _) => if def.is_enum() {\n                     field.index().to_string()\n                 } else {\n-                    def.non_enum_variant().fields[field.index()].ident.to_string()\n+                    def.non_enum_variant().fields[field.index()]\n+                        .ident\n+                        .to_string()\n                 },\n                 ty::TyTuple(_) => field.index().to_string(),\n                 ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n@@ -839,11 +841,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Retrieve span of given borrow from the current MIR representation\n-    crate fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n-        self.mir.source_info(borrow.reserve_location).span\n-    }\n-\n     // Retrieve type of a place for the current MIR representation\n     fn retrieve_type_for_place(&self, place: &Place<'tcx>) -> Option<ty::Ty> {\n         match place {\n@@ -860,3 +857,205 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n }\n+\n+// The span(s) associated to a use of a place.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub(super) enum UseSpans {\n+    // The access is caused by capturing a variable for a closure.\n+    ClosureUse {\n+        // The span of the args of the closure, including the `move` keyword if\n+        // it's present.\n+        args_span: Span,\n+        // The span of the first use of the captured variable inside the closure.\n+        var_span: Span\n+    },\n+    // This access has a single span associated to it: common case.\n+    OtherUse(Span),\n+}\n+\n+impl UseSpans {\n+    pub(super) fn args_or_use(self) -> Span {\n+        match self {\n+            UseSpans::ClosureUse {\n+                args_span: span, ..\n+            }\n+            | UseSpans::OtherUse(span) => span,\n+        }\n+    }\n+\n+    pub(super) fn var_or_use(self) -> Span {\n+        match self {\n+            UseSpans::ClosureUse { var_span: span, .. } | UseSpans::OtherUse(span) => span,\n+        }\n+    }\n+\n+    // Add a span label to the arguments of the closure, if it exists.\n+    pub(super) fn args_span_label(self, err: &mut DiagnosticBuilder, message: impl Into<String>) {\n+        if let UseSpans::ClosureUse { args_span, .. } = self {\n+            err.span_label(args_span, message);\n+        }\n+    }\n+\n+    // Add a span label to the use of the captured variable, if it exists.\n+    pub(super) fn var_span_label(self, err: &mut DiagnosticBuilder, message: impl Into<String>) {\n+        if let UseSpans::ClosureUse { var_span, .. } = self {\n+            err.span_label(var_span, message);\n+        }\n+    }\n+\n+    pub(super) fn for_closure(self) -> bool {\n+        match self {\n+            UseSpans::ClosureUse { .. } => true,\n+            UseSpans::OtherUse(_) => false,\n+        }\n+    }\n+\n+    pub(super) fn or_else<F>(self, if_other: F) -> Self\n+    where\n+        F: FnOnce() -> Self,\n+    {\n+        match self {\n+            closure @ UseSpans::ClosureUse { .. } => closure,\n+            UseSpans::OtherUse(_) => if_other(),\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Finds the spans associated to a move or copy of move_place at location.\n+    pub(super) fn move_spans(\n+        &self,\n+        moved_place: &Place<'tcx>, // Could also be an upvar.\n+        location: Location,\n+    ) -> UseSpans {\n+        use self::UseSpans::*;\n+        use rustc::hir::ExprKind::Closure;\n+        use rustc::mir::AggregateKind;\n+\n+        let stmt = match self.mir[location.block]\n+            .statements\n+            .get(location.statement_index)\n+        {\n+            Some(stmt) => stmt,\n+            None => return OtherUse(self.mir.source_info(location).span),\n+        };\n+\n+        if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n+            if let AggregateKind::Closure(def_id, _) = **kind {\n+                debug!(\"find_closure_move_span: found closure {:?}\", places);\n+\n+                if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                    if let Closure(_, _, _, args_span, _) = self.tcx.hir.expect_expr(node_id).node {\n+                        if let Some(var_span) = self.tcx.with_freevars(node_id, |freevars| {\n+                            for (v, place) in freevars.iter().zip(places) {\n+                                match place {\n+                                    Operand::Copy(place) | Operand::Move(place)\n+                                        if moved_place == place =>\n+                                    {\n+                                        debug!(\n+                                            \"find_closure_move_span: found captured local {:?}\",\n+                                            place\n+                                        );\n+                                        return Some(v.span);\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                            None\n+                        }) {\n+                            return ClosureUse {\n+                                args_span,\n+                                var_span,\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return OtherUse(stmt.source_info.span);\n+    }\n+\n+    /// Finds the span of arguments of a closure (within `maybe_closure_span`)\n+    /// and its usage of the local assigned at `location`.\n+    /// This is done by searching in statements succeeding `location`\n+    /// and originating from `maybe_closure_span`.\n+    pub(super) fn borrow_spans(&self, use_span: Span, location: Location) -> UseSpans {\n+        use self::UseSpans::*;\n+        use rustc::hir::ExprKind::Closure;\n+        use rustc::mir::AggregateKind;\n+\n+        let local = match self.mir[location.block]\n+            .statements\n+            .get(location.statement_index)\n+        {\n+            Some(&Statement {\n+                kind: StatementKind::Assign(Place::Local(local), _),\n+                ..\n+            }) => local,\n+            _ => return OtherUse(use_span),\n+        };\n+\n+        if self.mir.local_kind(local) != LocalKind::Temp {\n+            // operands are always temporaries.\n+            return OtherUse(use_span);\n+        }\n+\n+        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n+                if let AggregateKind::Closure(def_id, _) = **kind {\n+                    debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n+\n+                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                        let args_span = if let Closure(_, _, _, span, _) =\n+                            self.tcx.hir.expect_expr(node_id).node\n+                        {\n+                            span\n+                        } else {\n+                            return OtherUse(use_span);\n+                        };\n+\n+                        self.tcx\n+                            .with_freevars(node_id, |freevars| {\n+                                for (v, place) in freevars.iter().zip(places) {\n+                                    match *place {\n+                                        Operand::Copy(Place::Local(l))\n+                                        | Operand::Move(Place::Local(l))\n+                                            if local == l =>\n+                                        {\n+                                            debug!(\n+                                                \"find_closure_borrow_span: found captured local \\\n+                                                 {:?}\",\n+                                                l\n+                                            );\n+                                            return Some(v.span);\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                }\n+                                None\n+                            }).map(|var_span| ClosureUse {\n+                                args_span,\n+                                var_span,\n+                            }).unwrap_or(OtherUse(use_span))\n+                    } else {\n+                        OtherUse(use_span)\n+                    };\n+                }\n+            }\n+\n+            if use_span != stmt.source_info.span {\n+                break;\n+            }\n+        }\n+\n+        OtherUse(use_span)\n+    }\n+\n+    /// Helper to retrieve span(s) of given borrow from the current MIR\n+    /// representation\n+    pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData) -> UseSpans {\n+        let span = self.mir.source_info(borrow.reserve_location).span;\n+        self.borrow_spans(span, borrow.reserve_location)\n+    }\n+}"}, {"sha": "320d3a47203210e24611283560011f267f8b2e9b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -1542,7 +1542,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if borrow_of_local_data(&borrow.borrowed_place) {\n             let err = self.tcx\n                 .cannot_borrow_across_generator_yield(\n-                    self.retrieve_borrow_span(borrow),\n+                    self.retrieve_borrow_spans(borrow).var_or_use(),\n                     yield_span,\n                     Origin::Mir,\n                 );"}, {"sha": "e8862320ddf3fcc83ce454ad0b92cae14743edd7", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -160,7 +160,6 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         let act;\n         let acted_on;\n \n-\n         let span = match error_access {\n             AccessKind::Move => {\n                 err = self.tcx\n@@ -180,31 +179,23 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 act = \"borrow as mutable\";\n                 acted_on = \"borrowed as mutable\";\n \n-                let closure_span = self.find_closure_span(span, location);\n-                if let Some((args, var)) = closure_span {\n-                    err = self.tcx.cannot_borrow_path_as_mutable_because(\n-                        args,\n-                        &item_msg,\n-                        &reason,\n-                        Origin::Mir,\n-                    );\n-                    err.span_label(\n-                        var,\n-                        format!(\n-                            \"mutable borrow occurs due to use of `{}` in closure\",\n-                            self.describe_place(access_place).unwrap(),\n-                        ),\n-                    );\n-                    args\n-                } else {\n-                    err = self.tcx.cannot_borrow_path_as_mutable_because(\n-                        span,\n-                        &item_msg,\n-                        &reason,\n-                        Origin::Mir,\n-                    );\n-                    span\n-                }\n+                let borrow_spans = self.borrow_spans(span, location);\n+                let borrow_span = borrow_spans.args_or_use();\n+                err = self.tcx.cannot_borrow_path_as_mutable_because(\n+                    borrow_span,\n+                    &item_msg,\n+                    &reason,\n+                    Origin::Mir,\n+                );\n+                borrow_spans.var_span_label(\n+                    &mut err,\n+                    format!(\n+                        \"mutable borrow occurs due to use of `{}` in closure\",\n+                        // always Some() if the message is printed.\n+                        self.describe_place(access_place).unwrap_or(String::new()),\n+                    )\n+                );\n+                borrow_span\n             }\n         };\n "}, {"sha": "5098b24adc367507e756324a682e14f7234122ec", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -62,18 +62,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n-            Some(Cause::LiveVar(_local, location)) => {\n-                if self.is_borrow_location_in_loop(context.loc) {\n-                    err.span_label(\n-                        mir.source_info(location).span,\n-                        \"borrow used here in later iteration of loop\".to_string(),\n-                    );\n+            Some(Cause::LiveVar(local, location)) => {\n+                let span = mir.source_info(location).span;\n+                let spans = self.move_spans(&Place::Local(local), location)\n+                    .or_else(|| self.borrow_spans(span, location));\n+                let message = if self.is_borrow_location_in_loop(context.loc) {\n+                    if spans.for_closure() {\n+                        \"borrow captured here by closure in later iteration of loop\"\n+                    } else {\n+                        \"borrow used here in later iteration of loop\"\n+                    }\n                 } else {\n-                    err.span_label(\n-                        mir.source_info(location).span,\n-                        \"borrow later used here\".to_string(),\n-                    );\n-                }\n+                    if spans.for_closure() {\n+                        \"borrow later captured here by closure\"\n+                    } else {\n+                        \"borrow later used here\"\n+                    }\n+                };\n+                err.span_label(spans.var_or_use(), message);\n             }\n \n             Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {"}, {"sha": "0a53361df6e95b70c53a1e1b69b7bfde5ed13d35", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -203,8 +203,15 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n             desc,\n             OGN = o\n         );\n-        err.span_label(old_loan_span, \"first closure is constructed here\");\n-        err.span_label(new_loan_span, \"second closure is constructed here\");\n+        if old_loan_span == new_loan_span {\n+            err.span_label(\n+                old_loan_span,\n+                \"closures are constructed here in different iterations of loop\"\n+            );\n+        } else {\n+            err.span_label(old_loan_span, \"first closure is constructed here\");\n+            err.span_label(new_loan_span, \"second closure is constructed here\");\n+        }\n         if let Some(old_load_end_span) = old_load_end_span {\n             err.span_label(old_load_end_span, \"borrow from first closure ends here\");\n         }"}, {"sha": "6186c3839193d0dd3aa23c038fd71befd8371997", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -77,11 +77,11 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n   --> $DIR/borrowck-closures-two-mut.rs:24:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 4);\n-   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        -- - first borrow occurs due to use of `x` in closure\n    |                        |\n    |                        first mutable borrow occurs here\n LL |     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n-   |                        ^^ - borrow occurs due to use of `x` in closure\n+   |                        ^^ - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n LL |     //~| ERROR cannot borrow `x` as mutable more than once\n@@ -92,11 +92,11 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n   --> $DIR/borrowck-closures-two-mut.rs:36:24\n    |\n LL |     let c1 = to_fn_mut(|| set(&mut x));\n-   |                        --          - previous borrow occurs due to use of `x` in closure\n+   |                        --          - first borrow occurs due to use of `x` in closure\n    |                        |\n    |                        first mutable borrow occurs here\n LL |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n-   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        ^^          - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n LL |     //~| ERROR cannot borrow `x` as mutable more than once\n@@ -107,11 +107,11 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n   --> $DIR/borrowck-closures-two-mut.rs:44:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 5);\n-   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        -- - first borrow occurs due to use of `x` in closure\n    |                        |\n    |                        first mutable borrow occurs here\n LL |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n-   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        ^^          - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n LL |     //~| ERROR cannot borrow `x` as mutable more than once\n@@ -122,11 +122,11 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n   --> $DIR/borrowck-closures-two-mut.rs:52:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 5);\n-   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        -- - first borrow occurs due to use of `x` in closure\n    |                        |\n    |                        first mutable borrow occurs here\n LL |     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n-   |                        ^^                                  - borrow occurs due to use of `x` in closure\n+   |                        ^^                                  - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n ...\n@@ -137,11 +137,11 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n   --> $DIR/borrowck-closures-two-mut.rs:65:24\n    |\n LL |     let c1 = to_fn_mut(|| set(&mut *x.f));\n-   |                        --           - previous borrow occurs due to use of `x` in closure\n+   |                        --           - first borrow occurs due to use of `x` in closure\n    |                        |\n    |                        first mutable borrow occurs here\n LL |     let c2 = to_fn_mut(|| set(&mut *x.f));\n-   |                        ^^           - borrow occurs due to use of `x` in closure\n+   |                        ^^           - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n ..."}, {"sha": "426419a7b3b7f830a10d2aeb87a2a388846010d1", "filename": "src/test/ui/borrowck/borrowck-escaping-closure-error-1.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-1.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -1,8 +1,10 @@\n error[E0597]: `books` does not live long enough\n-  --> $DIR/borrowck-escaping-closure-error-1.rs:23:11\n+  --> $DIR/borrowck-escaping-closure-error-1.rs:23:14\n    |\n LL |     spawn(|| books.push(4));\n-   |           ^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |           -- ^^^^^ borrowed value does not live long enough\n+   |           |\n+   |           value captured here\n LL |     //~^ ERROR E0373\n LL | }\n    | - `books` dropped here while still borrowed"}, {"sha": "d5f3a0ed6d82eb082c216adb23b729492dc288fe", "filename": "src/test/ui/borrowck/borrowck-escaping-closure-error-2.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-escaping-closure-error-2.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -1,8 +1,10 @@\n error[E0597]: `books` does not live long enough\n-  --> $DIR/borrowck-escaping-closure-error-2.rs:21:14\n+  --> $DIR/borrowck-escaping-closure-error-2.rs:21:17\n    |\n LL |     Box::new(|| books.push(4))\n-   |              ^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |              -- ^^^^^ borrowed value does not live long enough\n+   |              |\n+   |              value captured here\n LL |     //~^ ERROR E0373\n LL | }\n    | - `books` dropped here while still borrowed"}, {"sha": "6f4823326ffa6a0abf9d2db4c240d96bdb00eb5a", "filename": "src/test/ui/error-codes/E0504.nll.stderr", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Ferror-codes%2FE0504.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Ferror-codes%2FE0504.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0504.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -1,17 +1,16 @@\n error[E0505]: cannot move out of `fancy_num` because it is borrowed\n   --> $DIR/E0504.rs:19:13\n    |\n-LL |       let fancy_ref = &fancy_num;\n-   |                       ---------- borrow of `fancy_num` occurs here\n+LL |     let fancy_ref = &fancy_num;\n+   |                     ---------- borrow of `fancy_num` occurs here\n LL | \n-LL |       let x = move || {\n-   |  _____________^\n-LL | |         println!(\"child function: {}\", fancy_num.num); //~ ERROR E0504\n-LL | |     };\n-   | |_____^ move out of `fancy_num` occurs here\n+LL |     let x = move || {\n+   |             ^^^^^^^ move out of `fancy_num` occurs here\n+LL |         println!(\"child function: {}\", fancy_num.num); //~ ERROR E0504\n+   |                                        --------- move occurs due to use in closure\n ...\n-LL |       println!(\"main function: {}\", fancy_ref.num);\n-   |                                     ------------- borrow later used here\n+LL |     println!(\"main function: {}\", fancy_ref.num);\n+   |                                   ------------- borrow later used here\n \n error: aborting due to previous error\n "}, {"sha": "a7e6c9f2b3371b7c54e40c88da02248888e1de7d", "filename": "src/test/ui/issue-11192.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-11192.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-11192.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11192.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -5,7 +5,7 @@ LL |     let mut test = |foo: &Foo| {\n    |                    ----------- mutable borrow occurs here\n LL |         println!(\"access {}\", foo.x);\n LL |         ptr = box Foo { x: ptr.x + 1 };\n-   |         --- previous borrow occurs due to use of `ptr` in closure\n+   |         --- first borrow occurs due to use of `ptr` in closure\n ...\n LL |     test(&*ptr);\n    |     -----^^^^^-"}, {"sha": "bf4fed06dee215faba00bfa586893ea5786e76c7", "filename": "src/test/ui/issue-11873.nll.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-11873.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-11873.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-11873.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -2,7 +2,9 @@ error[E0505]: cannot move out of `v` because it is borrowed\n   --> $DIR/issue-11873.rs:14:14\n    |\n LL |     let mut f = || v.push(2);\n-   |                 ------------ borrow of `v` occurs here\n+   |                 -- - borrow occurs due to use in closure\n+   |                 |\n+   |                 borrow of `v` occurs here\n LL |     let _w = v; //~ ERROR: cannot move out of `v`\n    |              ^ move out of `v` occurs here\n LL | "}, {"sha": "8acdc73bf0e6867c0f44c8f7ad31a43b333f17ae", "filename": "src/test/ui/issue-18783.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-18783.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-18783.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-18783.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -2,11 +2,11 @@ error[E0499]: cannot borrow `y` as mutable more than once at a time\n   --> $DIR/issue-18783.rs:17:21\n    |\n LL |     c.push(Box::new(|| y = 0));\n-   |                     -- - previous borrow occurs due to use of `y` in closure\n+   |                     -- - first borrow occurs due to use of `y` in closure\n    |                     |\n    |                     first mutable borrow occurs here\n LL |     c.push(Box::new(|| y = 0));\n-   |                     ^^ - borrow occurs due to use of `y` in closure\n+   |                     ^^ - second borrow occurs due to use of `y` in closure\n    |                     |\n    |                     second mutable borrow occurs here\n LL | //~^ ERROR cannot borrow `y` as mutable more than once at a time\n@@ -17,11 +17,11 @@ error[E0499]: cannot borrow `y` as mutable more than once at a time\n   --> $DIR/issue-18783.rs:26:29\n    |\n LL |     Push::push(&c, Box::new(|| y = 0));\n-   |                             -- - previous borrow occurs due to use of `y` in closure\n+   |                             -- - first borrow occurs due to use of `y` in closure\n    |                             |\n    |                             first mutable borrow occurs here\n LL |     Push::push(&c, Box::new(|| y = 0));\n-   |                             ^^ - borrow occurs due to use of `y` in closure\n+   |                             ^^ - second borrow occurs due to use of `y` in closure\n    |                             |\n    |                             second mutable borrow occurs here\n LL | //~^ ERROR cannot borrow `y` as mutable more than once at a time"}, {"sha": "e35f443548d90f8f75b2aff6a86cf35eb9bc7a6b", "filename": "src/test/ui/issue-24357.nll.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-24357.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-24357.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-24357.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -2,7 +2,9 @@ error[E0382]: use of moved value: `x`\n   --> $DIR/issue-24357.rs:16:12\n    |\n LL |    let f = move || { let y = x; };\n-   |            ---------------------- value moved here\n+   |            -------           - variable moved due to use in closure\n+   |            |\n+   |            value moved into closure here\n LL |    //~^ NOTE value moved (into closure) here\n LL |    let z = x;\n    |            ^ value used here after move"}, {"sha": "91c51bcd0582502f20de9d41e8ebd434d9cc2a60", "filename": "src/test/ui/issue-27282-move-match-input-into-guard.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -1,11 +1,13 @@\n error[E0505]: cannot move out of `b` because it is borrowed\n-  --> $DIR/issue-27282-move-match-input-into-guard.rs:26:16\n+  --> $DIR/issue-27282-move-match-input-into-guard.rs:26:17\n    |\n LL |     match b {\n    |           - borrow of `b` occurs here\n LL |         &mut false => {},\n LL |         _ if { (|| { let bar = b; *bar = false; })();\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move out of `b` occurs here\n+   |                 ^^             - move occurs due to use in closure\n+   |                 |\n+   |                 move out of `b` occurs here\n ...\n LL |         &mut true => { println!(\"You might think we should get here\"); },\n    |         --------- borrow later used here\n@@ -14,7 +16,9 @@ error[E0382]: use of moved value: `*b`\n   --> $DIR/issue-27282-move-match-input-into-guard.rs:29:14\n    |\n LL |         _ if { (|| { let bar = b; *bar = false; })();\n-   |                ----------------------------------- value moved here\n+   |                 --             - variable moved due to use in closure\n+   |                 |\n+   |                 value moved into closure here\n ...\n LL |         &mut true => { println!(\"You might think we should get here\"); },\n    |              ^^^^ value used here after move"}, {"sha": "a9d9651fb2a35e45bfc89b600b2d642d19a62650", "filename": "src/test/ui/issue-27282-mutate-before-diverging-arm-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -5,7 +5,7 @@ LL |     match x {\n    |           - borrow occurs here\n ...\n LL |             (|| { *x = None; drop(force_fn_once); })();\n-   |              ^^    - borrow occurs due to use of `x` in closure\n+   |              ^^    - second borrow occurs due to use of `x` in closure\n    |              |\n    |              closure construction occurs here\n ..."}, {"sha": "582d0fd678c07f56eb4d6f1d3a2caeec2de7ac20", "filename": "src/test/ui/issue-27282-mutate-before-diverging-arm-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -5,7 +5,7 @@ LL |     match x {\n    |           - borrow occurs here\n ...\n LL |                 (|| { *x = None; drop(force_fn_once); })();\n-   |                  ^^    - borrow occurs due to use of `x` in closure\n+   |                  ^^    - second borrow occurs due to use of `x` in closure\n    |                  |\n    |                  closure construction occurs here\n ..."}, {"sha": "4ccd24fa4592141da4799057f4c26a3cc9978ccd", "filename": "src/test/ui/issue-4335.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-4335.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-4335.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-4335.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -5,10 +5,12 @@ LL |     id(Box::new(|| *v))\n    |                    ^^ cannot move out of captured variable in an `FnMut` closure\n \n error[E0597]: `v` does not live long enough\n-  --> $DIR/issue-4335.rs:16:17\n+  --> $DIR/issue-4335.rs:16:21\n    |\n LL |     id(Box::new(|| *v))\n-   |                 ^^^^^ borrowed value does not live long enough\n+   |                 --  ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL | }\n    | - `v` dropped here while still borrowed"}, {"sha": "3ca2f39470da7a9471329906606684029a327c01", "filename": "src/test/ui/issue-6801.nll.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-6801.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fissue-6801.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-6801.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -2,7 +2,9 @@ error[E0505]: cannot move out of `x` because it is borrowed\n   --> $DIR/issue-6801.rs:29:13\n    |\n LL |       let sq =  || { *x * *x };\n-   |                 -------------- borrow of `x` occurs here\n+   |                 --    - borrow occurs due to use in closure\n+   |                 |\n+   |                 borrow of `x` occurs here\n LL | \n LL |       twice(x); //~ ERROR: cannot move out of\n    |             ^ move out of `x` occurs here"}, {"sha": "b49436fabcf7487e35598f66167dcc82bca1215a", "filename": "src/test/ui/nll/closure-access-spans.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that accesses due to a closure capture give a special note\n+\n+#![feature(nll)]\n+\n+fn closure_imm_capture_conflict(mut x: i32) {\n+    let r = &mut x;\n+    || x; //~ ERROR\n+    r.use_mut();\n+}\n+\n+fn closure_mut_capture_conflict(mut x: i32) {\n+    let r = &mut x;\n+    || x = 2; //~ ERROR\n+    r.use_mut();\n+}\n+\n+fn closure_unique_capture_conflict(mut x: &mut i32) {\n+    let r = &mut x;\n+    || *x = 2; //~ ERROR\n+    r.use_mut();\n+}\n+\n+fn closure_copy_capture_conflict(mut x: i32) {\n+    let r = &mut x;\n+    move || x; //~ ERROR\n+    r.use_ref();\n+}\n+\n+fn closure_move_capture_conflict(mut x: String) {\n+    let r = &x;\n+    || x; //~ ERROR\n+    r.use_ref();\n+}\n+\n+fn closure_imm_capture_moved(mut x: String) {\n+    let r = x;\n+    || x.len(); //~ ERROR\n+}\n+\n+fn closure_mut_capture_moved(mut x: String) {\n+    let r = x;\n+    || x = String::new(); //~ ERROR\n+}\n+\n+fn closure_unique_capture_moved(x: &mut String) {\n+    let r = x;\n+    || *x = String::new(); //~ ERROR\n+}\n+\n+fn closure_move_capture_moved(x: &mut String) {\n+    let r = x;\n+    || x; //~ ERROR\n+}\n+\n+fn main() {}\n+\n+trait Fake { fn use_mut(&mut self) { } fn use_ref(&self) { }  }\n+impl<T> Fake for T { }"}, {"sha": "0042b5d7d529b316050daab10ef89296ed26a403", "filename": "src/test/ui/nll/closure-access-spans.stderr", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-access-spans.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,110 @@\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/closure-access-spans.rs:17:5\n+   |\n+LL |     let r = &mut x;\n+   |             ------ mutable borrow occurs here\n+LL |     || x; //~ ERROR\n+   |     ^^ - second borrow occurs due to use of `x` in closure\n+   |     |\n+   |     immutable borrow occurs here\n+LL |     r.use_mut();\n+   |     - borrow later used here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/closure-access-spans.rs:23:5\n+   |\n+LL |     let r = &mut x;\n+   |             ------ first mutable borrow occurs here\n+LL |     || x = 2; //~ ERROR\n+   |     ^^ - second borrow occurs due to use of `x` in closure\n+   |     |\n+   |     second mutable borrow occurs here\n+LL |     r.use_mut();\n+   |     - borrow later used here\n+\n+error[E0500]: closure requires unique access to `x` but it is already borrowed\n+  --> $DIR/closure-access-spans.rs:29:5\n+   |\n+LL |     let r = &mut x;\n+   |             ------ borrow occurs here\n+LL |     || *x = 2; //~ ERROR\n+   |     ^^  - second borrow occurs due to use of `x` in closure\n+   |     |\n+   |     closure construction occurs here\n+LL |     r.use_mut();\n+   |     - borrow later used here\n+\n+error[E0503]: cannot use `x` because it was mutably borrowed\n+  --> $DIR/closure-access-spans.rs:35:13\n+   |\n+LL |     let r = &mut x;\n+   |             ------ borrow of `x` occurs here\n+LL |     move || x; //~ ERROR\n+   |             ^ use of borrowed `x`\n+LL |     r.use_ref();\n+   |     - borrow later used here\n+\n+error[E0505]: cannot move out of `x` because it is borrowed\n+  --> $DIR/closure-access-spans.rs:41:5\n+   |\n+LL |     let r = &x;\n+   |             -- borrow of `x` occurs here\n+LL |     || x; //~ ERROR\n+   |     ^^ - move occurs due to use in closure\n+   |     |\n+   |     move out of `x` occurs here\n+LL |     r.use_ref();\n+   |     - borrow later used here\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/closure-access-spans.rs:47:5\n+   |\n+LL |     let r = x;\n+   |             - value moved here\n+LL |     || x.len(); //~ ERROR\n+   |     ^^ - borrow occurs due to use in closure\n+   |     |\n+   |     value borrowed here after move\n+   |\n+   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/closure-access-spans.rs:52:5\n+   |\n+LL |     let r = x;\n+   |             - value moved here\n+LL |     || x = String::new(); //~ ERROR\n+   |     ^^ - borrow occurs due to use in closure\n+   |     |\n+   |     value borrowed here after move\n+   |\n+   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/closure-access-spans.rs:57:5\n+   |\n+LL |     let r = x;\n+   |             - value moved here\n+LL |     || *x = String::new(); //~ ERROR\n+   |     ^^  - borrow occurs due to use in closure\n+   |     |\n+   |     value borrowed here after move\n+   |\n+   = note: move occurs because `x` has type `&mut std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/closure-access-spans.rs:62:5\n+   |\n+LL |     let r = x;\n+   |             - value moved here\n+LL |     || x; //~ ERROR\n+   |     ^^ - use occurs due to use in closure\n+   |     |\n+   |     value used here after move\n+   |\n+   = note: move occurs because `x` has type `&mut std::string::String`, which does not implement the `Copy` trait\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors occurred: E0382, E0499, E0500, E0502, E0503, E0505.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "d62dc27dade8f68fce82a15a6bc7d6a4b680afde", "filename": "src/test/ui/nll/closure-borrow-spans.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-borrow-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-borrow-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-borrow-spans.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that existing borrows due to a closure capture give a special note\n+\n+#![feature(nll)]\n+\n+fn move_while_borrowed(x: String) {\n+    let f = || x.len();\n+    let y = x; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn borrow_mut_while_borrowed(mut x: i32) {\n+    let f = || x;\n+    let y = &mut x; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn drop_while_borrowed() {\n+    let f;\n+    {\n+        let x = 1;\n+        f = || x; //~ ERROR\n+    }\n+    f.use_ref();\n+}\n+\n+fn assign_while_borrowed(mut x: i32) {\n+    let f = || x;\n+    x = 1; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn copy_while_borrowed_mut(mut x: i32) {\n+    let f = || x = 0;\n+    let y = x; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn borrow_while_borrowed_mut(mut x: i32) {\n+    let f = || x = 0;\n+    let y = &x; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn borrow_mut_while_borrowed_mut(mut x: i32) {\n+    let f = || x = 0;\n+    let y = &mut x; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn drop_while_borrowed_mut() {\n+    let f;\n+    {\n+        let mut x = 1;\n+        f = || x = 0; //~ ERROR\n+    }\n+    f.use_ref();\n+}\n+\n+fn assign_while_borrowed_mut(mut x: i32) {\n+    let f = || x = 0;\n+    x = 1; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn copy_while_borrowed_unique(x: &mut i32) {\n+    let f = || *x = 0;\n+    let y = x; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn borrow_while_borrowed_unique(x: &mut i32) {\n+    let f = || *x = 0;\n+    let y = &x; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn borrow_mut_while_borrowed_unique(mut x: &mut i32) {\n+    let f = || *x = 0;\n+    let y = &mut x; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn drop_while_borrowed_unique() {\n+    let mut z = 1;\n+    let f;\n+    {\n+        let x = &mut z;\n+        f = || *x = 0; //~ ERROR\n+    }\n+    f.use_ref();\n+}\n+\n+fn assign_while_borrowed_unique(x: &mut i32) {\n+    let f = || *x = 0;\n+    *x = 1; //~ ERROR\n+    f.use_ref();\n+}\n+\n+fn main() {}\n+\n+trait Fake { fn use_mut(&mut self) { } fn use_ref(&self) { }  }\n+impl<T> Fake for T { }"}, {"sha": "1b9420b3c0bf327749bbcbf9d3b6360d893b3d6d", "filename": "src/test/ui/nll/closure-borrow-spans.stderr", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-borrow-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-borrow-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-borrow-spans.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,172 @@\n+error[E0505]: cannot move out of `x` because it is borrowed\n+  --> $DIR/closure-borrow-spans.rs:17:13\n+   |\n+LL |     let f = || x.len();\n+   |             -- - borrow occurs due to use in closure\n+   |             |\n+   |             borrow of `x` occurs here\n+LL |     let y = x; //~ ERROR\n+   |             ^ move out of `x` occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n+  --> $DIR/closure-borrow-spans.rs:23:13\n+   |\n+LL |     let f = || x;\n+   |             -- - first borrow occurs due to use of `x` in closure\n+   |             |\n+   |             immutable borrow occurs here\n+LL |     let y = &mut x; //~ ERROR\n+   |             ^^^^^^ mutable borrow occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/closure-borrow-spans.rs:31:16\n+   |\n+LL |         f = || x; //~ ERROR\n+   |             -- ^ borrowed value does not live long enough\n+   |             |\n+   |             value captured here\n+LL |     }\n+   |     - `x` dropped here while still borrowed\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/closure-borrow-spans.rs:38:5\n+   |\n+LL |     let f = || x;\n+   |             -- - borrow occurs due to use in closure\n+   |             |\n+   |             borrow of `x` occurs here\n+LL |     x = 1; //~ ERROR\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0503]: cannot use `x` because it was mutably borrowed\n+  --> $DIR/closure-borrow-spans.rs:44:13\n+   |\n+LL |     let f = || x = 0;\n+   |             -- - borrow occurs due to use of `x` in closure\n+   |             |\n+   |             borrow of `x` occurs here\n+LL |     let y = x; //~ ERROR\n+   |             ^ use of borrowed `x`\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n+  --> $DIR/closure-borrow-spans.rs:50:13\n+   |\n+LL |     let f = || x = 0;\n+   |             -- - first borrow occurs due to use of `x` in closure\n+   |             |\n+   |             mutable borrow occurs here\n+LL |     let y = &x; //~ ERROR\n+   |             ^^ immutable borrow occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/closure-borrow-spans.rs:56:13\n+   |\n+LL |     let f = || x = 0;\n+   |             -- - first borrow occurs due to use of `x` in closure\n+   |             |\n+   |             first mutable borrow occurs here\n+LL |     let y = &mut x; //~ ERROR\n+   |             ^^^^^^ second mutable borrow occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/closure-borrow-spans.rs:64:16\n+   |\n+LL |         f = || x = 0; //~ ERROR\n+   |             -- ^ borrowed value does not live long enough\n+   |             |\n+   |             value captured here\n+LL |     }\n+   |     - `x` dropped here while still borrowed\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/closure-borrow-spans.rs:71:5\n+   |\n+LL |     let f = || x = 0;\n+   |             -- - borrow occurs due to use in closure\n+   |             |\n+   |             borrow of `x` occurs here\n+LL |     x = 1; //~ ERROR\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0505]: cannot move out of `x` because it is borrowed\n+  --> $DIR/closure-borrow-spans.rs:77:13\n+   |\n+LL |     let f = || *x = 0;\n+   |             --  - borrow occurs due to use in closure\n+   |             |\n+   |             borrow of `x` occurs here\n+LL |     let y = x; //~ ERROR\n+   |             ^ move out of `x` occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n+  --> $DIR/closure-borrow-spans.rs:83:13\n+   |\n+LL |     let f = || *x = 0;\n+   |             --  - first borrow occurs due to use of `x` in closure\n+   |             |\n+   |             closure construction occurs here\n+LL |     let y = &x; //~ ERROR\n+   |             ^^ borrow occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0501]: cannot borrow `x` as mutable because previous closure requires unique access\n+  --> $DIR/closure-borrow-spans.rs:89:13\n+   |\n+LL |     let f = || *x = 0;\n+   |             --  - first borrow occurs due to use of `x` in closure\n+   |             |\n+   |             closure construction occurs here\n+LL |     let y = &mut x; //~ ERROR\n+   |             ^^^^^^ borrow occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/closure-borrow-spans.rs:98:17\n+   |\n+LL |         f = || *x = 0; //~ ERROR\n+   |             --  ^ borrowed value does not live long enough\n+   |             |\n+   |             value captured here\n+LL |     }\n+   |     - `x` dropped here while still borrowed\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/closure-borrow-spans.rs:105:5\n+   |\n+LL |     let f = || *x = 0;\n+   |             --  - borrow occurs due to use in closure\n+   |             |\n+   |             borrow of `*x` occurs here\n+LL |     *x = 1; //~ ERROR\n+   |     ^^^^^^ assignment to borrowed `*x` occurs here\n+LL |     f.use_ref();\n+   |     - borrow later used here\n+\n+error: aborting due to 14 previous errors\n+\n+Some errors occurred: E0499, E0501, E0502, E0503, E0505, E0506, E0597.\n+For more information about an error, try `rustc --explain E0499`."}, {"sha": "16385ca2499cc46f81c49130009fe706faec94a2", "filename": "src/test/ui/nll/closure-captures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -13,7 +13,7 @@\n #![allow(unused)]\n #![feature(nll)]\n \n-// Should have one error per assigment\n+// Should have one error per assignment\n \n fn one_closure(x: i32) {\n     ||"}, {"sha": "7e836275c8bff5a71b6d7222dfa8c90b3d803438", "filename": "src/test/ui/nll/closure-move-spans.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that moves due to a closure capture give a special note\n+\n+#![feature(nll)]\n+\n+fn move_after_move(x: String) {\n+    || x;\n+    let y = x; //~ ERROR\n+}\n+\n+fn borrow_after_move(x: String) {\n+    || x;\n+    let y = &x; //~ ERROR\n+}\n+\n+fn borrow_mut_after_move(mut x: String) {\n+    || x;\n+    let y = &mut x; //~ ERROR\n+}\n+\n+fn fn_ref<F: Fn()>(f: F) -> F { f }\n+fn fn_mut<F: FnMut()>(f: F) -> F { f }\n+\n+fn main() {}"}, {"sha": "80b7b4246a747a1add6911a671ce087a1a3d4802", "filename": "src/test/ui/nll/closure-move-spans.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-move-spans.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,39 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/closure-move-spans.rs:17:13\n+   |\n+LL |     || x;\n+   |     -- - variable moved due to use in closure\n+   |     |\n+   |     value moved into closure here\n+LL |     let y = x; //~ ERROR\n+   |             ^ value used here after move\n+   |\n+   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/closure-move-spans.rs:22:13\n+   |\n+LL |     || x;\n+   |     -- - variable moved due to use in closure\n+   |     |\n+   |     value moved into closure here\n+LL |     let y = &x; //~ ERROR\n+   |             ^^ value borrowed here after move\n+   |\n+   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0382]: borrow of moved value: `x`\n+  --> $DIR/closure-move-spans.rs:27:13\n+   |\n+LL |     || x;\n+   |     -- - variable moved due to use in closure\n+   |     |\n+   |     value moved into closure here\n+LL |     let y = &mut x; //~ ERROR\n+   |             ^^^^^^ value borrowed here after move\n+   |\n+   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "ce44903e6e6a84505b32f849b6d670f03a2503f3", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -27,8 +27,8 @@ fn test() {\n     {\n         let y = 22;\n \n-        let mut closure = || { //~ ERROR `y` does not live long enough [E0597]\n-            let mut closure1 = || p = &y;\n+        let mut closure = || {\n+            let mut closure1 = || p = &y; //~ ERROR `y` does not live long enough [E0597]\n             closure1();\n         };\n "}, {"sha": "ed2ae2f27b57b643e596f79c6cda6dbdb18db594", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -1,7 +1,7 @@\n note: External requirements\n   --> $DIR/escape-upvar-nested.rs:31:32\n    |\n-LL |             let mut closure1 = || p = &y;\n+LL |             let mut closure1 = || p = &y; //~ ERROR `y` does not live long enough [E0597]\n    |                                ^^^^^^^^^\n    |\n    = note: defining type: DefId(0/1:10 ~ escape_upvar_nested[317d]::test[0]::{{closure}}[0]::{{closure}}[0]) with closure substs [\n@@ -16,9 +16,9 @@ LL |             let mut closure1 = || p = &y;\n note: External requirements\n   --> $DIR/escape-upvar-nested.rs:30:27\n    |\n-LL |           let mut closure = || { //~ ERROR `y` does not live long enough [E0597]\n+LL |           let mut closure = || {\n    |  ___________________________^\n-LL | |             let mut closure1 = || p = &y;\n+LL | |             let mut closure1 = || p = &y; //~ ERROR `y` does not live long enough [E0597]\n LL | |             closure1();\n LL | |         };\n    | |_________^\n@@ -47,20 +47,18 @@ LL | | }\n    = note: defining type: DefId(0/0:3 ~ escape_upvar_nested[317d]::test[0]) with substs []\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/escape-upvar-nested.rs:30:27\n+  --> $DIR/escape-upvar-nested.rs:31:40\n    |\n-LL |           let mut closure = || { //~ ERROR `y` does not live long enough [E0597]\n-   |  ___________________________^\n-LL | |             let mut closure1 = || p = &y;\n-LL | |             closure1();\n-LL | |         };\n-   | |_________^ borrowed value does not live long enough\n+LL |         let mut closure = || {\n+   |                           -- value captured here\n+LL |             let mut closure1 = || p = &y; //~ ERROR `y` does not live long enough [E0597]\n+   |                                        ^ borrowed value does not live long enough\n ...\n-LL |       }\n-   |       - `y` dropped here while still borrowed\n+LL |     }\n+   |     - `y` dropped here while still borrowed\n LL | \n-LL |       deref(p);\n-   |             - borrow later used here\n+LL |     deref(p);\n+   |           - borrow later used here\n \n error: aborting due to previous error\n "}, {"sha": "8db56deeb1f7ae83dbb4482708fa314d7ec1dba0", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -28,10 +28,12 @@ LL | | }\n    = note: defining type: DefId(0/0:3 ~ escape_upvar_ref[317d]::test[0]) with substs []\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/escape-upvar-ref.rs:33:27\n+  --> $DIR/escape-upvar-ref.rs:33:35\n    |\n LL |         let mut closure = || p = &y;\n-   |                           ^^^^^^^^^ borrowed value does not live long enough\n+   |                           --      ^ borrowed value does not live long enough\n+   |                           |\n+   |                           value captured here\n ...\n LL |     }\n    |     - `y` dropped here while still borrowed"}, {"sha": "7ab382a96bbb49d53a4dd92f3d30758dfeee8b3a", "filename": "src/test/ui/nll/closure-use-spans.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-use-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-use-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-use-spans.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that liveness due to a closure capture gives a special note\n+\n+#![feature(nll)]\n+\n+fn use_as_borrow_capture(mut x: i32) {\n+    let y = &x;\n+    x = 0; //~ ERROR\n+    || *y;\n+}\n+\n+fn use_as_borrow_mut_capture(mut x: i32) {\n+    let y = &mut x;\n+    x = 0; //~ ERROR\n+    || *y = 1;\n+}\n+\n+fn use_as_move_capture(mut x: i32) {\n+    let y = &x;\n+    x = 0; //~ ERROR\n+    move || *y;\n+}\n+\n+fn main() {}"}, {"sha": "7e5f9621d0955c80379c04a50cc41b127f869690", "filename": "src/test/ui/nll/closure-use-spans.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-use-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosure-use-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-use-spans.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,33 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/closure-use-spans.rs:17:5\n+   |\n+LL |     let y = &x;\n+   |             -- borrow of `x` occurs here\n+LL |     x = 0; //~ ERROR\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+LL |     || *y;\n+   |         - borrow later captured here by closure\n+\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/closure-use-spans.rs:23:5\n+   |\n+LL |     let y = &mut x;\n+   |             ------ borrow of `x` occurs here\n+LL |     x = 0; //~ ERROR\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+LL |     || *y = 1;\n+   |         - borrow later captured here by closure\n+\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/closure-use-spans.rs:29:5\n+   |\n+LL |     let y = &x;\n+   |             -- borrow of `x` occurs here\n+LL |     x = 0; //~ ERROR\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+LL |     move || *y;\n+   |              - borrow later captured here by closure\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0506`."}, {"sha": "c6113f3a9c50a1a51337491c2d3db71c004c323d", "filename": "src/test/ui/nll/closures-in-loops.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.rs?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test messages where a closure capture conflicts with itself because it's in\n+// a loop.\n+\n+#![feature(nll)]\n+\n+fn repreated_move(x: String) {\n+    for i in 0..10 {\n+        || x; //~ ERROR\n+    }\n+}\n+\n+fn repreated_mut_borrow(mut x: String) {\n+    let mut v = Vec::new();\n+    for i in 0..10 {\n+        v.push(|| x = String::new()); //~ ERROR\n+    }\n+}\n+\n+fn repreated_unique_borrow(x: &mut String) {\n+    let mut v = Vec::new();\n+    for i in 0..10 {\n+        v.push(|| *x = String::new()); //~ ERROR\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9758a803620003e2f378509c156804dd11d0288c", "filename": "src/test/ui/nll/closures-in-loops.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosures-in-loops.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -0,0 +1,30 @@\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/closures-in-loops.rs:18:9\n+   |\n+LL |         || x; //~ ERROR\n+   |         ^^ - use occurs due to use in closure\n+   |         |\n+   |         value moved into closure here in previous iteration of loop\n+   |\n+   = note: move occurs because `x` has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/closures-in-loops.rs:25:16\n+   |\n+LL |         v.push(|| x = String::new()); //~ ERROR\n+   |                ^^ - borrows occur due to use of `x` in closure\n+   |                |\n+   |                mutable borrow starts here in previous iteration of loop\n+\n+error[E0524]: two closures require unique access to `x` at the same time\n+  --> $DIR/closures-in-loops.rs:32:16\n+   |\n+LL |         v.push(|| *x = String::new()); //~ ERROR\n+   |                ^^  - borrows occur due to use of `x` in closure\n+   |                |\n+   |                closures are constructed here in different iterations of loop\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0382, E0499, E0524.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "2ecfe03e7de6250e2e60b50a1360f20ce5bf1b3e", "filename": "src/test/ui/nll/issue-51268.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fissue-51268.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fnll%2Fissue-51268.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51268.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -8,7 +8,7 @@ LL |            self.thing.bar(|| {\n    | ||\n LL | ||         //~^ ERROR cannot borrow `self.thing` as mutable because it is also borrowed as immutable [E0502]\n LL | ||             &self.number;\n-   | ||              ---- previous borrow occurs due to use of `self` in closure\n+   | ||              ---- first borrow occurs due to use of `self` in closure\n LL | ||         });\n    | ||          ^\n    | ||__________|"}, {"sha": "d0d6bd4c78570c08bd349033b32a4855d9f205e6", "filename": "src/test/ui/region-borrow-params-issue-29793-small.nll.stderr", "status": "modified", "additions": 80, "deletions": 40, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fregion-borrow-params-issue-29793-small.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fregion-borrow-params-issue-29793-small.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregion-borrow-params-issue-29793-small.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -1,44 +1,54 @@\n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:19:17\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:19:34\n    |\n LL |         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                 ---------        ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL |     };\n    |      - `x` dropped here while still borrowed\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:19:17\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:19:45\n    |\n LL |         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                 ---------                   ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL |     };\n    |      - `y` dropped here while still borrowed\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:34:17\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:34:34\n    |\n LL |         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                 ---------        ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL |     };\n    |      - `x` dropped here while still borrowed\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:34:17\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:34:45\n    |\n LL |         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                 ---------                   ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL |     };\n    |      - `y` dropped here while still borrowed\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:65:17\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:65:34\n    |\n LL |         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                 ---------        ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL |     };\n    |     - `x` dropped here while still borrowed\n@@ -50,10 +60,12 @@ LL |     fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |          ^^\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:65:17\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:65:45\n    |\n LL |         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                 ---------                   ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL |     };\n    |     - `y` dropped here while still borrowed\n@@ -65,10 +77,12 @@ LL |     fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |          ^^\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:76:17\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:76:34\n    |\n LL |         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                 ---------        ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL |     };\n    |     - `x` dropped here while still borrowed\n@@ -80,10 +94,12 @@ LL |     fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |          ^^\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:76:17\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:76:45\n    |\n LL |         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                 ---------                   ^ borrowed value does not live long enough\n+   |                 |\n+   |                 value captured here\n ...\n LL |     };\n    |     - `y` dropped here while still borrowed\n@@ -95,10 +111,12 @@ LL |     fn g<'a>(x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |          ^^\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:100:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:100:38\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------        ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `x` dropped here while still borrowed\n@@ -110,10 +128,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:100:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:100:49\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------                   ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `y` dropped here while still borrowed\n@@ -125,10 +145,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:114:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:114:38\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------        ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `x` dropped here while still borrowed\n@@ -140,10 +162,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:114:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:114:49\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------                   ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `y` dropped here while still borrowed\n@@ -155,10 +179,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:142:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:142:38\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------        ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `x` dropped here while still borrowed\n@@ -170,10 +196,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:142:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:142:49\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------                   ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `y` dropped here while still borrowed\n@@ -185,10 +213,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:157:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:157:38\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------        ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `x` dropped here while still borrowed\n@@ -200,10 +230,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:157:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:157:49\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------                   ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `y` dropped here while still borrowed\n@@ -215,10 +247,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:185:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:185:38\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------        ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `x` dropped here while still borrowed\n@@ -230,10 +264,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:185:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:185:49\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------                   ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `y` dropped here while still borrowed\n@@ -245,10 +281,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `x` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:199:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:199:38\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------        ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `x` dropped here while still borrowed\n@@ -260,10 +298,12 @@ LL |         fn g<'a>(&self, x: usize, y:usize) -> Box<Fn(bool) -> usize + 'a> {\n    |              ^^\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/region-borrow-params-issue-29793-small.rs:199:21\n+  --> $DIR/region-borrow-params-issue-29793-small.rs:199:49\n    |\n LL |             let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n+   |                     ---------                   ^ borrowed value does not live long enough\n+   |                     |\n+   |                     value captured here\n ...\n LL |         }\n    |         - `y` dropped here while still borrowed"}, {"sha": "1b5bb7d5007798038855dcb2287971fb8a05df2b", "filename": "src/test/ui/regions-nested-fns-2.nll.stderr", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fregions-nested-fns-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fregions-nested-fns-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-nested-fns-2.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -1,13 +1,14 @@\n error[E0597]: `y` does not live long enough\n-  --> $DIR/regions-nested-fns-2.rs:16:9\n+  --> $DIR/regions-nested-fns-2.rs:18:25\n    |\n-LL | /         |z| {\n-LL | |             //~^ ERROR E0373\n-LL | |             if false { &y } else { z }\n-LL | |         });\n-   | |_________^ borrowed value does not live long enough\n-LL |   }\n-   |   - `y` dropped here while still borrowed\n+LL |         |z| {\n+   |         --- value captured here\n+LL |             //~^ ERROR E0373\n+LL |             if false { &y } else { z }\n+   |                         ^ borrowed value does not live long enough\n+LL |         });\n+LL | }\n+   | - `y` dropped here while still borrowed\n    |\n    = note: borrowed value must be valid for the static lifetime...\n "}, {"sha": "c7dbc043cdaee3fa78e23f7525645f50516e5a44", "filename": "src/test/ui/span/borrowck-call-is-borrow-issue-12224.nll.stderr", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -8,7 +8,7 @@ LL |       f(Box::new(|| {\n    | |\n LL | |     //~^ ERROR: cannot borrow `f` as mutable more than once\n LL | |         f((Box::new(|| {})))\n-   | |         - borrow occurs due to use of `f` in closure\n+   | |         - second borrow occurs due to use of `f` in closure\n LL | |     }));\n    | |_______- borrow later used here\n \n@@ -37,18 +37,17 @@ LL |         foo(f);\n error[E0505]: cannot move out of `f` because it is borrowed\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:65:16\n    |\n-LL |        f(Box::new(|a| {\n-   |   _____-__________^\n-   |  |     |\n-   |  |_____borrow of `f` occurs here\n-   | ||\n-LL | ||         foo(f);\n-LL | ||         //~^ ERROR cannot move `f` into closure because it is borrowed\n-LL | ||         //~| ERROR cannot move out of captured outer variable in an `FnMut` closure\n-LL | ||     }), 3);\n-   | ||_____^____- borrow later used here\n-   |  |_____|\n-   |        move out of `f` occurs here\n+LL |       f(Box::new(|a| {\n+   |       -          ^^^ move out of `f` occurs here\n+   |       |\n+   |  _____borrow of `f` occurs here\n+   | |\n+LL | |         foo(f);\n+   | |             - move occurs due to use in closure\n+LL | |         //~^ ERROR cannot move `f` into closure because it is borrowed\n+LL | |         //~| ERROR cannot move out of captured outer variable in an `FnMut` closure\n+LL | |     }), 3);\n+   | |__________- borrow later used here\n \n error: aborting due to 5 previous errors\n "}, {"sha": "c14cb7098933f1bb782ab318850ee7de21f81918", "filename": "src/test/ui/span/send-is-not-static-ensures-scoping.nll.stderr", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f9ac89d11a2afaeaa029738b38142124684c89b/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.nll.stderr?ref=9f9ac89d11a2afaeaa029738b38142124684c89b", "patch": "@@ -11,19 +11,18 @@ LL |     bad.join();\n    |     --- borrow later used here\n \n error[E0597]: `y` does not live long enough\n-  --> $DIR/send-is-not-static-ensures-scoping.rs:29:16\n+  --> $DIR/send-is-not-static-ensures-scoping.rs:30:22\n    |\n-LL |           scoped(|| {\n-   |  ________________^\n-LL | |             let _z = y;\n-LL | |             //~^ ERROR `y` does not live long enough\n-LL | |         })\n-   | |_________^ borrowed value does not live long enough\n-LL |       };\n-   |       - `y` dropped here while still borrowed\n+LL |         scoped(|| {\n+   |                -- value captured here\n+LL |             let _z = y;\n+   |                      ^ borrowed value does not live long enough\n+...\n+LL |     };\n+   |     - `y` dropped here while still borrowed\n LL | \n-LL |       bad.join();\n-   |       --- borrow later used here\n+LL |     bad.join();\n+   |     --- borrow later used here\n \n error: aborting due to 2 previous errors\n "}]}