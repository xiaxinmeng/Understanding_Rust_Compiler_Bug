{"sha": "d882bb516e0998d7f9c2d049dcc618992a1a04c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ODJiYjUxNmUwOTk4ZDdmOWMyZDA0OWRjYzYxODk5MmExYTA0YzA=", "commit": {"author": {"name": "Ed Schouten", "email": "ed@nuxi.nl", "date": "2018-01-11T10:21:42Z"}, "committer": {"name": "Ed Schouten", "email": "ed@nuxi.nl", "date": "2018-01-11T10:26:13Z"}, "message": "Add shims for modules that we can't implement on CloudABI.\n\nAs discussed in #47268, libstd isn't ready to have certain functionality\ndisabled yet. Follow wasm's approach of adding no-op modules for all of\nthe features that we can't implement.\n\nI've placed all of those shims in a shims/ subdirectory, so we (the\nCloudABI folks) can experiment with removing them more easily. It also\nensures that the code that does work doesn't get polluted with lots of\nuseless boilerplate code.", "tree": {"sha": "02370689e6220246902e84563623e84fb80c74a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02370689e6220246902e84563623e84fb80c74a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d882bb516e0998d7f9c2d049dcc618992a1a04c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d882bb516e0998d7f9c2d049dcc618992a1a04c0", "html_url": "https://github.com/rust-lang/rust/commit/d882bb516e0998d7f9c2d049dcc618992a1a04c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d882bb516e0998d7f9c2d049dcc618992a1a04c0/comments", "author": {"login": "EdSchouten", "id": 736085, "node_id": "MDQ6VXNlcjczNjA4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/736085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EdSchouten", "html_url": "https://github.com/EdSchouten", "followers_url": "https://api.github.com/users/EdSchouten/followers", "following_url": "https://api.github.com/users/EdSchouten/following{/other_user}", "gists_url": "https://api.github.com/users/EdSchouten/gists{/gist_id}", "starred_url": "https://api.github.com/users/EdSchouten/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EdSchouten/subscriptions", "organizations_url": "https://api.github.com/users/EdSchouten/orgs", "repos_url": "https://api.github.com/users/EdSchouten/repos", "events_url": "https://api.github.com/users/EdSchouten/events{/privacy}", "received_events_url": "https://api.github.com/users/EdSchouten/received_events", "type": "User", "site_admin": false}, "committer": {"login": "EdSchouten", "id": 736085, "node_id": "MDQ6VXNlcjczNjA4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/736085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EdSchouten", "html_url": "https://github.com/EdSchouten", "followers_url": "https://api.github.com/users/EdSchouten/followers", "following_url": "https://api.github.com/users/EdSchouten/following{/other_user}", "gists_url": "https://api.github.com/users/EdSchouten/gists{/gist_id}", "starred_url": "https://api.github.com/users/EdSchouten/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EdSchouten/subscriptions", "organizations_url": "https://api.github.com/users/EdSchouten/orgs", "repos_url": "https://api.github.com/users/EdSchouten/repos", "events_url": "https://api.github.com/users/EdSchouten/events{/privacy}", "received_events_url": "https://api.github.com/users/EdSchouten/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20745264ce3298147067fcb46e1f51efcb9670e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/20745264ce3298147067fcb46e1f51efcb9670e4", "html_url": "https://github.com/rust-lang/rust/commit/20745264ce3298147067fcb46e1f51efcb9670e4"}], "stats": {"total": 989, "additions": 980, "deletions": 9}, "files": [{"sha": "3b79e0c4f826744dafb1c5cf5d66ca0ea4782b72", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -473,21 +473,16 @@ pub mod f64;\n pub mod thread;\n pub mod ascii;\n pub mod collections;\n-#[cfg(not(target_os = \"cloudabi\"))]\n pub mod env;\n pub mod error;\n pub mod ffi;\n-#[cfg(not(target_os = \"cloudabi\"))]\n pub mod fs;\n pub mod io;\n-#[cfg(not(target_os = \"cloudabi\"))]\n pub mod net;\n pub mod num;\n pub mod os;\n pub mod panic;\n-#[cfg(not(target_os = \"cloudabi\"))]\n pub mod path;\n-#[cfg(not(target_os = \"cloudabi\"))]\n pub mod process;\n pub mod sync;\n pub mod time;"}, {"sha": "7b62cc6adc9848753e3a7fc57ccd0dd2eac5450d", "filename": "src/libstd/sys/cloudabi/args.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use sys::cloudabi::shims::args::*;\n+\n #[allow(dead_code)]\n pub fn init(_: isize, _: *const *const u8) {}\n "}, {"sha": "9e943c17fc85f788f9ebbc4656778a4ef50c9c33", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -34,6 +34,9 @@ pub mod time;\n \n mod abi;\n \n+mod shims;\n+pub use self::shims::*;\n+\n #[allow(dead_code)]\n pub fn init() {}\n "}, {"sha": "7e506b84df1ce653c5a65f4e7e7fb9db75b68e4e", "filename": "src/libstd/sys/cloudabi/os.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -12,6 +12,8 @@ use ffi::CStr;\n use libc::{self, c_int};\n use str;\n \n+pub use sys::cloudabi::shims::os::*;\n+\n pub fn errno() -> i32 {\n     extern \"C\" {\n         #[thread_local]\n@@ -29,3 +31,7 @@ pub fn error_string(errno: i32) -> String {\n         .unwrap()\n         .to_owned()\n }\n+\n+pub fn exit(code: i32) -> ! {\n+    unsafe { libc::exit(code as c_int) }\n+}"}, {"sha": "1b5785adc8ab377e74d2b1f3a6b89bbcbee52e2a", "filename": "src/libstd/sys/cloudabi/shims/args.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fargs.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+\n+pub struct Args(());\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        &[]\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        None\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(0))\n+    }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        None\n+    }\n+}\n+\n+pub fn args() -> Args {\n+    Args(())\n+}"}, {"sha": "31777aa94bcd4628ea477f6276d9f88bb8c71efa", "filename": "src/libstd/sys/cloudabi/shims/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fenv.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod os {\n+    pub const FAMILY: &'static str = \"cloudabi\";\n+    pub const OS: &'static str = \"cloudabi\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}"}, {"sha": "d3da0fbc37192b47017cc039b027f237a1cf7bb5", "filename": "src/libstd/sys/cloudabi/shims/fs.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -0,0 +1,302 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+use fmt;\n+use hash::{Hash, Hasher};\n+use io::{self, SeekFrom};\n+use path::{Path, PathBuf};\n+use sys::time::SystemTime;\n+use sys::{unsupported, Void};\n+\n+pub struct File(Void);\n+\n+pub struct FileAttr(Void);\n+\n+pub struct ReadDir(Void);\n+\n+pub struct DirEntry(Void);\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions {}\n+\n+pub struct FilePermissions(Void);\n+\n+pub struct FileType(Void);\n+\n+#[derive(Debug)]\n+pub struct DirBuilder {}\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 {\n+        match self.0 {}\n+    }\n+\n+    pub fn perm(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        match self.0 {}\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileAttr {\n+    fn clone(&self) -> FileAttr {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_readonly(&mut self, _readonly: bool) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FilePermissions {\n+    fn clone(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+}\n+\n+impl PartialEq for FilePermissions {\n+    fn eq(&self, _other: &FilePermissions) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FilePermissions {}\n+\n+impl fmt::Debug for FilePermissions {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_file(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_symlink(&self) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileType {\n+    fn clone(&self) -> FileType {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for FileType {}\n+\n+impl PartialEq for FileType {\n+    fn eq(&self, _other: &FileType) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FileType {}\n+\n+impl Hash for FileType {\n+    fn hash<H: Hasher>(&self, _h: &mut H) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for FileType {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        match self.0 {}\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {}\n+    }\n+\n+    pub fn read(&mut self, _read: bool) {}\n+    pub fn write(&mut self, _write: bool) {}\n+    pub fn append(&mut self, _append: bool) {}\n+    pub fn truncate(&mut self, _truncate: bool) {}\n+    pub fn create(&mut self, _create: bool) {}\n+    pub fn create_new(&mut self, _create_new: bool) {}\n+}\n+\n+impl File {\n+    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n+        unsupported()\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder {}\n+    }\n+\n+    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n+        unsupported()\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n+    unsupported()\n+}\n+\n+pub fn unlink(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    match perm.0 {}\n+}\n+\n+pub fn rmdir(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n+    unsupported()\n+}"}, {"sha": "407c2b90511d3e71cb1cc058e69576e41f2a7143", "filename": "src/libstd/sys/cloudabi/shims/mod.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+\n+pub mod args;\n+pub mod env;\n+pub mod fs;\n+pub mod net;\n+#[path = \"../../unix/path.rs\"]\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod os;\n+\n+// This enum is used as the storage for a bunch of types which can't actually exist.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub enum Void {}\n+\n+pub fn unsupported<T>() -> io::Result<T> {\n+    Err(io::Error::new(\n+        io::ErrorKind::Other,\n+        \"This function is not available on CloudABI.\",\n+    ))\n+}"}, {"sha": "93eaf6a9e7d6970171ce5bf12463a07ffbc0ff07", "filename": "src/libstd/sys/cloudabi/shims/net.rs", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -0,0 +1,296 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+use io;\n+use net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n+use time::Duration;\n+use sys::{unsupported, Void};\n+\n+pub extern crate libc as netc;\n+\n+pub struct TcpStream(Void);\n+\n+impl TcpStream {\n+    pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct TcpListener(Void);\n+\n+impl TcpListener {\n+    pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct UdpSocket(Void);\n+\n+impl UdpSocket {\n+    pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct LookupHost(Void);\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<SocketAddr> {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n+    unsupported()\n+}"}, {"sha": "1e355d9ad042e45e0b282a955d9c7a1e37bee990", "filename": "src/libstd/sys/cloudabi/shims/os.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fos.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use error::Error as StdError;\n+use ffi::{OsStr, OsString};\n+use fmt;\n+use io;\n+use iter;\n+use path::{self, PathBuf};\n+use sys::{unsupported, Void};\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn chdir(_: &path::Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub type Env = iter::Empty<(OsString, OsString)>;\n+\n+pub fn env() -> Env {\n+    iter::empty()\n+}\n+\n+pub fn getenv(_: &OsStr) -> io::Result<Option<OsString>> {\n+    Ok(None)\n+}\n+\n+pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub struct SplitPaths<'a>(&'a Void);\n+\n+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths {\n+    panic!(\"unsupported\")\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n+        match *self.0 {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n+{\n+    Err(JoinPathsError)\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"not supported on CloudABI yet\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str {\n+        \"not supported on CloudABI yet\"\n+    }\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    PathBuf::from(\"/tmp\")\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn getpid() -> u32 {\n+    1\n+}"}, {"sha": "77a9cd6259005c3675f1215ce1faf20423888762", "filename": "src/libstd/sys/cloudabi/shims/pipe.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fpipe.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::Void;\n+\n+pub struct AnonPipe(Void);\n+\n+impl AnonPipe {\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n+    match p1.0 {}\n+}"}, {"sha": "52e8c82e2b2393e916c8a56bacfc976fe4f88670", "filename": "src/libstd/sys/cloudabi/shims/process.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsStr;\n+use fmt;\n+use io;\n+use sys::fs::File;\n+use sys::pipe::AnonPipe;\n+use sys::{unsupported, Void};\n+use sys_common::process::{CommandEnv, DefaultEnvKey};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    env: CommandEnv<DefaultEnvKey>,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+}\n+\n+impl Command {\n+    pub fn new(_program: &OsStr) -> Command {\n+        Command {\n+            env: Default::default(),\n+        }\n+    }\n+\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n+\n+    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+        &mut self.env\n+    }\n+\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n+\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n+\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n+\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n+\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+}\n+\n+impl From<AnonPipe> for Stdio {\n+    fn from(pipe: AnonPipe) -> Stdio {\n+        pipe.diverge()\n+    }\n+}\n+\n+impl From<File> for Stdio {\n+    fn from(file: File) -> Stdio {\n+        file.diverge()\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+pub struct ExitStatus(Void);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for ExitStatus {\n+    fn clone(&self) -> ExitStatus {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for ExitStatus {}\n+\n+impl PartialEq for ExitStatus {\n+    fn eq(&self, _other: &ExitStatus) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for ExitStatus {}\n+\n+impl fmt::Debug for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct Process(Void);\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        match self.0 {}\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        match self.0 {}\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        match self.0 {}\n+    }\n+}"}, {"sha": "27504d374ddbfaba19cb09ea52ba382aae13919b", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d882bb516e0998d7f9c2d049dcc618992a1a04c0/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=d882bb516e0998d7f9c2d049dcc618992a1a04c0", "patch": "@@ -43,16 +43,13 @@ pub mod thread_local;\n pub mod util;\n pub mod wtf8;\n pub mod bytestring;\n-#[cfg(not(target_os = \"cloudabi\"))]\n pub mod process;\n \n cfg_if! {\n-    if #[cfg(any(target_os = \"redox\", target_os = \"l4re\"))] {\n+    if #[cfg(any(target_os = \"cloudabi\", target_os = \"l4re\", target_os = \"redox\"))] {\n         pub use sys::net;\n     } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n         pub use sys::net;\n-    } else if #[cfg(target_os = \"cloudabi\")] {\n-        // No networking support on CloudABI (yet).\n     } else {\n         pub mod net;\n     }"}]}