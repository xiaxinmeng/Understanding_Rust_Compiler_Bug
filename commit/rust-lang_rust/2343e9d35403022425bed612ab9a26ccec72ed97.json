{"sha": "2343e9d35403022425bed612ab9a26ccec72ed97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNDNlOWQzNTQwMzAyMjQyNWJlZDYxMmFiOWEyNmNjZWM3MmVkOTc=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-10-01T00:11:34Z"}, "committer": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-10-23T01:23:13Z"}, "message": "Part of #6993. Moved a bunch of uses of Ident to Name", "tree": {"sha": "0b8ef107a82261241ef2063ee471f4a420d5e50c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b8ef107a82261241ef2063ee471f4a420d5e50c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2343e9d35403022425bed612ab9a26ccec72ed97", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2343e9d35403022425bed612ab9a26ccec72ed97", "html_url": "https://github.com/rust-lang/rust/commit/2343e9d35403022425bed612ab9a26ccec72ed97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2343e9d35403022425bed612ab9a26ccec72ed97/comments", "author": null, "committer": null, "parents": [{"sha": "7d7e40983972d128c74eaea1f92be1adaf45d647", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d7e40983972d128c74eaea1f92be1adaf45d647", "html_url": "https://github.com/rust-lang/rust/commit/7d7e40983972d128c74eaea1f92be1adaf45d647"}], "stats": {"total": 726, "additions": 355, "deletions": 371}, "files": [{"sha": "507aaf137cdf5c99f4145f7fa6a329e5a1eb4fed", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -33,7 +33,7 @@ use syntax::parse::token;\n use std::collections::hashmap::HashMap;\n \n pub struct StaticMethodInfo {\n-    pub ident: ast::Ident,\n+    pub name: ast::Name,\n     pub def_id: ast::DefId,\n     pub fn_style: ast::FnStyle,\n     pub vis: ast::Visibility,\n@@ -57,7 +57,7 @@ pub fn each_lang_item(cstore: &cstore::CStore,\n pub fn each_child_of_item(cstore: &cstore::CStore,\n                           def_id: ast::DefId,\n                           callback: |decoder::DefLike,\n-                                     ast::Ident,\n+                                     ast::Name,\n                                      ast::Visibility|) {\n     let crate_data = cstore.get_crate_data(def_id.krate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n@@ -74,7 +74,7 @@ pub fn each_child_of_item(cstore: &cstore::CStore,\n pub fn each_top_level_item_of_crate(cstore: &cstore::CStore,\n                                     cnum: ast::CrateNum,\n                                     callback: |decoder::DefLike,\n-                                               ast::Ident,\n+                                               ast::Name,\n                                                ast::Visibility|) {\n     let crate_data = cstore.get_crate_data(cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n@@ -139,7 +139,7 @@ pub fn get_impl_or_trait_item(tcx: &ty::ctxt, def: ast::DefId)\n }\n \n pub fn get_trait_item_name_and_kind(cstore: &cstore::CStore, def: ast::DefId)\n-                                    -> (ast::Ident, resolve::TraitItemKind) {\n+                                    -> (ast::Name, resolve::TraitItemKind) {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_item_name_and_kind(cstore.intr.clone(),\n                                           &*cdata,\n@@ -173,7 +173,7 @@ pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<Rc<ty::TraitRef>>\n }\n \n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n-                          -> Option<ast::Ident> {\n+                          -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type_name_if_impl(&*cdata, def.node)\n }"}, {"sha": "e1205ae1f767736036cc8d5aaba3f872dc379487", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -292,12 +292,12 @@ fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n     result\n }\n \n-fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Ident {\n+fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n     match intr.find_equiv(&string) {\n-        None => token::str_to_ident(string),\n-        Some(val) => ast::Ident::new(val),\n+        None => token::intern(string),\n+        Some(val) => val,\n     }\n }\n \n@@ -457,7 +457,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                item_doc: rbml::Doc,\n                                get_crate_data: GetCrateDataCb,\n                                callback: |DefLike,\n-                                          ast::Ident,\n+                                          ast::Name,\n                                           ast::Visibility|) {\n     // Iterate over all children.\n     let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n@@ -579,7 +579,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                                                 child_def_id.krate);\n                 // These items have a public visibility because they're part of\n                 // a public re-export.\n-                callback(def_like, token::str_to_ident(name), ast::Public);\n+                callback(def_like, token::intern(name), ast::Public);\n             }\n         }\n \n@@ -592,7 +592,7 @@ pub fn each_child_of_item(intr: Rc<IdentInterner>,\n                           cdata: Cmd,\n                           id: ast::NodeId,\n                           get_crate_data: GetCrateDataCb,\n-                          callback: |DefLike, ast::Ident, ast::Visibility|) {\n+                          callback: |DefLike, ast::Name, ast::Visibility|) {\n     // Find the item.\n     let root_doc = rbml::Doc::new(cdata.data());\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -613,7 +613,7 @@ pub fn each_top_level_item_of_crate(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n                                     get_crate_data: GetCrateDataCb,\n                                     callback: |DefLike,\n-                                               ast::Ident,\n+                                               ast::Name,\n                                                ast::Visibility|) {\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n@@ -745,7 +745,7 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n                                     id: ast::NodeId)\n-                                    -> (ast::Ident, TraitItemKind) {\n+                                    -> (ast::Name, TraitItemKind) {\n     let doc = lookup_item(id, cdata.data());\n     let name = item_name(&*intr, doc);\n     match item_sort(doc) {\n@@ -800,7 +800,7 @@ pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n         }\n         't' => {\n             ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n-                ident: name,\n+                name: name,\n                 vis: vis,\n                 def_id: def_id,\n                 container: container,\n@@ -885,15 +885,15 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n }\n \n pub fn get_type_name_if_impl(cdata: Cmd,\n-                             node_id: ast::NodeId) -> Option<ast::Ident> {\n+                             node_id: ast::NodeId) -> Option<ast::Name> {\n     let item = lookup_item(node_id, cdata.data());\n     if item_family(item) != Impl {\n         return None;\n     }\n \n     let mut ret = None;\n     reader::tagged_docs(item, tag_item_impl_type_basename, |doc| {\n-        ret = Some(token::str_to_ident(doc.as_str_slice()));\n+        ret = Some(token::intern(doc.as_str_slice()));\n         false\n     });\n \n@@ -936,7 +936,7 @@ pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n                 }\n \n                 static_impl_methods.push(StaticMethodInfo {\n-                    ident: item_name(&*intr, impl_method_doc),\n+                    name: item_name(&*intr, impl_method_doc),\n                     def_id: item_def_id(impl_method_doc, cdata),\n                     fn_style: fn_style,\n                     vis: item_visibility(impl_method_doc),\n@@ -1005,13 +1005,12 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     reader::tagged_docs(item, tag_item_field, |an_item| {\n         let f = item_family(an_item);\n         if f == PublicField || f == InheritedField {\n-            // FIXME #6993: name should be of type Name, not Ident\n             let name = item_name(&*intr, an_item);\n             let did = item_def_id(an_item, cdata);\n             let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n             let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n             result.push(ty::field_ty {\n-                name: name.name,\n+                name: name,\n                 id: did,\n                 vis: struct_field_family_to_visibility(f),\n                 origin: origin_id,\n@@ -1393,7 +1392,7 @@ fn doc_generics(base_doc: rbml::Doc,\n     reader::tagged_docs(doc, tag_region_param_def, |rp_doc| {\n         let ident_str_doc = reader::get_doc(rp_doc,\n                                             tag_region_param_def_ident);\n-        let ident = item_name(&*token::get_ident_interner(), ident_str_doc);\n+        let name = item_name(&*token::get_ident_interner(), ident_str_doc);\n         let def_id_doc = reader::get_doc(rp_doc,\n                                          tag_region_param_def_def_id);\n         let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n@@ -1414,7 +1413,7 @@ fn doc_generics(base_doc: rbml::Doc,\n             true\n         });\n \n-        regions.push(space, ty::RegionParameterDef { name: ident.name,\n+        regions.push(space, ty::RegionParameterDef { name: name,\n                                                      def_id: def_id,\n                                                      space: space,\n                                                      index: index,"}, {"sha": "6fe14a2d12ab50bf9e358abbf66d622c37995e84", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -378,17 +378,17 @@ fn encode_path<PI: Iterator<PathElem> + Clone>(rbml_w: &mut Encoder,\n fn encode_reexported_static_method(rbml_w: &mut Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n-                                   method_ident: Ident) {\n+                                   method_name: Name) {\n     debug!(\"(encode reexported static method) {}::{}\",\n-            exp.name, token::get_ident(method_ident));\n+            exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n     rbml_w.wr_str(def_to_string(method_def_id).as_slice());\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n     rbml_w.wr_str(format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_ident(method_ident)).as_slice());\n+                          token::get_name(method_name)).as_slice());\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -410,7 +410,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                             encode_reexported_static_method(rbml_w,\n                                                             exp,\n                                                             m.def_id,\n-                                                            m.ident);\n+                                                            m.name);\n                         }\n                         ty::TypeTraitItem(_) => {}\n                     }\n@@ -435,7 +435,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                         encode_reexported_static_method(rbml_w,\n                                                         exp,\n                                                         m.def_id,\n-                                                        m.ident);\n+                                                        m.name);\n                     }\n                     _ => {}\n                 }\n@@ -829,7 +829,7 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n                            rbml_w: &mut Encoder,\n                            method_ty: &ty::Method) {\n     encode_def_id(rbml_w, method_ty.def_id);\n-    encode_name(rbml_w, method_ty.ident.name);\n+    encode_name(rbml_w, method_ty.name);\n     encode_generics(rbml_w, ecx, &method_ty.generics,\n                     tag_method_ty_generics);\n     encode_method_fty(ecx, rbml_w, &method_ty.fty);\n@@ -854,7 +854,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           ast_item_opt: Option<&ImplItem>) {\n \n     debug!(\"encode_info_for_method: {} {}\", m.def_id,\n-           token::get_ident(m.ident));\n+           token::get_name(m.name));\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_method_ty_fields(ecx, rbml_w, m);\n@@ -868,7 +868,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     let pty = lookup_item_type(ecx.tcx, m.def_id);\n     encode_bounds_and_type(rbml_w, ecx, &pty);\n \n-    let elem = ast_map::PathName(m.ident.name);\n+    let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n@@ -897,12 +897,12 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n                                    typedef_opt: Option<P<ast::Typedef>>) {\n     debug!(\"encode_info_for_associated_type({},{})\",\n            associated_type.def_id,\n-           token::get_ident(associated_type.ident));\n+           token::get_name(associated_type.name));\n \n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id(rbml_w, associated_type.def_id);\n-    encode_name(rbml_w, associated_type.ident.name);\n+    encode_name(rbml_w, associated_type.name);\n     encode_visibility(rbml_w, associated_type.vis);\n     encode_family(rbml_w, 'y');\n     encode_parent_item(rbml_w, local_def(parent_id));\n@@ -911,7 +911,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n     encode_stability(rbml_w, stab);\n \n-    let elem = ast_map::PathName(associated_type.ident.name);\n+    let elem = ast_map::PathName(associated_type.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n \n     match typedef_opt {\n@@ -1395,7 +1395,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     encode_method_ty_fields(ecx, rbml_w, &*method_ty);\n \n-                    let elem = ast_map::PathName(method_ty.ident.name);\n+                    let elem = ast_map::PathName(method_ty.name);\n                     encode_path(rbml_w,\n                                 path.clone().chain(Some(elem).into_iter()));\n \n@@ -1419,7 +1419,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         ty::StaticExplicitSelfCategory;\n                 }\n                 ty::TypeTraitItem(associated_type) => {\n-                    let elem = ast_map::PathName(associated_type.ident.name);\n+                    let elem = ast_map::PathName(associated_type.name);\n                     encode_path(rbml_w,\n                                 path.clone().chain(Some(elem).into_iter()));\n "}, {"sha": "0e57341a559ff6888d507a232207125e34965290", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -96,13 +96,17 @@ fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n+    ast::Ident::new(parse_name(st, last))\n+}\n+\n+pub fn parse_name(st: &mut PState, last: char) -> ast::Name {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n-    return parse_ident_(st, |a| is_last(last, a) );\n+    parse_name_(st, |a| is_last(last, a) )\n }\n \n-fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n+fn parse_name_(st: &mut PState, is_last: |char| -> bool) -> ast::Name {\n     scan(st, is_last, |bytes| {\n-        token::str_to_ident(str::from_utf8(bytes).unwrap())\n+        token::intern(str::from_utf8(bytes).unwrap())\n     })\n }\n \n@@ -625,7 +629,7 @@ pub fn parse_type_param_def_data(data: &[u8], start: uint,\n }\n \n fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n-    let ident = parse_ident(st, ':');\n+    let name = parse_name(st, ':');\n     let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n     let space = parse_param_space(st);\n     assert_eq!(next(st), '|');\n@@ -639,7 +643,7 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n     let default = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)));\n \n     ty::TypeParameterDef {\n-        ident: ident,\n+        name: name,\n         def_id: def_id,\n         space: space,\n         index: index,"}, {"sha": "e11385654ccc04458b998e4df62a07ab8f2f6ddd", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -383,7 +383,7 @@ pub fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n \n pub fn enc_type_param_def(w: &mut SeekableMemWriter, cx: &ctxt, v: &ty::TypeParameterDef) {\n     mywrite!(w, \"{}:{}|{}|{}|\",\n-             token::get_ident(v.ident), (cx.ds)(v.def_id),\n+             token::get_name(v.name), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);\n     enc_opt(w, v.associated_with, |w, did| mywrite!(w, \"{}\", (cx.ds)(did)));\n     mywrite!(w, \"|\");"}, {"sha": "f5b4dc7273e91fb892821bb87fd5a56b96439609", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -670,7 +670,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             if !contains_field_named(with_field, fields) {\n                 let cmt_field = self.mc.cat_field(&*with_expr,\n                                                   with_cmt.clone(),\n-                                                  with_field.ident,\n+                                                  with_field.name,\n                                                   with_field.mt.ty);\n                 self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n             }\n@@ -681,7 +681,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                                 -> bool\n         {\n             fields.iter().any(\n-                |f| f.ident.node.name == field.ident.name)\n+                |f| f.ident.node.name == field.name)\n         }\n     }\n "}, {"sha": "9646b40ebe37cae8c56c0d0340f30d1b566fedee", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -472,7 +472,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                    expr.id,\n                    expr.repr(self.tcx()),\n                    base_cmt.repr(self.tcx()));\n-            Ok(self.cat_field(expr, base_cmt, f_name.node, expr_ty))\n+            Ok(self.cat_field(expr, base_cmt, f_name.node.name, expr_ty))\n           }\n \n           ast::ExprTupField(ref base, idx, _) => {\n@@ -820,14 +820,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_field<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt,\n-                                 f_name: ast::Ident,\n+                                 f_name: ast::Name,\n                                  f_ty: ty::t)\n                                  -> cmt {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name.name))),\n+            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name))),\n             ty: f_ty,\n             note: NoteNone\n         })\n@@ -1223,7 +1223,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n                 let field_ty = if_ok!(self.pat_ty(&*fp.pat)); // see (*2)\n-                let cmt_field = self.cat_field(pat, cmt.clone(), fp.ident, field_ty);\n+                let cmt_field = self.cat_field(pat, cmt.clone(), fp.ident.name, field_ty);\n                 if_ok!(self.cat_pattern(cmt_field, &*fp.pat, |x,y,z| op(x,y,z)));\n             }\n           }"}, {"sha": "9c06ddca7e8ae0b6761595d4c04ac4b3762e5709", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 212, "deletions": 213, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n \n /// Contains data for specific types of import directives.\n enum ImportDirectiveSubclass {\n-    SingleImport(Ident /* target */, Ident /* source */),\n+    SingleImport(Name /* target */, Name /* source */),\n     GlobImport\n }\n \n@@ -376,7 +376,7 @@ impl Rib {\n \n /// One import directive.\n struct ImportDirective {\n-    module_path: Vec<Ident>,\n+    module_path: Vec<Name>,\n     subclass: ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n@@ -385,7 +385,7 @@ struct ImportDirective {\n }\n \n impl ImportDirective {\n-    fn new(module_path: Vec<Ident> ,\n+    fn new(module_path: Vec<Name> ,\n            subclass: ImportDirectiveSubclass,\n            span: Span,\n            id: NodeId,\n@@ -482,7 +482,7 @@ impl ImportResolution {\n #[deriving(Clone)]\n enum ParentLink {\n     NoParentLink,\n-    ModuleParentLink(Weak<Module>, Ident),\n+    ModuleParentLink(Weak<Module>, Name),\n     BlockParentLink(Weak<Module>, NodeId)\n }\n \n@@ -1058,7 +1058,7 @@ impl<'a> Resolver<'a> {\n      * a block, fails.\n      */\n     fn add_child(&self,\n-                 name: Ident,\n+                 name: Name,\n                  reduced_graph_parent: ReducedGraphParent,\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n@@ -1071,15 +1071,15 @@ impl<'a> Resolver<'a> {\n         let module_ = reduced_graph_parent.module();\n \n         self.check_for_conflicts_between_external_crates_and_items(&*module_,\n-                                                                   name.name,\n+                                                                   name,\n                                                                    sp);\n \n         // Add or reuse the child.\n-        let child = module_.children.borrow().find_copy(&name.name);\n+        let child = module_.children.borrow().find_copy(&name);\n         match child {\n             None => {\n                 let child = Rc::new(NameBindings::new());\n-                module_.children.borrow_mut().insert(name.name, child.clone());\n+                module_.children.borrow_mut().insert(name, child.clone());\n                 child\n             }\n             Some(child) => {\n@@ -1149,14 +1149,14 @@ impl<'a> Resolver<'a> {\n                     self.resolve_error(sp,\n                         format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_ident(name)).as_slice());\n+                             token::get_name(name)).as_slice());\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_ident(name)).as_slice());\n+                                      token::get_name(name)).as_slice());\n                         }\n                     }\n                 }\n@@ -1196,7 +1196,7 @@ impl<'a> Resolver<'a> {\n         return false;\n     }\n \n-    fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Ident)\n+    fn get_parent_link(&mut self, parent: ReducedGraphParent, name: Name)\n                            -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n@@ -1211,16 +1211,16 @@ impl<'a> Resolver<'a> {\n                                     parent: ReducedGraphParent)\n                                     -> ReducedGraphParent\n     {\n-        let ident = item.ident;\n+        let name = item.ident.name;\n         let sp = item.span;\n         let is_public = item.vis == ast::Public;\n \n         match item.node {\n             ItemMod(..) => {\n                 let name_bindings =\n-                    self.add_child(ident, parent.clone(), ForbidDuplicateModules, sp);\n+                    self.add_child(name, parent.clone(), ForbidDuplicateModules, sp);\n \n-                let parent_link = self.get_parent_link(parent, ident);\n+                let parent_link = self.get_parent_link(parent, name);\n                 let def_id = DefId { krate: 0, node: item.id };\n                 name_bindings.define_module(parent_link,\n                                             Some(def_id),\n@@ -1237,22 +1237,22 @@ impl<'a> Resolver<'a> {\n             // These items live in the value namespace.\n             ItemStatic(_, m, _) => {\n                 let name_bindings =\n-                    self.add_child(ident, parent.clone(), ForbidDuplicateValues, sp);\n+                    self.add_child(name, parent.clone(), ForbidDuplicateValues, sp);\n                 let mutbl = m == ast::MutMutable;\n \n                 name_bindings.define_value\n                     (DefStatic(local_def(item.id), mutbl), sp, is_public);\n                 parent\n             }\n             ItemConst(_, _) => {\n-                self.add_child(ident, parent.clone(), ForbidDuplicateValues, sp)\n+                self.add_child(name, parent.clone(), ForbidDuplicateValues, sp)\n                     .define_value(DefConst(local_def(item.id)),\n                                   sp, is_public);\n                 parent\n             }\n             ItemFn(_, fn_style, _, _, _) => {\n                 let name_bindings =\n-                    self.add_child(ident, parent.clone(), ForbidDuplicateValues, sp);\n+                    self.add_child(name, parent.clone(), ForbidDuplicateValues, sp);\n \n                 let def = DefFn(local_def(item.id), fn_style, false);\n                 name_bindings.define_value(def, sp, is_public);\n@@ -1262,7 +1262,7 @@ impl<'a> Resolver<'a> {\n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let name_bindings =\n-                    self.add_child(ident,\n+                    self.add_child(name,\n                                    parent.clone(),\n                                    ForbidDuplicateTypesAndModules,\n                                    sp);\n@@ -1274,7 +1274,7 @@ impl<'a> Resolver<'a> {\n \n             ItemEnum(ref enum_definition, _) => {\n                 let name_bindings =\n-                    self.add_child(ident,\n+                    self.add_child(name,\n                                    parent.clone(),\n                                    ForbidDuplicateTypesAndModules,\n                                    sp);\n@@ -1300,7 +1300,7 @@ impl<'a> Resolver<'a> {\n                     None            => (ForbidDuplicateTypesAndModules, None)\n                 };\n \n-                let name_bindings = self.add_child(ident, parent.clone(), forbid, sp);\n+                let name_bindings = self.add_child(name, parent.clone(), forbid, sp);\n \n                 // Define a name in the type namespace.\n                 name_bindings.define_type(DefTy(local_def(item.id), false), sp, is_public);\n@@ -1335,10 +1335,10 @@ impl<'a> Resolver<'a> {\n                 // Create the module and add all methods.\n                 match ty.node {\n                     TyPath(ref path, _, _) if path.segments.len() == 1 => {\n-                        let name = path.segments.last().unwrap().identifier;\n+                        let mod_name = path.segments.last().unwrap().identifier.name;\n \n                         let parent_opt = parent.module().children.borrow()\n-                                               .find_copy(&name.name);\n+                                               .find_copy(&mod_name);\n                         let new_parent = match parent_opt {\n                             // It already exists\n                             Some(ref child) if child.get_module_if_available()\n@@ -1350,13 +1350,13 @@ impl<'a> Resolver<'a> {\n                             // Create the module\n                             _ => {\n                                 let name_bindings =\n-                                    self.add_child(name,\n+                                    self.add_child(mod_name,\n                                                    parent.clone(),\n                                                    ForbidDuplicateModules,\n                                                    sp);\n \n                                 let parent_link =\n-                                    self.get_parent_link(parent.clone(), ident);\n+                                    self.get_parent_link(parent.clone(), name);\n                                 let def_id = local_def(item.id);\n                                 let ns = TypeNS;\n                                 let is_public =\n@@ -1380,9 +1380,9 @@ impl<'a> Resolver<'a> {\n                             match *impl_item {\n                                 MethodImplItem(ref method) => {\n                                     // Add the method to the module.\n-                                    let ident = method.pe_ident();\n+                                    let name = method.pe_ident().name;\n                                     let method_name_bindings =\n-                                        self.add_child(ident,\n+                                        self.add_child(name,\n                                                        new_parent.clone(),\n                                                        ForbidDuplicateValues,\n                                                        method.span);\n@@ -1413,10 +1413,10 @@ impl<'a> Resolver<'a> {\n                                 }\n                                 TypeImplItem(ref typedef) => {\n                                     // Add the typedef to the module.\n-                                    let ident = typedef.ident;\n+                                    let name = typedef.ident.name;\n                                     let typedef_name_bindings =\n                                         self.add_child(\n-                                            ident,\n+                                            name,\n                                             new_parent.clone(),\n                                             ForbidDuplicateTypesAndModules,\n                                             typedef.span);\n@@ -1448,13 +1448,13 @@ impl<'a> Resolver<'a> {\n \n             ItemTrait(_, _, _, ref methods) => {\n                 let name_bindings =\n-                    self.add_child(ident,\n+                    self.add_child(name,\n                                    parent.clone(),\n                                    ForbidDuplicateTypesAndModules,\n                                    sp);\n \n                 // Add all the methods within to a new module.\n-                let parent_link = self.get_parent_link(parent.clone(), ident);\n+                let parent_link = self.get_parent_link(parent.clone(), name);\n                 name_bindings.define_module(parent_link,\n                                             Some(local_def(item.id)),\n                                             TraitModuleKind,\n@@ -1468,13 +1468,13 @@ impl<'a> Resolver<'a> {\n \n                 // Add the names of all the methods to the trait info.\n                 for method in methods.iter() {\n-                    let (ident, kind) = match *method {\n+                    let (name, kind) = match *method {\n                         ast::RequiredMethod(_) |\n                         ast::ProvidedMethod(_) => {\n                             let ty_m =\n                                 ast_util::trait_item_to_ty_method(method);\n \n-                            let ident = ty_m.ident;\n+                            let name = ty_m.ident.name;\n \n                             // Add it as a name in the trait module.\n                             let (def, static_flag) = match ty_m.explicit_self\n@@ -1497,34 +1497,34 @@ impl<'a> Resolver<'a> {\n                             };\n \n                             let method_name_bindings =\n-                                self.add_child(ident,\n+                                self.add_child(name,\n                                                module_parent.clone(),\n                                                ForbidDuplicateTypesAndValues,\n                                                ty_m.span);\n                             method_name_bindings.define_value(def,\n                                                               ty_m.span,\n                                                               true);\n \n-                            (ident, static_flag)\n+                            (name, static_flag)\n                         }\n                         ast::TypeTraitItem(ref associated_type) => {\n                             let def = DefAssociatedTy(local_def(\n                                     associated_type.id));\n \n                             let name_bindings =\n-                                self.add_child(associated_type.ident,\n+                                self.add_child(associated_type.ident.name,\n                                                module_parent.clone(),\n                                                ForbidDuplicateTypesAndValues,\n                                                associated_type.span);\n                             name_bindings.define_type(def,\n                                                       associated_type.span,\n                                                       true);\n \n-                            (associated_type.ident, TypeTraitItemKind)\n+                            (associated_type.ident.name, TypeTraitItemKind)\n                         }\n                     };\n \n-                    self.trait_item_map.insert((ident.name, def_id), kind);\n+                    self.trait_item_map.insert((name, def_id), kind);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, is_public);\n@@ -1541,7 +1541,7 @@ impl<'a> Resolver<'a> {\n                                        item_id: DefId,\n                                        parent: ReducedGraphParent,\n                                        is_public: bool) {\n-        let ident = variant.node.name;\n+        let name = variant.node.name.name;\n         let is_exported = match variant.node.kind {\n             TupleVariantKind(_) => false,\n             StructVariantKind(_) => {\n@@ -1551,7 +1551,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        let child = self.add_child(ident, parent,\n+        let child = self.add_child(name, parent,\n                                    ForbidDuplicateTypesAndValues,\n                                    variant.span);\n         child.define_value(DefVariant(item_id,\n@@ -1575,14 +1575,14 @@ impl<'a> Resolver<'a> {\n                     ViewPathSimple(_, ref full_path, _) => {\n                         full_path.segments\n                             .as_slice().init()\n-                            .iter().map(|ident| ident.identifier)\n+                            .iter().map(|ident| ident.identifier.name)\n                             .collect()\n                     }\n \n                     ViewPathGlob(ref module_ident_path, _) |\n                     ViewPathList(ref module_ident_path, _, _) => {\n                         module_ident_path.segments\n-                            .iter().map(|ident| ident.identifier).collect()\n+                            .iter().map(|ident| ident.identifier.name).collect()\n                     }\n                 };\n \n@@ -1593,21 +1593,21 @@ impl<'a> Resolver<'a> {\n                     view_item.attrs\n                              .iter()\n                              .any(|attr| {\n-                                 attr.name() == token::get_ident(\n-                                    special_idents::prelude_import)\n+                                 attr.name() == token::get_name(\n+                                    special_idents::prelude_import.name)\n                              });\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path, id) => {\n-                        let source_ident =\n-                            full_path.segments.last().unwrap().identifier;\n-                        if token::get_ident(source_ident).get() == \"mod\" {\n+                        let source_name =\n+                            full_path.segments.last().unwrap().identifier.name;\n+                        if token::get_name(source_name).get() == \"mod\" {\n                             self.resolve_error(view_path.span,\n                                 \"`mod` imports are only allowed within a { } list\");\n                         }\n \n-                        let subclass = SingleImport(binding,\n-                                                    source_ident);\n+                        let subclass = SingleImport(binding.name,\n+                                                    source_name);\n                         self.build_import_directive(&*module_,\n                                                     module_path,\n                                                     subclass,\n@@ -1634,10 +1634,10 @@ impl<'a> Resolver<'a> {\n                         for source_item in source_items.iter() {\n                             let (module_path, name) = match source_item.node {\n                                 PathListIdent { name, .. } =>\n-                                    (module_path.clone(), name),\n+                                    (module_path.clone(), name.name),\n                                 PathListMod { .. } => {\n                                     let name = match module_path.last() {\n-                                        Some(ident) => ident.clone(),\n+                                        Some(name) => *name,\n                                         None => {\n                                             self.resolve_error(source_item.span,\n                                                 \"`mod` import can only appear in an import list \\\n@@ -1678,7 +1678,7 @@ impl<'a> Resolver<'a> {\n                     let def_id = DefId { krate: crate_id, node: 0 };\n                     self.external_exports.insert(def_id);\n                     let parent_link =\n-                        ModuleParentLink(parent.module().downgrade(), name);\n+                        ModuleParentLink(parent.module().downgrade(), name.name);\n                     let external_module = Rc::new(Module::new(parent_link,\n                                                               Some(def_id),\n                                                               NormalModuleKind,\n@@ -1703,7 +1703,7 @@ impl<'a> Resolver<'a> {\n                                             foreign_item: &ForeignItem,\n                                             parent: ReducedGraphParent,\n                                             f: |&mut Resolver|) {\n-        let name = foreign_item.ident;\n+        let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n         let name_bindings =\n             self.add_child(name, parent, ForbidDuplicateValues,\n@@ -1762,7 +1762,7 @@ impl<'a> Resolver<'a> {\n                            vis: Visibility,\n                            child_name_bindings: &NameBindings,\n                            final_ident: &str,\n-                           ident: Ident,\n+                           name: Name,\n                            new_parent: ReducedGraphParent) {\n         debug!(\"(building reduced graph for \\\n                 external crate) building external def, priv {}\",\n@@ -1799,7 +1799,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n                         {}\", final_ident);\n-                let parent_link = self.get_parent_link(new_parent.clone(), ident);\n+                let parent_link = self.get_parent_link(new_parent.clone(), name);\n \n                 child_name_bindings.define_module(parent_link,\n                                                   Some(def_id),\n@@ -1859,9 +1859,9 @@ impl<'a> Resolver<'a> {\n \n                   debug!(\"(building reduced graph for external crate) ... \\\n                           adding trait item '{}'\",\n-                         token::get_ident(trait_item_name));\n+                         token::get_name(trait_item_name));\n \n-                  self.trait_item_map.insert((trait_item_name.name, def_id), trait_item_kind);\n+                  self.trait_item_map.insert((trait_item_name, def_id), trait_item_kind);\n \n                   if is_exported {\n                       self.external_exports\n@@ -1872,7 +1872,7 @@ impl<'a> Resolver<'a> {\n               child_name_bindings.define_type(def, DUMMY_SP, is_public);\n \n               // Define a module if necessary.\n-              let parent_link = self.get_parent_link(new_parent, ident);\n+              let parent_link = self.get_parent_link(new_parent, name);\n               child_name_bindings.set_module_kind(parent_link,\n                                                   Some(def_id),\n                                                   TraitModuleKind,\n@@ -1919,7 +1919,7 @@ impl<'a> Resolver<'a> {\n     fn build_reduced_graph_for_external_crate_def(&mut self,\n                                                   root: Rc<Module>,\n                                                   def_like: DefLike,\n-                                                  ident: Ident,\n+                                                  name: Name,\n                                                   visibility: Visibility) {\n         match def_like {\n             DlDef(def) => {\n@@ -1931,27 +1931,27 @@ impl<'a> Resolver<'a> {\n                         csearch::each_child_of_item(&self.session.cstore,\n                                                     def_id,\n                                                     |def_like,\n-                                                     child_ident,\n+                                                     child_name,\n                                                      vis| {\n                             self.build_reduced_graph_for_external_crate_def(\n                                 root.clone(),\n                                 def_like,\n-                                child_ident,\n+                                child_name,\n                                 vis)\n                         });\n                     }\n                     _ => {\n                         let child_name_bindings =\n-                            self.add_child(ident,\n+                            self.add_child(name,\n                                            ModuleReducedGraphParent(root.clone()),\n                                            OverwriteDuplicates,\n                                            DUMMY_SP);\n \n                         self.handle_external_def(def,\n                                                  visibility,\n                                                  &*child_name_bindings,\n-                                                 token::get_ident(ident).get(),\n-                                                 ident,\n+                                                 token::get_name(name).get(),\n+                                                 name,\n                                                  ModuleReducedGraphParent(root));\n                     }\n                 }\n@@ -1960,7 +1960,7 @@ impl<'a> Resolver<'a> {\n                 // We only process static methods of impls here.\n                 match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n                     None => {}\n-                    Some(final_ident) => {\n+                    Some(final_name) => {\n                         let static_methods_opt =\n                             csearch::get_static_methods_if_impl(&self.session.cstore, def);\n                         match static_methods_opt {\n@@ -1969,11 +1969,11 @@ impl<'a> Resolver<'a> {\n                                 debug!(\"(building reduced graph for \\\n                                         external crate) processing \\\n                                         static methods for type name {}\",\n-                                        token::get_ident(final_ident));\n+                                        token::get_name(final_name));\n \n                                 let child_name_bindings =\n                                     self.add_child(\n-                                        final_ident,\n+                                        final_name,\n                                         ModuleReducedGraphParent(root.clone()),\n                                         OverwriteDuplicates,\n                                         DUMMY_SP);\n@@ -1998,7 +1998,7 @@ impl<'a> Resolver<'a> {\n                                     Some(_) | None => {\n                                         let parent_link =\n                                             self.get_parent_link(ModuleReducedGraphParent(root),\n-                                                                 final_ident);\n+                                                                 final_name);\n                                         child_name_bindings.define_module(\n                                             parent_link,\n                                             Some(def),\n@@ -2017,14 +2017,14 @@ impl<'a> Resolver<'a> {\n                                     ModuleReducedGraphParent(type_module);\n                                 for static_method_info in\n                                         static_methods.iter() {\n-                                    let ident = static_method_info.ident;\n+                                    let name = static_method_info.name;\n                                     debug!(\"(building reduced graph for \\\n                                              external crate) creating \\\n                                              static method '{}'\",\n-                                           token::get_ident(ident));\n+                                           token::get_name(name));\n \n                                     let method_name_bindings =\n-                                        self.add_child(ident,\n+                                        self.add_child(name,\n                                                        new_parent.clone(),\n                                                        OverwriteDuplicates,\n                                                        DUMMY_SP);\n@@ -2067,12 +2067,12 @@ impl<'a> Resolver<'a> {\n \n         csearch::each_child_of_item(&self.session.cstore,\n                                     def_id,\n-                                    |def_like, child_ident, visibility| {\n+                                    |def_like, child_name, visibility| {\n             debug!(\"(populating external module) ... found ident: {}\",\n-                   token::get_ident(child_ident));\n+                   token::get_name(child_name));\n             self.build_reduced_graph_for_external_crate_def(module.clone(),\n                                                             def_like,\n-                                                            child_ident,\n+                                                            child_name,\n                                                             visibility)\n         });\n         module.populated.set(true)\n@@ -2095,18 +2095,18 @@ impl<'a> Resolver<'a> {\n                                                   .get()\n                                                   .unwrap()\n                                                   .krate,\n-                                              |def_like, ident, visibility| {\n+                                              |def_like, name, visibility| {\n             self.build_reduced_graph_for_external_crate_def(root.clone(),\n                                                             def_like,\n-                                                            ident,\n+                                                            name,\n                                                             visibility)\n         });\n     }\n \n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(&mut self,\n                               module_: &Module,\n-                              module_path: Vec<Ident> ,\n+                              module_path: Vec<Name>,\n                               subclass: ImportDirectiveSubclass,\n                               span: Span,\n                               id: NodeId,\n@@ -2126,13 +2126,13 @@ impl<'a> Resolver<'a> {\n             SingleImport(target, _) => {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n-                       self.idents_to_string(module_.imports.borrow().last().unwrap()\n+                       self.names_to_string(module_.imports.borrow().last().unwrap()\n                                                  .module_path.as_slice()),\n-                       token::get_ident(target));\n+                       token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions\n                                                     .borrow_mut();\n-                match import_resolutions.find_mut(&target.name) {\n+                match import_resolutions.find_mut(&target) {\n                     Some(resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n@@ -2149,7 +2149,7 @@ impl<'a> Resolver<'a> {\n                 debug!(\"(building import directive) creating new\");\n                 let mut resolution = ImportResolution::new(id, is_public);\n                 resolution.outstanding_references = 1;\n-                import_resolutions.insert(target.name, resolution);\n+                import_resolutions.insert(target, resolution);\n             }\n             GlobImport => {\n                 // Set the glob flag. This tells us that we don't know the\n@@ -2259,48 +2259,48 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn idents_to_string(&self, idents: &[Ident]) -> String {\n+    fn names_to_string(&self, names: &[Name]) -> String {\n         let mut first = true;\n         let mut result = String::new();\n-        for ident in idents.iter() {\n+        for name in names.iter() {\n             if first {\n                 first = false\n             } else {\n                 result.push_str(\"::\")\n             }\n-            result.push_str(token::get_ident(*ident).get());\n+            result.push_str(token::get_name(*name).get());\n         };\n         result\n     }\n \n-    fn path_idents_to_string(&self, path: &Path) -> String {\n-        let identifiers: Vec<ast::Ident> = path.segments\n-                                             .iter()\n-                                             .map(|seg| seg.identifier)\n-                                             .collect();\n-        self.idents_to_string(identifiers.as_slice())\n+    fn path_names_to_string(&self, path: &Path) -> String {\n+        let names: Vec<ast::Name> = path.segments\n+                                        .iter()\n+                                        .map(|seg| seg.identifier.name)\n+                                        .collect();\n+        self.names_to_string(names.as_slice())\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n                                         subclass: ImportDirectiveSubclass)\n                                         -> String {\n         match subclass {\n             SingleImport(_, source) => {\n-                token::get_ident(source).get().to_string()\n+                token::get_name(source).get().to_string()\n             }\n             GlobImport => \"*\".to_string()\n         }\n     }\n \n     fn import_path_to_string(&mut self,\n-                          idents: &[Ident],\n+                          names: &[Name],\n                           subclass: ImportDirectiveSubclass)\n                           -> String {\n-        if idents.is_empty() {\n+        if names.is_empty() {\n             self.import_directive_subclass_to_string(subclass)\n         } else {\n             (format!(\"{}::{}\",\n-                     self.idents_to_string(idents),\n+                     self.names_to_string(names),\n                      self.import_directive_subclass_to_string(\n                          subclass))).to_string()\n         }\n@@ -2320,7 +2320,7 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in \\\n                 `{}`\",\n-               self.idents_to_string(module_path.as_slice()),\n+               self.names_to_string(module_path.as_slice()),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -2418,16 +2418,16 @@ impl<'a> Resolver<'a> {\n     fn resolve_single_import(&mut self,\n                              module_: &Module,\n                              containing_module: Rc<Module>,\n-                             target: Ident,\n-                             source: Ident,\n+                             target: Name,\n+                             source: Name,\n                              directive: &ImportDirective,\n                              lp: LastPrivate)\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n                 `{}` id {}, last private {}\",\n-               token::get_ident(target),\n+               token::get_name(target),\n                self.module_to_string(&*containing_module),\n-               token::get_ident(source),\n+               token::get_name(source),\n                self.module_to_string(module_),\n                directive.id,\n                lp);\n@@ -2450,7 +2450,7 @@ impl<'a> Resolver<'a> {\n         // Search for direct children of the containing module.\n         self.populate_module_if_necessary(&containing_module);\n \n-        match containing_module.children.borrow().find(&source.name) {\n+        match containing_module.children.borrow().find(&source) {\n             None => {\n                 // Continue.\n             }\n@@ -2486,7 +2486,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // Now search the exported imports within the containing module.\n-                match containing_module.import_resolutions.borrow().find(&source.name) {\n+                match containing_module.import_resolutions.borrow().find(&source) {\n                     None => {\n                         debug!(\"(resolving single import) no import\");\n                         // The containing module definitely doesn't have an\n@@ -2573,7 +2573,7 @@ impl<'a> Resolver<'a> {\n             BoundResult(..) => {}\n             _ => {\n                 match containing_module.external_module_children.borrow_mut()\n-                                       .find_copy(&source.name) {\n+                                       .find_copy(&source) {\n                     None => {} // Continue.\n                     Some(module) => {\n                         debug!(\"(resolving single import) found external \\\n@@ -2596,7 +2596,7 @@ impl<'a> Resolver<'a> {\n \n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let import_resolution = import_resolutions.get_mut(&target.name);\n+        let import_resolution = import_resolutions.get_mut(&target);\n \n         match value_result {\n             BoundResult(ref target_module, ref name_bindings) => {\n@@ -2605,7 +2605,7 @@ impl<'a> Resolver<'a> {\n                 self.check_for_conflicting_import(\n                     &import_resolution.value_target,\n                     directive.span,\n-                    target.name,\n+                    target,\n                     ValueNS);\n \n                 import_resolution.value_target =\n@@ -2628,7 +2628,7 @@ impl<'a> Resolver<'a> {\n                 self.check_for_conflicting_import(\n                     &import_resolution.type_target,\n                     directive.span,\n-                    target.name,\n+                    target,\n                     TypeNS);\n \n                 import_resolution.type_target =\n@@ -2649,11 +2649,11 @@ impl<'a> Resolver<'a> {\n             module_,\n             import_resolution,\n             directive.span,\n-            target.name);\n+            target);\n \n         if value_result.is_unbound() && type_result.is_unbound() {\n             let msg = format!(\"There is no `{}` in `{}`\",\n-                              token::get_ident(source),\n+                              token::get_name(source),\n                               self.module_to_string(&*containing_module));\n             return Failed(Some((directive.span, msg)));\n         }\n@@ -3052,7 +3052,7 @@ impl<'a> Resolver<'a> {\n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n                                      module_: Rc<Module>,\n-                                     module_path: &[Ident],\n+                                     module_path: &[Name],\n                                      index: uint,\n                                      span: Span,\n                                      name_search_type: NameSearchType,\n@@ -3085,21 +3085,21 @@ impl<'a> Resolver<'a> {\n         while index < module_path_len {\n             let name = module_path[index];\n             match self.resolve_name_in_module(search_module.clone(),\n-                                              name.name,\n+                                              name,\n                                               TypeNS,\n                                               name_search_type,\n                                               false) {\n                 Failed(None) => {\n-                    let segment_name = token::get_ident(name);\n+                    let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == module_name.as_slice() {\n                         span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n \n-                        match search_parent_externals(name.name,\n+                        match search_parent_externals(name,\n                                                      &self.current_module) {\n                             Some(module) => {\n-                                let path_str = self.idents_to_string(module_path);\n+                                let path_str = self.names_to_string(module_path);\n                                 let target_mod_str = self.module_to_string(&*module);\n                                 let current_mod_str =\n                                     self.module_to_string(&*self.current_module);\n@@ -3127,7 +3127,7 @@ impl<'a> Resolver<'a> {\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: {}\",\n-                            token::get_ident(name));\n+                            token::get_name(name));\n                     return Indeterminate;\n                 }\n                 Success((target, used_proxy)) => {\n@@ -3138,7 +3138,7 @@ impl<'a> Resolver<'a> {\n                             match type_def.module_def {\n                                 None => {\n                                     let msg = format!(\"Not a module `{}`\",\n-                                                        token::get_ident(name));\n+                                                        token::get_name(name));\n \n                                     return Failed(Some((span, msg)));\n                                 }\n@@ -3188,7 +3188,7 @@ impl<'a> Resolver<'a> {\n                         None => {\n                             // There are no type bindings at all.\n                             let msg = format!(\"Not a module `{}`\",\n-                                              token::get_ident(name));\n+                                              token::get_name(name));\n                             return Failed(Some((span, msg)));\n                         }\n                     }\n@@ -3208,7 +3208,7 @@ impl<'a> Resolver<'a> {\n     /// module found to the destination when resolving this path.\n     fn resolve_module_path(&mut self,\n                            module_: Rc<Module>,\n-                           module_path: &[Ident],\n+                           module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span,\n                            name_search_type: NameSearchType)\n@@ -3218,7 +3218,7 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at \\\n                `{}`\",\n-               self.idents_to_string(module_path),\n+               self.names_to_string(module_path),\n                self.module_to_string(&*module_));\n \n         // Resolve the module prefix, if any.\n@@ -3230,7 +3230,7 @@ impl<'a> Resolver<'a> {\n         let last_private;\n         match module_prefix_result {\n             Failed(None) => {\n-                let mpath = self.idents_to_string(module_path);\n+                let mpath = self.names_to_string(module_path);\n                 let mpath = mpath.as_slice();\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n@@ -3305,20 +3305,20 @@ impl<'a> Resolver<'a> {\n     /// import resolution.\n     fn resolve_item_in_lexical_scope(&mut self,\n                                      module_: Rc<Module>,\n-                                     name: Ident,\n+                                     name: Name,\n                                      namespace: Namespace)\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n                 namespace {} in `{}`\",\n-               token::get_ident(name),\n+               token::get_name(name),\n                namespace,\n                self.module_to_string(&*module_));\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n         self.populate_module_if_necessary(&module_);\n \n-        match module_.children.borrow().find(&name.name) {\n+        match module_.children.borrow().find(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"top name bindings succeeded\");\n@@ -3334,7 +3334,7 @@ impl<'a> Resolver<'a> {\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-        match module_.import_resolutions.borrow().find(&name.name) {\n+        match module_.import_resolutions.borrow().find(&name) {\n             None => {\n                 // Not found; continue.\n             }\n@@ -3363,7 +3363,7 @@ impl<'a> Resolver<'a> {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            match module_.external_module_children.borrow().find_copy(&name.name) {\n+            match module_.external_module_children.borrow().find_copy(&name) {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3412,7 +3412,7 @@ impl<'a> Resolver<'a> {\n \n             // Resolve the name in the parent module.\n             match self.resolve_name_in_module(search_module.clone(),\n-                                              name.name,\n+                                              name,\n                                               namespace,\n                                               PathSearch,\n                                               true) {\n@@ -3441,7 +3441,7 @@ impl<'a> Resolver<'a> {\n     /// Resolves a module name in the current lexical scope.\n     fn resolve_module_in_lexical_scope(&mut self,\n                                        module_: Rc<Module>,\n-                                       name: Ident)\n+                                       name: Name)\n                                 -> ResolveResult<Rc<Module>> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n@@ -3526,13 +3526,13 @@ impl<'a> Resolver<'a> {\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     fn resolve_module_prefix(&mut self,\n                              module_: Rc<Module>,\n-                             module_path: &[Ident])\n+                             module_path: &[Name])\n                                  -> ResolveResult<ModulePrefixResult> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n         let mut containing_module;\n         let mut i;\n-        let first_module_path_string = token::get_ident(module_path[0]);\n+        let first_module_path_string = token::get_name(module_path[0]);\n         if \"self\" == first_module_path_string.get() {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n@@ -3547,7 +3547,7 @@ impl<'a> Resolver<'a> {\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() {\n-            let string = token::get_ident(module_path[i]);\n+            let string = token::get_name(module_path[i]);\n             if \"super\" != string.get() {\n                 break\n             }\n@@ -3839,7 +3839,7 @@ impl<'a> Resolver<'a> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(&mut self, name: Option<Ident>, f: |&mut Resolver|) {\n+    fn with_scope(&mut self, name: Option<Name>, f: |&mut Resolver|) {\n         let orig_module = self.current_module.clone();\n \n         // Move down in the graph.\n@@ -3850,18 +3850,18 @@ impl<'a> Resolver<'a> {\n             Some(name) => {\n                 self.populate_module_if_necessary(&orig_module);\n \n-                match orig_module.children.borrow().find(&name.name) {\n+                match orig_module.children.borrow().find(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n-                               token::get_ident(name),\n+                               token::get_name(name),\n                                self.module_to_string(&*orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n-                                       token::get_ident(name),\n+                                       token::get_name(name),\n                                        self.module_to_string(&*orig_module));\n                             }\n                             Some(module_) => {\n@@ -4050,8 +4050,10 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_item(&mut self, item: &Item) {\n+        let name = item.ident.name;\n+\n         debug!(\"(resolving item) resolving {}\",\n-               token::get_ident(item.ident));\n+               token::get_name(name));\n \n         match item.node {\n \n@@ -4190,14 +4192,14 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemMod(ref module_) => {\n-                self.with_scope(Some(item.ident), |this| {\n-                    this.resolve_module(module_, item.span, item.ident,\n+                self.with_scope(Some(name), |this| {\n+                    this.resolve_module(module_, item.span, name,\n                                         item.id);\n                 });\n             }\n \n             ItemForeignMod(ref foreign_module) => {\n-                self.with_scope(Some(item.ident), |this| {\n+                self.with_scope(Some(name), |this| {\n                     for foreign_item in foreign_module.items.iter() {\n                         match foreign_item.node {\n                             ForeignItemFn(_, ref generics) => {\n@@ -4248,20 +4250,20 @@ impl<'a> Resolver<'a> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = HashSet::new();\n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n-                    let ident = type_parameter.ident;\n+                    let name = type_parameter.ident.name;\n                     debug!(\"with_type_parameter_rib: {} {}\", node_id,\n                            type_parameter.id);\n \n-                    if seen_bindings.contains(&ident) {\n+                    if seen_bindings.contains(&name) {\n                         self.resolve_error(type_parameter.span,\n                                            format!(\"the name `{}` is already \\\n                                                     used for a type \\\n                                                     parameter in this type \\\n                                                     parameter list\",\n-                                                   token::get_ident(\n-                                                       ident)).as_slice())\n+                                                   token::get_name(\n+                                                       name)).as_slice())\n                     }\n-                    seen_bindings.insert(ident);\n+                    seen_bindings.insert(name);\n \n                     let def_like = DlDef(DefTyParam(space,\n                                                     local_def(type_parameter.id),\n@@ -4271,7 +4273,7 @@ impl<'a> Resolver<'a> {\n                     self.record_def(type_parameter.id,\n                                     (DefTyParamBinder(node_id), LastMod(AllPublic)));\n                     // plain insert (no renaming)\n-                    function_type_rib.bindings.insert(ident.name, def_like);\n+                    function_type_rib.bindings.insert(name, def_like);\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }\n@@ -4404,7 +4406,7 @@ impl<'a> Resolver<'a> {\n                                         TypeNS,\n                                         true) {\n                     None => {\n-                        let path_str = self.path_idents_to_string(\n+                        let path_str = self.path_names_to_string(\n                             &unboxed_function.path);\n                         self.resolve_error(unboxed_function.path.span,\n                                            format!(\"unresolved trait `{}`\",\n@@ -4418,7 +4420,7 @@ impl<'a> Resolver<'a> {\n                             _ => {\n                                 let msg =\n                                     format!(\"`{}` is not a trait\",\n-                                            self.path_idents_to_string(\n+                                            self.path_names_to_string(\n                                                 &unboxed_function.path));\n                                 self.resolve_error(unboxed_function.path.span,\n                                                    msg.as_slice());\n@@ -4443,7 +4445,7 @@ impl<'a> Resolver<'a> {\n                                reference_type: TraitReferenceType) {\n         match self.resolve_path(id, &trait_reference.path, TypeNS, true) {\n             None => {\n-                let path_str = self.path_idents_to_string(&trait_reference.path);\n+                let path_str = self.path_names_to_string(&trait_reference.path);\n                 let usage_str = match reference_type {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n@@ -4462,7 +4464,7 @@ impl<'a> Resolver<'a> {\n                     (def, _) => {\n                         self.resolve_error(trait_reference.path.span,\n                                            format!(\"`{}` is not a trait\",\n-                                                   self.path_idents_to_string(\n+                                                   self.path_names_to_string(\n                                                         &trait_reference.path)));\n \n                         // If it's a typedef, give a note\n@@ -4609,7 +4611,7 @@ impl<'a> Resolver<'a> {\n                             MethodImplItem(ref method) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n-                                this.check_trait_item(method.pe_ident(),\n+                                this.check_trait_item(method.pe_ident().name,\n                                                       method.span);\n \n                                 // We also need a new scope for the method-\n@@ -4621,7 +4623,7 @@ impl<'a> Resolver<'a> {\n                             TypeImplItem(ref typedef) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n-                                this.check_trait_item(typedef.ident,\n+                                this.check_trait_item(typedef.ident.name,\n                                                       typedef.span);\n \n                                 this.resolve_type(&*typedef.typ);\n@@ -4657,23 +4659,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn check_trait_item(&self, ident: Ident, span: Span) {\n+    fn check_trait_item(&self, name: Name, span: Span) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n-            let method_name = ident.name;\n-\n-            if self.trait_item_map.find(&(method_name, did)).is_none() {\n-                let path_str = self.path_idents_to_string(&trait_ref.path);\n+            if self.trait_item_map.find(&(name, did)).is_none() {\n+                let path_str = self.path_names_to_string(&trait_ref.path);\n                 self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n-                                            token::get_name(method_name),\n+                                            token::get_name(name),\n                                             path_str).as_slice());\n             }\n         }\n     }\n \n     fn resolve_module(&mut self, module: &Mod, _span: Span,\n-                      _name: Ident, id: NodeId) {\n+                      _name: Name, id: NodeId) {\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID {}\", id);\n         visit::walk_mod(self, module);\n@@ -4869,13 +4869,13 @@ impl<'a> Resolver<'a> {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n                                 (id {})\",\n-                               self.path_idents_to_string(path),\n+                               self.path_names_to_string(path),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n-                                          self.path_idents_to_string(path));\n+                                          self.path_names_to_string(path));\n                         self.resolve_error(ty.span, msg.as_slice());\n                     }\n                 }\n@@ -4890,15 +4890,15 @@ impl<'a> Resolver<'a> {\n                 self.resolve_type(&*qpath.for_type);\n \n                 let current_module = self.current_module.clone();\n-                let module_path_idents: Vec<_> =\n+                let module_path: Vec<_> =\n                     qpath.trait_name\n                          .segments\n                          .iter()\n-                         .map(|ps| ps.identifier)\n+                         .map(|ps| ps.identifier.name)\n                          .collect();\n                 match self.resolve_module_path(\n                         current_module,\n-                        module_path_idents.as_slice(),\n+                        module_path.as_slice(),\n                         UseLexicalScope,\n                         qpath.trait_name.span,\n                         PathSearch) {\n@@ -4968,7 +4968,7 @@ impl<'a> Resolver<'a> {\n                        mode: PatternBindingMode,\n                        // Maps idents to the node ID for the (outermost)\n                        // pattern that binds them\n-                       bindings_list: &mut HashMap<Name,NodeId>) {\n+                       bindings_list: &mut HashMap<Name, NodeId>) {\n         let pat_id = pattern.id;\n         walk_pat(pattern, |pattern| {\n             match pattern.node {\n@@ -4986,7 +4986,7 @@ impl<'a> Resolver<'a> {\n                     let ident = path1.node;\n                     let renamed = mtwt::resolve(ident);\n \n-                    match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n+                    match self.resolve_bare_identifier_pattern(ident.name, pattern.span) {\n                         FoundStructOrEnumVariant(ref def, lp)\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -5135,7 +5135,7 @@ impl<'a> Resolver<'a> {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n-                                              self.path_idents_to_string(path));\n+                                              self.path_names_to_string(path));\n                             self.resolve_error(path.span, msg.as_slice());\n                         }\n                     }\n@@ -5149,7 +5149,7 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n-    fn resolve_bare_identifier_pattern(&mut self, name: Ident, span: Span)\n+    fn resolve_bare_identifier_pattern(&mut self, name: Name, span: Span)\n                                        -> BareIdentifierPatternResolution {\n         let module = self.current_module.clone();\n         match self.resolve_item_in_lexical_scope(module,\n@@ -5158,7 +5158,7 @@ impl<'a> Resolver<'a> {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n                          finding {} at {}\",\n-                        token::get_ident(name),\n+                        token::get_name(name),\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n                     None => {\n@@ -5204,7 +5204,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 debug!(\"(resolve bare identifier pattern) failed to find {}\",\n-                        token::get_ident(name));\n+                        token::get_name(name));\n                 return BareIdentifierPatternUnresolved;\n             }\n         }\n@@ -5273,8 +5273,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        return self.resolve_item_by_identifier_in_lexical_scope(identifier,\n-                                                                namespace);\n+        return self.resolve_item_by_name_in_lexical_scope(identifier.name, namespace);\n     }\n \n     // FIXME #4952: Merge me with resolve_name_in_module?\n@@ -5364,15 +5363,15 @@ impl<'a> Resolver<'a> {\n                                         path: &Path,\n                                         namespace: Namespace)\n                                         -> Option<(Def, LastPrivate)> {\n-        let module_path_idents = path.segments.init().iter()\n-                                                     .map(|ps| ps.identifier)\n-                                                     .collect::<Vec<_>>();\n+        let module_path = path.segments.init().iter()\n+                                              .map(|ps| ps.identifier.name)\n+                                              .collect::<Vec<_>>();\n \n         let containing_module;\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       module_path_idents.as_slice(),\n+                                       module_path.as_slice(),\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -5381,8 +5380,8 @@ impl<'a> Resolver<'a> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `{}`\",\n-                                          self.idents_to_string(\n-                                               module_path_idents.as_slice()));\n+                                          self.names_to_string(\n+                                               module_path.as_slice()));\n                         (path.span, msg)\n                     }\n                 };\n@@ -5398,9 +5397,9 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let ident = path.segments.last().unwrap().identifier;\n+        let name = path.segments.last().unwrap().identifier.name;\n         let def = match self.resolve_definition_of_name_in_module(containing_module.clone(),\n-                                                                  ident.name,\n+                                                                  name,\n                                                                   namespace) {\n             NoNameDefinition => {\n                 // We failed to resolve the name. Report an error.\n@@ -5423,16 +5422,16 @@ impl<'a> Resolver<'a> {\n                                    path: &Path,\n                                    namespace: Namespace)\n                                        -> Option<(Def, LastPrivate)> {\n-        let module_path_idents = path.segments.init().iter()\n-                                                     .map(|ps| ps.identifier)\n-                                                     .collect::<Vec<_>>();\n+        let module_path = path.segments.init().iter()\n+                                              .map(|ps| ps.identifier.name)\n+                                              .collect::<Vec<_>>();\n \n         let root_module = self.graph_root.get_module();\n \n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 module_path_idents.as_slice(),\n+                                                 module_path.as_slice(),\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -5442,8 +5441,7 @@ impl<'a> Resolver<'a> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.idents_to_string(\n-                                               module_path_idents.as_slice()));\n+                                          self.names_to_string(module_path.as_slice()));\n                         (path.span, msg)\n                     }\n                 };\n@@ -5509,14 +5507,14 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_item_by_identifier_in_lexical_scope(&mut self,\n-                                                   ident: Ident,\n-                                                   namespace: Namespace)\n-                                                -> Option<(Def, LastPrivate)> {\n+    fn resolve_item_by_name_in_lexical_scope(&mut self,\n+                                             name: Name,\n+                                             namespace: Namespace)\n+                                            -> Option<(Def, LastPrivate)> {\n         // Check the items.\n         let module = self.current_module.clone();\n         match self.resolve_item_in_lexical_scope(module,\n-                                                 ident,\n+                                                 name,\n                                                  namespace) {\n             Success((target, _)) => {\n                 match (*target.bindings).def_for_namespace(namespace) {\n@@ -5525,13 +5523,13 @@ impl<'a> Resolver<'a> {\n                         // found a module instead. Modules don't have defs.\n                         debug!(\"(resolving item path by identifier in lexical \\\n                                  scope) failed to resolve {} after success...\",\n-                                 token::get_ident(ident));\n+                                 token::get_name(name));\n                         return None;\n                     }\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `{}` to item\",\n-                               token::get_ident(ident));\n+                               token::get_name(name));\n                         // This lookup is \"all public\" because it only searched\n                         // for one identifier in the current module (couldn't\n                         // have passed through reexports or anything like that.\n@@ -5550,7 +5548,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 debug!(\"(resolving item path by identifier in lexical scope) \\\n-                         failed to resolve {}\", token::get_ident(ident));\n+                         failed to resolve {}\", token::get_name(name));\n                 return None;\n             }\n         }\n@@ -5589,24 +5587,24 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        fn get_module(this: &mut Resolver, span: Span, ident_path: &[ast::Ident])\n+        fn get_module(this: &mut Resolver, span: Span, name_path: &[ast::Name])\n                             -> Option<Rc<Module>> {\n             let root = this.current_module.clone();\n-            let last_name = ident_path.last().unwrap().name;\n+            let last_name = name_path.last().unwrap();\n \n-            if ident_path.len() == 1 {\n-                match this.primitive_type_table.primitive_types.find(&last_name) {\n+            if name_path.len() == 1 {\n+                match this.primitive_type_table.primitive_types.find(last_name) {\n                     Some(_) => None,\n                     None => {\n-                        match this.current_module.children.borrow().find(&last_name) {\n+                        match this.current_module.children.borrow().find(last_name) {\n                             Some(child) => child.get_module_if_available(),\n                             None => None\n                         }\n                     }\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                ident_path.as_slice(),\n+                                                name_path.as_slice(),\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -5641,13 +5639,13 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let ident_path = path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n+        let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, ident_path.as_slice()) {\n+        match get_module(self, path.span, name_path.as_slice()) {\n             Some(module) => match module.children.borrow().find(&name) {\n                 Some(binding) => {\n-                    let p_str = self.path_idents_to_string(&path);\n+                    let p_str = self.path_names_to_string(&path);\n                     match binding.def_for_namespace(ValueNS) {\n                         Some(DefStaticMethod(_, provenance, _)) => {\n                             match provenance {\n@@ -5668,7 +5666,7 @@ impl<'a> Resolver<'a> {\n         // Look for a method in the current trait.\n         match self.current_trait_ref {\n             Some((did, ref trait_ref)) => {\n-                let path_str = self.path_idents_to_string(&trait_ref.path);\n+                let path_str = self.path_names_to_string(&trait_ref.path);\n \n                 match self.trait_item_map.find(&(name, did)) {\n                     Some(&StaticMethodTraitItemKind) => {\n@@ -5739,11 +5737,12 @@ impl<'a> Resolver<'a> {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n-                               self.path_idents_to_string(path));\n+                               self.path_names_to_string(path));\n+\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n-                        let wrong_name = self.path_idents_to_string(path);\n+                        let wrong_name = self.path_names_to_string(path);\n                         // Be helpful if the name refers to a struct\n                         // (The pattern matching def_tys where the id is in self.structs\n                         // matches on regular structs while excluding tuple- and enum-like\n@@ -5851,7 +5850,7 @@ impl<'a> Resolver<'a> {\n                         debug!(\"(resolving expression) didn't find struct \\\n                                 def: {}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n-                                          self.path_idents_to_string(path));\n+                                          self.path_names_to_string(path));\n                         self.resolve_error(path.span, msg.as_slice());\n                     }\n                 }\n@@ -6196,30 +6195,30 @@ impl<'a> Resolver<'a> {\n \n     /// A somewhat inefficient routine to obtain the name of a module.\n     fn module_to_string(&self, module: &Module) -> String {\n-        let mut idents = Vec::new();\n+        let mut names = Vec::new();\n \n-        fn collect_mod(idents: &mut Vec<ast::Ident>, module: &Module) {\n+        fn collect_mod(names: &mut Vec<ast::Name>, module: &Module) {\n             match module.parent_link {\n                 NoParentLink => {}\n                 ModuleParentLink(ref module, name) => {\n-                    idents.push(name);\n-                    collect_mod(idents, &*module.upgrade().unwrap());\n+                    names.push(name);\n+                    collect_mod(names, &*module.upgrade().unwrap());\n                 }\n                 BlockParentLink(ref module, _) => {\n                     // danger, shouldn't be ident?\n-                    idents.push(special_idents::opaque);\n-                    collect_mod(idents, &*module.upgrade().unwrap());\n+                    names.push(special_idents::opaque.name);\n+                    collect_mod(names, &*module.upgrade().unwrap());\n                 }\n             }\n         }\n-        collect_mod(&mut idents, module);\n+        collect_mod(&mut names, module);\n \n-        if idents.len() == 0 {\n+        if names.len() == 0 {\n             return \"???\".to_string();\n         }\n-        self.idents_to_string(idents.into_iter().rev()\n-                                 .collect::<Vec<ast::Ident>>()\n-                                 .as_slice())\n+        self.names_to_string(names.into_iter().rev()\n+                                  .collect::<Vec<ast::Name>>()\n+                                  .as_slice())\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "5c2c879040ff892802f50988d570296b171c002a", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -794,7 +794,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                  def_id)\n                                     .iter()\n                                     .find(|mr| {\n-                                        mr.ident().name == ti.ident().name\n+                                        mr.name() == ti.name()\n                                     })\n                                     .unwrap()\n                                     .def_id())\n@@ -807,10 +807,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             Some((*impl_items)[def_id]\n                                            .iter()\n                                            .find(|mr| {\n-                                            ty::impl_or_trait_item(\n-                                                &self.analysis.ty_cx,\n-                                                mr.def_id()).ident().name ==\n-                                                ti.ident().name\n+                                                ty::impl_or_trait_item(\n+                                                    &self.analysis.ty_cx,\n+                                                    mr.def_id()\n+                                                ).name() == ti.name()\n                                             })\n                                            .unwrap()\n                                            .def_id())"}, {"sha": "496838c9e84f23ecbd1a253fd9173356fc3afa36", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -59,7 +59,7 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n             fields.len() == 1 &&\n-                fields[0].ident.name ==\n+                fields[0].name ==\n                     token::special_idents::unnamed_field.name &&\n                 type_is_immediate(ccx, fields[0].mt.ty)\n         }"}, {"sha": "2f193754c1a50624469c1cdc08608d29e411fb6b", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -585,7 +585,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n                   let cs = field_tys.iter().enumerate()\n                                     .map(|(ix, &field_ty)| {\n-                      match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n+                      match fs.iter().find(|f| field_ty.name == f.ident.node.name) {\n                           Some(ref f) => const_expr(cx, &*f.expr).val0(),\n                           None => {\n                               match base_val {"}, {"sha": "90801a4eaa39dbe457ac3ff2877f611a9e4b3664", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -1931,10 +1931,10 @@ impl StructMemberDescriptionFactory {\n         };\n \n         self.fields.iter().enumerate().map(|(i, field)| {\n-            let name = if field.ident.name == special_idents::unnamed_field.name {\n+            let name = if field.name == special_idents::unnamed_field.name {\n                 \"\".to_string()\n             } else {\n-                token::get_ident(field.ident).get().to_string()\n+                token::get_name(field.name).get().to_string()\n             };\n \n             let offset = if self.is_simd {\n@@ -2142,8 +2142,7 @@ impl EnumMemberDescriptionFactory {\n \n                 // First create a description of the artificial wrapper struct:\n                 let non_null_variant = &(*self.variants)[non_null_variant_index as uint];\n-                let non_null_variant_ident = non_null_variant.name;\n-                let non_null_variant_name = token::get_ident(non_null_variant_ident);\n+                let non_null_variant_name = token::get_name(non_null_variant.name);\n \n                 // The llvm type and metadata of the pointer\n                 let non_null_llvm_type = type_of::type_of(cx, nnty);\n@@ -2188,8 +2187,7 @@ impl EnumMemberDescriptionFactory {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - non_null_variant_index) as uint;\n-                let null_variant_ident = (*self.variants)[null_variant_index].name;\n-                let null_variant_name = token::get_ident(null_variant_ident);\n+                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0u,\n                                                 null_variant_name);\n@@ -2230,8 +2228,7 @@ impl EnumMemberDescriptionFactory {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as uint;\n-                let null_variant_ident = (*self.variants)[null_variant_index].name;\n-                let null_variant_name = token::get_ident(null_variant_ident);\n+                let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n                 let discrfield = match ptrfield {\n                     adt::ThinPointer(field) => format!(\"{}\", field),\n                     adt::FatPointer(field, pair) => format!(\"{}${}\", field, pair)\n@@ -2307,7 +2304,7 @@ fn describe_enum_variant(cx: &CrateContext,\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n-    let variant_name = token::get_ident(variant_info.name);\n+    let variant_name = token::get_name(variant_info.name);\n     let variant_name = variant_name.get();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n@@ -2377,7 +2374,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n         .map(|v| {\n-            token::get_ident(v.name).get().with_c_str(|name| {\n+            token::get_name(v.name).get().with_c_str(|name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerator(\n                         DIB(cx),"}, {"sha": "601ac18cf6af3d0794e9eb63eca725d44bacaf7c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -1328,7 +1328,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let numbered_fields = fields.iter().map(|field| {\n             let opt_pos =\n                 field_tys.iter().position(|field_ty|\n-                                          field_ty.ident.name == field.ident.node.name);\n+                                          field_ty.name == field.ident.node.name);\n             match opt_pos {\n                 Some(i) => {\n                     *need_base.get_mut(i) = false;"}, {"sha": "a0bb16b35c7d5be67aff0d22f11153229be6f8e6", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -300,10 +300,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                   .expect(\"could not find impl while translating\");\n     let meth_did = impl_items.iter()\n                              .find(|&did| {\n-                                ty::impl_or_trait_item(ccx.tcx(),\n-                                                       did.def_id()).ident()\n-                                                                    .name ==\n-                                    name\n+                                ty::impl_or_trait_item(ccx.tcx(), did.def_id()).name() == name\n                              }).expect(\"could not find method while \\\n                                         translating\");\n \n@@ -324,13 +321,13 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let ccx = bcx.ccx();\n             let impl_did = vtable_impl.impl_def_id;\n             let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n-                ty::MethodTraitItem(method) => method.ident,\n+                ty::MethodTraitItem(method) => method.name,\n                 ty::TypeTraitItem(_) => {\n                     bcx.tcx().sess.bug(\"can't monomorphize an associated \\\n                                         type\")\n                 }\n             };\n-            let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n+            let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n \n             // create a concatenated set of substitutions which includes\n             // those from the impl and those from the method:\n@@ -703,10 +700,10 @@ fn emit_vtable_methods(bcx: Block,\n     let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n     trait_item_def_ids.iter().flat_map(|method_def_id| {\n         let method_def_id = method_def_id.def_id();\n-        let ident = ty::impl_or_trait_item(tcx, method_def_id).ident();\n+        let name = ty::impl_or_trait_item(tcx, method_def_id).name();\n         // The substitutions we have are on the impl, so we grab\n         // the method type from the impl to substitute into.\n-        let m_id = method_with_name(ccx, impl_id, ident.name);\n+        let m_id = method_with_name(ccx, impl_id, name);\n         let ti = ty::impl_or_trait_item(tcx, m_id);\n         match ti {\n             ty::MethodTraitItem(m) => {\n@@ -717,7 +714,7 @@ fn emit_vtable_methods(bcx: Block,\n                    ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n                     debug!(\"(making impl vtable) method has self or type \\\n                             params: {}\",\n-                           token::get_ident(ident));\n+                           token::get_name(name));\n                     Some(C_null(Type::nil(ccx).ptr_to())).into_iter()\n                 } else {\n                     let mut fn_ref = trans_fn_ref_with_substs("}, {"sha": "8ac655fe47ad8b11455401d1147708a0e9e675b6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -65,7 +65,7 @@ pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n #[deriving(PartialEq, Eq, Hash)]\n pub struct field {\n-    pub ident: ast::Ident,\n+    pub name: ast::Name,\n     pub mt: mt\n }\n \n@@ -107,10 +107,10 @@ impl ImplOrTraitItem {\n         }\n     }\n \n-    pub fn ident(&self) -> ast::Ident {\n+    pub fn name(&self) -> ast::Name {\n         match *self {\n-            MethodTraitItem(ref method) => method.ident,\n-            TypeTraitItem(ref associated_type) => associated_type.ident,\n+            MethodTraitItem(ref method) => method.name,\n+            TypeTraitItem(ref associated_type) => associated_type.name,\n         }\n     }\n \n@@ -146,7 +146,7 @@ impl ImplOrTraitItemId {\n \n #[deriving(Clone, Show)]\n pub struct Method {\n-    pub ident: ast::Ident,\n+    pub name: ast::Name,\n     pub generics: ty::Generics,\n     pub fty: BareFnTy,\n     pub explicit_self: ExplicitSelfCategory,\n@@ -159,7 +159,7 @@ pub struct Method {\n }\n \n impl Method {\n-    pub fn new(ident: ast::Ident,\n+    pub fn new(name: ast::Name,\n                generics: ty::Generics,\n                fty: BareFnTy,\n                explicit_self: ExplicitSelfCategory,\n@@ -169,7 +169,7 @@ impl Method {\n                provided_source: Option<ast::DefId>)\n                -> Method {\n        Method {\n-            ident: ident,\n+            name: name,\n             generics: generics,\n             fty: fty,\n             explicit_self: explicit_self,\n@@ -190,7 +190,7 @@ impl Method {\n \n #[deriving(Clone)]\n pub struct AssociatedType {\n-    pub ident: ast::Ident,\n+    pub name: ast::Name,\n     pub vis: ast::Visibility,\n     pub def_id: ast::DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -1205,7 +1205,7 @@ impl fmt::Show for IntVarValue {\n \n #[deriving(Clone, Show)]\n pub struct TypeParameterDef {\n-    pub ident: ast::Ident,\n+    pub name: ast::Name,\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: uint,\n@@ -3746,18 +3746,18 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n-    for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n+    for f in fields.iter() { if f.name == name { return i; } i += 1u; }\n     tcx.sess.bug(format!(\n         \"no field named `{}` found in the list of fields `{}`\",\n         token::get_name(name),\n         fields.iter()\n-              .map(|f| token::get_ident(f.ident).get().to_string())\n+              .map(|f| token::get_name(f.name).get().to_string())\n               .collect::<Vec<String>>()).as_slice());\n }\n \n-pub fn impl_or_trait_item_idx(id: ast::Ident, trait_items: &[ImplOrTraitItem])\n+pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n                               -> Option<uint> {\n-    trait_items.iter().position(|m| m.ident() == id)\n+    trait_items.iter().position(|m| m.name() == id)\n }\n \n pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n@@ -4119,7 +4119,7 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n pub struct AssociatedTypeInfo {\n     pub def_id: ast::DefId,\n     pub index: uint,\n-    pub ident: ast::Ident,\n+    pub name: ast::Name,\n }\n \n impl PartialOrd for AssociatedTypeInfo {\n@@ -4222,7 +4222,7 @@ pub struct VariantInfo {\n     pub args: Vec<t>,\n     pub arg_names: Option<Vec<ast::Ident> >,\n     pub ctor_ty: t,\n-    pub name: ast::Ident,\n+    pub name: ast::Name,\n     pub id: ast::DefId,\n     pub disr_val: Disr,\n     pub vis: Visibility\n@@ -4250,7 +4250,7 @@ impl VariantInfo {\n                     args: arg_tys,\n                     arg_names: None,\n                     ctor_ty: ctor_ty,\n-                    name: ast_variant.node.name,\n+                    name: ast_variant.node.name.name,\n                     id: ast_util::local_def(ast_variant.node.id),\n                     disr_val: discriminant,\n                     vis: ast_variant.node.vis\n@@ -4275,7 +4275,7 @@ impl VariantInfo {\n                     args: arg_tys,\n                     arg_names: Some(arg_names),\n                     ctor_ty: ctor_ty,\n-                    name: ast_variant.node.name,\n+                    name: ast_variant.node.name.name,\n                     id: ast_util::local_def(ast_variant.node.id),\n                     disr_val: discriminant,\n                     vis: ast_variant.node.vis\n@@ -4578,8 +4578,7 @@ pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)\n                      -> Vec<field> {\n     lookup_struct_fields(cx, did).iter().map(|f| {\n        field {\n-            // FIXME #6993: change type of field to Name and get rid of new()\n-            ident: ast::Ident::new(f.name),\n+            name: f.name,\n             mt: mt {\n                 ty: lookup_field_type(cx, did, f.id, substs),\n                 mutbl: MutImmutable\n@@ -4593,8 +4592,7 @@ pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)\n pub fn tup_fields(v: &[t]) -> Vec<field> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            // FIXME #6993: change type of field to Name and get rid of new()\n-            ident: ast::Ident::new(token::intern(i.to_string().as_slice())),\n+            name: token::intern(i.to_string().as_slice()),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable\n@@ -5084,12 +5082,12 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n         Some(m) => m.clone(),\n         None => return None,\n     };\n-    let name = impl_item.ident().name;\n+    let name = impl_item.name();\n     match trait_of_item(tcx, def_id) {\n         Some(trait_did) => {\n             let trait_items = ty::trait_items(tcx, trait_did);\n             trait_items.iter()\n-                .position(|m| m.ident().name == name)\n+                .position(|m| m.name() == name)\n                 .map(|idx| ty::trait_item(tcx, trait_did, idx).id())\n         }\n         None => None"}, {"sha": "157f590a612e2ad2d30f510bfe06834342429ceb", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -324,7 +324,7 @@ impl TypeFoldable for ty::ParamBounds {\n impl TypeFoldable for ty::TypeParameterDef {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef {\n         ty::TypeParameterDef {\n-            ident: self.ident,\n+            name: self.name,\n             def_id: self.def_id,\n             space: self.space,\n             index: self.index,"}, {"sha": "4fb71c5c21bb779399cd90b5e9c7d5449c9bb3f7", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -543,7 +543,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             ty::trait_items(self.tcx(), trait_def_id);\n         let matching_index =\n             trait_items.iter()\n-                       .position(|item| item.ident().name == self.m_name);\n+                       .position(|item| item.name() == self.m_name);\n         let matching_index = match matching_index {\n             Some(i) => i,\n             None => { return; }\n@@ -1700,7 +1700,7 @@ fn trait_method(tcx: &ty::ctxt,\n     trait_items\n         .iter()\n         .enumerate()\n-        .find(|&(_, ref item)| item.ident().name == method_name)\n+        .find(|&(_, ref item)| item.name() == method_name)\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n }\n \n@@ -1714,7 +1714,7 @@ fn impl_method(tcx: &ty::ctxt,\n     impl_items\n         .iter()\n         .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n-        .find(|m| m.ident().name == method_name)\n+        .find(|m| m.name() == method_name)\n         .and_then(|item| item.as_opt_method())\n }\n "}, {"sha": "bbf6382ec86225b0d751d9a219d791487203bd92", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -761,8 +761,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                 let opt_trait_method_ty =\n                     trait_items.iter()\n                                .find(|ti| {\n-                                   ti.ident().name == impl_item_ty.ident()\n-                                                                  .name\n+                                   ti.name() == impl_item_ty.name()\n                                });\n                 match opt_trait_method_ty {\n                     Some(trait_method_ty) => {\n@@ -784,8 +783,8 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                                              format!(\"item `{}` is of a \\\n                                                       different kind from \\\n                                                       its trait `{}`\",\n-                                                     token::get_ident(\n-                                                        impl_item_ty.ident()),\n+                                                     token::get_name(\n+                                                        impl_item_ty.name()),\n                                                      pprust::path_to_string(\n                                                         &ast_trait_ref.path))\n                                              .as_slice());\n@@ -799,7 +798,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                             impl_method.span,\n                             format!(\n                                 \"method `{}` is not a member of trait `{}`\",\n-                                token::get_ident(impl_item_ty.ident()),\n+                                token::get_name(impl_item_ty.name()),\n                                 pprust::path_to_string(\n                                     &ast_trait_ref.path)).as_slice());\n                     }\n@@ -815,7 +814,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                 let opt_associated_type =\n                     trait_items.iter()\n                                .find(|ti| {\n-                                   ti.ident().name == typedef_ty.ident().name\n+                                   ti.name() == typedef_ty.name()\n                                });\n                 match opt_associated_type {\n                     Some(associated_type) => {\n@@ -830,8 +829,8 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                                              format!(\"item `{}` is of a \\\n                                                       different kind from \\\n                                                       its trait `{}`\",\n-                                                     token::get_ident(\n-                                                        typedef_ty.ident()),\n+                                                     token::get_name(\n+                                                        typedef_ty.name()),\n                                                      pprust::path_to_string(\n                                                         &ast_trait_ref.path))\n                                              .as_slice());\n@@ -846,7 +845,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                             format!(\n                                 \"associated type `{}` is not a member of \\\n                                  trait `{}`\",\n-                                token::get_ident(typedef_ty.ident()),\n+                                token::get_name(typedef_ty.name()),\n                                 pprust::path_to_string(\n                                     &ast_trait_ref.path)).as_slice());\n                     }\n@@ -866,33 +865,29 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                     impl_items.iter().any(|ii| {\n                         match *ii {\n                             ast::MethodImplItem(ref m) => {\n-                                m.pe_ident().name == trait_method.ident.name\n+                                m.pe_ident().name == trait_method.name\n                             }\n                             ast::TypeImplItem(_) => false,\n                         }\n                     });\n                 let is_provided =\n                     provided_methods.iter().any(\n-                        |m| m.ident.name == trait_method.ident.name);\n+                        |m| m.name == trait_method.name);\n                 if !is_implemented && !is_provided {\n-                    missing_methods.push(\n-                        format!(\"`{}`\",\n-                                token::get_ident(trait_method.ident)));\n+                    missing_methods.push(format!(\"`{}`\", token::get_name(trait_method.name)));\n                 }\n             }\n             ty::TypeTraitItem(ref associated_type) => {\n                 let is_implemented = impl_items.iter().any(|ii| {\n                     match *ii {\n                         ast::TypeImplItem(ref typedef) => {\n-                            typedef.ident.name == associated_type.ident.name\n+                            typedef.ident.name == associated_type.name\n                         }\n                         ast::MethodImplItem(_) => false,\n                     }\n                 });\n                 if !is_implemented {\n-                    missing_methods.push(\n-                        format!(\"`{}`\",\n-                                token::get_ident(associated_type.ident)));\n+                    missing_methods.push(format!(\"`{}`\", token::get_name(associated_type.name)));\n                 }\n             }\n         }\n@@ -943,7 +938,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 impl_m_span,\n                 format!(\"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n-                        token::get_ident(trait_m.ident),\n+                        token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n                             &impl_m.explicit_self)).as_slice());\n             return;\n@@ -953,7 +948,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 impl_m_span,\n                 format!(\"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n-                        token::get_ident(trait_m.ident),\n+                        token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n                             &trait_m.explicit_self)).as_slice());\n             return;\n@@ -969,7 +964,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         span_err!(tcx.sess, impl_m_span, E0049,\n             \"method `{}` has {} type parameter{} \\\n              but its trait declaration has {} type parameter{}\",\n-            token::get_ident(trait_m.ident),\n+            token::get_name(trait_m.name),\n             num_impl_m_type_params,\n             if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n             num_trait_m_type_params,\n@@ -981,7 +976,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         span_err!(tcx.sess, impl_m_span, E0050,\n             \"method `{}` has {} parameter{} \\\n              but the declaration in trait `{}` has {}\",\n-            token::get_ident(trait_m.ident),\n+            token::get_name(trait_m.name),\n             impl_m.fty.sig.inputs.len(),\n             if impl_m.fty.sig.inputs.len() == 1 {\"\"} else {\"s\"},\n             ty::item_path_str(tcx, trait_m.def_id),\n@@ -1082,7 +1077,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 \"in method `{}`, type parameter {} requires `{}`, \\\n                  which is not required by the corresponding type parameter \\\n                  in the trait declaration\",\n-                token::get_ident(trait_m.ident),\n+                token::get_name(trait_m.name),\n                 i,\n                 extra_bounds.user_string(tcx));\n            return;\n@@ -1121,7 +1116,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 span_err!(tcx.sess, impl_m_span, E0052,\n                     \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n                      required by the corresponding type parameter in the trait declaration\",\n-                    token::get_ident(trait_m.ident),\n+                    token::get_name(trait_m.name),\n                     i,\n                     ppaux::trait_ref_to_string(tcx, &*impl_trait_bound));\n             }\n@@ -1152,7 +1147,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         Err(ref terr) => {\n             span_err!(tcx.sess, impl_m_span, E0053,\n                 \"method `{}` has an incompatible type for trait: {}\",\n-                token::get_ident(trait_m.ident),\n+                token::get_name(trait_m.name),\n                 ty::type_err_to_str(tcx, terr));\n             ty::note_and_explain_type_err(tcx, terr);\n         }\n@@ -1228,7 +1223,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                 span,\n                 format!(\"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                        token::get_ident(impl_m.ident)).as_slice());\n+                        token::get_name(impl_m.name)).as_slice());\n             return false;\n         }\n \n@@ -3836,8 +3831,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                     ty::ty_struct(did, ref substs) => {\n                                         let fields = ty::struct_fields(fcx.tcx(), did, substs);\n                                         fields.len() == 1\n-                                        && fields[0].ident ==\n-                                        token::special_idents::unnamed_field\n+                                        && fields[0].name ==\n+                                        token::special_idents::unnamed_field.name\n                                     }\n                                     _ => false\n                                 };"}, {"sha": "cb4e878c22cc30b0e5ae4067cef53cd509c4d376", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -539,7 +539,7 @@ fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n            method.fty.repr(tcx));\n \n     ty::Method::new(\n-        method.ident,\n+        method.name,\n         method_generics,\n         method_fty,\n         method.explicit_self,"}, {"sha": "273518195b5618e4b0d3488d57a2d42e729f2fd6", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -279,7 +279,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             &trait_def.generics,\n                                             trait_items.as_slice(),\n                                             &m.id,\n-                                            &m.ident,\n+                                            &m.ident.name,\n                                             &m.explicit_self,\n                                             m.abi,\n                                             &m.generics,\n@@ -293,7 +293,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             &trait_def.generics,\n                                             trait_items.as_slice(),\n                                             &m.id,\n-                                            &m.pe_ident(),\n+                                            &m.pe_ident().name,\n                                             m.pe_explicit_self(),\n                                             m.pe_abi(),\n                                             m.pe_generics(),\n@@ -318,7 +318,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                             ast::TypeTraitItem(ref ast_associated_type) => {\n                                 let trait_did = local_def(trait_id);\n                                 let associated_type = ty::AssociatedType {\n-                                    ident: ast_associated_type.ident,\n+                                    name: ast_associated_type.ident.name,\n                                     vis: ast::Public,\n                                     def_id: local_def(ast_associated_type.id),\n                                     container: TraitContainer(trait_did),\n@@ -376,7 +376,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                  trait_generics: &ty::Generics,\n                                  trait_items: &[ast::TraitItem],\n                                  m_id: &ast::NodeId,\n-                                 m_ident: &ast::Ident,\n+                                 m_name: &ast::Name,\n                                  m_explicit_self: &ast::ExplicitSelf,\n                                  m_abi: abi::Abi,\n                                  m_generics: &ast::Generics,\n@@ -409,7 +409,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n         };\n \n         ty::Method::new(\n-            *m_ident,\n+            *m_name,\n             ty_generics,\n             fty,\n             explicit_self_category,\n@@ -489,7 +489,7 @@ fn convert_associated_type(ccx: &CrateCtxt,\n     write_ty_to_tcx(ccx.tcx, associated_type.id, param_type);\n \n     let associated_type = Rc::new(ty::AssociatedType {\n-        ident: associated_type.ident,\n+        name: associated_type.ident.name,\n         vis: ast::Public,\n         def_id: local_def(associated_type.id),\n         container: TraitContainer(trait_def.trait_ref.def_id),\n@@ -629,7 +629,7 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n         // foo(); }`).\n         let method_vis = m.pe_vis().inherit_from(rcvr_visibility);\n \n-        ty::Method::new(m.pe_ident(),\n+        ty::Method::new(m.pe_ident().name,\n                         m_ty_generics,\n                         fty,\n                         explicit_self_category,\n@@ -806,10 +806,8 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n                     match *impl_item {\n                         ast::MethodImplItem(_) => {}\n                         ast::TypeImplItem(ref typedef) => {\n-                            if associated_type.ident().name == typedef.ident\n-                                                                      .name {\n-                                return self.ccx.to_ty(&ExplicitRscope,\n-                                                      &*typedef.typ)\n+                            if associated_type.name() == typedef.ident.name {\n+                                return self.ccx.to_ty(&ExplicitRscope, &*typedef.typ)\n                             }\n                         }\n                     }\n@@ -1145,7 +1143,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                         write_ty_to_tcx(ccx.tcx, typedef.id, typ);\n \n                         let associated_type = Rc::new(ty::AssociatedType {\n-                            ident: typedef.ident,\n+                            name: typedef.ident.name,\n                             vis: typedef.vis,\n                             def_id: local_def(typedef.id),\n                             container: ty::ImplContainer(local_def(it.id)),\n@@ -1685,7 +1683,7 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n                 let def = ty::TypeParameterDef {\n                     space: subst::TypeSpace,\n                     index: generics.types.len(subst::TypeSpace),\n-                    ident: associated_type.ident,\n+                    name: associated_type.ident.name,\n                     def_id: local_def(associated_type.id),\n                     bounds: ty::ParamBounds {\n                         builtin_bounds: ty::empty_builtin_bounds(),\n@@ -1716,7 +1714,7 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n     let def = ty::TypeParameterDef {\n         space: subst::SelfSpace,\n         index: 0,\n-        ident: special_idents::type_self,\n+        name: special_idents::type_self.name,\n         def_id: local_def(param_id),\n         bounds: ty::ParamBounds {\n             region_bounds: vec!(),\n@@ -1817,7 +1815,7 @@ fn ensure_associated_types<'tcx,AC>(this: &AC, trait_id: ast::DefId)\n                                     let info = ty::AssociatedTypeInfo {\n                                         def_id: local_def(associated_type.id),\n                                         index: index,\n-                                        ident: associated_type.ident,\n+                                        name: associated_type.ident.name,\n                                     };\n                                     result.push(info);\n                                     index += 1;\n@@ -1855,7 +1853,7 @@ fn ensure_associated_types<'tcx,AC>(this: &AC, trait_id: ast::DefId)\n                 let info = ty::AssociatedTypeInfo {\n                     def_id: associated_type.def_id,\n                     index: index,\n-                    ident: associated_type.ident\n+                    name: associated_type.name\n                 };\n                 result.push(info);\n                 index += 1;\n@@ -1920,10 +1918,8 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                                                 this.tcx(),\n                                                 associated_type_info.def_id);\n                                         let def = ty::TypeParameterDef {\n-                                            ident: associated_type_trait_item\n-                                                       .ident(),\n-                                            def_id:\n-                                                associated_type_info.def_id,\n+                                            name: associated_type_trait_item.name(),\n+                                            def_id: associated_type_info.def_id,\n                                             space: space,\n                                             index: types.len() + index,\n                                             bounds: ty::ParamBounds {\n@@ -2033,7 +2029,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         let def = ty::TypeParameterDef {\n             space: space,\n             index: index,\n-            ident: param.ident,\n+            name: param.ident.name,\n             def_id: local_def(param.id),\n             associated_with: None,\n             bounds: bounds,"}, {"sha": "81deae86faa4849c32f8e2594e7861665d539bc8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -891,9 +891,9 @@ impl Repr for ty::Variance {\n \n impl Repr for ty::Method {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"method(ident: {}, generics: {}, fty: {}, \\\n+        format!(\"method(name: {}, generics: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n-                self.ident.repr(tcx),\n+                self.name.repr(tcx),\n                 self.generics.repr(tcx),\n                 self.fty.repr(tcx),\n                 self.explicit_self.repr(tcx),\n@@ -1214,7 +1214,7 @@ impl UserString for ParamTy {\n         let id = self.idx;\n         let did = self.def_id;\n         let ident = match tcx.ty_param_defs.borrow().find(&did.node) {\n-            Some(def) => token::get_ident(def.ident).get().to_string(),\n+            Some(def) => token::get_name(def.name).get().to_string(),\n \n             // This can only happen when a type mismatch error happens and\n             // the actual type has more type parameters than the expected one."}, {"sha": "ca79044e7f56d9eb3d4be5a4e664598cba5c37c3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2343e9d35403022425bed612ab9a26ccec72ed97/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2343e9d35403022425bed612ab9a26ccec72ed97", "patch": "@@ -463,10 +463,9 @@ impl Clean<TyParam> for ast::TyParam {\n impl Clean<TyParam> for ty::TypeParameterDef {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         cx.external_typarams.borrow_mut().as_mut().unwrap()\n-          .insert(self.def_id, self.ident.clean(cx));\n-\n+          .insert(self.def_id, self.name.clean(cx));\n         TyParam {\n-            name: self.ident.clean(cx),\n+            name: self.name.clean(cx),\n             did: self.def_id,\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx)\n@@ -1056,7 +1055,7 @@ impl Clean<Item> for ty::Method {\n         };\n \n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             visibility: Some(ast::Inherited),\n             stability: get_stability(cx, self.def_id),\n             def_id: self.def_id,\n@@ -2211,7 +2210,7 @@ impl Clean<Item> for ty::AssociatedType {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             source: DUMMY_SP.clean(cx),\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             attrs: Vec::new(),\n             inner: AssociatedTypeItem,\n             visibility: None,"}]}