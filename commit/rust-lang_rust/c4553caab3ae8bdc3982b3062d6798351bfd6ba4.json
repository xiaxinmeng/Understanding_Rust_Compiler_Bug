{"sha": "c4553caab3ae8bdc3982b3062d6798351bfd6ba4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NTUzY2FhYjNhZThiZGMzOTgyYjMwNjJkNjc5ODM1MWJmZDZiYTQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-01-17T20:44:25Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-01-17T20:44:25Z"}, "message": "Merge pull request #1554 from rtanglao/master\n\nrustdocs for box.rs, comm.rs, ctypes.rs, char.rs", "tree": {"sha": "1384cd6e67524052b2b27bdeb687c0b1244159fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1384cd6e67524052b2b27bdeb687c0b1244159fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4553caab3ae8bdc3982b3062d6798351bfd6ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4553caab3ae8bdc3982b3062d6798351bfd6ba4", "html_url": "https://github.com/rust-lang/rust/commit/c4553caab3ae8bdc3982b3062d6798351bfd6ba4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65e3c35c8d90fd3e4be8765b3c9eb755c52691ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/65e3c35c8d90fd3e4be8765b3c9eb755c52691ef", "html_url": "https://github.com/rust-lang/rust/commit/65e3c35c8d90fd3e4be8765b3c9eb755c52691ef"}, {"sha": "93be00f99594464fc753796395ce0cfb8ee790ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/93be00f99594464fc753796395ce0cfb8ee790ea", "html_url": "https://github.com/rust-lang/rust/commit/93be00f99594464fc753796395ce0cfb8ee790ea"}], "stats": {"total": 432, "additions": 165, "deletions": 267}, "files": [{"sha": "fefc129c8b05ba8fde66ca58e896262b512cecff", "filename": "src/libcore/box.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=c4553caab3ae8bdc3982b3062d6798351bfd6ba4", "patch": "@@ -1,15 +1,8 @@\n-/*\n-Module: box\n-*/\n-\n-\n export ptr_eq;\n \n-/*\n-Function: ptr_eq\n-\n-Determine if two shared boxes point to the same object\n-*/\n+#[doc(\n+  brief = \"Determine if two shared boxes point to the same object\"\n+)]\n pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     // FIXME: ptr::addr_of\n     unsafe {"}, {"sha": "2c46c652cd07cdc6508b3b3f7c5501dc30e72e71", "filename": "src/libcore/char.rs", "status": "modified", "additions": 40, "deletions": 74, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=c4553caab3ae8bdc3982b3062d6798351bfd6ba4", "patch": "@@ -1,8 +1,4 @@\n-/*\n-Module: char\n-\n-Utilities for manipulating the char type\n-*/\n+#[doc = \"Utilities for manipulating the char type\"];\n \n /*\n     Lu  Uppercase_Letter    an uppercase letter\n@@ -47,50 +43,40 @@ import is_alphabetic = unicode::derived_property::Alphabetic;\n import is_XID_start = unicode::derived_property::XID_Start;\n import is_XID_continue = unicode::derived_property::XID_Continue;\n \n-/*\n-Function: is_lowercase\n \n-Indicates whether a character is in lower case, defined in terms of the\n-Unicode General Category 'Ll'.\n-*/\n+#[doc(\n+  brief = \"Indicates whether a character is in lower case, defined \\\n+           in terms of the Unicode General Category 'Ll'.\"\n+)]\n pure fn is_lowercase(c: char) -> bool {\n     ret unicode::general_category::Ll(c);\n }\n \n-/*\n-Function: is_uppercase\n-\n-Indicates whether a character is in upper case, defined in terms of the\n-Unicode General Category 'Lu'.\n-*/\n+#[doc(\n+  brief = \"Indicates whether a character is in upper case, defined \\\n+           in terms of the Unicode General Category 'Lu'.\"\n+)]\n pure fn is_uppercase(c: char) -> bool {\n     ret unicode::general_category::Lu(c);\n }\n \n-/*\n-Function: is_whitespace\n-\n-Indicates whether a character is whitespace, defined in terms of\n-the Unicode General Categories 'Zs', 'Zl', 'Zp' and the additional\n-'Cc'-category control codes in the range [0x09, 0x0d].\n-\n-*/\n+#[doc(\n+  brief = \"Indicates whether a character is whitespace, defined in \\\n+           terms of the Unicode General Categories 'Zs', 'Zl', 'Zp' \\\n+           additional 'Cc'-category control codes in the range [0x09, 0x0d]\"\n+)]\n pure fn is_whitespace(c: char) -> bool {\n     ret ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n         || unicode::general_category::Zl(c)\n         || unicode::general_category::Zp(c);\n }\n \n-/*\n-Function: is_alphanumeric\n-\n-Indicates whether a character is alphanumeric, defined in terms of\n-the Unicode General Categories 'Nd', 'Nl', 'No' and the Derived\n-Core Property 'Alphabetic'.\n-\n-*/\n-\n+#[doc(\n+  brief = \"Indicates whether a character is alphanumeric, defined \\\n+            in terms of the Unicode General Categories 'Nd', \\\n+            'Nl', 'No' and the Derived Core Property 'Alphabetic'.\"\n+)]\n pure fn is_alphanumeric(c: char) -> bool {\n     ret unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n@@ -99,34 +85,24 @@ pure fn is_alphanumeric(c: char) -> bool {\n }\n \n \n-/*\n- Function: to_digit\n-\n- Convert a char to the corresponding digit.\n-\n- Parameters:\n-   c - a char, either '0' to '9', 'a' to 'z' or 'A' to 'Z'\n-\n- Returns:\n-   If `c` is between '0' and '9', the corresponding value between 0 and 9.\n- If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc.\n-\n- Safety note:\n-   This function fails if `c` is not a valid char\n-*/\n+#[doc(\n+  brief = \"Convert a char to the corresponding digit. \\\n+           Safety note: This function fails if `c` is not a valid char\",\n+  return = \"If `c` is between '0' and '9', the corresponding value \\\n+            between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is \\\n+            'b' or 'B', 11, etc.\"\n+)]\n pure fn to_digit(c: char) -> u8 unsafe {\n     alt maybe_digit(c) {\n       option::some(x) { x }\n       option::none. { fail; }\n     }\n }\n \n-/*\n- Function: maybe_digit\n-\n- Convert a char to the corresponding digit. Returns none when the\n- character is not a valid hexadecimal digit.\n-*/\n+#[doc(\n+  brief = \"Convert a char to the corresponding digit. Returns none when \\\n+           character is not a valid hexadecimal digit.\"\n+)]\n pure fn maybe_digit(c: char) -> option::t<u8> {\n     alt c {\n       '0' to '9' { option::some(c as u8 - ('0' as u8)) }\n@@ -137,12 +113,11 @@ pure fn maybe_digit(c: char) -> option::t<u8> {\n }\n \n /*\n- Function: to_lower\n-\n- Convert a char to the corresponding lower case.\n-\n  FIXME: works only on ASCII\n */\n+#[doc(\n+  brief = \"Convert a char to the corresponding lower case.\"\n+)]\n pure fn to_lower(c: char) -> char {\n     alt c {\n       'A' to 'Z' { ((c as u8) + 32u8) as char }\n@@ -151,31 +126,22 @@ pure fn to_lower(c: char) -> char {\n }\n \n /*\n- Function: to_upper\n-\n- Convert a char to the corresponding upper case.\n-\n  FIXME: works only on ASCII\n */\n+#[doc(\n+  brief = \"Convert a char to the corresponding upper case.\"\n+)]\n pure fn to_upper(c: char) -> char {\n     alt c {\n       'a' to 'z' { ((c as u8) - 32u8) as char }\n       _ { c }\n     }\n }\n \n-/*\n- Function: cmp\n-\n- Compare two chars.\n-\n- Parameters:\n-  a - a char\n-  b - a char\n-\n- Returns:\n-  -1 if a<b, 0 if a==b, +1 if a>b\n-*/\n+#[doc(\n+  brief =  \"Compare two chars.\",\n+  return = \"-1 if a<b, 0 if a==b, +1 if a>b\"\n+)]\n pure fn cmp(a: char, b: char) -> int {\n     ret  if b > a { -1 }\n     else if b < a { 1 }"}, {"sha": "f9e95edf5e2997bfb4648fa7f37a760043886c2c", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 58, "deletions": 81, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=c4553caab3ae8bdc3982b3062d6798351bfd6ba4", "patch": "@@ -1,28 +1,21 @@\n-/*\n-Module: comm\n-\n-Communication between tasks\n-\n-Communication between tasks is facilitated by ports (in the receiving task),\n-and channels (in the sending task). Any number of channels may feed into a\n-single port.\n-\n-Ports and channels may only transmit values of unique types; that is,\n-values that are statically guaranteed to be accessed by a single\n-'owner' at a time.  Unique types include scalars, vectors, strings,\n-and records, tags, tuples and unique boxes (~T) thereof. Most notably,\n-shared boxes (@T) may not be transmitted across channels.\n-\n-Example:\n-\n-> let p = comm::port();\n-> task::spawn(comm::chan(p), fn (c: chan<str>) {\n->   comm::send(c, \"Hello, World\");\n-> });\n->\n-> io::println(comm::recv(p));\n-\n-*/\n+#[doc(\n+  brief = \"Communication between tasks\",\n+  desc  = \"Communication between tasks is facilitated by ports (in the \\\n+           receiving task), and channels (in the sending task). Any \\\n+           number of channels may feed into a single port. \\\n+           Ports and channels may only transmit values of unique \\\n+           types; that is, values that are statically guaranteed to \\\n+           be accessed by a single 'owner' at a time.  Unique types \\\n+           include scalars, vectors, strings, and records, tags, \\\n+           tuples and unique boxes (~T) thereof. Most notably, \\\n+           shared boxes (@T) may not be transmitted across channels. \\\n+           Example: \\\n+               let p = comm::port(); \\\n+               task::spawn(comm::chan(p), fn (c: chan<str>) { \\\n+                   comm::send(c, \\\"Hello, World\\\"); \\\n+               }); \\\n+               io::println(comm::recv(p));\"\n+)];\n \n import sys;\n import task;\n@@ -59,22 +52,18 @@ type port_id = int;\n \n // It's critical that this only have one variant, so it has a record\n // layout, and will work in the rust_task structure in task.rs.\n-/*\n-Type: chan\n-\n-A communication endpoint that can send messages. Channels send\n-messages to ports.\n-\n-Each channel is bound to a port when the channel is constructed, so\n-the destination port for a channel must exist before the channel\n-itself.\n-\n-Channels are weak: a channel does not keep the port it is bound to alive.\n-If a channel attempts to send data to a dead port that data will be silently\n-dropped.\n-\n-Channels may be duplicated and themselves transmitted over other channels.\n-*/\n+#[doc(\n+  brief = \"A communication endpoint that can send messages. \\\n+           Channels send messages to ports.\",\n+  desc = \"Each channel is bound to a port when the channel is \\\n+          constructed, so the destination port for a channel \\\n+          must exist before the channel itself. \\\n+          Channels are weak: a channel does not keep the port it \\\n+          is bound to alive. If a channel attempts to send data \\\n+          to a dead port that data will be silently dropped. \\\n+          Channels may be duplicated and themselves transmitted \\\n+          over other channels.\"\n+)]\n tag chan<T: send> {\n     chan_t(task::task, port_id);\n }\n@@ -92,27 +81,21 @@ resource port_ptr<T: send>(po: *rustrt::rust_port) {\n     rustrt::del_port(po);\n }\n \n-/*\n-Type: port\n-\n-A communication endpoint that can receive messages. Ports receive\n-messages from channels.\n-\n-Each port has a unique per-task identity and may not be replicated or\n-transmitted. If a port value is copied, both copies refer to the same port.\n-\n-Ports may be associated with multiple <chan>s.\n-*/\n+#[doc(\n+  brief = \"A communication endpoint that can receive messages. \\\n+           Ports receive messages from channels.\",\n+  desc = \"Each port has a unique per-task identity and may not \\\n+          be replicated or transmitted. If a port value is \\\n+          copied, both copies refer to the same port. \\\n+          Ports may be associated with multiple <chan>s.\"\n+)]\n tag port<T: send> { port_t(@port_ptr<T>); }\n \n-/*\n-Function: send\n-\n-Sends data over a channel.\n-\n-The sent data is moved into the channel, whereupon the caller loses access\n-to it.\n-*/\n+#[doc(\n+  brief = \"Sends data over a channel. The sent data is moved \\\n+           into the channel, whereupon the caller loses \\\n+           access to it.\"\n+)]\n fn send<T: send>(ch: chan<T>, -data: T) {\n     let chan_t(t, p) = ch;\n     let res = rustrt::chan_id_send(sys::get_type_desc::<T>(), t, p, data);\n@@ -123,26 +106,23 @@ fn send<T: send>(ch: chan<T>, -data: T) {\n     task::yield();\n }\n \n-/*\n-Function: port\n-\n-Constructs a port.\n-*/\n+#[doc(\n+  brief = \"Constructs a port.\"\n+)]\n fn port<T: send>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n-/*\n-Function: recv\n-\n-Receive from a port.\n-\n-If no data is available on the port then the task will block until data\n-becomes available.\n-*/\n+#[doc(\n+  brief = \"Receive from a port. \\\n+           If no data is available on the port then the task will \\\n+           block until data becomes available.\"\n+)]\n fn recv<T: send>(p: port<T>) -> T { recv_(***p) }\n \n-// Receive on a raw port pointer\n+#[doc(\n+  brief = \"Receive on a raw port pointer\"\n+)]\n fn recv_<T: send>(p: *rustrt::rust_port) -> T {\n     // FIXME: Due to issue 1185 we can't use a return pointer when\n     // calling C code, and since we can't create our own return\n@@ -169,13 +149,10 @@ fn recv_<T: send>(p: *rustrt::rust_port) -> T {\n     ret res;\n }\n \n-/*\n-Function: chan\n-\n-Constructs a channel.\n-\n-The channel is bound to the port used to construct it.\n-*/\n+#[doc(\n+  brief = \"Constructs a channel. The channel is bound to the \\\n+           port used to construct it.\"\n+)]\n fn chan<T: send>(p: port<T>) -> chan<T> {\n     chan_t(task::get_task(), rustrt::get_port_id(***p))\n }"}, {"sha": "38ca8ac2a0c3971472bd7b02edb88a1e29d93840", "filename": "src/libcore/ctypes.rs", "status": "modified", "additions": 64, "deletions": 102, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/src%2Flibcore%2Fctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4553caab3ae8bdc3982b3062d6798351bfd6ba4/src%2Flibcore%2Fctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fctypes.rs?ref=c4553caab3ae8bdc3982b3062d6798351bfd6ba4", "patch": "@@ -1,8 +1,4 @@\n-/*\n-Module: ctypes\n-\n-Definitions useful for C interop\n-*/\n+#[doc = \"Definitions useful for C interop\"];\n \n /*\n FIXME: Add a test that uses some native code to verify these sizes,\n@@ -20,81 +16,62 @@ export enum;\n \n // PORT adapt to architecture\n \n-/*\n-Type: c_int\n-\n-A signed integer with the same size as a C `int`\n-*/\n+#[doc(\n+  brief = \"A signed integer with the same size as a C `int`.\"\n+)]\n type c_int = i32;\n \n-/*\n-Type: c_uint\n-\n-An unsigned integer with the same size as a C `unsigned int`\n-*/\n+#[doc(\n+  brief = \"An unsigned integer with the same size as a C `unsigned int`.\"\n+)]\n type c_uint = u32;\n \n-/*\n-Type: long\n-\n-A signed integer with the same size as a C `long`\n-*/\n+#[doc(\n+  brief = \"A signed integer with the same size as a C `long`.\"\n+)]\n type long = int;\n \n-/*\n-Type: longlong\n-\n-A signed integer with the same size as a C `long long`\n-*/\n+#[doc(\n+  brief = \"A signed integer with the same size as a C `long long`.\"\n+)]\n type longlong = i64;\n \n-/*\n-Type: unsigned\n-\n-An unsigned integer with the same size as a C `unsigned int`\n-*/\n+#[doc(\n+  brief = \"A signed integer with the same size as a C `unsigned int`.\"\n+)]\n type unsigned = u32;\n \n-/*\n-Type: ulong\n-\n-An unsigned integer with the same size as a C `unsigned long`\n-*/\n+#[doc(\n+  brief = \"A signed integer with the same size as a C `unsigned long`.\"\n+)]\n type ulong = uint;\n \n-/*\n-Type: ulonglong\n-\n-An unsigned integer with the same size as a C `unsigned long long`\n-*/\n+#[doc(\n+  brief = \"A signed integer with the same size as a C `unsigned long long`.\"\n+)]\n type ulonglong = u64;\n \n-/*\n-Type: intptr_t\n-\n-A signed integer with the same size as a pointer. This is\n-guaranteed to always be the same type as a Rust `int`\n-*/\n+#[doc(\n+  brief = \"A signed integer with the same size as a pointer. \\\n+           This is guaranteed to always be the same type as a \\\n+            Rust `int`.\"\n+)]\n type intptr_t = uint; // FIXME: int\n \n-/*\n-Type: uintptr_t\n-\n-An unsigned integer with the same size as a pointer. This is\n-guaranteed to always be the same type as a Rust `uint`.\n-*/\n+#[doc(\n+  brief = \"An unsigned integer with the same size as a pointer. \\\n+           This is guaranteed to always be the same type as a Rust \\\n+           `uint`.\"\n+)]\n type uintptr_t = uint;\n type uint32_t = u32;\n \n-/*\n-Type: void\n-\n-A type, a pointer to which can be used as C `void *`.\n-\n-The void type cannot be constructed or destructured, but using\n-pointers to this type when interoperating with C void pointers can\n-help in documentation.\n-*/\n+#[doc(\n+  brief = \"A type, a pointer to which can be used as C `void *`.\",\n+  desc = \"The void type cannot be constructed or destructured, \\\n+         but using pointers to this type when interoperating \\\n+         with C void pointers can help in documentation.\"\n+)]\n tag void {\n     // Making the only variant reference itself makes it impossible to\n     // construct. Not exporting it makes it impossible to destructure.\n@@ -103,60 +80,45 @@ tag void {\n     void_private2(@void);\n }\n \n-/*\n-Type: c_float\n-\n-A float value with the same size as a C `float`\n-*/\n+#[doc(\n+  brief = \"A float value with the same size as a C `float`.\"\n+)]\n type c_float = f32;\n \n-/*\n-Type: c_float\n-\n-A float value with the same size as a C `double`\n-*/\n+#[doc(\n+  brief = \"A float value with the same size as a C `double`.\"\n+)]\n type c_double = f64;\n \n-/*\n-Type: size_t\n-\n-An unsigned integer corresponding to the C `size_t`\n-*/\n+#[doc(\n+  brief = \"An unsigned integer corresponding to the C `size_t`.\"\n+)]\n type size_t = uint;\n \n-/*\n-Type: ssize_t\n-\n-A signed integer correpsonding to the C `ssize_t`\n-*/\n+#[doc(\n+  brief = \"A signed integer corresponding to the C `ssize_t`.\"\n+)]\n type ssize_t = int;\n \n-/*\n-Type: off_t\n-\n-An unsigned integer corresponding to the C `off_t`\n-*/\n+#[doc(\n+  brief = \"An unsigned integer corresponding to the C `off_t`.\"\n+)]\n type off_t = uint;\n \n-/*\n-Type: fd_t\n-\n-A type that can be used for C file descriptors\n-*/\n+#[doc(\n+  brief = \"A type that can be used for C file descriptors.\"\n+)]\n type fd_t = i32;      // not actually a C type, but should be.\n \n-/*\n-Type: pid_t\n-\n-A type for representing process ID's, corresponding to C `pid_t`\n-*/\n+#[doc(\n+  brief = \"A type for representing process ID's, corresponding to C `pid_t`.\"\n+)]\n type pid_t = i32;\n \n-// enum is implementation-defined, but is 32-bits in practice\n-/*\n-Type: enum\n-\n-An unsigned integer with the same size as a C enum\n-*/\n+#[doc(\n+  brief = \"An unsigned integer with the same size as a C enum. \\\n+           enum is implementation-defined, but is 32-bits in \\\n+           practice\"\n+)]\n type enum = u32;\n "}]}