{"sha": "fc875b087cdd844fa61204db30c287f3c3179d92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjODc1YjA4N2NkZDg0NGZhNjEyMDRkYjMwYzI4N2YzYzMxNzlkOTI=", "commit": {"author": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2016-01-31T00:39:03Z"}, "committer": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2016-02-03T00:34:49Z"}, "message": "Add issue number to guard map methods.", "tree": {"sha": "9b48984185b88a72be5d9c68cb24394da04dd429", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b48984185b88a72be5d9c68cb24394da04dd429"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc875b087cdd844fa61204db30c287f3c3179d92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc875b087cdd844fa61204db30c287f3c3179d92", "html_url": "https://github.com/rust-lang/rust/commit/fc875b087cdd844fa61204db30c287f3c3179d92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc875b087cdd844fa61204db30c287f3c3179d92/comments", "author": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf60078b48649ef4d3a9cb0034208672b82e9b51", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf60078b48649ef4d3a9cb0034208672b82e9b51", "html_url": "https://github.com/rust-lang/rust/commit/bf60078b48649ef4d3a9cb0034208672b82e9b51"}], "stats": {"total": 127, "additions": 78, "deletions": 49}, "files": [{"sha": "a6ab54730762df6bf943df9cb53b8fd19a3db719", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fc875b087cdd844fa61204db30c287f3c3179d92/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc875b087cdd844fa61204db30c287f3c3179d92/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=fc875b087cdd844fa61204db30c287f3c3179d92", "patch": "@@ -211,8 +211,10 @@ impl<T: ?Sized> Mutex<T> {\n     /// this call will return an error once the mutex is acquired.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n-        unsafe { self.inner.lock.lock() }\n-        unsafe { MutexGuard::new(&*self.inner, &self.data) }\n+        unsafe {\n+            self.inner.lock.lock();\n+            MutexGuard::new(&*self.inner, &self.data)\n+        }\n     }\n \n     /// Attempts to acquire this lock.\n@@ -230,10 +232,12 @@ impl<T: ?Sized> Mutex<T> {\n     /// acquired.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n-        if unsafe { self.inner.lock.try_lock() } {\n-            Ok(try!(unsafe { MutexGuard::new(&*self.inner, &self.data) }))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.inner.lock.try_lock() {\n+                Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -338,17 +342,21 @@ impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n     pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n-        unsafe { self.lock.lock() }\n-        unsafe { MutexGuard::new(self, &DUMMY.0) }\n+        unsafe {\n+            self.lock.lock();\n+            MutexGuard::new(self, &DUMMY.0)\n+        }\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n     #[inline]\n     pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n-        if unsafe { self.lock.try_lock() } {\n-            Ok(try!(unsafe { MutexGuard::new(self, &DUMMY.0) }))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.lock.try_lock() {\n+                Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -393,26 +401,28 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n     /// let x = Mutex::new(vec![1, 2]);\n     ///\n     /// {\n-    ///     let y = MutexGuard::map(x.lock().unwrap(), |v| &mut v[0]);\n+    ///     let mut y = MutexGuard::map(x.lock().unwrap(), |v| &mut v[0]);\n     ///     *y = 3;\n     /// }\n     ///\n-    /// assert_eq!(&*x.lock(), &[3, 2]);\n+    /// assert_eq!(&*x.lock().unwrap(), &[3, 2]);\n     /// ```\n     #[unstable(feature = \"guard_map\",\n                reason = \"recently added, needs RFC for stabilization\",\n-               issue = \"0\")]\n+               issue = \"27746\")]\n     pub fn map<U: ?Sized, F>(this: Self, cb: F) -> MutexGuard<'mutex, U>\n-    where F: FnOnce(&'mutex mut T) -> &'mutex mut U {\n+        where F: FnOnce(&'mutex mut T) -> &'mutex mut U\n+    {\n         // Compute the new data while still owning the original lock\n         // in order to correctly poison if the callback panics.\n         let data = unsafe { ptr::read(&this.__data) };\n         let new_data = cb(data);\n \n         // We don't want to unlock the lock by running the destructor of the\n         // original lock, so just read the fields we need and forget it.\n-        let poison = unsafe { ptr::read(&this.__poison) };\n-        let lock = unsafe { ptr::read(&this.__lock) };\n+        let (poison, lock) = unsafe {\n+            (ptr::read(&this.__poison), ptr::read(&this.__lock))\n+        };\n         mem::forget(this);\n \n         MutexGuard {"}, {"sha": "2b3233b2dabef26868a316e6e79e11d2b5433acb", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 50, "deletions": 31, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fc875b087cdd844fa61204db30c287f3c3179d92/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc875b087cdd844fa61204db30c287f3c3179d92/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=fc875b087cdd844fa61204db30c287f3c3179d92", "patch": "@@ -177,8 +177,10 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n-        unsafe { self.inner.lock.read() }\n-        unsafe { RwLockReadGuard::new(&*self.inner, &self.data) }\n+        unsafe {\n+            self.inner.lock.read();\n+            RwLockReadGuard::new(&*self.inner, &self.data)\n+        }\n     }\n \n     /// Attempts to acquire this rwlock with shared read access.\n@@ -201,10 +203,12 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n-        if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(unsafe { RwLockReadGuard::new(&*self.inner, &self.data) }))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.inner.lock.try_read() {\n+                Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -225,8 +229,10 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n-        unsafe { self.inner.lock.write() }\n-        unsafe { RwLockWriteGuard::new(&*self.inner, &self.data) }\n+        unsafe {\n+            self.inner.lock.write();\n+            RwLockWriteGuard::new(&*self.inner, &self.data)\n+        }\n     }\n \n     /// Attempts to lock this rwlock with exclusive write access.\n@@ -249,10 +255,12 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n-        if unsafe { self.inner.lock.try_write() } {\n-            Ok(try!(unsafe { RwLockWriteGuard::new(&*self.inner, &self.data) }))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.inner.lock.try_write() {\n+                Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -360,8 +368,10 @@ impl StaticRwLock {\n     /// See `RwLock::read`.\n     #[inline]\n     pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n-        unsafe { self.lock.read() }\n-        unsafe { RwLockReadGuard::new(self, &DUMMY.0) }\n+        unsafe {\n+            self.lock.read();\n+            RwLockReadGuard::new(self, &DUMMY.0)\n+        }\n     }\n \n     /// Attempts to acquire this lock with shared read access.\n@@ -370,10 +380,12 @@ impl StaticRwLock {\n     #[inline]\n     pub fn try_read(&'static self)\n                     -> TryLockResult<RwLockReadGuard<'static, ()>> {\n-        if unsafe { self.lock.try_read() } {\n-            unsafe { Ok(try!(RwLockReadGuard::new(self, &DUMMY.0))) }\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.lock.try_read(){\n+                Ok(try!(RwLockReadGuard::new(self, &DUMMY.0)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -383,8 +395,10 @@ impl StaticRwLock {\n     /// See `RwLock::write`.\n     #[inline]\n     pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n-        unsafe { self.lock.write() }\n-        unsafe { RwLockWriteGuard::new(self, &DUMMY.0) }\n+        unsafe {\n+            self.lock.write();\n+            RwLockWriteGuard::new(self, &DUMMY.0)\n+        }\n     }\n \n     /// Attempts to lock this rwlock with exclusive write access.\n@@ -393,10 +407,12 @@ impl StaticRwLock {\n     #[inline]\n     pub fn try_write(&'static self)\n                      -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n-        if unsafe { self.lock.try_write() } {\n-            Ok(unsafe { try!(RwLockWriteGuard::new(self, &DUMMY.0)) })\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.lock.try_write() {\n+                Ok(try!(RwLockWriteGuard::new(self, &DUMMY.0)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -439,9 +455,10 @@ impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n     /// ```\n     #[unstable(feature = \"guard_map\",\n                reason = \"recently added, needs RFC for stabilization\",\n-               issue = \"0\")]\n+               issue = \"27746\")]\n     pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockReadGuard<'rwlock, U>\n-    where F: FnOnce(&'rwlock T) -> &'rwlock U {\n+        where F: FnOnce(&'rwlock T) -> &'rwlock U\n+    {\n         let new = RwLockReadGuard {\n             __lock: this.__lock,\n             __data: cb(this.__data)\n@@ -478,7 +495,7 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     /// let x = RwLock::new(vec![1, 2]);\n     ///\n     /// {\n-    ///     let y = RwLockWriteGuard::map(x.write().unwrap(), |v| &mut v[0]);\n+    ///     let mut y = RwLockWriteGuard::map(x.write().unwrap(), |v| &mut v[0]);\n     ///     assert_eq!(*y, 1);\n     ///\n     ///     *y = 10;\n@@ -488,18 +505,20 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     /// ```\n     #[unstable(feature = \"guard_map\",\n                reason = \"recently added, needs RFC for stabilization\",\n-               issue = \"0\")]\n+               issue = \"27746\")]\n     pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockWriteGuard<'rwlock, U>\n-    where F: FnOnce(&'rwlock mut T) -> &'rwlock mut U {\n+        where F: FnOnce(&'rwlock mut T) -> &'rwlock mut U\n+    {\n         // Compute the new data while still owning the original lock\n         // in order to correctly poison if the callback panics.\n         let data = unsafe { ptr::read(&this.__data) };\n         let new_data = cb(data);\n \n         // We don't want to unlock the lock by running the destructor of the\n         // original lock, so just read the fields we need and forget it.\n-        let poison = unsafe { ptr::read(&this.__poison) };\n-        let lock = unsafe { ptr::read(&this.__lock) };\n+        let (poison, lock) = unsafe {\n+            (ptr::read(&this.__poison), ptr::read(&this.__lock))\n+        };\n         mem::forget(this);\n \n         RwLockWriteGuard {"}]}