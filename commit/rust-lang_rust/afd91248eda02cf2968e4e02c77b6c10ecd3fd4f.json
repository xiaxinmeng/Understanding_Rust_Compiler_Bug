{"sha": "afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZDkxMjQ4ZWRhMDJjZjI5NjhlNGUwMmM3N2I2YzEwZWNkM2ZkNGY=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-23T11:01:12Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-23T11:01:12Z"}, "message": "Rustup", "tree": {"sha": "c7576421245bef3401158338f99a7d8641a90187", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7576421245bef3401158338f99a7d8641a90187"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "html_url": "https://github.com/rust-lang/rust/commit/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff0e5f967fde38242a1f2bf852082d2e105fc29c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0e5f967fde38242a1f2bf852082d2e105fc29c", "html_url": "https://github.com/rust-lang/rust/commit/ff0e5f967fde38242a1f2bf852082d2e105fc29c"}], "stats": {"total": 584, "additions": 292, "deletions": 292}, "files": [{"sha": "cd2444ff31f0d458cba655975967b1180d7b2d89", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n+fn check_lit(cx: &LateContext<'_, '_>, lit: &Lit, e: &Expr) {\n     match lit.node {\n         LitKind::Float(s, FloatTy::F32) => check_known_consts(cx, e, s, \"f32\"),\n         LitKind::Float(s, FloatTy::F64) => check_known_consts(cx, e, s, \"f64\"),\n@@ -79,7 +79,7 @@ fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     }\n }\n \n-fn check_known_consts(cx: &LateContext, e: &Expr, s: symbol::Symbol, module: &str) {\n+fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr, s: symbol::Symbol, module: &str) {\n     let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {"}, {"sha": "3d25f524afd87fabcc9e37097b3d731c203d6cdb", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -226,22 +226,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n }\n \n-fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n+fn is_relevant_item(tcx: TyCtxt<'_, '_, '_>, item: &Item) -> bool {\n     if let ItemKind::Fn(_, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         true\n     }\n }\n \n-fn is_relevant_impl(tcx: TyCtxt, item: &ImplItem) -> bool {\n+fn is_relevant_impl(tcx: TyCtxt<'_, '_, '_>, item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n+fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n@@ -251,7 +251,7 @@ fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n     }\n }\n \n-fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n+fn is_relevant_block(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match stmt.node {\n             StmtKind::Decl(_, _) => true,\n@@ -262,7 +262,7 @@ fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> b\n     }\n }\n \n-fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n+fn is_relevant_expr(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n     match expr.node {\n         ExprKind::Block(ref block, _) => is_relevant_block(tcx, tables, block),\n         ExprKind::Ret(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n@@ -280,7 +280,7 @@ fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool\n     }\n }\n \n-fn check_attrs(cx: &LateContext, span: Span, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attribute]) {\n     if in_macro(span) {\n         return;\n     }\n@@ -331,7 +331,7 @@ fn check_attrs(cx: &LateContext, span: Span, name: Name, attrs: &[Attribute]) {\n     }\n }\n \n-fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n+fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n     if let LitKind::Str(ref is, _) = lit.node {\n         if Version::parse(&is.as_str()).is_ok() {\n             return;\n@@ -358,7 +358,7 @@ fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {\n // sources that the user has no control over.\n // For some reason these attributes don't have any expansion info on them, so\n // we have to check it this way until there is a better way.\n-fn is_present_in_source(cx: &LateContext, span: Span) -> bool {\n+fn is_present_in_source(cx: &LateContext<'_, '_>, span: Span) -> bool {\n     if let Some(snippet) = snippet_opt(cx, span) {\n         if snippet.is_empty() {\n             return false;"}, {"sha": "249ebbde2f79fcd1ffa8717fb77c4d88017ccbee", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -158,7 +158,7 @@ fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n }\n \n \n-fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n+fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n     if let ExprKind::Binary(ref op, ref left, ref right) = bit_op.node {\n         if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n             return;\n@@ -169,7 +169,7 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOpKind, cmp_value:\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext, bit_op: BinOpKind, cmp_op: BinOpKind, mask_value: u128, cmp_value: u128, span: Span) {\n+fn check_bit_mask(cx: &LateContext<'_, '_>, bit_op: BinOpKind, cmp_op: BinOpKind, mask_value: u128, cmp_value: u128, span: Span) {\n     match cmp_op {\n         BinOpKind::Eq | BinOpKind::Ne => match bit_op {\n             BinOpKind::BitAnd => if mask_value & cmp_value != cmp_value {\n@@ -270,7 +270,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOpKind, cmp_op: BinOpKind, mask_v\n     }\n }\n \n-fn check_ineffective_lt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n+fn check_ineffective_lt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n     if c.is_power_of_two() && m < c {\n         span_lint(\n             cx,\n@@ -286,7 +286,7 @@ fn check_ineffective_lt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n     }\n }\n \n-fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n+fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n         span_lint(\n             cx,\n@@ -302,7 +302,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n     }\n }\n \n-fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n+fn fetch_int_literal(cx: &LateContext<'_, '_>, lit: &Expr) -> Option<u128> {\n     match constant(cx, cx.tables, lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,"}, {"sha": "f1596476bfda012b65063ec430aa1469c6d9caf0", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n }\n \n // The boolean part of the return indicates whether some simplifications have been applied.\n-fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n+fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n     let mut suggest_context = SuggestContext {\n         terminals,\n         cx,"}, {"sha": "2d4279d3cc19d0dccc0bcb908ed40c1f5846f30d", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -38,7 +38,7 @@ impl LintPass for ByteCount {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.node;\n             if count.ident.name == \"count\";"}, {"sha": "2771006aad3b40652dae6e7f4bd8ae932e628661", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -80,14 +80,14 @@ impl LintPass for CollapsibleIf {\n }\n \n impl EarlyLintPass for CollapsibleIf {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if !in_macro(expr.span) {\n             check_if(cx, expr)\n         }\n     }\n }\n \n-fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     match expr.node {\n         ast::ExprKind::If(ref check, ref then, ref else_) => if let Some(ref else_) = *else_ {\n             check_collapsible_maybe_if_let(cx, else_);\n@@ -101,7 +101,7 @@ fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n     }\n }\n \n-fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n+fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::Block(ref block, _) = else_.node;\n         if let Some(else_) = expr_block(block);\n@@ -122,7 +122,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n     }\n }\n \n-fn check_collapsible_no_if_let(cx: &EarlyContext, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n+fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n     if_chain! {\n         if let Some(inner) = expr_block(then);\n         if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;"}, {"sha": "1af0741d67fb193973465e0743ced0b7406be611", "filename": "clippy_lints/src/const_static_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -35,7 +35,7 @@ impl LintPass for StaticConst {\n \n impl StaticConst {\n     // Recursively visit types\n-    fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext) {\n+    fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext<'_>) {\n         match ty.node {\n             // Be careful of nested structures (arrays and tuples)\n             TyKind::Array(ref ty, _) => {\n@@ -79,7 +79,7 @@ impl StaticConst {\n }\n \n impl EarlyLintPass for StaticConst {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if !in_macro(item.span) {\n             // Match only constants...\n             if let ItemKind::Const(ref var_type, _) = item.node {"}, {"sha": "84167553a54cd7d302c48f615e02cdc82791162e", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -123,7 +123,7 @@ impl Hash for Constant {\n }\n \n impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt, cmp_type: &ty::TypeVariants, left: &Self, right: &Self) -> Option<Ordering> {\n+    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: &ty::TypeVariants<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n             (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n@@ -236,7 +236,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn constant_not(&self, o: &Constant, ty: ty::Ty) -> Option<Constant> {\n+    fn constant_not(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Bool(b) => Some(Bool(!b)),\n@@ -252,7 +252,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn constant_negate(&self, o: &Constant, ty: ty::Ty) -> Option<Constant> {\n+    fn constant_negate(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Int(value) => {"}, {"sha": "5709526c6007e2c5ae85d9a3ffd74c8ef0b9ca7d", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -134,7 +134,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n }\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n+fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block]) {\n     let eq: &dyn Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n \n     if let Some((i, j)) = search_same_sequenced(blocks, eq) {\n@@ -150,7 +150,7 @@ fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n }\n \n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n+fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr]) {\n     let hash: &dyn Fn(&&Expr) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx, cx.tables);\n         h.hash_expr(expr);\n@@ -172,7 +172,7 @@ fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n }\n \n /// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n+fn lint_match_arms(cx: &LateContext<'_, '_>, expr: &Expr) {\n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.node {\n         let hash = |&(_, arm): &(usize, &Arm)| -> u64 {\n             let mut h = SpanlessHash::new(cx, cx.tables);"}, {"sha": "d66e6f2849bb694efee3567102051603c37e3afa", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n \n #[cfg(feature = \"debugging\")]\n #[allow(too_many_arguments)]\n-fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, _: NodeId) {\n+fn report_cc_bug(_: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, _: NodeId) {\n     span_bug!(\n         span,\n         \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n@@ -201,7 +201,7 @@ fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, re\n }\n #[cfg(not(feature = \"debugging\"))]\n #[allow(too_many_arguments)]\n-fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, id: NodeId) {\n+fn report_cc_bug(cx: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, id: NodeId) {\n     if !is_allowed(cx, CYCLOMATIC_COMPLEXITY, id) {\n         cx.sess().span_note_without_error(\n             span,"}, {"sha": "2b11e8fa77d4d6c399d7c92e1cfba61bf2d96234", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -52,11 +52,11 @@ impl LintPass for Doc {\n }\n \n impl EarlyLintPass for Doc {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &ast::Crate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &ast::Crate) {\n         check_attrs(cx, &self.valid_idents, &krate.attrs);\n     }\n \n-    fn check_item(&mut self, cx: &EarlyContext, item: &ast::Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         check_attrs(cx, &self.valid_idents, &item.attrs);\n     }\n }\n@@ -139,7 +139,7 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n     panic!(\"not a doc-comment: {}\", comment);\n }\n \n-pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n+pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n     let mut doc = String::new();\n     let mut spans = vec![];\n \n@@ -186,7 +186,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n }\n \n fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n-    cx: &EarlyContext,\n+    cx: &EarlyContext<'_>,\n     valid_idents: &[String],\n     docs: Events,\n     spans: &[(usize, Span)],\n@@ -232,7 +232,7 @@ fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n     }\n }\n \n-fn check_text(cx: &EarlyContext, valid_idents: &[String], text: &str, span: Span) {\n+fn check_text(cx: &EarlyContext<'_>, valid_idents: &[String], text: &str, span: Span) {\n     for word in text.split_whitespace() {\n         // Trim punctuation as in `some comment (see foo::bar).`\n         //                                                   ^^\n@@ -255,7 +255,7 @@ fn check_text(cx: &EarlyContext, valid_idents: &[String], text: &str, span: Span\n     }\n }\n \n-fn check_word(cx: &EarlyContext, word: &str, span: Span) {\n+fn check_word(cx: &EarlyContext<'_>, word: &str, span: Span) {\n     /// Checks if a string is camel-case, ie. contains at least two uppercase\n     /// letter (`Clippy` is\n     /// ok) and one lower-case letter (`NASA` is ok). Plural are also excluded"}, {"sha": "abd5666385d029dbc710eaffb8e3f092842b6710", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -31,7 +31,7 @@ impl LintPass for DoubleParens {\n }\n \n impl EarlyLintPass for DoubleParens {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         match expr.node {\n             ExprKind::Paren(ref in_paren) => match in_paren.node {\n                 ExprKind::Paren(_) | ExprKind::Tup(_) => {"}, {"sha": "d3560434a31cc0c8369b87b5fb26304c2f3ff99a", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -49,7 +49,7 @@ impl LintPass for ElseIfWithoutElse {\n }\n \n impl EarlyLintPass for ElseIfWithoutElse {\n-    fn check_expr(&mut self, cx: &EarlyContext, mut item: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, mut item: &Expr) {\n         if in_external_macro(cx, item.span) {\n             return;\n         }"}, {"sha": "f95ae32d5611d87dfc9b24f8b0fe08f9a2a7b771", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -33,7 +33,7 @@ impl LintPass for EmptyEnum {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "6f8afc710de66173be773dc2099cb2c4e7692403", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n }\n \n impl EnumGlobUse {\n-    fn lint_item(&self, cx: &LateContext, item: &Item) {\n+    fn lint_item(&self, cx: &LateContext<'_, '_>, item: &Item) {\n         if item.vis.node.is_pub() {\n             return; // re-exports are fine\n         }"}, {"sha": "16c9212e5db86b344402feeb36a9d5abd831ce31", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -149,7 +149,7 @@ fn partial_rmatch(post: &str, name: &str) -> usize {\n // FIXME: #600\n #[allow(while_let_on_iterator)]\n fn check_variant(\n-    cx: &EarlyContext,\n+    cx: &EarlyContext<'_>,\n     threshold: u64,\n     def: &EnumDef,\n     item_name: &str,\n@@ -240,12 +240,12 @@ fn to_camel_case(item_name: &str) -> String {\n }\n \n impl EarlyLintPass for EnumVariantNames {\n-    fn check_item_post(&mut self, _cx: &EarlyContext, _item: &Item) {\n+    fn check_item_post(&mut self, _cx: &EarlyContext<'_>, _item: &Item) {\n         let last = self.modules.pop();\n         assert!(last.is_some());\n     }\n \n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         let item_name = item.ident.as_str();\n         let item_name_chars = item_name.chars().count();\n         let item_camel = to_camel_case(&item_name);"}, {"sha": "4960a48b3c880c804e0f6a46dda160abebdf849b", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n     }\n }\n \n-fn check(cx: &LateContext, e: &Expr, span: Span) {\n+fn check(cx: &LateContext<'_, '_>, e: &Expr, span: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         if v == 0 {\n             span_lint("}, {"sha": "ebbc2c34811b51e34c68697174733f7556da5c0b", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -39,7 +39,7 @@ declare_clippy_lint! {\n     \"using `Box<T>` where unnecessary\"\n }\n \n-fn is_non_trait_box(ty: Ty) -> bool {\n+fn is_non_trait_box(ty: Ty<'_>) -> bool {\n     ty.is_box() && !ty.boxed_ty().is_trait()\n }\n \n@@ -137,7 +137,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             }\n         }\n     }\n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, _: ty::BorrowKind, loan_cause: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, _: ty::BorrowKind, loan_cause: LoanCause) {\n         if let Categorization::Local(lid) = cmt.cat {\n             match loan_cause {\n                 // x.foo()"}, {"sha": "2071628a6cfeef18ee4bba432f26ad9b85fa95d3", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n     }\n }\n \n-fn check_closure(cx: &LateContext, expr: &Expr) {\n+fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n     if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n         let body = cx.tcx.hir.body(eid);\n         let ex = &body.value;"}, {"sha": "7ccf8c31569d864c3edfc3a1123a7ef1e917cab6", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n ///   logical operators are considered to have a defined evaluation order.\n ///\n /// When such a read is found, the lint is triggered.\n-fn check_for_unsequenced_reads(vis: &mut ReadVisitor) {\n+fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n     let map = &vis.cx.tcx.hir;\n     let mut cur_id = vis.write_expr.id;\n     loop {\n@@ -348,7 +348,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n }\n \n /// Returns true if `expr` is the LHS of an assignment, like `expr = ...`.\n-fn is_in_assignment_position(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         if let ExprKind::Assign(ref lhs, _) = parent.node {\n             return lhs.id == expr.id;"}, {"sha": "3db644911d78a75fd1dadb10c53de8ce3b2dd2b0", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -128,7 +128,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n }\n \n-fn match_type(tcx: ty::TyCtxt, ty: ty::Ty, path: &[&str]) -> bool {\n+fn match_type(tcx: ty::TyCtxt<'_, '_, '_>, ty: ty::Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(tcx, adt.did, path),\n         _ => false,"}, {"sha": "80fc4c3acfe48be0e728a702d180732b78bd85f7", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -105,7 +105,7 @@ fn check_single_piece(expr: &Expr) -> bool {\n /// ```\n /// and that type of `__arg0` is `&str` or `String`\n /// then returns the span of first element of the matched tuple\n-fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n+fn get_single_string_arg(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Span> {\n     if_chain! {\n         if let ExprKind::AddrOf(_, ref expr) = expr.node;\n         if let ExprKind::Match(ref match_expr, ref arms, _) = expr.node;"}, {"sha": "60001c792c0b41640ef5e0ededccf247cca773b6", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -83,7 +83,7 @@ impl LintPass for Formatting {\n }\n \n impl EarlyLintPass for Formatting {\n-    fn check_block(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         for w in block.stmts.windows(2) {\n             match (&w[0].node, &w[1].node) {\n                 (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Expr(ref second)) |\n@@ -95,15 +95,15 @@ impl EarlyLintPass for Formatting {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         check_assign(cx, expr);\n         check_else_if(cx, expr);\n         check_array(cx, expr);\n     }\n }\n \n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n-fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_assign(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let ast::ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro(lhs.span) {\n             let eq_span = lhs.span.between(rhs.span);\n@@ -132,7 +132,7 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for weird `else if`.\n-fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_else_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let Some((then, &Some(ref else_))) = unsugar_if(expr) {\n         if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(then.span) {\n             // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to\n@@ -164,7 +164,7 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `POSSIBLE_MISSING_COMMA` lint for array\n-fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_array(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let ast::ExprKind::Array(ref array) = expr.node {\n         for element in array {\n             if let ast::ExprKind::Binary(ref op, ref lhs, _) = element.node {\n@@ -190,7 +190,7 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n-fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n+fn check_consecutive_ifs(cx: &EarlyContext<'_>, first: &ast::Expr, second: &ast::Expr) {\n     if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) && unsugar_if(first).is_some()\n         && unsugar_if(second).is_some()\n     {"}, {"sha": "8903766c330b4636dfc488d446ce4856bcd3bb4f", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n }\n \n impl<'a, 'tcx> Functions {\n-    fn check_arg_number(self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n+    fn check_arg_number(self, cx: &LateContext<'_, '_>, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n             span_lint("}, {"sha": "23b34362171986d2b6ba43e1e432e6e357546841", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n }\n \n #[allow(cast_possible_wrap)]\n-fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n+fn check(cx: &LateContext<'_, '_>, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         let check = match cx.tables.expr_ty(e).sty {\n             ty::TyInt(ity) => unsext(cx.tcx, -1i128, ity),"}, {"sha": "915bc28f751d5f468645d71d3f57e74a0f463591", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -47,7 +47,7 @@ impl LintPass for IfNotElse {\n }\n \n impl EarlyLintPass for IfNotElse {\n-    fn check_expr(&mut self, cx: &EarlyContext, item: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n         if in_external_macro(cx, item.span) {\n             return;\n         }"}, {"sha": "677f59d32cc5a70170821d490d4be95f498c2707", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n /// the range.\n fn to_const_range<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    range: Range,\n+    range: Range<'_>,\n     array_size: u128,\n ) -> Option<(u128, u128)> {\n     let s = range"}, {"sha": "eaa93cb62f8789f0b0209fbd311a198f8fb3fd5b", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -140,7 +140,7 @@ static HEURISTICS: &[(&str, usize, Heuristic, Finiteness)] = &[\n     (\"scan\", 3, First, MaybeInfinite),\n ];\n \n-fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n+fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n@@ -204,7 +204,7 @@ static COMPLETING_METHODS: &[(&str, usize)] = &[\n     (\"product\", 1),\n ];\n \n-fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n+fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len) in COMPLETING_METHODS.iter() {"}, {"sha": "70f88a76f45042adc32371566e70f1b215f26578", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_attrs(cx: &LateContext, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_, '_>, name: Name, attrs: &[Attribute]) {\n     for attr in attrs {\n         if attr.name() != \"inline\" {\n             continue;"}, {"sha": "9b6fc579a31ce8b1085d239ff20580711e43b358", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -61,7 +61,7 @@ impl IntPlusOne {\n         false\n     }\n \n-    fn check_binop(&self, cx: &EarlyContext, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n+    fn check_binop(&self, cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n         match (binop, &lhs.node, &rhs.node) {\n             // case where `x - 1 >= ...` or `-1 + x >= ...`\n             (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n@@ -127,7 +127,7 @@ impl IntPlusOne {\n \n     fn generate_recommendation(\n         &self,\n-        cx: &EarlyContext,\n+        cx: &EarlyContext<'_>,\n         binop: BinOpKind,\n         node: &Expr,\n         other_side: &Expr,\n@@ -150,15 +150,15 @@ impl IntPlusOne {\n         None\n     }\n \n-    fn emit_warning(&self, cx: &EarlyContext, block: &Expr, recommendation: String) {\n+    fn emit_warning(&self, cx: &EarlyContext<'_>, block: &Expr, recommendation: String) {\n         span_lint_and_then(cx, INT_PLUS_ONE, block.span, \"Unnecessary `>= y + 1` or `x - 1 >=`\", |db| {\n             db.span_suggestion(block.span, \"change `>= y + 1` to `> y` as shown\", recommendation);\n         });\n     }\n }\n \n impl EarlyLintPass for IntPlusOne {\n-    fn check_expr(&mut self, cx: &EarlyContext, item: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.node {\n             if let Some(ref rec) = self.check_binop(cx, kind.node, lhs, rhs) {\n                 self.emit_warning(cx, item, rec.clone());"}, {"sha": "07ef086d694c77603c4af9dfccc817216bf96ee1", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -43,7 +43,7 @@ impl LintPass for ItemsAfterStatements {\n }\n \n impl EarlyLintPass for ItemsAfterStatements {\n-    fn check_block(&mut self, cx: &EarlyContext, item: &Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n         if in_macro(item.span) {\n             return;\n         }"}, {"sha": "2c03b6b5f682c2ed766d65d849aa2e52bc44f85d", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -48,7 +48,7 @@ impl LintPass for LargeEnumVariant {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "b73f912fad5ec69e56c1f5f13aca018876e53116", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -106,8 +106,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n     }\n }\n \n-fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n-    fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n+fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &TraitItemRef, name: &str) -> bool {\n         item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n@@ -119,7 +119,7 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n     }\n \n     // fill the set with current and super traits\n-    fn fill_trait_set(traitt: DefId, set: &mut HashSet<DefId>, cx: &LateContext) {\n+    fn fill_trait_set(traitt: DefId, set: &mut HashSet<DefId>, cx: &LateContext<'_, '_>) {\n         if set.insert(traitt) {\n             for supertrait in ::rustc::traits::supertrait_def_ids(cx.tcx, traitt) {\n                 fill_trait_set(supertrait, set, cx);\n@@ -154,8 +154,8 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n     }\n }\n \n-fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n-    fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n+fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplItemRef]) {\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &ImplItemRef, name: &str) -> bool {\n         item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n@@ -194,7 +194,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     }\n }\n \n-fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n+fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n     if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.node, &lit.node) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n@@ -207,7 +207,7 @@ fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str,\n     }\n }\n \n-fn check_len(cx: &LateContext, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n+fn check_len(cx: &LateContext<'_, '_>, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n     if let Spanned {\n         node: LitKind::Int(lit, _),\n         ..\n@@ -232,9 +232,9 @@ fn check_len(cx: &LateContext, span: Span, method_name: Name, args: &[Expr], lit\n }\n \n /// Check if this type has an `is_empty` method.\n-fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n-    fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n+    fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if item.ident.name == \"is_empty\" {\n                 let sig = cx.tcx.fn_sig(item.def_id);\n@@ -249,7 +249,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     }\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n-    fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n+    fn has_is_empty_impl(cx: &LateContext<'_, '_>, id: DefId) -> bool {\n         cx.tcx.inherent_impls(id).iter().any(|imp| {\n             cx.tcx\n                 .associated_items(*imp)"}, {"sha": "b08449d2bebf30ee1d4e6b81189694139cdcd8be", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -181,7 +181,7 @@ pub fn register_pre_expansion_lints(session: &rustc::session::Session, store: &m\n }\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n-pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n+pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>) {\n     let conf = match utils::conf::file_from_args(reg.args()) {\n         Ok(file_name) => {\n             // if the user specified a file, it must exist, otherwise default to `clippy.toml` but"}, {"sha": "383bba2d4bded65b651b6fbebe11c673a17d2dfc", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -229,7 +229,7 @@ enum WarningType {\n }\n \n impl WarningType {\n-    crate fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: syntax_pos::Span) {\n+    crate fn display(&self, grouping_hint: &str, cx: &EarlyContext<'_>, span: syntax_pos::Span) {\n         match self {\n             WarningType::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n@@ -281,7 +281,7 @@ impl LintPass for LiteralDigitGrouping {\n }\n \n impl EarlyLintPass for LiteralDigitGrouping {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n@@ -293,7 +293,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n }\n \n impl LiteralDigitGrouping {\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         match lit.node {\n             LitKind::Int(..) => {\n                 // Lint integral literals.\n@@ -421,7 +421,7 @@ impl LintPass for LiteralRepresentation {\n }\n \n impl EarlyLintPass for LiteralRepresentation {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n@@ -438,7 +438,7 @@ impl LiteralRepresentation {\n             threshold,\n         }\n     }\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         // Lint integral literals.\n         if_chain! {\n             if let LitKind::Int(..) = lit.node;"}, {"sha": "23830c566df8443dadb1a88df3545476ae3d4dde", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -743,7 +743,7 @@ struct FixedOffsetVar {\n     offset: Offset,\n }\n \n-fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n+fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     let is_slice = match ty.sty {\n         ty::TyRef(_, subty, _) => is_slice_like(cx, subty),\n         ty::TySlice(..) | ty::TyArray(..) => true,\n@@ -1185,7 +1185,7 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n     }\n }\n \n-fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &str) {\n+fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_name: &str) {\n     let object = snippet(cx, args[0].span, \"_\");\n     let muta = if method_name == \"iter_mut\" {\n         \"mut \"\n@@ -1203,7 +1203,7 @@ fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &s\n     )\n }\n \n-fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n+fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Expr) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n     if let ExprKind::MethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n@@ -1258,7 +1258,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n }\n \n /// Check for `for` loops over `Option`s and `Results`\n-fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n+fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n     let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(\n@@ -1420,7 +1420,7 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let Categorization::Local(id) = cmt.cat {\n                 if Some(id) == self.node_id_low {\n@@ -1453,7 +1453,7 @@ impl<'tcx> MutatePairDelegate {\n     }\n }\n \n-fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr) {\n+fn check_for_mut_range_bound(cx: &LateContext<'_, '_>, arg: &Expr, body: &Expr) {\n     if let Some(higher::Range {\n         start: Some(start),\n         end: Some(end),\n@@ -1472,7 +1472,7 @@ fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr) {\n     }\n }\n \n-fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n+fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n     if let Some(sp) = span {\n         span_lint(\n             cx,\n@@ -1483,7 +1483,7 @@ fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n+fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId> {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n@@ -1505,7 +1505,7 @@ fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n     None\n }\n \n-fn check_for_mutation(cx: &LateContext, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n+fn check_for_mutation(cx: &LateContext<'_, '_>, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n         node_id_low: bound_ids[0],\n         node_id_high: bound_ids[1],\n@@ -1782,7 +1782,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n /// Return true if the type of expr is one that provides `IntoIterator` impls\n /// for `&T` and `&mut T`, such as `Vec`.\n #[cfg_attr(rustfmt, rustfmt_skip)]\n-fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n+fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n     let ty = cx.tables.expr_ty(e);\n@@ -1797,7 +1797,7 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, ty, &paths::BTREESET)\n }\n \n-fn is_iterable_array(ty: Ty, cx: &LateContext) -> bool {\n+fn is_iterable_array(ty: Ty<'_>, cx: &LateContext<'_, '_>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n         ty::TyArray(_, n) => (0..=32).contains(&n.assert_usize(cx.tcx).expect(\"array length\")),\n@@ -2006,7 +2006,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n+fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<NodeId> {\n     if let ExprKind::Path(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(node_id) = path_res {\n@@ -2030,7 +2030,7 @@ fn is_conditional(expr: &Expr) -> bool {\n     }\n }\n \n-fn is_nested(cx: &LateContext, match_expr: &Expr, iter_expr: &Expr) -> bool {\n+fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     if_chain! {\n         if let Some(loop_block) = get_enclosing_block(cx, match_expr.id);\n         if let Some(map::Node::NodeExpr(loop_expr)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(loop_block.id));\n@@ -2041,7 +2041,7 @@ fn is_nested(cx: &LateContext, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     false\n }\n \n-fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n+fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n     let mut id = loop_expr.id;\n     let iter_name = if let Some(name) = path_name(iter_expr) {\n         name"}, {"sha": "d8b14db605f291c240626e8b10dd6537ddc7ca49", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn expr_eq_name(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n+fn expr_eq_name(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n         ExprKind::Path(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [\n@@ -116,7 +116,7 @@ fn expr_eq_name(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     }\n }\n \n-fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n+fn get_type_name(cx: &LateContext<'_, '_>, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         Some(\"iterator\")\n     } else if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(arg)), &paths::OPTION) {\n@@ -126,7 +126,7 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n     }\n }\n \n-fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n+fn only_derefs(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n         ExprKind::Unary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n         _ => expr_eq_name(cx, expr, id),"}, {"sha": "6ccf8daa71d64cbe7dc45b1f6463e2a37e080032", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -84,15 +84,15 @@ impl LintPass for Pass {\n     }\n }\n \n-fn is_unit_type(ty: ty::Ty) -> bool {\n+fn is_unit_type(ty: ty::Ty<'_>) -> bool {\n     match ty.sty {\n         ty::TyTuple(slice) => slice.is_empty(),\n         ty::TyNever => true,\n         _ => false,\n     }\n }\n \n-fn is_unit_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n+fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n \n     if let ty::TyFnDef(id, _) = ty.sty {\n@@ -103,15 +103,15 @@ fn is_unit_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n     false\n }\n \n-fn is_unit_expression(cx: &LateContext, expr: &hir::Expr) -> bool {\n+fn is_unit_expression(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     is_unit_type(cx.tables.expr_ty(expr))\n }\n \n /// The expression inside a closure may or may not have surrounding braces and\n /// semicolons, which causes problems when generating a suggestion. Given an\n /// expression that evaluates to '()' or '!', recursively remove useless braces\n /// and semi-colons until is suitable for including in the suggestion template\n-fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Span> {\n+fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) -> Option<Span> {\n     if !is_unit_expression(cx, expr) {\n         return None;\n     }\n@@ -175,7 +175,7 @@ fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Op\n /// `y` => `_y`\n ///\n /// Anything else will return `_`.\n-fn let_binding_name(cx: &LateContext, var_arg: &hir::Expr) -> String {\n+fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr) -> String {\n     match &var_arg.node {\n         hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n         hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n@@ -191,7 +191,7 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     )\n }\n \n-fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n+fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n     let var_arg = &map_args[0];\n     let fn_arg = &map_args[1];\n \n@@ -244,7 +244,7 @@ fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_ar\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt) {\n         if in_macro(stmt.span) {\n             return;\n         }"}, {"sha": "10d4d94cb915497b1511ec5c3ddf85a2fc80756a", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n }\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n-fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n       arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n       arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n@@ -222,13 +222,13 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     }\n }\n \n-fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+fn check_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n     if is_wild(&arms[1].pats[0]) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n \n-fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+fn report_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n     let lint = if els.is_some() {\n         SINGLE_MATCH_ELSE\n     } else {\n@@ -252,7 +252,7 @@ fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n     );\n }\n \n-fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty, els: Option<&Expr>) {\n+fn check_single_match_opt_like(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty<'_>, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n     let candidates = &[\n         (&paths::COW, \"Borrowed\"),\n@@ -284,7 +284,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     }\n }\n \n-fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tables.expr_ty(ex).sty == ty::TyBool {\n         span_lint_and_then(\n@@ -365,7 +365,7 @@ fn is_wild(pat: &impl std::ops::Deref<Target = Pat>) -> bool {\n     }\n }\n \n-fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n+fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n         for arm in arms {\n@@ -405,7 +405,7 @@ fn is_panic_block(block: &Block) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n         let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n@@ -436,7 +436,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr)\n     }\n }\n \n-fn check_match_as_ref(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n         arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n         arms[1].pats.len() == 1 && arms[1].guard.is_none() {"}, {"sha": "c1ae61dd2710030b5a532dd9fa6c7d5f8d51283a", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -876,10 +876,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n /// Checks for the `OR_FUN_CALL` lint.\n-fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         fun: &hir::Expr,\n         self_expr: &hir::Expr,\n@@ -924,7 +924,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n     /// Check for `*or(foo())`.\n     #[allow(too_many_arguments)]\n     fn check_general_case(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         method_span: Span,\n         fun_span: Span,\n@@ -967,7 +967,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n             return;\n         }\n \n-        let sugg: Cow<_> = match (fn_has_arguments, !or_has_args) {\n+        let sugg: Cow<'_, _> = match (fn_has_arguments, !or_has_args) {\n             (true, _) => format!(\"|_| {}\", snippet(cx, arg.span, \"..\")).into(),\n             (false, false) => format!(\"|| {}\", snippet(cx, arg.span, \"..\")).into(),\n             (false, true) => snippet(cx, fun_span, \"..\"),\n@@ -1000,7 +1000,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n }\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n-fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     fn extract_format_args(arg: &hir::Expr) -> Option<&hir::HirVec<hir::Expr>> {\n         if let hir::ExprKind::AddrOf(_, ref addr_of) = arg.node {\n             if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = addr_of.node {\n@@ -1015,7 +1015,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n         None\n     }\n \n-    fn generate_format_arg_snippet(cx: &LateContext, a: &hir::Expr) -> String {\n+    fn generate_format_arg_snippet(cx: &LateContext<'_, '_>, a: &hir::Expr) -> String {\n         if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n             if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n                 if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n@@ -1028,7 +1028,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n     }\n \n     fn check_general_case(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         method_span: Span,\n         self_expr: &hir::Expr,\n@@ -1079,7 +1079,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n             return;\n         }\n \n-        let sugg: Cow<_> = snippet(cx, arg.span, \"..\");\n+        let sugg: Cow<'_, _> = snippet(cx, arg.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,\n@@ -1100,7 +1100,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty) {\n+fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty<'_>) {\n     let ty = cx.tables.expr_ty(expr);\n     if let ty::TyRef(_, inner, _) = arg_ty.sty {\n         if let ty::TyRef(_, innermost, _) = inner.sty {\n@@ -1168,7 +1168,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n     }\n }\n \n-fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n+fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n \n     if let ty::TyAdt(_, subst) = obj_ty.sty {\n@@ -1194,7 +1194,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n }\n \n \n-fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n@@ -1223,14 +1223,14 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     }\n }\n \n-fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n     if match_type(cx, obj_ty, &paths::STRING) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n-fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n+fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n     if_chain! {\n         if let hir::ExprKind::Call(ref fun, ref args) = new.node;\n         if args.len() == 1;\n@@ -1251,7 +1251,7 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     }\n }\n \n-fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n+fn lint_iter_cloned_collect(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n     if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC)\n         && derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n     {\n@@ -1265,7 +1265,7 @@ fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir\n     }\n }\n \n-fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n+fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n     // Check that this is a call to Iterator::fold rather than just some function called fold\n     if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n@@ -1275,7 +1275,7 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n         \"Expected fold_args to have three entries - the receiver, the initial value and the closure\");\n \n     fn check_fold_with_op(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         fold_args: &[hir::Expr],\n         op: hir::BinOpKind,\n         replacement_method_name: &str,\n@@ -1353,7 +1353,7 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n     };\n }\n \n-fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n+fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n@@ -1377,7 +1377,7 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is\n     );\n }\n \n-fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n+fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n     let expr_ty = cx.tables.expr_ty(&get_args[0]);\n@@ -1416,7 +1416,7 @@ fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], i\n     );\n }\n \n-fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n+fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         span_lint(\n@@ -1428,8 +1428,8 @@ fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::Sugg<'static>> {\n-    fn may_slice(cx: &LateContext, ty: Ty) -> bool {\n+fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Option<sugg::Sugg<'static>> {\n+    fn may_slice(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyAdt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n@@ -1461,7 +1461,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n }\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n+fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n@@ -1489,7 +1489,7 @@ fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n }\n \n /// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n+fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n     // lint if the caller of `ok()` is a `Result`\n     if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT) {\n         let result_type = cx.tables.expr_ty(&ok_args[0]);\n@@ -1507,7 +1507,7 @@ fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n }\n \n /// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n+fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n         // get snippets for args to map() and unwrap_or()\n@@ -1765,7 +1765,7 @@ struct BinaryExprInfo<'a> {\n }\n \n /// Checks for the `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n-fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, info: &mut BinaryExprInfo) {\n+fn lint_binary_expr_with_method_call(cx: &LateContext<'_, '_>, info: &mut BinaryExprInfo<'_>) {\n     macro_rules! lint_with_both_lhs_and_rhs {\n         ($func:ident, $cx:expr, $info:ident) => {\n             if !$func($cx, $info) {\n@@ -1784,9 +1784,9 @@ fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, i\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n-fn lint_chars_cmp<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    info: &BinaryExprInfo,\n+fn lint_chars_cmp(\n+    cx: &LateContext<'_, '_>,\n+    info: &BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,\n     suggest: &str,\n@@ -1824,12 +1824,12 @@ fn lint_chars_cmp<'a, 'tcx>(\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint.\n-fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_NEXT_CMP, \"ends_with\") {\n         true\n     } else {\n@@ -1840,7 +1840,7 @@ fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    info: &BinaryExprInfo,\n+    info: &BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,\n     suggest: &str,\n@@ -1871,12 +1871,12 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n-fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n-fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     if lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {\n@@ -1907,7 +1907,7 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hi\n }\n \n /// Checks for the `USELESS_ASREF` lint.\n-fn lint_asref(cx: &LateContext, expr: &hir::Expr, call_name: &str, as_ref_args: &[hir::Expr]) {\n+fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_ref_args: &[hir::Expr]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n@@ -1931,7 +1931,7 @@ fn lint_asref(cx: &LateContext, expr: &hir::Expr, call_name: &str, as_ref_args:\n }\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n-fn get_error_type<'a>(cx: &LateContext, ty: Ty<'a>) -> Option<Ty<'a>> {\n+fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         if match_type(cx, ty, &paths::RESULT) {\n             substs.types().nth(1)\n@@ -2033,7 +2033,7 @@ enum SelfKind {\n impl SelfKind {\n     fn matches(\n         self,\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         ty: &hir::Ty,\n         arg: &hir::Arg,\n         self_ty: &hir::Ty,\n@@ -2160,7 +2160,7 @@ impl Convention {\n }\n \n impl fmt::Display for Convention {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n             Convention::Eq(this) => this.fmt(f),\n             Convention::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n@@ -2177,7 +2177,7 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(self, cx: &LateContext, ty: &hir::FunctionRetTy) -> bool {\n+    fn matches(self, cx: &LateContext<'_, '_>, ty: &hir::FunctionRetTy) -> bool {\n         let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyKind::Tup(vec![].into()));\n         match (self, ty) {\n             (OutType::Unit, &hir::DefaultReturn(_)) => true,"}, {"sha": "bc573841cc80d0651c6a3ff0c670bb56eba1feeb", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -66,7 +66,7 @@ enum MinMax {\n     Max,\n }\n \n-fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n+fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n     if let ExprKind::Call(ref path, ref args) = expr.node {\n         if let ExprKind::Path(ref qpath) = path.node {\n             opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)).and_then(|def_id| {\n@@ -86,7 +86,7 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n     }\n }\n \n-fn fetch_const<'a>(cx: &LateContext, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n+fn fetch_const<'a>(cx: &LateContext<'_, '_>, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n     if args.len() != 2 {\n         return None;\n     }"}, {"sha": "b01d24a1ad33143b26535c5fe2515844e71f18da", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -433,7 +433,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n+fn check_nan(cx: &LateContext<'_, '_>, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n         if let Some(seg) = path.segments.last() {\n             if seg.ident.name == \"NAN\" {\n@@ -464,11 +464,11 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n     }\n }\n \n-fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_float(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n-fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n+fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n     let (arg_ty, snip) = match expr.node {\n         ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n@@ -542,7 +542,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n /// Heuristic to see if an expression is used. Should be compatible with\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n-fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n             ExprKind::Assign(_, ref rhs) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n@@ -565,14 +565,14 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n }\n \n /// Test whether `def` is a variable defined outside a macro.\n-fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n+fn non_macro_local(cx: &LateContext<'_, '_>, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(id) | def::Def::Upvar(id, _, _) => !in_macro(cx.tcx.hir.span(id)),\n         _ => false,\n     }\n }\n \n-fn check_cast(cx: &LateContext, span: Span, e: &Expr, ty: &Ty) {\n+fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr, ty: &Ty) {\n     if_chain! {\n         if let TyKind::Ptr(MutTy { mutbl, .. }) = ty.node;\n         if let ExprKind::Lit(ref lit) = e.node;"}, {"sha": "5d2b3914f845083f41fb2b80bbe70ab3d4484e3e", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -189,7 +189,7 @@ impl LintPass for MiscEarly {\n }\n \n impl EarlyLintPass for MiscEarly {\n-    fn check_generics(&mut self, cx: &EarlyContext, gen: &Generics) {\n+    fn check_generics(&mut self, cx: &EarlyContext<'_>, gen: &Generics) {\n         for param in &gen.params {\n             if let GenericParamKind::Type { .. } = param.kind {\n                 let name = param.ident.as_str();\n@@ -205,7 +205,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &EarlyContext, pat: &Pat) {\n+    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n         if let PatKind::Struct(ref npat, ref pfields, _) = pat.node {\n             let mut wilds = 0;\n             let type_name = npat.segments\n@@ -266,7 +266,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, _: Span, _: NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, _: FnKind<'_>, decl: &FnDecl, _: Span, _: NodeId) {\n         let mut registered_names: HashMap<String, Span> = HashMap::new();\n \n         for arg in &decl.inputs {\n@@ -293,7 +293,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n@@ -325,7 +325,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_block(&mut self, cx: &EarlyContext, block: &Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n         for w in block.stmts.windows(2) {\n             if_chain! {\n                 if let StmtKind::Local(ref local) = w[0].node;\n@@ -352,7 +352,7 @@ impl EarlyLintPass for MiscEarly {\n }\n \n impl MiscEarly {\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         if_chain! {\n             if let LitKind::Int(value, ..) = lit.node;\n             if let Some(src) = snippet_opt(cx, lit.span);"}, {"sha": "fe2bbbdb9af0b0308fa1bf5e54815cef1ad7aec2", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -67,7 +67,7 @@ impl MissingDoc {\n             .expect(\"empty doc_hidden_stack\")\n     }\n \n-    fn check_missing_docs_attrs(&self, cx: &LateContext, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+    fn check_missing_docs_attrs(&self, cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {"}, {"sha": "e19ec4da67ed29cd4352924181c908dc96e41b9c", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -68,7 +68,7 @@ declare_clippy_lint! {\n \n pub struct MissingInline;\n \n-fn check_missing_inline_attrs(cx: &LateContext,\n+fn check_missing_inline_attrs(cx: &LateContext<'_, '_>,\n                               attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n     let has_inline = attrs\n         .iter()"}, {"sha": "d424604550661c57cc5fad9400dd44caf01fce07", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -39,7 +39,7 @@ impl LintPass for Pass {\n }\n \n impl EarlyLintPass for Pass {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &Crate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n         let metadata = match cargo_metadata::metadata_deps(None, true) {\n             Ok(metadata) => metadata,\n             Err(_) => {"}, {"sha": "50ef9f268f29ab5b36e09a8a5bbe38821f2afccc", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n     }\n }\n \n-fn get_atomic_name(ty: Ty) -> Option<(&'static str)> {\n+fn get_atomic_name(ty: Ty<'_>) -> Option<(&'static str)> {\n     match ty.sty {\n         ty::TyBool => Some(\"AtomicBool\"),\n         ty::TyUint(_) => Some(\"AtomicUsize\"),"}, {"sha": "60ab0eaae02415a7c041d869b6e4da90fe1a15ab", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -110,7 +110,7 @@ impl LintPass for NeedlessContinue {\n }\n \n impl EarlyLintPass for NeedlessContinue {\n-    fn check_expr(&mut self, ctx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, ctx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if !in_macro(expr.span) {\n             check_and_warn(ctx, expr);\n         }\n@@ -265,7 +265,7 @@ const DROP_ELSE_BLOCK_MSG: &str = \"Consider dropping the else clause, and moving\n                                    block, like so:\\n\";\n \n \n-fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: LintType) {\n+fn emit_warning<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str, typ: LintType) {\n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n@@ -284,7 +284,7 @@ fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: L\n     span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n }\n \n-fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n \n     let if_code = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n@@ -301,7 +301,7 @@ fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext, data: &'a L\n     ret\n }\n \n-fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n     let mut if_code = format!(\"if {} {{\\n\", cond_code);\n \n@@ -332,7 +332,7 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext, data: &'a\n     ret\n }\n \n-fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n+fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n     with_loop_block(expr, |loop_block| {\n         for (i, stmt) in loop_block.stmts.iter().enumerate() {\n             with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {"}, {"sha": "82e85f3453a1526d5c1ebaaf74c37a2d3cb4feca", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     }\n \n                     // Dereference suggestion\n-                    let sugg = |db: &mut DiagnosticBuilder| {\n+                    let sugg = |db: &mut DiagnosticBuilder<'_>| {\n                         if let ty::TypeVariants::TyAdt(def, ..) = ty.sty {\n                             if let Some(span) = cx.tcx.hir.span_if_local(def.did) {\n                                 if cx.param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n@@ -396,7 +396,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn borrow(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: ty::Region, _: ty::BorrowKind, _: euv::LoanCause) {}\n+    fn borrow(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: ty::Region<'_>, _: ty::BorrowKind, _: euv::LoanCause) {}\n \n     fn mutate(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n "}, {"sha": "c056ff46178b6af646d24fd238426227ba693be4", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n     }\n }\n \n-fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n+fn check_mul(cx: &LateContext<'_, '_>, span: Span, lit: &Expr, exp: &Expr) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.node;\n         if let Constant::Int(val) = consts::lit_to_constant(&l.node, cx.tables.expr_ty(lit));"}, {"sha": "49e4e966e18cdaea8dd8d270c3531ca02e282391", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -157,7 +157,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     }\n }\n \n-fn create_new_without_default_suggest_msg(ty: Ty) -> String {\n+fn create_new_without_default_suggest_msg(ty: Ty<'_>) -> String {\n     #[cfg_attr(rustfmt, rustfmt_skip)]\n     format!(\n \"impl Default for {} {{"}, {"sha": "cacb5d6a9ffcc31d9749b41a7113c9e24e273ade", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -41,7 +41,7 @@ declare_clippy_lint! {\n     \"outer expressions with no effect\"\n }\n \n-fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if in_macro(expr.span) {\n         return false;\n     }\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n \n-fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n+fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n     if in_macro(expr.span) {\n         return None;\n     }"}, {"sha": "e9688262c2a76eeb401771d58c3de37cdec41f35", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -312,21 +312,21 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n }\n \n impl EarlyLintPass for NonExpressiveNames {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if let ItemKind::Fn(ref decl, _, _, ref blk) = item.node {\n             do_check(self, cx, &item.attrs, decl, blk);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &EarlyContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &EarlyContext<'_>, item: &ImplItem) {\n         if let ImplItemKind::Method(ref sig, ref blk) = item.node {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }\n \n }\n \n-fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n+fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext<'_>, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n     if !attr::contains_name(attrs, \"test\") {\n         let mut visitor = SimilarNamesLocalVisitor {\n             names: Vec::new(),"}, {"sha": "effeb88d0cf8569d8457067c23846c21d460641f", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -61,7 +61,7 @@ enum OpenOption {\n     Append,\n }\n \n-fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n+fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.node {\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n \n@@ -112,7 +112,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n     }\n }\n \n-fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n+fn check_open_options(cx: &LateContext<'_, '_>, options: &[(OpenOption, Argument)], span: Span) {\n     let (mut create, mut append, mut truncate, mut read, mut write) = (false, false, false, false, false);\n     let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) =\n         (false, false, false, false, false);"}, {"sha": "e603773f7ba40155529303f9c362c5a24f2351a5", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -86,7 +86,7 @@ fn get_outer_span(expr: &Expr) -> Span {\n     }\n }\n \n-fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext) {\n+fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext<'_, '_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = params[0].node;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();"}, {"sha": "6a0f4f147b727b496f0d6b47a84a66b2330d685d", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -37,7 +37,7 @@ impl LintPass for Precedence {\n }\n \n impl EarlyLintPass for Precedence {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if in_macro(expr.span) {\n             return;\n         }"}, {"sha": "ea2d07df45577a655f0c526bb2f956f2f5c7b646", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n+fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();"}, {"sha": "630dd1b57be1660cb01c858f71efcd1dd494f93e", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -52,7 +52,7 @@ impl QuestionMarkPass {\n     /// ```\n     ///\n     /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_and_early_return_none(cx: &LateContext, expr: &Expr) {\n+    fn check_is_none_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n             if let ExprKind::If(ref if_expr, ref body, _) = expr.node;\n             if let ExprKind::MethodCall(ref segment, _, ref args) = if_expr.node;\n@@ -81,13 +81,13 @@ impl QuestionMarkPass {\n         }\n     }\n \n-    fn is_option(cx: &LateContext, expression: &Expr) -> bool {\n+    fn is_option(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n         match_type(cx, expr_ty, &OPTION)\n     }\n \n-    fn expression_returns_none(cx: &LateContext, expression: &Expr) -> bool {\n+    fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n         match expression.node {\n             ExprKind::Block(ref block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {"}, {"sha": "fd303bb6ab4f8dd39ebde8de2e3dada1c9b32e5a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_step_by(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n     let ty = cx.tables.expr_ty_adjusted(expr);"}, {"sha": "f349f46d926e31987f2f8a024c4584e69a1e1424", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -39,7 +39,7 @@ fn without_parens(mut e: &Expr) -> &Expr {\n }\n \n impl EarlyLintPass for Pass {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n             if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node;\n             if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node;\n@@ -84,7 +84,7 @@ impl LintPass for DerefPass {\n }\n \n impl EarlyLintPass for DerefPass {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n             if let ExprKind::Field(ref object, ref field_name) = e.node;\n             if let ExprKind::Paren(ref parened) = object.node;"}, {"sha": "e4973cadc61528a335dd074c3e3c59c7ae66e5ad", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -49,7 +49,7 @@ pub struct ReturnPass;\n \n impl ReturnPass {\n     // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         if let Some(stmt) = block.stmts.last() {\n             match stmt.node {\n                 ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n@@ -61,7 +61,7 @@ impl ReturnPass {\n     }\n \n     // Check a the final expression in a block if it's a return.\n-    fn check_final_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr, span: Option<Span>) {\n+    fn check_final_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr, span: Option<Span>) {\n         match expr.node {\n             // simple return is always \"bad\"\n             ast::ExprKind::Ret(Some(ref inner)) => {\n@@ -89,7 +89,7 @@ impl ReturnPass {\n         }\n     }\n \n-    fn emit_return_lint(&mut self, cx: &EarlyContext, ret_span: Span, inner_span: Span) {\n+    fn emit_return_lint(&mut self, cx: &EarlyContext<'_>, ret_span: Span, inner_span: Span) {\n         if in_external_macro(cx, inner_span) || in_macro(inner_span) {\n             return;\n         }\n@@ -101,7 +101,7 @@ impl ReturnPass {\n     }\n \n     // Check for \"let x = EXPR; x\"\n-    fn check_let_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_let_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         let mut it = block.stmts.iter();\n \n         // we need both a let-binding stmt and an expr\n@@ -138,14 +138,14 @@ impl LintPass for ReturnPass {\n }\n \n impl EarlyLintPass for ReturnPass {\n-    fn check_fn(&mut self, cx: &EarlyContext, kind: FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n         match kind {\n             FnKind::ItemFn(.., block) | FnKind::Method(.., block) => self.check_block_return(cx, block),\n             FnKind::Closure(body) => self.check_final_expr(cx, body, Some(body.span)),\n         }\n     }\n \n-    fn check_block(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         self.check_let_return(cx, block);\n     }\n }"}, {"sha": "1b29e53b75435015f54b21cd43ed32ce21cbd443", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -148,7 +148,7 @@ fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings:\n     }\n }\n \n-fn is_binding(cx: &LateContext, pat_id: HirId) -> bool {\n+fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables.node_id_to_type(pat_id);\n     match var_ty.sty {\n         ty::TyAdt(..) => false,"}, {"sha": "a13f864c5ce7debea72e0c385d1f92c84de45c9e", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -117,11 +117,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     }\n }\n \n-fn is_string(cx: &LateContext, e: &Expr) -> bool {\n+fn is_string(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(e)), &paths::STRING)\n }\n \n-fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n+fn is_add(cx: &LateContext<'_, '_>, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n         ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprKind::Block(ref block, _) => {"}, {"sha": "b0a8a2d00617cff2a85fab7cf07f85dbbe5c6de6", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n }\n \n fn check_binop<'a>(\n-    cx: &LateContext,\n+    cx: &LateContext<'_, '_>,\n     expr: &hir::Expr,\n     binop: hir::BinOpKind,\n     traits: &[&'a str],"}, {"sha": "38369d05676ca4501dda009231ef92dccacbf784", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Swap {\n }\n \n /// Implementation of the `MANUAL_SWAP` lint.\n-fn check_manual_swap(cx: &LateContext, block: &Block) {\n+fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n@@ -84,7 +84,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n             then {\n                 fn check_for_slice<'a>(\n-                    cx: &LateContext,\n+                    cx: &LateContext<'_, '_>,\n                     lhs1: &'a Expr,\n                     lhs2: &'a Expr,\n                 ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n@@ -145,7 +145,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint.\n-fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n+fn check_suspicious_swap(cx: &LateContext<'_, '_>, block: &Block) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n             if let StmtKind::Semi(ref first, _) = w[0].node;"}, {"sha": "403aeb47402077d143d7f28a1a3009a1d44f8f77", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -454,7 +454,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n /// the type's `ToString` implementation. In weird cases it could lead to types\n /// with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &QPath, to_ref_ty: Ty) -> String {\n+fn get_type_snippet(cx: &LateContext<'_, '_>, path: &QPath, to_ref_ty: Ty<'_>) -> String {\n     let seg = last_path_segment(path);\n     if_chain! {\n         if let Some(ref params) = seg.args;"}, {"sha": "d3932f411d1e4db9cdf71c6dcdd8fe0d22cce230", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -138,7 +138,7 @@ impl LintPass for TypePass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext<'_, '_>, _: FnKind<'_>, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n         // skip trait implementations, see #605\n         if let Some(map::NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(id)) {\n             if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n@@ -149,26 +149,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n         check_fn_decl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &StructField) {\n         check_ty(cx, &field.ty, false);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &TraitItem) {\n         match item.node {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty, false),\n             TraitItemKind::Method(ref sig, _) => check_fn_decl(cx, &sig.decl),\n             _ => (),\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext, local: &Local) {\n+    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local) {\n         if let Some(ref ty) = local.ty {\n             check_ty(cx, ty, true);\n         }\n     }\n }\n \n-fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n+fn check_fn_decl(cx: &LateContext<'_, '_>, decl: &FnDecl) {\n     for input in &decl.inputs {\n         check_ty(cx, input, false);\n     }\n@@ -179,7 +179,7 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n }\n \n /// Check if `qpath` has last segment with type parameter matching `path`\n-fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool {\n+fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n     if_chain! {\n         if let Some(ref params) = last.args;\n@@ -203,7 +203,7 @@ fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool\n ///\n /// The parameter `is_local` distinguishes the context of the type; types from\n /// local bindings should only be checked for the `BORROWED_BOX` lint.\n-fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n+fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n     if in_macro(ast_ty.span) {\n         return;\n     }\n@@ -294,7 +294,7 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n     }\n }\n \n-fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n+fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n     match mut_ty.ty.node {\n         TyKind::Path(ref qpath) => {\n             let hir_id = cx.tcx.hir.node_to_hir_id(mut_ty.ty.id);\n@@ -378,7 +378,7 @@ declare_clippy_lint! {\n     \"creating a let binding to a value of unit type, which usually can't be used afterwards\"\n }\n \n-fn check_let_unit(cx: &LateContext, decl: &Decl) {\n+fn check_let_unit(cx: &LateContext<'_, '_>, decl: &Decl) {\n     if let DeclKind::Local(ref local) = decl.node {\n         if is_unit(cx.tables.pat_ty(&local.pat)) {\n             if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n@@ -548,7 +548,7 @@ fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n     }\n }\n \n-fn is_unit(ty: Ty) -> bool {\n+fn is_unit(ty: Ty<'_>) -> bool {\n     match ty.sty {\n         ty::TyTuple(slice) if slice.is_empty() => true,\n         _ => false,\n@@ -753,7 +753,7 @@ declare_clippy_lint! {\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n-fn int_ty_to_nbits(typ: Ty, tcx: TyCtxt) -> u64 {\n+fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n     match typ.sty {\n         ty::TyInt(i) => match i {\n             IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n@@ -775,14 +775,14 @@ fn int_ty_to_nbits(typ: Ty, tcx: TyCtxt) -> u64 {\n     }\n }\n \n-fn is_isize_or_usize(typ: Ty) -> bool {\n+fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n     match typ.sty {\n         ty::TyInt(IntTy::Isize) | ty::TyUint(UintTy::Usize) => true,\n         _ => false,\n     }\n }\n \n-fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty<'_>, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -822,7 +822,7 @@ fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n     false\n }\n \n-fn span_lossless_lint(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n     if in_constant(cx, expr.id) { return }\n     // The suggestion is to use a function call, so if the original expression\n@@ -854,7 +854,7 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn check_truncation_and_wrapping(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -925,7 +925,7 @@ fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, c\n     }\n }\n \n-fn check_lossless(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn check_lossless(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n     let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n     let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n@@ -1183,7 +1183,7 @@ impl<'a, 'tcx> TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &hir::Ty) {\n+    fn check_type(&self, cx: &LateContext<'_, '_>, ty: &hir::Ty) {\n         if in_macro(ty.span) {\n             return;\n         }\n@@ -1562,7 +1562,7 @@ impl Ord for FullInt {\n }\n \n \n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n@@ -1628,7 +1628,7 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n     }\n }\n \n-fn err_upcast_comparison(cx: &LateContext, span: Span, expr: &Expr, always: bool) {\n+fn err_upcast_comparison(cx: &LateContext<'_, '_>, span: Span, expr: &Expr, always: bool) {\n     if let ExprKind::Cast(ref cast_val, _) = expr.node {\n         span_lint(\n             cx,\n@@ -1750,11 +1750,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n \n         fn suggestion<'a, 'tcx>(\n             cx: &LateContext<'a, 'tcx>,\n-            db: &mut DiagnosticBuilder,\n+            db: &mut DiagnosticBuilder<'_>,\n             generics_span: Span,\n             generics_suggestion_span: Span,\n-            target: &ImplicitHasherType,\n-            vis: ImplicitHasherConstructorVisitor,\n+            target: &ImplicitHasherType<'_>,\n+            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n         ) {\n             let generics_snip = snippet(cx, generics_span, \"\");\n             // trim `<` `>`"}, {"sha": "0549e774fb55debb70f1c4b6b9408b591c9bf808", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -94,7 +94,7 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n     result\n }\n \n-fn check_str(cx: &LateContext, span: Span, id: NodeId) {\n+fn check_str(cx: &LateContext<'_, '_>, span: Span, id: NodeId) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n         span_help_and_lint("}, {"sha": "2f8b3ab836db99ab2c6348d1675b1f922cd358e6", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -35,14 +35,14 @@ impl LintPass for UnsafeNameRemoval {\n }\n \n impl EarlyLintPass for UnsafeNameRemoval {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if let ItemKind::Use(ref use_tree) = item.node {\n             check_use_tree(use_tree, cx, item.span);\n         }\n     }\n }\n \n-fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: Span) {\n+fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext<'_>, span: Span) {\n     match use_tree.kind {\n         UseTreeKind::Simple(Some(new_name), ..) => {\n             let old_name = use_tree\n@@ -63,7 +63,7 @@ fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: Span) {\n     }\n }\n \n-fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: Span) {\n+fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext<'_>, span: Span) {\n     let old_str = old_name.name.as_str();\n     let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {"}, {"sha": "a9a7e102ab274bf62554142bd40468c8f3c80926", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -39,7 +39,7 @@ impl LintPass for UnusedIoAmount {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtKind::Semi(ref expr, _) | hir::StmtKind::Expr(ref expr, _) => &**expr,\n             _ => return,\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n     }\n }\n \n-fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n+fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr, expr: &hir::Expr) {\n     if let hir::ExprKind::MethodCall(ref path, _, _) = call.node {\n         let symbol = &*path.ident.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {"}, {"sha": "a27013344d8e9586f8eba8a1b1dcd8e34820a0c6", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -52,7 +52,7 @@ pub enum Error {\n }\n \n impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n             Error::Io(ref err) => err.fmt(f),\n             Error::Toml(ref err) => err.fmt(f),"}, {"sha": "3931f6c55f9ed0b9bda60de4be8d1d00602152db", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -212,7 +212,7 @@ pub enum VecArgs<'a> {\n \n /// Returns the arguments of the `vec!` macro if this expression was expanded\n /// from `vec!`.\n-pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n+pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_chain! {\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.node;\n         if let hir::ExprKind::Path(ref path) = fun.node;"}, {"sha": "b6c241a682533d9021cf6d6dbfd5ef73e4db5451", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -141,7 +141,7 @@ fn has_attr(attrs: &[Attribute]) -> bool {\n     get_attr(attrs, \"dump\").count() > 0\n }\n \n-fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n+fn print_decl(cx: &LateContext<'_, '_>, decl: &hir::Decl) {\n     match decl.node {\n         hir::DeclKind::Local(ref local) => {\n             println!(\"local variable of type {}\", cx.tables.node_id_to_type(local.hir_id));\n@@ -156,7 +156,7 @@ fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n     }\n }\n \n-fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n+fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n@@ -342,7 +342,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n     }\n }\n \n-fn print_item(cx: &LateContext, item: &hir::Item) {\n+fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n     let did = cx.tcx.hir.local_def_id(item.id);\n     println!(\"item `{}`\", item.name);\n     match item.vis.node {\n@@ -414,7 +414,7 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n     }\n }\n \n-fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n+fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     match pat.node {"}, {"sha": "32aee09917717f48df24064b8028b263d03a8cc6", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -64,7 +64,7 @@ impl LintPass for Clippy {\n }\n \n impl EarlyLintPass for Clippy {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &AstCrate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &AstCrate) {\n         if let Some(utils) = krate\n             .module\n             .items"}, {"sha": "8e83b8d81f2e4f06dc5c64d1062aac0cf5f22e6f", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -48,7 +48,7 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.ctxt() != lhs.ctxt()\n }\n \n-pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n+pub fn in_constant(cx: &LateContext<'_, '_>, id: NodeId) -> bool {\n     let parent_id = cx.tcx.hir.get_parent(id);\n     match cx.tcx.hir.body_owner_kind(parent_id) {\n         hir::BodyOwnerKind::Fn => false,\n@@ -115,7 +115,7 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n+pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) -> bool {\n     use syntax::symbol;\n \n     struct AbsolutePathBuffer {\n@@ -145,15 +145,15 @@ pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n }\n \n /// Check if type is struct, enum or union type with given def path.\n-pub fn match_type(cx: &LateContext, ty: Ty, path: &[&str]) -> bool {\n+pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n     }\n }\n \n /// Check if the method call given in `expr` belongs to given type.\n-pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n+pub fn match_impl_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.impl_of_method(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n@@ -164,7 +164,7 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n }\n \n /// Check if the method call given in `expr` belongs to given trait.\n-pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n+pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.trait_of_item(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n@@ -244,7 +244,7 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n }\n \n /// Get the definition associated to a path.\n-pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n+pub fn path_to_def(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Def> {\n     let crates = cx.tcx.crates();\n     let krate = crates\n         .iter()\n@@ -280,7 +280,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n }\n \n /// Convenience function to get the `DefId` of a trait by path.\n-pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n+pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId> {\n     let def = match path_to_def(cx, path) {\n         Some(def) => def,\n         None => return None,\n@@ -308,7 +308,7 @@ pub fn implements_trait<'a, 'tcx>(\n }\n \n /// Check whether this type implements Drop.\n-pub fn has_drop(cx: &LateContext, expr: &Expr) -> bool {\n+pub fn has_drop(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     let struct_ty = cx.tables.expr_ty(expr);\n     match struct_ty.ty_adt_def() {\n         Some(def) => def.has_dtor(cx.tcx),\n@@ -317,7 +317,7 @@ pub fn has_drop(cx: &LateContext, expr: &Expr) -> bool {\n }\n \n /// Resolve the definition of a node from its `HirId`.\n-pub fn resolve_node(cx: &LateContext, qpath: &QPath, id: HirId) -> def::Def {\n+pub fn resolve_node(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> def::Def {\n     cx.tables.qpath_def(qpath, id)\n }\n \n@@ -352,7 +352,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n \n \n /// Get the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n+pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.hir.get_parent(expr.id);\n     match cx.tcx.hir.find(parent_id) {\n         Some(Node::NodeItem(&Item { ref name, .. })) => Some(*name),\n@@ -458,13 +458,13 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n \n /// Trim indentation from a multiline string with possibility of ignoring the\n /// first line.\n-pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n+pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool) -> Cow<'_, str> {\n     let s_space = trim_multiline_inner(s, ignore_first, ' ');\n     let s_tab = trim_multiline_inner(s_space, ignore_first, '\\t');\n     trim_multiline_inner(s_tab, ignore_first, ' ')\n }\n \n-fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n+fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_, str> {\n     let x = s.lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n@@ -502,7 +502,7 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n }\n \n /// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n-pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n+pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.hir;\n     let node_id: NodeId = e.id;\n     let parent_id: NodeId = map.get_parent_node(node_id);\n@@ -642,7 +642,7 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n /// appear once per\n /// replacement. In human-readable format though, it only appears once before\n /// the whole suggestion.\n-pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder, help_msg: String, sugg: I)\n+pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder<'_>, help_msg: String, sugg: I)\n where\n     I: IntoIterator<Item = (Span, String)>,\n {\n@@ -675,7 +675,7 @@ pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n }\n \n /// Return the base type for references and raw pointers.\n-pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n+pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n     match ty.sty {\n         ty::TyRef(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n@@ -684,8 +684,8 @@ pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n \n /// Return the base type for references and raw pointers, and count reference\n /// depth.\n-pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n-    fn inner(ty: Ty, depth: usize) -> (Ty, usize) {\n+pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n         match ty.sty {\n             ty::TyRef(_, ty, _) => inner(ty, depth + 1),\n             _ => (ty, depth),\n@@ -705,7 +705,7 @@ pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     false\n }\n \n-pub fn is_adjusted(cx: &LateContext, e: &Expr) -> bool {\n+pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     cx.tables.adjustments().get(e.hir_id).is_some()\n }\n \n@@ -898,15 +898,15 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n /// Return whether a pattern is refutable.\n-pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n-    fn is_enum_variant(cx: &LateContext, qpath: &QPath, id: HirId) -> bool {\n+pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n+    fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> bool {\n         matches!(\n             cx.tables.qpath_def(qpath, id),\n             def::Def::Variant(..) | def::Def::VariantCtor(..)\n         )\n     }\n \n-    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext<'_, '_>, mut i: I) -> bool {\n         i.any(|pat| is_refutable(cx, pat))\n     }\n \n@@ -1065,7 +1065,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n /// Returns true if the lint is allowed in the current context\n ///\n /// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext, lint: &'static Lint, id: NodeId) -> bool {\n+pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: NodeId) -> bool {\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n@@ -1085,24 +1085,24 @@ pub fn get_arg_ident(pat: &Pat) -> Option<ast::Ident> {\n     }\n }\n \n-pub fn int_bits(tcx: TyCtxt, ity: ast::IntTy) -> u64 {\n+pub fn int_bits(tcx: TyCtxt<'_, '_, '_>, ity: ast::IntTy) -> u64 {\n     layout::Integer::from_attr(tcx, attr::IntType::SignedInt(ity)).size().bits()\n }\n \n /// Turn a constant int byte representation into an i128\n-pub fn sext(tcx: TyCtxt, u: u128, ity: ast::IntTy) -> i128 {\n+pub fn sext(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::IntTy) -> i128 {\n     let amt = 128 - int_bits(tcx, ity);\n     ((u as i128) << amt) >> amt\n }\n \n /// clip unused bytes\n-pub fn unsext(tcx: TyCtxt, u: i128, ity: ast::IntTy) -> u128 {\n+pub fn unsext(tcx: TyCtxt<'_, '_, '_>, u: i128, ity: ast::IntTy) -> u128 {\n     let amt = 128 - int_bits(tcx, ity);\n     ((u as u128) << amt) >> amt\n }\n \n /// clip unused bytes\n-pub fn clip(tcx: TyCtxt, u: u128, ity: ast::UintTy) -> u128 {\n+pub fn clip(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::UintTy) -> u128 {\n     let bits = layout::Integer::from_attr(tcx, attr::IntType::UnsignedInt(ity)).size().bits();\n     let amt = 128 - bits;\n     (u << amt) >> amt\n@@ -1141,7 +1141,7 @@ pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n     without\n }\n \n-pub fn any_parent_is_automatically_derived(tcx: TyCtxt, node: NodeId) -> bool {\n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: NodeId) -> bool {\n     let map = &tcx.hir;\n     let mut prev_enclosing_node = None;\n     let mut enclosing_node = node;"}, {"sha": "1a20eb0101538b17533cd0916a2445b4fb25bdf0", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -7,7 +7,7 @@ use syntax::codemap::Span;\n use crate::utils::{get_pat_name, match_var, snippet};\n \n pub fn get_spans(\n-    cx: &LateContext,\n+    cx: &LateContext<'_, '_>,\n     opt_body_id: Option<BodyId>,\n     idx: usize,\n     replacements: &'static [(&'static str, &'static str)],"}, {"sha": "91fd5ec874afda3ffabb3bd402d2ba87f8793aab", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -32,8 +32,8 @@ pub enum Sugg<'a> {\n /// Literal constant `1`, for convenience.\n pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n \n-impl<'a> Display for Sugg<'a> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+impl Display for Sugg<'_> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         match *self {\n             Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => s.fmt(f),\n         }\n@@ -43,7 +43,7 @@ impl<'a> Display for Sugg<'a> {\n #[allow(wrong_self_convention)] // ok, because of the function `as_ty` method\n impl<'a> Sugg<'a> {\n     /// Prepare a suggestion from an expression.\n-    pub fn hir_opt(cx: &LateContext, expr: &hir::Expr) -> Option<Self> {\n+    pub fn hir_opt(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n             match expr.node {\n@@ -82,12 +82,12 @@ impl<'a> Sugg<'a> {\n \n     /// Convenience function around `hir_opt` for suggestions with a default\n     /// text.\n-    pub fn hir(cx: &LateContext, expr: &hir::Expr, default: &'a str) -> Self {\n+    pub fn hir(cx: &LateContext<'_, '_>, expr: &hir::Expr, default: &'a str) -> Self {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n     /// Prepare a suggestion from an expression.\n-    pub fn ast(cx: &EarlyContext, expr: &ast::Expr, default: &'a str) -> Self {\n+    pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use syntax::ast::RangeLimits;\n \n         let snippet = snippet(cx, expr.span, default);\n@@ -241,7 +241,7 @@ impl<T> ParenHelper<T> {\n }\n \n impl<T: Display> Display for ParenHelper<T> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         if self.paren {\n             write!(f, \"({})\", self.wrapped)\n         } else {\n@@ -255,7 +255,7 @@ impl<T: Display> Display for ParenHelper<T> {\n /// For convenience, the operator is taken as a string because all unary\n /// operators have the same\n /// precedence.\n-pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n+pub fn make_unop(op: &str, expr: Sugg<'_>) -> Sugg<'static> {\n     Sugg::MaybeParen(format!(\"{}{}\", op, expr.maybe_par()).into())\n }\n \n@@ -264,7 +264,7 @@ pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n /// Precedence of shift operator relative to other arithmetic operation is\n /// often confusing so\n /// parenthesis will always be added for a mix of these.\n-pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n     /// Whether the operator is a shift operator `<<` or `>>`.\n     fn is_shift(op: &AssocOp) -> bool {\n         matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n@@ -335,7 +335,7 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n }\n \n /// Convinience wrapper arround `make_assoc` and `AssocOp::from_ast_binop`.\n-pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n     make_assoc(AssocOp::from_ast_binop(op), lhs, rhs)\n }\n "}, {"sha": "43e492bfb4e40f70b6fe7a4d1f796deeb6538b70", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -44,7 +44,7 @@ struct MutVarsDelegate {\n }\n \n impl<'tcx> MutVarsDelegate {\n-    fn update(&mut self, cat: &'tcx Categorization) {\n+    fn update(&mut self, cat: &'tcx Categorization<'_>) {\n         match *cat {\n             Categorization::Local(id) => {\n                 self.used_mutably.insert(id);\n@@ -68,7 +68,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt.cat)\n         }"}, {"sha": "cea3307a8273fcc0280da7da664879b64ee3cf88", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -94,7 +94,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n }\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n-fn vec_type(ty: Ty) -> Ty {\n+fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         substs.type_at(0)\n     } else {"}, {"sha": "a019e23a3014f34821d4ac6df525515edd99cae6", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -168,7 +168,7 @@ impl LintPass for Pass {\n }\n \n impl EarlyLintPass for Pass {\n-    fn check_mac(&mut self, cx: &EarlyContext, mac: &Mac) {\n+    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &Mac) {\n         if mac.node.path == \"println\" {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n             if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n@@ -261,7 +261,7 @@ fn check_tts(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> Op\n             return Some(fmtstr);\n         }\n         let expr = parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n-        const SIMPLE: FormatSpec = FormatSpec {\n+        const SIMPLE: FormatSpec<'_> = FormatSpec {\n             fill: None,\n             align: AlignUnknown,\n             flags: 0,"}, {"sha": "1123c968006ab82f70d370a5aecd55747f0d23e7", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd91248eda02cf2968e4e02c77b6c10ecd3fd4f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=afd91248eda02cf2968e4e02c77b6c10ecd3fd4f", "patch": "@@ -10,7 +10,7 @@\n use rustc_plugin::Registry;\n \n #[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n+pub fn plugin_registrar(reg: &mut Registry<'_>) {\n     reg.sess.lint_store.with_read_lock(|lint_store| {\n         for (lint, _, _) in lint_store.get_lint_groups() {\n             reg.sess"}]}