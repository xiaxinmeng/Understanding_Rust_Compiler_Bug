{"sha": "2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "node_id": "C_kwDOAAsO6NoAKDJlMGE4MGM4YzBlNGZiMmZkYmRjZWNmYTIxZGYyMmFkMjA1MjFmZDE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-01-12T22:13:52Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-01-12T22:13:52Z"}, "message": "Err about fn traits in a single place.", "tree": {"sha": "8f6faab3e415f657e1be06a74274fa67e9cf7d4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f6faab3e415f657e1be06a74274fa67e9cf7d4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "html_url": "https://github.com/rust-lang/rust/commit/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b285925c8764aad027437491e10d9e0ca9edbbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b285925c8764aad027437491e10d9e0ca9edbbc", "html_url": "https://github.com/rust-lang/rust/commit/7b285925c8764aad027437491e10d9e0ca9edbbc"}], "stats": {"total": 233, "additions": 127, "deletions": 106}, "files": [{"sha": "1f99a9b0536d0e967a54d17ddcef6d170d387162", "filename": "compiler/rustc_typeck/src/astconv/errors.rs", "status": "modified", "additions": 83, "deletions": 49, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs?ref=2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "patch": "@@ -93,62 +93,96 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         span: Span,\n         trait_def_id: DefId,\n         trait_segment: &'_ hir::PathSegment<'_>,\n+        is_impl: bool,\n     ) {\n+        if self.tcx().features().unboxed_closures {\n+            return;\n+        }\n+\n         let trait_def = self.tcx().trait_def(trait_def_id);\n+        if !trait_def.paren_sugar {\n+            if trait_segment.args().parenthesized {\n+                // For now, require that parenthetical notation be used only with `Fn()` etc.\n+                let mut err = feature_err(\n+                    &self.tcx().sess.parse_sess,\n+                    sym::unboxed_closures,\n+                    span,\n+                    \"parenthetical notation is only stable when used with `Fn`-family traits\",\n+                );\n+                err.emit();\n+            }\n \n-        if !self.tcx().features().unboxed_closures\n-            && trait_segment.args().parenthesized != trait_def.paren_sugar\n-        {\n-            let sess = &self.tcx().sess.parse_sess;\n+            return;\n+        }\n+\n+        let sess = self.tcx().sess;\n+\n+        if !trait_segment.args().parenthesized {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n-            let (msg, sugg) = if trait_def.paren_sugar {\n-                (\n-                    \"the precise format of `Fn`-family traits' type parameters is subject to \\\n-                     change\",\n-                    Some(format!(\n-                        \"{}{} -> {}\",\n-                        trait_segment.ident,\n-                        trait_segment\n-                            .args\n-                            .as_ref()\n-                            .and_then(|args| args.args.get(0))\n-                            .and_then(|arg| match arg {\n-                                hir::GenericArg::Type(ty) => match ty.kind {\n-                                    hir::TyKind::Tup(t) => t\n-                                        .iter()\n-                                        .map(|e| sess.source_map().span_to_snippet(e.span))\n-                                        .collect::<Result<Vec<_>, _>>()\n-                                        .map(|a| a.join(\", \")),\n-                                    _ => sess.source_map().span_to_snippet(ty.span),\n-                                }\n-                                .map(|s| format!(\"({})\", s))\n-                                .ok(),\n-                                _ => None,\n-                            })\n-                            .unwrap_or_else(|| \"()\".to_string()),\n-                        trait_segment\n-                            .args()\n-                            .bindings\n-                            .iter()\n-                            .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n-                                (true, hir::TypeBindingKind::Equality { ty }) => {\n-                                    sess.source_map().span_to_snippet(ty.span).ok()\n-                                }\n-                                _ => None,\n-                            })\n-                            .unwrap_or_else(|| \"()\".to_string()),\n-                    )),\n-                )\n-            } else {\n-                (\"parenthetical notation is only stable when used with `Fn`-family traits\", None)\n-            };\n-            let mut err = feature_err(sess, sym::unboxed_closures, span, msg);\n-            if let Some(sugg) = sugg {\n-                let msg = \"use parenthetical notation instead\";\n-                err.span_suggestion(span, msg, sugg, Applicability::MaybeIncorrect);\n+            let mut err = feature_err(\n+                &sess.parse_sess,\n+                sym::unboxed_closures,\n+                span,\n+                \"the precise format of `Fn`-family traits' type parameters is subject to change\",\n+            );\n+            // Do not suggest the other syntax if we are in trait impl:\n+            // the desugaring would contain an associated type constrait.\n+            if !is_impl {\n+                let args = trait_segment\n+                    .args\n+                    .as_ref()\n+                    .and_then(|args| args.args.get(0))\n+                    .and_then(|arg| match arg {\n+                        hir::GenericArg::Type(ty) => match ty.kind {\n+                            hir::TyKind::Tup(t) => t\n+                                .iter()\n+                                .map(|e| sess.source_map().span_to_snippet(e.span))\n+                                .collect::<Result<Vec<_>, _>>()\n+                                .map(|a| a.join(\", \")),\n+                            _ => sess.source_map().span_to_snippet(ty.span),\n+                        }\n+                        .map(|s| format!(\"({})\", s))\n+                        .ok(),\n+                        _ => None,\n+                    })\n+                    .unwrap_or_else(|| \"()\".to_string());\n+                let ret = trait_segment\n+                    .args()\n+                    .bindings\n+                    .iter()\n+                    .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n+                        (true, hir::TypeBindingKind::Equality { ty }) => {\n+                            sess.source_map().span_to_snippet(ty.span).ok()\n+                        }\n+                        _ => None,\n+                    })\n+                    .unwrap_or_else(|| \"()\".to_string());\n+                err.span_suggestion(\n+                    span,\n+                    \"use parenthetical notation instead\",\n+                    format!(\"{}{} -> {}\", trait_segment.ident, args, ret),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n             err.emit();\n         }\n+\n+        if is_impl {\n+            let trait_name = self.tcx().def_path_str(trait_def_id);\n+            struct_span_err!(\n+                self.tcx().sess,\n+                span,\n+                E0183,\n+                \"manual implementations of `{}` are experimental\",\n+                trait_name,\n+            )\n+            .span_label(\n+                span,\n+                format!(\"manual implementations of `{}` are experimental\", trait_name),\n+            )\n+            .help(\"add `#![feature(unboxed_closures)]` to the crate attributes to enable\")\n+            .emit();\n+        }\n     }\n \n     pub(crate) fn complain_about_assoc_type_not_found<I>("}, {"sha": "ba40f3c7db26842de3c2c89587705d0d0b42d7cd", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "patch": "@@ -669,6 +669,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise()),\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n+            true,\n         )\n     }\n \n@@ -765,7 +766,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let infer_args = trait_segment.infer_args;\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n-        self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n+        self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, false);\n \n         self.instantiate_poly_trait_ref_inner(\n             hir_id,\n@@ -822,9 +823,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &hir::PathSegment<'_>,\n+        is_impl: bool,\n     ) -> ty::TraitRef<'tcx> {\n-        let (substs, _) =\n-            self.create_substs_for_ast_trait_ref(span, trait_def_id, self_ty, trait_segment);\n+        let (substs, _) = self.create_substs_for_ast_trait_ref(\n+            span,\n+            trait_def_id,\n+            self_ty,\n+            trait_segment,\n+            is_impl,\n+        );\n         let assoc_bindings = self.create_assoc_bindings_for_generic_args(trait_segment.args());\n         if let Some(b) = assoc_bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -839,8 +846,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n+        is_impl: bool,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n-        self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n+        self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, is_impl);\n \n         self.create_substs_for_ast_path(\n             span,\n@@ -1932,7 +1940,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n-        let trait_ref = self.ast_path_to_mono_trait_ref(span, trait_def_id, self_ty, trait_segment);\n+        let trait_ref =\n+            self.ast_path_to_mono_trait_ref(span, trait_def_id, self_ty, trait_segment, false);\n \n         let item_substs = self.create_substs_for_associated_item(\n             tcx,"}, {"sha": "055818f55f0c8f6a84dd476db41bbca640a4f0b3", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "patch": "@@ -121,28 +121,6 @@ fn enforce_trait_manually_implementable(\n             return;\n         }\n     }\n-\n-    let trait_name = if did == li.fn_trait() {\n-        \"Fn\"\n-    } else if did == li.fn_mut_trait() {\n-        \"FnMut\"\n-    } else if did == li.fn_once_trait() {\n-        \"FnOnce\"\n-    } else {\n-        return; // everything OK\n-    };\n-\n-    let span = impl_header_span(tcx, impl_def_id);\n-    struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0183,\n-        \"manual implementations of `{}` are experimental\",\n-        trait_name\n-    )\n-    .span_label(span, format!(\"manual implementations of `{}` are experimental\", trait_name))\n-    .help(\"add `#![feature(unboxed_closures)]` to the crate attributes to enable\")\n-    .emit();\n }\n \n /// We allow impls of marker traits to overlap, so they can't override impls"}, {"sha": "f647380ef9bc4dd7182fb2638ac7ca8ad87abfca", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures-manual-impls.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr?ref=2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "patch": "@@ -38,11 +38,27 @@ error[E0658]: the precise format of `Fn`-family traits' type parameters is subje\n   --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:9:6\n    |\n LL | impl Fn<()> for Foo {\n-   |      ^^^^^^ help: use parenthetical notation instead: `Fn() -> ()`\n+   |      ^^^^^^\n    |\n    = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n+error[E0183]: manual implementations of `Fn` are experimental\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:9:6\n+   |\n+LL | impl Fn<()> for Foo {\n+   |      ^^^^^^ manual implementations of `Fn` are experimental\n+   |\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n+error[E0183]: manual implementations of `FnOnce` are experimental\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:16:6\n+   |\n+LL | impl FnOnce() for Foo1 {\n+   |      ^^^^^^^^ manual implementations of `FnOnce` are experimental\n+   |\n+   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n+\n error[E0229]: associated type bindings are not allowed here\n   --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:16:6\n    |\n@@ -53,49 +69,33 @@ error[E0658]: the precise format of `Fn`-family traits' type parameters is subje\n   --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:6\n    |\n LL | impl FnMut<()> for Bar {\n-   |      ^^^^^^^^^ help: use parenthetical notation instead: `FnMut() -> ()`\n-   |\n-   = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n-   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n-\n-error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:30:6\n-   |\n-LL | impl FnOnce<()> for Baz {\n-   |      ^^^^^^^^^^ help: use parenthetical notation instead: `FnOnce() -> ()`\n+   |      ^^^^^^^^^\n    |\n    = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-error[E0183]: manual implementations of `Fn` are experimental\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:9:1\n-   |\n-LL | impl Fn<()> for Foo {\n-   | ^^^^^^^^^^^^^^^^^^^ manual implementations of `Fn` are experimental\n-   |\n-   = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n-\n error[E0183]: manual implementations of `FnMut` are experimental\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:1\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:6\n    |\n LL | impl FnMut<()> for Bar {\n-   | ^^^^^^^^^^^^^^^^^^^^^^ manual implementations of `FnMut` are experimental\n+   |      ^^^^^^^^^ manual implementations of `FnMut` are experimental\n    |\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-error[E0183]: manual implementations of `FnOnce` are experimental\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:16:1\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:30:6\n    |\n-LL | impl FnOnce() for Foo1 {\n-   | ^^^^^^^^^^^^^^^^^^^^^^ manual implementations of `FnOnce` are experimental\n+LL | impl FnOnce<()> for Baz {\n+   |      ^^^^^^^^^^\n    |\n+   = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0183]: manual implementations of `FnOnce` are experimental\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:30:1\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:30:6\n    |\n LL | impl FnOnce<()> for Baz {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ manual implementations of `FnOnce` are experimental\n+   |      ^^^^^^^^^^ manual implementations of `FnOnce` are experimental\n    |\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n "}, {"sha": "a763c28de602b65931251f923dad642119057d14", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr?ref=2e0a80c8c0e4fb2fdbdcecfa21df22ad20521fd1", "patch": "@@ -11,16 +11,16 @@ error[E0658]: the precise format of `Fn`-family traits' type parameters is subje\n   --> $DIR/feature-gate-unboxed-closures.rs:5:6\n    |\n LL | impl FnOnce<(u32, u32)> for Test {\n-   |      ^^^^^^^^^^^^^^^^^^ help: use parenthetical notation instead: `FnOnce(u32, u32) -> ()`\n+   |      ^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #29625 <https://github.com/rust-lang/rust/issues/29625> for more information\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0183]: manual implementations of `FnOnce` are experimental\n-  --> $DIR/feature-gate-unboxed-closures.rs:5:1\n+  --> $DIR/feature-gate-unboxed-closures.rs:5:6\n    |\n LL | impl FnOnce<(u32, u32)> for Test {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ manual implementations of `FnOnce` are experimental\n+   |      ^^^^^^^^^^^^^^^^^^ manual implementations of `FnOnce` are experimental\n    |\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n "}]}