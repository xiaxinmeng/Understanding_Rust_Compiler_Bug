{"sha": "eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5", "node_id": "C_kwDOAAsO6NoAKGVlYjViNzgyYTYxM2IzN2MxM2JmZDM5NTg4YTNlM2FlNmRjZjBmZjU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-03-29T23:57:44Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-03-30T10:14:37Z"}, "message": "Improve the `rustc_data_structures::sync` module doc comment.\n\nAlso, `MTRef<'a, T>` is a typedef for a reference to a `T`, but in\npractice it's only used (and useful) in combination with `MTLock`, i.e.\n`MTRef<'a, MTLock<T>>`. So this commit changes it to be a typedef for a\nreference to an `MTLock<T>`, and renames it as `MTLockRef`. I think this\nclarifies things, because I found `MTRef` quite puzzling at first.", "tree": {"sha": "6183c6c463b1dc50e659670f8d01141ea9c6443e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6183c6c463b1dc50e659670f8d01141ea9c6443e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5", "html_url": "https://github.com/rust-lang/rust/commit/eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "478cbb42b730ba4739351b72ce2aa928e78e2f81", "url": "https://api.github.com/repos/rust-lang/rust/commits/478cbb42b730ba4739351b72ce2aa928e78e2f81", "html_url": "https://github.com/rust-lang/rust/commit/478cbb42b730ba4739351b72ce2aa928e78e2f81"}], "stats": {"total": 63, "additions": 44, "deletions": 19}, "files": [{"sha": "09765607cbd5472bfe90fb1c7c58e7b2f75e8434", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5", "patch": "@@ -1,21 +1,46 @@\n-//! This module defines types which are thread safe if cfg!(parallel_compiler) is true.\n+//! This module defines various operations and types that are implemented in\n+//! one way for the serial compiler, and another way the parallel compiler.\n //!\n-//! `Lrc` is an alias of `Arc` if cfg!(parallel_compiler) is true, `Rc` otherwise.\n+//! Operations\n+//! ----------\n+//! The parallel versions of operations use Rayon to execute code in parallel,\n+//! while the serial versions degenerate straightforwardly to serial execution.\n+//! The operations include `join`, `parallel`, `par_iter`, and `par_for_each`.\n //!\n-//! `Lock` is a mutex.\n-//! It internally uses `parking_lot::Mutex` if cfg!(parallel_compiler) is true,\n-//! `RefCell` otherwise.\n+//! `rustc_erase_owner!` erases an `OwningRef` owner into `Erased` for the\n+//! serial version and `Erased + Send + Sync` for the parallel version.\n //!\n-//! `RwLock` is a read-write lock.\n-//! It internally uses `parking_lot::RwLock` if cfg!(parallel_compiler) is true,\n-//! `RefCell` otherwise.\n+//! Types\n+//! -----\n+//! The parallel versions of types provide various kinds of synchronization,\n+//! while the serial compiler versions do not.\n //!\n-//! `MTLock` is a mutex which disappears if cfg!(parallel_compiler) is false.\n+//! The following table shows how the types are implemented internally. Except\n+//! where noted otherwise, the type in column one is defined as a\n+//! newtype around the type from column two or three.\n //!\n-//! `MTRef` is an immutable reference if cfg!(parallel_compiler), and a mutable reference otherwise.\n+//! | Type                    | Serial version      | Parallel version                |\n+//! | ----------------------- | ------------------- | ------------------------------- |\n+//! | `Lrc<T>`                | `rc::Rc<T>`         | `sync::Arc<T>`                  |\n+//! |` Weak<T>`               | `rc::Weak<T>`       | `sync::Weak<T>`                 |\n+//! |                         |                     |                                 |\n+//! | `AtomicBool`            | `Cell<bool>`        | `atomic::AtomicBool`            |\n+//! | `AtomicU32`             | `Cell<u32>`         | `atomic::AtomicU32`             |\n+//! | `AtomicU64`             | `Cell<u64>`         | `atomic::AtomicU64`             |\n+//! | `AtomicUsize`           | `Cell<usize>`       | `atomic::AtomicUsize`           |\n+//! |                         |                     |                                 |\n+//! | `Lock<T>`               | `RefCell<T>`        | `parking_lot::Mutex<T>`         |\n+//! | `RwLock<T>`             | `RefCell<T>`        | `parking_lot::RwLock<T>`        |\n+//! | `MTLock<T>`        [^1] | `T`                 | `Lock<T>`                       |\n+//! | `MTLockRef<'a, T>` [^2] | `&'a mut MTLock<T>` | `&'a MTLock<T>`                 |\n+//! |                         |                     |                                 |\n+//! | `ParallelIterator`      | `Iterator`          | `rayon::iter::ParallelIterator` |\n //!\n-//! `rustc_erase_owner!` erases an OwningRef owner into Erased or Erased + Send + Sync\n-//! depending on the value of cfg!(parallel_compiler).\n+//! [^1] `MTLock` is similar to `Lock`, but the serial version avoids the cost\n+//! of a `RefCell`. This is appropriate when interior mutability is not\n+//! required.\n+//!\n+//! [^2] `MTLockRef` is a typedef.\n \n use crate::owning_ref::{Erased, OwningRef};\n use std::collections::HashMap;\n@@ -209,7 +234,7 @@ cfg_if! {\n             }\n         }\n \n-        pub type MTRef<'a, T> = &'a mut T;\n+        pub type MTLockRef<'a, T> = &'a mut MTLock<T>;\n \n         #[derive(Debug, Default)]\n         pub struct MTLock<T>(T);\n@@ -267,7 +292,7 @@ cfg_if! {\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n \n-        pub type MTRef<'a, T> = &'a T;\n+        pub type MTLockRef<'a, T> = &'a MTLock<T>;\n \n         #[derive(Debug, Default)]\n         pub struct MTLock<T>(Lock<T>);"}, {"sha": "e24d31c43d377505be02c02786454680f48530db", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=eeb5b782a613b37c13bfd39588a3e3ae6dcf0ff5", "patch": "@@ -174,7 +174,7 @@\n //! regardless of whether it is actually needed or not.\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::{par_for_each_in, MTLock, MTRef};\n+use rustc_data_structures::sync::{par_for_each_in, MTLock, MTLockRef};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n@@ -340,8 +340,8 @@ pub fn collect_crate_mono_items(\n     let recursion_limit = tcx.recursion_limit();\n \n     {\n-        let visited: MTRef<'_, _> = &mut visited;\n-        let inlining_map: MTRef<'_, _> = &mut inlining_map;\n+        let visited: MTLockRef<'_, _> = &mut visited;\n+        let inlining_map: MTLockRef<'_, _> = &mut inlining_map;\n \n         tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_for_each_in(roots, |root| {\n@@ -406,10 +406,10 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n-    visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n+    visited: MTLockRef<'_, FxHashSet<MonoItem<'tcx>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n     recursion_limit: Limit,\n-    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n+    inlining_map: MTLockRef<'_, InliningMap<'tcx>>,\n ) {\n     if !visited.lock_mut().insert(starting_point.node) {\n         // We've been here already, no need to search again."}]}