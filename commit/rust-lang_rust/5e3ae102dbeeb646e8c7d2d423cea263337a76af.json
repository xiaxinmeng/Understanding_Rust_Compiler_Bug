{"sha": "5e3ae102dbeeb646e8c7d2d423cea263337a76af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlM2FlMTAyZGJlZWI2NDZlOGM3ZDJkNDIzY2VhMjYzMzM3YTc2YWY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-02-12T11:50:44Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-02-14T00:32:08Z"}, "message": "Dramatically expand the docs of std::raw.\n\nThis overhauls the very meager docs that currently exist to clarify\nvarious understandable confusions that I've noticed, e.g. people look in\n`std::raw` for the \"real\" types of slices like `&[T]`, or think that\n`Slice<T>` refers to `[T]` (fixes #22214).\n\nThis patch takes the liberty of offering some \"style\" guidance around\n`raw::Slice`, since there's more restricted ways to duplicate all\nfunctionality connected to it: `std::slice::from_raw_parts{,_mut}` for\nconstruction and `.as_{,mut_}ptr` & `.len` for deconstruction.\n\nIt also deprecates the `std::raw::Closure` type which is now useless for\nnon-type-erased closures, and replaced by `TraitObject` for `&Fn`, `&mut\nFnMut` etc, so I guess it should be called a:\n\n[breaking-change]", "tree": {"sha": "657bb3fde66dac9b988de7dfe983b6d653242620", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/657bb3fde66dac9b988de7dfe983b6d653242620"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e3ae102dbeeb646e8c7d2d423cea263337a76af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e3ae102dbeeb646e8c7d2d423cea263337a76af", "html_url": "https://github.com/rust-lang/rust/commit/5e3ae102dbeeb646e8c7d2d423cea263337a76af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e3ae102dbeeb646e8c7d2d423cea263337a76af/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fdca30fcb2303966ad2529b7a3b0599088c105d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fdca30fcb2303966ad2529b7a3b0599088c105d", "html_url": "https://github.com/rust-lang/rust/commit/0fdca30fcb2303966ad2529b7a3b0599088c105d"}], "stats": {"total": 113, "additions": 108, "deletions": 5}, "files": [{"sha": "81edfe7d6e268d43688e671d3827123bd40ace8b", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 108, "deletions": 5, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5e3ae102dbeeb646e8c7d2d423cea263337a76af/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e3ae102dbeeb646e8c7d2d423cea263337a76af/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=5e3ae102dbeeb646e8c7d2d423cea263337a76af", "patch": "@@ -21,7 +21,40 @@\n use marker::Copy;\n use mem;\n \n-/// The representation of a Rust slice\n+/// The representation of a slice like `&[T]`.\n+///\n+/// This struct is guaranteed to have the layout of types like `&[T]`,\n+/// `&str`, and `Box<[T]>`, but is not the type of such slices\n+/// (e.g. the fields are not directly accessible on a `&[T]`) nor does\n+/// it control that layout (changing the definition will not change\n+/// the layout of a `&[T]`). It is only designed to be used by unsafe\n+/// code that needs to manipulate the low-level details.\n+///\n+/// However, it is not recommended to use this type for such code,\n+/// since there are alternatives which may be safer:\n+///\n+/// - Creating a slice from a data pointer and length can be done with\n+///   `std::slice::from_raw_parts` or `std::slice::from_raw_parts_mut`\n+///   instead of `std::mem::transmute`ing a value of type `Slice`.\n+/// - Extracting the data pointer and length from a slice can be\n+///   performed with the `as_ptr` (or `as_mut_ptr`) and `len`\n+///   methods.\n+///\n+/// If one does decide to convert a slice value to a `Slice`, the\n+/// `Repr` trait in this module provides a method for a safe\n+/// conversion from `&[T]` (and `&str`) to a `Slice`, more type-safe\n+/// than a call to `transmute`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::raw::{self, Repr};\n+///\n+/// let slice: &[u16] = &[1, 2, 3, 4];\n+///\n+/// let repr: raw::Slice<u16> = slice.repr();\n+/// println!(\"data pointer = {:?}, length = {}\", repr.data, repr.len);\n+/// ```\n #[repr(C)]\n pub struct Slice<T> {\n     pub data: *const T,\n@@ -30,18 +63,88 @@ pub struct Slice<T> {\n \n impl<T> Copy for Slice<T> {}\n \n-/// The representation of a Rust closure\n+/// The representation of an old closure.\n #[repr(C)]\n #[derive(Copy)]\n+#[unstable(feature = \"core\")]\n+#[deprecated(reason = \"unboxed new closures do not have a universal representation; \\\n+                       `&Fn` (etc) trait objects should use `TraitObject` instead\",\n+             since= \"1.0.0\")]\n pub struct Closure {\n     pub code: *mut (),\n     pub env: *mut (),\n }\n \n-/// The representation of a Rust trait object.\n+/// The representation of a trait object like `&SomeTrait`.\n+///\n+/// This struct has the same layout as types like `&SomeTrait` and\n+/// `Box<AnotherTrait>`. The [Static and Dynamic Dispatch chapter of the\n+/// Book][moreinfo] contains more details about the precise nature of\n+/// these internals.\n+///\n+/// [moreinfo]: ../../book/static-and-dynamic-dispatch.html#representation\n+///\n+/// `TraitObject` is guaranteed to match layouts, but it is not the\n+/// type of trait objects (e.g. the fields are not directly accessible\n+/// on a `&SomeTrait`) nor does it control that layout (changing the\n+/// definition will not change the layout of a `&SometTrait`). It is\n+/// only designed to be used by unsafe code that needs to manipulate\n+/// the low-level details.\n+///\n+/// There is no `Repr` implementation for `TraitObject` because there\n+/// is no way to refer to all trait objects generically, so the only\n+/// way to create values of this type is with functions like\n+/// `std::mem::transmute`. Similarly, the only way to create a true\n+/// trait object from a `TraitObject` value is with `transmute`.\n+///\n+/// Synthesizing a trait object with mismatched types\u2014one where the\n+/// vtable does not correspond to the type of the value to which the\n+/// data pointer points\u2014is highly likely to lead to undefined\n+/// behaviour.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::raw;\n+///\n+/// // an example trait\n+/// trait Foo {\n+///     fn bar(&self) -> i32;\n+/// }\n+/// impl Foo for i32 {\n+///     fn bar(&self) -> i32 {\n+///          *self + 1\n+///     }\n+/// }\n+///\n+/// let value: i32 = 123;\n+///\n+/// // let the compiler make a trait object\n+/// let object: &Foo = &value;\n+///\n+/// // look at the raw representation\n+/// let raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n+///\n+/// // the data pointer is the address of `value`\n+/// assert_eq!(raw_object.data as *const i32, &value as *const _);\n+///\n+///\n+/// let other_value: i32 = 456;\n+///\n+/// // construct a new object, pointing to a different `i32`, being\n+/// // careful to use the `i32` vtable from `object`\n+/// let synthesized: &Foo = unsafe {\n+///      mem::transmute(raw::TraitObject {\n+///          data: &other_value as *const _ as *mut (),\n+///          vtable: raw_object.vtable\n+///      })\n+/// };\n ///\n-/// This struct does not have a `Repr` implementation\n-/// because there is no way to refer to all trait objects generically.\n+/// // it should work just like we constructed a trait object out of\n+/// // `other_value` directly\n+/// assert_eq!(synthesized.bar(), 457);\n+/// ```\n #[repr(C)]\n #[derive(Copy)]\n pub struct TraitObject {"}]}