{"sha": "8d6fdaa024138de464a74ebd5307c706c68a3eef", "node_id": "C_kwDOAAsO6NoAKDhkNmZkYWEwMjQxMzhkZTQ2NGE3NGViZDUzMDdjNzA2YzY4YTNlZWY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-24T22:02:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-24T22:03:02Z"}, "message": "make the tests pass\n\n(and some formatting)", "tree": {"sha": "ba287bee094fd8ad16b04a763d1d756a264061fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba287bee094fd8ad16b04a763d1d756a264061fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d6fdaa024138de464a74ebd5307c706c68a3eef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6fdaa024138de464a74ebd5307c706c68a3eef", "html_url": "https://github.com/rust-lang/rust/commit/8d6fdaa024138de464a74ebd5307c706c68a3eef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d6fdaa024138de464a74ebd5307c706c68a3eef/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0f7118342ccf77330c92d50222f90856730254b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0f7118342ccf77330c92d50222f90856730254b", "html_url": "https://github.com/rust-lang/rust/commit/c0f7118342ccf77330c92d50222f90856730254b"}], "stats": {"total": 361, "additions": 201, "deletions": 160}, "files": [{"sha": "f6b2413c65f594d04bf7faf8d6c8d7156b7be586", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d6fdaa024138de464a74ebd5307c706c68a3eef/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d6fdaa024138de464a74ebd5307c706c68a3eef/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8d6fdaa024138de464a74ebd5307c706c68a3eef", "patch": "@@ -358,9 +358,7 @@ to Miri failing to detect cases of undefined behavior in a program.\n   for pointer-to-int and int-to-pointer casts, respectively. This will\n   necessarily miss some bugs as those semantics are not efficiently\n   implementable in a sanitizer, but it will only miss bugs that concerns\n-  memory/pointers which is subject to these operations. Also note that this flag\n-  is currently incompatible with Stacked Borrows, so you will have to also pass\n-  `-Zmiri-disable-stacked-borrows` to use this.\n+  memory/pointers which is subject to these operations.\n * `-Zmiri-symbolic-alignment-check` makes the alignment check more strict.  By\n   default, alignment is checked by casting the pointer to an integer, and making\n   sure that is a multiple of the alignment.  This can lead to cases where a"}, {"sha": "9ec96b8f491e20bcca64c14e050b681bc5eb2943", "filename": "src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d6fdaa024138de464a74ebd5307c706c68a3eef/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6fdaa024138de464a74ebd5307c706c68a3eef/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=8d6fdaa024138de464a74ebd5307c706c68a3eef", "patch": "@@ -102,12 +102,11 @@ impl<'mir, 'tcx> GlobalStateInner {\n     }\n \n     pub fn expose_ptr(ecx: &mut MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId, sb: SbTag) {\n-        trace!(\"Exposing allocation id {:?}\", alloc_id);\n-\n         let global_state = ecx.machine.intptrcast.get_mut();\n         // In legacy and strict mode, we don't need this, so we can save some cycles\n         // by not tracking it.\n         if global_state.provenance_mode == ProvenanceMode::Permissive {\n+            trace!(\"Exposing allocation id {alloc_id:?}\");\n             global_state.exposed.insert(alloc_id);\n             if ecx.machine.stacked_borrows.is_some() {\n                 ecx.expose_tag(alloc_id, sb);"}, {"sha": "432f469733cbef2dccab7f607b9ceb3ec301c8f6", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d6fdaa024138de464a74ebd5307c706c68a3eef/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6fdaa024138de464a74ebd5307c706c68a3eef/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8d6fdaa024138de464a74ebd5307c706c68a3eef", "patch": "@@ -6,6 +6,7 @@\n #![feature(let_else)]\n #![feature(io_error_more)]\n #![feature(yeet_expr)]\n+#![feature(is_some_with)]\n #![warn(rust_2018_idioms)]\n #![allow(\n     clippy::collapsible_else_if,"}, {"sha": "8411d85f0e01962479544085caa4657b06180830", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 122, "deletions": 101, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/8d6fdaa024138de464a74ebd5307c706c68a3eef/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6fdaa024138de464a74ebd5307c706c68a3eef/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=8d6fdaa024138de464a74ebd5307c706c68a3eef", "patch": "@@ -104,9 +104,10 @@ pub struct Stack {\n     /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n     /// * Except for `Untagged`, no tag occurs in the stack more than once.\n     borrows: Vec<Item>,\n-    /// If this is `Some(id)`, then the actual current stack is unknown. What we do know\n-    /// is that `borrows` are at the top of the stack, and below it are arbitrarily many items\n-    /// whose `tag` is either `Untagged` or strictly less than `id`.\n+    /// If this is `Some(id)`, then the actual current stack is unknown. THis can happen when\n+    /// wildcard pointers are used to access this location. What we do know is that `borrows` are at\n+    /// the top of the stack, and below it are arbitrarily many items whose `tag` is either\n+    /// `Untagged` or strictly less than `id`.\n     unknown_bottom: Option<PtrId>,\n }\n \n@@ -289,72 +290,72 @@ impl Permission {\n impl<'tcx> Stack {\n     /// Find the item granting the given kind of access to the given tag, and return where\n     /// it is on the stack.\n-    // TODO: Doc ok with Some(index) or None if unknown_bottom used\n-    // Err if does not match\n+    /// `Ok(None)` indicates it matched the \"unknown\" part of the stack, or it was a wildcard tag\n+    /// and we have no clue what exactly it matched (but it could have matched something)\n+    /// `Err` indicates it was not found.\n     fn find_granting(\n         &self,\n         access: AccessKind,\n         tag: Option<SbTag>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> Result<Option<usize>, ()> {\n-        let res = self\n-            .borrows\n-            .iter()\n-            .enumerate() // we also need to know *where* in the stack\n-            .rev() // search top-to-bottom\n-            // Return permission of first item that grants access.\n-            // We require a permission with the right tag, ensuring U3 and F3.\n-            .find_map(|(idx, item)| {\n-                match tag {\n-                    Some(tag) if tag == item.tag && item.perm.grants(access) => Some(idx),\n-                    None if exposed_tags.contains(&item.tag) => Some(idx),\n-                    _ => None,\n-                }\n-            });\n+        let Some(tag) = tag else {\n+            // Handle the wildcard case.\n+            // Go search the stack for an exposed tag.\n+            let maybe_in_stack = self\n+                .borrows\n+                .iter()\n+                .rev() // search top-to-bottom\n+                .find_map(|item| {\n+                    // If the item fits and *might* be this wildcard, use it.\n+                    if item.perm.grants(access) && exposed_tags.contains(&item.tag) {\n+                        Some(())\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .is_some();\n+            // If we couldn't find it in the stack, check the unknown bottom.\n+            let found = maybe_in_stack || self.unknown_bottom.is_some();\n+            return if found { Ok(None) } else { Err(()) };\n+        };\n \n-        if res.is_some() {\n-            return Ok(res);\n+        if let Some(idx) =\n+            self.borrows\n+                .iter()\n+                .enumerate() // we also need to know *where* in the stack\n+                .rev() // search top-to-bottom\n+                // Return permission of first item that grants access.\n+                // We require a permission with the right tag, ensuring U3 and F3.\n+                .find_map(|(idx, item)| {\n+                    if tag == item.tag && item.perm.grants(access) { Some(idx) } else { None }\n+                })\n+        {\n+            return Ok(Some(idx));\n         }\n \n-        match self.unknown_bottom {\n-            Some(id) =>\n-                match tag {\n-                    Some(tag) =>\n-                        match tag {\n-                            SbTag::Tagged(tag_id) if tag_id < id => Ok(None),\n-                            SbTag::Untagged => Ok(None),\n-                            _ => Err(()),\n-                        },\n-                    None => Ok(None),\n-                },\n-            None => Err(()),\n-        }\n+        // Couldn't find it in the stack; but if there is an unknown bottom it might be there.\n+        let found = self.unknown_bottom.is_some_and(|&unknown_limit| {\n+            match tag {\n+                SbTag::Tagged(tag_id) => tag_id < unknown_limit, // unknown_limit is an upper bound for what can be in the unknown bottom.\n+                SbTag::Untagged => true,                         // yeah whatever\n+            }\n+        });\n+        if found { Ok(None) } else { Err(()) }\n     }\n \n     /// Find the first write-incompatible item above the given one --\n     /// i.e, find the height to which the stack will be truncated when writing to `granting`.\n-    fn find_first_write_incompatible(&self, granting: Option<usize>) -> usize {\n-        let perm = if let Some(idx) = granting {\n-            self.borrows[idx].perm\n-        } else {\n-            // I assume this has to be it?\n-            Permission::SharedReadWrite\n-        };\n-\n+    fn find_first_write_incompatible(&self, granting: usize) -> usize {\n+        let perm = self.borrows[granting].perm;\n         match perm {\n             Permission::SharedReadOnly => bug!(\"Cannot use SharedReadOnly for writing\"),\n             Permission::Disabled => bug!(\"Cannot use Disabled for anything\"),\n             // On a write, everything above us is incompatible.\n-            Permission::Unique =>\n-                if let Some(idx) = granting {\n-                    idx + 1\n-                } else {\n-                    0\n-                },\n+            Permission::Unique => granting + 1,\n             Permission::SharedReadWrite => {\n                 // The SharedReadWrite *just* above us are compatible, to skip those.\n-                let mut idx = if let Some(idx) = granting { idx + 1 } else { 0 };\n-\n+                let mut idx = granting + 1;\n                 while let Some(item) = self.borrows.get(idx) {\n                     if item.perm == Permission::SharedReadWrite {\n                         // Go on.\n@@ -440,52 +441,57 @@ impl<'tcx> Stack {\n             alloc_history.access_error(access, tag, alloc_id, alloc_range, offset, self)\n         })?;\n \n+        let Some(granting_idx) = granting_idx else {\n+            // The access used a wildcard pointer or matched the unknown bottom.\n+            // Nobody knows what happened, so forget everything.\n+            trace!(\"access: clearing stack due to wildcard\");\n+            self.borrows.clear();\n+            self.unknown_bottom = Some(global.next_ptr_id);\n+            return Ok(());\n+        };\n+        let tag = tag.unwrap(); // only precise tags have precise locations\n+\n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n-        if let Some(tag) = tag {\n-            if access == AccessKind::Write {\n-                // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n-                // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n-                let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n-                for item in self.borrows.drain(first_incompatible_idx..).rev() {\n-                    trace!(\"access: popping item {:?}\", item);\n+        if access == AccessKind::Write {\n+            // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n+            // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n+            let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n+            for item in self.borrows.drain(first_incompatible_idx..).rev() {\n+                trace!(\"access: popping item {:?}\", item);\n+                Stack::check_protector(\n+                    &item,\n+                    Some((tag, alloc_range, offset, access)),\n+                    global,\n+                    alloc_history,\n+                )?;\n+                alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n+            }\n+        } else {\n+            // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n+            // The reason this is not following the stack discipline (by removing the first Unique and\n+            // everything on top of it) is that in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n+            // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n+            // `SharedReadWrite` for `raw`.\n+            // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n+            // reference and use that.\n+            // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n+            let first_incompatible_idx = granting_idx + 1;\n+            for idx in (first_incompatible_idx..self.borrows.len()).rev() {\n+                let item = &mut self.borrows[idx];\n+\n+                if item.perm == Permission::Unique {\n+                    trace!(\"access: disabling item {:?}\", item);\n                     Stack::check_protector(\n-                        &item,\n+                        item,\n                         Some((tag, alloc_range, offset, access)),\n                         global,\n                         alloc_history,\n                     )?;\n+                    item.perm = Permission::Disabled;\n                     alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n                 }\n-            } else {\n-                let start_idx = if let Some(idx) = granting_idx { idx + 1 } else { 0 };\n-                // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n-                // The reason this is not following the stack discipline (by removing the first Unique and\n-                // everything on top of it) is that in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n-                // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n-                // `SharedReadWrite` for `raw`.\n-                // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n-                // reference and use that.\n-                // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n-                for idx in (start_idx..self.borrows.len()).rev() {\n-                    let item = &mut self.borrows[idx];\n-\n-                    if item.perm == Permission::Unique {\n-                        trace!(\"access: disabling item {:?}\", item);\n-                        Stack::check_protector(\n-                            item,\n-                            Some((tag, alloc_range, offset, access)),\n-                            global,\n-                            alloc_history,\n-                        )?;\n-                        item.perm = Permission::Disabled;\n-                        alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n-                    }\n-                }\n             }\n-        } else {\n-            self.borrows.clear();\n-            self.unknown_bottom = Some(global.next_ptr_id);\n         }\n \n         // Done.\n@@ -502,7 +508,7 @@ impl<'tcx> Stack {\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n-        // Step 1: Find granting item.\n+        // Step 1: Make sure there is a granting item.\n         self.find_granting(AccessKind::Write, tag, exposed_tags).map_err(|_| {\n             err_sb_ub(format!(\n                 \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n@@ -556,17 +562,20 @@ impl<'tcx> Stack {\n                 \"this case only makes sense for stack-like accesses\"\n             );\n \n-            if derived_from.is_some() {\n-                // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n-                // access.  Instead of popping the stack, we insert the item at the place the stack would\n-                // be popped to (i.e., we insert it above all the write-compatible items).\n-                // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n-                self.find_first_write_incompatible(granting_idx)\n-            } else {\n-                // TODO: is this correct\n+            let Some(granting_idx) = granting_idx else {\n+                // The parent is a wildcard pointer or matched the unknown bottom.\n+                // Nobody knows what happened, so forget everything.\n+                trace!(\"reborrow: clearing stack due to wildcard\");\n                 self.borrows.clear();\n-                0\n-            }\n+                self.unknown_bottom = Some(global.next_ptr_id);\n+                return Ok(());\n+            };\n+\n+            // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n+            // access.  Instead of popping the stack, we insert the item at the place the stack would\n+            // be popped to (i.e., we insert it above all the write-compatible items).\n+            // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n+            self.find_first_write_incompatible(granting_idx)\n         } else {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n@@ -587,9 +596,11 @@ impl<'tcx> Stack {\n             // This ensures U1 and F1.\n             self.borrows.len()\n         };\n+\n         // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n+        // `new_idx` might be 0 if we just cleared the entire stack.\n         if self.borrows.get(new_idx) == Some(&new)\n-            || new_idx > 0 && self.borrows.get(new_idx - 1) == Some(&new)\n+            || (new_idx > 0 && self.borrows[new_idx - 1] == new)\n         {\n             // Optimization applies, done.\n             trace!(\"reborrow: avoiding adding redundant item {:?}\", new);\n@@ -648,7 +659,7 @@ impl<'tcx> Stacks {\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let stacks = self.stacks.get_mut();\n-        let history = &mut *self.history.borrow_mut();\n+        let history = &mut *self.history.get_mut();\n         let exposed_tags = self.exposed_tags.get_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n             f(offset, stack, history, exposed_tags)?;\n@@ -1083,10 +1094,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Function pointers and dead objects don't have an alloc_extra so we ignore them.\n         // This is okay because accessing them is UB anyway, no need for any Stacked Borrows checks.\n+        // NOT using `get_alloc_extra_mut` since this might be a read-only allocation!\n         // FIXME: this catches `InterpError`, which we should not usually do.\n         // We might need a proper fallible API from `memory.rs` to avoid this though.\n-        if let Ok((alloc_extra, _)) = this.get_alloc_extra_mut(alloc_id) {\n-            alloc_extra.stacked_borrows.as_mut().unwrap().exposed_tags.get_mut().insert(tag);\n+        match this.get_alloc_extra(alloc_id) {\n+            Ok(alloc_extra) => {\n+                trace!(\"Stacked Borrows tag {tag:?} exposed in {alloc_id}\");\n+                alloc_extra.stacked_borrows.as_ref().unwrap().exposed_tags.borrow_mut().insert(tag);\n+            }\n+            Err(err) => {\n+                trace!(\n+                    \"Not exposing Stacked Borrows tag {tag:?} due to error \\\n+                    when accessing {alloc_id}: {err}\"\n+                );\n+            }\n         }\n     }\n }"}, {"sha": "9b4234499df044644b74922305db7b662c874759", "filename": "tests/fail/stacked_borrows/exposed_only_ro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d6fdaa024138de464a74ebd5307c706c68a3eef/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6fdaa024138de464a74ebd5307c706c68a3eef/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.rs?ref=8d6fdaa024138de464a74ebd5307c706c68a3eef", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let _fool = &mut x as *mut i32; // this would have fooled the old untagged pointer logic\n     let addr = (&x as *const i32).expose_addr();\n     let ptr = std::ptr::from_exposed_addr_mut::<i32>(addr);\n-    unsafe { ptr.write(0) }; //~ ERROR: borrow stack\n+    unsafe { *ptr = 0 }; //~ ERROR: borrow stack\n }"}, {"sha": "9748fe78c718473672a36026c93a53fb4491e8d6", "filename": "tests/fail/stacked_borrows/exposed_only_ro.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d6fdaa024138de464a74ebd5307c706c68a3eef/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d6fdaa024138de464a74ebd5307c706c68a3eef/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr?ref=8d6fdaa024138de464a74ebd5307c706c68a3eef", "patch": "@@ -0,0 +1,18 @@\n+error: Undefined Behavior: attempting a write access using \"<wildcard>\" at ALLOC[0x0], but no exposed tags are valid in the borrow stack for this location\n+  --> $DIR/exposed_only_ro.rs:LL:CC\n+   |\n+LL |     unsafe { *ptr = 0 };\n+   |              ^^^^^^^^\n+   |              |\n+   |              attempting a write access using \"<wildcard>\" at ALLOC[0x0], but no exposed tags are valid in the borrow stack for this location\n+   |              this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+           \n+   = note: inside `main` at $DIR/exposed_only_ro.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "dc3675406276fd0547cb5954724f4f17457d6f1c", "filename": "tests/pass/stacked-borrows/int-to-ptr.rs", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8d6fdaa024138de464a74ebd5307c706c68a3eef/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6fdaa024138de464a74ebd5307c706c68a3eef/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs?ref=8d6fdaa024138de464a74ebd5307c706c68a3eef", "patch": "@@ -13,63 +13,67 @@ fn ref_raw_int_raw() {\n }\n \n /// Ensure that we do not just pick the topmost possible item on int2ptr casts.\n-fn example(variant: bool) { unsafe {\n-    fn not_so_innocent(x: &mut u32) -> usize {\n-        let x_raw4 = x as *mut u32;\n-        x_raw4.expose_addr()\n-    }\n+fn example(variant: bool) {\n+    unsafe {\n+        fn not_so_innocent(x: &mut u32) -> usize {\n+            let x_raw4 = x as *mut u32;\n+            x_raw4.expose_addr()\n+        }\n+\n+        let mut c = 42u32;\n+\n+        let x_unique1 = &mut c;\n+        // [..., Unique(1)]\n+\n+        let x_raw2 = x_unique1 as *mut u32;\n+        let x_raw2_addr = x_raw2.expose_addr();\n+        // [..., Unique(1), SharedRW(2)]\n+\n+        let x_unique3 = &mut *x_raw2;\n+        // [.., Unique(1), SharedRW(2), Unique(3)]\n \n-    let mut c = 42u32;\n+        assert_eq!(not_so_innocent(x_unique3), x_raw2_addr);\n+        // [.., Unique(1), SharedRW(2), Unique(3), ..., SharedRW(4)]\n \n-    let x_unique1 = &mut c;\n-    // [..., Unique(1)]\n-    \n-    let x_raw2 = x_unique1 as *mut u32;\n-    let x_raw2_addr = x_raw2.expose_addr();\n-    // [..., Unique(1), SharedRW(2)]\n-    \n-    let x_unique3 = &mut *x_raw2;\n-    // [.., Unique(1), SharedRW(2), Unique(3)]\n-    \n-    assert_eq!(not_so_innocent(x_unique3), x_raw2_addr);\n-    // [.., Unique(1), SharedRW(2), Unique(3), ..., SharedRW(4)]\n-    \n-    // Do an int2ptr cast. This can pick tag 2 or 4 (the two previously exposed tags).\n-    // 4 is the \"obvious\" choice (topmost tag, what we used to do with untagged pointers).\n-    // And indeed if `variant == true` it is the only possible choice.\n-    // But if `variant == false` then 2 is the only possible choice!\n-    let x_wildcard = ptr::from_exposed_addr_mut::<i32>(x_raw2_addr);\n-    \n-    if variant {\n-        // If we picked 2, this will invalidate 3.\n-        *x_wildcard = 10;\n-        // Now we use 3. Only possible if above we picked 4.\n-        *x_unique3 = 12;\n-    } else {\n-        // This invalidates tag 4.\n-        *x_unique3 = 10;\n-        // Now try to write with the \"guessed\" tag; it must be 2.\n-        *x_wildcard = 12;\n+        // Do an int2ptr cast. This can pick tag 2 or 4 (the two previously exposed tags).\n+        // 4 is the \"obvious\" choice (topmost tag, what we used to do with untagged pointers).\n+        // And indeed if `variant == true` it is the only possible choice.\n+        // But if `variant == false` then 2 is the only possible choice!\n+        let x_wildcard = ptr::from_exposed_addr_mut::<i32>(x_raw2_addr);\n+\n+        if variant {\n+            // If we picked 2, this will invalidate 3.\n+            *x_wildcard = 10;\n+            // Now we use 3. Only possible if above we picked 4.\n+            *x_unique3 = 12;\n+        } else {\n+            // This invalidates tag 4.\n+            *x_unique3 = 10;\n+            // Now try to write with the \"guessed\" tag; it must be 2.\n+            *x_wildcard = 12;\n+        }\n     }\n-} }\n+}\n \n-fn test() { unsafe {\n-    let root = &mut 42;\n-    let root_raw = root as *mut i32;\n-    let addr1 = root_raw as usize;\n-    let child = &mut *root_raw;\n-    let child_raw = child as *mut i32;\n-    let addr2 = child_raw as usize;\n-    assert_eq!(addr1, addr2);\n-    // First use child.\n-    *(addr2 as *mut i32) -= 2; // picks child_raw\n-    *child -= 2;\n-    // Then use root.\n-    *(addr1 as *mut i32) += 2; // picks root_raw\n-    *root += 2;\n-    // Value should be unchanged.\n-    assert_eq!(*root, 42);\n-} }\n+fn test() {\n+    unsafe {\n+        let root = &mut 42;\n+        let root_raw = root as *mut i32;\n+        let addr1 = root_raw as usize;\n+        let child = &mut *root_raw;\n+        let child_raw = child as *mut i32;\n+        let addr2 = child_raw as usize;\n+        assert_eq!(addr1, addr2);\n+        // First use child.\n+        *(addr2 as *mut i32) -= 2; // picks child_raw\n+        *child -= 2;\n+        // Then use root.\n+        *(addr1 as *mut i32) += 2; // picks root_raw\n+        *root += 2;\n+        // Value should be unchanged.\n+        assert_eq!(*root, 42);\n+    }\n+}\n \n fn main() {\n     ref_raw_int_raw();"}]}