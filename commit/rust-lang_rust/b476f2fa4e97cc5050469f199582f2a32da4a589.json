{"sha": "b476f2fa4e97cc5050469f199582f2a32da4a589", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NzZmMmZhNGU5N2NjNTA1MDQ2OWYxOTk1ODJmMmEzMmRhNGE1ODk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-06T13:42:14Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-14T15:05:45Z"}, "message": "rustc_metadata: Use `CrateSource` where appropriate", "tree": {"sha": "cef13d75c67c6a900ec9ad9a27735d9424f05960", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cef13d75c67c6a900ec9ad9a27735d9424f05960"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b476f2fa4e97cc5050469f199582f2a32da4a589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b476f2fa4e97cc5050469f199582f2a32da4a589", "html_url": "https://github.com/rust-lang/rust/commit/b476f2fa4e97cc5050469f199582f2a32da4a589", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b476f2fa4e97cc5050469f199582f2a32da4a589/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8c28e24b99f9da9bf797848902ab7763da54c5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c28e24b99f9da9bf797848902ab7763da54c5b", "html_url": "https://github.com/rust-lang/rust/commit/e8c28e24b99f9da9bf797848902ab7763da54c5b"}], "stats": {"total": 110, "additions": 43, "deletions": 67}, "files": [{"sha": "1706d3120fb6676d9b69470101bcd20f28bb545b", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b476f2fa4e97cc5050469f199582f2a32da4a589/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b476f2fa4e97cc5050469f199582f2a32da4a589/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b476f2fa4e97cc5050469f199582f2a32da4a589", "patch": "@@ -32,6 +32,12 @@ pub struct CrateSource {\n     pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n+impl CrateSource {\n+    pub fn paths(&self) -> impl Iterator<Item = &PathBuf> {\n+        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).map(|p| &p.0)\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Copy, Clone,\n          Ord, PartialOrd, Eq, PartialEq, Debug, HashStable)]\n pub enum DepKind {"}, {"sha": "438d42cf752849cfce70f9830179fa4ce92eadde", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b476f2fa4e97cc5050469f199582f2a32da4a589/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b476f2fa4e97cc5050469f199582f2a32da4a589/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=b476f2fa4e97cc5050469f199582f2a32da4a589", "patch": "@@ -34,9 +34,7 @@ use log::{debug, info, log_enabled};\n use proc_macro::bridge::client::ProcMacro;\n \n crate struct Library {\n-    pub dylib: Option<(PathBuf, PathKind)>,\n-    pub rlib: Option<(PathBuf, PathKind)>,\n-    pub rmeta: Option<(PathBuf, PathKind)>,\n+    pub source: CrateSource,\n     pub metadata: MetadataBlob,\n }\n \n@@ -197,10 +195,10 @@ impl<'a> CrateLoader<'a> {\n         dep_kind: DepKind,\n         name: Symbol\n     ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n-        let _prof_timer =\n-            self.sess.prof.generic_activity(\"metadata_register_crate\");\n+        let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n \n-        let crate_root = lib.metadata.get_root();\n+        let Library { source, metadata } = lib;\n+        let crate_root = metadata.get_root();\n         self.verify_no_symbol_conflicts(span, &crate_root);\n \n         let private_dep = self.sess.opts.externs.get(&name.as_str())\n@@ -218,28 +216,22 @@ impl<'a> CrateLoader<'a> {\n         let root = if let Some(root) = root {\n             root\n         } else {\n-            crate_paths = CratePaths {\n-                ident: crate_root.name.to_string(),\n-                dylib: lib.dylib.clone().map(|p| p.0),\n-                rlib:  lib.rlib.clone().map(|p| p.0),\n-                rmeta: lib.rmeta.clone().map(|p| p.0),\n-            };\n+            crate_paths = CratePaths { name: crate_root.name, source: source.clone() };\n             &crate_paths\n         };\n \n-        let Library { dylib, rlib, rmeta, metadata } = lib;\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n         let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n             let temp_root;\n-            let (dlsym_dylib, dlsym_root) = match &host_lib {\n+            let (dlsym_source, dlsym_root) = match &host_lib {\n                 Some(host_lib) =>\n-                    (&host_lib.dylib, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n-                None => (&dylib, &crate_root),\n+                    (&host_lib.source, { temp_root = host_lib.metadata.get_root(); &temp_root }),\n+                None => (&source, &crate_root),\n             };\n-            let dlsym_dylib = dlsym_dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n+            let dlsym_dylib = dlsym_source.dylib.as_ref().expect(\"no dylib for a proc-macro crate\");\n             self.dlsym_proc_macros(&dlsym_dylib.0, dlsym_root.disambiguator, span)\n         });\n \n@@ -268,11 +260,7 @@ impl<'a> CrateLoader<'a> {\n             source_map_import_info: RwLock::new(vec![]),\n             alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n             dep_kind: Lock::new(dep_kind),\n-            source: CrateSource {\n-                dylib,\n-                rlib,\n-                rmeta,\n-            },\n+            source,\n             private_dep,\n             raw_proc_macros,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n@@ -558,7 +546,7 @@ impl<'a> CrateLoader<'a> {\n                 (data.source.dylib.clone(), PMDSource::Registered(data))\n             }\n             LoadResult::Loaded(library) => {\n-                let dylib = library.dylib.clone();\n+                let dylib = library.source.dylib.clone();\n                 let metadata = PMDSource::Owned(library);\n                 (dylib, metadata)\n             }"}, {"sha": "05676dad3340c7553772ea73f362222ced55f033", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b476f2fa4e97cc5050469f199582f2a32da4a589/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b476f2fa4e97cc5050469f199582f2a32da4a589/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=b476f2fa4e97cc5050469f199582f2a32da4a589", "patch": "@@ -219,7 +219,7 @@ use crate::schema::{METADATA_HEADER, rustc_version};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc::middle::cstore::MetadataLoader;\n+use rustc::middle::cstore::{CrateSource, MetadataLoader};\n use rustc::session::{config, Session};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n@@ -274,10 +274,8 @@ crate struct Context<'a> {\n }\n \n crate struct CratePaths {\n-    pub ident: String,\n-    pub dylib: Option<PathBuf>,\n-    pub rlib: Option<PathBuf>,\n-    pub rmeta: Option<PathBuf>,\n+    pub name: Symbol,\n+    pub source: CrateSource,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -297,12 +295,6 @@ impl fmt::Display for CrateFlavor {\n     }\n }\n \n-impl CratePaths {\n-    fn paths(&self) -> Vec<PathBuf> {\n-        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).cloned().collect()\n-    }\n-}\n-\n impl<'a> Context<'a> {\n     crate fn reset(&mut self) {\n         self.rejected_via_hash.clear();\n@@ -324,7 +316,7 @@ impl<'a> Context<'a> {\n     crate fn report_errs(self) -> ! {\n         let add = match self.root {\n             None => String::new(),\n-            Some(r) => format!(\" which `{}` depends on\", r.ident),\n+            Some(r) => format!(\" which `{}` depends on\", r.name),\n         };\n         let mut msg = \"the following crate versions were found:\".to_string();\n         let mut err = if !self.rejected_via_hash.is_empty() {\n@@ -342,8 +334,8 @@ impl<'a> Context<'a> {\n             match self.root {\n                 None => {}\n                 Some(r) => {\n-                    for path in r.paths().iter() {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.ident, path.display()));\n+                    for path in r.source.paths() {\n+                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n                     }\n                 }\n             }\n@@ -535,18 +527,8 @@ impl<'a> Context<'a> {\n         // search is being performed for.\n         let mut libraries = FxHashMap::default();\n         for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n-            let mut slot = None;\n-            let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n-            let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n-            let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n-            if let Some((h, m)) = slot {\n-                libraries.insert(h,\n-                                 Library {\n-                                     dylib,\n-                                     rlib,\n-                                     rmeta,\n-                                     metadata: m,\n-                                 });\n+            if let Some((svh, lib)) = self.extract_lib(rlibs, rmetas, dylibs) {\n+                libraries.insert(svh, lib);\n             }\n         }\n \n@@ -564,7 +546,7 @@ impl<'a> Context<'a> {\n                                                self.crate_name);\n                 let candidates = libraries.iter().filter_map(|(_, lib)| {\n                     let crate_name = &lib.metadata.get_root().name.as_str();\n-                    match &(&lib.dylib, &lib.rlib) {\n+                    match &(&lib.source.dylib, &lib.source.rlib) {\n                         &(&Some((ref pd, _)), &Some((ref pr, _))) => {\n                             Some(format!(\"\\ncrate `{}`: {}\\n{:>padding$}\",\n                                          crate_name,\n@@ -585,6 +567,21 @@ impl<'a> Context<'a> {\n         }\n     }\n \n+    fn extract_lib(\n+        &mut self,\n+        rlibs: FxHashMap<PathBuf, PathKind>,\n+        rmetas: FxHashMap<PathBuf, PathKind>,\n+        dylibs: FxHashMap<PathBuf, PathKind>,\n+    ) -> Option<(Svh, Library)> {\n+        let mut slot = None;\n+        let source = CrateSource {\n+            rlib: self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot),\n+            rmeta: self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot),\n+            dylib: self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot),\n+        };\n+        slot.map(|(svh, metadata)| (svh, Library { source, metadata }))\n+    }\n+\n     // Attempts to extract *one* library from the set `m`. If the set has no\n     // elements, `None` is returned. If the set has more than one element, then\n     // the errors and notes are emitted about the set of libraries.\n@@ -829,23 +826,8 @@ impl<'a> Context<'a> {\n             }\n         };\n \n-        // Extract the rlib/dylib pair.\n-        let mut slot = None;\n-        let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n-        let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n-        let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n-\n-        if rlib.is_none() && rmeta.is_none() && dylib.is_none() {\n-            return None;\n-        }\n-        slot.map(|(_, metadata)|\n-            Library {\n-                dylib,\n-                rlib,\n-                rmeta,\n-                metadata,\n-            }\n-        )\n+        // Extract the dylib/rlib/rmeta triple.\n+        self.extract_lib(rlibs, rmetas, dylibs).map(|(_, lib)| lib)\n     }\n }\n "}]}