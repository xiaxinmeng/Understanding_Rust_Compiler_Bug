{"sha": "76ff835ca0b6669b185e6a4aeedc144432db91f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZmY4MzVjYTBiNjY2OWIxODVlNmE0YWVlZGMxNDQ0MzJkYjkxZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-05T07:14:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-05T07:14:47Z"}, "message": "Auto merge of #27503 - c-nixon:master, r=steveklabnik\n\nI was reading through the docs and came across a section that felt awkward.\r\n\r\nI've tried to improve the flow by splitting up and reversing the explanations of\r\nArc and Mutex with some example code in between.\r\n\r\nThe \"This would have have happened\" bit is unfortunate but I couldn't see any\r\nother way to illustrate it. The compiler errors didn't really help tell the\r\nstory in this particular instance so it still feels a bit forced. However I do think it's\r\nan a small improvement...\r\n\r\nDoes anyone have any other ideas that might flow better?", "tree": {"sha": "68b553e7857465100f363cbd51e8bcfeb3177337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68b553e7857465100f363cbd51e8bcfeb3177337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76ff835ca0b6669b185e6a4aeedc144432db91f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76ff835ca0b6669b185e6a4aeedc144432db91f8", "html_url": "https://github.com/rust-lang/rust/commit/76ff835ca0b6669b185e6a4aeedc144432db91f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76ff835ca0b6669b185e6a4aeedc144432db91f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8228240ca88371150314d5474b6795c5410c7a8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8228240ca88371150314d5474b6795c5410c7a8e", "html_url": "https://github.com/rust-lang/rust/commit/8228240ca88371150314d5474b6795c5410c7a8e"}, {"sha": "d5b522e20e4aa862a62e086706187a51c9478a59", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b522e20e4aa862a62e086706187a51c9478a59", "html_url": "https://github.com/rust-lang/rust/commit/d5b522e20e4aa862a62e086706187a51c9478a59"}], "stats": {"total": 94, "additions": 61, "deletions": 33}, "files": [{"sha": "17627da3513ec207b501e0818580dd190cc4998b", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/76ff835ca0b6669b185e6a4aeedc144432db91f8/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/76ff835ca0b6669b185e6a4aeedc144432db91f8/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=76ff835ca0b6669b185e6a4aeedc144432db91f8", "patch": "@@ -135,28 +135,34 @@ This gives us an error:\n         ^~~~\n ```\n \n-In this case, we know that our code _should_ be safe, but Rust isn't sure. And\n-it's actually not safe: if we had a reference to `data` in each thread, and the\n-thread takes ownership of the reference, we have three owners! That's bad. We\n-can fix this by using the `Arc<T>` type, which is an atomic reference counted\n-pointer. The 'atomic' part means that it's safe to share across threads.\n+Rust knows this wouldn't be safe! If we had a reference to `data` in each\n+thread, and the thread takes ownership of the reference, we'd have three\n+owners!\n+\n+So, we need some type that lets us have more than one reference to a value and\n+that we can share between threads, that is it must implement `Sync`.\n+\n+We'll use `Arc<T>`, rust's standard atomic reference count type, which\n+wraps a value up with some extra runtime bookkeeping which allows us to\n+share the ownership of the value between multiple references at the same time.\n+\n+The bookkeeping consists of a count of how many of these references exist to\n+the value, hence the reference count part of the name.\n+\n+The Atomic part means `Arc<T>` can safely be accessed from multiple threads.\n+To do this the compiler guarantees that mutations of the internal count use\n+indivisible operations which can't have data races.\n \n-`Arc<T>` assumes one more property about its contents to ensure that it is safe\n-to share across threads: it assumes its contents are `Sync`. But in our\n-case, we want to be able to mutate the value. We need a type that can ensure\n-only one person at a time can mutate what's inside. For that, we can use the\n-`Mutex<T>` type. Here's the second version of our code. It still doesn't work,\n-but for a different reason:\n \n ```ignore\n use std::thread;\n-use std::sync::Mutex;\n+use std::sync::Arc;\n \n fn main() {\n-    let mut data = Mutex::new(vec![1, 2, 3]);\n+    let mut data = Arc::new(vec![1, 2, 3]);\n \n     for i in 0..3 {\n-        let data = data.lock().unwrap();\n+        let data = data.clone();\n         thread::spawn(move || {\n             data[i] += 1;\n         });\n@@ -166,29 +172,29 @@ fn main() {\n }\n ```\n \n-Here's the error:\n+We now call `clone()` on our `Arc<T>`, which increases the internal count.\n+This handle is then moved into the new thread.\n+\n+And... still gives us an error.\n \n ```text\n-<anon>:9:9: 9:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]\n-<anon>:11         thread::spawn(move || {\n-                  ^~~~~~~~~~~~~\n-<anon>:9:9: 9:22 note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent between threads safely\n-<anon>:11         thread::spawn(move || {\n-                  ^~~~~~~~~~~~~\n+<anon>:11:24 error: cannot borrow immutable borrowed content as mutable\n+<anon>:11                    data[i] += 1;\n+                             ^~~~\n ```\n \n-You see, [`Mutex`](../std/sync/struct.Mutex.html) has a\n-[`lock`](../std/sync/struct.Mutex.html#method.lock)\n-method which has this signature:\n+`Arc<T>` assumes one more property about its contents to ensure that it is safe\n+to share across threads: it assumes its contents are `Sync`. This is true for\n+our value if it's immutable, but we want to be able to mutate it, so we need\n+something else to persuade the borrow checker we know what we're doing.\n \n-```ignore\n-fn lock(&self) -> LockResult<MutexGuard<T>>\n-```\n+It looks like we need some type that allows us to safely mutate a shared value,\n+for example a type that that can ensure only one thread at a time is able to\n+mutate the value inside it at any one time.\n \n-Because `Send` is not implemented for `MutexGuard<T>`, we can't transfer the\n-guard across thread boundaries, which gives us our error.\n+For that, we can use the `Mutex<T>` type!\n \n-We can use `Arc<T>` to fix this. Here's the working version:\n+Here's the working version:\n \n ```rust\n use std::sync::{Arc, Mutex};\n@@ -209,9 +215,31 @@ fn main() {\n }\n ```\n \n-We now call `clone()` on our `Arc`, which increases the internal count. This\n-handle is then moved into the new thread. Let's examine the body of the\n-thread more closely:\n+\n+If we'd tried to use `Mutex<T>` without wrapping it in an `Arc<T>` we would have\n+seen another error like:\n+\n+```text\n+error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]\n+ thread::spawn(move || {\n+                  ^~~~~~~~~~~~~\n+note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent between threads safely\n+ thread::spawn(move || {\n+                  ^~~~~~~~~~~~~\n+```\n+\n+You see, [`Mutex`](../std/sync/struct.Mutex.html) has a\n+[`lock`](../std/sync/struct.Mutex.html#method.lock)\n+method which has this signature:\n+\n+```ignore\n+fn lock(&self) -> LockResult<MutexGuard<T>>\n+```\n+\n+and because `Send` is not implemented for `MutexGuard<T>`, we couldn't have\n+transferred the guard across thread boundaries on it's own.\n+\n+Let's examine the body of the thread more closely:\n \n ```rust\n # use std::sync::{Arc, Mutex};"}]}