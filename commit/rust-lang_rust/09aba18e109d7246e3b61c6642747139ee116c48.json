{"sha": "09aba18e109d7246e3b61c6642747139ee116c48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YWJhMThlMTA5ZDcyNDZlM2I2MWM2NjQyNzQ3MTM5ZWUxMTZjNDg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-11-30T22:35:25Z"}, "committer": {"name": "petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-12-26T12:01:49Z"}, "message": "More systematic error reporting in path resolution", "tree": {"sha": "9f7e59b7d18cd85bbf16864d6819e3451a09c213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f7e59b7d18cd85bbf16864d6819e3451a09c213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09aba18e109d7246e3b61c6642747139ee116c48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09aba18e109d7246e3b61c6642747139ee116c48", "html_url": "https://github.com/rust-lang/rust/commit/09aba18e109d7246e3b61c6642747139ee116c48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09aba18e109d7246e3b61c6642747139ee116c48/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fb676afb061edc708030a5ed1e5f3983e0beaa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fb676afb061edc708030a5ed1e5f3983e0beaa5", "html_url": "https://github.com/rust-lang/rust/commit/3fb676afb061edc708030a5ed1e5f3983e0beaa5"}], "stats": {"total": 2498, "additions": 1246, "deletions": 1252}, "files": [{"sha": "d0003693eefe34e78b071150593427bfa13443e3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -298,8 +298,7 @@ pub trait CrateStore<'tcx> {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n-    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> Option<ty::AssociatedItem>;\n+    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n@@ -456,8 +455,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn associated_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n+    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }"}, {"sha": "2ab10d0446b2a11f22749cc6044a9ec07bee14d2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -2071,7 +2071,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n         self.associated_items.memoize(def_id, || {\n             if !def_id.is_local() {\n-                return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n+                return self.sess.cstore.associated_item(def_id)\n                            .expect(\"missing AssociatedItem in metadata\");\n             }\n \n@@ -2526,8 +2526,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.associated_item(self.global_tcx(), def_id)\n-                       .and_then(|item| {\n+            return self.sess.cstore.associated_item(def_id).and_then(|item| {\n                 match item.container {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),"}, {"sha": "0ac3ffd5cb9ce2a4d6f8a3073bfd0a6df74b60a6", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -188,8 +188,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n-    fn associated_item<'a>(&self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> Option<ty::AssociatedItem>\n+    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_associated_item(def.index)"}, {"sha": "1b3791355d2c35a460f79d58c9e542e2babf4a70", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 22, "deletions": 53, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -417,58 +417,38 @@ impl<'a> Resolver<'a> {\n         let ident = Ident::with_empty_ctxt(child.name);\n         let def = child.def;\n         let def_id = def.def_id();\n-        let vis = match def {\n-            Def::Macro(..) => ty::Visibility::Public,\n-            _ if parent.is_trait() => ty::Visibility::Public,\n-            _ => self.session.cstore.visibility(def_id),\n-        };\n+        let vis = self.session.cstore.visibility(def_id);\n \n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n                 let module = self.new_module(parent, ModuleKind::Def(def, ident.name), def_id);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n-            Def::Variant(..) => {\n+            Def::Variant(..) | Def::TyAlias(..) => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n-            Def::VariantCtor(..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n-            }\n-            Def::Fn(..) |\n-            Def::Static(..) |\n-            Def::Const(..) |\n-            Def::AssociatedConst(..) |\n-            Def::Method(..) => {\n+            Def::Fn(..) | Def::Static(..) | Def::Const(..) |\n+            Def::VariantCtor(..) | Def::StructCtor(..) => {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Trait(..) => {\n                 let module_kind = ModuleKind::Def(def, ident.name);\n                 let module = self.new_module(parent, module_kind, parent.normal_ancestor_id);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n-                // If this is a trait, add all the trait item names to the trait info.\n-                let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n-                for trait_item_def_id in trait_item_def_ids {\n-                    let trait_item_name = self.session.cstore.def_key(trait_item_def_id)\n-                                              .disambiguated_data.data.get_opt_name()\n-                                              .expect(\"opt_item_name returned None for trait\");\n-                    self.trait_item_map.insert((trait_item_name, def_id), false);\n-                }\n-            }\n-            Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n-            }\n-            Def::Struct(..) => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                for child in self.session.cstore.item_children(def_id) {\n+                    let ns = if let Def::AssociatedTy(..) = child.def { TypeNS } else { ValueNS };\n+                    let ident = Ident::with_empty_ctxt(child.name);\n+                    self.define(module, ident, ns, (child.def, ty::Visibility::Public,\n+                                                    DUMMY_SP, Mark::root()));\n \n-                // Record field names for error reporting.\n-                let field_names = self.session.cstore.struct_field_names(def_id);\n-                self.insert_field_names(def_id, field_names);\n-            }\n-            Def::StructCtor(..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                    let has_self = self.session.cstore.associated_item(child.def.def_id())\n+                                       .map_or(false, |item| item.method_has_self_argument);\n+                    self.trait_item_map.insert((def_id, child.name, ns), (child.def, has_self));\n+                }\n+                module.populated.set(true);\n             }\n-            Def::Union(..) => {\n+            Def::Struct(..) | Def::Union(..) => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n@@ -478,15 +458,7 @@ impl<'a> Resolver<'a> {\n             Def::Macro(..) => {\n                 self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n-            Def::Local(..) |\n-            Def::PrimTy(..) |\n-            Def::TyParam(..) |\n-            Def::Upvar(..) |\n-            Def::Label(..) |\n-            Def::SelfTy(..) |\n-            Def::Err => {\n-                bug!(\"unexpected definition: {:?}\", def);\n-            }\n+            _ => bug!(\"unexpected definition: {:?}\", def)\n         }\n     }\n \n@@ -751,18 +723,15 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n         // Add the item to the trait info.\n         let item_def_id = self.resolver.definitions.local_def_id(item.id);\n-        let mut is_static_method = false;\n-        let (def, ns) = match item.node {\n-            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n-            TraitItemKind::Method(ref sig, _) => {\n-                is_static_method = !sig.decl.has_self();\n-                (Def::Method(item_def_id), ValueNS)\n-            }\n-            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n+        let (def, ns, has_self) = match item.node {\n+            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS, false),\n+            TraitItemKind::Method(ref sig, _) =>\n+                (Def::Method(item_def_id), ValueNS, sig.decl.has_self()),\n+            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS, false),\n             TraitItemKind::Macro(_) => bug!(),  // handled above\n         };\n \n-        self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n+        self.resolver.trait_item_map.insert((def_id, item.ident.name, ns), (def, has_self));\n \n         let vis = ty::Visibility::Public;\n         self.resolver.define(parent, item.ident, ns, (def, vis, item.span, self.expansion));"}, {"sha": "2fada8a9ec212f0e051129115a002eb27d71c34b", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -860,6 +860,26 @@ match (A, B, C) {\n ```\n \"##,\n \n+E0422: r##\"\n+You are trying to use an identifier that is either undefined or not a struct.\n+Erroneous code example:\n+``` compile_fail,E0422\n+fn main () {\n+    let x = Foo { x: 1, y: 2 };\n+}\n+```\n+In this case, `Foo` is undefined, so it inherently isn't anything, and\n+definitely not a struct.\n+```compile_fail\n+fn main () {\n+    let foo = 1;\n+    let x = foo { x: 1, y: 2 };\n+}\n+```\n+In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n+one.\n+\"##,\n+\n E0423: r##\"\n A `struct` variant name was used like a function name.\n \n@@ -1519,7 +1539,12 @@ register_diagnostics! {\n //  E0419, merged into 531\n //  E0420, merged into 532\n //  E0421, merged into 531\n-//  E0422, merged into 531/532\n     E0531, // unresolved pattern path kind `name`\n //  E0427, merged into 530\n+    E0573,\n+    E0574,\n+    E0575,\n+    E0576,\n+    E0577,\n+    E0578,\n }"}, {"sha": "a0af4c456535990c0b9ce9f7f91a52353bd9584b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 614, "deletions": 722, "changes": 1336, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -33,7 +33,6 @@ extern crate arena;\n extern crate rustc;\n \n use self::Namespace::*;\n-use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n use self::RibKind::*;\n \n@@ -83,16 +82,16 @@ mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n \n-enum SuggestionType {\n-    Macro(String),\n-    Function(Symbol),\n-    NotFound,\n+/// A free importable items suggested in case of resolution failure.\n+struct ImportSuggestion {\n+    path: Path,\n }\n \n-/// Candidates for a name resolution failure\n-struct SuggestedCandidates {\n-    name: String,\n-    candidates: Vec<Path>,\n+/// A field or associated item from self type suggested in case of resolution failure.\n+enum AssocSuggestion {\n+    Field,\n+    MethodWithSelf,\n+    AssocItem,\n }\n \n enum ResolutionError<'a> {\n@@ -102,10 +101,6 @@ enum ResolutionError<'a> {\n     OuterTypeParameterContext,\n     /// error E0403: the name is already used for a type parameter in this type parameter list\n     NameAlreadyUsedInTypeParameterList(Name, &'a Span),\n-    /// error E0404: is not a trait\n-    IsNotATrait(&'a str, &'a str),\n-    /// error E0405: use of undeclared trait name\n-    UndeclaredTraitName(&'a str, SuggestedCandidates),\n     /// error E0407: method is not a member of trait\n     MethodNotMemberOfTrait(Name, &'a str),\n     /// error E0437: type is not a member of trait\n@@ -116,27 +111,10 @@ enum ResolutionError<'a> {\n     VariableNotBoundInPattern(Name, usize, usize),\n     /// error E0409: variable is bound with different mode in pattern #{} than in pattern #1\n     VariableBoundWithDifferentMode(Name, usize, Span),\n-    /// error E0411: use of `Self` outside of an impl or trait\n-    SelfUsedOutsideImplOrTrait,\n-    /// error E0412: use of undeclared\n-    UseOfUndeclared(&'a str, &'a str, SuggestedCandidates),\n     /// error E0415: identifier is bound more than once in this parameter list\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n-    /// error E0423: is a struct variant name, but this expression uses it like a function name\n-    StructVariantUsedAsFunction(&'a str),\n-    /// error E0424: `self` is not available in a static method\n-    SelfNotAvailableInStaticMethod,\n-    /// error E0425: unresolved name\n-    UnresolvedName {\n-        path: &'a str,\n-        message: &'a str,\n-        context: UnresolvedNameContext<'a>,\n-        is_static_method: bool,\n-        is_field: bool,\n-        def: Def,\n-    },\n     /// error E0426: use of undeclared label\n     UndeclaredLabel(&'a str),\n     /// error E0429: `self` imports are only allowed within a { } list\n@@ -155,37 +133,18 @@ enum ResolutionError<'a> {\n     AttemptToUseNonConstantValueInConstant,\n     /// error E0530: X bindings cannot shadow Ys\n     BindingShadowsSomethingUnacceptable(&'a str, Name, &'a NameBinding<'a>),\n-    /// error E0531: unresolved pattern path kind `name`\n-    PatPathUnresolved(&'a str, &'a Path),\n-    /// error E0532: expected pattern path kind, found another pattern path kind\n-    PatPathUnexpected(&'a str, &'a str, &'a Path),\n-}\n-\n-/// Context of where `ResolutionError::UnresolvedName` arose.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum UnresolvedNameContext<'a> {\n-    /// `PathIsMod(parent)` indicates that a given path, used in\n-    /// expression context, actually resolved to a module rather than\n-    /// a value. The optional expression attached to the variant is the\n-    /// the parent of the erroneous path expression.\n-    PathIsMod(Option<&'a Expr>),\n-\n-    /// `Other` means we have no extra information about the context\n-    /// of the unresolved name error. (Maybe we could eliminate all\n-    /// such cases; but for now, this is an information-free default.)\n-    Other,\n }\n \n-fn resolve_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n-                                 span: syntax_pos::Span,\n-                                 resolution_error: ResolutionError<'c>) {\n+fn resolve_error<'sess, 'a>(resolver: &'sess Resolver,\n+                            span: Span,\n+                            resolution_error: ResolutionError<'a>) {\n     resolve_struct_error(resolver, span, resolution_error).emit();\n }\n \n-fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n-                                        span: syntax_pos::Span,\n-                                        resolution_error: ResolutionError<'c>)\n-                                        -> DiagnosticBuilder<'a> {\n+fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n+                                   span: Span,\n+                                   resolution_error: ResolutionError<'a>)\n+                                   -> DiagnosticBuilder<'sess> {\n     match resolution_error {\n         ResolutionError::TypeParametersFromOuterFunction => {\n             let mut err = struct_span_err!(resolver.session,\n@@ -212,26 +171,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n              err.span_label(span, &format!(\"already used\"));\n              err.span_label(first_use_span.clone(), &format!(\"first use of `{}`\", name));\n              err\n-\n-        }\n-        ResolutionError::IsNotATrait(name, kind_name) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0404,\n-                                           \"`{}` is not a trait\",\n-                                           name);\n-            err.span_label(span, &format!(\"expected trait, found {}\", kind_name));\n-            err\n-        }\n-        ResolutionError::UndeclaredTraitName(name, candidates) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0405,\n-                                           \"trait `{}` is not in scope\",\n-                                           name);\n-            show_candidates(&mut err, &candidates);\n-            err.span_label(span, &format!(\"`{}` is not in scope\", name));\n-            err\n         }\n         ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n             let mut err = struct_span_err!(resolver.session,\n@@ -288,25 +227,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(first_binding_span, &format!(\"first binding\"));\n             err\n         }\n-        ResolutionError::SelfUsedOutsideImplOrTrait => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0411,\n-                                           \"use of `Self` outside of an impl or trait\");\n-            err.span_label(span, &format!(\"used outside of impl or trait\"));\n-            err\n-        }\n-        ResolutionError::UseOfUndeclared(kind, name, candidates) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0412,\n-                                           \"{} `{}` is undefined or not in scope\",\n-                                           kind,\n-                                           name);\n-            show_candidates(&mut err, &candidates);\n-            err.span_label(span, &format!(\"undefined or not in scope\"));\n-            err\n-        }\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n             let mut err = struct_span_err!(resolver.session,\n                              span,\n@@ -325,69 +245,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(span, &format!(\"used in a pattern more than once\"));\n             err\n         }\n-        ResolutionError::StructVariantUsedAsFunction(path_name) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0423,\n-                             \"`{}` is the name of a struct or struct variant, but this expression \\\n-                             uses it like a function name\",\n-                             path_name);\n-            err.span_label(span, &format!(\"struct called like a function\"));\n-            err\n-        }\n-        ResolutionError::SelfNotAvailableInStaticMethod => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0424,\n-                             \"`self` is not available in a static method\");\n-            err.span_label(span, &format!(\"not available in static method\"));\n-            err.note(&format!(\"maybe a `self` argument is missing?\"));\n-            err\n-        }\n-        ResolutionError::UnresolvedName { path, message: msg, context, is_static_method,\n-                                          is_field, def } => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0425,\n-                                           \"unresolved name `{}`\",\n-                                           path);\n-            if msg != \"\" {\n-                err.span_label(span, &msg);\n-            } else {\n-                err.span_label(span, &format!(\"unresolved name\"));\n-            }\n-\n-            match context {\n-                UnresolvedNameContext::Other => {\n-                    if msg.is_empty() && is_static_method && is_field {\n-                        err.help(\"this is an associated function, you don't have access to \\\n-                                  this type's fields or methods\");\n-                    }\n-                }\n-                UnresolvedNameContext::PathIsMod(parent) => {\n-                    err.help(&match parent.map(|parent| &parent.node) {\n-                        Some(&ExprKind::Field(_, ident)) => {\n-                            format!(\"to reference an item from the `{module}` module, \\\n-                                     use `{module}::{ident}`\",\n-                                    module = path,\n-                                    ident = ident.node)\n-                        }\n-                        Some(&ExprKind::MethodCall(ident, ..)) => {\n-                            format!(\"to call a function from the `{module}` module, \\\n-                                     use `{module}::{ident}(..)`\",\n-                                    module = path,\n-                                    ident = ident.node)\n-                        }\n-                        _ => {\n-                            format!(\"{def} `{module}` cannot be used as an expression\",\n-                                    def = def.kind_name(),\n-                                    module = path)\n-                        }\n-                    });\n-                }\n-            }\n-            err\n-        }\n         ResolutionError::UndeclaredLabel(name) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n@@ -462,23 +319,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(binding.span, msg);\n             err\n         }\n-        ResolutionError::PatPathUnresolved(expected_what, path) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0531,\n-                             \"unresolved {} `{}`\",\n-                             expected_what,\n-                             path)\n-        }\n-        ResolutionError::PatPathUnexpected(expected_what, found_what, path) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0532,\n-                             \"expected {}, found {} `{}`\",\n-                             expected_what,\n-                             found_what,\n-                             path)\n-        }\n     }\n }\n \n@@ -520,6 +360,163 @@ impl PatternSource {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum PathSource<'a> {\n+    // Type paths `Path`.\n+    Type,\n+    // Trait paths in bounds or impls.\n+    Trait,\n+    // Expression paths `path`, with optional parent context.\n+    Expr(Option<&'a ExprKind>),\n+    // Paths in path patterns `Path`.\n+    Pat,\n+    // Paths in struct expressions and patterns `Path { .. }`.\n+    Struct,\n+    // Paths in tuple struct patterns `Path(..)`.\n+    TupleStruct,\n+    // `m::A::B` in `<T as m::A>::B::C`.\n+    TraitItem(Namespace),\n+    // Path in `pub(path)`\n+    Visibility,\n+    // Path in `use a::b::{...};`\n+    ImportPrefix,\n+}\n+\n+impl<'a> PathSource<'a> {\n+    fn namespace(self) -> Namespace {\n+        match self {\n+            PathSource::Type | PathSource::Trait | PathSource::Struct |\n+            PathSource::Visibility | PathSource::ImportPrefix => TypeNS,\n+            PathSource::Expr(..) | PathSource::Pat | PathSource::TupleStruct => ValueNS,\n+            PathSource::TraitItem(ns) => ns,\n+        }\n+    }\n+\n+    fn global_by_default(self) -> bool {\n+        match self {\n+            PathSource::Visibility | PathSource::ImportPrefix => true,\n+            PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n+            PathSource::Struct | PathSource::TupleStruct |\n+            PathSource::Trait | PathSource::TraitItem(..) => false,\n+        }\n+    }\n+\n+    fn defer_to_typeck(self) -> bool {\n+        match self {\n+            PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n+            PathSource::Struct | PathSource::TupleStruct => true,\n+            PathSource::Trait | PathSource::TraitItem(..) |\n+            PathSource::Visibility | PathSource::ImportPrefix => false,\n+        }\n+    }\n+\n+    fn descr_expected(self) -> &'static str {\n+        match self {\n+            PathSource::Type => \"type\",\n+            PathSource::Trait => \"trait\",\n+            PathSource::Pat => \"unit struct/variant or constant\",\n+            PathSource::Struct => \"struct, variant or union type\",\n+            PathSource::TupleStruct => \"tuple struct/variant\",\n+            PathSource::Visibility => \"module\",\n+            PathSource::ImportPrefix => \"module or enum\",\n+            PathSource::TraitItem(ns) => match ns {\n+                TypeNS => \"associated type\",\n+                ValueNS => \"method or associated constant\",\n+                MacroNS => bug!(\"associated macro\"),\n+            },\n+            PathSource::Expr(parent) => match parent {\n+                // \"function\" here means \"anything callable\" rather than `Def::Fn`,\n+                // this is not precise but usually more helpful than just \"value\".\n+                Some(&ExprKind::Call(..)) => \"function\",\n+                _ => \"value\",\n+            },\n+        }\n+    }\n+\n+    fn is_expected(self, def: Def) -> bool {\n+        match self {\n+            PathSource::Type => match def {\n+                Def::Struct(..) | Def::Union(..) | Def::Enum(..) |\n+                Def::Trait(..) | Def::TyAlias(..) | Def::AssociatedTy(..) |\n+                Def::PrimTy(..) | Def::TyParam(..) | Def::SelfTy(..) => true,\n+                _ => false,\n+            },\n+            PathSource::Trait => match def {\n+                Def::Trait(..) => true,\n+                _ => false,\n+            },\n+            PathSource::Expr(..) => match def {\n+                Def::StructCtor(_, CtorKind::Const) | Def::StructCtor(_, CtorKind::Fn) |\n+                Def::VariantCtor(_, CtorKind::Const) | Def::VariantCtor(_, CtorKind::Fn) |\n+                Def::Const(..) | Def::Static(..) | Def::Local(..) | Def::Upvar(..) |\n+                Def::Fn(..) | Def::Method(..) | Def::AssociatedConst(..) => true,\n+                _ => false,\n+            },\n+            PathSource::Pat => match def {\n+                Def::StructCtor(_, CtorKind::Const) |\n+                Def::VariantCtor(_, CtorKind::Const) |\n+                Def::Const(..) | Def::AssociatedConst(..) => true,\n+                _ => false,\n+            },\n+            PathSource::TupleStruct => match def {\n+                Def::StructCtor(_, CtorKind::Fn) | Def::VariantCtor(_, CtorKind::Fn) => true,\n+                _ => false,\n+            },\n+            PathSource::Struct => match def {\n+                Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => true,\n+                _ => false,\n+            },\n+            PathSource::TraitItem(ns) => match def {\n+                Def::AssociatedConst(..) | Def::Method(..) if ns == ValueNS => true,\n+                Def::AssociatedTy(..) if ns == TypeNS => true,\n+                _ => false,\n+            },\n+            PathSource::ImportPrefix => match def {\n+                Def::Mod(..) | Def::Enum(..) => true,\n+                _ => false,\n+            },\n+            PathSource::Visibility => match def {\n+                Def::Mod(..) => true,\n+                _ => false,\n+            },\n+        }\n+    }\n+\n+    fn error_code(self, has_unexpected_resolution: bool) -> &'static str {\n+        __diagnostic_used!(E0404);\n+        __diagnostic_used!(E0405);\n+        __diagnostic_used!(E0412);\n+        __diagnostic_used!(E0422);\n+        __diagnostic_used!(E0423);\n+        __diagnostic_used!(E0425);\n+        __diagnostic_used!(E0531);\n+        __diagnostic_used!(E0532);\n+        __diagnostic_used!(E0573);\n+        __diagnostic_used!(E0574);\n+        __diagnostic_used!(E0575);\n+        __diagnostic_used!(E0576);\n+        __diagnostic_used!(E0577);\n+        __diagnostic_used!(E0578);\n+        match (self, has_unexpected_resolution) {\n+            (PathSource::Trait, true) => \"E0404\",\n+            (PathSource::Trait, false) => \"E0405\",\n+            (PathSource::Type, true) => \"E0573\",\n+            (PathSource::Type, false) => \"E0412\",\n+            (PathSource::Struct, true) => \"E0574\",\n+            (PathSource::Struct, false) => \"E0422\",\n+            (PathSource::Expr(..), true) => \"E0423\",\n+            (PathSource::Expr(..), false) => \"E0425\",\n+            (PathSource::Pat, true) | (PathSource::TupleStruct, true) => \"E0532\",\n+            (PathSource::Pat, false) | (PathSource::TupleStruct, false) => \"E0531\",\n+            (PathSource::TraitItem(..), true) => \"E0575\",\n+            (PathSource::TraitItem(..), false) => \"E0576\",\n+            (PathSource::Visibility, true) | (PathSource::ImportPrefix, true) => \"E0577\",\n+            (PathSource::Visibility, false) | (PathSource::ImportPrefix, false) => \"E0578\",\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Namespace {\n     TypeNS,\n@@ -572,15 +569,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n-        self.resolve_type(ty);\n+        if let TyKind::Path(ref qself, ref path) = ty.node {\n+            self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n+        }\n+        visit::walk_ty(self, ty);\n     }\n     fn visit_poly_trait_ref(&mut self,\n                             tref: &'tcx ast::PolyTraitRef,\n                             m: &'tcx ast::TraitBoundModifier) {\n-        let ast::Path { ref segments, span } = tref.trait_ref.path;\n-        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n-        let def = self.resolve_trait_reference(&path, None, span);\n-        self.record_def(tref.trait_ref.ref_id, def);\n+        self.smart_resolve_path(tref.trait_ref.ref_id, None,\n+                                &tref.trait_ref.path, PathSource::Trait);\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self,\n@@ -666,13 +664,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n \n pub type ErrorMessage = Option<(Span, String)>;\n \n-enum FallbackSuggestion {\n-    NoSuggestion,\n-    Field,\n-    TraitItem,\n-    TraitMethod(String),\n-}\n-\n #[derive(Copy, Clone)]\n enum TypeParameters<'a, 'b> {\n     NoTypeParameters,\n@@ -732,7 +723,7 @@ impl<'a> Rib<'a> {\n }\n \n /// A definition along with the index of the rib it was found on\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n struct LocalDef {\n     ribs: Option<(Namespace, usize)>,\n     def: Def,\n@@ -1025,7 +1016,7 @@ pub struct Resolver<'a> {\n \n     prelude: Option<Module<'a>>,\n \n-    trait_item_map: FxHashMap<(Name, DefId), bool /* is static method? */>,\n+    trait_item_map: FxHashMap<(DefId, Name, Namespace), (Def, bool /* has self */)>,\n \n     // Names of fields of an item `DefId` accessible with dot syntax.\n     // Used for hints during error reporting.\n@@ -1391,11 +1382,9 @@ impl<'a> Resolver<'a> {\n         for i in (0 .. self.ribs[ns].len()).rev() {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n-                return Some(LexicalScopeBinding::Def(if let Some(span) = record_used {\n-                    self.adjust_local_def(LocalDef { ribs: Some((ns, i)), def: def }, span)\n-                } else {\n-                    def\n-                }));\n+                return Some(LexicalScopeBinding::Def(\n+                    self.adjust_local_def(LocalDef { ribs: Some((ns, i)), def: def }, record_used)\n+                ));\n             }\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n@@ -1521,7 +1510,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::DefaultImpl(_, ref trait_ref) => {\n-                self.with_optional_trait_ref(Some(trait_ref), |_, _| {}, None);\n+                self.with_optional_trait_ref(Some(trait_ref), |_, _| {});\n             }\n             ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n                 self.resolve_implementation(generics,\n@@ -1586,33 +1575,9 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n-                    ast::ViewPathList(ref prefix, ref items) => {\n-                        let path: Vec<_> =\n-                            prefix.segments.iter().map(|seg| seg.identifier).collect();\n-                        // Resolve prefix of an import with empty braces (issue #28388)\n-                        if items.is_empty() && !prefix.segments.is_empty() {\n-                            let span = prefix.span;\n-                            // FIXME(#38012) This should be a module path, not anything in TypeNS.\n-                            let result = self.resolve_path(&path, Some(TypeNS), Some(span));\n-                            let (def, msg) = match result {\n-                                PathResult::Module(module) => (module.def().unwrap(), None),\n-                                PathResult::NonModule(res) if res.depth == 0 =>\n-                                    (res.base_def, None),\n-                                PathResult::NonModule(_) => {\n-                                    // Resolve a module path for better errors\n-                                    match self.resolve_path(&path, None, Some(span)) {\n-                                        PathResult::Failed(msg, _) => (Def::Err, Some(msg)),\n-                                        _ => unreachable!(),\n-                                    }\n-                                }\n-                                PathResult::Indeterminate => unreachable!(),\n-                                PathResult::Failed(msg, _) => (Def::Err, Some(msg)),\n-                            };\n-                            if let Some(msg) = msg {\n-                                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                            }\n-                            self.record_def(item.id, PathResolution::new(def));\n-                        }\n+                    ast::ViewPathList(ref prefix, ref items) if items.is_empty() => {\n+                        // Resolve prefix of an import with empty braces (issue #28388).\n+                        self.smart_resolve_path(item.id, None, prefix, PathSource::ImportPrefix);\n                     }\n                     _ => {}\n                 }\n@@ -1685,54 +1650,6 @@ impl<'a> Resolver<'a> {\n         self.ribs[ValueNS].pop();\n     }\n \n-    fn resolve_trait_reference(&mut self,\n-                               path: &[Ident],\n-                               generics: Option<&Generics>,\n-                               span: Span)\n-                               -> PathResolution {\n-        let def = match self.resolve_path(path, None, Some(span)) {\n-            PathResult::Module(module) => Some(module.def().unwrap()),\n-            PathResult::NonModule(..) => return err_path_resolution(),\n-            PathResult::Failed(msg, false) => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                return err_path_resolution();\n-            }\n-            _ => match self.resolve_path(path, Some(TypeNS), None) {\n-                PathResult::NonModule(path_resolution) => Some(path_resolution.base_def),\n-                _ => None,\n-            },\n-        };\n-\n-        if let Some(def) = def {\n-            if let Def::Trait(_) = def {\n-                return PathResolution::new(def);\n-            }\n-\n-            let mut err = resolve_struct_error(self, span, {\n-                ResolutionError::IsNotATrait(&names_to_string(path), def.kind_name())\n-            });\n-            if let Some(generics) = generics {\n-                if let Some(span) = generics.span_for_name(&names_to_string(path)) {\n-                    err.span_label(span, &\"type parameter defined here\");\n-                }\n-            }\n-\n-            // If it's a typedef, give a note\n-            if let Def::TyAlias(..) = def {\n-                err.note(&format!(\"type aliases cannot be used for traits\"));\n-            }\n-            err.emit();\n-        } else {\n-            // find possible candidates\n-            let is_trait = |def| match def { Def::Trait(_) => true, _ => false };\n-            let candidates = self.lookup_candidates(path.last().unwrap().name, TypeNS, is_trait);\n-\n-            let path = names_to_string(path);\n-            resolve_error(self, span, ResolutionError::UndeclaredTraitName(&path, candidates));\n-        }\n-        err_path_resolution()\n-    }\n-\n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n         where F: FnOnce(&mut Resolver) -> T\n     {\n@@ -1743,24 +1660,17 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn with_optional_trait_ref<T, F>(&mut self,\n-                                     opt_trait_ref: Option<&TraitRef>,\n-                                     f: F,\n-                                     generics: Option<&Generics>)\n-        -> T\n+    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n         where F: FnOnce(&mut Resolver, Option<DefId>) -> T\n     {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let ast::Path { ref segments, span } = trait_ref.path;\n-            let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n-            let path_res = self.resolve_trait_reference(&path, generics, span);\n-            assert!(path_res.depth == 0);\n-            self.record_def(trait_ref.ref_id, path_res);\n-            if path_res.base_def != Def::Err {\n-                new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n-                new_id = Some(path_res.base_def.def_id());\n+            let def = self.smart_resolve_path(trait_ref.ref_id, None,\n+                                              &trait_ref.path, PathSource::Trait).base_def;\n+            if def != Def::Err {\n+                new_val = Some((def.def_id(), trait_ref.clone()));\n+                new_id = Some(def.def_id());\n             }\n             visit::walk_trait_ref(self, trait_ref);\n         }\n@@ -1808,6 +1718,7 @@ impl<'a> Resolver<'a> {\n                                     // If this is a trait impl, ensure the const\n                                     // exists in trait\n                                     this.check_trait_item(impl_item.ident.name,\n+                                                          ValueNS,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n                                     visit::walk_impl_item(this, impl_item);\n@@ -1816,6 +1727,7 @@ impl<'a> Resolver<'a> {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait\n                                     this.check_trait_item(impl_item.ident.name,\n+                                                          ValueNS,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n \n@@ -1832,6 +1744,7 @@ impl<'a> Resolver<'a> {\n                                     // If this is a trait impl, ensure the type\n                                     // exists in trait\n                                     this.check_trait_item(impl_item.ident.name,\n+                                                          TypeNS,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n \n@@ -1842,18 +1755,18 @@ impl<'a> Resolver<'a> {\n                         }\n                     });\n                 });\n-            }, Some(&generics));\n+            });\n         });\n     }\n \n-    fn check_trait_item<F>(&self, name: Name, span: Span, err: F)\n+    fn check_trait_item<F>(&self, name: Name, ns: Namespace, span: Span, err: F)\n         where F: FnOnce(Name, &str) -> ResolutionError\n     {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n-            if !self.trait_item_map.contains_key(&(name, did)) {\n-                let path_str = path_names_to_string(&trait_ref.path, 0);\n+            if !self.trait_item_map.contains_key(&(did, name, ns)) {\n+                let path_str = path_names_to_string(&trait_ref.path);\n                 resolve_error(self, span, err(name, &path_str));\n             }\n         }\n@@ -1993,58 +1906,6 @@ impl<'a> Resolver<'a> {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    fn resolve_type(&mut self, ty: &Ty) {\n-        if let TyKind::Path(ref maybe_qself, ref path) = ty.node {\n-            // This is a path in the type namespace. Walk through scopes looking for it.\n-            if let Some(def) =\n-                    self.resolve_possibly_assoc_item(ty.id, maybe_qself.as_ref(), path, TypeNS) {\n-                match def.base_def {\n-                    Def::Mod(..) if def.depth == 0 => {\n-                        self.session.span_err(path.span, \"expected type, found module\");\n-                        self.record_def(ty.id, err_path_resolution());\n-                    }\n-                    _ => {\n-                        // Write the result into the def map.\n-                        debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n-                               path_names_to_string(path, 0), ty.id, def);\n-                        self.record_def(ty.id, def);\n-                   }\n-                }\n-            } else {\n-                self.record_def(ty.id, err_path_resolution());\n-                // Keep reporting some errors even if they're ignored above.\n-                let kind = if maybe_qself.is_some() { \"associated type\" } else { \"type name\" };\n-                let is_invalid_self_type_name = {\n-                    path.segments.len() > 0 &&\n-                    maybe_qself.is_none() &&\n-                    path.segments[0].identifier.name == keywords::SelfType.name()\n-                };\n-\n-                if is_invalid_self_type_name {\n-                    resolve_error(self, ty.span, ResolutionError::SelfUsedOutsideImplOrTrait);\n-                } else {\n-                    let type_name = path.segments.last().unwrap().identifier.name;\n-                    let candidates = self.lookup_candidates(type_name, TypeNS, |def| {\n-                        match def {\n-                            Def::Trait(_) |\n-                            Def::Enum(_) |\n-                            Def::Struct(_) |\n-                            Def::Union(_) |\n-                            Def::TyAlias(_) => true,\n-                            _ => false,\n-                        }\n-                    });\n-\n-                    let name = &path_names_to_string(path, 0);\n-                    let error = ResolutionError::UseOfUndeclared(kind, name, candidates);\n-                    resolve_error(self, ty.span, error);\n-                }\n-            }\n-        }\n-        // Resolve embedded types.\n-        visit::walk_ty(self, ty);\n-    }\n-\n     fn fresh_binding(&mut self,\n                      ident: &SpannedIdent,\n                      pat_id: NodeId,\n@@ -2098,61 +1959,6 @@ impl<'a> Resolver<'a> {\n         PathResolution::new(def)\n     }\n \n-    fn resolve_pattern_path<ExpectedFn>(&mut self,\n-                                        pat_id: NodeId,\n-                                        qself: Option<&QSelf>,\n-                                        path: &Path,\n-                                        namespace: Namespace,\n-                                        expected_fn: ExpectedFn,\n-                                        expected_what: &str)\n-        where ExpectedFn: FnOnce(Def) -> bool\n-    {\n-        let resolution = if let Some(resolution) = self.resolve_possibly_assoc_item(pat_id,\n-                                                                        qself, path, namespace) {\n-            if resolution.depth == 0 {\n-                if expected_fn(resolution.base_def) || resolution.base_def == Def::Err {\n-                    resolution\n-                } else {\n-                    resolve_error(\n-                        self,\n-                        path.span,\n-                        ResolutionError::PatPathUnexpected(expected_what,\n-                                                           resolution.kind_name(), path)\n-                    );\n-                    err_path_resolution()\n-                }\n-            } else {\n-                // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n-                // or `<T>::A::B`. If `B` should be resolved in value namespace then\n-                // it needs to be added to the trait map.\n-                if namespace == ValueNS {\n-                    let item_name = path.segments.last().unwrap().identifier.name;\n-                    let traits = self.get_traits_containing_item(item_name);\n-                    self.trait_map.insert(pat_id, traits);\n-                }\n-                resolution\n-            }\n-        } else {\n-            let error = ResolutionError::PatPathUnresolved(expected_what, path);\n-            resolve_error(self, path.span, error);\n-            err_path_resolution()\n-        };\n-\n-        self.record_def(pat_id, resolution);\n-    }\n-\n-    fn resolve_struct_path(&mut self, node_id: NodeId, path: &Path) {\n-        // Resolution logic is equivalent for expressions and patterns,\n-        // reuse `resolve_pattern_path` for both.\n-        self.resolve_pattern_path(node_id, None, path, TypeNS, |def| {\n-            match def {\n-                Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => true,\n-                _ => false,\n-            }\n-        }, \"struct, variant or union type\");\n-    }\n-\n     fn resolve_pattern(&mut self,\n                        pat: &Pat,\n                        pat_src: PatternSource,\n@@ -2208,28 +2014,15 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 PatKind::TupleStruct(ref path, ..) => {\n-                    self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n-                        match def {\n-                            Def::StructCtor(_, CtorKind::Fn) |\n-                            Def::VariantCtor(_, CtorKind::Fn) => true,\n-                            _ => false,\n-                        }\n-                    }, \"tuple struct/variant\");\n+                    self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct);\n                 }\n \n                 PatKind::Path(ref qself, ref path) => {\n-                    self.resolve_pattern_path(pat.id, qself.as_ref(), path, ValueNS, |def| {\n-                        match def {\n-                            Def::StructCtor(_, CtorKind::Const) |\n-                            Def::VariantCtor(_, CtorKind::Const) |\n-                            Def::Const(..) | Def::AssociatedConst(..) => true,\n-                            _ => false,\n-                        }\n-                    }, \"unit struct/variant or constant\");\n+                    self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n                 }\n \n                 PatKind::Struct(ref path, ..) => {\n-                    self.resolve_struct_path(pat.id, path);\n+                    self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n                 }\n \n                 _ => {}\n@@ -2240,33 +2033,245 @@ impl<'a> Resolver<'a> {\n         visit::walk_pat(self, pat);\n     }\n \n-    /// Handles paths that may refer to associated items\n-    fn resolve_possibly_assoc_item(&mut self,\n+    // High-level and context dependent path resolution routine.\n+    // Resolves the path and records the resolution into definition map.\n+    // If resolution fails tries several techniques to find likely\n+    // resolution candidates, suggest imports or other help, and report\n+    // errors in user friendly way.\n+    fn smart_resolve_path(&mut self,\n+                          id: NodeId,\n+                          qself: Option<&QSelf>,\n+                          path: &Path,\n+                          source: PathSource)\n+                          -> PathResolution {\n+        let segments = &path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n+        self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n+    }\n+\n+    fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n-                                   maybe_qself: Option<&QSelf>,\n-                                   path: &Path,\n-                                   ns: Namespace)\n-                                   -> Option<PathResolution> {\n-        let ast::Path { ref segments, span } = *path;\n-        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n-\n-        if let Some(qself) = maybe_qself {\n+                                   qself: Option<&QSelf>,\n+                                   path: &[Ident],\n+                                   span: Span,\n+                                   source: PathSource)\n+                                   -> PathResolution {\n+        let ns = source.namespace();\n+        let is_expected = &|def| source.is_expected(def);\n+\n+        // Base error is amended with one short label and possibly some longer helps/notes.\n+        let report_errors = |this: &mut Self, def: Option<Def>| {\n+            // Make the base error.\n+            let expected = source.descr_expected();\n+            let path_str = names_to_string(path);\n+            let code = source.error_code(def.is_some());\n+            let base_msg = if let Some(def) = def {\n+                format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str)\n+            } else {\n+                format!(\"unresolved {} `{}`\", expected, path_str)\n+            };\n+            let mut err = this.session.struct_span_err_with_code(span, &base_msg, code);\n+\n+            // Emit special messages for unresolved `Self` and `self`.\n+            if is_self_type(path, ns) {\n+                __diagnostic_used!(E0411);\n+                err.code(\"E0411\".into());\n+                err.span_label(span, &format!(\"`Self` is only available in traits and impls\"));\n+                return err;\n+            }\n+            if is_self_value(path, ns) {\n+                __diagnostic_used!(E0424);\n+                err.code(\"E0424\".into());\n+                err.span_label(span, &format!(\"`self` value is only available in \\\n+                                               methods with `self` parameter\"));\n+                return err;\n+            }\n+\n+            // Try to lookup the name in more relaxed fashion for better error reporting.\n+            let name = path.last().unwrap().name;\n+            let candidates = this.lookup_import_candidates(name, ns, is_expected);\n+            if !candidates.is_empty() {\n+                // Report import candidates as help and proceed searching for labels.\n+                show_candidates(&mut err, &candidates, def.is_some());\n+            }\n+            if path.len() == 1 && this.self_type_is_available() {\n+                if let Some(candidate) = this.lookup_assoc_candidate(name, ns, is_expected) {\n+                    let self_is_available = this.self_value_is_available(path[0].ctxt);\n+                    match candidate {\n+                        AssocSuggestion::Field => {\n+                            err.span_label(span, &format!(\"did you mean `self.{}`?\", path_str));\n+                            if !self_is_available {\n+                                err.span_label(span, &format!(\"`self` value is only available in \\\n+                                                               methods with `self` parameter\"));\n+                            }\n+                        }\n+                        AssocSuggestion::MethodWithSelf if self_is_available => {\n+                            err.span_label(span, &format!(\"did you mean `self.{}(...)`?\",\n+                                                           path_str));\n+                        }\n+                        AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n+                            err.span_label(span, &format!(\"did you mean `Self::{}`?\", path_str));\n+                        }\n+                    }\n+                    return err;\n+                }\n+            }\n+\n+            // Try context dependent help if relaxed lookup didn't work.\n+            if let Some(def) = def {\n+                match (def, source) {\n+                    (Def::Macro(..), _) => {\n+                        err.span_label(span, &format!(\"did you mean `{}!(...)`?\", path_str));\n+                        return err;\n+                    }\n+                    (Def::TyAlias(..), PathSource::Trait) => {\n+                        err.span_label(span, &format!(\"type aliases cannot be used for traits\"));\n+                        return err;\n+                    }\n+                    (Def::Mod(..), PathSource::Expr(Some(parent))) => match *parent {\n+                        ExprKind::Field(_, ident) => {\n+                            err.span_label(span, &format!(\"did you mean `{}::{}`?\",\n+                                                           path_str, ident.node));\n+                            return err;\n+                        }\n+                        ExprKind::MethodCall(ident, ..) => {\n+                            err.span_label(span, &format!(\"did you mean `{}::{}(...)`?\",\n+                                                           path_str, ident.node));\n+                            return err;\n+                        }\n+                        _ => {}\n+                    },\n+                    _ if ns == ValueNS && is_struct_like(def) => {\n+                        err.span_label(span, &format!(\"did you mean `{} {{ /* fields */ }}`?\",\n+                                                       path_str));\n+                        return err;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            // Try Levenshtein if nothing else worked.\n+            if path.len() == 1 {\n+                if let Some(candidate) = this.lookup_typo_candidate(name, ns, is_expected) {\n+                    err.span_label(span, &format!(\"did you mean `{}`?\", candidate));\n+                    return err;\n+                }\n+            }\n+\n+            // Fallback labels.\n+            if def.is_some() {\n+                err.span_label(span, &format!(\"not a {}\", expected));\n+            } else {\n+                err.span_label(span, &format!(\"no resolution found\"));\n+            }\n+            err\n+        };\n+        let report_errors = |this: &mut Self, def: Option<Def>| {\n+            report_errors(this, def).emit();\n+            err_path_resolution()\n+        };\n+\n+        let resolution = match self.resolve_qpath_anywhere(id, qself, path, ns, span,\n+                                                           source.defer_to_typeck(),\n+                                                           source.global_by_default()) {\n+            Some(resolution) if resolution.depth == 0 => {\n+                if is_expected(resolution.base_def) || resolution.base_def == Def::Err {\n+                    resolution\n+                } else {\n+                    report_errors(self, Some(resolution.base_def))\n+                }\n+            }\n+            Some(resolution) if source.defer_to_typeck() => {\n+                // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n+                // or `<T>::A::B`. If `B` should be resolved in value namespace then\n+                // it needs to be added to the trait map.\n+                if ns == ValueNS {\n+                    let item_name = path.last().unwrap().name;\n+                    let traits = self.get_traits_containing_item(item_name, ns);\n+                    self.trait_map.insert(id, traits);\n+                }\n+                resolution\n+            }\n+            _ => report_errors(self, None)\n+        };\n+\n+        if let PathSource::TraitItem(..) = source {} else {\n+            // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n+            self.record_def(id, resolution);\n+        }\n+        resolution\n+    }\n+\n+    fn self_type_is_available(&mut self) -> bool {\n+        let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(), TypeNS, None);\n+        if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n+    }\n+\n+    fn self_value_is_available(&mut self, ctxt: SyntaxContext) -> bool {\n+        let ident = Ident { name: keywords::SelfValue.name(), ctxt: ctxt };\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None);\n+        if let Some(LexicalScopeBinding::Def(def)) = binding { def != Def::Err } else { false }\n+    }\n+\n+    // Resolve in alternative namespaces if resolution in the primary namespace fails.\n+    fn resolve_qpath_anywhere(&mut self,\n+                              id: NodeId,\n+                              qself: Option<&QSelf>,\n+                              path: &[Ident],\n+                              primary_ns: Namespace,\n+                              span: Span,\n+                              defer_to_typeck: bool,\n+                              global_by_default: bool)\n+                              -> Option<PathResolution> {\n+        let mut fin_res = None;\n+        // FIXME: can't resolve paths in macro namespace yet, macros are\n+        // processed by the little special hack below.\n+        for (i, ns) in [primary_ns, TypeNS, ValueNS, /*MacroNS*/].iter().cloned().enumerate() {\n+            if i == 0 || ns != primary_ns {\n+                match self.resolve_qpath(id, qself, path, ns, span, global_by_default) {\n+                    // If defer_to_typeck, then resolution > no resolution,\n+                    // otherwise full resolution > partial resolution > no resolution.\n+                    Some(res) if res.depth == 0 || defer_to_typeck => return Some(res),\n+                    res => if fin_res.is_none() { fin_res = res },\n+                };\n+            }\n+        }\n+        if primary_ns != MacroNS && path.len() == 1 &&\n+                self.macro_names.contains(&path[0].name) {\n+            // Return some dummy definition, it's enough for error reporting.\n+            return Some(PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX))));\n+        }\n+        fin_res\n+    }\n+\n+    /// Handles paths that may refer to associated items.\n+    fn resolve_qpath(&mut self,\n+                     id: NodeId,\n+                     qself: Option<&QSelf>,\n+                     path: &[Ident],\n+                     ns: Namespace,\n+                     span: Span,\n+                     global_by_default: bool)\n+                     -> Option<PathResolution> {\n+        if let Some(qself) = qself {\n             if qself.position == 0 {\n                 // FIXME: Create some fake resolution that can't possibly be a type.\n                 return Some(PathResolution {\n-                    base_def: Def::Mod(self.definitions.local_def_id(ast::CRATE_NODE_ID)),\n+                    base_def: Def::Mod(DefId::local(CRATE_DEF_INDEX)),\n                     depth: path.len(),\n                 });\n             }\n-            // Make sure the trait is valid.\n-            self.resolve_trait_reference(&path[..qself.position], None, span);\n+            // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n+            let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n+            let mut res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n+                                                           span, PathSource::TraitItem(ns));\n+            if res.base_def != Def::Err {\n+                res.depth += path.len() - qself.position - 1;\n+            }\n+            return Some(res);\n         }\n \n         let result = match self.resolve_path(&path, Some(ns), Some(span)) {\n-            PathResult::NonModule(path_res) => match path_res.base_def {\n-                Def::Trait(..) if maybe_qself.is_some() => return None,\n-                _ => path_res,\n-            },\n+            PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(module) if !module.is_normal() => {\n                 PathResolution::new(module.def().unwrap())\n             }\n@@ -2287,18 +2292,19 @@ impl<'a> Resolver<'a> {\n                        self.primitive_type_table.primitive_types.contains_key(&path[0].name) => {\n                 PathResolution {\n                     base_def: Def::PrimTy(self.primitive_type_table.primitive_types[&path[0].name]),\n-                    depth: segments.len() - 1,\n+                    depth: path.len() - 1,\n                 }\n             }\n             PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n             PathResult::Failed(msg, false) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 err_path_resolution()\n             }\n-            _ => return None,\n+            PathResult::Failed(..) => return None,\n+            PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n-        if path.len() == 1 || result.base_def == Def::Err {\n+        if path.len() == 1 || global_by_default || result.base_def == Def::Err {\n             return Some(result);\n         }\n \n@@ -2399,10 +2405,10 @@ impl<'a> Resolver<'a> {\n                     let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n-                            self.lookup_candidates(ident.name, TypeNS, is_mod).candidates;\n-                        candidates.sort_by_key(|path| (path.segments.len(), path.to_string()));\n+                            self.lookup_import_candidates(ident.name, TypeNS, is_mod);\n+                        candidates.sort_by_key(|c| (c.path.segments.len(), c.path.to_string()));\n                         if let Some(candidate) = candidates.get(0) {\n-                            format!(\"Did you mean `{}`?\", candidate)\n+                            format!(\"Did you mean `{}`?\", candidate.path)\n                         } else {\n                             format!(\"Maybe a missing `extern crate {};`?\", ident)\n                         }\n@@ -2420,15 +2426,15 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n-    fn adjust_local_def(&mut self, local_def: LocalDef, span: Span) -> Def {\n+    fn adjust_local_def(&mut self, local_def: LocalDef, record_used: Option<Span>) -> Def {\n         let ribs = match local_def.ribs {\n             Some((ns, i)) => &self.ribs[ns][i + 1..],\n             None => &[] as &[_],\n         };\n         let mut def = local_def.def;\n         match def {\n             Def::Upvar(..) => {\n-                span_bug!(span, \"unexpected {:?} in bindings\", def)\n+                span_bug!(record_used.unwrap_or(DUMMY_SP), \"unexpected {:?} in bindings\", def)\n             }\n             Def::Local(def_id) => {\n                 for rib in ribs {\n@@ -2451,28 +2457,32 @@ impl<'a> Resolver<'a> {\n                                           .entry(function_id)\n                                           .or_insert_with(|| vec![]);\n                             let depth = vec.len();\n-                            vec.push(Freevar {\n-                                def: prev_def,\n-                                span: span,\n-                            });\n-\n                             def = Def::Upvar(def_id, depth, function_id);\n-                            seen.insert(node_id, depth);\n+\n+                            if let Some(span) = record_used {\n+                                vec.push(Freevar {\n+                                    def: prev_def,\n+                                    span: span,\n+                                });\n+                                seen.insert(node_id, depth);\n+                            }\n                         }\n                         ItemRibKind | MethodRibKind(_) => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-                            resolve_error(self,\n-                                          span,\n-                                          ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n+                            if let Some(span) = record_used {\n+                                resolve_error(self, span,\n+                                        ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n+                            }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            resolve_error(self,\n-                                          span,\n-                                          ResolutionError::AttemptToUseNonConstantValueInConstant);\n+                            if let Some(span) = record_used {\n+                                resolve_error(self, span,\n+                                        ResolutionError::AttemptToUseNonConstantValueInConstant);\n+                            }\n                             return Def::Err;\n                         }\n                     }\n@@ -2488,15 +2498,18 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind => {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n-\n-                            resolve_error(self,\n-                                          span,\n-                                          ResolutionError::TypeParametersFromOuterFunction);\n+                            if let Some(span) = record_used {\n+                                resolve_error(self, span,\n+                                              ResolutionError::TypeParametersFromOuterFunction);\n+                            }\n                             return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            resolve_error(self, span, ResolutionError::OuterTypeParameterContext);\n+                            if let Some(span) = record_used {\n+                                resolve_error(self, span,\n+                                              ResolutionError::OuterTypeParameterContext);\n+                            }\n                             return Def::Err;\n                         }\n                     }\n@@ -2532,7 +2545,13 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n-    fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n+    fn lookup_assoc_candidate<FilterFn>(&mut self,\n+                                        name: Name,\n+                                        ns: Namespace,\n+                                        filter_fn: FilterFn)\n+                                        -> Option<AssocSuggestion>\n+        where FilterFn: Fn(Def) -> bool\n+    {\n         fn extract_node_id(t: &Ty) -> Option<NodeId> {\n             match t.node {\n                 TyKind::Path(None, _) => Some(t.id),\n@@ -2544,51 +2563,59 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n-            // Look for a field with the same name in the current self_type.\n-            if let Some(resolution) = self.def_map.get(&node_id) {\n-                match resolution.base_def {\n-                    Def::Struct(did) | Def::Union(did) if resolution.depth == 0 => {\n-                        if let Some(field_names) = self.field_names.get(&did) {\n-                            if field_names.iter().any(|&field_name| name == field_name) {\n-                                return Field;\n+        // Fields are generally expected in the same contexts as locals.\n+        if filter_fn(Def::Local(DefId::local(CRATE_DEF_INDEX))) {\n+            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n+                // Look for a field with the same name in the current self_type.\n+                if let Some(resolution) = self.def_map.get(&node_id) {\n+                    match resolution.base_def {\n+                        Def::Struct(did) | Def::Union(did) if resolution.depth == 0 => {\n+                            if let Some(field_names) = self.field_names.get(&did) {\n+                                if field_names.iter().any(|&field_name| name == field_name) {\n+                                    return Some(AssocSuggestion::Field);\n+                                }\n                             }\n                         }\n+                        _ => {}\n                     }\n-                    _ => {}\n                 }\n             }\n         }\n \n-        // Look for a method in the current trait.\n-        if let Some((trait_did, ref trait_ref)) = self.current_trait_ref {\n-            if let Some(&is_static_method) = self.trait_item_map.get(&(name, trait_did)) {\n-                if is_static_method {\n-                    return TraitMethod(path_names_to_string(&trait_ref.path, 0));\n-                } else {\n-                    return TraitItem;\n+        // Look for associated items in the current trait.\n+        if let Some((trait_did, _)) = self.current_trait_ref {\n+            if let Some(&(def, has_self)) = self.trait_item_map.get(&(trait_did, name, ns)) {\n+                if filter_fn(def) {\n+                    return Some(if has_self {\n+                        AssocSuggestion::MethodWithSelf\n+                    } else {\n+                        AssocSuggestion::AssocItem\n+                    });\n                 }\n             }\n         }\n \n-        NoSuggestion\n+        None\n     }\n \n-    fn find_best_match(&mut self, name: &str) -> SuggestionType {\n-        if let Some(macro_name) = self.macro_names.iter().find(|&n| n == &name) {\n-            return SuggestionType::Macro(format!(\"{}!\", macro_name));\n+    fn lookup_typo_candidate<FilterFn>(&mut self,\n+                                       name: Name,\n+                                       ns: Namespace,\n+                                       filter_fn: FilterFn)\n+                                       -> Option<Name>\n+        where FilterFn: Fn(Def) -> bool\n+    {\n+        // FIXME: bindings in ribs provide quite modest set of candidates,\n+        // extend it with other names in scope.\n+        let names = self.ribs[ns].iter().rev().flat_map(|rib| {\n+            rib.bindings.iter().filter_map(|(ident, def)| {\n+                if filter_fn(*def) { Some(&ident.name) } else { None }\n+            })\n+        });\n+        match find_best_match_for_name(names, &name.as_str(), None) {\n+            Some(found) if found != name => Some(found),\n+            _ => None,\n         }\n-\n-        let names = self.ribs[ValueNS]\n-                    .iter()\n-                    .rev()\n-                    .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n-\n-        if let Some(found) = find_best_match_for_name(names, name, None) {\n-            if found != name {\n-                return SuggestionType::Function(found);\n-            }\n-        } SuggestionType::NotFound\n     }\n \n     fn resolve_labeled_block(&mut self, label: Option<SpannedIdent>, id: NodeId, block: &Block) {\n@@ -2603,150 +2630,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n+    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&ExprKind>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n \n         self.record_candidate_traits_for_expr_if_necessary(expr);\n \n         // Next, resolve the node.\n         match expr.node {\n-            ExprKind::Path(ref maybe_qself, ref path) => {\n-                // This is a local path in the value namespace. Walk through\n-                // scopes looking for it.\n-                if let Some(path_res) = self.resolve_possibly_assoc_item(expr.id,\n-                                                            maybe_qself.as_ref(), path, ValueNS) {\n-                    // Check if struct variant\n-                    let is_struct_variant = match path_res.base_def {\n-                        Def::VariantCtor(_, CtorKind::Fictive) => true,\n-                        _ => false,\n-                    };\n-                    if is_struct_variant {\n-                        let path_name = path_names_to_string(path, 0);\n-\n-                        let mut err = resolve_struct_error(self,\n-                                        expr.span,\n-                                        ResolutionError::StructVariantUsedAsFunction(&path_name));\n-\n-                        let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n-                                          path_name);\n-                        err.help(&msg);\n-                        err.emit();\n-                        self.record_def(expr.id, err_path_resolution());\n-                    } else {\n-                        // Write the result into the def map.\n-                        debug!(\"(resolving expr) resolved `{}`\",\n-                               path_names_to_string(path, 0));\n-\n-                        // Partial resolutions will need the set of traits in scope,\n-                        // so they can be completed during typeck.\n-                        if path_res.depth != 0 {\n-                            let method_name = path.segments.last().unwrap().identifier.name;\n-                            let traits = self.get_traits_containing_item(method_name);\n-                            self.trait_map.insert(expr.id, traits);\n-                        }\n-\n-                        self.record_def(expr.id, path_res);\n-                    }\n-                } else {\n-                    // Be helpful if the name refers to a struct\n-                    let path_name = path_names_to_string(path, 0);\n-                    let path: Vec<_> = path.segments.iter().map(|seg| seg.identifier).collect();\n-                    let type_res = match self.resolve_path(&path, Some(TypeNS), None) {\n-                        PathResult::NonModule(type_res) => Some(type_res),\n-                        _ => None,\n-                    };\n-\n-                    self.record_def(expr.id, err_path_resolution());\n-\n-                    if let Some(Def::Struct(..)) = type_res.map(|r| r.base_def) {\n-                        let error_variant =\n-                            ResolutionError::StructVariantUsedAsFunction(&path_name);\n-                        let mut err = resolve_struct_error(self, expr.span, error_variant);\n-\n-                        let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n-                                          path_name);\n-\n-                        err.help(&msg);\n-                        err.emit();\n-                    } else {\n-                        // Keep reporting some errors even if they're ignored above.\n-                        let mut method_scope = false;\n-                        let mut is_static = false;\n-                        self.ribs[ValueNS].iter().rev().all(|rib| {\n-                            method_scope = match rib.kind {\n-                                MethodRibKind(is_static_) => {\n-                                    is_static = is_static_;\n-                                    true\n-                                }\n-                                ItemRibKind | ConstantItemRibKind => false,\n-                                _ => return true, // Keep advancing\n-                            };\n-                            false // Stop advancing\n-                        });\n-\n-                        if method_scope && keywords::SelfValue.name() == &*path_name {\n-                            let error = ResolutionError::SelfNotAvailableInStaticMethod;\n-                            resolve_error(self, expr.span, error);\n-                        } else {\n-                            let fallback =\n-                                self.find_fallback_in_self_type(path.last().unwrap().name);\n-                            let (mut msg, is_field) = match fallback {\n-                                NoSuggestion => {\n-                                    // limit search to 5 to reduce the number\n-                                    // of stupid suggestions\n-                                    (match self.find_best_match(&path_name) {\n-                                        SuggestionType::Macro(s) => {\n-                                            format!(\"the macro `{}`\", s)\n-                                        }\n-                                        SuggestionType::Function(s) => format!(\"`{}`\", s),\n-                                        SuggestionType::NotFound => \"\".to_string(),\n-                                    }, false)\n-                                }\n-                                Field => {\n-                                    (if is_static && method_scope {\n-                                        \"\".to_string()\n-                                    } else {\n-                                        format!(\"`self.{}`\", path_name)\n-                                    }, true)\n-                                }\n-                                TraitItem => (format!(\"to call `self.{}`\", path_name), false),\n-                                TraitMethod(path_str) =>\n-                                    (format!(\"to call `{}::{}`\", path_str, path_name), false),\n-                            };\n-\n-                            let mut context = UnresolvedNameContext::Other;\n-                            let mut def = Def::Err;\n-                            if !msg.is_empty() {\n-                                msg = format!(\"did you mean {}?\", msg);\n-                            } else {\n-                                // we display a help message if this is a module\n-                                if let PathResult::Module(module) =\n-                                        self.resolve_path(&path, None, None) {\n-                                    def = module.def().unwrap();\n-                                    context = UnresolvedNameContext::PathIsMod(parent);\n-                                }\n-                            }\n-\n-                            let error = ResolutionError::UnresolvedName {\n-                                path: &path_name,\n-                                message: &msg,\n-                                context: context,\n-                                is_static_method: method_scope && is_static,\n-                                is_field: is_field,\n-                                def: def,\n-                            };\n-                            resolve_error(self, expr.span, error);\n-                        }\n-                    }\n-                }\n-\n+            ExprKind::Path(ref qself, ref path) => {\n+                self.smart_resolve_path(expr.id, qself.as_ref(), path, PathSource::Expr(parent));\n                 visit::walk_expr(self, expr);\n             }\n \n             ExprKind::Struct(ref path, ..) => {\n-                self.resolve_struct_path(expr.id, path);\n-\n+                self.smart_resolve_path(expr.id, None, path, PathSource::Struct);\n                 visit::walk_expr(self, expr);\n             }\n \n@@ -2809,19 +2707,26 @@ impl<'a> Resolver<'a> {\n                 self.ribs[ValueNS].pop();\n             }\n \n+            // Equivalent to `visit::walk_expr` + passing some context to children.\n             ExprKind::Field(ref subexpression, _) => {\n-                self.resolve_expr(subexpression, Some(expr));\n+                self.resolve_expr(subexpression, Some(&expr.node));\n             }\n             ExprKind::MethodCall(_, ref types, ref arguments) => {\n                 let mut arguments = arguments.iter();\n-                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n+                self.resolve_expr(arguments.next().unwrap(), Some(&expr.node));\n                 for argument in arguments {\n                     self.resolve_expr(argument, None);\n                 }\n                 for ty in types.iter() {\n                     self.visit_ty(ty);\n                 }\n             }\n+            ExprKind::Call(ref callee, ref arguments) => {\n+                self.resolve_expr(callee, Some(&expr.node));\n+                for argument in arguments {\n+                    self.resolve_expr(argument, None);\n+                }\n+            }\n \n             _ => {\n                 visit::walk_expr(self, expr);\n@@ -2836,13 +2741,13 @@ impl<'a> Resolver<'a> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(name.node.name);\n+                let traits = self.get_traits_containing_item(name.node.name, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(name, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(name.node.name);\n+                let traits = self.get_traits_containing_item(name.node.name, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -2851,20 +2756,20 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_traits_containing_item(&mut self, name: Name) -> Vec<TraitCandidate> {\n+    fn get_traits_containing_item(&mut self, name: Name, ns: Namespace) -> Vec<TraitCandidate> {\n         debug!(\"(getting traits containing item) looking for '{}'\", name);\n \n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((trait_def_id, _)) = self.current_trait_ref {\n-            if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+            if self.trait_item_map.contains_key(&(trait_def_id, name, ns)) {\n                 found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: None });\n             }\n         }\n \n         let mut search_module = self.current_module;\n         loop {\n-            self.get_traits_in_module_containing_item(name, search_module, &mut found_traits);\n+            self.get_traits_in_module_containing_item(name, ns, search_module, &mut found_traits);\n             match search_module.kind {\n                 ModuleKind::Block(..) => search_module = search_module.parent.unwrap(),\n                 _ => break,\n@@ -2873,7 +2778,7 @@ impl<'a> Resolver<'a> {\n \n         if let Some(prelude) = self.prelude {\n             if !search_module.no_implicit_prelude {\n-                self.get_traits_in_module_containing_item(name, prelude, &mut found_traits);\n+                self.get_traits_in_module_containing_item(name, ns, prelude, &mut found_traits);\n             }\n         }\n \n@@ -2882,6 +2787,7 @@ impl<'a> Resolver<'a> {\n \n     fn get_traits_in_module_containing_item(&mut self,\n                                             name: Name,\n+                                            ns: Namespace,\n                                             module: Module,\n                                             found_traits: &mut Vec<TraitCandidate>) {\n         let mut traits = module.traits.borrow_mut();\n@@ -2898,7 +2804,7 @@ impl<'a> Resolver<'a> {\n \n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n             let trait_def_id = binding.def().def_id();\n-            if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+            if self.trait_item_map.contains_key(&(trait_def_id, name, ns)) {\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);\n@@ -2919,13 +2825,14 @@ impl<'a> Resolver<'a> {\n     ///\n     /// NOTE: The method does not look into imports, but this is not a problem,\n     /// since we report the definitions (thus, the de-aliased imports).\n-    fn lookup_candidates<FilterFn>(&mut self,\n-                                   lookup_name: Name,\n-                                   namespace: Namespace,\n-                                   filter_fn: FilterFn) -> SuggestedCandidates\n-        where FilterFn: Fn(Def) -> bool {\n-\n-        let mut lookup_results = Vec::new();\n+    fn lookup_import_candidates<FilterFn>(&mut self,\n+                                          lookup_name: Name,\n+                                          namespace: Namespace,\n+                                          filter_fn: FilterFn)\n+                                          -> Vec<ImportSuggestion>\n+        where FilterFn: Fn(Def) -> bool\n+    {\n+        let mut candidates = Vec::new();\n         let mut worklist = Vec::new();\n         let mut seen_modules = FxHashSet();\n         worklist.push((self.graph_root, Vec::new(), false));\n@@ -2939,6 +2846,8 @@ impl<'a> Resolver<'a> {\n \n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n+                // avoid non-importable candidates as well\n+                if !name_binding.is_importable() { return; }\n \n                 // collect results based on the filter function\n                 if ident.name == lookup_name && ns == namespace {\n@@ -2959,7 +2868,7 @@ impl<'a> Resolver<'a> {\n                         // declared as public (due to pruning, we don't explore\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n-                            lookup_results.push(path);\n+                            candidates.push(ImportSuggestion { path: path });\n                         }\n                     }\n                 }\n@@ -2981,50 +2890,40 @@ impl<'a> Resolver<'a> {\n             })\n         }\n \n-        SuggestedCandidates {\n-            name: lookup_name.as_str().to_string(),\n-            candidates: lookup_results,\n-        }\n+        candidates\n     }\n \n     fn record_def(&mut self, node_id: NodeId, resolution: PathResolution) {\n         debug!(\"(recording def) recording {:?} for {}\", resolution, node_id);\n+        assert!(resolution.depth == 0 || resolution.base_def != Def::Err);\n         if let Some(prev_res) = self.def_map.insert(node_id, resolution) {\n             panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n     }\n \n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n-        let (segments, span, id) = match *vis {\n-            ast::Visibility::Public => return ty::Visibility::Public,\n-            ast::Visibility::Crate(_) => {\n-                return ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-            }\n-            ast::Visibility::Restricted { ref path, id } => (&path.segments, path.span, id),\n+        match *vis {\n+            ast::Visibility::Public => ty::Visibility::Public,\n+            ast::Visibility::Crate(..) => ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n             ast::Visibility::Inherited => {\n-                return ty::Visibility::Restricted(self.current_module.normal_ancestor_id);\n-            }\n-        };\n-\n-        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n-        let mut path_resolution = err_path_resolution();\n-        let vis = match self.resolve_path(&path, None, Some(span)) {\n-            PathResult::Module(module) => {\n-                path_resolution = PathResolution::new(module.def().unwrap());\n-                ty::Visibility::Restricted(module.normal_ancestor_id)\n+                ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n-            PathResult::Failed(msg, _) => {\n-                self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n-                ty::Visibility::Public\n+            ast::Visibility::Restricted { ref path, id } => {\n+                let def = self.smart_resolve_path(id, None, path, PathSource::Visibility).base_def;\n+                if def == Def::Err {\n+                    ty::Visibility::Public\n+                } else {\n+                    let vis = ty::Visibility::Restricted(def.def_id());\n+                    if self.is_accessible(vis) {\n+                        vis\n+                    } else {\n+                        self.session.span_err(path.span, \"visibilities can only be restricted \\\n+                                                          to ancestor modules\");\n+                        ty::Visibility::Public\n+                    }\n+                }\n             }\n-            _ => ty::Visibility::Public,\n-        };\n-        self.def_map.insert(id, path_resolution);\n-        if !self.is_accessible(vis) {\n-            let msg = format!(\"visibilities can only be restricted to ancestor modules\");\n-            self.session.span_err(span, &msg);\n         }\n-        vis\n     }\n \n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n@@ -3175,79 +3074,72 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-fn names_to_string(names: &[Ident]) -> String {\n+fn is_struct_like(def: Def) -> bool {\n+    match def {\n+        Def::VariantCtor(_, CtorKind::Fictive) => true,\n+        _ => PathSource::Struct.is_expected(def),\n+    }\n+}\n+\n+fn is_self_type(path: &[Ident], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].name == keywords::SelfType.name()\n+}\n+\n+fn is_self_value(path: &[Ident], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].name == keywords::SelfValue.name()\n+}\n+\n+fn names_to_string(idents: &[Ident]) -> String {\n     let mut result = String::new();\n-    for (i, ident) in names.iter().enumerate() {\n+    for (i, ident) in idents.iter().filter(|i| i.name != keywords::CrateRoot.name()).enumerate() {\n         if i > 0 {\n             result.push_str(\"::\");\n         }\n-        if ident.name != keywords::CrateRoot.name() {\n-            result.push_str(&ident.name.as_str());\n-        }\n+        result.push_str(&ident.name.as_str());\n     }\n     result\n }\n \n-fn path_names_to_string(path: &Path, depth: usize) -> String {\n-    let names: Vec<_> =\n-        path.segments[..path.segments.len() - depth].iter().map(|seg| seg.identifier).collect();\n-    names_to_string(&names)\n+fn path_names_to_string(path: &Path) -> String {\n+    names_to_string(&path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>())\n }\n \n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n fn show_candidates(session: &mut DiagnosticBuilder,\n-                   candidates: &SuggestedCandidates) {\n-\n-    let paths = &candidates.candidates;\n-\n-    if paths.len() > 0 {\n-        // don't show more than MAX_CANDIDATES results, so\n-        // we're consistent with the trait suggestions\n-        const MAX_CANDIDATES: usize = 5;\n-\n-        // we want consistent results across executions, but candidates are produced\n-        // by iterating through a hash map, so make sure they are ordered:\n-        let mut path_strings: Vec<_> = paths.into_iter()\n-                                            .map(|p| path_names_to_string(&p, 0))\n-                                            .collect();\n-        path_strings.sort();\n-\n-        // behave differently based on how many candidates we have:\n-        if !paths.is_empty() {\n-            if paths.len() == 1 {\n-                session.help(\n-                    &format!(\"you can import it into scope: `use {};`.\",\n-                        &path_strings[0]),\n-                );\n-            } else {\n-                session.help(\"you can import several candidates \\\n-                    into scope (`use ...;`):\");\n-                let count = path_strings.len() as isize - MAX_CANDIDATES as isize + 1;\n-\n-                for (idx, path_string) in path_strings.iter().enumerate() {\n-                    if idx == MAX_CANDIDATES - 1 && count > 1 {\n-                        session.help(\n-                            &format!(\"  and {} other candidates\", count).to_string(),\n-                        );\n-                        break;\n-                    } else {\n-                        session.help(\n-                            &format!(\"  `{}`\", path_string).to_string(),\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    } else {\n-        // nothing found:\n-        session.help(\n-            &format!(\"no candidates by the name of `{}` found in your \\\n-            project; maybe you misspelled the name or forgot to import \\\n-            an external crate?\", candidates.name.to_string()),\n-        );\n+                   candidates: &[ImportSuggestion],\n+                   better: bool) {\n+    // don't show more than MAX_CANDIDATES results, so\n+    // we're consistent with the trait suggestions\n+    const MAX_CANDIDATES: usize = 5;\n+\n+    // we want consistent results across executions, but candidates are produced\n+    // by iterating through a hash map, so make sure they are ordered:\n+    let mut path_strings: Vec<_> =\n+        candidates.into_iter().map(|c| path_names_to_string(&c.path)).collect();\n+    path_strings.sort();\n+\n+    let better = if better { \"better \" } else { \"\" };\n+    let msg_diff = match path_strings.len() {\n+        1 => \" is found in another module, you can import it\",\n+        _ => \"s are found in other modules, you can import them\",\n     };\n+    session.help(&format!(\"possible {}candidate{} into scope:\", better, msg_diff));\n+\n+    let count = path_strings.len() as isize - MAX_CANDIDATES as isize + 1;\n+    for (idx, path_string) in path_strings.iter().enumerate() {\n+        if idx == MAX_CANDIDATES - 1 && count > 1 {\n+            session.help(\n+                &format!(\"  and {} other candidates\", count).to_string(),\n+            );\n+            break;\n+        } else {\n+            session.help(\n+                &format!(\"  `use {};`\", path_string).to_string(),\n+            );\n+        }\n+    }\n }\n \n /// A somewhat inefficient routine to obtain the name of a module."}, {"sha": "41d8f16b88dfd4849200d72eaf157f564c717e30", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -717,7 +717,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         // Record the destination of this import\n-        self.def_map.insert(directive.id, PathResolution::new(module.def().unwrap()));\n+        self.record_def(directive.id, PathResolution::new(module.def().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording reexports, reporting conflicts,"}, {"sha": "598003a3925127607c4347cf77c4e177ad4beb4e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1519,14 +1519,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.set_tainted_by_errors();\n                 return self.tcx().types.err;\n             }\n-            _ => {\n-                struct_span_err!(tcx.sess, span, E0248,\n-                           \"found value `{}` used as a type\",\n-                            tcx.item_path_str(path.def.def_id()))\n-                           .span_label(span, &format!(\"value used as a type\"))\n-                           .emit();\n-                return self.tcx().types.err;\n-            }\n+            _ => span_bug!(span, \"unexpected definition: {:?}\", path.def)\n         }\n     }\n "}, {"sha": "cea3ad43a95b84624b670df1f4e1f498ad2c7496", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -2861,25 +2861,6 @@ struct Bar<S, T> { x: Foo<S, T> }\n ```\n \"##,\n \n-E0248: r##\"\n-This error indicates an attempt to use a value where a type is expected. For\n-example:\n-\n-```compile_fail,E0248\n-enum Foo {\n-    Bar(u32)\n-}\n-\n-fn do_something(x: Foo::Bar) { }\n-```\n-\n-In this example, we're attempting to take a type of `Foo::Bar` in the\n-do_something function. This is not legal: `Foo::Bar` is a value of type `Foo`,\n-not a distinct static type. Likewise, it's not legal to attempt to\n-`impl Foo::Bar`: instead, you must `impl Foo` and then pattern match to specify\n-behavior for specific enum variants.\n-\"##,\n-\n E0569: r##\"\n If an impl has a generic parameter with the `#[may_dangle]` attribute, then\n that impl must be declared as an `unsafe impl. For example:\n@@ -4247,6 +4228,7 @@ register_diagnostics! {\n     E0245, // not a trait\n //  E0246, // invalid recursive type\n //  E0247,\n+//  E0248, // value used as a type, now reported earlier during resolution as E0412\n //  E0249,\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck"}, {"sha": "b0a2859a5dacb0032e8ad4426a16fbf72517e0a1", "filename": "src/test/compile-fail-fulldeps/macro-crate-doesnt-resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,5 +14,5 @@\n extern crate macro_crate_test;\n \n fn main() {\n-    macro_crate_test::foo(); //~ ERROR unresolved name\n+    macro_crate_test::foo(); //~ ERROR unresolved function `macro_crate_test::foo`\n }"}, {"sha": "149985717c6e011c9c4306f9ff1b662c881ddd06", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -39,6 +39,6 @@ fn main() {\n \n     assert_eq!(pprust::expr_to_string(&*quote_expr!(&cx, 23)), \"23\");\n \n-    let expr = quote_expr!(&cx, 2 - $abcd + 7); //~ ERROR unresolved name `abcd`\n+    let expr = quote_expr!(&cx, 2 - $abcd + 7); //~ ERROR unresolved value `abcd`\n     assert_eq!(pprust::expr_to_string(&*expr), \"2 - $abcd + 7\");\n }"}, {"sha": "03d47472093924f22e9212d7a1186f6b7bb148d3", "filename": "src/test/compile-fail/E0033.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2FE0033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2FE0033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0033.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,8 +14,8 @@ trait SomeTrait {\n \n fn main() {\n     let trait_obj: &SomeTrait = SomeTrait;\n-    //~^ ERROR E0425\n-    //~| NOTE unresolved name\n+    //~^ ERROR expected value, found trait `SomeTrait`\n+    //~| NOTE not a value\n     //~| ERROR E0038\n     //~| method `foo` has no receiver\n     //~| NOTE the trait `SomeTrait` cannot be made into an object"}, {"sha": "f5fea77cf9639a001500ece7b31521280b88a88e", "filename": "src/test/compile-fail/E0423.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2FE0423.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2FE0423.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0423.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -12,5 +12,4 @@ fn main () {\n     struct Foo { a: bool };\n \n     let f = Foo(); //~ ERROR E0423\n-                   //~^ struct called like a function\n }"}, {"sha": "445d0c5f3edc0db383c7925cdc243d22b23eab57", "filename": "src/test/compile-fail/E0424.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2FE0424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2FE0424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0424.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,10 +14,7 @@ impl Foo {\n     fn bar(self) {}\n \n     fn foo() {\n-        self.bar();\n-        //~^ ERROR `self` is not available in a static method [E0424]\n-        //~| NOTE not available in static method\n-        //~| NOTE maybe a `self` argument is missing?\n+        self.bar(); //~ ERROR E0424\n     }\n }\n "}, {"sha": "3786282031f25b306971b60c593cc4b0f1ff5562", "filename": "src/test/compile-fail/E0425.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2FE0425.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2FE0425.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0425.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     fn bar() {\n-        Self; //~ ERROR E0425\n+        elf; //~ ERROR E0425\n     }\n }\n "}, {"sha": "0295d4248e545c2fb31a8f32c496ef6513d38dd7", "filename": "src/test/compile-fail/associated-path-shl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fassociated-path-shl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fassociated-path-shl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-path-shl.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -11,10 +11,10 @@\n // Check that associated paths starting with `<<` are successfully parsed.\n \n fn main() {\n-    let _: <<A>::B>::C; //~ ERROR type name `A` is undefined or not in scope\n-    let _ = <<A>::B>::C; //~ ERROR type name `A` is undefined or not in scope\n-    let <<A>::B>::C; //~ ERROR type name `A` is undefined or not in scope\n-    let 0 ... <<A>::B>::C; //~ ERROR type name `A` is undefined or not in scope\n+    let _: <<A>::B>::C; //~ ERROR unresolved type `A`\n+    let _ = <<A>::B>::C; //~ ERROR unresolved type `A`\n+    let <<A>::B>::C; //~ ERROR unresolved type `A`\n+    let 0 ... <<A>::B>::C; //~ ERROR unresolved type `A`\n                            //~^ ERROR only char and numeric types are allowed in range patterns\n-    <<A>::B>::C; //~ ERROR type name `A` is undefined or not in scope\n+    <<A>::B>::C; //~ ERROR unresolved type `A`\n }"}, {"sha": "46d5633c8dd6132ec48d8d01ae1216dfdf8ad893", "filename": "src/test/compile-fail/associated-types-eq-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -17,7 +17,7 @@ pub trait Foo {\n }\n \n fn foo2<I: Foo>(x: I) {\n-    let _: A = x.boo(); //~ERROR undefined or not in scope\n+    let _: A = x.boo(); //~ ERROR unresolved type `A`\n }\n \n pub fn main() {}"}, {"sha": "5e3cb606ce0371f258c77d2ec1576f398f29addd", "filename": "src/test/compile-fail/auxiliary/lint_stability.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -132,6 +132,10 @@ pub struct UnstableStruct {\n pub struct StableStruct {\n     #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: isize\n }\n+#[unstable(feature = \"test_feature\", issue = \"0\")]\n+pub enum UnstableEnum {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum StableEnum {}\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]"}, {"sha": "05400a0eb657798b5be62788c85f4c3c2e0f7fba", "filename": "src/test/compile-fail/bad-expr-path.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name `m1::arguments`\n-\n mod m1 {}\n \n-fn main(arguments: Vec<String>) { log(debug, m1::arguments); }\n+fn main(arguments: Vec<String>) { //~ ERROR main function has wrong type\n+    log(debug, m1::arguments);\n+    //~^ ERROR unresolved function `log`\n+    //~| ERROR unresolved value `debug`\n+    //~| ERROR unresolved value `m1::arguments`\n+}"}, {"sha": "867166134b294f107178a845f677f882ddf11cec", "filename": "src/test/compile-fail/bad-expr-path2.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-expr-path2.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name `m1::arguments`\n-\n mod m1 {\n     pub mod arguments {}\n }\n \n-fn main(arguments: Vec<String>) {\n+fn main(arguments: Vec<String>) { //~ ERROR main function has wrong type\n     log(debug, m1::arguments);\n+    //~^ ERROR unresolved function `log`\n+    //~| ERROR unresolved value `debug`\n+    //~| ERROR expected value, found module `m1::arguments`\n }"}, {"sha": "cab46ec1fbf22e5359cebc23adaa64d65d96f828", "filename": "src/test/compile-fail/class-missing-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -16,8 +16,8 @@ impl cat {\n     fn sleep(&self) { loop{} }\n     fn meow(&self) {\n       println!(\"Meow\");\n-      meows += 1; //~ ERROR unresolved name\n-      sleep();     //~ ERROR unresolved name\n+      meows += 1; //~ ERROR unresolved value `meows`\n+      sleep();     //~ ERROR unresolved function `sleep`\n     }\n \n }"}, {"sha": "7c7782b9b443f0733469429755753940dc34518f", "filename": "src/test/compile-fail/coherence-error-suppression.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fcoherence-error-suppression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fcoherence-error-suppression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-error-suppression.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -16,7 +16,7 @@ impl Foo for i8 {}\n impl Foo for i16 {}\n impl Foo for i32 {}\n impl Foo for i64 {}\n-impl Foo for DoesNotExist {} //~ ERROR `DoesNotExist` is undefined\n+impl Foo for DoesNotExist {} //~ ERROR unresolved type `DoesNotExist`\n impl Foo for u8 {}\n impl Foo for u16 {}\n impl Foo for u32 {}"}, {"sha": "2a294a4e31f5e11f6977e7f86de60c554d0e8f08", "filename": "src/test/compile-fail/derived-errors/issue-31997.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -20,7 +20,7 @@ fn closure<F, T>(x: F) -> Result<T, ()>\n }\n \n fn foo() -> Result<(), ()> {\n-    try!(closure(|| bar(0 as *mut _))); //~ ERROR unresolved name `bar`\n+    try!(closure(|| bar(0 as *mut _))); //~ ERROR unresolved function `bar`\n     Ok(())\n }\n "}, {"sha": "96e14d2fb221b2ef884c938e41c976655802c894", "filename": "src/test/compile-fail/does-nothing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name `this_does_nothing_what_the`\n fn main() { println!(\"doing\"); this_does_nothing_what_the; println!(\"boing\"); }\n+//~^ ERROR unresolved value `this_does_nothing_what_the`"}, {"sha": "d4e85e9744d649b29bc50fd65f3630adfb3a90bd", "filename": "src/test/compile-fail/empty-struct-braces-expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -22,13 +22,13 @@ enum E {\n }\n \n fn main() {\n-    let e1 = Empty1; //~ ERROR `Empty1` is the name of a struct or struct variant\n-    let e1 = Empty1(); //~ ERROR `Empty1` is the name of a struct or struct variant\n-    let e3 = E::Empty3; //~ ERROR `E::Empty3` is the name of a struct or struct variant\n-    let e3 = E::Empty3(); //~ ERROR `E::Empty3` is the name of a struct or struct variant\n+    let e1 = Empty1; //~ ERROR expected value, found struct `Empty1`\n+    let e1 = Empty1(); //~ ERROR expected function, found struct `Empty1`\n+    let e3 = E::Empty3; //~ ERROR expected value, found struct variant `E::Empty3`\n+    let e3 = E::Empty3(); //~ ERROR expected function, found struct variant `E::Empty3`\n \n-    let xe1 = XEmpty1; //~ ERROR `XEmpty1` is the name of a struct or struct variant\n-    let xe1 = XEmpty1(); //~ ERROR `XEmpty1` is the name of a struct or struct variant\n+    let xe1 = XEmpty1; //~ ERROR expected value, found struct `XEmpty1`\n+    let xe1 = XEmpty1(); //~ ERROR expected function, found struct `XEmpty1`\n     let xe3 = XE::Empty3; //~ ERROR no associated item named `Empty3` found for type\n     let xe3 = XE::Empty3(); //~ ERROR no associated item named `Empty3` found for type\n }"}, {"sha": "d3b13457dc62b878cc6bfef5255f621178442311", "filename": "src/test/compile-fail/empty-struct-braces-pat-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -22,15 +22,15 @@ fn main() {\n     let xe1 = XEmpty1 {};\n \n     match e1 {\n-        Empty1() => () //~ ERROR unresolved tuple struct/variant `Empty1`\n+        Empty1() => () //~ ERROR expected tuple struct/variant, found struct `Empty1`\n     }\n     match xe1 {\n-        XEmpty1() => () //~ ERROR unresolved tuple struct/variant `XEmpty1`\n+        XEmpty1() => () //~ ERROR expected tuple struct/variant, found struct `XEmpty1`\n     }\n     match e1 {\n-        Empty1(..) => () //~ ERROR unresolved tuple struct/variant `Empty1`\n+        Empty1(..) => () //~ ERROR expected tuple struct/variant, found struct `Empty1`\n     }\n     match xe1 {\n-        XEmpty1(..) => () //~ ERROR unresolved tuple struct/variant `XEmpty1`\n+        XEmpty1(..) => () //~ ERROR expected tuple struct/variant, found struct `XEmpty1`\n     }\n }"}, {"sha": "258bfd1e3ba9246412ec8eb92161d6353002bb3b", "filename": "src/test/compile-fail/enum-variant-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,6 +14,6 @@ enum Foo {\n     Bar\n }\n \n-fn foo(x: Foo::Bar) {} //~ERROR found value `Foo::Bar` used as a type\n+fn foo(x: Foo::Bar) {} //~ ERROR expected type, found variant `Foo::Bar`\n \n fn main() {}"}, {"sha": "19fa13f8377dbc81845d1913eb7522964db26457", "filename": "src/test/compile-fail/export-fully-qualified.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: failed to resolve. Use of undeclared type or module `foo`\n-\n // In this test baz isn't resolved when called as foo.baz even though\n // it's called from inside foo. This is somewhat surprising and may\n // want to change eventually.\n \n mod foo {\n-    pub fn bar() { foo::baz(); }\n+    pub fn bar() { foo::baz(); } //~ ERROR failed to resolve. Use of undeclared type or module `foo`\n \n     fn baz() { }\n }"}, {"sha": "a412cac699f628081890083911278ee09113be31", "filename": "src/test/compile-fail/export.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name\n mod foo {\n     pub fn x(y: isize) { log(debug, y); }\n+    //~^ ERROR unresolved function `log`\n+    //~| ERROR unresolved value `debug`\n     fn z(y: isize) { log(debug, y); }\n+    //~^ ERROR unresolved function `log`\n+    //~| ERROR unresolved value `debug`\n }\n \n-fn main() { foo::z(10); }\n+fn main() { foo::z(10); } //~ ERROR function `z` is private"}, {"sha": "dc96ce7f504964b14ceab88bd1ee73ffac39d4d1", "filename": "src/test/compile-fail/export2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport2.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: failed to resolve. Use of undeclared type or module `bar`\n-\n mod foo {\n-    pub fn x() { bar::x(); }\n+    pub fn x() { bar::x(); } //~ ERROR failed to resolve. Use of undeclared type or module `bar`\n }\n \n mod bar {"}, {"sha": "0f8ad8d53882297bff9e3407be25c186e16b0463", "filename": "src/test/compile-fail/extern-with-type-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -24,7 +24,7 @@ extern \"rust-intrinsic\" {\n \n     // Unresolved bounds should still error.\n     fn align_of<T: NoSuchTrait>() -> usize;\n-    //~^ ERROR trait `NoSuchTrait` is not in scope\n+    //~^ ERROR unresolved trait `NoSuchTrait`\n }\n \n fn main() {}"}, {"sha": "a051789ec9842bc0d4ab9f0924c10affdd0e9fd0", "filename": "src/test/compile-fail/for-expn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Ffor-expn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Ffor-expn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-expn.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     // Odd formatting to make sure we get the right span.\n     for t in &\n-      foo //~ ERROR unresolved name `foo`\n+      foo //~ ERROR unresolved value `foo`\n     {\n     }\n }"}, {"sha": "2135ad6e73c49b9f915d2df0125ebc8812305a2d", "filename": "src/test/compile-fail/for-loop-hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-hygiene.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -13,6 +13,6 @@\n \n fn main() {\n     for _ in 0..10 {\n-        iter.next();  //~ error: unresolved name `iter`\n+        iter.next();  //~ ERROR unresolved value `iter`\n     }\n }"}, {"sha": "58e677965867bd8ac2cb3dc6f26cc08d3645a964", "filename": "src/test/compile-fail/glob-resolve1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fglob-resolve1.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -29,13 +29,13 @@ mod bar {\n fn foo<T>() {}\n \n fn main() {\n-    fpriv(); //~ ERROR: unresolved\n-    epriv(); //~ ERROR: unresolved\n-    B; //~ ERROR: unresolved\n-    C; //~ ERROR: unresolved\n-    import(); //~ ERROR: unresolved\n-\n-    foo::<A>(); //~ ERROR: not in scope\n-    foo::<C>(); //~ ERROR: not in scope\n-    foo::<D>(); //~ ERROR: not in scope\n+    fpriv(); //~ ERROR unresolved function `fpriv`\n+    epriv(); //~ ERROR unresolved function `epriv`\n+    B; //~ ERROR expected value, found enum `B`\n+    C; //~ ERROR unresolved value `C`\n+    import(); //~ ERROR: unresolved function `import`\n+\n+    foo::<A>(); //~ ERROR: unresolved type `A`\n+    foo::<C>(); //~ ERROR: unresolved type `C`\n+    foo::<D>(); //~ ERROR: unresolved type `D`\n }"}, {"sha": "12e45cfa2cbef3f380d8e74e4aae560a745d7d19", "filename": "src/test/compile-fail/import-glob-0.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name\n-\n use module_of_many_things::*;\n \n mod module_of_many_things {\n@@ -23,6 +21,6 @@ mod module_of_many_things {\n fn main() {\n     f1();\n     f2();\n-    f999(); // 'export' currently doesn't work?\n+    f999(); //~ ERROR unresolved function `f999`\n     f4();\n }"}, {"sha": "b7797cf5b367ae9899ce818ee26a1aa24e767819", "filename": "src/test/compile-fail/issue-1476.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1476.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    println!(\"{}\", x); //~ ERROR unresolved name `x`\n+    println!(\"{}\", x); //~ ERROR unresolved value `x`\n }"}, {"sha": "4e77636b3797bd23a1ac975bfa78f96a2e72d62f", "filename": "src/test/compile-fail/issue-15167.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -11,10 +11,10 @@\n // macro f should not be able to inject a reference to 'n'.\n \n macro_rules! f { () => (n) }\n-//~^ ERROR unresolved name `n`\n-//~| ERROR unresolved name `n`\n-//~| ERROR unresolved name `n`\n-//~| ERROR unresolved name `n`\n+//~^ ERROR unresolved value `n`\n+//~| ERROR unresolved value `n`\n+//~| ERROR unresolved value `n`\n+//~| ERROR unresolved value `n`\n \n fn main() -> (){\n     for n in 0..1 {"}, {"sha": "fe125b973d9bd72de187129c9716ad3610972e38", "filename": "src/test/compile-fail/issue-17546.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-17546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-17546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17546.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -20,7 +20,7 @@ mod foo {\n     }\n \n     fn new() -> NoResult<MyEnum, String> {\n-        //~^ ERROR: found value `foo::MyEnum::NoResult` used as a type\n+        //~^ ERROR expected type, found variant `NoResult`\n         unimplemented!()\n     }\n }\n@@ -30,18 +30,18 @@ mod bar {\n     use foo;\n \n     fn new() -> Result<foo::MyEnum, String> {\n-        //~^ ERROR: found value `foo::MyEnum::Result` used as a type\n+        //~^ ERROR expected type, found variant `Result`\n         unimplemented!()\n     }\n }\n \n fn new() -> Result<foo::MyEnum, String> {\n-    //~^ ERROR: found value `foo::MyEnum::Result` used as a type\n+    //~^ ERROR expected type, found variant `Result`\n     unimplemented!()\n }\n \n fn newer() -> NoResult<foo::MyEnum, String> {\n-    //~^ ERROR: found value `foo::MyEnum::NoResult` used as a type\n+    //~^ ERROR expected type, found variant `NoResult`\n     unimplemented!()\n }\n "}, {"sha": "1611cc418fb11d59e9ac4050dcb518ef66b48a75", "filename": "src/test/compile-fail/issue-18058.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-18058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-18058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18058.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n impl Undefined {}\n-//~^ ERROR type name `Undefined` is undefined or not in scope\n+//~^ ERROR unresolved type `Undefined`\n \n fn main() {}"}, {"sha": "412f7566f472be63fddb7e1c59101f486043eb4a", "filename": "src/test/compile-fail/issue-18119.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-18119.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-18119.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18119.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -13,10 +13,10 @@ static Y: u8 = 1;\n fn foo() {}\n \n impl X {}\n-//~^ ERROR type name `X` is undefined or not in scope\n+//~^ ERROR expected type, found constant `X`\n impl Y {}\n-//~^ ERROR type name `Y` is undefined or not in scope\n+//~^ ERROR expected type, found static `Y`\n impl foo {}\n-//~^ ERROR type name `foo` is undefined or not in scope\n+//~^ ERROR expected type, found function `foo`\n \n fn main() {}"}, {"sha": "6fc5fa03c58c2681811e68e67897f1998618b246", "filename": "src/test/compile-fail/issue-19883.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19883.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -17,7 +17,7 @@ trait From<Src> {\n trait To: Sized {\n     fn to<Dst: From<Self>>(self) ->\n         <Dst as From<Self>>::Dst\n-        //~^ ERROR associated type `From::Dst` is undefined or not in scope\n+        //~^ ERROR unresolved associated type `From::Dst`\n     {\n         From::from(self)\n     }"}, {"sha": "2a81b55dc7be87e995efc8e98e40a581c2334f03", "filename": "src/test/compile-fail/issue-22037.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-22037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-22037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22037.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -11,7 +11,7 @@\n trait A {\n     type Output;\n     fn a(&self) -> <Self as A>::X;\n-//~^ ERROR: associated type `A::X` is undefined or not in scope\n+    //~^ ERROR unresolved associated type `A::X`\n }\n \n impl A for u32 {"}, {"sha": "ad42a7e4a97458f132d6edcf48019221b362e2e2", "filename": "src/test/compile-fail/issue-22384.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-22384.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-22384.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22384.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,5 +14,5 @@ trait Trait {\n \n fn main() {\n     <<i32 as Copy>::foobar as Trait>::foo();\n-    //~^ ERROR associated type `Copy::foobar` is undefined or not in scope\n+    //~^ ERROR unresolved associated type `Copy::foobar`\n }"}, {"sha": "8d21650ed6f33d0c370ce2fd3cc8dd78166af68c", "filename": "src/test/compile-fail/issue-2281-part1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2281-part1.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,6 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name `foobar`\n-\n-fn main() { println!(\"{}\", foobar); }\n+fn main() { println!(\"{}\", foobar); } //~ ERROR unresolved value `foobar`"}, {"sha": "f1a282695ac11f70c2985edeb788835b161808a8", "filename": "src/test/compile-fail/issue-2330.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2330.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -15,7 +15,7 @@ trait channel<T> {\n }\n \n // `chan` is not a trait, it's an enum\n-impl chan for isize { //~ ERROR `chan` is not a trait\n+impl chan for isize { //~ ERROR expected trait, found enum `chan`\n     fn send(&self, v: isize) { panic!() }\n }\n "}, {"sha": "334fdee00a0e72883a9000a569007dd40faf85f8", "filename": "src/test/compile-fail/issue-28388-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -10,8 +10,6 @@\n \n // Prefix in imports with empty braces should be resolved and checked privacy, stability, etc.\n \n-use foo::{};\n-//~^ ERROR failed to resolve. Maybe a missing `extern crate foo;`?\n-//~| NOTE foo\n+use foo::{}; //~ ERROR unresolved module or enum `foo`\n \n fn main() {}"}, {"sha": "12357779b5171e3b7ae5e5a144f0621edf43dcdf", "filename": "src/test/compile-fail/issue-28388-3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-28388-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-28388-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28388-3.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,8 +14,7 @@\n \n extern crate lint_stability;\n \n-use lint_stability::UnstableStruct::{};\n-//~^ ERROR use of unstable library feature 'test_feature'\n-use lint_stability::StableStruct::{}; // OK\n+use lint_stability::UnstableEnum::{}; //~ ERROR use of unstable library feature 'test_feature'\n+use lint_stability::StableEnum::{}; // OK\n \n fn main() {}"}, {"sha": "90f5220a623af856d8c14b33634906abdc9f55ca", "filename": "src/test/compile-fail/issue-30535.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-30535.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-30535.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30535.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -13,7 +13,7 @@\n extern crate issue_30535 as foo;\n \n fn bar(\n-    _: foo::Foo::FooV //~ ERROR value `foo::Foo::FooV` used as a type\n+    _: foo::Foo::FooV //~ ERROR expected type, found variant `foo::Foo::FooV`\n ) {}\n \n fn main() {}"}, {"sha": "dd5fac9bed13c8292b5018f2864254f768fe34ba", "filename": "src/test/compile-fail/issue-30589.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-30589.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-30589.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30589.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -10,7 +10,7 @@\n \n use std::fmt;\n \n-impl fmt::Display for DecoderError { //~ ERROR E0412\n+impl fmt::Display for DecoderError { //~ ERROR unresolved type `DecoderError`\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Missing data: {}\", self.0)\n     }"}, {"sha": "32e004af1f3d7a4e13adc5abd9c3b1f3cedc5d39", "filename": "src/test/compile-fail/issue-31845.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-31845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-31845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31845.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,7 +14,7 @@ fn f() {\n     fn g() {}\n     mod foo {\n         fn h() {\n-           g(); //~ ERROR unresolved name\n+           g(); //~ ERROR unresolved function `g`\n         }\n     }\n }"}, {"sha": "fa672557c5ed033b53dd822969c36cb8e75740fb", "filename": "src/test/compile-fail/issue-34334.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-34334.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-34334.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34334.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -11,5 +11,5 @@\n fn main () {\n     let sr: Vec<(u32, _, _) = vec![]; //~ ERROR expected one of `+`, `,`, or `>`, found `=`\n     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n-    //~^ ERROR unresolved name `sr`\n+    //~^ ERROR unresolved value `sr`\n }"}, {"sha": "39d06312aa791611fb311319a68437dc84640fc7", "filename": "src/test/compile-fail/issue-35075.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-35075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-35075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35075.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n struct Bar<T> {\n-    inner: Foo<T> //~ ERROR type name `Foo` is undefined or not in scope\n+    inner: Foo<T> //~ ERROR unresolved type `Foo`\n }\n \n enum Baz<T> {\n-    Foo(Foo<T>) //~ ERROR type name `Foo` is undefined or not in scope\n+    Foo(Foo<T>) //~ ERROR unresolved type `Foo`\n }\n \n fn main() {}"}, {"sha": "1a6d92166d7c0769df03b446b822537520c71593", "filename": "src/test/compile-fail/issue-37534.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-37534.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-37534.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37534.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n struct Foo<T: ?Hash> { }\n-//~^ ERROR trait `Hash` is not in scope [E0405]\n-//~^^ ERROR parameter `T` is never used [E0392]\n+//~^ ERROR unresolved trait `Hash`\n+//~^^ ERROR parameter `T` is never used\n //~^^^ WARN default bound relaxed for a type parameter, but this does nothing\n \n fn main() { }"}, {"sha": "687720a130c9977edfc9c754618960ce26ca4a3a", "filename": "src/test/compile-fail/issue-4366-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-4366-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-4366-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4366-2.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -23,7 +23,7 @@ mod a {\n     pub mod sub {\n         use a::b::*;\n         fn sub() -> bar { 1 }\n-        //~^ ERROR: type name `bar` is undefined or not in scope\n+        //~^ ERROR unresolved type `bar`\n     }\n }\n \n@@ -32,5 +32,5 @@ mod m1 {\n }\n \n fn main() {\n-    foo(); //~ ERROR: unresolved name\n+    foo(); //~ ERROR expected function, found module `foo`\n }"}, {"sha": "18e55ee3c2a6278059e47ff1533ab657d86a8374", "filename": "src/test/compile-fail/issue-4366.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-4366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-4366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4366.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -25,7 +25,7 @@ mod a {\n     }\n     pub mod sub {\n         use a::b::*;\n-        fn sub() -> isize { foo(); 1 } //~ ERROR: unresolved name `foo`\n+        fn sub() -> isize { foo(); 1 } //~ ERROR unresolved function `foo`\n     }\n }\n "}, {"sha": "e78b54bd411fb1bff3bf067e1bbf66e8276f421e", "filename": "src/test/compile-fail/issue-5099.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-5099.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-5099.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5099.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n \n-trait B < A > { fn a() -> A { this.a } } //~ ERROR unresolved name\n+trait B < A > { fn a() -> A { this.a } } //~ ERROR unresolved value `this`\n \n fn main() {}"}, {"sha": "c421dbd1eb3c8b7e8748d9e1d642cfefef05f71d", "filename": "src/test/compile-fail/issue-5927.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -12,7 +12,7 @@\n fn main() {\n     let z = match 3 {\n         x(1) => x(1) //~ ERROR unresolved tuple struct/variant `x`\n-        //~^ ERROR unresolved name `x`\n+        //~^ ERROR unresolved function `x`\n     };\n     assert!(z == 3);\n }"}, {"sha": "e7b7decbdb073b6752c312ed12c1cd5e77cf92cd", "filename": "src/test/compile-fail/issue-7607-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -12,7 +12,7 @@ struct Foo {\n     x: isize\n }\n \n-impl Fo { //~ ERROR type name `Fo` is undefined or not in scope\n+impl Fo { //~ ERROR unresolved type `Fo`\n     fn foo() {}\n }\n "}, {"sha": "318eab92252859c1b34ef0130249a24866d19f37", "filename": "src/test/compile-fail/issue-8767.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-impl B { //~ ERROR type name `B` is undefined or not in scope\n+impl B { //~ ERROR unresolved type `B`\n }\n \n fn main() {"}, {"sha": "62649ba8a0fe1e364cdca2e26c02939d9ea5d687", "filename": "src/test/compile-fail/keyword-super-as-identifier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fkeyword-super-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fkeyword-super-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-super-as-identifier.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let super = \"foo\"; //~ ERROR unresolved unit struct/variant or constant `super`\n+    let super = \"foo\"; //~ ERROR failed to resolve. There are too many initial `super`s\n }"}, {"sha": "02047bd639ff919df011aba842d568ebdbd2fedf", "filename": "src/test/compile-fail/keyword-super.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fkeyword-super.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fkeyword-super.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-super.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let super: isize; //~ ERROR unresolved unit struct/variant or constant `super`\n+    let super: isize; //~ ERROR failed to resolve. There are too many initial `super`s\n }"}, {"sha": "70a50d83904d7af6e997cd98092c0da54a8b4153", "filename": "src/test/compile-fail/macro-outer-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -25,6 +25,6 @@ test!(b,\n // test1!(#[bar])\n #[qux]\n fn main() {\n-    a::bar(); //~ ERROR unresolved name `a::bar`\n+    a::bar(); //~ ERROR unresolved function `a::bar`\n     b::bar();\n }"}, {"sha": "dc5a2deab42b251483e090662599194884d3f1a3", "filename": "src/test/compile-fail/macro-parameter-span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmacro-parameter-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmacro-parameter-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-parameter-span.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -18,6 +18,6 @@ macro_rules! foo {\n // not to the macro variable '$id'\n fn main() {\n     foo!(\n-        x //~ ERROR unresolved name `x`\n+        x //~ ERROR unresolved value `x`\n         );\n }"}, {"sha": "3f6304db957bf6805231c48e2504dd3d2f2cecc8", "filename": "src/test/compile-fail/match-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-join.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -16,6 +16,6 @@ fn my_panic() -> ! { panic!(); }\n fn main() {\n     match true { false => { my_panic(); } true => { } }\n \n-    println!(\"{}\", x); //~ ERROR unresolved name `x`\n+    println!(\"{}\", x); //~ ERROR unresolved value `x`\n     let x: isize;\n }"}, {"sha": "4cf8eea78cfa7dce62af1d1cd5fdc6ec1fc12937", "filename": "src/test/compile-fail/match-vec-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -34,7 +34,7 @@ fn main() {\n         [0, 1, 2, 3, x..] => {} //~ ERROR pattern requires\n     };\n \n-    match does_not_exist { //~ ERROR unresolved name\n+    match does_not_exist { //~ ERROR unresolved value `does_not_exist`\n         [] => {}\n     };\n }"}, {"sha": "c64b22a7f415a50eba24d8f70ec0b5ae844adff6", "filename": "src/test/compile-fail/mod_file_correct_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -13,5 +13,5 @@\n mod mod_file_aux;\n \n fn main() {\n-    assert!(mod_file_aux::bar() == 10); //~ ERROR unresolved name\n+    assert!(mod_file_aux::bar() == 10); //~ ERROR unresolved function `mod_file_aux::bar`\n }"}, {"sha": "359417aee52797c992a2d8c93c52a2b6025f9b4d", "filename": "src/test/compile-fail/name-clash-nullary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -13,6 +13,6 @@ use std::option::*;\n fn main() {\n   let None: isize = 42; //~ ERROR let bindings cannot shadow unit variants\n   log(debug, None);\n-  //~^ ERROR unresolved name `debug`\n-  //~| ERROR unresolved name `log`\n+  //~^ ERROR unresolved function `log`\n+  //~| ERROR unresolved value `debug`\n }"}, {"sha": "c1c724fc431c7c30e497b3daf456b9731bdf97cf", "filename": "src/test/compile-fail/namespace-mix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fnamespace-mix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fnamespace-mix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespace-mix.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -41,13 +41,13 @@ mod m2 {\n \n fn f12() {\n     check(m1::S{}); //~ ERROR c::Item\n-    check(m1::S); //~ ERROR unresolved name\n+    check(m1::S); //~ ERROR expected value, found type alias `m1::S`\n     check(m2::S{}); //~ ERROR c::S\n     check(m2::S); //~ ERROR c::Item\n }\n fn xf12() {\n     check(xm1::S{}); //~ ERROR c::Item\n-    check(xm1::S); //~ ERROR unresolved name\n+    check(xm1::S); //~ ERROR expected value, found type alias `xm1::S`\n     check(xm2::S{}); //~ ERROR c::S\n     check(xm2::S); //~ ERROR c::Item\n }\n@@ -107,13 +107,13 @@ mod m8 {\n \n fn f78() {\n     check(m7::V{}); //~ ERROR c::Item\n-    check(m7::V); //~ ERROR name of a struct or struct variant\n+    check(m7::V); //~ ERROR expected value, found struct variant `m7::V`\n     check(m8::V{}); //~ ERROR c::E\n     check(m8::V); //~ ERROR c::Item\n }\n fn xf78() {\n     check(xm7::V{}); //~ ERROR c::Item\n-    check(xm7::V); //~ ERROR name of a struct or struct variant\n+    check(xm7::V); //~ ERROR expected value, found struct variant `xm7::V`\n     check(xm8::V{}); //~ ERROR c::E\n     check(xm8::V); //~ ERROR c::Item\n }"}, {"sha": "d92323e290b42f6096318b645ee40e2adf1b1315", "filename": "src/test/compile-fail/namespaced-enum-glob-import-no-impls-xcrate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls-xcrate.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -18,8 +18,8 @@ mod m {\n pub fn main() {\n     use namespaced_enums::Foo::*;\n \n-    foo(); //~ ERROR unresolved name `foo`\n-    m::foo(); //~ ERROR unresolved name `m::foo`\n-    bar(); //~ ERROR unresolved name `bar`\n-    m::bar(); //~ ERROR unresolved name `m::bar`\n+    foo(); //~ ERROR unresolved function `foo`\n+    m::foo(); //~ ERROR unresolved function `m::foo`\n+    bar(); //~ ERROR unresolved function `bar`\n+    m::bar(); //~ ERROR unresolved function `m::bar`\n }"}, {"sha": "b7c7397ee989c1cf230f873fdf53b730e3a3a54a", "filename": "src/test/compile-fail/namespaced-enum-glob-import-no-impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -28,8 +28,8 @@ mod m {\n pub fn main() {\n     use m2::Foo::*;\n \n-    foo(); //~ ERROR unresolved name `foo`\n-    m::foo(); //~ ERROR unresolved name `m::foo`\n-    bar(); //~ ERROR unresolved name `bar`\n-    m::bar(); //~ ERROR unresolved name `m::bar`\n+    foo(); //~ ERROR unresolved function `foo`\n+    m::foo(); //~ ERROR unresolved function `m::foo`\n+    bar(); //~ ERROR unresolved function `bar`\n+    m::bar(); //~ ERROR unresolved function `m::bar`\n }"}, {"sha": "f3e20f4f614663cb8cf180742a4f6c8481d6263f", "filename": "src/test/compile-fail/nested-cfg-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fnested-cfg-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fnested-cfg-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnested-cfg-attrs.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -11,4 +11,4 @@\n #[cfg_attr(all(), cfg_attr(all(), cfg(foo)))]\n fn f() {}\n \n-fn main() { f() } //~ ERROR unresolved name `f`\n+fn main() { f() } //~ ERROR unresolved function `f`"}, {"sha": "49e2e9f34fa3e796787ebfe8279f4172297917be", "filename": "src/test/compile-fail/no-implicit-prelude-nested.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude-nested.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -18,41 +18,41 @@\n mod foo {\n     mod baz {\n         struct Test;\n-        impl Add for Test {} //~ ERROR: not in scope\n-        impl Clone for Test {} //~ ERROR: not in scope\n-        impl Iterator for Test {} //~ ERROR: not in scope\n-        impl ToString for Test {} //~ ERROR: not in scope\n-        impl Writer for Test {} //~ ERROR: not in scope\n+        impl Add for Test {} //~ ERROR unresolved trait `Add`\n+        impl Clone for Test {} //~ ERROR unresolved trait `Clone`\n+        impl Iterator for Test {} //~ ERROR unresolved trait `Iterator`\n+        impl ToString for Test {} //~ ERROR unresolved trait `ToString`\n+        impl Writer for Test {} //~ ERROR unresolved trait `Writer`\n \n         fn foo() {\n-            drop(2) //~ ERROR: unresolved name\n+            drop(2) //~ ERROR unresolved function `drop`\n         }\n     }\n \n     struct Test;\n-    impl Add for Test {} //~ ERROR: not in scope\n-    impl Clone for Test {} //~ ERROR: not in scope\n-    impl Iterator for Test {} //~ ERROR: not in scope\n-    impl ToString for Test {} //~ ERROR: not in scope\n-    impl Writer for Test {} //~ ERROR: not in scope\n+    impl Add for Test {} //~ ERROR unresolved trait `Add`\n+    impl Clone for Test {} //~ ERROR unresolved trait `Clone`\n+    impl Iterator for Test {} //~ ERROR unresolved trait `Iterator`\n+    impl ToString for Test {} //~ ERROR unresolved trait `ToString`\n+    impl Writer for Test {} //~ ERROR unresolved trait `Writer`\n \n     fn foo() {\n-        drop(2) //~ ERROR: unresolved name\n+        drop(2) //~ ERROR unresolved function `drop`\n     }\n }\n \n fn qux() {\n     #[no_implicit_prelude]\n     mod qux_inner {\n         struct Test;\n-        impl Add for Test {} //~ ERROR: not in scope\n-        impl Clone for Test {} //~ ERROR: not in scope\n-        impl Iterator for Test {} //~ ERROR: not in scope\n-        impl ToString for Test {} //~ ERROR: not in scope\n-        impl Writer for Test {} //~ ERROR: not in scope\n+        impl Add for Test {} //~ ERROR unresolved trait `Add`\n+        impl Clone for Test {} //~ ERROR unresolved trait `Clone`\n+        impl Iterator for Test {} //~ ERROR unresolved trait `Iterator`\n+        impl ToString for Test {} //~ ERROR unresolved trait `ToString`\n+        impl Writer for Test {} //~ ERROR unresolved trait `Writer`\n \n         fn foo() {\n-            drop(2) //~ ERROR: unresolved name\n+            drop(2) //~ ERROR unresolved function `drop`\n         }\n     }\n }"}, {"sha": "b830a64fa8188d2f01a92f5f15f498cea944f8b3", "filename": "src/test/compile-fail/no-implicit-prelude.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-implicit-prelude.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -17,12 +17,12 @@\n // fail with the same error message).\n \n struct Test;\n-impl Add for Test {} //~ ERROR: not in scope\n-impl Clone for Test {} //~ ERROR: not in scope\n-impl Iterator for Test {} //~ ERROR: not in scope\n-impl ToString for Test {} //~ ERROR: not in scope\n-impl Writer for Test {} //~ ERROR: not in scope\n+impl Add for Test {} //~ ERROR unresolved trait `Add`\n+impl Clone for Test {} //~ ERROR unresolved trait `Clone`\n+impl Iterator for Test {} //~ ERROR unresolved trait `Iterator`\n+impl ToString for Test {} //~ ERROR unresolved trait `ToString`\n+impl Writer for Test {} //~ ERROR unresolved trait `Writer`\n \n fn main() {\n-    drop(2) //~ ERROR: unresolved name\n+    drop(2) //~ ERROR unresolved function `drop`\n }"}, {"sha": "7e4e55543cd222d1a316ff8d265f873f8b3fb5fc", "filename": "src/test/compile-fail/no-link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-link.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -15,5 +15,5 @@ extern crate empty_struct;\n //~^ WARN custom derive crates and `#[no_link]` crates have no effect without `#[macro_use]`\n \n fn main() {\n-    empty_struct::XEmpty1; //~ ERROR unresolved name\n+    empty_struct::XEmpty1; //~ ERROR unresolved value `empty_struct::XEmpty1`\n }"}, {"sha": "373b33c3e4985d56a08bec4311bc6e2292e7501a", "filename": "src/test/compile-fail/parser-recovery-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fparser-recovery-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fparser-recovery-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparser-recovery-1.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,11 +14,11 @@\n \n trait Foo {\n     fn bar() {\n-        let x = foo(); //~ ERROR unresolved name `foo`\n+        let x = foo(); //~ ERROR unresolved function `foo`\n \n }\n \n fn main() {\n     let x = y.;  //~ ERROR unexpected token\n-                 //~^ ERROR unresolved name `y`\n+                 //~^ ERROR unresolved value `y`\n } //~ ERROR this file contains an un-closed delimiter"}, {"sha": "c2bbbda4011e9b42ad7eb45aa170efdc841ca106", "filename": "src/test/compile-fail/parser-recovery-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fparser-recovery-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fparser-recovery-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparser-recovery-2.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,11 +14,11 @@\n \n trait Foo {\n     fn bar() {\n-        let x = foo(); //~ ERROR unresolved name `foo`\n+        let x = foo(); //~ ERROR unresolved function `foo`\n     ) //~ ERROR incorrect close delimiter: `)`\n }\n \n fn main() {\n     let x = y.;  //~ ERROR unexpected token\n-                 //~^ ERROR unresolved name `y`\n+                 //~^ ERROR unresolved value `y`\n }"}, {"sha": "24f296661725a00885a87935c7f040731a3217e5", "filename": "src/test/compile-fail/pattern-macro-hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -12,5 +12,5 @@ macro_rules! foo { () => ( x ) }\n \n fn main() {\n     let foo!() = 2;\n-    x + 1; //~ ERROR unresolved name `x`\n+    x + 1; //~ ERROR unresolved value `x`\n }"}, {"sha": "9c1e8250dbc6df0466ba8d824612af9c888d3ded", "filename": "src/test/compile-fail/privacy-ns1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns1.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -27,7 +27,7 @@ pub mod foo1 {\n fn test_glob1() {\n     use foo1::*;\n \n-    Bar();  //~ ERROR unresolved name `Bar`\n+    Bar();  //~ ERROR expected function, found trait `Bar`\n }\n \n // private type, public value\n@@ -42,7 +42,7 @@ pub mod foo2 {\n fn test_glob2() {\n     use foo2::*;\n \n-    let _x: Box<Bar>;  //~ ERROR type name `Bar` is undefined or not in scope\n+    let _x: Box<Bar>;  //~ ERROR expected type, found function `Bar`\n }\n \n // neither public\n@@ -57,8 +57,8 @@ pub mod foo3 {\n fn test_glob3() {\n     use foo3::*;\n \n-    Bar();  //~ ERROR unresolved name `Bar`\n-    let _x: Box<Bar>;  //~ ERROR  type name `Bar` is undefined or not in scope\n+    Bar();  //~ ERROR unresolved function `Bar`\n+    let _x: Box<Bar>;  //~ ERROR unresolved type `Bar`\n }\n \n fn main() {"}, {"sha": "ec9396b5e7bcbad193d7f2a087486e77dd6de2c2", "filename": "src/test/compile-fail/privacy-ns2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy-ns2.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -27,13 +27,13 @@ pub mod foo1 {\n fn test_single1() {\n     use foo1::Bar;\n \n-    Bar(); //~ ERROR unresolved name `Bar`\n+    Bar(); //~ ERROR expected function, found trait `Bar`\n }\n \n fn test_list1() {\n     use foo1::{Bar,Baz};\n \n-    Bar(); //~ ERROR unresolved name `Bar`\n+    Bar(); //~ ERROR expected function, found trait `Bar`\n }\n \n // private type, public value\n@@ -48,13 +48,13 @@ pub mod foo2 {\n fn test_single2() {\n     use foo2::Bar;\n \n-    let _x : Box<Bar>; //~ ERROR type name `Bar` is undefined\n+    let _x : Box<Bar>; //~ ERROR expected type, found function `Bar`\n }\n \n fn test_list2() {\n     use foo2::{Bar,Baz};\n \n-    let _x: Box<Bar>; //~ ERROR type name `Bar` is undefined\n+    let _x: Box<Bar>; //~ ERROR expected type, found function `Bar`\n }\n \n // neither public"}, {"sha": "01e2c6cd7e8288b40a99fc27d9e42bbb9802e6cf", "filename": "src/test/compile-fail/privacy/restricted/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftest.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -57,6 +57,6 @@ fn main() {\n }\n \n mod pathological {\n-    pub(bad::path) mod m1 {} //~ ERROR failed to resolve module path\n+    pub(bad::path) mod m1 {} //~ ERROR failed to resolve. Maybe a missing `extern crate bad;`?\n     pub(foo) mod m2 {} //~ ERROR visibilities can only be restricted to ancestor modules\n }"}, {"sha": "593713a6e059fa0dfa22583e29b2b9308820a876", "filename": "src/test/compile-fail/privacy/restricted/ty-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Fty-params.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -16,11 +16,11 @@ macro_rules! m {\n \n struct S<T>(T);\n m!{ S<u8> } //~ ERROR type or lifetime parameters in visibility path\n-//~^ ERROR failed to resolve module path. Not a module `S`\n+//~^ ERROR expected module, found struct `S`\n \n mod foo {\n     struct S(pub(foo<T>) ()); //~ ERROR type or lifetime parameters in visibility path\n-    //~^ ERROR type name `T` is undefined or not in scope\n+    //~^ ERROR unresolved type `T`\n }\n \n fn main() {}"}, {"sha": "48ec16a7610b7fc2afbda0674d46bb4987ee6ba2", "filename": "src/test/compile-fail/recursive-reexports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Frecursive-reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Frecursive-reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursive-reexports.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -12,6 +12,6 @@\n \n extern crate recursive_reexports;\n \n-fn f() -> recursive_reexports::S {} //~ ERROR type name `recursive_reexports::S` is undefined\n+fn f() -> recursive_reexports::S {} //~ ERROR unresolved type `recursive_reexports::S`\n \n fn main() {}"}, {"sha": "6b4a5122ad045711676bd5421ad8dbc91bf4d47b", "filename": "src/test/compile-fail/resolve-bad-import-prefix.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fresolve-bad-import-prefix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fresolve-bad-import-prefix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-bad-import-prefix.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod m {}\n+enum E {}\n+struct S;\n+trait Tr {}\n+\n+use {}; // OK\n+use ::{}; // OK\n+use m::{}; // OK\n+use E::{}; // OK\n+use S::{}; //~ ERROR expected module or enum, found struct `S`\n+use Tr::{}; //~ ERROR expected module or enum, found trait `Tr`\n+use Nonexistent::{}; //~ ERROR unresolved module or enum `Nonexistent`\n+\n+fn main () {}"}, {"sha": "088a4e6cd76601afb4b72c46a8184fb7fb964ef1", "filename": "src/test/compile-fail/resolve-bad-visibility.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fresolve-bad-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fresolve-bad-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-bad-visibility.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(pub_restricted)]\n+\n+enum E {}\n+trait Tr {}\n+\n+pub(E) struct S; //~ ERROR expected module, found enum `E`\n+pub(Tr) struct Z; //~ ERROR expected module, found trait `Tr`\n+pub(std::vec) struct F; //~ ERROR visibilities can only be restricted to ancestor modules\n+pub(nonexistent) struct G; //~ ERROR unresolved module `nonexistent`\n+pub(too_soon) struct H; //~ ERROR unresolved module `too_soon`\n+\n+// Visibilities are resolved eagerly without waiting for modules becoming fully populated.\n+// Visibilities can only use ancestor modules legally which are always available in time,\n+// so the worst thing that can happen due to eager resolution is a suboptimal error message.\n+mod too_soon {}\n+\n+fn main () {}"}, {"sha": "de463cd9e6af6dc1ee10ee34b3ac49613cdd849f", "filename": "src/test/compile-fail/resolve-primitive-fallback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fresolve-primitive-fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fresolve-primitive-fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-primitive-fallback.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -11,10 +11,10 @@\n fn main() {\n     // Make sure primitive type fallback doesn't work in value namespace\n     std::mem::size_of(u16);\n-    //~^ ERROR unresolved name `u16`\n+    //~^ ERROR expected value, found builtin type `u16`\n     //~| ERROR this function takes 0 parameters but 1 parameter was supplied\n \n     // Make sure primitive type fallback doesn't work with global paths\n     let _: ::u8;\n-    //~^ ERROR type name `::u8` is undefined or not in scope\n+    //~^ ERROR unresolved type `u8`\n }"}, {"sha": "affafbfadcf274171e514d039f98ea0b2ec5d7da", "filename": "src/test/compile-fail/resolve-unknown-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -10,10 +10,10 @@\n \n \n trait NewTrait : SomeNonExistentTrait {}\n-//~^ ERROR trait `SomeNonExistentTrait` is not in scope\n+//~^ ERROR unresolved trait `SomeNonExistentTrait`\n \n impl SomeNonExistentTrait for isize {}\n-//~^ ERROR trait `SomeNonExistentTrait` is not in scope\n+//~^ ERROR unresolved trait `SomeNonExistentTrait`\n \n fn f<T:SomeNonExistentTrait>() {}\n-//~^ ERROR trait `SomeNonExistentTrait` is not in scope\n+//~^ ERROR unresolved trait `SomeNonExistentTrait`"}, {"sha": "455574bbb9dde58912e0f721fc2138730ab3c8ca", "filename": "src/test/compile-fail/rmeta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Frmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Frmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -15,5 +15,5 @@\n #![crate_type=\"metadata\"]\n \n fn main() {\n-    let _ = Foo; //~ ERROR unresolved name `Foo`\n+    let _ = Foo; //~ ERROR unresolved value `Foo`\n }"}, {"sha": "d15553730159a3d375f4f8800566338d7ce0657b", "filename": "src/test/compile-fail/struct-fields-shorthand-unresolved.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fstruct-fields-shorthand-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fstruct-fields-shorthand-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-shorthand-unresolved.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -19,6 +19,6 @@ fn main() {\n     let x = 0;\n     let foo = Foo {\n         x,\n-        y //~ ERROR unresolved name `y`\n+        y //~ ERROR unresolved value `y`\n     };\n }"}, {"sha": "0beb4f084c8babd1da0feec5431c415226b4b023", "filename": "src/test/compile-fail/syntax-extension-minor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-minor.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -18,7 +18,7 @@ pub fn main() {\n     // this now fails (correctly, I claim) because hygiene prevents\n     // the assembled identifier from being a reference to the binding.\n     assert!(concat_idents!(asd, f_f, dsa) == \"<.<\".to_string());\n-    //~^ ERROR: unresolved name `asdf_fdsa`\n+    //~^ ERROR unresolved value `asdf_fdsa`\n \n     assert_eq!(stringify!(use_mention_distinction), \"use_mention_distinction\");\n }"}, {"sha": "28c69e8df222fd350056e78db0d669711259a4a6", "filename": "src/test/compile-fail/test-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Ftest-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Ftest-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftest-cfg.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -14,5 +14,5 @@\n fn foo() {}\n \n fn main() {\n-    foo(); //~ ERROR unresolved name `foo`\n+    foo(); //~ ERROR unresolved function `foo`\n }"}, {"sha": "5337272343b7d184d85f7ac821befd86b0ffdb62", "filename": "src/test/compile-fail/ufcs-partially-resolved.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fufcs-partially-resolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fufcs-partially-resolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-partially-resolved.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_type_defaults)]\n+\n+trait Tr {\n+    type Y = u16;\n+    fn Y() {}\n+}\n+impl Tr for u8 {}\n+\n+trait Dr {\n+    type X = u16;\n+    fn Z() {}\n+}\n+impl Dr for u8 {}\n+\n+enum E { Y }\n+type A = u32;\n+\n+fn main() {\n+    let _: <u8 as Tr>::N; //~ ERROR unresolved associated type `Tr::N`\n+    let _: <u8 as E>::N; //~ ERROR unresolved associated type `E::N`\n+    let _: <u8 as A>::N; //~ ERROR unresolved associated type `A::N`\n+    <u8 as Tr>::N; //~ ERROR unresolved method or associated constant `Tr::N`\n+    <u8 as E>::N; //~ ERROR unresolved method or associated constant `E::N`\n+    <u8 as A>::N; //~ ERROR unresolved method or associated constant `A::N`\n+    let _: <u8 as Tr>::Y; // OK\n+    let _: <u8 as E>::Y; //~ ERROR expected associated type, found variant `E::Y`\n+    <u8 as Tr>::Y; // OK\n+    <u8 as E>::Y; //~ ERROR expected method or associated constant, found unit variant `E::Y`\n+\n+    let _: <u8 as Tr>::N::NN; //~ ERROR unresolved associated type `Tr::N`\n+    let _: <u8 as E>::N::NN; //~ ERROR unresolved associated type `E::N`\n+    let _: <u8 as A>::N::NN; //~ ERROR unresolved associated type `A::N`\n+    <u8 as Tr>::N::NN; //~ ERROR unresolved associated type `Tr::N`\n+    <u8 as E>::N::NN; //~ ERROR unresolved associated type `E::N`\n+    <u8 as A>::N::NN; //~ ERROR unresolved associated type `A::N`\n+    let _: <u8 as Tr>::Y::NN; //~ ERROR ambiguous associated type\n+    let _: <u8 as E>::Y::NN; //~ ERROR expected associated type, found variant `E::Y`\n+    <u8 as Tr>::Y::NN; //~ ERROR no associated item named `NN` found for type `<u8 as Tr>::Y`\n+    <u8 as E>::Y::NN; //~ ERROR expected associated type, found variant `E::Y`\n+\n+    let _: <u8 as Tr::N>::NN; //~ ERROR unresolved associated type `Tr::N::NN`\n+    let _: <u8 as E::N>::NN; //~ ERROR unresolved associated type `E::N::NN`\n+    let _: <u8 as A::N>::NN; //~ ERROR unresolved associated type `A::N::NN`\n+    <u8 as Tr::N>::NN; //~ ERROR unresolved method or associated constant `Tr::N::NN`\n+    <u8 as E::N>::NN; //~ ERROR unresolved method or associated constant `E::N::NN`\n+    <u8 as A::N>::NN; //~ ERROR unresolved method or associated constant `A::N::NN`\n+    let _: <u8 as Tr::Y>::NN; //~ ERROR unresolved associated type `Tr::Y::NN`\n+    let _: <u8 as E::Y>::NN; //~ ERROR unresolved associated type `E::Y::NN`\n+    <u8 as Tr::Y>::NN; //~ ERROR unresolved method or associated constant `Tr::Y::NN`\n+    <u8 as E::Y>::NN; //~ ERROR unresolved method or associated constant `E::Y::NN`\n+\n+    let _: <u8 as Dr>::Z; //~ ERROR expected associated type, found method `Dr::Z`\n+    <u8 as Dr>::X; //~ ERROR expected method or associated constant, found associated type `Dr::X`\n+    let _: <u8 as Dr>::Z::N; //~ ERROR expected associated type, found method `Dr::Z`\n+    <u8 as Dr>::X::N; //~ ERROR no associated item named `N` found for type `<u8 as Dr>::X`\n+}"}, {"sha": "c889b7d28f8c2a8568ace30ce068822f39e987ac", "filename": "src/test/compile-fail/variant-used-as-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fvariant-used-as-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fvariant-used-as-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariant-used-as-type.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -15,7 +15,7 @@\n enum Ty {\n     A,\n     B(Ty::A),\n-    //~^ ERROR: found value `Ty::A` used as a type\n+    //~^ ERROR expected type, found variant `Ty::A`\n }\n \n \n@@ -25,6 +25,6 @@ enum E {\n }\n \n impl E::A {}\n-//~^ ERROR: found value `E::A` used as a type\n+//~^ ERROR expected type, found variant `E::A`\n \n fn main() {}"}, {"sha": "04af71330007593f0b4f15989652cc67a438eda6", "filename": "src/test/compile-fail/xcrate-unit-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -17,6 +17,6 @@ extern crate xcrate_unit_struct;\n \n fn main() {\n     let _ = xcrate_unit_struct::StructWithFields;\n-    //~^ ERROR: `xcrate_unit_struct::StructWithFields` is the name of a struct or struct variant\n+    //~^ ERROR expected value, found struct `xcrate_unit_struct::StructWithFields`\n     let _ = xcrate_unit_struct::Struct;\n }"}, {"sha": "73d548009dda1277d41a91ff6f3c6dbe27d80deb", "filename": "src/test/ui/codemap_tests/tab.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftab.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,8 +1,8 @@\n-error[E0425]: unresolved name `bar`\n+error[E0425]: unresolved value `bar`\n   --> $DIR/tab.rs:14:2\n    |\n 14 | \\tbar;\n-   | \\t^^^ unresolved name\n+   | \\t^^^ no resolution found\n \n error: aborting due to previous error\n "}, {"sha": "9db43dde1ac7e1be6558212afea633f966011b71", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,8 @@\n-error[E0404]: `Bar` is not a trait\n+error[E0404]: expected trait, found type alias `Bar`\n   --> $DIR/two_files.rs:15:6\n    |\n 15 | impl Bar for Baz { }\n-   |      ^^^ expected trait, found type alias\n-   |\n-   = note: type aliases cannot be used for traits\n+   |      ^^^ type aliases cannot be used for traits\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "27514093621583d1c327e71c8aa76c2fd534a7a1", "filename": "src/test/ui/macros/macro-backtrace-nested.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-nested.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,17 +1,17 @@\n-error[E0425]: unresolved name `fake`\n+error[E0425]: unresolved value `fake`\n   --> $DIR/macro-backtrace-nested.rs:15:12\n    |\n 15 |     () => (fake)\n-   |            ^^^^ unresolved name\n+   |            ^^^^ no resolution found\n ...\n 27 |     1 + call_nested_expr!();\n    |         ------------------- in this macro invocation\n \n-error[E0425]: unresolved name `fake`\n+error[E0425]: unresolved value `fake`\n   --> $DIR/macro-backtrace-nested.rs:15:12\n    |\n 15 |     () => (fake)\n-   |            ^^^^ unresolved name\n+   |            ^^^^ no resolution found\n ...\n 28 |     call_nested_expr_sum!();\n    |     ------------------------ in this macro invocation"}, {"sha": "fda8023b7f69e722e746ea09dfd74995db3f5cc5", "filename": "src/test/ui/resolve/enums-are-namespaced-xc.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,20 +1,29 @@\n-error[E0425]: unresolved name `namespaced_enums::A`\n+error[E0425]: unresolved value `namespaced_enums::A`\n   --> $DIR/enums-are-namespaced-xc.rs:15:13\n    |\n 15 |     let _ = namespaced_enums::A;\n-   |             ^^^^^^^^^^^^^^^^^^^ unresolved name\n+   |             ^^^^^^^^^^^^^^^^^^^ no resolution found\n+   |\n+   = help: possible candidate is found in another module, you can import it into scope:\n+   = help:   `use namespaced_enums::Foo::A;`\n \n-error[E0425]: unresolved name `namespaced_enums::B`\n+error[E0425]: unresolved function `namespaced_enums::B`\n   --> $DIR/enums-are-namespaced-xc.rs:18:13\n    |\n 18 |     let _ = namespaced_enums::B(10);\n-   |             ^^^^^^^^^^^^^^^^^^^ unresolved name\n+   |             ^^^^^^^^^^^^^^^^^^^ no resolution found\n+   |\n+   = help: possible candidate is found in another module, you can import it into scope:\n+   = help:   `use namespaced_enums::Foo::B;`\n \n-error[E0531]: unresolved struct, variant or union type `namespaced_enums::C`\n+error[E0422]: unresolved struct, variant or union type `namespaced_enums::C`\n   --> $DIR/enums-are-namespaced-xc.rs:21:13\n    |\n 21 |     let _ = namespaced_enums::C { a: 10 };\n-   |             ^^^^^^^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^^^^^^^^^^ no resolution found\n+   |\n+   = help: possible candidate is found in another module, you can import it into scope:\n+   = help:   `use namespaced_enums::Foo::C;`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2780c1c406f91cb303556ec131aa97695a642b20", "filename": "src/test/ui/resolve/issue-14254.stderr", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-14254.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-14254.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-14254.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,146 +1,146 @@\n-error[E0425]: unresolved name `baz`\n+error[E0425]: unresolved function `baz`\n   --> $DIR/issue-14254.rs:29:9\n    |\n 29 |         baz();\n-   |         ^^^ did you mean to call `self.baz`?\n+   |         ^^^ did you mean `self.baz(...)`?\n \n-error[E0425]: unresolved name `a`\n+error[E0425]: unresolved value `a`\n   --> $DIR/issue-14254.rs:32:9\n    |\n 32 |         a;\n-   |         ^ unresolved name\n+   |         ^ no resolution found\n \n-error[E0425]: unresolved name `baz`\n+error[E0425]: unresolved function `baz`\n   --> $DIR/issue-14254.rs:40:9\n    |\n 40 |         baz();\n-   |         ^^^ did you mean to call `self.baz`?\n+   |         ^^^ did you mean `self.baz(...)`?\n \n-error[E0425]: unresolved name `x`\n+error[E0425]: unresolved value `x`\n   --> $DIR/issue-14254.rs:43:9\n    |\n 43 |         x;\n    |         ^ did you mean `self.x`?\n \n-error[E0425]: unresolved name `y`\n+error[E0425]: unresolved value `y`\n   --> $DIR/issue-14254.rs:46:9\n    |\n 46 |         y;\n    |         ^ did you mean `self.y`?\n \n-error[E0425]: unresolved name `a`\n+error[E0425]: unresolved value `a`\n   --> $DIR/issue-14254.rs:49:9\n    |\n 49 |         a;\n-   |         ^ unresolved name\n+   |         ^ no resolution found\n \n-error[E0425]: unresolved name `bah`\n+error[E0425]: unresolved value `bah`\n   --> $DIR/issue-14254.rs:52:9\n    |\n 52 |         bah;\n-   |         ^^^ did you mean to call `Foo::bah`?\n+   |         ^^^ did you mean `Self::bah`?\n \n-error[E0425]: unresolved name `b`\n+error[E0425]: unresolved value `b`\n   --> $DIR/issue-14254.rs:55:9\n    |\n 55 |         b;\n-   |         ^ unresolved name\n+   |         ^ no resolution found\n \n-error[E0425]: unresolved name `baz`\n+error[E0425]: unresolved function `baz`\n   --> $DIR/issue-14254.rs:63:9\n    |\n 63 |         baz();\n-   |         ^^^ did you mean to call `self.baz`?\n+   |         ^^^ did you mean `self.baz(...)`?\n \n-error[E0425]: unresolved name `x`\n+error[E0425]: unresolved value `x`\n   --> $DIR/issue-14254.rs:66:9\n    |\n 66 |         x;\n    |         ^ did you mean `self.x`?\n \n-error[E0425]: unresolved name `y`\n+error[E0425]: unresolved value `y`\n   --> $DIR/issue-14254.rs:69:9\n    |\n 69 |         y;\n    |         ^ did you mean `self.y`?\n \n-error[E0425]: unresolved name `a`\n+error[E0425]: unresolved value `a`\n   --> $DIR/issue-14254.rs:72:9\n    |\n 72 |         a;\n-   |         ^ unresolved name\n+   |         ^ no resolution found\n \n-error[E0425]: unresolved name `bah`\n+error[E0425]: unresolved value `bah`\n   --> $DIR/issue-14254.rs:75:9\n    |\n 75 |         bah;\n-   |         ^^^ did you mean to call `Foo::bah`?\n+   |         ^^^ did you mean `Self::bah`?\n \n-error[E0425]: unresolved name `b`\n+error[E0425]: unresolved value `b`\n   --> $DIR/issue-14254.rs:78:9\n    |\n 78 |         b;\n-   |         ^ unresolved name\n+   |         ^ no resolution found\n \n-error[E0425]: unresolved name `baz`\n+error[E0425]: unresolved function `baz`\n   --> $DIR/issue-14254.rs:86:9\n    |\n 86 |         baz();\n-   |         ^^^ did you mean to call `self.baz`?\n+   |         ^^^ did you mean `self.baz(...)`?\n \n-error[E0425]: unresolved name `bah`\n+error[E0425]: unresolved value `bah`\n   --> $DIR/issue-14254.rs:89:9\n    |\n 89 |         bah;\n-   |         ^^^ did you mean to call `Foo::bah`?\n+   |         ^^^ did you mean `Self::bah`?\n \n-error[E0425]: unresolved name `baz`\n+error[E0425]: unresolved function `baz`\n   --> $DIR/issue-14254.rs:97:9\n    |\n 97 |         baz();\n-   |         ^^^ did you mean to call `self.baz`?\n+   |         ^^^ did you mean `self.baz(...)`?\n \n-error[E0425]: unresolved name `bah`\n+error[E0425]: unresolved value `bah`\n    --> $DIR/issue-14254.rs:100:9\n     |\n 100 |         bah;\n-    |         ^^^ did you mean to call `Foo::bah`?\n+    |         ^^^ did you mean `Self::bah`?\n \n-error[E0425]: unresolved name `baz`\n+error[E0425]: unresolved function `baz`\n    --> $DIR/issue-14254.rs:108:9\n     |\n 108 |         baz();\n-    |         ^^^ did you mean to call `self.baz`?\n+    |         ^^^ did you mean `self.baz(...)`?\n \n-error[E0425]: unresolved name `bah`\n+error[E0425]: unresolved value `bah`\n    --> $DIR/issue-14254.rs:111:9\n     |\n 111 |         bah;\n-    |         ^^^ did you mean to call `Foo::bah`?\n+    |         ^^^ did you mean `Self::bah`?\n \n-error[E0425]: unresolved name `baz`\n+error[E0425]: unresolved function `baz`\n    --> $DIR/issue-14254.rs:119:9\n     |\n 119 |         baz();\n-    |         ^^^ did you mean to call `self.baz`?\n+    |         ^^^ did you mean `self.baz(...)`?\n \n-error[E0425]: unresolved name `bah`\n+error[E0425]: unresolved value `bah`\n    --> $DIR/issue-14254.rs:122:9\n     |\n 122 |         bah;\n-    |         ^^^ did you mean to call `Foo::bah`?\n+    |         ^^^ did you mean `Self::bah`?\n \n-error[E0425]: unresolved name `baz`\n+error[E0425]: unresolved function `baz`\n    --> $DIR/issue-14254.rs:130:9\n     |\n 130 |         baz();\n-    |         ^^^ did you mean to call `self.baz`?\n+    |         ^^^ did you mean `self.baz(...)`?\n \n-error[E0425]: unresolved name `bah`\n+error[E0425]: unresolved value `bah`\n    --> $DIR/issue-14254.rs:133:9\n     |\n 133 |         bah;\n-    |         ^^^ did you mean to call `Foo::bah`?\n+    |         ^^^ did you mean `Self::bah`?\n \n error: main function not found\n "}, {"sha": "6b00cfb86931677943b69ee4a0d3224b9071e371", "filename": "src/test/ui/resolve/issue-16058.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-16058.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,8 +1,13 @@\n-error[E0532]: expected struct, variant or union type, found enum `Result`\n+error[E0574]: expected struct, variant or union type, found enum `Result`\n   --> $DIR/issue-16058.rs:19:9\n    |\n 19 |         Result {\n-   |         ^^^^^^\n+   |         ^^^^^^ not a struct, variant or union type\n+   |\n+   = help: possible better candidates are found in other modules, you can import them into scope:\n+   = help:   `use std::fmt::Result;`\n+   = help:   `use std::io::Result;`\n+   = help:   `use std::thread::Result;`\n \n error: aborting due to previous error\n "}, {"sha": "9de43728b2f7bceef1e087dd482b2feea8d75d87", "filename": "src/test/ui/resolve/issue-17518.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-17518.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,8 +1,11 @@\n-error[E0531]: unresolved struct, variant or union type `E`\n+error[E0422]: unresolved struct, variant or union type `E`\n   --> $DIR/issue-17518.rs:16:5\n    |\n 16 |     E { name: \"foobar\" }; //~ ERROR unresolved struct, variant or union type `E`\n-   |     ^\n+   |     ^ no resolution found\n+   |\n+   = help: possible candidate is found in another module, you can import it into scope:\n+   = help:   `use SomeEnum::E;`\n \n error: aborting due to previous error\n "}, {"sha": "edc7196d8464570222f235bd0a0b9b3e10947f20", "filename": "src/test/ui/resolve/issue-18252.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-18252.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-18252.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-18252.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,8 @@\n-error[E0423]: `Foo::Variant` is the name of a struct or struct variant, but this expression uses it like a function name\n+error[E0423]: expected function, found struct variant `Foo::Variant`\n   --> $DIR/issue-18252.rs:16:13\n    |\n 16 |     let f = Foo::Variant(42);\n-   |             ^^^^^^^^^^^^ struct called like a function\n-   |\n-   = help: did you mean to write: `Foo::Variant { /* fields */ }`?\n+   |             ^^^^^^^^^^^^ did you mean `Foo::Variant { /* fields */ }`?\n \n error: aborting due to previous error\n "}, {"sha": "7b14d49af51dd8c79cddd54c83372dd9b8929395", "filename": "src/test/ui/resolve/issue-19452.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-19452.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-19452.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-19452.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,18 +1,14 @@\n-error[E0423]: `Homura::Madoka` is the name of a struct or struct variant, but this expression uses it like a function name\n+error[E0423]: expected value, found struct variant `Homura::Madoka`\n   --> $DIR/issue-19452.rs:19:18\n    |\n 19 |     let homura = Homura::Madoka;\n-   |                  ^^^^^^^^^^^^^^ struct called like a function\n-   |\n-   = help: did you mean to write: `Homura::Madoka { /* fields */ }`?\n+   |                  ^^^^^^^^^^^^^^ did you mean `Homura::Madoka { /* fields */ }`?\n \n-error[E0423]: `issue_19452_aux::Homura::Madoka` is the name of a struct or struct variant, but this expression uses it like a function name\n+error[E0423]: expected value, found struct variant `issue_19452_aux::Homura::Madoka`\n   --> $DIR/issue-19452.rs:22:18\n    |\n 22 |     let homura = issue_19452_aux::Homura::Madoka;\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ struct called like a function\n-   |\n-   = help: did you mean to write: `issue_19452_aux::Homura::Madoka { /* fields */ }`?\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ did you mean `issue_19452_aux::Homura::Madoka { /* fields */ }`?\n \n error: aborting due to 2 previous errors\n "}, {"sha": "17b70d2182ed8fbccc800d995c5ed26c6bcf2972", "filename": "src/test/ui/resolve/issue-21221-1.stderr", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,42 +1,41 @@\n-error[E0405]: trait `Mul` is not in scope\n+error[E0405]: unresolved trait `Mul`\n   --> $DIR/issue-21221-1.rs:53:6\n    |\n 53 | impl Mul for Foo {\n-   |      ^^^ `Mul` is not in scope\n+   |      ^^^ no resolution found\n    |\n-   = help: you can import several candidates into scope (`use ...;`):\n-   = help:   `mul1::Mul`\n-   = help:   `mul2::Mul`\n-   = help:   `std::ops::Mul`\n+   = help: possible candidates are found in other modules, you can import them into scope:\n+   = help:   `use mul1::Mul;`\n+   = help:   `use mul2::Mul;`\n+   = help:   `use std::ops::Mul;`\n \n-error[E0412]: type name `Mul` is undefined or not in scope\n+error[E0412]: unresolved type `Mul`\n   --> $DIR/issue-21221-1.rs:72:16\n    |\n 72 | fn getMul() -> Mul {\n-   |                ^^^ undefined or not in scope\n+   |                ^^^ no resolution found\n    |\n-   = help: you can import several candidates into scope (`use ...;`):\n-   = help:   `mul1::Mul`\n-   = help:   `mul2::Mul`\n-   = help:   `mul3::Mul`\n-   = help:   `mul4::Mul`\n+   = help: possible candidates are found in other modules, you can import them into scope:\n+   = help:   `use mul1::Mul;`\n+   = help:   `use mul2::Mul;`\n+   = help:   `use mul3::Mul;`\n+   = help:   `use mul4::Mul;`\n    = help:   and 2 other candidates\n \n-error[E0405]: trait `ThisTraitReallyDoesntExistInAnyModuleReally` is not in scope\n+error[E0405]: unresolved trait `ThisTraitReallyDoesntExistInAnyModuleReally`\n   --> $DIR/issue-21221-1.rs:83:6\n    |\n 83 | impl ThisTraitReallyDoesntExistInAnyModuleReally for Foo {\n-   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ThisTraitReallyDoesntExistInAnyModuleReally` is not in scope\n-   |\n-   = help: no candidates by the name of `ThisTraitReallyDoesntExistInAnyModuleReally` found in your project; maybe you misspelled the name or forgot to import an external crate?\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no resolution found\n \n-error[E0405]: trait `Div` is not in scope\n+error[E0405]: unresolved trait `Div`\n   --> $DIR/issue-21221-1.rs:88:6\n    |\n 88 | impl Div for Foo {\n-   |      ^^^ `Div` is not in scope\n+   |      ^^^ no resolution found\n    |\n-   = help: you can import it into scope: `use std::ops::Div;`.\n+   = help: possible candidate is found in another module, you can import it into scope:\n+   = help:   `use std::ops::Div;`\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "342fe12f5e5f96d203bbc80d6db305814df2232d", "filename": "src/test/ui/resolve/issue-21221-2.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,11 @@\n-error[E0405]: trait `T` is not in scope\n+error[E0405]: unresolved trait `T`\n   --> $DIR/issue-21221-2.rs:28:6\n    |\n 28 | impl T for Foo { }\n-   |      ^ `T` is not in scope\n+   |      ^ no resolution found\n    |\n-   = help: you can import it into scope: `use foo::bar::T;`.\n+   = help: possible candidate is found in another module, you can import it into scope:\n+   = help:   `use foo::bar::T;`\n \n error: main function not found\n "}, {"sha": "25f57f3e3d1f0fa04b3e38feb702866f7365f87d", "filename": "src/test/ui/resolve/issue-21221-3.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,11 @@\n-error[E0405]: trait `OuterTrait` is not in scope\n+error[E0405]: unresolved trait `OuterTrait`\n   --> $DIR/issue-21221-3.rs:25:6\n    |\n 25 | impl OuterTrait for Foo {}\n-   |      ^^^^^^^^^^ `OuterTrait` is not in scope\n+   |      ^^^^^^^^^^ no resolution found\n    |\n-   = help: you can import it into scope: `use issue_21221_3::outer::OuterTrait;`.\n+   = help: possible candidate is found in another module, you can import it into scope:\n+   = help:   `use issue_21221_3::outer::OuterTrait;`\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "7ddbeebb8df0d49fef31cc62f39a6bd6676dece8", "filename": "src/test/ui/resolve/issue-21221-4.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,11 @@\n-error[E0405]: trait `T` is not in scope\n+error[E0405]: unresolved trait `T`\n   --> $DIR/issue-21221-4.rs:20:6\n    |\n 20 | impl T for Foo {}\n-   |      ^ `T` is not in scope\n+   |      ^ no resolution found\n    |\n-   = help: you can import it into scope: `use issue_21221_4::T;`.\n+   = help: possible candidate is found in another module, you can import it into scope:\n+   = help:   `use issue_21221_4::T;`\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "cd0d7d3ce16e32d3b906d9184c247add82d00fb6", "filename": "src/test/ui/resolve/issue-23305.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,8 +1,8 @@\n-error[E0411]: use of `Self` outside of an impl or trait\n+error[E0411]: unresolved type `Self`\n   --> $DIR/issue-23305.rs:15:12\n    |\n 15 | impl ToNbt<Self> {}\n-   |            ^^^^ used outside of impl or trait\n+   |            ^^^^ `Self` is only available in traits and impls\n \n error[E0038]: the trait `ToNbt` cannot be made into an object\n   --> $DIR/issue-23305.rs:15:6"}, {"sha": "32c1a3694d7e3bca92ef5c84c852f0c7f9517e40", "filename": "src/test/ui/resolve/issue-2356.stderr", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,112 +1,110 @@\n-error[E0425]: unresolved name `shave`\n+error[E0425]: unresolved function `shave`\n   --> $DIR/issue-2356.rs:27:5\n    |\n 27 |     shave();\n-   |     ^^^^^ unresolved name\n+   |     ^^^^^ no resolution found\n \n-error[E0425]: unresolved name `clone`\n+error[E0425]: unresolved function `clone`\n   --> $DIR/issue-2356.rs:35:5\n    |\n 35 |     clone();\n-   |     ^^^^^ did you mean to call `self.clone`?\n+   |     ^^^^^ did you mean `self.clone(...)`?\n \n-error[E0425]: unresolved name `default`\n+error[E0425]: unresolved function `default`\n   --> $DIR/issue-2356.rs:43:5\n    |\n 43 |     default();\n-   |     ^^^^^^^ did you mean to call `self.default`?\n+   |     ^^^^^^^ did you mean `Self::default`?\n \n-error[E0425]: unresolved name `whiskers`\n+error[E0425]: unresolved value `whiskers`\n   --> $DIR/issue-2356.rs:52:5\n    |\n 52 |     whiskers -= other;\n-   |     ^^^^^^^^ unresolved name\n-   |\n-   = help: this is an associated function, you don't have access to this type's fields or methods\n+   |     ^^^^^^^^\n+   |     |\n+   |     did you mean `self.whiskers`?\n+   |     `self` value is only available in methods with `self` parameter\n \n-error[E0425]: unresolved name `shave`\n+error[E0425]: unresolved function `shave`\n   --> $DIR/issue-2356.rs:57:5\n    |\n 57 |     shave(4);\n-   |     ^^^^^ did you mean to call `Groom::shave`?\n+   |     ^^^^^ did you mean `Self::shave`?\n \n-error[E0425]: unresolved name `purr`\n+error[E0425]: unresolved function `purr`\n   --> $DIR/issue-2356.rs:60:5\n    |\n 60 |     purr();\n-   |     ^^^^ unresolved name\n+   |     ^^^^ no resolution found\n \n-error[E0425]: unresolved name `static_method`\n+error[E0425]: unresolved function `static_method`\n   --> $DIR/issue-2356.rs:70:9\n    |\n 70 |         static_method();\n-   |         ^^^^^^^^^^^^^ unresolved name\n+   |         ^^^^^^^^^^^^^ no resolution found\n \n-error[E0425]: unresolved name `purr`\n+error[E0425]: unresolved function `purr`\n   --> $DIR/issue-2356.rs:73:9\n    |\n 73 |         purr();\n-   |         ^^^^ unresolved name\n+   |         ^^^^ no resolution found\n \n-error[E0425]: unresolved name `purr`\n+error[E0425]: unresolved function `purr`\n   --> $DIR/issue-2356.rs:76:9\n    |\n 76 |         purr();\n-   |         ^^^^ unresolved name\n+   |         ^^^^ no resolution found\n \n-error[E0425]: unresolved name `purr`\n+error[E0425]: unresolved function `purr`\n   --> $DIR/issue-2356.rs:79:9\n    |\n 79 |         purr();\n-   |         ^^^^ unresolved name\n+   |         ^^^^ no resolution found\n \n-error[E0424]: `self` is not available in a static method\n+error[E0424]: expected value, found module `self`\n   --> $DIR/issue-2356.rs:87:8\n    |\n 87 |     if self.whiskers > 3 {\n-   |        ^^^^ not available in static method\n-   |\n-   = note: maybe a `self` argument is missing?\n+   |        ^^^^ `self` value is only available in methods with `self` parameter\n \n-error[E0425]: unresolved name `grow_older`\n+error[E0425]: unresolved function `grow_older`\n   --> $DIR/issue-2356.rs:95:5\n    |\n 95 |     grow_older();\n-   |     ^^^^^^^^^^ unresolved name\n+   |     ^^^^^^^^^^ no resolution found\n \n-error[E0425]: unresolved name `shave`\n+error[E0425]: unresolved function `shave`\n   --> $DIR/issue-2356.rs:98:5\n    |\n 98 |     shave();\n-   |     ^^^^^ unresolved name\n+   |     ^^^^^ no resolution found\n \n-error[E0425]: unresolved name `whiskers`\n+error[E0425]: unresolved value `whiskers`\n    --> $DIR/issue-2356.rs:104:5\n     |\n 104 |     whiskers = 0;\n     |     ^^^^^^^^ did you mean `self.whiskers`?\n \n-error[E0425]: unresolved name `whiskers`\n+error[E0425]: unresolved value `whiskers`\n    --> $DIR/issue-2356.rs:110:5\n     |\n 110 |     whiskers = 4;\n-    |     ^^^^^^^^ unresolved name\n-    |\n-    = help: this is an associated function, you don't have access to this type's fields or methods\n+    |     ^^^^^^^^\n+    |     |\n+    |     did you mean `self.whiskers`?\n+    |     `self` value is only available in methods with `self` parameter\n \n-error[E0425]: unresolved name `purr_louder`\n+error[E0425]: unresolved function `purr_louder`\n    --> $DIR/issue-2356.rs:115:5\n     |\n 115 |     purr_louder();\n-    |     ^^^^^^^^^^^ unresolved name\n+    |     ^^^^^^^^^^^ no resolution found\n \n-error[E0425]: unresolved name `self`\n+error[E0424]: expected value, found module `self`\n    --> $DIR/issue-2356.rs:122:5\n     |\n 122 |     self += 1;\n-    |     ^^^^ unresolved name\n-    |\n-    = help: module `self` cannot be used as an expression\n+    |     ^^^^ `self` value is only available in methods with `self` parameter\n \n error: aborting due to 17 previous errors\n "}, {"sha": "3050bc4eb624ddef547bd013a3e81cd2bb4b8861", "filename": "src/test/ui/resolve/issue-24968.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-24968.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-24968.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-24968.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,8 +1,8 @@\n-error[E0411]: use of `Self` outside of an impl or trait\n+error[E0411]: unresolved type `Self`\n   --> $DIR/issue-24968.rs:11:11\n    |\n 11 | fn foo(_: Self) {\n-   |           ^^^^ used outside of impl or trait\n+   |           ^^^^ `Self` is only available in traits and impls\n \n error: aborting due to previous error\n "}, {"sha": "5dbecc4f0c5fa1ca937092b80d39cbb57de8282c", "filename": "src/test/ui/resolve/issue-33876.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-33876.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-33876.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-33876.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,8 @@\n-error[E0425]: unresolved name `Bar`\n+error[E0423]: expected value, found trait `Bar`\n   --> $DIR/issue-33876.rs:20:22\n    |\n 20 |     let any: &Any = &Bar; //~ ERROR expected value, found trait `Bar`\n-   |                      ^^^ unresolved name\n-   |\n-   = help: trait `Bar` cannot be used as an expression\n+   |                      ^^^ not a value\n \n error: aborting due to previous error\n "}, {"sha": "0a402680aa8beadf2bf4f0270fabb742f4ab386d", "filename": "src/test/ui/resolve/issue-3907.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,11 @@\n-error[E0404]: `Foo` is not a trait\n+error[E0404]: expected trait, found type alias `Foo`\n   --> $DIR/issue-3907.rs:20:6\n    |\n 20 | impl Foo for S { //~ ERROR expected trait, found type alias `Foo`\n-   |      ^^^ expected trait, found type alias\n+   |      ^^^ type aliases cannot be used for traits\n    |\n-   = note: type aliases cannot be used for traits\n+   = help: possible better candidate is found in another module, you can import it into scope:\n+   = help:   `use issue_3907::Foo;`\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "6cb9a28937980ea1055f112fd3fc88e9d707f7ab", "filename": "src/test/ui/resolve/issue-5035.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -4,13 +4,11 @@ error[E0432]: unresolved import `ImportError`\n 16 | use ImportError; //~ ERROR unresolved import `ImportError` [E0432]\n    |     ^^^^^^^^^^^ no `ImportError` in the root\n \n-error[E0404]: `K` is not a trait\n+error[E0404]: expected trait, found type alias `K`\n   --> $DIR/issue-5035.rs:13:6\n    |\n 13 | impl K for isize {} //~ ERROR expected trait, found type alias `K`\n-   |      ^ expected trait, found type alias\n-   |\n-   = note: type aliases cannot be used for traits\n+   |      ^ type aliases cannot be used for traits\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "b50295752f2e0a1632558b7d6de3a25a17d4b57d", "filename": "src/test/ui/resolve/issue-6702.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-6702.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fissue-6702.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-6702.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,8 @@\n-error[E0423]: `Monster` is the name of a struct or struct variant, but this expression uses it like a function name\n+error[E0423]: expected function, found struct `Monster`\n   --> $DIR/issue-6702.rs:17:14\n    |\n 17 |     let _m = Monster(); //~ ERROR expected function, found struct `Monster`\n-   |              ^^^^^^^ struct called like a function\n-   |\n-   = help: did you mean to write: `Monster { /* fields */ }`?\n+   |              ^^^^^^^ did you mean `Monster { /* fields */ }`?\n \n error: aborting due to previous error\n "}, {"sha": "98ead71394787c9f6951abd7281345bb307a108f", "filename": "src/test/ui/resolve/resolve-assoc-suggestions.stderr", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fresolve-assoc-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fresolve-assoc-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-assoc-suggestions.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,62 +1,56 @@\n-error[E0412]: type name `field` is undefined or not in scope\n+error[E0412]: unresolved type `field`\n   --> $DIR/resolve-assoc-suggestions.rs:26:16\n    |\n 26 |         let _: field;\n-   |                ^^^^^ undefined or not in scope\n-   |\n-   = help: no candidates by the name of `field` found in your project; maybe you misspelled the name or forgot to import an external crate?\n+   |                ^^^^^ no resolution found\n \n error[E0531]: unresolved tuple struct/variant `field`\n   --> $DIR/resolve-assoc-suggestions.rs:29:13\n    |\n 29 |         let field(..);\n-   |             ^^^^^\n+   |             ^^^^^ no resolution found\n \n-error[E0425]: unresolved name `field`\n+error[E0425]: unresolved value `field`\n   --> $DIR/resolve-assoc-suggestions.rs:32:9\n    |\n 32 |         field;\n    |         ^^^^^ did you mean `self.field`?\n \n-error[E0412]: type name `Type` is undefined or not in scope\n+error[E0412]: unresolved type `Type`\n   --> $DIR/resolve-assoc-suggestions.rs:36:16\n    |\n 36 |         let _: Type;\n-   |                ^^^^ undefined or not in scope\n-   |\n-   = help: no candidates by the name of `Type` found in your project; maybe you misspelled the name or forgot to import an external crate?\n+   |                ^^^^ did you mean `Self::Type`?\n \n error[E0531]: unresolved tuple struct/variant `Type`\n   --> $DIR/resolve-assoc-suggestions.rs:39:13\n    |\n 39 |         let Type(..);\n-   |             ^^^^\n+   |             ^^^^ no resolution found\n \n-error[E0425]: unresolved name `Type`\n+error[E0425]: unresolved value `Type`\n   --> $DIR/resolve-assoc-suggestions.rs:42:9\n    |\n 42 |         Type;\n-   |         ^^^^ did you mean to call `self.Type`?\n+   |         ^^^^ no resolution found\n \n-error[E0412]: type name `method` is undefined or not in scope\n+error[E0412]: unresolved type `method`\n   --> $DIR/resolve-assoc-suggestions.rs:46:16\n    |\n 46 |         let _: method;\n-   |                ^^^^^^ undefined or not in scope\n-   |\n-   = help: no candidates by the name of `method` found in your project; maybe you misspelled the name or forgot to import an external crate?\n+   |                ^^^^^^ no resolution found\n \n error[E0531]: unresolved tuple struct/variant `method`\n   --> $DIR/resolve-assoc-suggestions.rs:49:13\n    |\n 49 |         let method(..);\n-   |             ^^^^^^\n+   |             ^^^^^^ no resolution found\n \n-error[E0425]: unresolved name `method`\n+error[E0425]: unresolved value `method`\n   --> $DIR/resolve-assoc-suggestions.rs:52:9\n    |\n 52 |         method;\n-   |         ^^^^^^ did you mean to call `self.method`?\n+   |         ^^^^^^ did you mean `self.method(...)`?\n \n error: aborting due to 9 previous errors\n "}, {"sha": "ffb3f8484306f72b66f857cc1a634233deb6c1c2", "filename": "src/test/ui/resolve/resolve-hint-macro.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-hint-macro.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,8 +1,8 @@\n-error[E0425]: unresolved name `assert`\n+error[E0423]: expected function, found macro `assert`\n   --> $DIR/resolve-hint-macro.rs:12:5\n    |\n 12 |     assert(true);\n-   |     ^^^^^^ did you mean the macro `assert!`?\n+   |     ^^^^^^ did you mean `assert!(...)`?\n \n error: aborting due to previous error\n "}, {"sha": "173b69055411c49b3f00fb721b070ac920e9cc82", "filename": "src/test/ui/resolve/resolve-speculative-adjustment.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fresolve-speculative-adjustment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fresolve-speculative-adjustment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-speculative-adjustment.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,26 +1,26 @@\n-error[E0425]: unresolved name `field`\n+error[E0425]: unresolved value `field`\n   --> $DIR/resolve-speculative-adjustment.rs:27:13\n    |\n 27 |             field;\n-   |             ^^^^^ did you mean `self.field`?\n+   |             ^^^^^ no resolution found\n \n-error[E0425]: unresolved name `method`\n+error[E0425]: unresolved function `method`\n   --> $DIR/resolve-speculative-adjustment.rs:30:13\n    |\n 30 |             method();\n-   |             ^^^^^^ did you mean to call `self.method`?\n+   |             ^^^^^^ no resolution found\n \n-error[E0425]: unresolved name `field`\n+error[E0425]: unresolved value `field`\n   --> $DIR/resolve-speculative-adjustment.rs:35:9\n    |\n 35 |         field;\n    |         ^^^^^ did you mean `self.field`?\n \n-error[E0425]: unresolved name `method`\n+error[E0425]: unresolved function `method`\n   --> $DIR/resolve-speculative-adjustment.rs:38:9\n    |\n 38 |         method();\n-   |         ^^^^^^ did you mean to call `self.method`?\n+   |         ^^^^^^ did you mean `self.method(...)`?\n \n error: aborting due to 4 previous errors\n "}, {"sha": "8ace738ad6d8183a5046c501802993201882d6bb", "filename": "src/test/ui/resolve/suggest-path-instead-of-mod-dot-item.stderr", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fsuggest-path-instead-of-mod-dot-item.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,74 +1,56 @@\n-error[E0425]: unresolved name `a`\n+error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:27:5\n    |\n 27 |     a.I\n-   |     ^ unresolved name\n-   |\n-   = help: to reference an item from the `a` module, use `a::I`\n+   |     ^ did you mean `a::I`?\n \n-error[E0425]: unresolved name `a`\n+error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:33:5\n    |\n 33 |     a.g()\n-   |     ^ unresolved name\n-   |\n-   = help: to call a function from the `a` module, use `a::g(..)`\n+   |     ^ did you mean `a::g(...)`?\n \n-error[E0425]: unresolved name `a`\n+error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:39:5\n    |\n 39 |     a.b.J\n-   |     ^ unresolved name\n-   |\n-   = help: to reference an item from the `a` module, use `a::b`\n+   |     ^ did you mean `a::b`?\n \n-error[E0425]: unresolved name `a::b`\n+error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:45:5\n    |\n 45 |     a::b.J\n-   |     ^^^^ unresolved name\n-   |\n-   = help: to reference an item from the `a::b` module, use `a::b::J`\n+   |     ^^^^ did you mean `a::b::J`?\n \n-error[E0425]: unresolved name `a`\n+error[E0423]: expected value, found module `a`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:51:5\n    |\n 51 |     a.b.f();\n-   |     ^ unresolved name\n-   |\n-   = help: to reference an item from the `a` module, use `a::b`\n+   |     ^ did you mean `a::b`?\n \n-error[E0425]: unresolved name `a::b`\n+error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:55:12\n    |\n 55 |     v.push(a::b);\n-   |            ^^^^ unresolved name\n-   |\n-   = help: module `a::b` cannot be used as an expression\n+   |            ^^^^ not a value\n \n-error[E0425]: unresolved name `a::b`\n+error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:61:5\n    |\n 61 |     a::b.f()\n-   |     ^^^^ unresolved name\n-   |\n-   = help: to call a function from the `a::b` module, use `a::b::f(..)`\n+   |     ^^^^ did you mean `a::b::f(...)`?\n \n-error[E0425]: unresolved name `a::b`\n+error[E0423]: expected value, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:67:5\n    |\n 67 |     a::b\n-   |     ^^^^ unresolved name\n-   |\n-   = help: module `a::b` cannot be used as an expression\n+   |     ^^^^ not a value\n \n-error[E0425]: unresolved name `a::b`\n+error[E0423]: expected function, found module `a::b`\n   --> $DIR/suggest-path-instead-of-mod-dot-item.rs:73:5\n    |\n 73 |     a::b()\n-   |     ^^^^ unresolved name\n-   |\n-   = help: module `a::b` cannot be used as an expression\n+   |     ^^^^ not a function\n \n error: main function not found\n "}, {"sha": "7c422398e21bb16e9586b808369b3838cd58416c", "filename": "src/test/ui/resolve/token-error-correct-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-2.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -10,11 +10,11 @@ note: unclosed delimiter\n 14 |     if foo {\n    |            ^\n \n-error[E0425]: unresolved name `foo`\n+error[E0425]: unresolved value `foo`\n   --> $DIR/token-error-correct-2.rs:14:8\n    |\n 14 |     if foo {\n-   |        ^^^ unresolved name\n+   |        ^^^ no resolution found\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0b15c23909ca65cf3bed29f124762b7fcdaaee50", "filename": "src/test/ui/resolve/token-error-correct-3.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -22,11 +22,11 @@ error: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n 29 |         } else { //~ ERROR: incorrect close delimiter: `}`\n    |         ^\n \n-error[E0425]: unresolved name `is_directory`\n+error[E0425]: unresolved function `is_directory`\n   --> $DIR/token-error-correct-3.rs:21:13\n    |\n 21 |         if !is_directory(path.as_ref()) { //~ ERROR: unresolved function `is_directory`\n-   |             ^^^^^^^^^^^^ unresolved name\n+   |             ^^^^^^^^^^^^ no resolution found\n \n error[E0308]: mismatched types\n   --> $DIR/token-error-correct-3.rs:25:13\n@@ -36,6 +36,10 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `()`\n    = note:    found type `std::result::Result<bool, std::io::Error>`\n+   = help: here are some functions which might fulfill your needs:\n+ - .unwrap()\n+ - .unwrap_err()\n+ - .unwrap_or_default()\n \n error: aborting due to previous error\n "}, {"sha": "38cd95a486743b984cbe7fc194dd14e0661c60ac", "filename": "src/test/ui/resolve/token-error-correct.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -40,17 +40,17 @@ error: expected expression, found `)`\n 23 | }\n    | ^\n \n-error[E0425]: unresolved name `foo`\n+error[E0425]: unresolved function `foo`\n   --> $DIR/token-error-correct.rs:14:5\n    |\n 14 |     foo(bar(;\n-   |     ^^^ unresolved name\n+   |     ^^^ no resolution found\n \n-error[E0425]: unresolved name `bar`\n+error[E0425]: unresolved function `bar`\n   --> $DIR/token-error-correct.rs:14:9\n    |\n 14 |     foo(bar(;\n-   |         ^^^ unresolved name\n+   |         ^^^ no resolution found\n \n error: aborting due to 7 previous errors\n "}, {"sha": "c9c05202fea2bda526eabea96c1a5765c9a109b6", "filename": "src/test/ui/resolve/tuple-struct-alias.rs", "status": "renamed", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftuple-struct-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftuple-struct-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftuple-struct-alias.rs?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -8,11 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Foo {\n-    Bar(u32),\n+struct S(u8, u16);\n+type A = S;\n+\n+impl S {\n+    fn f() {\n+        let s = Self(0, 1);\n+        match s {\n+            Self(..) => {}\n+        }\n+    }\n }\n \n-fn do_something(x: Foo::Bar) { } //~ ERROR E0248\n-                //~| NOTE value used as a type\n fn main() {\n+    let s = A(0, 1);\n+    match s {\n+        A(..) => {}\n+    }\n }", "previous_filename": "src/test/compile-fail/E0248.rs"}, {"sha": "485c8ebbaeb6b9c4e8dfa8a4da264a2861bc5404", "filename": "src/test/ui/resolve/tuple-struct-alias.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftuple-struct-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Ftuple-struct-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftuple-struct-alias.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -0,0 +1,26 @@\n+error[E0423]: expected function, found self type `Self`\n+  --> $DIR/tuple-struct-alias.rs:16:17\n+   |\n+16 |         let s = Self(0, 1);\n+   |                 ^^^^ did you mean `Self { /* fields */ }`?\n+\n+error[E0532]: expected tuple struct/variant, found self type `Self`\n+  --> $DIR/tuple-struct-alias.rs:18:13\n+   |\n+18 |             Self(..) => {}\n+   |             ^^^^ did you mean `Self { /* fields */ }`?\n+\n+error[E0423]: expected function, found type alias `A`\n+  --> $DIR/tuple-struct-alias.rs:24:13\n+   |\n+24 |     let s = A(0, 1);\n+   |             ^ did you mean `A { /* fields */ }`?\n+\n+error[E0532]: expected tuple struct/variant, found type alias `A`\n+  --> $DIR/tuple-struct-alias.rs:26:9\n+   |\n+26 |         A(..) => {}\n+   |         ^ did you mean `A { /* fields */ }`?\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "ba90321ca2bde04fce123fd2fa401e9a23b96e66", "filename": "src/test/ui/resolve/unboxed-closure-sugar-nonexistent-trait.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,18 +1,14 @@\n-error[E0405]: trait `Nonexist` is not in scope\n+error[E0405]: unresolved trait `Nonexist`\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:11:8\n    |\n 11 | fn f<F:Nonexist(isize) -> isize>(x: F) {}\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^ `Nonexist` is not in scope\n-   |\n-   = help: no candidates by the name of `Nonexist` found in your project; maybe you misspelled the name or forgot to import an external crate?\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^ no resolution found\n \n-error[E0404]: `Typedef` is not a trait\n+error[E0404]: expected trait, found type alias `Typedef`\n   --> $DIR/unboxed-closure-sugar-nonexistent-trait.rs:17:8\n    |\n 17 | fn g<F:Typedef(isize) -> isize>(x: F) {}\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^ expected trait, found type alias\n-   |\n-   = note: type aliases cannot be used for traits\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^ type aliases cannot be used for traits\n \n error: cannot continue compilation due to previous error\n "}, {"sha": "1d0ee1911750e8849a0781ae5143011e212540ae", "filename": "src/test/ui/resolve/unresolved_static_type_field.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Funresolved_static_type_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fresolve%2Funresolved_static_type_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Funresolved_static_type_field.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,11 @@\n-error[E0425]: unresolved name `cx`\n+error[E0425]: unresolved value `cx`\n   --> $DIR/unresolved_static_type_field.rs:19:11\n    |\n 19 |         f(cx);\n-   |           ^^ unresolved name\n-   |\n-   = help: this is an associated function, you don't have access to this type's fields or methods\n+   |           ^^\n+   |           |\n+   |           did you mean `self.cx`?\n+   |           `self` value is only available in methods with `self` parameter\n \n error: aborting due to previous error\n "}, {"sha": "717f5ee200c74041e5aea5c3509ea17ef7e5869d", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,3 +1,9 @@\n+error[E0437]: type `bar` is not a member of trait `Foo`\n+  --> $DIR/impl-wrong-item-for-trait.rs:47:5\n+   |\n+47 |     type bar = u64;\n+   |     ^^^^^^^^^^^^^^^ not a member of trait `Foo`\n+\n error[E0323]: item `bar` is an associated const, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:25:5\n    |"}, {"sha": "764f34cabde9ac85a8f93ce946506373d9f6204d", "filename": "src/test/ui/span/issue-35987.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,11 @@\n-error[E0404]: `Add` is not a trait\n+error[E0404]: expected trait, found type parameter `Add`\n   --> $DIR/issue-35987.rs:15:21\n    |\n 15 | impl<T: Clone, Add> Add for Foo<T> {\n-   |                ---  ^^^ expected trait, found type parameter\n-   |                |\n-   |                type parameter defined here\n+   |                     ^^^ not a trait\n+   |\n+   = help: possible better candidate is found in another module, you can import it into scope:\n+   = help:   `use std::ops::Add;`\n \n error: main function not found\n "}, {"sha": "117c38e1db97149dc5fefdd418118034444232f6", "filename": "src/test/ui/span/typo-suggestion.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fspan%2Ftypo-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09aba18e109d7246e3b61c6642747139ee116c48/src%2Ftest%2Fui%2Fspan%2Ftypo-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftypo-suggestion.stderr?ref=09aba18e109d7246e3b61c6642747139ee116c48", "patch": "@@ -1,10 +1,10 @@\n-error[E0425]: unresolved name `bar`\n+error[E0425]: unresolved value `bar`\n   --> $DIR/typo-suggestion.rs:15:26\n    |\n 15 |     println!(\"Hello {}\", bar);\n-   |                          ^^^ unresolved name\n+   |                          ^^^ no resolution found\n \n-error[E0425]: unresolved name `fob`\n+error[E0425]: unresolved value `fob`\n   --> $DIR/typo-suggestion.rs:18:26\n    |\n 18 |     println!(\"Hello {}\", fob);"}]}