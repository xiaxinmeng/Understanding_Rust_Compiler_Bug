{"sha": "09227b17f4daf86afb269669671f197b4d481717", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MjI3YjE3ZjRkYWY4NmFmYjI2OTY2OTY3MWYxOTdiNGQ0ODE3MTc=", "commit": {"author": {"name": "Duncan", "email": "duncan@vtllf.org", "date": "2016-10-25T01:22:54Z"}, "committer": {"name": "Duncan", "email": "duncan@vtllf.org", "date": "2016-10-25T17:24:52Z"}, "message": "Vec docs: fix broken links and make quoting consistent", "tree": {"sha": "d9d81ab920f7bbc5b0f9fc9ba34ae1ae471b8d92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9d81ab920f7bbc5b0f9fc9ba34ae1ae471b8d92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09227b17f4daf86afb269669671f197b4d481717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09227b17f4daf86afb269669671f197b4d481717", "html_url": "https://github.com/rust-lang/rust/commit/09227b17f4daf86afb269669671f197b4d481717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09227b17f4daf86afb269669671f197b4d481717/comments", "author": null, "committer": null, "parents": [{"sha": "affc3b7552324284ccd7042b5b23f6ecd391babc", "url": "https://api.github.com/repos/rust-lang/rust/commits/affc3b7552324284ccd7042b5b23f6ecd391babc", "html_url": "https://github.com/rust-lang/rust/commit/affc3b7552324284ccd7042b5b23f6ecd391babc"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "7fdf7e903d5ca9c3a76d6b278bf975f21ee9d2ff", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/09227b17f4daf86afb269669671f197b4d481717/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09227b17f4daf86afb269669671f197b4d481717/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=09227b17f4daf86afb269669671f197b4d481717", "patch": "@@ -166,7 +166,7 @@ use super::range::RangeArgument;\n /// # Slicing\n ///\n /// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n-/// To get a slice, use \"&\". Example:\n+/// To get a slice, use `&`. Example:\n ///\n /// ```\n /// fn read_slice(slice: &[usize]) {\n@@ -203,33 +203,33 @@ use super::range::RangeArgument;\n ///\n /// # Guarantees\n ///\n-/// Due to its incredibly fundamental nature, Vec makes a lot of guarantees\n+/// Due to its incredibly fundamental nature, `Vec` makes a lot of guarantees\n /// about its design. This ensures that it's as low-overhead as possible in\n /// the general case, and can be correctly manipulated in primitive ways\n /// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n /// If additional type parameters are added (e.g. to support custom allocators),\n /// overriding their defaults may change the behavior.\n ///\n-/// Most fundamentally, Vec is and always will be a (pointer, capacity, length)\n+/// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)\n /// triplet. No more, no less. The order of these fields is completely\n /// unspecified, and you should use the appropriate methods to modify these.\n /// The pointer will never be null, so this type is null-pointer-optimized.\n ///\n /// However, the pointer may not actually point to allocated memory. In particular,\n-/// if you construct a Vec with capacity 0 via [`Vec::new()`], [`vec![]`][`vec!`],\n+/// if you construct a `Vec` with capacity 0 via [`Vec::new()`], [`vec![]`][`vec!`],\n /// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit()`]\n /// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n /// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n-/// the `Vec` may not report a [`capacity()`] of 0*. Vec will allocate if and only\n+/// the `Vec` may not report a [`capacity()`] of 0*. `Vec` will allocate if and only\n /// if [`mem::size_of::<T>()`]` * capacity() > 0`. In general, `Vec`'s allocation\n /// details are subtle enough that it is strongly recommended that you only\n-/// free memory allocated by a Vec by creating a new Vec and dropping it.\n+/// free memory allocated by a `Vec` by creating a new `Vec` and dropping it.\n ///\n /// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n /// (as defined by the allocator Rust is configured to use by default), and its\n /// pointer points to [`len()`] initialized elements in order (what you would see\n-/// if you coerced it to a slice), followed by `[capacity()][`capacity()`] -\n-/// [len()][`len()`]` logically uninitialized elements.\n+/// if you coerced it to a slice), followed by [`capacity()`]` - `[`len()`]\n+/// logically uninitialized elements.\n ///\n /// `Vec` will never perform a \"small optimization\" where elements are actually\n /// stored on the stack for two reasons:\n@@ -249,8 +249,8 @@ use super::range::RangeArgument;\n /// [`shrink_to_fit`][`shrink_to_fit()`].\n ///\n /// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n-/// sufficient. [`push`] and [`insert`] *will* (re)allocate if `[len()][`len()`]\n-/// == [capacity()][`capacity()`]`. That is, the reported capacity is completely\n+/// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n+/// [`len()`]` == `[`capacity()`]. That is, the reported capacity is completely\n /// accurate, and can be relied on. It can even be used to manually free the memory\n /// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n /// when not necessary.\n@@ -261,11 +261,10 @@ use super::range::RangeArgument;\n /// strategy is used will of course guarantee `O(1)` amortized [`push`].\n ///\n /// `vec![x; n]`, `vec![a, b, c, d]`, and\n-/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all\n-/// produce a `Vec` with exactly the requested capacity. If `[len()][`len()`] ==\n-/// [capacity()][`capacity()`]`, (as is the case for the [`vec!`] macro), then a\n-/// `Vec<T>` can be converted to and from a [`Box<[T]>`] without reallocating or\n-/// moving the elements.\n+/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n+/// with exactly the requested capacity. If [`len()`]` == `[`capacity()`],\n+/// (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\n+/// and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n ///\n /// `Vec` will not specifically overwrite any data that is removed from it,\n /// but also won't specifically preserve it. Its uninitialized memory is\n@@ -292,7 +291,7 @@ use super::range::RangeArgument;\n /// [`push`]: ../../std/vec/struct.Vec.html#method.push\n /// [`insert`]: ../../std/vec/struct.Vec.html#method.insert\n /// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n-/// [`Box<[T]>`]: ../../std/boxed/struct.Box.html\n+/// [owned slice]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n@@ -329,9 +328,10 @@ impl<T> Vec<T> {\n     /// reallocating. If `capacity` is 0, the vector will not allocate.\n     ///\n     /// It is important to note that this function does not specify the *length*\n-    /// of the returned vector, but only the *capacity*. (For an explanation of\n-    /// the difference between length and capacity, see the main `Vec<T>` docs\n-    /// above, 'Capacity and reallocation'.)\n+    /// of the returned vector, but only the *capacity*. For an explanation of\n+    /// the difference between length and capacity, see *[Capacity and reallocation]*.\n+    ///\n+    /// [Capacity and reallocation]: #capacity-and-reallocation\n     ///\n     /// # Examples\n     ///\n@@ -497,13 +497,13 @@ impl<T> Vec<T> {\n         self.buf.shrink_to_fit(self.len);\n     }\n \n-    /// Converts the vector into [`Box<[T]>`].\n+    /// Converts the vector into [`Box<[T]>`][owned slice].\n     ///\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with [`into_vec()`] is equivalent to calling\n     /// [`shrink_to_fit()`].\n     ///\n-    /// [`Box<[T]>`]: ../../std/boxed/struct.Box.html\n+    /// [owned slice]: ../../std/boxed/struct.Box.html\n     /// [`into_vec()`]: ../../std/primitive.slice.html#method.into_vec\n     /// [`shrink_to_fit()`]: #method.shrink_to_fit\n     ///\n@@ -779,7 +779,7 @@ impl<T> Vec<T> {\n \n     /// Retains only the elements specified by the predicate.\n     ///\n-    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n+    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n     /// This method operates in place and preserves the order of the retained\n     /// elements.\n     ///"}]}