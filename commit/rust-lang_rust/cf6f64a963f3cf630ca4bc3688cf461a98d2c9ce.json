{"sha": "cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "node_id": "C_kwDOAAsO6NoAKGNmNmY2NGE5NjNmM2NmNjMwY2E0YmMzNjg4Y2Y0NjFhOThkMmM5Y2U", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2021-11-05T12:39:01Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2021-11-17T21:50:42Z"}, "message": "Make slice->str conversion and related functions const\n\nThis commit makes the following functions from `core::str` `const fn`:\n- `from_utf8[_mut]` (`feature(const_str_from_utf8)`)\n- `from_utf8_unchecked_mut` (`feature(const_str_from_utf8_unchecked_mut)`)\n- `Utf8Error::{valid_up_to,error_len}` (`feature(const_str_from_utf8)`)", "tree": {"sha": "4cae355fdc2398feb66f1195a72a293ddca13343", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cae355fdc2398feb66f1195a72a293ddca13343"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "html_url": "https://github.com/rust-lang/rust/commit/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9c4b5d7276297679387189d96a952f2b760e7ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9c4b5d7276297679387189d96a952f2b760e7ad", "html_url": "https://github.com/rust-lang/rust/commit/c9c4b5d7276297679387189d96a952f2b760e7ad"}], "stats": {"total": 130, "additions": 106, "deletions": 24}, "files": [{"sha": "68e48348b076e18e5489c3f9560b6fdcbe070931", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "patch": "@@ -25,6 +25,7 @@\n #![feature(const_btree_new)]\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n+#![feature(const_str_from_utf8)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "1b741f174fb12f605b01984196f60d85a3c7e132", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "patch": "@@ -1,3 +1,4 @@\n+use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::cmp::Ordering::{Equal, Greater, Less};\n use std::str::{from_utf8, from_utf8_unchecked};\n@@ -883,6 +884,33 @@ fn test_is_utf8() {\n     assert!(from_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]).is_ok());\n }\n \n+#[test]\n+fn test_const_is_utf8() {\n+    const _: () = {\n+        // deny overlong encodings\n+        assert!(from_utf8(&[0xc0, 0x80]).is_err());\n+        assert!(from_utf8(&[0xc0, 0xae]).is_err());\n+        assert!(from_utf8(&[0xe0, 0x80, 0x80]).is_err());\n+        assert!(from_utf8(&[0xe0, 0x80, 0xaf]).is_err());\n+        assert!(from_utf8(&[0xe0, 0x81, 0x81]).is_err());\n+        assert!(from_utf8(&[0xf0, 0x82, 0x82, 0xac]).is_err());\n+        assert!(from_utf8(&[0xf4, 0x90, 0x80, 0x80]).is_err());\n+\n+        // deny surrogates\n+        assert!(from_utf8(&[0xED, 0xA0, 0x80]).is_err());\n+        assert!(from_utf8(&[0xED, 0xBF, 0xBF]).is_err());\n+\n+        assert!(from_utf8(&[0xC2, 0x80]).is_ok());\n+        assert!(from_utf8(&[0xDF, 0xBF]).is_ok());\n+        assert!(from_utf8(&[0xE0, 0xA0, 0x80]).is_ok());\n+        assert!(from_utf8(&[0xED, 0x9F, 0xBF]).is_ok());\n+        assert!(from_utf8(&[0xEE, 0x80, 0x80]).is_ok());\n+        assert!(from_utf8(&[0xEF, 0xBF, 0xBF]).is_ok());\n+        assert!(from_utf8(&[0xF0, 0x90, 0x80, 0x80]).is_ok());\n+        assert!(from_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]).is_ok());\n+    };\n+}\n+\n #[test]\n fn from_utf8_mostly_ascii() {\n     // deny invalid bytes embedded in long stretches of ascii\n@@ -895,13 +923,43 @@ fn from_utf8_mostly_ascii() {\n     }\n }\n \n+#[test]\n+fn const_from_utf8_mostly_ascii() {\n+    const _: () = {\n+        // deny invalid bytes embedded in long stretches of ascii\n+        let mut i = 32;\n+        while i < 64 {\n+            let mut data = [0; 128];\n+            data[i] = 0xC0;\n+            assert!(from_utf8(&data).is_err());\n+            data[i] = 0xC2;\n+            assert!(from_utf8(&data).is_err());\n+\n+            i = i + 1;\n+        }\n+    };\n+}\n+\n #[test]\n fn from_utf8_error() {\n     macro_rules! test {\n-        ($input: expr, $expected_valid_up_to: expr, $expected_error_len: expr) => {\n+        ($input: expr, $expected_valid_up_to:pat, $expected_error_len:pat) => {\n             let error = from_utf8($input).unwrap_err();\n-            assert_eq!(error.valid_up_to(), $expected_valid_up_to);\n-            assert_eq!(error.error_len(), $expected_error_len);\n+            assert_matches!(error.valid_up_to(), $expected_valid_up_to);\n+            assert_matches!(error.error_len(), $expected_error_len);\n+\n+            const _: () = {\n+                match from_utf8($input) {\n+                    Err(error) => {\n+                        let valid_up_to = error.valid_up_to();\n+                        let error_len = error.error_len();\n+\n+                        assert!(matches!(valid_up_to, $expected_valid_up_to));\n+                        assert!(matches!(error_len, $expected_error_len));\n+                    }\n+                    Ok(_) => unreachable!(),\n+                }\n+            };\n         };\n     }\n     test!(b\"A\\xC3\\xA9 \\xFF \", 4, Some(1));"}, {"sha": "3b0872378c6e9f41f45806312464e0b149a8b938", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "patch": "@@ -97,6 +97,7 @@\n #![allow(explicit_outlives_requirements)]\n //\n // Library features for const fns:\n+#![feature(const_align_offset)]\n #![feature(const_align_of_val)]\n #![feature(const_alloc_layout)]\n #![feature(const_arguments_as_str)]\n@@ -130,6 +131,7 @@\n #![feature(const_size_of_val)]\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_slice_ptr_len)]\n+#![feature(const_str_from_utf8_unchecked_mut)]\n #![feature(const_swap)]\n #![feature(const_trait_impl)]\n #![feature(const_type_id)]\n@@ -138,6 +140,7 @@\n #![feature(duration_consts_2)]\n #![feature(ptr_metadata)]\n #![feature(slice_ptr_get)]\n+#![feature(str_internals)]\n #![feature(variant_count)]\n #![feature(const_array_from_ref)]\n #![feature(const_slice_from_ref)]"}, {"sha": "8ac28669b308019e0f63a33791e8782620534303", "filename": "library/core/src/str/converts.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs?ref=cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "patch": "@@ -82,10 +82,16 @@ use super::Utf8Error;\n /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n-    run_utf8_validation(v)?;\n-    // SAFETY: Just ran validation.\n-    Ok(unsafe { from_utf8_unchecked(v) })\n+#[rustc_const_unstable(feature = \"const_str_from_utf8\", issue = \"none\")]\n+pub const fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n+    // This should use `?` again, once it's `const`\n+    match run_utf8_validation(v) {\n+        Ok(_) => {\n+            // SAFETY: validation succeeded.\n+            Ok(unsafe { from_utf8_unchecked(v) })\n+        }\n+        Err(err) => Err(err),\n+    }\n }\n \n /// Converts a mutable slice of bytes to a mutable string slice.\n@@ -119,10 +125,16 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n /// See the docs for [`Utf8Error`] for more details on the kinds of\n /// errors that can be returned.\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n-    run_utf8_validation(v)?;\n-    // SAFETY: Just ran validation.\n-    Ok(unsafe { from_utf8_unchecked_mut(v) })\n+#[rustc_const_unstable(feature = \"const_str_from_utf8\", issue = \"none\")]\n+pub const fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n+    // This should use `?` again, once it's `const`\n+    match run_utf8_validation(v) {\n+        Ok(_) => {\n+            // SAFETY: validation succeeded.\n+            Ok(unsafe { from_utf8_unchecked_mut(v) })\n+        }\n+        Err(err) => Err(err),\n+    }\n }\n \n /// Converts a slice of bytes to a string slice without checking\n@@ -184,7 +196,8 @@ pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[inline]\n #[must_use]\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n+#[rustc_const_unstable(feature = \"const_str_from_utf8_unchecked_mut\", issue = \"none\")]\n+pub const unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n     // SAFETY: the caller must guarantee that the bytes `v`\n     // are valid UTF-8, thus the cast to `*mut str` is safe.\n     // Also, the pointer dereference is safe because that pointer"}, {"sha": "3d0aeb52016e9408b1b2ab797f7915366fef3a83", "filename": "library/core/src/str/error.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs?ref=cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "patch": "@@ -72,9 +72,10 @@ impl Utf8Error {\n     /// assert_eq!(1, error.valid_up_to());\n     /// ```\n     #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n+    #[rustc_const_unstable(feature = \"const_str_from_utf8\", issue = \"none\")]\n     #[must_use]\n     #[inline]\n-    pub fn valid_up_to(&self) -> usize {\n+    pub const fn valid_up_to(&self) -> usize {\n         self.valid_up_to\n     }\n \n@@ -94,10 +95,15 @@ impl Utf8Error {\n     ///\n     /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n     #[stable(feature = \"utf8_error_error_len\", since = \"1.20.0\")]\n+    #[rustc_const_unstable(feature = \"const_str_from_utf8\", issue = \"none\")]\n     #[must_use]\n     #[inline]\n-    pub fn error_len(&self) -> Option<usize> {\n-        self.error_len.map(|len| len as usize)\n+    pub const fn error_len(&self) -> Option<usize> {\n+        // This should become `map` again, once it's `const`\n+        match self.error_len {\n+            Some(len) => Some(len as usize),\n+            None => None,\n+        }\n     }\n }\n "}, {"sha": "e362d5c05c1b475b834dccfcf1768c8025de592a", "filename": "library/core/src/str/validations.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=cf6f64a963f3cf630ca4bc3688cf461a98d2c9ce", "patch": "@@ -8,25 +8,25 @@ use super::Utf8Error;\n /// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n /// for width 3, and 3 bits for width 4.\n #[inline]\n-fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n+const fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n     (byte & (0x7F >> width)) as u32\n }\n \n /// Returns the value of `ch` updated with continuation byte `byte`.\n #[inline]\n-fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n+const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n     (ch << 6) | (byte & CONT_MASK) as u32\n }\n \n /// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n /// bits `10`).\n #[inline]\n-pub(super) fn utf8_is_cont_byte(byte: u8) -> bool {\n+pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {\n     (byte as i8) < -64\n }\n \n #[inline]\n-fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n+const fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     match opt {\n         Some(&byte) => byte,\n         None => 0,\n@@ -105,14 +105,15 @@ const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n \n /// Returns `true` if any byte in the word `x` is nonascii (>= 128).\n #[inline]\n-fn contains_nonascii(x: usize) -> bool {\n+const fn contains_nonascii(x: usize) -> bool {\n     (x & NONASCII_MASK) != 0\n }\n \n /// Walks through `v` checking that it's a valid UTF-8 sequence,\n /// returning `Ok(())` in that case, or, if it is invalid, `Err(err)`.\n #[inline(always)]\n-pub(super) fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n+#[rustc_const_unstable(feature = \"str_internals\", issue = \"none\")]\n+pub(super) const fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n     let mut index = 0;\n     let len = v.len();\n \n@@ -142,7 +143,7 @@ pub(super) fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n \n         let first = v[index];\n         if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as usize];\n+            let w = utf8_char_width(first);\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n             // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n@@ -230,7 +231,7 @@ pub(super) fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n }\n \n // https://tools.ietf.org/html/rfc3629\n-static UTF8_CHAR_WIDTH: [u8; 256] = [\n+const UTF8_CHAR_WIDTH: &[u8; 256] = &[\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n     1, // 0x1F\n     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -253,7 +254,7 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n #[unstable(feature = \"str_internals\", issue = \"none\")]\n #[must_use]\n #[inline]\n-pub fn utf8_char_width(b: u8) -> usize {\n+pub const fn utf8_char_width(b: u8) -> usize {\n     UTF8_CHAR_WIDTH[b as usize] as usize\n }\n "}]}