{"sha": "a8272f23cc121cc3e98f3148c8dab532decc7b90", "node_id": "C_kwDOAAsO6NoAKGE4MjcyZjIzY2MxMjFjYzNlOThmMzE0OGM4ZGFiNTMyZGVjYzdiOTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-22T10:50:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-22T10:50:23Z"}, "message": "Auto merge of #96197 - erikdesjardins:scalarpairenum, r=oli-obk\n\nMark payload fields of ScalarPair enums as Scalar::Union when they're not always initialized\n\nFixes #96158\n\nr? `@RalfJung`", "tree": {"sha": "14fa5affb325b05802588c88dfda0855a7e63fc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14fa5affb325b05802588c88dfda0855a7e63fc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8272f23cc121cc3e98f3148c8dab532decc7b90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8272f23cc121cc3e98f3148c8dab532decc7b90", "html_url": "https://github.com/rust-lang/rust/commit/a8272f23cc121cc3e98f3148c8dab532decc7b90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8272f23cc121cc3e98f3148c8dab532decc7b90/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d68f2f94f9b5cc49958844c935ee84fd63c87f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d68f2f94f9b5cc49958844c935ee84fd63c87f7", "html_url": "https://github.com/rust-lang/rust/commit/8d68f2f94f9b5cc49958844c935ee84fd63c87f7"}, {"sha": "4dcc1aae0a9d2b9eeee3f6404b8b7873a80aa6de", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dcc1aae0a9d2b9eeee3f6404b8b7873a80aa6de", "html_url": "https://github.com/rust-lang/rust/commit/4dcc1aae0a9d2b9eeee3f6404b8b7873a80aa6de"}], "stats": {"total": 811, "additions": 795, "deletions": 16}, "files": [{"sha": "7cf2984a63f90609b10f30ed2d85d393792a656c", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a8272f23cc121cc3e98f3148c8dab532decc7b90/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8272f23cc121cc3e98f3148c8dab532decc7b90/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=a8272f23cc121cc3e98f3148c8dab532decc7b90", "patch": "@@ -1120,21 +1120,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 match st[i].abi() {\n                                     Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n                                     Abi::ScalarPair(first, second) => {\n-                                        // We need to use scalar_unit to reset the\n-                                        // valid range to the maximal one for that\n-                                        // primitive, because only the niche is\n-                                        // guaranteed to be initialised, not the\n-                                        // other primitive.\n+                                        // Only the niche is guaranteed to be initialised,\n+                                        // so use union layout for the other primitive.\n                                         if offset.bytes() == 0 {\n-                                            Abi::ScalarPair(\n-                                                niche_scalar,\n-                                                scalar_unit(second.primitive()),\n-                                            )\n+                                            Abi::ScalarPair(niche_scalar, second.to_union())\n                                         } else {\n-                                            Abi::ScalarPair(\n-                                                scalar_unit(first.primitive()),\n-                                                niche_scalar,\n-                                            )\n+                                            Abi::ScalarPair(first.to_union(), niche_scalar)\n                                         }\n                                     }\n                                     _ => Abi::Aggregate { sized: true },\n@@ -1329,22 +1320,30 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n                     let mut common_prim = None;\n+                    let mut common_prim_initialized_in_all_variants = true;\n                     for (field_layouts, layout_variant) in iter::zip(&variants, &layout_variants) {\n                         let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n                             bug!();\n                         };\n                         let mut fields =\n                             iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n                         let (field, offset) = match (fields.next(), fields.next()) {\n-                            (None, None) => continue,\n+                            (None, None) => {\n+                                common_prim_initialized_in_all_variants = false;\n+                                continue;\n+                            }\n                             (Some(pair), None) => pair,\n                             _ => {\n                                 common_prim = None;\n                                 break;\n                             }\n                         };\n                         let prim = match field.abi {\n-                            Abi::Scalar(scalar) => scalar.primitive(),\n+                            Abi::Scalar(scalar) => {\n+                                common_prim_initialized_in_all_variants &=\n+                                    matches!(scalar, Scalar::Initialized { .. });\n+                                scalar.primitive()\n+                            }\n                             _ => {\n                                 common_prim = None;\n                                 break;\n@@ -1364,7 +1363,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         }\n                     }\n                     if let Some((prim, offset)) = common_prim {\n-                        let pair = self.scalar_pair(tag, scalar_unit(prim));\n+                        let prim_scalar = if common_prim_initialized_in_all_variants {\n+                            scalar_unit(prim)\n+                        } else {\n+                            // Common prim might be uninit.\n+                            Scalar::Union { value: prim }\n+                        };\n+                        let pair = self.scalar_pair(tag, prim_scalar);\n                         let pair_offsets = match pair.fields {\n                             FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                 assert_eq!(memory_index, &[0, 1]);"}, {"sha": "89387e01ba572c6c56d66ed690a08f9ee9a13e29", "filename": "src/test/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a8272f23cc121cc3e98f3148c8dab532decc7b90/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8272f23cc121cc3e98f3148c8dab532decc7b90/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.rs?ref=a8272f23cc121cc3e98f3148c8dab532decc7b90", "patch": "@@ -0,0 +1,54 @@\n+// normalize-stderr-test \"pref: Align \\{\\n *pow2: [1-3],\\n *\\}\" -> \"pref: $$PREF_ALIGN\"\n+#![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n+\n+use std::mem::MaybeUninit;\n+\n+enum HasNiche {\n+    A,\n+    B,\n+    C,\n+}\n+\n+// This should result in ScalarPair(Initialized, Union),\n+// since the u8 payload will be uninit for `None`.\n+#[rustc_layout(debug)]\n+pub enum MissingPayloadField { //~ ERROR: layout_of\n+    Some(u8),\n+    None\n+}\n+\n+// This should result in ScalarPair(Initialized, Initialized),\n+// since the u8 field is present in all variants,\n+// and hence will always be initialized.\n+#[rustc_layout(debug)]\n+pub enum CommonPayloadField { //~ ERROR: layout_of\n+    A(u8),\n+    B(u8),\n+}\n+\n+// This should result in ScalarPair(Initialized, Union),\n+// since, though a u8-sized field is present in all variants, it might be uninit.\n+#[rustc_layout(debug)]\n+pub enum CommonPayloadFieldIsMaybeUninit { //~ ERROR: layout_of\n+    A(u8),\n+    B(MaybeUninit<u8>),\n+}\n+\n+// This should result in ScalarPair(Initialized, Union),\n+// since only the niche field (used for the tag) is guaranteed to be initialized.\n+#[rustc_layout(debug)]\n+pub enum NicheFirst { //~ ERROR: layout_of\n+    A(HasNiche, u8),\n+    B,\n+    C\n+}\n+\n+// This should result in ScalarPair(Union, Initialized),\n+// since only the niche field (used for the tag) is guaranteed to be initialized.\n+#[rustc_layout(debug)]\n+pub enum NicheSecond { //~ ERROR: layout_of\n+    A(u8, HasNiche),\n+    B,\n+    C,\n+}"}, {"sha": "46187aae30445ea03240d1cebc37c692db5e6793", "filename": "src/test/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.stderr", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/a8272f23cc121cc3e98f3148c8dab532decc7b90/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8272f23cc121cc3e98f3148c8dab532decc7b90/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr?ref=a8272f23cc121cc3e98f3148c8dab532decc7b90", "patch": "@@ -0,0 +1,720 @@\n+error: layout_of(MissingPayloadField) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 0,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 1,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 0,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:16:1\n+   |\n+LL | / pub enum MissingPayloadField {\n+LL | |     Some(u8),\n+LL | |     None\n+LL | | }\n+   | |_^\n+\n+error: layout_of(CommonPayloadField) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 0,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=255,\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 0,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:25:1\n+   |\n+LL | / pub enum CommonPayloadField {\n+LL | |     A(u8),\n+LL | |     B(u8),\n+LL | | }\n+   | |_^\n+\n+error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 0,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 0,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:33:1\n+   |\n+LL | / pub enum CommonPayloadFieldIsMaybeUninit {\n+LL | |     A(u8),\n+LL | |     B(MaybeUninit<u8>),\n+LL | | }\n+   | |_^\n+\n+error: layout_of(NicheFirst) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 0,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+               tag_encoding: Niche {\n+                   dataful_variant: 0,\n+                   niche_variants: 1..=2,\n+                   niche_start: 3,\n+               },\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 0,\n+                               },\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                               1,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=2,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=255,\n+                           },\n+                       ),\n+                       largest_niche: Some(\n+                           Niche {\n+                               offset: Size {\n+                                   raw: 0,\n+                               },\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=2,\n+                           },\n+                       ),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 2,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 0,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 0,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:41:1\n+   |\n+LL | / pub enum NicheFirst {\n+LL | |     A(HasNiche, u8),\n+LL | |     B,\n+LL | |     C\n+LL | | }\n+   | |_^\n+\n+error: layout_of(NicheSecond) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 1,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+               tag_encoding: Niche {\n+                   dataful_variant: 0,\n+                   niche_variants: 1..=2,\n+                   niche_start: 3,\n+               },\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 0,\n+                               },\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                               1,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=255,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=2,\n+                           },\n+                       ),\n+                       largest_niche: Some(\n+                           Niche {\n+                               offset: Size {\n+                                   raw: 1,\n+                               },\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=2,\n+                           },\n+                       ),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 2,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size {\n+                           raw: 0,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 1,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:50:1\n+   |\n+LL | / pub enum NicheSecond {\n+LL | |     A(u8, HasNiche),\n+LL | |     B,\n+LL | |     C,\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 5 previous errors\n+"}]}