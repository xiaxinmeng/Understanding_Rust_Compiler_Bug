{"sha": "71bb0ff33e3759ee71ea19c230492c11e5e32b87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYmIwZmYzM2UzNzU5ZWU3MWVhMTljMjMwNDkyYzExZTVlMzJiODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-31T09:50:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-31T09:50:49Z"}, "message": "Auto merge of #67597 - estebank:placeholder-type, r=oli-obk\n\nSuggest type param when encountering `_` in item signatures\n\nFix #27435.", "tree": {"sha": "61f623415ecedc01861b1d9599ad8dad350c0efe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61f623415ecedc01861b1d9599ad8dad350c0efe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71bb0ff33e3759ee71ea19c230492c11e5e32b87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71bb0ff33e3759ee71ea19c230492c11e5e32b87", "html_url": "https://github.com/rust-lang/rust/commit/71bb0ff33e3759ee71ea19c230492c11e5e32b87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71bb0ff33e3759ee71ea19c230492c11e5e32b87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf2d145c62888c853db0bcfd8f5b3a6919f15502", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf2d145c62888c853db0bcfd8f5b3a6919f15502", "html_url": "https://github.com/rust-lang/rust/commit/bf2d145c62888c853db0bcfd8f5b3a6919f15502"}, {"sha": "261b606ddc12cfb027659562f3e22fbf77bfe448", "url": "https://api.github.com/repos/rust-lang/rust/commits/261b606ddc12cfb027659562f3e22fbf77bfe448", "html_url": "https://github.com/rust-lang/rust/commit/261b606ddc12cfb027659562f3e22fbf77bfe448"}], "stats": {"total": 635, "additions": 516, "deletions": 119}, "files": [{"sha": "1cd0b67ef05c0e3c3a56d48bd8097b4031f21952", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -398,6 +398,16 @@ rustc_queries! {\n                 typeck_tables.map(|tables| &*tcx.arena.alloc(tables))\n             }\n         }\n+        query diagnostic_only_typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n+            cache_on_disk_if { key.is_local() }\n+            load_cached(tcx, id) {\n+                let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n+                    .queries.on_disk_cache\n+                    .try_load_query_result(tcx, id);\n+\n+                typeck_tables.map(|tables| &*tcx.arena.alloc(tables))\n+            }\n+        }\n     }\n \n     Other {"}, {"sha": "41d493cceec69c835cae66251b704d03bbbbe51f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -2,8 +2,10 @@\n //! The main routine here is `ast_ty_to_ty()`; each use is parameterized by an\n //! instance of `AstConv`.\n \n+use crate::collect::PlaceholderHirTyCollector;\n use crate::hir::def::{CtorOf, DefKind, Res};\n use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::Visitor;\n use crate::hir::print;\n use crate::hir::{self, ExprKind, GenericArg, GenericArgs};\n use crate::lint;\n@@ -65,6 +67,9 @@ pub trait AstConv<'tcx> {\n     /// Returns the type to use when a type is omitted.\n     fn ty_infer(&self, param: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx>;\n \n+    /// Returns `true` if `_` is allowed in type signatures in the current context.\n+    fn allow_ty_infer(&self) -> bool;\n+\n     /// Returns the const to use when a const is omitted.\n     fn ct_infer(\n         &self,\n@@ -2591,7 +2596,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::BareFn(ref bf) => {\n                 require_c_abi_if_c_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                tcx.mk_fn_ptr(self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl))\n+                tcx.mk_fn_ptr(self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl, &[], None))\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n@@ -2756,14 +2761,24 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n         decl: &hir::FnDecl<'_>,\n+        generic_params: &[hir::GenericParam<'_>],\n+        ident_span: Option<Span>,\n     ) -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n \n         let tcx = self.tcx();\n-        let input_tys = decl.inputs.iter().map(|a| self.ty_of_arg(a, None));\n \n+        // We proactively collect all the infered type params to emit a single error per fn def.\n+        let mut visitor = PlaceholderHirTyCollector::default();\n+        for ty in decl.inputs {\n+            visitor.visit_ty(ty);\n+        }\n+        let input_tys = decl.inputs.iter().map(|a| self.ty_of_arg(a, None));\n         let output_ty = match decl.output {\n-            hir::Return(ref output) => self.ast_ty_to_ty(output),\n+            hir::Return(ref output) => {\n+                visitor.visit_ty(output);\n+                self.ast_ty_to_ty(output)\n+            }\n             hir::DefaultReturn(..) => tcx.mk_unit(),\n         };\n \n@@ -2772,6 +2787,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let bare_fn_ty =\n             ty::Binder::bind(tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi));\n \n+        if !self.allow_ty_infer() {\n+            // We always collect the spans for placeholder types when evaluating `fn`s, but we\n+            // only want to emit an error complaining about them if infer types (`_`) are not\n+            // allowed. `allow_ty_infer` gates this behavior.\n+            crate::collect::placeholder_type_error(\n+                tcx,\n+                ident_span.unwrap_or(DUMMY_SP),\n+                generic_params,\n+                visitor.0,\n+                ident_span.is_some(),\n+            );\n+        }\n+\n         // Find any late-bound regions declared in return type that do\n         // not appear in the arguments. These are not well-formed.\n         //"}, {"sha": "67bbc6db49577feb4c8bfefd96983c990a284101", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -756,6 +756,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         typeck_item_bodies,\n         typeck_tables_of,\n+        diagnostic_only_typeck_tables_of,\n         has_typeck_tables,\n         adt_destructor,\n         used_trait_imports,\n@@ -941,7 +942,31 @@ where\n     val.fold_with(&mut FixupFolder { tcx })\n }\n \n-fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n+fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &ty::TypeckTables<'tcx> {\n+    let fallback = move || tcx.type_of(def_id);\n+    typeck_tables_of_with_fallback(tcx, def_id, fallback)\n+}\n+\n+/// Used only to get `TypeckTables` for type inference during error recovery.\n+/// Currently only used for type inference of `static`s and `const`s to avoid type cycle errors.\n+fn diagnostic_only_typeck_tables_of<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> &ty::TypeckTables<'tcx> {\n+    assert!(def_id.is_local());\n+    let fallback = move || {\n+        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id).unwrap());\n+        tcx.sess.delay_span_bug(span, \"diagnostic only typeck table used\");\n+        tcx.types.err\n+    };\n+    typeck_tables_of_with_fallback(tcx, def_id, fallback)\n+}\n+\n+fn typeck_tables_of_with_fallback<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    fallback: impl Fn() -> Ty<'tcx> + 'tcx,\n+) -> &'tcx ty::TypeckTables<'tcx> {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n@@ -963,7 +988,7 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n         let fcx = if let (Some(header), Some(decl)) = (fn_header, fn_decl) {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-                AstConv::ty_of_fn(&fcx, header.unsafety, header.abi, decl)\n+                AstConv::ty_of_fn(&fcx, header.unsafety, header.abi, decl, &[], None)\n             } else {\n                 tcx.fn_sig(def_id)\n             };\n@@ -990,7 +1015,7 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n                     hir::TyKind::Infer => Some(AstConv::ast_ty_to_ty(&fcx, ty)),\n                     _ => None,\n                 })\n-                .unwrap_or_else(|| tcx.type_of(def_id));\n+                .unwrap_or_else(fallback);\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n@@ -1069,6 +1094,7 @@ fn typeck_tables_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TypeckTables<'_> {\n             let ty = fcx.normalize_ty(span, ty);\n             fcx.require_type_is_sized(ty, span, code);\n         }\n+\n         fcx.select_all_obligations_or_error();\n \n         if fn_decl.is_some() {\n@@ -2563,6 +2589,10 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         Some(self.next_region_var(v))\n     }\n \n+    fn allow_ty_infer(&self) -> bool {\n+        true\n+    }\n+\n     fn ty_infer(&self, param: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n         if let Some(param) = param {\n             if let GenericArgKind::Type(ty) = self.var_for_def(span, param).unpack() {"}, {"sha": "e8193ae944891d69bdd215b19382c4960e1b9251", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 142, "deletions": 21, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -102,17 +102,98 @@ pub struct ItemCtxt<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n+#[derive(Default)]\n+crate struct PlaceholderHirTyCollector(crate Vec<Span>);\n+\n+impl<'v> Visitor<'v> for PlaceholderHirTyCollector {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+        NestedVisitorMap::None\n+    }\n+    fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n+        if let hir::TyKind::Infer = t.kind {\n+            self.0.push(t.span);\n+        }\n+        hir::intravisit::walk_ty(self, t)\n+    }\n+}\n+\n struct CollectItemTypesVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n }\n \n+/// If there are any placeholder types (`_`), emit an error explaining that this is not allowed\n+/// and suggest adding type parameters in the appropriate place, taking into consideration any and\n+/// all already existing generic type parameters to avoid suggesting a name that is already in use.\n+crate fn placeholder_type_error(\n+    tcx: TyCtxt<'tcx>,\n+    ident_span: Span,\n+    generics: &[hir::GenericParam<'_>],\n+    placeholder_types: Vec<Span>,\n+    suggest: bool,\n+) {\n+    if placeholder_types.is_empty() {\n+        return;\n+    }\n+    // This is the whitelist of possible parameter names that we might suggest.\n+    let possible_names = [\"T\", \"K\", \"L\", \"A\", \"B\", \"C\"];\n+    let used_names = generics\n+        .iter()\n+        .filter_map(|p| match p.name {\n+            hir::ParamName::Plain(ident) => Some(ident.name),\n+            _ => None,\n+        })\n+        .collect::<Vec<_>>();\n+\n+    let type_name = possible_names\n+        .iter()\n+        .find(|n| !used_names.contains(&Symbol::intern(n)))\n+        .unwrap_or(&\"ParamName\");\n+\n+    let mut sugg: Vec<_> =\n+        placeholder_types.iter().map(|sp| (*sp, type_name.to_string())).collect();\n+    if generics.is_empty() {\n+        sugg.push((ident_span.shrink_to_hi(), format!(\"<{}>\", type_name)));\n+    } else {\n+        sugg.push((\n+            generics.iter().last().unwrap().span.shrink_to_hi(),\n+            format!(\", {}\", type_name),\n+        ));\n+    }\n+    let mut err = bad_placeholder_type(tcx, placeholder_types);\n+    if suggest {\n+        err.multipart_suggestion(\n+            \"use type parameters instead\",\n+            sugg,\n+            Applicability::HasPlaceholders,\n+        );\n+    }\n+    err.emit();\n+}\n+\n+fn reject_placeholder_type_signatures_in_item(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+    let (generics, suggest) = match &item.kind {\n+        hir::ItemKind::Union(_, generics)\n+        | hir::ItemKind::Enum(_, generics)\n+        | hir::ItemKind::Struct(_, generics) => (&generics.params[..], true),\n+        hir::ItemKind::TyAlias(_, generics) => (&generics.params[..], false),\n+        // `static`, `fn` and `const` are handled elsewhere to suggest appropriate type.\n+        _ => return,\n+    };\n+\n+    let mut visitor = PlaceholderHirTyCollector::default();\n+    visitor.visit_item(item);\n+\n+    placeholder_type_error(tcx, item.ident.span, generics, visitor.0, suggest);\n+}\n+\n impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         convert_item(self.tcx, item.hir_id);\n+        reject_placeholder_type_signatures_in_item(self.tcx, item);\n         intravisit::walk_item(self, item);\n     }\n \n@@ -157,15 +238,21 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Utility types and common code for the above passes.\n \n-fn bad_placeholder_type(tcx: TyCtxt<'tcx>, span: Span) -> errors::DiagnosticBuilder<'tcx> {\n-    let mut diag = struct_span_err!(\n+fn bad_placeholder_type(\n+    tcx: TyCtxt<'tcx>,\n+    mut spans: Vec<Span>,\n+) -> errors::DiagnosticBuilder<'tcx> {\n+    spans.sort();\n+    let mut err = struct_span_err!(\n         tcx.sess,\n-        span,\n+        spans.clone(),\n         E0121,\n         \"the type placeholder `_` is not allowed within types on item signatures\",\n     );\n-    diag.span_label(span, \"not allowed in type signatures\");\n-    diag\n+    for span in spans {\n+        err.span_label(span, \"not allowed in type signatures\");\n+    }\n+    err\n }\n \n impl ItemCtxt<'tcx> {\n@@ -195,9 +282,12 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         None\n     }\n \n-    fn ty_infer(&self, _: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n-        bad_placeholder_type(self.tcx(), span).emit();\n+    fn allow_ty_infer(&self) -> bool {\n+        false\n+    }\n \n+    fn ty_infer(&self, _: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n+        self.tcx().sess.delay_span_bug(span, \"bad placeholder type\");\n         self.tcx().types.err\n     }\n \n@@ -207,7 +297,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         _: Option<&ty::GenericParamDef>,\n         span: Span,\n     ) -> &'tcx Const<'tcx> {\n-        bad_placeholder_type(self.tcx(), span).emit();\n+        bad_placeholder_type(self.tcx(), vec![span]).emit();\n \n         self.tcx().consts.err\n     }\n@@ -1132,7 +1222,7 @@ fn infer_placeholder_type(\n     span: Span,\n     item_ident: Ident,\n ) -> Ty<'_> {\n-    let ty = tcx.typeck_tables_of(def_id).node_type(body_id.hir_id);\n+    let ty = tcx.diagnostic_only_typeck_tables_of(def_id).node_type(body_id.hir_id);\n \n     // If this came from a free `const` or `static mut?` item,\n     // then the user may have written e.g. `const A = 42;`.\n@@ -1152,7 +1242,7 @@ fn infer_placeholder_type(\n             .emit();\n         }\n         None => {\n-            let mut diag = bad_placeholder_type(tcx, span);\n+            let mut diag = bad_placeholder_type(tcx, vec![span]);\n             if ty != tcx.types.err {\n                 diag.span_suggestion(\n                     span,\n@@ -1183,7 +1273,7 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n             TraitItemKind::Const(ref ty, body_id) => body_id\n                 .and_then(|body_id| {\n-                    if let hir::TyKind::Infer = ty.kind {\n+                    if is_suggestable_infer_ty(ty) {\n                         Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n                     } else {\n                         None\n@@ -1202,7 +1292,7 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 tcx.mk_fn_def(def_id, substs)\n             }\n             ImplItemKind::Const(ref ty, body_id) => {\n-                if let hir::TyKind::Infer = ty.kind {\n+                if is_suggestable_infer_ty(ty) {\n                     infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                 } else {\n                     icx.to_ty(ty)\n@@ -1227,7 +1317,7 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         Node::Item(item) => {\n             match item.kind {\n                 ItemKind::Static(ref ty, .., body_id) | ItemKind::Const(ref ty, body_id) => {\n-                    if let hir::TyKind::Infer = ty.kind {\n+                    if is_suggestable_infer_ty(ty) {\n                         infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n                     } else {\n                         icx.to_ty(ty)\n@@ -1699,9 +1789,20 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n }\n \n+/// Whether `ty` is a type with `_` placeholders that can be infered. Used in diagnostics only to\n+/// use inference to provide suggestions for the appropriate type if possible.\n+fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n+    match &ty.kind {\n+        hir::TyKind::Infer => true,\n+        hir::TyKind::Slice(ty) | hir::TyKind::Array(ty, _) => is_suggestable_infer_ty(ty),\n+        hir::TyKind::Tup(tys) => tys.iter().any(|ty| is_suggestable_infer_ty(ty)),\n+        _ => false,\n+    }\n+}\n+\n pub fn get_infer_ret_ty(output: &'hir hir::FunctionRetTy<'hir>) -> Option<&'hir hir::Ty<'hir>> {\n     if let hir::FunctionRetTy::Return(ref ty) = output {\n-        if let hir::TyKind::Infer = ty.kind {\n+        if is_suggestable_infer_ty(ty) {\n             return Some(&**ty);\n         }\n     }\n@@ -1719,34 +1820,54 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n             kind: TraitItemKind::Method(sig, TraitMethod::Provided(_)),\n+            ident,\n+            generics,\n             ..\n         })\n-        | ImplItem(hir::ImplItem { kind: ImplItemKind::Method(sig, _), .. })\n-        | Item(hir::Item { kind: ItemKind::Fn(sig, _, _), .. }) => {\n+        | ImplItem(hir::ImplItem { kind: ImplItemKind::Method(sig, _), ident, generics, .. })\n+        | Item(hir::Item { kind: ItemKind::Fn(sig, generics, _), ident, .. }) => {\n             match get_infer_ret_ty(&sig.decl.output) {\n                 Some(ty) => {\n                     let fn_sig = tcx.typeck_tables_of(def_id).liberated_fn_sigs()[hir_id];\n-                    let mut diag = bad_placeholder_type(tcx, ty.span);\n+                    let mut visitor = PlaceholderHirTyCollector::default();\n+                    visitor.visit_ty(ty);\n+                    let mut diag = bad_placeholder_type(tcx, visitor.0);\n                     let ret_ty = fn_sig.output();\n                     if ret_ty != tcx.types.err {\n                         diag.span_suggestion(\n                             ty.span,\n-                            \"replace `_` with the correct return type\",\n+                            \"replace with the correct return type\",\n                             ret_ty.to_string(),\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n                     diag.emit();\n                     ty::Binder::bind(fn_sig)\n                 }\n-                None => AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl),\n+                None => AstConv::ty_of_fn(\n+                    &icx,\n+                    sig.header.unsafety,\n+                    sig.header.abi,\n+                    &sig.decl,\n+                    &generics.params[..],\n+                    Some(ident.span),\n+                ),\n             }\n         }\n \n         TraitItem(hir::TraitItem {\n             kind: TraitItemKind::Method(FnSig { header, decl }, _),\n+            ident,\n+            generics,\n             ..\n-        }) => AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl),\n+        }) => AstConv::ty_of_fn(\n+            &icx,\n+            header.unsafety,\n+            header.abi,\n+            decl,\n+            &generics.params[..],\n+            Some(ident.span),\n+        ),\n \n         ForeignItem(&hir::ForeignItem { kind: ForeignItemKind::Fn(ref fn_decl, _, _), .. }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n@@ -2351,7 +2472,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     } else {\n         hir::Unsafety::Unsafe\n     };\n-    let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), unsafety, abi, decl);\n+    let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), unsafety, abi, decl, &[], None);\n \n     // Feature gate SIMD types in FFI, since I am not sure that the\n     // ABIs are handled at all correctly. -huonw"}, {"sha": "5a5c6b40c5afecbcc7303459e13ff528d3ed23ba", "filename": "src/test/ui/error-codes/E0121.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -5,7 +5,7 @@ LL | fn foo() -> _ { 5 }\n    |             ^\n    |             |\n    |             not allowed in type signatures\n-   |             help: replace `_` with the correct return type: `i32`\n+   |             help: replace with the correct return type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/E0121.rs:3:13"}, {"sha": "1475b212b56a6a3b89d20c3e13f28e7f3294bb90", "filename": "src/test/ui/self/self-infer.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Fself%2Fself-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Fself%2Fself-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself-infer.stderr?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -3,12 +3,22 @@ error[E0121]: the type placeholder `_` is not allowed within types on item signa\n    |\n LL |     fn f(self: _) {}\n    |                ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn f<T>(self: T) {}\n+   |         ^^^       ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/self-infer.rs:5:17\n    |\n LL |     fn g(self: &_) {}\n    |                 ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn g<T>(self: &T) {}\n+   |         ^^^        ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5b0ca2f347ea821af5e3dee5ba0e3bb5ba9da736", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -6,7 +6,6 @@ fn test() -> _ { 5 }\n \n fn test2() -> (_, _) { (5, 5) }\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-//~^^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n static TEST3: _ = \"test\";\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n@@ -16,16 +15,22 @@ static TEST4: _ = 145;\n \n static TEST5: (_, _) = (1, 2);\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-//~^^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n fn test6(_: _) { }\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n+fn test6_b<T>(_: _, _: T) { }\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+\n+fn test6_c<T, K, L, A, B>(_: _, _: (T, K, L, A, B)) { }\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+\n fn test7(x: _) { let _x: usize = x; }\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n fn test8(_f: fn() -> _) { }\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n \n struct Test9;\n \n@@ -49,8 +54,6 @@ struct Test10 {\n     a: _,\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n     b: (_, _),\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-    //~^^ ERROR the type placeholder `_` is not allowed within types on item signatures\n }\n \n pub fn main() {\n@@ -59,7 +62,6 @@ pub fn main() {\n \n     fn fn_test2() -> (_, _) { (5, 5) }\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-    //~^^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n     static FN_TEST3: _ = \"test\";\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n@@ -69,7 +71,6 @@ pub fn main() {\n \n     static FN_TEST5: (_, _) = (1, 2);\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-    //~^^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n     fn fn_test6(_: _) { }\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n@@ -79,6 +80,7 @@ pub fn main() {\n \n     fn fn_test8(_f: fn() -> _) { }\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    //~| ERROR the type placeholder `_` is not allowed within types on item signatures\n \n     struct FnTest9;\n \n@@ -102,8 +104,30 @@ pub fn main() {\n         a: _,\n         //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n         b: (_, _),\n-        //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-        //~^^ ERROR the type placeholder `_` is not allowed within types on item signatures\n     }\n \n+    fn fn_test11(_: _) -> (_, _) { panic!() }\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    //~| ERROR type annotations needed\n+\n+    fn fn_test12(x: i32) -> (_, _) { (x, x) }\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+\n+    fn fn_test13(x: _) -> (i32, _) { (x, x) }\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+}\n+\n+trait T {\n+    fn method_test1(&self, x: _);\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    fn method_test2(&self, x: _) -> _;\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    fn method_test3(&self) -> _;\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    fn assoc_fn_test1(x: _);\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    fn assoc_fn_test2(x: _) -> _;\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    fn assoc_fn_test3() -> _;\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n }"}, {"sha": "9fe7af4c822c17eacecb04ccb46c472d56d9fc30", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 256, "deletions": 82, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -5,22 +5,20 @@ LL | fn test() -> _ { 5 }\n    |              ^\n    |              |\n    |              not allowed in type signatures\n-   |              help: replace `_` with the correct return type: `i32`\n+   |              help: replace with the correct return type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/typeck_type_placeholder_item.rs:7:16\n    |\n LL | fn test2() -> (_, _) { (5, 5) }\n-   |                ^ not allowed in type signatures\n+   |               -^--^-\n+   |               ||  |\n+   |               ||  not allowed in type signatures\n+   |               |not allowed in type signatures\n+   |               help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:7:19\n-   |\n-LL | fn test2() -> (_, _) { (5, 5) }\n-   |                   ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:11:15\n+  --> $DIR/typeck_type_placeholder_item.rs:10:15\n    |\n LL | static TEST3: _ = \"test\";\n    |               ^\n@@ -29,7 +27,7 @@ LL | static TEST3: _ = \"test\";\n    |               help: replace `_` with the correct type: `&'static str`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:14:15\n+  --> $DIR/typeck_type_placeholder_item.rs:13:15\n    |\n LL | static TEST4: _ = 145;\n    |               ^\n@@ -38,94 +36,112 @@ LL | static TEST4: _ = 145;\n    |               help: replace `_` with the correct type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:17:16\n+  --> $DIR/typeck_type_placeholder_item.rs:16:15\n    |\n LL | static TEST5: (_, _) = (1, 2);\n-   |                ^ not allowed in type signatures\n+   |               ^^^^^^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:17:19\n+  --> $DIR/typeck_type_placeholder_item.rs:19:13\n    |\n-LL | static TEST5: (_, _) = (1, 2);\n-   |                   ^ not allowed in type signatures\n+LL | fn test6(_: _) { }\n+   |             ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | fn test6<T>(_: T) { }\n+   |         ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:21:13\n+  --> $DIR/typeck_type_placeholder_item.rs:22:18\n    |\n-LL | fn test6(_: _) { }\n-   |             ^ not allowed in type signatures\n+LL | fn test6_b<T>(_: _, _: T) { }\n+   |                  ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | fn test6_b<T, K>(_: K, _: T) { }\n+   |             ^^^     ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:25:30\n+   |\n+LL | fn test6_c<T, K, L, A, B>(_: _, _: (T, K, L, A, B)) { }\n+   |                              ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | fn test6_c<T, K, L, A, B, C>(_: C, _: (T, K, L, A, B)) { }\n+   |                         ^^^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:24:13\n+  --> $DIR/typeck_type_placeholder_item.rs:28:13\n    |\n LL | fn test7(x: _) { let _x: usize = x; }\n    |             ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | fn test7<T>(x: T) { let _x: usize = x; }\n+   |         ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:27:22\n+  --> $DIR/typeck_type_placeholder_item.rs:31:22\n    |\n LL | fn test8(_f: fn() -> _) { }\n    |                      ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:49:8\n+  --> $DIR/typeck_type_placeholder_item.rs:31:22\n    |\n-LL |     a: _,\n-   |        ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:51:9\n+LL | fn test8(_f: fn() -> _) { }\n+   |                      ^ not allowed in type signatures\n    |\n-LL |     b: (_, _),\n-   |         ^ not allowed in type signatures\n+help: use type parameters instead\n+   |\n+LL | fn test8<T>(_f: fn() -> T) { }\n+   |         ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:51:12\n+  --> $DIR/typeck_type_placeholder_item.rs:54:8\n    |\n+LL |     a: _,\n+   |        ^ not allowed in type signatures\n+LL |\n LL |     b: (_, _),\n-   |            ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:102:12\n+   |         ^  ^ not allowed in type signatures\n+   |         |\n+   |         not allowed in type signatures\n    |\n-LL |         a: _,\n-   |            ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:104:13\n+help: use type parameters instead\n    |\n-LL |         b: (_, _),\n-   |             ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:104:16\n+LL | struct Test10<T> {\n+LL |     a: T,\n+LL |\n+LL |     b: (T, T),\n    |\n-LL |         b: (_, _),\n-   |                ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:57:21\n+  --> $DIR/typeck_type_placeholder_item.rs:60:21\n    |\n LL |     fn fn_test() -> _ { 5 }\n    |                     ^\n    |                     |\n    |                     not allowed in type signatures\n-   |                     help: replace `_` with the correct return type: `i32`\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:60:23\n-   |\n-LL |     fn fn_test2() -> (_, _) { (5, 5) }\n-   |                       ^ not allowed in type signatures\n+   |                     help: replace with the correct return type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:60:26\n+  --> $DIR/typeck_type_placeholder_item.rs:63:23\n    |\n LL |     fn fn_test2() -> (_, _) { (5, 5) }\n-   |                          ^ not allowed in type signatures\n+   |                      -^--^-\n+   |                      ||  |\n+   |                      ||  not allowed in type signatures\n+   |                      |not allowed in type signatures\n+   |                      help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:64:22\n+  --> $DIR/typeck_type_placeholder_item.rs:66:22\n    |\n LL |     static FN_TEST3: _ = \"test\";\n    |                      ^\n@@ -134,7 +150,7 @@ LL |     static FN_TEST3: _ = \"test\";\n    |                      help: replace `_` with the correct type: `&'static str`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:67:22\n+  --> $DIR/typeck_type_placeholder_item.rs:69:22\n    |\n LL |     static FN_TEST4: _ = 145;\n    |                      ^\n@@ -143,95 +159,253 @@ LL |     static FN_TEST4: _ = 145;\n    |                      help: replace `_` with the correct type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:70:23\n+  --> $DIR/typeck_type_placeholder_item.rs:72:22\n    |\n LL |     static FN_TEST5: (_, _) = (1, 2);\n-   |                       ^ not allowed in type signatures\n+   |                      ^^^^^^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:70:26\n-   |\n-LL |     static FN_TEST5: (_, _) = (1, 2);\n-   |                          ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:74:20\n+  --> $DIR/typeck_type_placeholder_item.rs:75:20\n    |\n LL |     fn fn_test6(_: _) { }\n    |                    ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn fn_test6<T>(_: T) { }\n+   |                ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:77:20\n+  --> $DIR/typeck_type_placeholder_item.rs:78:20\n    |\n LL |     fn fn_test7(x: _) { let _x: usize = x; }\n    |                    ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn fn_test7<T>(x: T) { let _x: usize = x; }\n+   |                ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:80:29\n+  --> $DIR/typeck_type_placeholder_item.rs:81:29\n    |\n LL |     fn fn_test8(_f: fn() -> _) { }\n    |                             ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:33:24\n+  --> $DIR/typeck_type_placeholder_item.rs:81:29\n+   |\n+LL |     fn fn_test8(_f: fn() -> _) { }\n+   |                             ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn fn_test8<T>(_f: fn() -> T) { }\n+   |                ^^^             ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:104:12\n+   |\n+LL |         a: _,\n+   |            ^ not allowed in type signatures\n+LL |\n+LL |         b: (_, _),\n+   |             ^  ^ not allowed in type signatures\n+   |             |\n+   |             not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     struct FnTest10<T> {\n+LL |         a: T,\n+LL |\n+LL |         b: (T, T),\n+   |\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/typeck_type_placeholder_item.rs:109:27\n+   |\n+LL |     fn fn_test11(_: _) -> (_, _) { panic!() }\n+   |                           ^^^^^^ cannot infer type\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:109:28\n+   |\n+LL |     fn fn_test11(_: _) -> (_, _) { panic!() }\n+   |                            ^  ^ not allowed in type signatures\n+   |                            |\n+   |                            not allowed in type signatures\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:113:30\n+   |\n+LL |     fn fn_test12(x: i32) -> (_, _) { (x, x) }\n+   |                             -^--^-\n+   |                             ||  |\n+   |                             ||  not allowed in type signatures\n+   |                             |not allowed in type signatures\n+   |                             help: replace with the correct return type: `(i32, i32)`\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:116:33\n+   |\n+LL |     fn fn_test13(x: _) -> (i32, _) { (x, x) }\n+   |                           ------^-\n+   |                           |     |\n+   |                           |     not allowed in type signatures\n+   |                           help: replace with the correct return type: `(i32, i32)`\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:121:31\n+   |\n+LL |     fn method_test1(&self, x: _);\n+   |                               ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn method_test1<T>(&self, x: T);\n+   |                    ^^^           ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:123:31\n+   |\n+LL |     fn method_test2(&self, x: _) -> _;\n+   |                               ^     ^ not allowed in type signatures\n+   |                               |\n+   |                               not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn method_test2<T>(&self, x: T) -> T;\n+   |                    ^^^           ^     ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:125:31\n+   |\n+LL |     fn method_test3(&self) -> _;\n+   |                               ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn method_test3<T>(&self) -> T;\n+   |                    ^^^           ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:127:26\n+   |\n+LL |     fn assoc_fn_test1(x: _);\n+   |                          ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn assoc_fn_test1<T>(x: T);\n+   |                      ^^^    ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:129:26\n+   |\n+LL |     fn assoc_fn_test2(x: _) -> _;\n+   |                          ^     ^ not allowed in type signatures\n+   |                          |\n+   |                          not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn assoc_fn_test2<T>(x: T) -> T;\n+   |                      ^^^    ^     ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:131:28\n+   |\n+LL |     fn assoc_fn_test3() -> _;\n+   |                            ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn assoc_fn_test3<T>() -> T;\n+   |                      ^^^      ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:38:24\n    |\n LL |     fn test9(&self) -> _ { () }\n    |                        ^\n    |                        |\n    |                        not allowed in type signatures\n-   |                        help: replace `_` with the correct return type: `()`\n+   |                        help: replace with the correct return type: `()`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:36:27\n+  --> $DIR/typeck_type_placeholder_item.rs:41:27\n    |\n LL |     fn test10(&self, _x : _) { }\n    |                           ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn test10<T>(&self, _x : T) { }\n+   |              ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:41:24\n+  --> $DIR/typeck_type_placeholder_item.rs:46:24\n    |\n LL |     fn clone(&self) -> _ { Test9 }\n    |                        ^\n    |                        |\n    |                        not allowed in type signatures\n-   |                        help: replace `_` with the correct return type: `Test9`\n+   |                        help: replace with the correct return type: `Test9`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:44:37\n+  --> $DIR/typeck_type_placeholder_item.rs:49:37\n    |\n LL |     fn clone_from(&mut self, other: _) { *self = Test9; }\n    |                                     ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn clone_from<T>(&mut self, other: T) { *self = Test9; }\n+   |                  ^^^                   ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:86:31\n+  --> $DIR/typeck_type_placeholder_item.rs:88:31\n    |\n LL |         fn fn_test9(&self) -> _ { () }\n    |                               ^\n    |                               |\n    |                               not allowed in type signatures\n-   |                               help: replace `_` with the correct return type: `()`\n+   |                               help: replace with the correct return type: `()`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:89:34\n+  --> $DIR/typeck_type_placeholder_item.rs:91:34\n    |\n LL |         fn fn_test10(&self, _x : _) { }\n    |                                  ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |         fn fn_test10<T>(&self, _x : T) { }\n+   |                     ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:94:28\n+  --> $DIR/typeck_type_placeholder_item.rs:96:28\n    |\n LL |         fn clone(&self) -> _ { FnTest9 }\n    |                            ^\n    |                            |\n    |                            not allowed in type signatures\n-   |                            help: replace `_` with the correct return type: `main::FnTest9`\n+   |                            help: replace with the correct return type: `main::FnTest9`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:97:41\n+  --> $DIR/typeck_type_placeholder_item.rs:99:41\n    |\n LL |         fn clone_from(&mut self, other: _) { *self = FnTest9; }\n    |                                         ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |         fn clone_from<T>(&mut self, other: T) { *self = FnTest9; }\n+   |                      ^^^                   ^\n \n-error: aborting due to 34 previous errors\n+error: aborting due to 40 previous errors\n \n-For more information about this error, try `rustc --explain E0121`.\n+Some errors have detailed explanations: E0121, E0282.\n+For more information about an error, try `rustc --explain E0121`."}, {"sha": "e3bc059d1f18187f18a8c6a0f078e98454924a0d", "filename": "src/test/ui/typeck/typeck_type_placeholder_item_help.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71bb0ff33e3759ee71ea19c230492c11e5e32b87/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr?ref=71bb0ff33e3759ee71ea19c230492c11e5e32b87", "patch": "@@ -5,7 +5,7 @@ LL | fn test1() -> _ { Some(42) }\n    |               ^\n    |               |\n    |               not allowed in type signatures\n-   |               help: replace `_` with the correct return type: `std::option::Option<i32>`\n+   |               help: replace with the correct return type: `std::option::Option<i32>`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/typeck_type_placeholder_item_help.rs:7:14"}]}