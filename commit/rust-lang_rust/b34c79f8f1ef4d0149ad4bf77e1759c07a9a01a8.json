{"sha": "b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "node_id": "C_kwDOAAsO6NoAKGIzNGM3OWY4ZjFlZjRkMDE0OWFkNGJmNzdlMTc1OWMwN2E5YTAxYTg", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-07-03T05:04:31Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-07-18T17:06:51Z"}, "message": "proc_macro: stop using a remote object handle for Literal\n\nThis builds on the symbol infrastructure built for `Ident` to replicate\nthe `LitKind` and `Lit` structures in rustc within the `proc_macro`\nclient, allowing literals to be fully created and interacted with from\nthe client thread. Only parsing and subspan operations still require\nsync RPC.", "tree": {"sha": "f781a9657843441cd6709527cbde5358f56b3310", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f781a9657843441cd6709527cbde5358f56b3310"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "html_url": "https://github.com/rust-lang/rust/commit/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "491fccfbe3561b0674a7dd13ac9f00820662aa59", "url": "https://api.github.com/repos/rust-lang/rust/commits/491fccfbe3561b0674a7dd13ac9f00820662aa59", "html_url": "https://github.com/rust-lang/rust/commit/491fccfbe3561b0674a7dd13ac9f00820662aa59"}], "stats": {"total": 565, "additions": 305, "deletions": 260}, "files": [{"sha": "0618c9aa084d6989419cf477cdd847161428427e", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 149, "deletions": 181, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "patch": "@@ -14,9 +14,10 @@ use rustc_span::def_id::CrateNum;\n use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n \n-use pm::bridge::{server, DelimSpan, ExpnGlobals, Group, Ident, Punct, TokenTree};\n+use pm::bridge::{\n+    server, DelimSpan, ExpnGlobals, Group, Ident, LitKind, Literal, Punct, TokenTree,\n+};\n use pm::{Delimiter, Level, LineColumn};\n-use std::ascii;\n use std::ops::Bound;\n \n trait FromInternal<T> {\n@@ -49,9 +50,40 @@ impl ToInternal<token::Delimiter> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n-    for Vec<TokenTree<TokenStream, Span, Symbol, Literal>>\n-{\n+impl FromInternal<token::LitKind> for LitKind {\n+    fn from_internal(kind: token::LitKind) -> Self {\n+        match kind {\n+            token::Byte => LitKind::Byte,\n+            token::Char => LitKind::Char,\n+            token::Integer => LitKind::Integer,\n+            token::Float => LitKind::Float,\n+            token::Str => LitKind::Str,\n+            token::StrRaw(n) => LitKind::StrRaw(n),\n+            token::ByteStr => LitKind::ByteStr,\n+            token::ByteStrRaw(n) => LitKind::ByteStrRaw(n),\n+            token::Err => LitKind::Err,\n+            token::Bool => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl ToInternal<token::LitKind> for LitKind {\n+    fn to_internal(self) -> token::LitKind {\n+        match self {\n+            LitKind::Byte => token::Byte,\n+            LitKind::Char => token::Char,\n+            LitKind::Integer => token::Integer,\n+            LitKind::Float => token::Float,\n+            LitKind::Str => token::Str,\n+            LitKind::StrRaw(n) => token::StrRaw(n),\n+            LitKind::ByteStr => token::ByteStr,\n+            LitKind::ByteStrRaw(n) => token::ByteStrRaw(n),\n+            LitKind::Err => token::Err,\n+        }\n+    }\n+}\n+\n+impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)> for Vec<TokenTree<TokenStream, Span, Symbol>> {\n     fn from_internal((stream, rustc): (TokenStream, &mut Rustc<'_, '_>)) -> Self {\n         use rustc_ast::token::*;\n \n@@ -143,7 +175,14 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n                         TokenTree::Ident(Ident { sym: ident.name, is_raw: false, span }),\n                     ]);\n                 }\n-                Literal(lit) => trees.push(TokenTree::Literal(self::Literal { lit, span })),\n+                Literal(token::Lit { kind, symbol, suffix }) => {\n+                    trees.push(TokenTree::Literal(self::Literal {\n+                        kind: FromInternal::from_internal(kind),\n+                        symbol,\n+                        suffix,\n+                        span,\n+                    }));\n+                }\n                 DocComment(_, attr_style, data) => {\n                     let mut escaped = String::new();\n                     for ch in data.as_str().chars() {\n@@ -199,9 +238,7 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n     }\n }\n \n-impl ToInternal<TokenStream>\n-    for (TokenTree<TokenStream, Span, Symbol, Literal>, &mut Rustc<'_, '_>)\n-{\n+impl ToInternal<TokenStream> for (TokenTree<TokenStream, Span, Symbol>, &mut Rustc<'_, '_>) {\n     fn to_internal(self) -> TokenStream {\n         use rustc_ast::token::*;\n \n@@ -221,7 +258,9 @@ impl ToInternal<TokenStream>\n                 return tokenstream::TokenTree::token(Ident(sym, is_raw), span).into();\n             }\n             TokenTree::Literal(self::Literal {\n-                lit: token::Lit { kind: token::Integer, symbol, suffix },\n+                kind: self::LitKind::Integer,\n+                symbol,\n+                suffix,\n                 span,\n             }) if symbol.as_str().starts_with('-') => {\n                 let minus = BinOp(BinOpToken::Minus);\n@@ -232,7 +271,9 @@ impl ToInternal<TokenStream>\n                 return [a, b].into_iter().collect();\n             }\n             TokenTree::Literal(self::Literal {\n-                lit: token::Lit { kind: token::Float, symbol, suffix },\n+                kind: self::LitKind::Float,\n+                symbol,\n+                suffix,\n                 span,\n             }) if symbol.as_str().starts_with('-') => {\n                 let minus = BinOp(BinOpToken::Minus);\n@@ -242,8 +283,12 @@ impl ToInternal<TokenStream>\n                 let b = tokenstream::TokenTree::token(float, span);\n                 return [a, b].into_iter().collect();\n             }\n-            TokenTree::Literal(self::Literal { lit, span }) => {\n-                return tokenstream::TokenTree::token(Literal(lit), span).into();\n+            TokenTree::Literal(self::Literal { kind, symbol, suffix, span }) => {\n+                return tokenstream::TokenTree::token(\n+                    TokenKind::lit(kind.to_internal(), symbol, suffix),\n+                    span,\n+                )\n+                .into();\n             }\n         };\n \n@@ -292,13 +337,6 @@ impl ToInternal<rustc_errors::Level> for Level {\n \n pub struct FreeFunctions;\n \n-// FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n-#[derive(Clone, Debug)]\n-pub struct Literal {\n-    lit: token::Lit,\n-    span: Span,\n-}\n-\n pub(crate) struct Rustc<'a, 'b> {\n     ecx: &'a mut ExtCtxt<'b>,\n     def_site: Span,\n@@ -324,16 +362,11 @@ impl<'a, 'b> Rustc<'a, 'b> {\n     fn sess(&self) -> &ParseSess {\n         self.ecx.parse_sess()\n     }\n-\n-    fn lit(&mut self, kind: token::LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Literal {\n-        Literal { lit: token::Lit::new(kind, symbol, suffix), span: self.call_site }\n-    }\n }\n \n impl server::Types for Rustc<'_, '_> {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n-    type Literal = Literal;\n     type SourceFile = Lrc<SourceFile>;\n     type MultiSpan = Vec<Span>;\n     type Diagnostic = Diagnostic;\n@@ -352,6 +385,94 @@ impl server::FreeFunctions for Rustc<'_, '_> {\n     fn track_path(&mut self, path: &str) {\n         self.sess().file_depinfo.borrow_mut().insert(Symbol::intern(path));\n     }\n+\n+    fn literal_from_str(&mut self, s: &str) -> Result<Literal<Self::Span, Self::Symbol>, ()> {\n+        let name = FileName::proc_macro_source_code(s);\n+        let mut parser = rustc_parse::new_parser_from_source_str(self.sess(), name, s.to_owned());\n+\n+        let first_span = parser.token.span.data();\n+        let minus_present = parser.eat(&token::BinOp(token::Minus));\n+\n+        let lit_span = parser.token.span.data();\n+        let token::Literal(mut lit) = parser.token.kind else {\n+            return Err(());\n+        };\n+\n+        // Check no comment or whitespace surrounding the (possibly negative)\n+        // literal, or more tokens after it.\n+        if (lit_span.hi.0 - first_span.lo.0) as usize != s.len() {\n+            return Err(());\n+        }\n+\n+        if minus_present {\n+            // If minus is present, check no comment or whitespace in between it\n+            // and the literal token.\n+            if first_span.hi.0 != lit_span.lo.0 {\n+                return Err(());\n+            }\n+\n+            // Check literal is a kind we allow to be negated in a proc macro token.\n+            match lit.kind {\n+                token::LitKind::Bool\n+                | token::LitKind::Byte\n+                | token::LitKind::Char\n+                | token::LitKind::Str\n+                | token::LitKind::StrRaw(_)\n+                | token::LitKind::ByteStr\n+                | token::LitKind::ByteStrRaw(_)\n+                | token::LitKind::Err => return Err(()),\n+                token::LitKind::Integer | token::LitKind::Float => {}\n+            }\n+\n+            // Synthesize a new symbol that includes the minus sign.\n+            let symbol = Symbol::intern(&s[..1 + lit.symbol.as_str().len()]);\n+            lit = token::Lit::new(lit.kind, symbol, lit.suffix);\n+        }\n+        let token::Lit { kind, symbol, suffix } = lit;\n+        Ok(Literal {\n+            kind: FromInternal::from_internal(kind),\n+            symbol,\n+            suffix,\n+            span: self.call_site,\n+        })\n+    }\n+\n+    fn literal_subspan(\n+        &mut self,\n+        literal: Literal<Self::Span, Self::Symbol>,\n+        start: Bound<usize>,\n+        end: Bound<usize>,\n+    ) -> Option<Self::Span> {\n+        let span = literal.span;\n+        let length = span.hi().to_usize() - span.lo().to_usize();\n+\n+        let start = match start {\n+            Bound::Included(lo) => lo,\n+            Bound::Excluded(lo) => lo.checked_add(1)?,\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end = match end {\n+            Bound::Included(hi) => hi.checked_add(1)?,\n+            Bound::Excluded(hi) => hi,\n+            Bound::Unbounded => length,\n+        };\n+\n+        // Bounds check the values, preventing addition overflow and OOB spans.\n+        if start > u32::MAX as usize\n+            || end > u32::MAX as usize\n+            || (u32::MAX - start as u32) < span.lo().to_u32()\n+            || (u32::MAX - end as u32) < span.lo().to_u32()\n+            || start >= end\n+            || end > length\n+        {\n+            return None;\n+        }\n+\n+        let new_lo = span.lo() + BytePos::from_usize(start);\n+        let new_hi = span.lo() + BytePos::from_usize(end);\n+        Some(span.with_lo(new_lo).with_hi(new_hi))\n+    }\n }\n \n impl server::TokenStream for Rustc<'_, '_> {\n@@ -429,15 +550,15 @@ impl server::TokenStream for Rustc<'_, '_> {\n \n     fn from_token_tree(\n         &mut self,\n-        tree: TokenTree<Self::TokenStream, Self::Span, Self::Symbol, Self::Literal>,\n+        tree: TokenTree<Self::TokenStream, Self::Span, Self::Symbol>,\n     ) -> Self::TokenStream {\n         (tree, &mut *self).to_internal()\n     }\n \n     fn concat_trees(\n         &mut self,\n         base: Option<Self::TokenStream>,\n-        trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol, Self::Literal>>,\n+        trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol>>,\n     ) -> Self::TokenStream {\n         let mut builder = tokenstream::TokenStreamBuilder::new();\n         if let Some(base) = base {\n@@ -467,164 +588,11 @@ impl server::TokenStream for Rustc<'_, '_> {\n     fn into_trees(\n         &mut self,\n         stream: Self::TokenStream,\n-    ) -> Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol, Self::Literal>> {\n+    ) -> Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol>> {\n         FromInternal::from_internal((stream, self))\n     }\n }\n \n-impl server::Literal for Rustc<'_, '_> {\n-    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n-        let name = FileName::proc_macro_source_code(s);\n-        let mut parser = rustc_parse::new_parser_from_source_str(self.sess(), name, s.to_owned());\n-\n-        let first_span = parser.token.span.data();\n-        let minus_present = parser.eat(&token::BinOp(token::Minus));\n-\n-        let lit_span = parser.token.span.data();\n-        let token::Literal(mut lit) = parser.token.kind else {\n-            return Err(());\n-        };\n-\n-        // Check no comment or whitespace surrounding the (possibly negative)\n-        // literal, or more tokens after it.\n-        if (lit_span.hi.0 - first_span.lo.0) as usize != s.len() {\n-            return Err(());\n-        }\n-\n-        if minus_present {\n-            // If minus is present, check no comment or whitespace in between it\n-            // and the literal token.\n-            if first_span.hi.0 != lit_span.lo.0 {\n-                return Err(());\n-            }\n-\n-            // Check literal is a kind we allow to be negated in a proc macro token.\n-            match lit.kind {\n-                token::LitKind::Bool\n-                | token::LitKind::Byte\n-                | token::LitKind::Char\n-                | token::LitKind::Str\n-                | token::LitKind::StrRaw(_)\n-                | token::LitKind::ByteStr\n-                | token::LitKind::ByteStrRaw(_)\n-                | token::LitKind::Err => return Err(()),\n-                token::LitKind::Integer | token::LitKind::Float => {}\n-            }\n-\n-            // Synthesize a new symbol that includes the minus sign.\n-            let symbol = Symbol::intern(&s[..1 + lit.symbol.as_str().len()]);\n-            lit = token::Lit::new(lit.kind, symbol, lit.suffix);\n-        }\n-\n-        Ok(Literal { lit, span: self.call_site })\n-    }\n-\n-    fn to_string(&mut self, literal: &Self::Literal) -> String {\n-        literal.lit.to_string()\n-    }\n-\n-    fn debug_kind(&mut self, literal: &Self::Literal) -> String {\n-        format!(\"{:?}\", literal.lit.kind)\n-    }\n-\n-    fn symbol(&mut self, literal: &Self::Literal) -> String {\n-        literal.lit.symbol.to_string()\n-    }\n-\n-    fn suffix(&mut self, literal: &Self::Literal) -> Option<String> {\n-        literal.lit.suffix.as_ref().map(Symbol::to_string)\n-    }\n-\n-    fn integer(&mut self, n: &str) -> Self::Literal {\n-        self.lit(token::Integer, Symbol::intern(n), None)\n-    }\n-\n-    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n-        self.lit(token::Integer, Symbol::intern(n), Some(Symbol::intern(kind)))\n-    }\n-\n-    fn float(&mut self, n: &str) -> Self::Literal {\n-        self.lit(token::Float, Symbol::intern(n), None)\n-    }\n-\n-    fn f32(&mut self, n: &str) -> Self::Literal {\n-        self.lit(token::Float, Symbol::intern(n), Some(sym::f32))\n-    }\n-\n-    fn f64(&mut self, n: &str) -> Self::Literal {\n-        self.lit(token::Float, Symbol::intern(n), Some(sym::f64))\n-    }\n-\n-    fn string(&mut self, string: &str) -> Self::Literal {\n-        let quoted = format!(\"{:?}\", string);\n-        assert!(quoted.starts_with('\"') && quoted.ends_with('\"'));\n-        let symbol = &quoted[1..quoted.len() - 1];\n-        self.lit(token::Str, Symbol::intern(symbol), None)\n-    }\n-\n-    fn character(&mut self, ch: char) -> Self::Literal {\n-        let quoted = format!(\"{:?}\", ch);\n-        assert!(quoted.starts_with('\\'') && quoted.ends_with('\\''));\n-        let symbol = &quoted[1..quoted.len() - 1];\n-        self.lit(token::Char, Symbol::intern(symbol), None)\n-    }\n-\n-    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n-        let string = bytes\n-            .iter()\n-            .cloned()\n-            .flat_map(ascii::escape_default)\n-            .map(Into::<char>::into)\n-            .collect::<String>();\n-        self.lit(token::ByteStr, Symbol::intern(&string), None)\n-    }\n-\n-    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n-        literal.span\n-    }\n-\n-    fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n-        literal.span = span;\n-    }\n-\n-    fn subspan(\n-        &mut self,\n-        literal: &Self::Literal,\n-        start: Bound<usize>,\n-        end: Bound<usize>,\n-    ) -> Option<Self::Span> {\n-        let span = literal.span;\n-        let length = span.hi().to_usize() - span.lo().to_usize();\n-\n-        let start = match start {\n-            Bound::Included(lo) => lo,\n-            Bound::Excluded(lo) => lo.checked_add(1)?,\n-            Bound::Unbounded => 0,\n-        };\n-\n-        let end = match end {\n-            Bound::Included(hi) => hi.checked_add(1)?,\n-            Bound::Excluded(hi) => hi,\n-            Bound::Unbounded => length,\n-        };\n-\n-        // Bounds check the values, preventing addition overflow and OOB spans.\n-        if start > u32::MAX as usize\n-            || end > u32::MAX as usize\n-            || (u32::MAX - start as u32) < span.lo().to_u32()\n-            || (u32::MAX - end as u32) < span.lo().to_u32()\n-            || start >= end\n-            || end > length\n-        {\n-            return None;\n-        }\n-\n-        let new_lo = span.lo() + BytePos::from_usize(start);\n-        let new_hi = span.lo() + BytePos::from_usize(end);\n-        Some(span.with_lo(new_lo).with_hi(new_hi))\n-    }\n-}\n-\n impl server::SourceFile for Rustc<'_, '_> {\n     fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n         Lrc::ptr_eq(file1, file2)"}, {"sha": "1516f084ab8b65b3db8821f78cc314dd6712cd2b", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "patch": "@@ -175,7 +175,6 @@ define_handles! {\n     'owned:\n     FreeFunctions,\n     TokenStream,\n-    Literal,\n     SourceFile,\n     MultiSpan,\n     Diagnostic,\n@@ -196,25 +195,6 @@ impl Clone for TokenStream {\n     }\n }\n \n-impl Clone for Literal {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Literal\")\n-            // format the kind without quotes, as in `kind: Float`\n-            .field(\"kind\", &format_args!(\"{}\", &self.debug_kind()))\n-            .field(\"symbol\", &self.symbol())\n-            // format `Some(\"...\")` on one line even in {:#?} mode\n-            .field(\"suffix\", &format_args!(\"{:?}\", &self.suffix()))\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n impl Clone for SourceFile {\n     fn clone(&self) -> Self {\n         self.clone()"}, {"sha": "712b8c637973e9ca115235a2d5f28bab27b972f3", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "patch": "@@ -56,6 +56,8 @@ macro_rules! with_api {\n                 fn drop($self: $S::FreeFunctions);\n                 fn track_env_var(var: &str, value: Option<&str>);\n                 fn track_path(path: &str);\n+                fn literal_from_str(s: &str) -> Result<Literal<$S::Span, $S::Symbol>, ()>;\n+                fn literal_subspan(lit: Literal<$S::Span, $S::Symbol>, start: Bound<usize>, end: Bound<usize>) -> Option<$S::Span>;\n             },\n             TokenStream {\n                 fn drop($self: $S::TokenStream);\n@@ -65,43 +67,19 @@ macro_rules! with_api {\n                 fn from_str(src: &str) -> $S::TokenStream;\n                 fn to_string($self: &$S::TokenStream) -> String;\n                 fn from_token_tree(\n-                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Symbol, $S::Literal>,\n+                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Symbol>,\n                 ) -> $S::TokenStream;\n                 fn concat_trees(\n                     base: Option<$S::TokenStream>,\n-                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Symbol, $S::Literal>>,\n+                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Symbol>>,\n                 ) -> $S::TokenStream;\n                 fn concat_streams(\n                     base: Option<$S::TokenStream>,\n                     streams: Vec<$S::TokenStream>,\n                 ) -> $S::TokenStream;\n                 fn into_trees(\n                     $self: $S::TokenStream\n-                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Symbol, $S::Literal>>;\n-            },\n-            Literal {\n-                fn drop($self: $S::Literal);\n-                fn clone($self: &$S::Literal) -> $S::Literal;\n-                fn from_str(s: &str) -> Result<$S::Literal, ()>;\n-                fn to_string($self: &$S::Literal) -> String;\n-                fn debug_kind($self: &$S::Literal) -> String;\n-                fn symbol($self: &$S::Literal) -> String;\n-                fn suffix($self: &$S::Literal) -> Option<String>;\n-                fn integer(n: &str) -> $S::Literal;\n-                fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n-                fn float(n: &str) -> $S::Literal;\n-                fn f32(n: &str) -> $S::Literal;\n-                fn f64(n: &str) -> $S::Literal;\n-                fn string(string: &str) -> $S::Literal;\n-                fn character(ch: char) -> $S::Literal;\n-                fn byte_string(bytes: &[u8]) -> $S::Literal;\n-                fn span($self: &$S::Literal) -> $S::Span;\n-                fn set_span($self: &mut $S::Literal, span: $S::Span);\n-                fn subspan(\n-                    $self: &$S::Literal,\n-                    start: Bound<usize>,\n-                    end: Bound<usize>,\n-                ) -> Option<$S::Span>;\n+                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Symbol>>;\n             },\n             SourceFile {\n                 fn drop($self: $S::SourceFile);\n@@ -332,6 +310,7 @@ mark_noop! {\n     u8,\n     usize,\n     Delimiter,\n+    LitKind,\n     Level,\n     LineColumn,\n     Spacing,\n@@ -361,6 +340,33 @@ rpc_encode_decode!(\n     }\n );\n \n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+pub enum LitKind {\n+    Byte,\n+    Char,\n+    Integer,\n+    Float,\n+    Str,\n+    StrRaw(u8),\n+    ByteStr,\n+    ByteStrRaw(u8),\n+    Err,\n+}\n+\n+rpc_encode_decode!(\n+    enum LitKind {\n+        Byte,\n+        Char,\n+        Integer,\n+        Float,\n+        Str,\n+        StrRaw(n),\n+        ByteStr,\n+        ByteStrRaw(n),\n+        Err,\n+    }\n+);\n+\n macro_rules! mark_compound {\n     (struct $name:ident <$($T:ident),+> { $($field:ident),* $(,)? }) => {\n         impl<$($T: Mark),+> Mark for $name <$($T),+> {\n@@ -477,16 +483,26 @@ pub struct Ident<Span, Symbol> {\n \n compound_traits!(struct Ident<Span, Symbol> { sym, is_raw, span });\n \n+#[derive(Clone, Eq, PartialEq)]\n+pub struct Literal<Span, Symbol> {\n+    pub kind: LitKind,\n+    pub symbol: Symbol,\n+    pub suffix: Option<Symbol>,\n+    pub span: Span,\n+}\n+\n+compound_traits!(struct Literal<Sp, Sy> { kind, symbol, suffix, span });\n+\n #[derive(Clone)]\n-pub enum TokenTree<TokenStream, Span, Symbol, Literal> {\n+pub enum TokenTree<TokenStream, Span, Symbol> {\n     Group(Group<TokenStream, Span>),\n     Punct(Punct<Span>),\n     Ident(Ident<Span, Symbol>),\n-    Literal(Literal),\n+    Literal(Literal<Span, Symbol>),\n }\n \n compound_traits!(\n-    enum TokenTree<TokenStream, Span, Symbol, Literal> {\n+    enum TokenTree<TokenStream, Span, Symbol> {\n         Group(tt),\n         Punct(tt),\n         Ident(tt),"}, {"sha": "d46e325951d72fd2013fa34c3245f21dffa204dc", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "patch": "@@ -8,7 +8,6 @@ use super::client::HandleStore;\n pub trait Types {\n     type FreeFunctions: 'static;\n     type TokenStream: 'static + Clone;\n-    type Literal: 'static + Clone;\n     type SourceFile: 'static + Clone;\n     type MultiSpan: 'static;\n     type Diagnostic: 'static;"}, {"sha": "372bd3ac2141ef7a71bb7ce92fbfe627f2382a66", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 110, "deletions": 28, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=b34c79f8f1ef4d0149ad4bf77e1759c07a9a01a8", "patch": "@@ -215,12 +215,7 @@ pub use quote::{quote, quote_span};\n \n fn tree_to_bridge_tree(\n     tree: TokenTree,\n-) -> bridge::TokenTree<\n-    bridge::client::TokenStream,\n-    bridge::client::Span,\n-    bridge::client::Symbol,\n-    bridge::client::Literal,\n-> {\n+) -> bridge::TokenTree<bridge::client::TokenStream, bridge::client::Span, bridge::client::Symbol> {\n     match tree {\n         TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n         TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n@@ -245,7 +240,6 @@ struct ConcatTreesHelper {\n             bridge::client::TokenStream,\n             bridge::client::Span,\n             bridge::client::Symbol,\n-            bridge::client::Literal,\n         >,\n     >,\n }\n@@ -372,7 +366,6 @@ pub mod token_stream {\n                 bridge::client::TokenStream,\n                 bridge::client::Span,\n                 bridge::client::Symbol,\n-                bridge::client::Literal,\n             >,\n         >,\n     );\n@@ -1147,7 +1140,7 @@ impl fmt::Debug for Ident {\n /// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n #[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Literal(bridge::client::Literal);\n+pub struct Literal(bridge::Literal<bridge::client::Span, bridge::client::Symbol>);\n \n macro_rules! suffixed_int_literals {\n     ($($name:ident => $kind:ident,)*) => ($(\n@@ -1164,7 +1157,12 @@ macro_rules! suffixed_int_literals {\n         /// below.\n         #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n         pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::typed_integer(&n.to_string(), stringify!($kind)))\n+            Literal(bridge::Literal {\n+                kind: bridge::LitKind::Integer,\n+                symbol: bridge::client::Symbol::new(&n.to_string()),\n+                suffix: Some(bridge::client::Symbol::new(stringify!($kind))),\n+                span: Span::call_site().0,\n+            })\n         }\n     )*)\n }\n@@ -1186,12 +1184,26 @@ macro_rules! unsuffixed_int_literals {\n         /// below.\n         #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n         pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::integer(&n.to_string()))\n+            Literal(bridge::Literal {\n+                kind: bridge::LitKind::Integer,\n+                symbol: bridge::client::Symbol::new(&n.to_string()),\n+                suffix: None,\n+                span: Span::call_site().0,\n+            })\n         }\n     )*)\n }\n \n impl Literal {\n+    fn new(kind: bridge::LitKind, value: &str, suffix: Option<&str>) -> Self {\n+        Literal(bridge::Literal {\n+            kind,\n+            symbol: bridge::client::Symbol::new(value),\n+            suffix: suffix.map(bridge::client::Symbol::new),\n+            span: Span::call_site().0,\n+        })\n+    }\n+\n     suffixed_int_literals! {\n         u8_suffixed => u8,\n         u16_suffixed => u16,\n@@ -1243,7 +1255,7 @@ impl Literal {\n         if !repr.contains('.') {\n             repr.push_str(\".0\");\n         }\n-        Literal(bridge::client::Literal::float(&repr))\n+        Literal::new(bridge::LitKind::Float, &repr, None)\n     }\n \n     /// Creates a new suffixed floating-point literal.\n@@ -1264,7 +1276,7 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {n}\");\n         }\n-        Literal(bridge::client::Literal::f32(&n.to_string()))\n+        Literal::new(bridge::LitKind::Float, &n.to_string(), Some(\"f32\"))\n     }\n \n     /// Creates a new unsuffixed floating-point literal.\n@@ -1288,7 +1300,7 @@ impl Literal {\n         if !repr.contains('.') {\n             repr.push_str(\".0\");\n         }\n-        Literal(bridge::client::Literal::float(&repr))\n+        Literal::new(bridge::LitKind::Float, &repr, None)\n     }\n \n     /// Creates a new suffixed floating-point literal.\n@@ -1309,37 +1321,49 @@ impl Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {n}\");\n         }\n-        Literal(bridge::client::Literal::f64(&n.to_string()))\n+        Literal::new(bridge::LitKind::Float, &n.to_string(), Some(\"f64\"))\n     }\n \n     /// String literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn string(string: &str) -> Literal {\n-        Literal(bridge::client::Literal::string(string))\n+        let quoted = format!(\"{:?}\", string);\n+        assert!(quoted.starts_with('\"') && quoted.ends_with('\"'));\n+        let symbol = &quoted[1..quoted.len() - 1];\n+        Literal::new(bridge::LitKind::Str, symbol, None)\n     }\n \n     /// Character literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn character(ch: char) -> Literal {\n-        Literal(bridge::client::Literal::character(ch))\n+        let quoted = format!(\"{:?}\", ch);\n+        assert!(quoted.starts_with('\\'') && quoted.ends_with('\\''));\n+        let symbol = &quoted[1..quoted.len() - 1];\n+        Literal::new(bridge::LitKind::Char, symbol, None)\n     }\n \n     /// Byte string literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn byte_string(bytes: &[u8]) -> Literal {\n-        Literal(bridge::client::Literal::byte_string(bytes))\n+        let string = bytes\n+            .iter()\n+            .cloned()\n+            .flat_map(std::ascii::escape_default)\n+            .map(Into::<char>::into)\n+            .collect::<String>();\n+        Literal::new(bridge::LitKind::ByteStr, &string, None)\n     }\n \n     /// Returns the span encompassing this literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        Span(self.0.span())\n+        Span(self.0.span)\n     }\n \n     /// Configures the span associated for this literal.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.0.set_span(span.0);\n+        self.0.span = span.0;\n     }\n \n     /// Returns a `Span` that is a subset of `self.span()` containing only the\n@@ -1355,7 +1379,55 @@ impl Literal {\n     // was 'c' or whether it was '\\u{63}'.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n-        self.0.subspan(range.start_bound().cloned(), range.end_bound().cloned()).map(Span)\n+        bridge::client::FreeFunctions::literal_subspan(\n+            self.0.clone(),\n+            range.start_bound().cloned(),\n+            range.end_bound().cloned(),\n+        )\n+        .map(Span)\n+    }\n+\n+    fn with_symbol_and_suffix<R>(&self, f: impl FnOnce(&str, &str) -> R) -> R {\n+        self.0.symbol.with(|symbol| match self.0.suffix {\n+            Some(suffix) => suffix.with(|suffix| f(symbol, suffix)),\n+            None => f(symbol, \"\"),\n+        })\n+    }\n+\n+    /// Invokes the callback with a `&[&str]` consisting of each part of the\n+    /// literal's representation. This is done to allow the `ToString` and\n+    /// `Display` implementations to borrow references to symbol values, and\n+    /// both be optimized to reduce overhead.\n+    fn with_stringify_parts<R>(&self, f: impl FnOnce(&[&str]) -> R) -> R {\n+        /// Returns a string containing exactly `num` '#' characters.\n+        /// Uses a 256-character source string literal which is always safe to\n+        /// index with a `u8` index.\n+        fn get_hashes_str(num: u8) -> &'static str {\n+            const HASHES: &str = \"\\\n+            ################################################################\\\n+            ################################################################\\\n+            ################################################################\\\n+            ################################################################\\\n+            \";\n+            const _: () = assert!(HASHES.len() == 256);\n+            &HASHES[..num as usize]\n+        }\n+\n+        self.with_symbol_and_suffix(|symbol, suffix| match self.0.kind {\n+            bridge::LitKind::Byte => f(&[\"b'\", symbol, \"'\", suffix]),\n+            bridge::LitKind::Char => f(&[\"'\", symbol, \"'\", suffix]),\n+            bridge::LitKind::Str => f(&[\"\\\"\", symbol, \"\\\"\", suffix]),\n+            bridge::LitKind::StrRaw(n) => {\n+                let hashes = get_hashes_str(n);\n+                f(&[\"r\", hashes, \"\\\"\", symbol, \"\\\"\", hashes, suffix])\n+            }\n+            bridge::LitKind::ByteStr => f(&[\"b\\\"\", symbol, \"\\\"\", suffix]),\n+            bridge::LitKind::ByteStrRaw(n) => {\n+                let hashes = get_hashes_str(n);\n+                f(&[\"br\", hashes, \"\\\"\", symbol, \"\\\"\", hashes, suffix])\n+            }\n+            _ => f(&[symbol, suffix]),\n+        })\n     }\n }\n \n@@ -1374,19 +1446,17 @@ impl FromStr for Literal {\n     type Err = LexError;\n \n     fn from_str(src: &str) -> Result<Self, LexError> {\n-        match bridge::client::Literal::from_str(src) {\n+        match bridge::client::FreeFunctions::literal_from_str(src) {\n             Ok(literal) => Ok(Literal(literal)),\n             Err(()) => Err(LexError),\n         }\n     }\n }\n \n-// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n-// based on it (the reverse of the usual relationship between the two).\n-#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl ToString for Literal {\n     fn to_string(&self) -> String {\n-        self.0.to_string()\n+        self.with_stringify_parts(|parts| parts.concat())\n     }\n }\n \n@@ -1395,14 +1465,26 @@ impl ToString for Literal {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n+        self.with_stringify_parts(|parts| {\n+            for part in parts {\n+                fmt::Display::fmt(part, f)?;\n+            }\n+            Ok(())\n+        })\n     }\n }\n \n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Debug for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n+        f.debug_struct(\"Literal\")\n+            // format the kind on one line even in {:#?} mode\n+            .field(\"kind\", &format_args!(\"{:?}\", &self.0.kind))\n+            .field(\"symbol\", &self.0.symbol)\n+            // format `Some(\"...\")` on one line even in {:#?} mode\n+            .field(\"suffix\", &format_args!(\"{:?}\", &self.0.suffix))\n+            .field(\"span\", &self.0.span)\n+            .finish()\n     }\n }\n "}]}