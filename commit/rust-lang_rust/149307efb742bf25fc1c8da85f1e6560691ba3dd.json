{"sha": "149307efb742bf25fc1c8da85f1e6560691ba3dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0OTMwN2VmYjc0MmJmMjVmYzFjOGRhODVmMWU2NTYwNjkxYmEzZGQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-28T01:07:27Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-30T18:13:18Z"}, "message": "Improve `BitSet` APIs\n\nA few small cleanups to `BitSet` and friends:\n\n- Overload `clone_from` for `BitSet`.\n- Improve `Debug` represenation of `HybridBitSet`.\n- Make `HybridBitSet::domain_size` public.\n- Don't require `T: Idx` at the type level. The `Idx` bound is still on\n  most `BitSet` methods, but like `HashMap`, it doesn't need to be\n  satisfied for the type to exist.", "tree": {"sha": "e9ffe1252d8beddd697c26a4cda191e4496a6b25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9ffe1252d8beddd697c26a4cda191e4496a6b25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/149307efb742bf25fc1c8da85f1e6560691ba3dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/149307efb742bf25fc1c8da85f1e6560691ba3dd", "html_url": "https://github.com/rust-lang/rust/commit/149307efb742bf25fc1c8da85f1e6560691ba3dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/149307efb742bf25fc1c8da85f1e6560691ba3dd/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85fbf49ce0e2274d0acf798f6e703747674feec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/85fbf49ce0e2274d0acf798f6e703747674feec3", "html_url": "https://github.com/rust-lang/rust/commit/85fbf49ce0e2274d0acf798f6e703747674feec3"}], "stats": {"total": 54, "additions": 37, "deletions": 17}, "files": [{"sha": "8e00e54650df0405269a9671bdd3572c22df64f2", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/149307efb742bf25fc1c8da85f1e6560691ba3dd/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/149307efb742bf25fc1c8da85f1e6560691ba3dd/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=149307efb742bf25fc1c8da85f1e6560691ba3dd", "patch": "@@ -28,13 +28,20 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n /// will panic if the bitsets have differing domain sizes.\n ///\n /// [`GrowableBitSet`]: struct.GrowableBitSet.html\n-#[derive(Clone, Eq, PartialEq, Decodable, Encodable)]\n-pub struct BitSet<T: Idx> {\n+#[derive(Eq, PartialEq, Decodable, Encodable)]\n+pub struct BitSet<T> {\n     domain_size: usize,\n     words: Vec<Word>,\n     marker: PhantomData<T>,\n }\n \n+impl<T> BitSet<T> {\n+    /// Gets the domain size.\n+    pub fn domain_size(&self) -> usize {\n+        self.domain_size\n+    }\n+}\n+\n impl<T: Idx> BitSet<T> {\n     /// Creates a new, empty bitset with a given `domain_size`.\n     #[inline]\n@@ -52,11 +59,6 @@ impl<T: Idx> BitSet<T> {\n         result\n     }\n \n-    /// Gets the domain size.\n-    pub fn domain_size(&self) -> usize {\n-        self.domain_size\n-    }\n-\n     /// Clear all elements.\n     #[inline]\n     pub fn clear(&mut self) {\n@@ -75,12 +77,6 @@ impl<T: Idx> BitSet<T> {\n         }\n     }\n \n-    /// Efficiently overwrite `self` with `other`.\n-    pub fn overwrite(&mut self, other: &BitSet<T>) {\n-        assert!(self.domain_size == other.domain_size);\n-        self.words.clone_from_slice(&other.words);\n-    }\n-\n     /// Count the number of set bits in the set.\n     pub fn count(&self) -> usize {\n         self.words.iter().map(|e| e.count_ones() as usize).sum()\n@@ -243,6 +239,21 @@ impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n     }\n }\n \n+impl<T> Clone for BitSet<T> {\n+    fn clone(&self) -> Self {\n+        BitSet { domain_size: self.domain_size, words: self.words.clone(), marker: PhantomData }\n+    }\n+\n+    fn clone_from(&mut self, from: &Self) {\n+        if self.domain_size != from.domain_size {\n+            self.words.resize(from.domain_size, 0);\n+            self.domain_size = from.domain_size;\n+        }\n+\n+        self.words.copy_from_slice(&from.words);\n+    }\n+}\n+\n impl<T: Idx> fmt::Debug for BitSet<T> {\n     fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n         w.debug_list().entries(self.iter()).finish()\n@@ -363,7 +374,7 @@ const SPARSE_MAX: usize = 8;\n ///\n /// This type is used by `HybridBitSet`; do not use directly.\n #[derive(Clone, Debug)]\n-pub struct SparseBitSet<T: Idx> {\n+pub struct SparseBitSet<T> {\n     domain_size: usize,\n     elems: ArrayVec<[T; SPARSE_MAX]>,\n }\n@@ -464,18 +475,27 @@ impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n /// All operations that involve an element will panic if the element is equal\n /// to or greater than the domain size. All operations that involve two bitsets\n /// will panic if the bitsets have differing domain sizes.\n-#[derive(Clone, Debug)]\n-pub enum HybridBitSet<T: Idx> {\n+#[derive(Clone)]\n+pub enum HybridBitSet<T> {\n     Sparse(SparseBitSet<T>),\n     Dense(BitSet<T>),\n }\n \n+impl<T: Idx> fmt::Debug for HybridBitSet<T> {\n+    fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Sparse(b) => b.fmt(w),\n+            Self::Dense(b) => b.fmt(w),\n+        }\n+    }\n+}\n+\n impl<T: Idx> HybridBitSet<T> {\n     pub fn new_empty(domain_size: usize) -> Self {\n         HybridBitSet::Sparse(SparseBitSet::new_empty(domain_size))\n     }\n \n-    fn domain_size(&self) -> usize {\n+    pub fn domain_size(&self) -> usize {\n         match self {\n             HybridBitSet::Sparse(sparse) => sparse.domain_size,\n             HybridBitSet::Dense(dense) => dense.domain_size,"}]}