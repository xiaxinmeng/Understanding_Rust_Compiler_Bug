{"sha": "62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3", "node_id": "C_kwDOAAsO6NoAKDYyZDZiNWE1OTRjNGI4ZmE1M2VlYzI1ZTRiMmQyZmQyNTgwYTMxZjM", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-05-30T17:34:09Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-05-31T16:22:11Z"}, "message": "Generalize some inference functions for patterns", "tree": {"sha": "a478ff0ca4cf0b8b021ded62f26d0c5dbc26dd8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a478ff0ca4cf0b8b021ded62f26d0c5dbc26dd8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmKWQLMACgkQ4laYqTBY\nYXGNYxAAq0HH52b0nUM4XDm5PLRmDRv8XZTLhvDV7E/0sKfUSKUBrOo02vGSaPWJ\n1/dd9GxNEO7J4bM8ApSza5IQqTYe+en+BmCiXMfNJSpYh525z22NOiExNBMTC2KH\nNhxM64IAyW9nDt61dHb8lv2YUgH5TgCFqI4h6GvMNEwZZLGI76+jECGmNwZzaaOT\nqdfM97Szr+08Gnxc9wQxmuph7aPq7h9Eftf24PMHiO5yd9wnGsQL1DMdiVHqmkxc\n43SNkCSIkH+aa16wRJiJyKofxG+46mqoZJogP32ucwnn0rEKk8qOyOoGlfqkdxXp\nma5fokW/0ZuQl3eLYg6S4RCdC+aWkCe/2CKL2+oO2vrH/j0A84OZrJ4XXkgue0Hh\nLExTYoCY2QEtMumRmqPYmXKej8D9MeO3oXT6ylLWnEMd6DDmKpLJlwnyOyLZ501d\nQDsFXHmmzzU1n8szjA/swMc7mwum27KaU+cg697fw8ciqh2oLE0ENag4jl/FpHFc\nihdhG7wde9Q++SQ23zDnPU7aozOGbkaDVeKWEtTzl5btqTTfcOZTpdLjOGhUWK+q\nhFKrB1SrvVUmPTgG9ERB6iO2Faqe8jQWiHvTnH5uLNE+nKm1Oh4epw4p2MXWx2gl\nK0+GlUdIOmoTICf3m5Yy/rXIHLcO5ycwr35idE4G3q6pJ2CGKXc=\n=n5hc\n-----END PGP SIGNATURE-----", "payload": "tree a478ff0ca4cf0b8b021ded62f26d0c5dbc26dd8a\nparent c1c867506b69410f6c92ddbe2d7c6b81ab9974ab\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1653932049 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1654014131 +0900\n\nGeneralize some inference functions for patterns\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3", "html_url": "https://github.com/rust-lang/rust/commit/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1c867506b69410f6c92ddbe2d7c6b81ab9974ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c867506b69410f6c92ddbe2d7c6b81ab9974ab", "html_url": "https://github.com/rust-lang/rust/commit/c1c867506b69410f6c92ddbe2d7c6b81ab9974ab"}], "stats": {"total": 171, "additions": 107, "deletions": 64}, "files": [{"sha": "4b80f06a3aed2a34da792f81262703b9bcf8cc49", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3", "patch": "@@ -125,6 +125,31 @@ impl Default for BindingMode {\n     }\n }\n \n+/// Used to generalize patterns and assignee expressions.\n+trait PatLike: Into<ExprOrPatId> + Copy {\n+    type BindingMode: Copy;\n+\n+    fn infer(\n+        this: &mut InferenceContext,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty;\n+}\n+\n+impl PatLike for PatId {\n+    type BindingMode = BindingMode;\n+\n+    fn infer(\n+        this: &mut InferenceContext,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty {\n+        this.infer_pat(id, expected_ty, default_bm)\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct InferOk<T> {\n     value: T,"}, {"sha": "dc86f696d4fcad83a49a78a43531ce6b1be99958", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 82, "deletions": 64, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=62d6b5a594c4b8fa53eec25e4b2d2fd2580a31f3", "patch": "@@ -4,7 +4,7 @@ use std::iter::repeat_with;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{BindingAnnotation, Expr, Literal, Pat, PatId, RecordFieldPat},\n+    expr::{BindingAnnotation, Expr, Literal, Pat, PatId},\n     path::Path,\n     type_ref::ConstScalar,\n };\n@@ -17,15 +17,20 @@ use crate::{\n     TyKind,\n };\n \n+use super::PatLike;\n+\n impl<'a> InferenceContext<'a> {\n-    fn infer_tuple_struct_pat(\n+    /// Infers type for tuple struct pattern or its corresponding assignee expression.\n+    ///\n+    /// Ellipses found in the original pattern or expression must be filtered out.\n+    pub(super) fn infer_tuple_struct_pat_like<T: PatLike>(\n         &mut self,\n         path: Option<&Path>,\n-        subpats: &[PatId],\n         expected: &Ty,\n-        default_bm: BindingMode,\n-        id: PatId,\n+        default_bm: T::BindingMode,\n+        id: T,\n         ellipsis: Option<usize>,\n+        subs: &[T],\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path, true);\n         let var_data = def.map(|it| it.variant_data(self.db.upcast()));\n@@ -39,8 +44,8 @@ impl<'a> InferenceContext<'a> {\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n         let (pre, post) = match ellipsis {\n-            Some(idx) => subpats.split_at(idx),\n-            None => (subpats, &[][..]),\n+            Some(idx) => subs.split_at(idx),\n+            None => (subs, &[][..]),\n         };\n         let post_idx_offset = field_tys.iter().count().saturating_sub(post.len());\n \n@@ -54,22 +59,22 @@ impl<'a> InferenceContext<'a> {\n                     field_tys[field].clone().substitute(Interner, &substs)\n                 });\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n-            self.infer_pat(subpat, &expected_ty, default_bm);\n+            T::infer(self, subpat, &expected_ty, default_bm);\n         }\n \n         ty\n     }\n \n-    fn infer_record_pat(\n+    /// Infers type for record pattern or its corresponding assignee expression.\n+    pub(super) fn infer_record_pat_like<T: PatLike>(\n         &mut self,\n         path: Option<&Path>,\n-        subpats: &[RecordFieldPat],\n         expected: &Ty,\n-        default_bm: BindingMode,\n-        id: PatId,\n+        default_bm: T::BindingMode,\n+        id: T,\n+        subs: impl Iterator<Item = (Name, T)>,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path, false);\n-        let var_data = def.map(|it| it.variant_data(self.db.upcast()));\n         if let Some(variant) = def {\n             self.write_variant_resolution(id.into(), variant);\n         }\n@@ -80,18 +85,64 @@ impl<'a> InferenceContext<'a> {\n             ty.as_adt().map(|(_, s)| s.clone()).unwrap_or_else(|| Substitution::empty(Interner));\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n-        for subpat in subpats {\n-            let matching_field = var_data.as_ref().and_then(|it| it.field(&subpat.name));\n-            let expected_ty = matching_field.map_or(self.err_ty(), |field| {\n-                field_tys[field].clone().substitute(Interner, &substs)\n-            });\n+        let var_data = def.map(|it| it.variant_data(self.db.upcast()));\n+\n+        for (name, inner) in subs {\n+            let expected_ty = var_data\n+                .as_ref()\n+                .and_then(|it| it.field(&name))\n+                .map_or(self.err_ty(), |f| field_tys[f].clone().substitute(Interner, &substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n-            self.infer_pat(subpat.pat, &expected_ty, default_bm);\n+\n+            T::infer(self, inner, &expected_ty, default_bm);\n         }\n \n         ty\n     }\n \n+    /// Infers type for tuple pattern or its corresponding assignee expression.\n+    ///\n+    /// Ellipses found in the original pattern or expression must be filtered out.\n+    pub(super) fn infer_tuple_pat_like<T: PatLike>(\n+        &mut self,\n+        expected: &Ty,\n+        default_bm: T::BindingMode,\n+        ellipsis: Option<usize>,\n+        subs: &[T],\n+    ) -> Ty {\n+        let expectations = match expected.as_tuple() {\n+            Some(parameters) => &*parameters.as_slice(Interner),\n+            _ => &[],\n+        };\n+\n+        let ((pre, post), n_uncovered_patterns) = match ellipsis {\n+            Some(idx) => (subs.split_at(idx), expectations.len().saturating_sub(subs.len())),\n+            None => ((&subs[..], &[][..]), 0),\n+        };\n+        let mut expectations_iter = expectations\n+            .iter()\n+            .cloned()\n+            .map(|a| a.assert_ty_ref(Interner).clone())\n+            .chain(repeat_with(|| self.table.new_type_var()));\n+\n+        let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + subs.len());\n+\n+        inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns + subs.len()));\n+\n+        // Process pre\n+        for (ty, pat) in inner_tys.iter_mut().zip(pre) {\n+            *ty = T::infer(self, *pat, ty, default_bm);\n+        }\n+\n+        // Process post\n+        for (ty, pat) in inner_tys.iter_mut().skip(pre.len() + n_uncovered_patterns).zip(post) {\n+            *ty = T::infer(self, *pat, ty, default_bm);\n+        }\n+\n+        TyKind::Tuple(inner_tys.len(), Substitution::from_iter(Interner, inner_tys))\n+            .intern(Interner)\n+    }\n+\n     pub(super) fn infer_pat(\n         &mut self,\n         pat: PatId,\n@@ -129,42 +180,7 @@ impl<'a> InferenceContext<'a> {\n \n         let ty = match &self.body[pat] {\n             Pat::Tuple { args, ellipsis } => {\n-                let expectations = match expected.as_tuple() {\n-                    Some(parameters) => &*parameters.as_slice(Interner),\n-                    _ => &[],\n-                };\n-\n-                let ((pre, post), n_uncovered_patterns) = match ellipsis {\n-                    Some(idx) => {\n-                        (args.split_at(*idx), expectations.len().saturating_sub(args.len()))\n-                    }\n-                    None => ((&args[..], &[][..]), 0),\n-                };\n-                let mut expectations_iter = expectations\n-                    .iter()\n-                    .cloned()\n-                    .map(|a| a.assert_ty_ref(Interner).clone())\n-                    .chain(repeat_with(|| self.table.new_type_var()));\n-\n-                let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + args.len());\n-\n-                inner_tys\n-                    .extend(expectations_iter.by_ref().take(n_uncovered_patterns + args.len()));\n-\n-                // Process pre\n-                for (ty, pat) in inner_tys.iter_mut().zip(pre) {\n-                    *ty = self.infer_pat(*pat, ty, default_bm);\n-                }\n-\n-                // Process post\n-                for (ty, pat) in\n-                    inner_tys.iter_mut().skip(pre.len() + n_uncovered_patterns).zip(post)\n-                {\n-                    *ty = self.infer_pat(*pat, ty, default_bm);\n-                }\n-\n-                TyKind::Tuple(inner_tys.len(), Substitution::from_iter(Interner, inner_tys))\n-                    .intern(Interner)\n+                self.infer_tuple_pat_like(&expected, default_bm, *ellipsis, args)\n             }\n             Pat::Or(pats) => {\n                 if let Some((first_pat, rest)) = pats.split_first() {\n@@ -191,16 +207,18 @@ impl<'a> InferenceContext<'a> {\n                 let subty = self.infer_pat(*pat, &expectation, default_bm);\n                 TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n             }\n-            Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n-                p.as_deref(),\n-                subpats,\n-                &expected,\n-                default_bm,\n-                pat,\n-                *ellipsis,\n-            ),\n+            Pat::TupleStruct { path: p, args: subpats, ellipsis } => self\n+                .infer_tuple_struct_pat_like(\n+                    p.as_deref(),\n+                    &expected,\n+                    default_bm,\n+                    pat,\n+                    *ellipsis,\n+                    subpats,\n+                ),\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {\n-                self.infer_record_pat(p.as_deref(), fields, &expected, default_bm, pat)\n+                let subs = fields.iter().map(|f| (f.name.clone(), f.pat));\n+                self.infer_record_pat_like(p.as_deref(), &expected, default_bm, pat.into(), subs)\n             }\n             Pat::Path(path) => {\n                 // FIXME use correct resolver for the surrounding expression"}]}