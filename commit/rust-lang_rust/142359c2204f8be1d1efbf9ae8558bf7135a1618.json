{"sha": "142359c2204f8be1d1efbf9ae8558bf7135a1618", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MjM1OWMyMjA0ZjhiZTFkMWVmYmY5YWU4NTU4YmY3MTM1YTE2MTg=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-10-24T21:41:40Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-03T10:41:55Z"}, "message": "Extend `ty::fold::RegionReplacer` to `ty::fold::BoundVarReplacer`\nUse the new `BoundVarReplacer` to perform canonical substitutions.", "tree": {"sha": "1658ed259a030fb337753ffa6e223ae6a51a8d41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1658ed259a030fb337753ffa6e223ae6a51a8d41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/142359c2204f8be1d1efbf9ae8558bf7135a1618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/142359c2204f8be1d1efbf9ae8558bf7135a1618", "html_url": "https://github.com/rust-lang/rust/commit/142359c2204f8be1d1efbf9ae8558bf7135a1618", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/142359c2204f8be1d1efbf9ae8558bf7135a1618/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d99195ad8fefb5752423c0c5224a2395e7e9255b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d99195ad8fefb5752423c0c5224a2395e7e9255b", "html_url": "https://github.com/rust-lang/rust/commit/d99195ad8fefb5752423c0c5224a2395e7e9255b"}], "stats": {"total": 289, "additions": 149, "deletions": 140}, "files": [{"sha": "3fd86f9c6a1d9f2f850d0301e48e6a24affa583e", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 14, "deletions": 75, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/142359c2204f8be1d1efbf9ae8558bf7135a1618/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142359c2204f8be1d1efbf9ae8558bf7135a1618/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=142359c2204f8be1d1efbf9ae8558bf7135a1618", "patch": "@@ -17,9 +17,9 @@\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n \n use infer::canonical::{Canonical, CanonicalVarValues};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::fold::TypeFoldable;\n use ty::subst::UnpackedKind;\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, TyCtxt};\n \n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n@@ -65,82 +65,21 @@ where\n {\n     if var_values.var_values.is_empty() {\n         value.clone()\n-    } else if !value.has_escaping_bound_vars() {\n-        // There are no bound vars to substitute.\n-        value.clone()\n     } else {\n-        value.fold_with(&mut CanonicalVarValuesSubst {\n-            tcx,\n-            var_values,\n-            binder_index: ty::INNERMOST,\n-        })\n-    }\n-}\n-\n-struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    var_values: &'cx CanonicalVarValues<'tcx>,\n-    binder_index: ty::DebruijnIndex,\n-}\n-\n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n-        where T: TypeFoldable<'tcx>\n-    {\n-        self.binder_index.shift_in(1);\n-        let t = t.super_fold_with(self);\n-        self.binder_index.shift_out(1);\n-        t\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n-            ty::Bound(b) => {\n-                if b.index == self.binder_index {\n-                    match self.var_values.var_values[b.var].unpack() {\n-                        UnpackedKind::Type(ty) => ty::fold::shift_vars(\n-                            self.tcx,\n-                            &ty,\n-                            self.binder_index.index() as u32\n-                        ),\n-                        r => bug!(\"{:?} is a type but value is {:?}\", b, r),\n-                    }\n-                } else {\n-                    t\n-                }\n+        let fld_r = |br: ty::BoundRegion| {\n+            match var_values.var_values[br.as_bound_var()].unpack() {\n+                UnpackedKind::Lifetime(l) => l,\n+                r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n             }\n-            _ => {\n-                if !t.has_vars_bound_at_or_above(self.binder_index) {\n-                    // Nothing more to substitute.\n-                    t\n-                } else {\n-                    t.super_fold_with(self)\n-                }\n-            }\n-        }\n-    }\n+        };\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match r {\n-            ty::RegionKind::ReLateBound(index, br) => {\n-                if *index == self.binder_index {\n-                    match self.var_values.var_values[br.as_bound_var()].unpack() {\n-                        UnpackedKind::Lifetime(l) => ty::fold::shift_region(\n-                            self.tcx,\n-                            l,\n-                            self.binder_index.index() as u32,\n-                        ),\n-                        r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n-                    }\n-                } else {\n-                    r\n-                }\n+        let fld_t = |bound_ty: ty::BoundTy| {\n+            match var_values.var_values[bound_ty.var].unpack() {\n+                UnpackedKind::Type(ty) => ty,\n+                r => bug!(\"{:?} is a type but value is {:?}\", bound_ty, r),\n             }\n-            _ => r.super_fold_with(self),\n-        }\n+        };\n+\n+        tcx.replace_escaping_bound_vars(value, fld_r, fld_t)\n     }\n }"}, {"sha": "06cc316f7883a971d24f82c84adae2ddf198cda8", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 135, "deletions": 65, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/142359c2204f8be1d1efbf9ae8558bf7135a1618/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/142359c2204f8be1d1efbf9ae8558bf7135a1618/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=142359c2204f8be1d1efbf9ae8558bf7135a1618", "patch": "@@ -416,19 +416,93 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Late-bound region replacer\n+// Bound vars replacer\n \n-// Replaces the escaping regions in a type.\n-\n-struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+/// Replaces the escaping bound vars (late bound regions or bound types) in a type.\n+struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     /// As with `RegionFolder`, represents the index of a binder *just outside*\n     /// the ones we have visited.\n     current_index: ty::DebruijnIndex,\n \n     fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n-    map: BTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n+    fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> ty::Ty<'tcx> + 'a),\n+}\n+\n+impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n+    fn new<F, G>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        fld_r: &'a mut F,\n+        fld_t: &'a mut G\n+    ) -> Self\n+        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+              G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>\n+    {\n+        BoundVarReplacer {\n+            tcx,\n+            current_index: ty::INNERMOST,\n+            fld_r,\n+            fld_t,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n+        self.current_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.current_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::Bound(bound_ty) => {\n+                if bound_ty.index == self.current_index {\n+                    let fld_t = &mut self.fld_t;\n+                    let ty = fld_t(bound_ty);\n+                    ty::fold::shift_vars(\n+                        self.tcx,\n+                        &ty,\n+                        self.current_index.as_u32()\n+                    )\n+                } else {\n+                    t\n+                }\n+            }\n+            _ => {\n+                if !t.has_vars_bound_at_or_above(self.current_index) {\n+                    // Nothing more to substitute.\n+                    t\n+                } else {\n+                    t.super_fold_with(self)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n+                let fld_r = &mut self.fld_r;\n+                let region = fld_r(br);\n+                if let ty::ReLateBound(debruijn1, br) = *region {\n+                    // If the callback returns a late-bound region,\n+                    // that region should always use the INNERMOST\n+                    // debruijn index. Then we adjust it to the\n+                    // correct depth.\n+                    assert_eq!(debruijn1, ty::INNERMOST);\n+                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n+                } else {\n+                    region\n+                }\n+            }\n+            _ => r\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -440,16 +514,65 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// same `BoundRegion` will reuse the previous result.  A map is\n     /// returned at the end with each bound region and the free region\n     /// that replaced it.\n-    pub fn replace_late_bound_regions<T,F>(self,\n+    ///\n+    /// This method only replaces late bound regions and the result may still\n+    /// contain escaping bound types.\n+    pub fn replace_late_bound_regions<T, F>(\n+        self,\n         value: &Binder<T>,\n-        mut f: F)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-        where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-              T : TypeFoldable<'tcx>,\n+        mut fld_r: F\n+    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+              T: TypeFoldable<'tcx>\n     {\n-        let mut replacer = RegionReplacer::new(self, &mut f);\n+        let mut map = BTreeMap::new();\n+        let mut real_fldr = |br| {\n+            *map.entry(br).or_insert_with(|| fld_r(br))\n+        };\n+\n+        // identity for bound types\n+        let mut fld_t = |bound_ty| self.mk_ty(ty::Bound(bound_ty));\n+\n+        let mut replacer = BoundVarReplacer::new(self, &mut real_fldr, &mut fld_t);\n         let result = value.skip_binder().fold_with(&mut replacer);\n-        (result, replacer.map)\n+        (result, map)\n+    }\n+\n+    /// Replace all escaping bound vars. The `fld_r` closure replaces escaping\n+    /// bound regions while the `flr_t` closure replaces escaping bound types.\n+    pub fn replace_escaping_bound_vars<T, F, G>(\n+        self,\n+        value: &T,\n+        mut fld_r: F,\n+        mut fld_t: G\n+    ) -> T\n+        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+              G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>,\n+              T: TypeFoldable<'tcx>\n+    {\n+        if !value.has_escaping_bound_vars() {\n+            value.clone()\n+        } else {\n+            let mut replacer = BoundVarReplacer::new(self, &mut fld_r, &mut fld_t);\n+            let result = value.fold_with(&mut replacer);\n+            result\n+        }\n+    }\n+\n+    /// Replace all types or regions bound by the given `Binder`. The `fld_r`\n+    /// closure replaces bound regions while the `flr_t` closure replaces bound\n+    /// types.\n+    pub fn replace_bound_vars<T, F, G>(\n+        self,\n+        value: &Binder<T>,\n+        fld_r: F,\n+        fld_t: G\n+    ) -> T\n+        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+              G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>,\n+              T: TypeFoldable<'tcx>\n+    {\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n     }\n \n     /// Replace any late-bound regions bound in `value` with\n@@ -549,59 +672,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n-    fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>, fld_r: &'a mut F)\n-              -> RegionReplacer<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>\n-    {\n-        RegionReplacer {\n-            tcx,\n-            current_index: ty::INNERMOST,\n-            fld_r,\n-            map: BTreeMap::default()\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n-\n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n-        self.current_index.shift_in(1);\n-        let t = t.super_fold_with(self);\n-        self.current_index.shift_out(1);\n-        t\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_vars_bound_at_or_above(self.current_index) {\n-            return t;\n-        }\n-\n-        t.super_fold_with(self)\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n-                let fld_r = &mut self.fld_r;\n-                let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n-                if let ty::ReLateBound(debruijn1, br) = *region {\n-                    // If the callback returns a late-bound region,\n-                    // that region should always use the INNERMOST\n-                    // debruijn index. Then we adjust it to the\n-                    // correct depth.\n-                    assert_eq!(debruijn1, ty::INNERMOST);\n-                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n-                } else {\n-                    region\n-                }\n-            }\n-            _ => r\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Shifter\n //"}]}