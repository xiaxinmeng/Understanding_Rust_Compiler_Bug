{"sha": "1b83dcf2eed11bfe9a902d769e9474f39a902326", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiODNkY2YyZWVkMTFiZmU5YTkwMmQ3NjllOTQ3NGYzOWE5MDIzMjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-03T18:41:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-03T18:41:46Z"}, "message": "Rollup merge of #66750 - alexcrichton:update-wasi, r=sfackler\n\nUpdate the `wasi` crate for `wasm32-wasi`\n\nThis commit updates the `wasi` crate used by the standard library which\nis used to implement most of the functionality of libstd on the\n`wasm32-wasi` target. This update comes with a brand new crate structure\nin the `wasi` crate which caused quite a few changes for the wasi target\nhere, but it also comes with a significant change to where the\nfunctionality is coming from.\n\nThe WASI specification is organized into \"snapshots\" and a new snapshot\nhappened recently, so the WASI APIs themselves have changed since the\nprevious revision. This had only minor impact on the public facing\nsurface area of libstd, only changing on `u32` to a `u64` in an unstable\nAPI. The actual source for all of these types and such, however, is now\ncoming from the `wasi_preview_snapshot1` module instead of the\n`wasi_unstable` module like before. This means that any implementors\ngenerating binaries will need to ensure that their embedding environment\nhandles the `wasi_preview_snapshot1` module.", "tree": {"sha": "5d4b88b27f9e2ba652b0e4a05eff2a4f10eb5dbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d4b88b27f9e2ba652b0e4a05eff2a4f10eb5dbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b83dcf2eed11bfe9a902d769e9474f39a902326", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd5qxqCRBK7hj4Ov3rIwAAdHIIAC2qC5rAa0ML0n+6e4zCgzMD\nk2Dh93gYhrw5MpGZz6eas4N2Qmh3NoCWeJOhyf5Lgb6Z5Al1FPRqJ7kqb86JeBxW\n8Qpt5vU/uSa7UA0EvZhDbv5wJZU6FhwweWXpEZGcbAG/2bBKZtpV35zO2ucbuY4u\ny3RTlAp5k6ODhqWwzq0J1Nvs08EeQaI+aREFk9vCIHfdGHR2sk9zxlHP/1cQ6jyg\n3L8Km0oRUVJ0XjAa8zmFXmcE+cONXj10gE5imYSIQ04+lcJfZkJ3d5uNSybAoMXU\nOqOeRaePApcuf228C9K2IRmdxrL5KEuF904QULNh8+MJvKZnT5O93vylCZL2M+g=\n=0FK5\n-----END PGP SIGNATURE-----\n", "payload": "tree 5d4b88b27f9e2ba652b0e4a05eff2a4f10eb5dbe\nparent f577b0ef6e637ab7a6095cdfe0b51fa3faf97050\nparent f3fb1c5e95b9fef29df00f0924a27790b03c524b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1575398506 +0100\ncommitter GitHub <noreply@github.com> 1575398506 +0100\n\nRollup merge of #66750 - alexcrichton:update-wasi, r=sfackler\n\nUpdate the `wasi` crate for `wasm32-wasi`\n\nThis commit updates the `wasi` crate used by the standard library which\nis used to implement most of the functionality of libstd on the\n`wasm32-wasi` target. This update comes with a brand new crate structure\nin the `wasi` crate which caused quite a few changes for the wasi target\nhere, but it also comes with a significant change to where the\nfunctionality is coming from.\n\nThe WASI specification is organized into \"snapshots\" and a new snapshot\nhappened recently, so the WASI APIs themselves have changed since the\nprevious revision. This had only minor impact on the public facing\nsurface area of libstd, only changing on `u32` to a `u64` in an unstable\nAPI. The actual source for all of these types and such, however, is now\ncoming from the `wasi_preview_snapshot1` module instead of the\n`wasi_unstable` module like before. This means that any implementors\ngenerating binaries will need to ensure that their embedding environment\nhandles the `wasi_preview_snapshot1` module.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b83dcf2eed11bfe9a902d769e9474f39a902326", "html_url": "https://github.com/rust-lang/rust/commit/1b83dcf2eed11bfe9a902d769e9474f39a902326", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b83dcf2eed11bfe9a902d769e9474f39a902326/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "url": "https://api.github.com/repos/rust-lang/rust/commits/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050", "html_url": "https://github.com/rust-lang/rust/commit/f577b0ef6e637ab7a6095cdfe0b51fa3faf97050"}, {"sha": "f3fb1c5e95b9fef29df00f0924a27790b03c524b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fb1c5e95b9fef29df00f0924a27790b03c524b", "html_url": "https://github.com/rust-lang/rust/commit/f3fb1c5e95b9fef29df00f0924a27790b03c524b"}], "stats": {"total": 668, "additions": 304, "deletions": 364}, "files": [{"sha": "5a56bf03f4da236be1699f0be30453d9a0d649c0", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -1294,7 +1294,7 @@ checksum = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"wasi\",\n+ \"wasi 0.7.0\",\n ]\n \n [[package]]\n@@ -4301,7 +4301,7 @@ dependencies = [\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n- \"wasi\",\n+ \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n \n [[package]]\n@@ -5172,6 +5172,12 @@ name = \"wasi\"\n version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.9.0+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cccddf32554fecc6acb585f82a32a72e28b48f8c4c1883ddfeeeaa96f7d8e519\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\","}, {"sha": "a22e162bbff4804b1332c867483c8748b65d58d0", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -54,7 +54,7 @@ fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n hermit-abi = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n-wasi = { version = \"0.7.0\", features = ['rustc-dep-of-std', 'alloc'] }\n+wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features = false }\n \n [features]\n default = [\"std_detect_file_io\", \"std_detect_dlsym_getauxval\"]"}, {"sha": "3db36f5e1325169b9a09409c9240b1124b51e64c", "filename": "src/libstd/sys/wasi/args.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -1,15 +1,11 @@\n-use crate::ffi::OsString;\n+use crate::ffi::{CStr, OsStr, OsString};\n use crate::marker::PhantomData;\n-use crate::os::wasi::ffi::OsStringExt;\n+use crate::os::wasi::ffi::OsStrExt;\n use crate::vec;\n \n-use ::wasi::wasi_unstable as wasi;\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n \n-pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n-}\n-\n-pub unsafe fn cleanup() {\n-}\n+pub unsafe fn cleanup() {}\n \n pub struct Args {\n     iter: vec::IntoIter<OsString>,\n@@ -18,17 +14,24 @@ pub struct Args {\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n-    let buf = wasi::args_sizes_get().and_then(|args_sizes| {\n-        let mut buf = Vec::with_capacity(args_sizes.get_count());\n-        wasi::args_get(args_sizes, |arg| {\n-            let arg = OsString::from_vec(arg.to_vec());\n-            buf.push(arg);\n-        })?;\n-        Ok(buf)\n-    }).unwrap_or(vec![]);\n     Args {\n-        iter: buf.into_iter(),\n-        _dont_send_or_sync_me: PhantomData\n+        iter: maybe_args().unwrap_or(Vec::new()).into_iter(),\n+        _dont_send_or_sync_me: PhantomData,\n+    }\n+}\n+\n+fn maybe_args() -> Option<Vec<OsString>> {\n+    unsafe {\n+        let (argc, buf_size) = wasi::args_sizes_get().ok()?;\n+        let mut argv = Vec::with_capacity(argc);\n+        let mut buf = Vec::with_capacity(buf_size);\n+        wasi::args_get(argv.as_mut_ptr(), buf.as_mut_ptr()).ok()?;\n+        let mut ret = Vec::with_capacity(argc);\n+        for ptr in argv {\n+            let s = CStr::from_ptr(ptr.cast());\n+            ret.push(OsStr::from_bytes(s.to_bytes()).to_owned());\n+        }\n+        Some(ret)\n     }\n }\n "}, {"sha": "92d0e60c07e83b8f5f1abb227880a9430c159b8f", "filename": "src/libstd/sys/wasi/ext/fs.rs", "status": "modified", "additions": 54, "deletions": 63, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -4,12 +4,10 @@\n \n use crate::fs::{self, File, Metadata, OpenOptions};\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::os::wasi::ffi::OsStrExt;\n use crate::path::{Path, PathBuf};\n+use crate::sys::fs::osstr2str;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n \n-use ::wasi::wasi_unstable as wasi;\n-\n /// WASI-specific extensions to [`File`].\n ///\n /// [`File`]: ../../../../std/fs/struct.File.html\n@@ -49,62 +47,62 @@ pub trait FileExt {\n \n     /// Returns the current position within the file.\n     ///\n-    /// This corresponds to the `__wasi_fd_tell` syscall and is similar to\n+    /// This corresponds to the `fd_tell` syscall and is similar to\n     /// `seek` where you offset 0 bytes from the current position.\n     fn tell(&self) -> io::Result<u64>;\n \n     /// Adjust the flags associated with this file.\n     ///\n-    /// This corresponds to the `__wasi_fd_fdstat_set_flags` syscall.\n+    /// This corresponds to the `fd_fdstat_set_flags` syscall.\n     fn fdstat_set_flags(&self, flags: u16) -> io::Result<()>;\n \n     /// Adjust the rights associated with this file.\n     ///\n-    /// This corresponds to the `__wasi_fd_fdstat_set_rights` syscall.\n+    /// This corresponds to the `fd_fdstat_set_rights` syscall.\n     fn fdstat_set_rights(&self, rights: u64, inheriting: u64) -> io::Result<()>;\n \n     /// Provide file advisory information on a file descriptor.\n     ///\n-    /// This corresponds to the `__wasi_fd_advise` syscall.\n+    /// This corresponds to the `fd_advise` syscall.\n     fn advise(&self, offset: u64, len: u64, advice: u8) -> io::Result<()>;\n \n     /// Force the allocation of space in a file.\n     ///\n-    /// This corresponds to the `__wasi_fd_allocate` syscall.\n+    /// This corresponds to the `fd_allocate` syscall.\n     fn allocate(&self, offset: u64, len: u64) -> io::Result<()>;\n \n     /// Create a directory.\n     ///\n-    /// This corresponds to the `__wasi_path_create_directory` syscall.\n+    /// This corresponds to the `path_create_directory` syscall.\n     fn create_directory<P: AsRef<Path>>(&self, dir: P) -> io::Result<()>;\n \n     /// Read the contents of a symbolic link.\n     ///\n-    /// This corresponds to the `__wasi_path_readlink` syscall.\n+    /// This corresponds to the `path_readlink` syscall.\n     fn read_link<P: AsRef<Path>>(&self, path: P) -> io::Result<PathBuf>;\n \n     /// Return the attributes of a file or directory.\n     ///\n-    /// This corresponds to the `__wasi_path_filestat_get` syscall.\n+    /// This corresponds to the `path_filestat_get` syscall.\n     fn metadata_at<P: AsRef<Path>>(&self, lookup_flags: u32, path: P) -> io::Result<Metadata>;\n \n     /// Unlink a file.\n     ///\n-    /// This corresponds to the `__wasi_path_unlink_file` syscall.\n+    /// This corresponds to the `path_unlink_file` syscall.\n     fn remove_file<P: AsRef<Path>>(&self, path: P) -> io::Result<()>;\n \n     /// Remove a directory.\n     ///\n-    /// This corresponds to the `__wasi_path_remove_directory` syscall.\n+    /// This corresponds to the `path_remove_directory` syscall.\n     fn remove_directory<P: AsRef<Path>>(&self, path: P) -> io::Result<()>;\n }\n \n-// FIXME: bind __wasi_fd_fdstat_get - need to define a custom return type\n-// FIXME: bind __wasi_fd_readdir - can't return `ReadDir` since we only have entry name\n-// FIXME: bind __wasi_fd_filestat_set_times maybe? - on crates.io for unix\n-// FIXME: bind __wasi_path_filestat_set_times maybe? - on crates.io for unix\n-// FIXME: bind __wasi_poll_oneoff maybe? - probably should wait for I/O to settle\n-// FIXME: bind __wasi_random_get maybe? - on crates.io for unix\n+// FIXME: bind fd_fdstat_get - need to define a custom return type\n+// FIXME: bind fd_readdir - can't return `ReadDir` since we only have entry name\n+// FIXME: bind fd_filestat_set_times maybe? - on crates.io for unix\n+// FIXME: bind path_filestat_set_times maybe? - on crates.io for unix\n+// FIXME: bind poll_oneoff maybe? - probably should wait for I/O to settle\n+// FIXME: bind random_get maybe? - on crates.io for unix\n \n impl FileExt for fs::File {\n     fn read_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n@@ -136,9 +134,7 @@ impl FileExt for fs::File {\n     }\n \n     fn create_directory<P: AsRef<Path>>(&self, dir: P) -> io::Result<()> {\n-        self.as_inner()\n-            .fd()\n-            .create_directory(dir.as_ref().as_os_str().as_bytes())\n+        self.as_inner().fd().create_directory(osstr2str(dir.as_ref().as_ref())?)\n     }\n \n     fn read_link<P: AsRef<Path>>(&self, path: P) -> io::Result<PathBuf> {\n@@ -151,26 +147,22 @@ impl FileExt for fs::File {\n     }\n \n     fn remove_file<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n-        self.as_inner()\n-            .fd()\n-            .unlink_file(path.as_ref().as_os_str().as_bytes())\n+        self.as_inner().fd().unlink_file(osstr2str(path.as_ref().as_ref())?)\n     }\n \n     fn remove_directory<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n-        self.as_inner()\n-            .fd()\n-            .remove_directory(path.as_ref().as_os_str().as_bytes())\n+        self.as_inner().fd().remove_directory(osstr2str(path.as_ref().as_ref())?)\n     }\n }\n \n /// WASI-specific extensions to [`fs::OpenOptions`].\n ///\n /// [`fs::OpenOptions`]: ../../../../std/fs/struct.OpenOptions.html\n pub trait OpenOptionsExt {\n-    /// Pass custom `dirflags` argument to `__wasi_path_open`.\n+    /// Pass custom `dirflags` argument to `path_open`.\n     ///\n     /// This option configures the `dirflags` argument to the\n-    /// `__wasi_path_open` syscall which `OpenOptions` will eventually call. The\n+    /// `path_open` syscall which `OpenOptions` will eventually call. The\n     /// `dirflags` argument configures how the file is looked up, currently\n     /// primarily affecting whether symlinks are followed or not.\n     ///\n@@ -188,39 +180,39 @@ pub trait OpenOptionsExt {\n     fn directory(&mut self, dir: bool) -> &mut Self;\n \n     /// Indicates whether `__WASI_FDFLAG_DSYNC` is passed in the `fs_flags`\n-    /// field of `__wasi_path_open`.\n+    /// field of `path_open`.\n     ///\n     /// This option is by default `false`\n     fn dsync(&mut self, dsync: bool) -> &mut Self;\n \n     /// Indicates whether `__WASI_FDFLAG_NONBLOCK` is passed in the `fs_flags`\n-    /// field of `__wasi_path_open`.\n+    /// field of `path_open`.\n     ///\n     /// This option is by default `false`\n     fn nonblock(&mut self, nonblock: bool) -> &mut Self;\n \n     /// Indicates whether `__WASI_FDFLAG_RSYNC` is passed in the `fs_flags`\n-    /// field of `__wasi_path_open`.\n+    /// field of `path_open`.\n     ///\n     /// This option is by default `false`\n     fn rsync(&mut self, rsync: bool) -> &mut Self;\n \n     /// Indicates whether `__WASI_FDFLAG_SYNC` is passed in the `fs_flags`\n-    /// field of `__wasi_path_open`.\n+    /// field of `path_open`.\n     ///\n     /// This option is by default `false`\n     fn sync(&mut self, sync: bool) -> &mut Self;\n \n     /// Indicates the value that should be passed in for the `fs_rights_base`\n-    /// parameter of `__wasi_path_open`.\n+    /// parameter of `path_open`.\n     ///\n     /// This option defaults based on the `read` and `write` configuration of\n     /// this `OpenOptions` builder. If this method is called, however, the\n     /// exact mask passed in will be used instead.\n     fn fs_rights_base(&mut self, rights: u64) -> &mut Self;\n \n     /// Indicates the value that should be passed in for the\n-    /// `fs_rights_inheriting` parameter of `__wasi_path_open`.\n+    /// `fs_rights_inheriting` parameter of `path_open`.\n     ///\n     /// The default for this option is the same value as what will be passed\n     /// for the `fs_rights_base` parameter but if this method is called then\n@@ -229,7 +221,7 @@ pub trait OpenOptionsExt {\n \n     /// Open a file or directory.\n     ///\n-    /// This corresponds to the `__wasi_path_open` syscall.\n+    /// This corresponds to the `path_open` syscall.\n     fn open_at<P: AsRef<Path>>(&self, file: &File, path: P) -> io::Result<File>;\n }\n \n@@ -284,38 +276,38 @@ impl OpenOptionsExt for OpenOptions {\n ///\n /// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n pub trait MetadataExt {\n-    /// Returns the `st_dev` field of the internal `__wasi_filestat_t`\n+    /// Returns the `st_dev` field of the internal `filestat_t`\n     fn dev(&self) -> u64;\n-    /// Returns the `st_ino` field of the internal `__wasi_filestat_t`\n+    /// Returns the `st_ino` field of the internal `filestat_t`\n     fn ino(&self) -> u64;\n-    /// Returns the `st_nlink` field of the internal `__wasi_filestat_t`\n-    fn nlink(&self) -> u32;\n-    /// Returns the `st_atim` field of the internal `__wasi_filestat_t`\n+    /// Returns the `st_nlink` field of the internal `filestat_t`\n+    fn nlink(&self) -> u64;\n+    /// Returns the `st_atim` field of the internal `filestat_t`\n     fn atim(&self) -> u64;\n-    /// Returns the `st_mtim` field of the internal `__wasi_filestat_t`\n+    /// Returns the `st_mtim` field of the internal `filestat_t`\n     fn mtim(&self) -> u64;\n-    /// Returns the `st_ctim` field of the internal `__wasi_filestat_t`\n+    /// Returns the `st_ctim` field of the internal `filestat_t`\n     fn ctim(&self) -> u64;\n }\n \n impl MetadataExt for fs::Metadata {\n     fn dev(&self) -> u64 {\n-        self.as_inner().as_wasi().st_dev\n+        self.as_inner().as_wasi().dev\n     }\n     fn ino(&self) -> u64 {\n-        self.as_inner().as_wasi().st_ino\n+        self.as_inner().as_wasi().ino\n     }\n-    fn nlink(&self) -> u32 {\n-        self.as_inner().as_wasi().st_nlink\n+    fn nlink(&self) -> u64 {\n+        self.as_inner().as_wasi().nlink\n     }\n     fn atim(&self) -> u64 {\n-        self.as_inner().as_wasi().st_atim\n+        self.as_inner().as_wasi().atim\n     }\n     fn mtim(&self) -> u64 {\n-        self.as_inner().as_wasi().st_mtim\n+        self.as_inner().as_wasi().mtim\n     }\n     fn ctim(&self) -> u64 {\n-        self.as_inner().as_wasi().st_ctim\n+        self.as_inner().as_wasi().ctim\n     }\n }\n \n@@ -355,7 +347,7 @@ impl FileTypeExt for fs::FileType {\n ///\n /// [`fs::DirEntry`]: ../../../../std/fs/struct.DirEntry.html\n pub trait DirEntryExt {\n-    /// Returns the underlying `d_ino` field of the `__wasi_dirent_t`\n+    /// Returns the underlying `d_ino` field of the `dirent_t`\n     fn ino(&self) -> u64;\n }\n \n@@ -367,7 +359,7 @@ impl DirEntryExt for fs::DirEntry {\n \n /// Create a hard link.\n ///\n-/// This corresponds to the `__wasi_path_link` syscall.\n+/// This corresponds to the `path_link` syscall.\n pub fn link<P: AsRef<Path>, U: AsRef<Path>>(\n     old_fd: &File,\n     old_flags: u32,\n@@ -377,38 +369,37 @@ pub fn link<P: AsRef<Path>, U: AsRef<Path>>(\n ) -> io::Result<()> {\n     old_fd.as_inner().fd().link(\n         old_flags,\n-        old_path.as_ref().as_os_str().as_bytes(),\n+        osstr2str(old_path.as_ref().as_ref())?,\n         new_fd.as_inner().fd(),\n-        new_path.as_ref().as_os_str().as_bytes(),\n+        osstr2str(new_path.as_ref().as_ref())?,\n     )\n }\n \n /// Rename a file or directory.\n ///\n-/// This corresponds to the `__wasi_path_rename` syscall.\n+/// This corresponds to the `path_rename` syscall.\n pub fn rename<P: AsRef<Path>, U: AsRef<Path>>(\n     old_fd: &File,\n     old_path: P,\n     new_fd: &File,\n     new_path: U,\n ) -> io::Result<()> {\n     old_fd.as_inner().fd().rename(\n-        old_path.as_ref().as_os_str().as_bytes(),\n+        osstr2str(old_path.as_ref().as_ref())?,\n         new_fd.as_inner().fd(),\n-        new_path.as_ref().as_os_str().as_bytes(),\n+        osstr2str(new_path.as_ref().as_ref())?,\n     )\n }\n \n /// Create a symbolic link.\n ///\n-/// This corresponds to the `__wasi_path_symlink` syscall.\n+/// This corresponds to the `path_symlink` syscall.\n pub fn symlink<P: AsRef<Path>, U: AsRef<Path>>(\n     old_path: P,\n     fd: &File,\n     new_path: U,\n ) -> io::Result<()> {\n-    fd.as_inner().fd().symlink(\n-        old_path.as_ref().as_os_str().as_bytes(),\n-        new_path.as_ref().as_os_str().as_bytes(),\n-    )\n+    fd.as_inner()\n+        .fd()\n+        .symlink(osstr2str(old_path.as_ref().as_ref())?, osstr2str(new_path.as_ref().as_ref())?)\n }"}, {"sha": "f678b71a2b9f08202ce2acc758e3c0ea73eac226", "filename": "src/libstd/sys/wasi/ext/io.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -8,8 +8,6 @@ use crate::sys;\n use crate::net;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n-use ::wasi::wasi_unstable as wasi;\n-\n /// Raw file descriptors.\n pub type RawFd = u32;\n \n@@ -127,18 +125,18 @@ impl IntoRawFd for fs::File {\n \n impl AsRawFd for io::Stdin {\n     fn as_raw_fd(&self) -> RawFd {\n-        wasi::STDIN_FD\n+        sys::stdio::Stdin.as_raw_fd()\n     }\n }\n \n impl AsRawFd for io::Stdout {\n     fn as_raw_fd(&self) -> RawFd {\n-        wasi::STDOUT_FD\n+        sys::stdio::Stdout.as_raw_fd()\n     }\n }\n \n impl AsRawFd for io::Stderr {\n     fn as_raw_fd(&self) -> RawFd {\n-        wasi::STDERR_FD\n+        sys::stdio::Stderr.as_raw_fd()\n     }\n }"}, {"sha": "00327c1743c3db391497c47e61895ac44032b45e", "filename": "src/libstd/sys/wasi/fd.rs", "status": "modified", "additions": 52, "deletions": 70, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -1,40 +1,31 @@\n #![allow(dead_code)]\n \n+use super::err2io;\n use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::net::Shutdown;\n-use super::err2io;\n-use ::wasi::wasi_unstable as wasi;\n \n #[derive(Debug)]\n pub struct WasiFd {\n     fd: wasi::Fd,\n }\n \n-fn iovec<'a>(a: &'a mut [IoSliceMut<'_>]) -> &'a [wasi::IoVec] {\n-    assert_eq!(\n-        mem::size_of::<IoSliceMut<'_>>(),\n-        mem::size_of::<wasi::IoVec>()\n-    );\n-    assert_eq!(\n-        mem::align_of::<IoSliceMut<'_>>(),\n-        mem::align_of::<wasi::IoVec>()\n-    );\n+fn iovec<'a>(a: &'a mut [IoSliceMut<'_>]) -> &'a [wasi::Iovec] {\n+    assert_eq!(mem::size_of::<IoSliceMut<'_>>(), mem::size_of::<wasi::Iovec>());\n+    assert_eq!(mem::align_of::<IoSliceMut<'_>>(), mem::align_of::<wasi::Iovec>());\n     /// SAFETY: `IoSliceMut` and `IoVec` have exactly the same memory layout\n-    unsafe { mem::transmute(a) }\n+    unsafe {\n+        mem::transmute(a)\n+    }\n }\n \n-fn ciovec<'a>(a: &'a [IoSlice<'_>]) -> &'a [wasi::CIoVec] {\n-    assert_eq!(\n-        mem::size_of::<IoSlice<'_>>(),\n-        mem::size_of::<wasi::CIoVec>()\n-    );\n-    assert_eq!(\n-        mem::align_of::<IoSlice<'_>>(),\n-        mem::align_of::<wasi::CIoVec>()\n-    );\n+fn ciovec<'a>(a: &'a [IoSlice<'_>]) -> &'a [wasi::Ciovec] {\n+    assert_eq!(mem::size_of::<IoSlice<'_>>(), mem::size_of::<wasi::Ciovec>());\n+    assert_eq!(mem::align_of::<IoSlice<'_>>(), mem::align_of::<wasi::Ciovec>());\n     /// SAFETY: `IoSlice` and `CIoVec` have exactly the same memory layout\n-    unsafe { mem::transmute(a) }\n+    unsafe {\n+        mem::transmute(a)\n+    }\n }\n \n impl WasiFd {\n@@ -87,7 +78,7 @@ impl WasiFd {\n \n     // FIXME: __wasi_fd_fdstat_get\n \n-    pub fn set_flags(&self, flags: wasi::FdFlags) -> io::Result<()> {\n+    pub fn set_flags(&self, flags: wasi::Fdflags) -> io::Result<()> {\n         unsafe { wasi::fd_fdstat_set_flags(self.fd, flags).map_err(err2io) }\n     }\n \n@@ -107,31 +98,30 @@ impl WasiFd {\n         unsafe { wasi::fd_allocate(self.fd, offset, len).map_err(err2io) }\n     }\n \n-    pub fn create_directory(&self, path: &[u8]) -> io::Result<()> {\n+    pub fn create_directory(&self, path: &str) -> io::Result<()> {\n         unsafe { wasi::path_create_directory(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn link(\n         &self,\n-        old_flags: wasi::LookupFlags,\n-        old_path: &[u8],\n+        old_flags: wasi::Lookupflags,\n+        old_path: &str,\n         new_fd: &WasiFd,\n-        new_path: &[u8],\n+        new_path: &str,\n     ) -> io::Result<()> {\n         unsafe {\n-            wasi::path_link(self.fd, old_flags, old_path, new_fd.fd, new_path)\n-                .map_err(err2io)\n+            wasi::path_link(self.fd, old_flags, old_path, new_fd.fd, new_path).map_err(err2io)\n         }\n     }\n \n     pub fn open(\n         &self,\n-        dirflags: wasi::LookupFlags,\n-        path: &[u8],\n-        oflags: wasi::OFlags,\n+        dirflags: wasi::Lookupflags,\n+        path: &str,\n+        oflags: wasi::Oflags,\n         fs_rights_base: wasi::Rights,\n         fs_rights_inheriting: wasi::Rights,\n-        fs_flags: wasi::FdFlags,\n+        fs_flags: wasi::Fdflags,\n     ) -> io::Result<WasiFd> {\n         unsafe {\n             wasi::path_open(\n@@ -142,37 +132,35 @@ impl WasiFd {\n                 fs_rights_base,\n                 fs_rights_inheriting,\n                 fs_flags,\n-            ).map(|fd| WasiFd::from_raw(fd)).map_err(err2io)\n+            )\n+            .map(|fd| WasiFd::from_raw(fd))\n+            .map_err(err2io)\n         }\n     }\n \n-    pub fn readdir(&self, buf: &mut [u8], cookie: wasi::DirCookie) -> io::Result<usize> {\n-        unsafe { wasi::fd_readdir(self.fd, buf, cookie).map_err(err2io) }\n+    pub fn readdir(&self, buf: &mut [u8], cookie: wasi::Dircookie) -> io::Result<usize> {\n+        unsafe { wasi::fd_readdir(self.fd, buf.as_mut_ptr(), buf.len(), cookie).map_err(err2io) }\n     }\n \n-    pub fn readlink(&self, path: &[u8], buf: &mut [u8]) -> io::Result<usize> {\n-        unsafe { wasi::path_readlink(self.fd, path, buf).map_err(err2io) }\n+    pub fn readlink(&self, path: &str, buf: &mut [u8]) -> io::Result<usize> {\n+        unsafe { wasi::path_readlink(self.fd, path, buf.as_mut_ptr(), buf.len()).map_err(err2io) }\n     }\n \n-    pub fn rename(&self, old_path: &[u8], new_fd: &WasiFd, new_path: &[u8]) -> io::Result<()> {\n-        unsafe {\n-            wasi::path_rename(self.fd, old_path, new_fd.fd, new_path).map_err(err2io)\n-        }\n+    pub fn rename(&self, old_path: &str, new_fd: &WasiFd, new_path: &str) -> io::Result<()> {\n+        unsafe { wasi::path_rename(self.fd, old_path, new_fd.fd, new_path).map_err(err2io) }\n     }\n \n-    pub fn filestat_get(&self) -> io::Result<wasi::FileStat> {\n+    pub fn filestat_get(&self) -> io::Result<wasi::Filestat> {\n         unsafe { wasi::fd_filestat_get(self.fd).map_err(err2io) }\n     }\n \n     pub fn filestat_set_times(\n         &self,\n         atim: wasi::Timestamp,\n         mtim: wasi::Timestamp,\n-        fstflags: wasi::FstFlags,\n+        fstflags: wasi::Fstflags,\n     ) -> io::Result<()> {\n-        unsafe {\n-            wasi::fd_filestat_set_times(self.fd, atim, mtim, fstflags).map_err(err2io)\n-        }\n+        unsafe { wasi::fd_filestat_set_times(self.fd, atim, mtim, fstflags).map_err(err2io) }\n     }\n \n     pub fn filestat_set_size(&self, size: u64) -> io::Result<()> {\n@@ -181,61 +169,55 @@ impl WasiFd {\n \n     pub fn path_filestat_get(\n         &self,\n-        flags: wasi::LookupFlags,\n-        path: &[u8],\n-    ) -> io::Result<wasi::FileStat> {\n+        flags: wasi::Lookupflags,\n+        path: &str,\n+    ) -> io::Result<wasi::Filestat> {\n         unsafe { wasi::path_filestat_get(self.fd, flags, path).map_err(err2io) }\n     }\n \n     pub fn path_filestat_set_times(\n         &self,\n-        flags: wasi::LookupFlags,\n-        path: &[u8],\n+        flags: wasi::Lookupflags,\n+        path: &str,\n         atim: wasi::Timestamp,\n         mtim: wasi::Timestamp,\n-        fstflags: wasi::FstFlags,\n+        fstflags: wasi::Fstflags,\n     ) -> io::Result<()> {\n         unsafe {\n-            wasi::path_filestat_set_times(\n-                self.fd,\n-                flags,\n-                path,\n-                atim,\n-                mtim,\n-                fstflags,\n-            ).map_err(err2io)\n+            wasi::path_filestat_set_times(self.fd, flags, path, atim, mtim, fstflags)\n+                .map_err(err2io)\n         }\n     }\n \n-    pub fn symlink(&self, old_path: &[u8], new_path: &[u8]) -> io::Result<()> {\n+    pub fn symlink(&self, old_path: &str, new_path: &str) -> io::Result<()> {\n         unsafe { wasi::path_symlink(old_path, self.fd, new_path).map_err(err2io) }\n     }\n \n-    pub fn unlink_file(&self, path: &[u8]) -> io::Result<()> {\n+    pub fn unlink_file(&self, path: &str) -> io::Result<()> {\n         unsafe { wasi::path_unlink_file(self.fd, path).map_err(err2io) }\n     }\n \n-    pub fn remove_directory(&self, path: &[u8]) -> io::Result<()> {\n+    pub fn remove_directory(&self, path: &str) -> io::Result<()> {\n         unsafe { wasi::path_remove_directory(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn sock_recv(\n         &self,\n         ri_data: &mut [IoSliceMut<'_>],\n-        ri_flags: wasi::RiFlags,\n-    ) -> io::Result<(usize, wasi::RoFlags)> {\n+        ri_flags: wasi::Riflags,\n+    ) -> io::Result<(usize, wasi::Roflags)> {\n         unsafe { wasi::sock_recv(self.fd, iovec(ri_data), ri_flags).map_err(err2io) }\n     }\n \n-    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: wasi::SiFlags) -> io::Result<usize> {\n+    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: wasi::Siflags) -> io::Result<usize> {\n         unsafe { wasi::sock_send(self.fd, ciovec(si_data), si_flags).map_err(err2io) }\n     }\n \n     pub fn sock_shutdown(&self, how: Shutdown) -> io::Result<()> {\n         let how = match how {\n-            Shutdown::Read => wasi::SHUT_RD,\n-            Shutdown::Write => wasi::SHUT_WR,\n-            Shutdown::Both => wasi::SHUT_WR | wasi::SHUT_RD,\n+            Shutdown::Read => wasi::SDFLAGS_RD,\n+            Shutdown::Write => wasi::SDFLAGS_WR,\n+            Shutdown::Both => wasi::SDFLAGS_WR | wasi::SDFLAGS_RD,\n         };\n         unsafe { wasi::sock_shutdown(self.fd, how).map_err(err2io) }\n     }"}, {"sha": "fad092e35c3e6d751f71f300a0b6adbc5b3f90dd", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 90, "deletions": 121, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -15,20 +15,18 @@ use crate::sys_common::FromInner;\n pub use crate::sys_common::fs::copy;\n pub use crate::sys_common::fs::remove_dir_all;\n \n-use ::wasi::wasi_unstable as wasi;\n-\n pub struct File {\n     fd: WasiFd,\n }\n \n #[derive(Clone)]\n pub struct FileAttr {\n-    meta: wasi::FileStat,\n+    meta: wasi::Filestat,\n }\n \n pub struct ReadDir {\n     inner: Arc<ReadDirInner>,\n-    cookie: Option<wasi::DirCookie>,\n+    cookie: Option<wasi::Dircookie>,\n     buf: Vec<u8>,\n     offset: usize,\n     cap: usize,\n@@ -49,9 +47,9 @@ pub struct DirEntry {\n pub struct OpenOptions {\n     read: bool,\n     write: bool,\n-    dirflags: wasi::LookupFlags,\n-    fdflags: wasi::FdFlags,\n-    oflags: wasi::OFlags,\n+    dirflags: wasi::Lookupflags,\n+    fdflags: wasi::Fdflags,\n+    oflags: wasi::Oflags,\n     rights_base: Option<wasi::Rights>,\n     rights_inheriting: Option<wasi::Rights>,\n }\n@@ -63,15 +61,15 @@ pub struct FilePermissions {\n \n #[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]\n pub struct FileType {\n-    bits: wasi::FileType,\n+    bits: wasi::Filetype,\n }\n \n #[derive(Debug)]\n pub struct DirBuilder {}\n \n impl FileAttr {\n     pub fn size(&self) -> u64 {\n-        self.meta.st_size\n+        self.meta.size\n     }\n \n     pub fn perm(&self) -> FilePermissions {\n@@ -80,24 +78,22 @@ impl FileAttr {\n     }\n \n     pub fn file_type(&self) -> FileType {\n-        FileType {\n-            bits: self.meta.st_filetype,\n-        }\n+        FileType { bits: self.meta.filetype }\n     }\n \n     pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from_wasi_timestamp(self.meta.st_mtim))\n+        Ok(SystemTime::from_wasi_timestamp(self.meta.mtim))\n     }\n \n     pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from_wasi_timestamp(self.meta.st_atim))\n+        Ok(SystemTime::from_wasi_timestamp(self.meta.atim))\n     }\n \n     pub fn created(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from_wasi_timestamp(self.meta.st_ctim))\n+        Ok(SystemTime::from_wasi_timestamp(self.meta.ctim))\n     }\n \n-    pub fn as_wasi(&self) -> &wasi::FileStat {\n+    pub fn as_wasi(&self) -> &wasi::Filestat {\n         &self.meta\n     }\n }\n@@ -125,7 +121,7 @@ impl FileType {\n         self.bits == wasi::FILETYPE_SYMBOLIC_LINK\n     }\n \n-    pub fn bits(&self) -> wasi::FileType {\n+    pub fn bits(&self) -> wasi::Filetype {\n         self.bits\n     }\n }\n@@ -177,8 +173,7 @@ impl Iterator for ReadDir {\n                 continue;\n             }\n             let (dirent, data) = data.split_at(dirent_size);\n-            let dirent =\n-                unsafe { ptr::read_unaligned(dirent.as_ptr() as *const wasi::Dirent) };\n+            let dirent = unsafe { ptr::read_unaligned(dirent.as_ptr() as *const wasi::Dirent) };\n \n             // If the file name was truncated, then we need to reinvoke\n             // `readdir` so we truncate our buffer to start over and reread this\n@@ -224,17 +219,11 @@ impl DirEntry {\n     }\n \n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        metadata_at(\n-            &self.inner.dir.fd,\n-            0,\n-            OsStr::from_bytes(&self.name).as_ref(),\n-        )\n+        metadata_at(&self.inner.dir.fd, 0, OsStr::from_bytes(&self.name).as_ref())\n     }\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n-        Ok(FileType {\n-            bits: self.meta.d_type,\n-        })\n+        Ok(FileType { bits: self.meta.d_type })\n     }\n \n     pub fn ino(&self) -> wasi::Inode {\n@@ -245,7 +234,7 @@ impl DirEntry {\n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n         let mut base = OpenOptions::default();\n-        base.dirflags = wasi::LOOKUP_SYMLINK_FOLLOW;\n+        base.dirflags = wasi::LOOKUPFLAGS_SYMLINK_FOLLOW;\n         return base;\n     }\n \n@@ -258,23 +247,23 @@ impl OpenOptions {\n     }\n \n     pub fn truncate(&mut self, truncate: bool) {\n-        self.oflag(wasi::O_TRUNC, truncate);\n+        self.oflag(wasi::OFLAGS_TRUNC, truncate);\n     }\n \n     pub fn create(&mut self, create: bool) {\n-        self.oflag(wasi::O_CREAT, create);\n+        self.oflag(wasi::OFLAGS_CREAT, create);\n     }\n \n     pub fn create_new(&mut self, create_new: bool) {\n-        self.oflag(wasi::O_EXCL, create_new);\n-        self.oflag(wasi::O_CREAT, create_new);\n+        self.oflag(wasi::OFLAGS_EXCL, create_new);\n+        self.oflag(wasi::OFLAGS_CREAT, create_new);\n     }\n \n     pub fn directory(&mut self, directory: bool) {\n-        self.oflag(wasi::O_DIRECTORY, directory);\n+        self.oflag(wasi::OFLAGS_DIRECTORY, directory);\n     }\n \n-    fn oflag(&mut self, bit: wasi::OFlags, set: bool) {\n+    fn oflag(&mut self, bit: wasi::Oflags, set: bool) {\n         if set {\n             self.oflags |= bit;\n         } else {\n@@ -283,26 +272,26 @@ impl OpenOptions {\n     }\n \n     pub fn append(&mut self, set: bool) {\n-        self.fdflag(wasi::FDFLAG_APPEND, set);\n+        self.fdflag(wasi::FDFLAGS_APPEND, set);\n     }\n \n     pub fn dsync(&mut self, set: bool) {\n-        self.fdflag(wasi::FDFLAG_DSYNC, set);\n+        self.fdflag(wasi::FDFLAGS_DSYNC, set);\n     }\n \n     pub fn nonblock(&mut self, set: bool) {\n-        self.fdflag(wasi::FDFLAG_NONBLOCK, set);\n+        self.fdflag(wasi::FDFLAGS_NONBLOCK, set);\n     }\n \n     pub fn rsync(&mut self, set: bool) {\n-        self.fdflag(wasi::FDFLAG_RSYNC, set);\n+        self.fdflag(wasi::FDFLAGS_RSYNC, set);\n     }\n \n     pub fn sync(&mut self, set: bool) {\n-        self.fdflag(wasi::FDFLAG_SYNC, set);\n+        self.fdflag(wasi::FDFLAGS_SYNC, set);\n     }\n \n-    fn fdflag(&mut self, bit: wasi::FdFlags, set: bool) {\n+    fn fdflag(&mut self, bit: wasi::Fdflags, set: bool) {\n         if set {\n             self.fdflags |= bit;\n         } else {\n@@ -330,36 +319,36 @@ impl OpenOptions {\n         // based on that.\n         let mut base = 0;\n         if self.read {\n-            base |= wasi::RIGHT_FD_READ;\n-            base |= wasi::RIGHT_FD_READDIR;\n+            base |= wasi::RIGHTS_FD_READ;\n+            base |= wasi::RIGHTS_FD_READDIR;\n         }\n         if self.write {\n-            base |= wasi::RIGHT_FD_WRITE;\n-            base |= wasi::RIGHT_FD_DATASYNC;\n-            base |= wasi::RIGHT_FD_ALLOCATE;\n-            base |= wasi::RIGHT_FD_FILESTAT_SET_SIZE;\n+            base |= wasi::RIGHTS_FD_WRITE;\n+            base |= wasi::RIGHTS_FD_DATASYNC;\n+            base |= wasi::RIGHTS_FD_ALLOCATE;\n+            base |= wasi::RIGHTS_FD_FILESTAT_SET_SIZE;\n         }\n \n         // FIXME: some of these should probably be read-only or write-only...\n-        base |= wasi::RIGHT_FD_ADVISE;\n-        base |= wasi::RIGHT_FD_FDSTAT_SET_FLAGS;\n-        base |= wasi::RIGHT_FD_FILESTAT_SET_TIMES;\n-        base |= wasi::RIGHT_FD_SEEK;\n-        base |= wasi::RIGHT_FD_SYNC;\n-        base |= wasi::RIGHT_FD_TELL;\n-        base |= wasi::RIGHT_PATH_CREATE_DIRECTORY;\n-        base |= wasi::RIGHT_PATH_CREATE_FILE;\n-        base |= wasi::RIGHT_PATH_FILESTAT_GET;\n-        base |= wasi::RIGHT_PATH_LINK_SOURCE;\n-        base |= wasi::RIGHT_PATH_LINK_TARGET;\n-        base |= wasi::RIGHT_PATH_OPEN;\n-        base |= wasi::RIGHT_PATH_READLINK;\n-        base |= wasi::RIGHT_PATH_REMOVE_DIRECTORY;\n-        base |= wasi::RIGHT_PATH_RENAME_SOURCE;\n-        base |= wasi::RIGHT_PATH_RENAME_TARGET;\n-        base |= wasi::RIGHT_PATH_SYMLINK;\n-        base |= wasi::RIGHT_PATH_UNLINK_FILE;\n-        base |= wasi::RIGHT_POLL_FD_READWRITE;\n+        base |= wasi::RIGHTS_FD_ADVISE;\n+        base |= wasi::RIGHTS_FD_FDSTAT_SET_FLAGS;\n+        base |= wasi::RIGHTS_FD_FILESTAT_SET_TIMES;\n+        base |= wasi::RIGHTS_FD_SEEK;\n+        base |= wasi::RIGHTS_FD_SYNC;\n+        base |= wasi::RIGHTS_FD_TELL;\n+        base |= wasi::RIGHTS_PATH_CREATE_DIRECTORY;\n+        base |= wasi::RIGHTS_PATH_CREATE_FILE;\n+        base |= wasi::RIGHTS_PATH_FILESTAT_GET;\n+        base |= wasi::RIGHTS_PATH_LINK_SOURCE;\n+        base |= wasi::RIGHTS_PATH_LINK_TARGET;\n+        base |= wasi::RIGHTS_PATH_OPEN;\n+        base |= wasi::RIGHTS_PATH_READLINK;\n+        base |= wasi::RIGHTS_PATH_REMOVE_DIRECTORY;\n+        base |= wasi::RIGHTS_PATH_RENAME_SOURCE;\n+        base |= wasi::RIGHTS_PATH_RENAME_TARGET;\n+        base |= wasi::RIGHTS_PATH_SYMLINK;\n+        base |= wasi::RIGHTS_PATH_UNLINK_FILE;\n+        base |= wasi::RIGHTS_POLL_FD_READWRITE;\n \n         return base;\n     }\n@@ -368,14 +357,14 @@ impl OpenOptions {\n         self.rights_inheriting.unwrap_or_else(|| self.rights_base())\n     }\n \n-    pub fn lookup_flags(&mut self, flags: wasi::LookupFlags) {\n+    pub fn lookup_flags(&mut self, flags: wasi::Lookupflags) {\n         self.dirflags = flags;\n     }\n }\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let (dir, file) = open_parent(path, wasi::RIGHT_PATH_OPEN)?;\n+        let (dir, file) = open_parent(path, wasi::RIGHTS_PATH_OPEN)?;\n         open_at(&dir, &file, opts)\n     }\n \n@@ -387,11 +376,7 @@ impl File {\n         self.fd.filestat_get().map(|meta| FileAttr { meta })\n     }\n \n-    pub fn metadata_at(\n-        &self,\n-        flags: wasi::LookupFlags,\n-        path: &Path,\n-    ) -> io::Result<FileAttr> {\n+    pub fn metadata_at(&self, flags: wasi::Lookupflags, path: &Path) -> io::Result<FileAttr> {\n         metadata_at(&self.fd, flags, path)\n     }\n \n@@ -457,11 +442,7 @@ impl File {\n \n impl FromInner<u32> for File {\n     fn from_inner(fd: u32) -> File {\n-        unsafe {\n-            File {\n-                fd: WasiFd::from_raw(fd),\n-            }\n-        }\n+        unsafe { File { fd: WasiFd::from_raw(fd) } }\n     }\n }\n \n@@ -471,16 +452,14 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let (dir, file) = open_parent(p, wasi::RIGHT_PATH_CREATE_DIRECTORY)?;\n-        dir.create_directory(file.as_os_str().as_bytes())\n+        let (dir, file) = open_parent(p, wasi::RIGHTS_PATH_CREATE_DIRECTORY)?;\n+        dir.create_directory(osstr2str(file.as_ref())?)\n     }\n }\n \n impl fmt::Debug for File {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"File\")\n-            .field(\"fd\", &self.fd.as_raw())\n-            .finish()\n+        f.debug_struct(\"File\").field(\"fd\", &self.fd.as_raw()).finish()\n     }\n }\n \n@@ -494,26 +473,19 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n         buf: vec![0; 128],\n         offset: 0,\n         cap: 0,\n-        inner: Arc::new(ReadDirInner {\n-            dir,\n-            root: p.to_path_buf(),\n-        }),\n+        inner: Arc::new(ReadDirInner { dir, root: p.to_path_buf() }),\n     })\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_UNLINK_FILE)?;\n-    dir.unlink_file(file.as_os_str().as_bytes())\n+    let (dir, file) = open_parent(p, wasi::RIGHTS_PATH_UNLINK_FILE)?;\n+    dir.unlink_file(osstr2str(file.as_ref())?)\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let (old, old_file) = open_parent(old, wasi::RIGHT_PATH_RENAME_SOURCE)?;\n-    let (new, new_file) = open_parent(new, wasi::RIGHT_PATH_RENAME_TARGET)?;\n-    old.rename(\n-        old_file.as_os_str().as_bytes(),\n-        &new,\n-        new_file.as_os_str().as_bytes(),\n-    )\n+    let (old, old_file) = open_parent(old, wasi::RIGHTS_PATH_RENAME_SOURCE)?;\n+    let (new, new_file) = open_parent(new, wasi::RIGHTS_PATH_RENAME_TARGET)?;\n+    old.rename(osstr2str(old_file.as_ref())?, &new, osstr2str(new_file.as_ref())?)\n }\n \n pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n@@ -523,12 +495,12 @@ pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_REMOVE_DIRECTORY)?;\n-    dir.remove_directory(file.as_os_str().as_bytes())\n+    let (dir, file) = open_parent(p, wasi::RIGHTS_PATH_REMOVE_DIRECTORY)?;\n+    dir.remove_directory(osstr2str(file.as_ref())?)\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_READLINK)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHTS_PATH_READLINK)?;\n     read_link(&dir, &file)\n }\n \n@@ -549,7 +521,7 @@ fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n     // Now that we have an initial guess of how big to make our buffer, call\n     // `readlink` in a loop until it fails or reports it filled fewer bytes than\n     // we asked for, indicating we got everything.\n-    let file = file.as_os_str().as_bytes();\n+    let file = osstr2str(file.as_ref())?;\n     let mut destination = vec![0u8; initial_size];\n     loop {\n         let len = fd.readlink(file, &mut destination)?;\n@@ -564,38 +536,34 @@ fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (dst, dst_file) = open_parent(dst, wasi::RIGHT_PATH_SYMLINK)?;\n-    dst.symlink(src.as_os_str().as_bytes(), dst_file.as_os_str().as_bytes())\n+    let (dst, dst_file) = open_parent(dst, wasi::RIGHTS_PATH_SYMLINK)?;\n+    dst.symlink(osstr2str(src.as_ref())?, osstr2str(dst_file.as_ref())?)\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (src, src_file) = open_parent(src, wasi::RIGHT_PATH_LINK_SOURCE)?;\n-    let (dst, dst_file) = open_parent(dst, wasi::RIGHT_PATH_LINK_TARGET)?;\n+    let (src, src_file) = open_parent(src, wasi::RIGHTS_PATH_LINK_SOURCE)?;\n+    let (dst, dst_file) = open_parent(dst, wasi::RIGHTS_PATH_LINK_TARGET)?;\n     src.link(\n-        wasi::LOOKUP_SYMLINK_FOLLOW,\n-        src_file.as_os_str().as_bytes(),\n+        wasi::LOOKUPFLAGS_SYMLINK_FOLLOW,\n+        osstr2str(src_file.as_ref())?,\n         &dst,\n-        dst_file.as_os_str().as_bytes(),\n+        osstr2str(dst_file.as_ref())?,\n     )\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_FILESTAT_GET)?;\n-    metadata_at(&dir, wasi::LOOKUP_SYMLINK_FOLLOW, &file)\n+    let (dir, file) = open_parent(p, wasi::RIGHTS_PATH_FILESTAT_GET)?;\n+    metadata_at(&dir, wasi::LOOKUPFLAGS_SYMLINK_FOLLOW, &file)\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_FILESTAT_GET)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHTS_PATH_FILESTAT_GET)?;\n     metadata_at(&dir, 0, &file)\n }\n \n-fn metadata_at(\n-    fd: &WasiFd,\n-    flags: wasi::LookupFlags,\n-    path: &Path,\n-) -> io::Result<FileAttr> {\n-    fd.path_filestat_get(flags, path.as_os_str().as_bytes())\n-        .map(|meta| FileAttr { meta })\n+fn metadata_at(fd: &WasiFd, flags: wasi::Lookupflags, path: &Path) -> io::Result<FileAttr> {\n+    let meta = fd.path_filestat_get(flags, osstr2str(path.as_ref())?)?;\n+    Ok(FileAttr { meta })\n }\n \n pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n@@ -607,7 +575,7 @@ pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n     let fd = fd.open(\n         opts.dirflags,\n-        path.as_os_str().as_bytes(),\n+        osstr2str(path.as_ref())?,\n         opts.oflags,\n         opts.rights_base(),\n         opts.rights_inheriting(),\n@@ -643,10 +611,7 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n ///\n /// Note that this can fail if `p` doesn't look like it can be opened relative\n /// to any preopened file descriptor.\n-fn open_parent(\n-    p: &Path,\n-    rights: wasi::Rights,\n-) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n+fn open_parent(p: &Path, rights: wasi::Rights) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n     let p = CString::new(p.as_os_str().as_bytes())?;\n     unsafe {\n         let mut ret = ptr::null();\n@@ -671,3 +636,7 @@ fn open_parent(\n         return Ok((ManuallyDrop::new(WasiFd::from_raw(fd as u32)), path));\n     }\n }\n+\n+pub fn osstr2str(f: &OsStr) -> io::Result<&str> {\n+    f.to_str().ok_or_else(|| io::Error::new(io::ErrorKind::Other, \"input must be utf-8\"))\n+}"}, {"sha": "41a6e9783c0470285cc1ecbfde709e1055a18133", "filename": "src/libstd/sys/wasi/io.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -1,21 +1,18 @@\n use crate::marker::PhantomData;\n use crate::slice;\n \n-use ::wasi::wasi_unstable as wasi;\n-use core::ffi::c_void;\n-\n #[repr(transparent)]\n pub struct IoSlice<'a> {\n-    vec: wasi::CIoVec,\n+    vec: wasi::Ciovec,\n     _p: PhantomData<&'a [u8]>,\n }\n \n impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice {\n-            vec: wasi::CIoVec {\n-                buf: buf.as_ptr() as *const c_void,\n+            vec: wasi::Ciovec {\n+                buf: buf.as_ptr(),\n                 buf_len: buf.len(),\n             },\n             _p: PhantomData,\n@@ -44,16 +41,16 @@ impl<'a> IoSlice<'a> {\n \n #[repr(transparent)]\n pub struct IoSliceMut<'a> {\n-    vec: wasi::IoVec,\n+    vec: wasi::Iovec,\n     _p: PhantomData<&'a mut [u8]>,\n }\n \n impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut {\n-            vec: wasi::IoVec {\n-                buf: buf.as_mut_ptr() as *mut c_void,\n+            vec: wasi::Iovec {\n+                buf: buf.as_mut_ptr(),\n                 buf_len: buf.len()\n             },\n             _p: PhantomData,"}, {"sha": "83f98a19f4706f28fff6e334fc791840e57158e2", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -17,7 +17,6 @@\n use crate::io as std_io;\n use crate::mem;\n use crate::os::raw::c_char;\n-use ::wasi::wasi_unstable as wasi;\n \n pub mod alloc;\n pub mod args;\n@@ -72,25 +71,21 @@ pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n     if errno > u16::max_value() as i32 || errno < 0 {\n         return Other;\n     }\n-    let code = match wasi::Error::new(errno as u16) {\n-        Some(code) => code,\n-        None => return Other,\n-    };\n-    match code {\n-        wasi::ECONNREFUSED => ConnectionRefused,\n-        wasi::ECONNRESET => ConnectionReset,\n-        wasi::EPERM | wasi::EACCES => PermissionDenied,\n-        wasi::EPIPE => BrokenPipe,\n-        wasi::ENOTCONN => NotConnected,\n-        wasi::ECONNABORTED => ConnectionAborted,\n-        wasi::EADDRNOTAVAIL => AddrNotAvailable,\n-        wasi::EADDRINUSE => AddrInUse,\n-        wasi::ENOENT => NotFound,\n-        wasi::EINTR => Interrupted,\n-        wasi::EINVAL => InvalidInput,\n-        wasi::ETIMEDOUT => TimedOut,\n-        wasi::EEXIST => AlreadyExists,\n-        wasi::EAGAIN => WouldBlock,\n+    match errno as u16 {\n+        wasi::ERRNO_CONNREFUSED => ConnectionRefused,\n+        wasi::ERRNO_CONNRESET => ConnectionReset,\n+        wasi::ERRNO_PERM | wasi::ERRNO_ACCES => PermissionDenied,\n+        wasi::ERRNO_PIPE => BrokenPipe,\n+        wasi::ERRNO_NOTCONN => NotConnected,\n+        wasi::ERRNO_CONNABORTED => ConnectionAborted,\n+        wasi::ERRNO_ADDRNOTAVAIL => AddrNotAvailable,\n+        wasi::ERRNO_ADDRINUSE => AddrInUse,\n+        wasi::ERRNO_NOENT => NotFound,\n+        wasi::ERRNO_INTR => Interrupted,\n+        wasi::ERRNO_INVAL => InvalidInput,\n+        wasi::ERRNO_TIMEDOUT => TimedOut,\n+        wasi::ERRNO_EXIST => AlreadyExists,\n+        wasi::ERRNO_AGAIN => WouldBlock,\n         _ => Other,\n     }\n }\n@@ -116,16 +111,13 @@ pub unsafe fn abort_internal() -> ! {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut ret = (0u64, 0u64);\n     unsafe {\n-        let base = &mut ret as *mut (u64, u64) as *mut core::ffi::c_void;\n+        let base = &mut ret as *mut (u64, u64) as *mut u8;\n         let len = mem::size_of_val(&ret);\n-        let ret = wasi::raw::__wasi_random_get(base, len);\n-        if ret != 0 {\n-            panic!(\"__wasi_random_get failure\")\n-        }\n+        wasi::random_get(base, len).expect(\"random_get failure\");\n     }\n     return ret\n }\n \n fn err2io(err: wasi::Error) -> std_io::Error {\n-    std_io::Error::from_raw_os_error(err.get() as i32)\n+    std_io::Error::from_raw_os_error(err.raw_error().into())\n }"}, {"sha": "1d53884f2d6b40a6779718ea4c0387777c90b6b5", "filename": "src/libstd/sys/wasi/stdio.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -2,8 +2,6 @@ use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem::ManuallyDrop;\n use crate::sys::fd::WasiFd;\n \n-use ::wasi::wasi_unstable as wasi;\n-\n pub struct Stdin;\n pub struct Stdout;\n pub struct Stderr;\n@@ -18,8 +16,11 @@ impl Stdin {\n     }\n \n     pub fn read_vectored(&self, data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDIN_FD) })\n-            .read(data)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).read(data)\n+    }\n+\n+    pub fn as_raw_fd(&self) -> u32 {\n+        0\n     }\n }\n \n@@ -33,13 +34,16 @@ impl Stdout {\n     }\n \n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDOUT_FD) })\n-            .write(data)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).write(data)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n         Ok(())\n     }\n+\n+    pub fn as_raw_fd(&self) -> u32 {\n+        1\n+    }\n }\n \n impl Stderr {\n@@ -52,13 +56,16 @@ impl Stderr {\n     }\n \n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDERR_FD) })\n-            .write(data)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).write(data)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n         Ok(())\n     }\n+\n+    pub fn as_raw_fd(&self) -> u32 {\n+        2\n+    }\n }\n \n impl io::Write for Stderr {\n@@ -74,7 +81,7 @@ impl io::Write for Stderr {\n pub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n \n pub fn is_ebadf(err: &io::Error) -> bool {\n-    err.raw_os_error() == Some(wasi::EBADF.get() as i32)\n+    err.raw_os_error() == Some(wasi::ERRNO_BADF.into())\n }\n \n pub fn panic_output() -> Option<impl io::Write> {"}, {"sha": "0986759b89b7cd13efeb8ca1f217a37d7bf05866", "filename": "src/libstd/sys/wasi/thread.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -4,22 +4,18 @@ use crate::mem;\n use crate::sys::{unsupported, Void};\n use crate::time::Duration;\n \n-use ::wasi::wasi_unstable as wasi;\n-\n pub struct Thread(Void);\n \n pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n \n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>)\n-        -> io::Result<Thread>\n-    {\n+    pub unsafe fn new(_stack: usize, _p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n         unsupported()\n     }\n \n     pub fn yield_now() {\n-        let ret = wasi::sched_yield();\n+        let ret = unsafe { wasi::sched_yield() };\n         debug_assert_eq!(ret, Ok(()));\n     }\n \n@@ -33,32 +29,30 @@ impl Thread {\n \n         const USERDATA: wasi::Userdata = 0x0123_45678;\n \n-        let clock = wasi::raw::__wasi_subscription_u_clock_t {\n-            identifier: 0,\n-            clock_id: wasi::CLOCK_MONOTONIC,\n+        let clock = wasi::SubscriptionClock {\n+            id: wasi::CLOCKID_MONOTONIC,\n             timeout: nanos as u64,\n             precision: 0,\n             flags: 0,\n         };\n \n-        let in_ = [wasi::Subscription {\n+        let in_ = wasi::Subscription {\n             userdata: USERDATA,\n-            type_: wasi::EVENTTYPE_CLOCK,\n-            u: wasi::raw::__wasi_subscription_u { clock: clock },\n-        }];\n-        let (res, event) = unsafe {\n-            let mut out: [wasi::Event; 1] = mem::zeroed();\n-            let res = wasi::poll_oneoff(&in_, &mut out);\n-            (res, out[0])\n+            r#type: wasi::EVENTTYPE_CLOCK,\n+            u: wasi::SubscriptionU { clock },\n         };\n-        match (res, event) {\n-            (Ok(1), wasi::Event {\n-                userdata: USERDATA,\n-                error: 0,\n-                type_: wasi::EVENTTYPE_CLOCK,\n-                ..\n-            }) => {}\n-            _ => panic!(\"thread::sleep(): unexpected result of poll_oneoff\"),\n+        unsafe {\n+            let mut event: wasi::Event = mem::zeroed();\n+            let res = wasi::poll_oneoff(&in_, &mut event, 1);\n+            match (res, event) {\n+                (\n+                    Ok(1),\n+                    wasi::Event {\n+                        userdata: USERDATA, error: 0, r#type: wasi::EVENTTYPE_CLOCK, ..\n+                    },\n+                ) => {}\n+                _ => panic!(\"thread::sleep(): unexpected result of poll_oneoff\"),\n+            }\n         }\n     }\n \n@@ -69,6 +63,10 @@ impl Thread {\n \n pub mod guard {\n     pub type Guard = !;\n-    pub unsafe fn current() -> Option<Guard> { None }\n-    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn current() -> Option<Guard> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<Guard> {\n+        None\n+    }\n }"}, {"sha": "80ec317b5a2c60520fc03c634455b24b0cf3aed9", "filename": "src/libstd/sys/wasi/time.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b83dcf2eed11bfe9a902d769e9474f39a902326/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs?ref=1b83dcf2eed11bfe9a902d769e9474f39a902326", "patch": "@@ -1,5 +1,4 @@\n use crate::time::Duration;\n-use ::wasi::wasi_unstable as wasi;\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -10,19 +9,18 @@ pub struct SystemTime(Duration);\n pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n fn current_time(clock: u32) -> Duration {\n-    let ts = wasi::clock_time_get(\n-        clock,\n-        1, // precision... seems ignored though?\n-    ).unwrap();\n-    Duration::new(\n-        (ts / 1_000_000_000) as u64,\n-        (ts % 1_000_000_000) as u32,\n-    )\n+    let ts = unsafe {\n+        wasi::clock_time_get(\n+            clock, 1, // precision... seems ignored though?\n+        )\n+        .unwrap()\n+    };\n+    Duration::new((ts / 1_000_000_000) as u64, (ts % 1_000_000_000) as u32)\n }\n \n impl Instant {\n     pub fn now() -> Instant {\n-        Instant(current_time(wasi::CLOCK_MONOTONIC))\n+        Instant(current_time(wasi::CLOCKID_MONOTONIC))\n     }\n \n     pub const fn zero() -> Instant {\n@@ -48,15 +46,14 @@ impl Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        SystemTime(current_time(wasi::CLOCK_REALTIME))\n+        SystemTime(current_time(wasi::CLOCKID_REALTIME))\n     }\n \n     pub fn from_wasi_timestamp(ts: wasi::Timestamp) -> SystemTime {\n         SystemTime(Duration::from_nanos(ts))\n     }\n \n-    pub fn sub_time(&self, other: &SystemTime)\n-                    -> Result<Duration, Duration> {\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n         self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n     }\n "}]}