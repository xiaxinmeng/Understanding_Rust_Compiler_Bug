{"sha": "a5b422fe6ba916b8761a70f3043982ce0af77956", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YjQyMmZlNmJhOTE2Yjg3NjFhNzBmMzA0Mzk4MmNlMGFmNzc5NTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-30T00:33:41Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-30T00:34:49Z"}, "message": "rustc: Translate calls on the C stack", "tree": {"sha": "ef3b1677ccf1623cc9a0e10908c43dc3fc5b190c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef3b1677ccf1623cc9a0e10908c43dc3fc5b190c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5b422fe6ba916b8761a70f3043982ce0af77956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b422fe6ba916b8761a70f3043982ce0af77956", "html_url": "https://github.com/rust-lang/rust/commit/a5b422fe6ba916b8761a70f3043982ce0af77956", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5b422fe6ba916b8761a70f3043982ce0af77956/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f22601321f3844ea009ece6d410353644aaf8ec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f22601321f3844ea009ece6d410353644aaf8ec2", "html_url": "https://github.com/rust-lang/rust/commit/f22601321f3844ea009ece6d410353644aaf8ec2"}], "stats": {"total": 124, "additions": 98, "deletions": 26}, "files": [{"sha": "35ecd1470820a2b10a46c5e28067ec6c4c234fb3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 98, "deletions": 26, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a5b422fe6ba916b8761a70f3043982ce0af77956/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b422fe6ba916b8761a70f3043982ce0af77956/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a5b422fe6ba916b8761a70f3043982ce0af77956", "patch": "@@ -3897,6 +3897,11 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     // with trans_call.\n     let tcx = bcx_tcx(in_cx);\n     let fn_expr_ty = ty::expr_ty(tcx, f);\n+\n+    if check type_is_native_fn_on_c_stack(tcx, fn_expr_ty) {\n+        ret trans_c_stack_native_call(in_cx, f, args);\n+    }\n+\n     let by_ref = ast_util::ret_by_ref(ty::ty_fn_ret_style(tcx, fn_expr_ty));\n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n     let f_res = trans_callee(cx, f);\n@@ -3977,6 +3982,63 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     ret {res: rslt(bcx, retval), by_ref: by_ref};\n }\n \n+// Translates a native call on the C stack. Calls into the runtime to perform\n+// the stack switching operation.\n+fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n+                             args: [@ast::expr])\n+        -> {res: result, by_ref: bool} {\n+    let ccx = bcx_ccx(bcx);\n+    let f_res = trans_callee(bcx, f);\n+    let llfn = f_res.val; bcx = f_res.bcx;\n+\n+    // Translate the callee.\n+    let fn_ty = ty::expr_ty(bcx_tcx(bcx), f);\n+    let fn_arg_tys = ty::ty_fn_args(bcx_tcx(bcx), fn_ty);\n+\n+    // Translate arguments.\n+    let (to_zero, to_revoke) = ([], []);\n+    let llargs = vec::map2({ |ty_arg, arg|\n+        let arg_ty = ty_arg.ty;\n+        check type_has_static_size(ccx, arg_ty);\n+        let llargty = type_of(ccx, f.span, arg_ty);\n+        let r = trans_arg_expr(bcx, ty_arg, llargty, to_zero, to_revoke, arg);\n+        let llargval = r.val; bcx = r.bcx;\n+        { llval: llargval, llty: llargty }\n+    }, fn_arg_tys, args);\n+\n+    // Allocate the argument bundle.\n+    let llargbundlety = T_struct(vec::map({ |r| r.llty }, llargs));\n+    let llargbundlesz = llsize_of(llargbundlety);\n+    let llrawargbundle = Call(bcx, ccx.upcalls.alloc_c_stack,\n+                              [llargbundlesz]);\n+    let llargbundle = PointerCast(bcx, llrawargbundle, T_ptr(llargbundlety));\n+\n+    // Copy in arguments.\n+    log_err (\"bundle type\", val_str(ccx.tn, llargbundle));\n+    vec::eachi({ |llarg, i|\n+        // FIXME: This load is unfortunate.\n+        let llargval = Load(bcx, llarg.llval);\n+        log_err (\"llarg type\", val_str(ccx.tn, llargval), i);\n+        store_inbounds(bcx, llargval, llargbundle, [C_int(0), C_uint(i)]);\n+    }, llargs);\n+\n+    // Call.\n+    // TODO: Invoke instead.\n+    let llrawretval = Call(bcx, ccx.upcalls.call_c_stack,\n+                           [llfn, llrawargbundle]);\n+\n+    // Cast return type.\n+    let ret_ty = ty::ty_fn_ret(bcx_tcx(bcx), fn_ty);\n+    check type_has_static_size(ccx, ret_ty);\n+    let llretty = type_of(ccx, f.span, ret_ty);\n+    let llretval = TruncOrBitCast(bcx, llrawretval, llretty);\n+\n+    // Forget about anything we moved out.\n+    bcx = zero_and_revoke(bcx, to_zero, to_revoke);\n+\n+    ret {res: rslt(bcx, llretval), by_ref: false};\n+}\n+\n fn zero_and_revoke(bcx: @block_ctxt,\n                    to_zero: [{v: ValueRef, t: ty::t}],\n                    to_revoke: [{v: ValueRef, t: ty::t}]) -> @block_ctxt {\n@@ -5662,7 +5724,7 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     ret count;\n }\n \n-fn native_abi_requires_pair(abi: ast::native_abi) -> bool {\n+pure fn native_abi_requires_pair(abi: ast::native_abi) -> bool {\n     alt abi {\n         ast::native_abi_rust. | ast::native_abi_cdecl. |\n         ast::native_abi_llvm. | ast::native_abi_rust_intrinsic. |\n@@ -5671,6 +5733,13 @@ fn native_abi_requires_pair(abi: ast::native_abi) -> bool {\n     }\n }\n \n+pure fn type_is_native_fn_on_c_stack(tcx: ty::ctxt, t: ty::t) -> bool {\n+    alt ty::struct(tcx, t) {\n+        ty::ty_native_fn(abi, _, _) { ret !native_abi_requires_pair(abi); }\n+        _ { ret false; }\n+    }\n+}\n+\n fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n@@ -5690,32 +5759,8 @@ fn raw_native_fn_type(ccx: @crate_ctxt, sp: span, args: [ty::arg],\n \n fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n                            id: ast::node_id) {\n-    let path = path;\n-    let num_ty_param = native_fn_ty_param_count(ccx, id);\n-    // Declare the wrapper.\n-\n-    let t = node_id_type(ccx, id);\n-    let wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n-    let ps: str = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n-    let wrapper_fn = decl_cdecl_fn(ccx.llmod, ps, wrapper_type);\n-    ccx.item_ids.insert(id, wrapper_fn);\n-    ccx.item_symbols.insert(id, ps);\n-\n-    // Build the wrapper.\n-    let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, wrapper_fn);\n-    let bcx = new_top_block_ctxt(fcx);\n-    let lltop = bcx.llbb;\n-\n-    // Declare the function itself.\n     let fn_type = node_id_type(ccx, id); // NB: has no type params\n-\n     let abi = ty::ty_fn_abi(ccx.tcx, fn_type);\n-    // FIXME: If the returned type is not nil, then we assume it's 32 bits\n-    // wide. This is obviously wildly unsafe. We should have a better FFI\n-    // that allows types of different sizes to be returned.\n-\n-    let rty = ty::ty_fn_ret(ccx.tcx, fn_type);\n-    let rty_is_nil = ty::type_is_nil(ccx.tcx, rty);\n \n     let pass_task;\n     let uses_retptr;\n@@ -5747,10 +5792,37 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n         cast_to_i32 = true;\n       }\n       ast::native_abi_c_stack_cdecl. {\n-        fail \"C stack cdecl ABI shouldn't have a wrapper\";\n+        let llfn = decl_cdecl_fn(ccx.llmod, name, T_fn([], T_void()));\n+        ccx.item_ids.insert(id, llfn);\n+        ccx.item_symbols.insert(id, name);\n+        ret;\n       }\n     }\n \n+    let path = path;\n+    let num_ty_param = native_fn_ty_param_count(ccx, id);\n+    // Declare the wrapper.\n+\n+    let t = node_id_type(ccx, id);\n+    let wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n+    let ps: str = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n+    let wrapper_fn = decl_cdecl_fn(ccx.llmod, ps, wrapper_type);\n+    ccx.item_ids.insert(id, wrapper_fn);\n+    ccx.item_symbols.insert(id, ps);\n+\n+    // Build the wrapper.\n+    let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, wrapper_fn);\n+    let bcx = new_top_block_ctxt(fcx);\n+    let lltop = bcx.llbb;\n+\n+    // Declare the function itself.\n+    // FIXME: If the returned type is not nil, then we assume it's 32 bits\n+    // wide. This is obviously wildly unsafe. We should have a better FFI\n+    // that allows types of different sizes to be returned.\n+\n+    let rty = ty::ty_fn_ret(ccx.tcx, fn_type);\n+    let rty_is_nil = ty::type_is_nil(ccx.tcx, rty);\n+\n     let lltaskptr;\n     if cast_to_i32 {\n         lltaskptr = vp2i(bcx, fcx.lltaskptr);"}]}