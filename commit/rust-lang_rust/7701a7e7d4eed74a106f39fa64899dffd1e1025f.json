{"sha": "7701a7e7d4eed74a106f39fa64899dffd1e1025f", "node_id": "C_kwDOAAsO6NoAKDc3MDFhN2U3ZDRlZWQ3NGExMDZmMzlmYTY0ODk5ZGZmZDFlMTAyNWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-09T03:05:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-09T03:05:27Z"}, "message": "Auto merge of #105456 - matthiaskrgr:rollup-yennygf, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #104922 (Detect long types in E0308 and write them to disk)\n - #105120 (kmc-solid: `std::sys` code maintenance)\n - #105255 (Make nested RPIT inherit the parent opaque's generics.)\n - #105317 (make retagging work even with 'unstable' places)\n - #105405 (Stop passing -export-dynamic to wasm-ld.)\n - #105408 (Add help for `#![feature(impl_trait_in_fn_trait_return)]`)\n - #105423 (Use `Symbol` for the crate name instead of `String`/`str`)\n - #105433 (CI: add missing line continuation marker)\n - #105434 (Fix warning when libcore is compiled with no_fp_fmt_parse)\n - #105441 (Remove `UnsafetyState`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6921886cc9b73c908488dbfdf2322e92e0ced131", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6921886cc9b73c908488dbfdf2322e92e0ced131"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7701a7e7d4eed74a106f39fa64899dffd1e1025f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7701a7e7d4eed74a106f39fa64899dffd1e1025f", "html_url": "https://github.com/rust-lang/rust/commit/7701a7e7d4eed74a106f39fa64899dffd1e1025f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7701a7e7d4eed74a106f39fa64899dffd1e1025f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b359ccf1b0b7b2d2c1c4932344b806e68bd053a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b359ccf1b0b7b2d2c1c4932344b806e68bd053a9", "html_url": "https://github.com/rust-lang/rust/commit/b359ccf1b0b7b2d2c1c4932344b806e68bd053a9"}, {"sha": "660795eee5852a9ea66e7554cb517f14b99fb2f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/660795eee5852a9ea66e7554cb517f14b99fb2f0", "html_url": "https://github.com/rust-lang/rust/commit/660795eee5852a9ea66e7554cb517f14b99fb2f0"}], "stats": {"total": 1400, "additions": 825, "deletions": 575}, "files": [{"sha": "844cf99b4688d0cc0daa3a85d09d985df4822147", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -4348,6 +4348,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n+ \"termize\",\n  \"tracing\",\n  \"winapi\",\n ]"}, {"sha": "4fa18907fcd466cd262eeddc2968514d01022945", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -259,6 +259,8 @@ enum ImplTraitContext {\n     },\n     /// Impl trait in type aliases.\n     TypeAliasesOpaqueTy,\n+    /// `impl Trait` is unstably accepted in this position.\n+    FeatureGated(ImplTraitPosition, Symbol),\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n@@ -1372,25 +1374,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         path\n                     }\n-                    ImplTraitContext::Disallowed(\n-                        position @ (ImplTraitPosition::TraitReturn | ImplTraitPosition::ImplReturn),\n-                    ) => {\n+                    ImplTraitContext::FeatureGated(position, feature) => {\n                         self.tcx\n                             .sess\n                             .create_feature_err(\n                                 MisplacedImplTrait {\n                                     span: t.span,\n-                                    position: DiagnosticArgFromDisplay(&position),\n+                                    position: DiagnosticArgFromDisplay(position),\n                                 },\n-                                sym::return_position_impl_trait_in_trait,\n+                                *feature,\n                             )\n                             .emit();\n                         hir::TyKind::Err\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n                         self.tcx.sess.emit_err(MisplacedImplTrait {\n                             span: t.span,\n-                            position: DiagnosticArgFromDisplay(&position),\n+                            position: DiagnosticArgFromDisplay(position),\n                         });\n                         hir::TyKind::Err\n                     }\n@@ -1739,14 +1739,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         } else {\n             match &decl.output {\n                 FnRetTy::Ty(ty) => {\n-                    let mut context = if kind.return_impl_trait_allowed(self.tcx) {\n+                    let context = if kind.return_impl_trait_allowed(self.tcx) {\n                         let fn_def_id = self.local_def_id(fn_node_id);\n                         ImplTraitContext::ReturnPositionOpaqueTy {\n                             origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                             in_trait: matches!(kind, FnDeclKind::Trait),\n                         }\n                     } else {\n-                        ImplTraitContext::Disallowed(match kind {\n+                        let position = match kind {\n                             FnDeclKind::Fn | FnDeclKind::Inherent => {\n                                 unreachable!(\"fn should allow in-band lifetimes\")\n                             }\n@@ -1755,9 +1755,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             FnDeclKind::Pointer => ImplTraitPosition::PointerReturn,\n                             FnDeclKind::Trait => ImplTraitPosition::TraitReturn,\n                             FnDeclKind::Impl => ImplTraitPosition::ImplReturn,\n-                        })\n+                        };\n+                        match kind {\n+                            FnDeclKind::Trait | FnDeclKind::Impl => ImplTraitContext::FeatureGated(\n+                                position,\n+                                sym::return_position_impl_trait_in_trait,\n+                            ),\n+                            _ => ImplTraitContext::Disallowed(position),\n+                        }\n                     };\n-                    hir::FnRetTy::Return(self.lower_ty(ty, &mut context))\n+                    hir::FnRetTy::Return(self.lower_ty(ty, &context))\n                 }\n                 FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(*span)),\n             }\n@@ -1938,7 +1945,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     output,\n                     span,\n                     if in_trait && !this.tcx.features().return_position_impl_trait_in_trait {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::TraitReturn)\n+                        ImplTraitContext::FeatureGated(\n+                            ImplTraitPosition::TraitReturn,\n+                            sym::return_position_impl_trait_in_trait,\n+                        )\n                     } else {\n                         ImplTraitContext::ReturnPositionOpaqueTy {\n                             origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),"}, {"sha": "592fc5aa6456f064e0d399f5a0c1487067f147ce", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::{self as ast, *};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, PartialRes, Res};\n use rustc_hir::GenericArg;\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};\n@@ -352,11 +352,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // fn f(_: impl Fn() -> impl Debug) -> impl Fn() -> impl Debug\n             // //      disallowed --^^^^^^^^^^        allowed --^^^^^^^^^^\n             // ```\n-            FnRetTy::Ty(ty)\n-                if matches!(itctx, ImplTraitContext::ReturnPositionOpaqueTy { .. })\n-                    && self.tcx.features().impl_trait_in_fn_trait_return =>\n-            {\n-                self.lower_ty(&ty, itctx)\n+            FnRetTy::Ty(ty) if matches!(itctx, ImplTraitContext::ReturnPositionOpaqueTy { .. }) => {\n+                if self.tcx.features().impl_trait_in_fn_trait_return {\n+                    self.lower_ty(&ty, itctx)\n+                } else {\n+                    self.lower_ty(\n+                        &ty,\n+                        &ImplTraitContext::FeatureGated(\n+                            ImplTraitPosition::FnTraitReturn,\n+                            sym::impl_trait_in_fn_trait_return,\n+                        ),\n+                    )\n+                }\n             }\n             FnRetTy::Ty(ty) => {\n                 self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))"}, {"sha": "882430694e16d7f65668154330f9796d7f8ff924", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -102,7 +102,7 @@ pub fn link_binary<'a>(\n                 sess,\n                 crate_type,\n                 outputs,\n-                codegen_results.crate_info.local_crate_name.as_str(),\n+                codegen_results.crate_info.local_crate_name,\n             );\n             match crate_type {\n                 CrateType::Rlib => {"}, {"sha": "0604d5ee6fa4c93e94211111da45abd2e4715f15", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -373,9 +373,21 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Executes a retagging operation.\n+    /// Executes a retagging operation for a single pointer.\n+    /// Returns the possibly adjusted pointer.\n     #[inline]\n-    fn retag(\n+    fn retag_ptr_value(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _kind: mir::RetagKind,\n+        val: &ImmTy<'tcx, Self::Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Self::Provenance>> {\n+        Ok(val.clone())\n+    }\n+\n+    /// Executes a retagging operation on a compound value.\n+    /// Replaces all pointers stored in the given place.\n+    #[inline]\n+    fn retag_place_contents(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: &PlaceTy<'tcx, Self::Provenance>,"}, {"sha": "81b44a49484d0a72e213d8a32b510e784b7938b1", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::ty::layout::LayoutOf;\n \n-use super::{InterpCx, Machine};\n+use super::{ImmTy, InterpCx, Machine};\n \n /// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n@@ -108,7 +108,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Stacked Borrows.\n             Retag(kind, place) => {\n                 let dest = self.eval_place(**place)?;\n-                M::retag(self, *kind, &dest)?;\n+                M::retag_place_contents(self, *kind, &dest)?;\n             }\n \n             Intrinsic(box ref intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n@@ -247,10 +247,41 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n             }\n \n-            AddressOf(_, place) | Ref(_, _, place) => {\n+            Ref(_, borrow_kind, place) => {\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(&src)?;\n-                self.write_immediate(place.to_ref(self), &dest)?;\n+                let val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n+                // A fresh reference was created, make sure it gets retagged.\n+                let val = M::retag_ptr_value(\n+                    self,\n+                    if borrow_kind.allows_two_phase_borrow() {\n+                        mir::RetagKind::TwoPhase\n+                    } else {\n+                        mir::RetagKind::Default\n+                    },\n+                    &val,\n+                )?;\n+                self.write_immediate(*val, &dest)?;\n+            }\n+\n+            AddressOf(_, place) => {\n+                // Figure out whether this is an addr_of of an already raw place.\n+                let place_base_raw = if place.has_deref() {\n+                    let ty = self.frame().body.local_decls[place.local].ty;\n+                    ty.is_unsafe_ptr()\n+                } else {\n+                    // Not a deref, and thus not raw.\n+                    false\n+                };\n+\n+                let src = self.eval_place(place)?;\n+                let place = self.force_allocation(&src)?;\n+                let mut val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n+                if !place_base_raw {\n+                    // If this was not already raw, it needs retagging.\n+                    val = M::retag_ptr_value(self, mir::RetagKind::Raw, &val)?;\n+                }\n+                self.write_immediate(*val, &dest)?;\n             }\n \n             NullaryOp(null_op, ty) => {"}, {"sha": "f06ca5a0733a58039724c244df9f27ba871be246", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -25,6 +25,7 @@ use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorGuaranteed, PResult};\n use rustc_feature::find_gated_cfg;\n+use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n@@ -374,14 +375,14 @@ fn run_compiler(\n             queries.global_ctxt()?.peek_mut().enter(|tcx| {\n                 let result = tcx.analysis(());\n                 if sess.opts.unstable_opts.save_analysis {\n-                    let crate_name = queries.crate_name()?.peek().clone();\n+                    let crate_name = tcx.crate_name(LOCAL_CRATE);\n                     sess.time(\"save_analysis\", || {\n                         save::process_crate(\n                             tcx,\n-                            &crate_name,\n+                            crate_name,\n                             compiler.input(),\n                             None,\n-                            DumpHandler::new(compiler.output_dir().as_deref(), &crate_name),\n+                            DumpHandler::new(compiler.output_dir().as_deref(), crate_name),\n                         )\n                     });\n                 }\n@@ -678,7 +679,7 @@ fn print_crate_info(\n                 let crate_types = collect_crate_types(sess, attrs);\n                 for &style in &crate_types {\n                     let fname =\n-                        rustc_session::output::filename_for_input(sess, style, &id, &t_outputs);\n+                        rustc_session::output::filename_for_input(sess, style, id, &t_outputs);\n                     println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n                 }\n             }"}, {"sha": "9d6a4f9a1fd7d063dfc06c704e5084abf31de117", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -960,7 +960,7 @@ pub trait LintStoreExpand {\n         node_id: NodeId,\n         attrs: &[Attribute],\n         items: &[P<Item>],\n-        name: &str,\n+        name: Symbol,\n     );\n }\n "}, {"sha": "1014ec2209c614cec4fef55cbbc9481be3192792", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1122,7 +1122,7 @@ impl InvocationCollectorNode for P<ast::Item> {\n                         ecx.current_expansion.lint_node_id,\n                         &attrs,\n                         &items,\n-                        ident.name.as_str(),\n+                        ident.name,\n                     );\n                 }\n "}, {"sha": "8bc022e1e178e19b50698104254dad839b950461", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -827,7 +827,7 @@ impl<'tcx> AttributeMap<'tcx> {\n pub struct OwnerNodes<'tcx> {\n     /// Pre-computed hash of the full HIR.\n     pub hash_including_bodies: Fingerprint,\n-    /// Pre-computed hash of the item signature, sithout recursing into the body.\n+    /// Pre-computed hash of the item signature, without recursing into the body.\n     pub hash_without_bodies: Fingerprint,\n     /// Full HIR for the current owner.\n     // The zeroth node's parent should never be accessed: the owner's parent is computed by the"}, {"sha": "d4791150947fb1fa3fa9f7a529ee113f59fea059", "filename": "compiler/rustc_hir/src/tests.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftests.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1,5 +1,7 @@\n use crate::definitions::{DefKey, DefPathData, DisambiguatedDefPathData};\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n+use rustc_span::edition::Edition;\n+use rustc_span::{create_session_if_not_set_then, Symbol};\n \n #[test]\n fn def_path_hash_depends_on_crate_id() {\n@@ -11,26 +13,28 @@ fn def_path_hash_depends_on_crate_id() {\n     // the crate by changing the crate disambiguator (e.g. via bumping the\n     // crate's version number).\n \n-    let id0 = StableCrateId::new(\"foo\", false, vec![\"1\".to_string()]);\n-    let id1 = StableCrateId::new(\"foo\", false, vec![\"2\".to_string()]);\n+    create_session_if_not_set_then(Edition::Edition2024, |_| {\n+        let id0 = StableCrateId::new(Symbol::intern(\"foo\"), false, vec![\"1\".to_string()]);\n+        let id1 = StableCrateId::new(Symbol::intern(\"foo\"), false, vec![\"2\".to_string()]);\n \n-    let h0 = mk_test_hash(id0);\n-    let h1 = mk_test_hash(id1);\n+        let h0 = mk_test_hash(id0);\n+        let h1 = mk_test_hash(id1);\n \n-    assert_ne!(h0.stable_crate_id(), h1.stable_crate_id());\n-    assert_ne!(h0.local_hash(), h1.local_hash());\n+        assert_ne!(h0.stable_crate_id(), h1.stable_crate_id());\n+        assert_ne!(h0.local_hash(), h1.local_hash());\n \n-    fn mk_test_hash(stable_crate_id: StableCrateId) -> DefPathHash {\n-        let parent_hash = DefPathHash::new(stable_crate_id, 0);\n+        fn mk_test_hash(stable_crate_id: StableCrateId) -> DefPathHash {\n+            let parent_hash = DefPathHash::new(stable_crate_id, 0);\n \n-        let key = DefKey {\n-            parent: None,\n-            disambiguated_data: DisambiguatedDefPathData {\n-                data: DefPathData::CrateRoot,\n-                disambiguator: 0,\n-            },\n-        };\n+            let key = DefKey {\n+                parent: None,\n+                disambiguated_data: DisambiguatedDefPathData {\n+                    data: DefPathData::CrateRoot,\n+                    disambiguator: 0,\n+                },\n+            };\n \n-        key.compute_stable_hash(parent_hash)\n-    }\n+            key.compute_stable_hash(parent_hash)\n+        }\n+    })\n }"}, {"sha": "0a7e25300cba84b38c551cc6ea84fc71ef786e7f", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -4,7 +4,6 @@ use hir::{\n     GenericParamKind, HirId, Node,\n };\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n@@ -143,20 +142,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             Some(tcx.typeck_root_def_id(def_id))\n         }\n         Node::Item(item) => match item.kind {\n-            ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin:\n-                    hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n-                in_trait,\n-                ..\n-            }) => {\n-                if in_trait {\n-                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn))\n-                } else {\n-                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn | DefKind::Fn))\n-                }\n-                Some(fn_def_id.to_def_id())\n-            }\n-            ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n+            ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n                 let parent_id = tcx.hir().get_parent_item(hir_id);\n                 assert_ne!(parent_id, hir::CRATE_OWNER_ID);\n                 debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);"}, {"sha": "32f86b8042c11c39d36baa268dc8cb40d1c1a1c3", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1,7 +1,7 @@\n use crate::coercion::CoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n use crate::FnCtxt;\n-use crate::{GeneratorTypes, UnsafetyState};\n+use crate::GeneratorTypes;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::intravisit::Visitor;\n@@ -30,7 +30,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     can_be_generator: Option<hir::Movability>,\n ) -> Option<GeneratorTypes<'tcx>> {\n     let fn_id = fcx.tcx.hir().local_def_id_to_hir_id(fn_def_id);\n-    fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n \n     let tcx = fcx.tcx;\n     let hir = tcx.hir();"}, {"sha": "60fec05d36d6d57545a223bda2a4d1c7d73af4d5", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1393,8 +1393,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         blk: &'tcx hir::Block<'tcx>,\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let prev = self.ps.replace(self.ps.get().recurse(blk));\n-\n         // In some cases, blocks have just one exit, but other blocks\n         // can be targeted by multiple breaks. This can happen both\n         // with labeled blocks as well as when we desugar\n@@ -1558,7 +1556,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.write_ty(blk.hir_id, ty);\n \n-        self.ps.set(prev);\n         ty\n     }\n "}, {"sha": "30b59da7852d46f1e96543ef7566668e00834910", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::ErrorGuaranteed;\n pub use suggestions::*;\n \n use crate::coercion::DynamicCoerceMany;\n-use crate::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n+use crate::{Diverges, EnclosingBreakables, Inherited};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir_analysis::astconv::AstConv;\n@@ -74,8 +74,6 @@ pub struct FnCtxt<'a, 'tcx> {\n \n     pub(super) resume_yield_tys: Option<(Ty<'tcx>, Ty<'tcx>)>,\n \n-    pub(super) ps: Cell<UnsafetyState>,\n-\n     /// Whether the last checked node generates a divergence (e.g.,\n     /// `return` will set this to `Always`). In general, when entering\n     /// an expression or other node in the tree, the initial value\n@@ -129,7 +127,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ret_coercion: None,\n             ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n-            ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {\n                 stack: Vec::new(),"}, {"sha": "5b2352cda34b3ee5fa9bcfa2f98d11acee4af2c4", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -89,38 +89,6 @@ pub struct LocalTy<'tcx> {\n     revealed_ty: Ty<'tcx>,\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnsafetyState {\n-    pub def: hir::HirId,\n-    pub unsafety: hir::Unsafety,\n-    from_fn: bool,\n-}\n-\n-impl UnsafetyState {\n-    pub fn function(unsafety: hir::Unsafety, def: hir::HirId) -> UnsafetyState {\n-        UnsafetyState { def, unsafety, from_fn: true }\n-    }\n-\n-    pub fn recurse(self, blk: &hir::Block<'_>) -> UnsafetyState {\n-        use hir::BlockCheckMode;\n-        match self.unsafety {\n-            // If this unsafe, then if the outer function was already marked as\n-            // unsafe we shouldn't attribute the unsafe'ness to the block. This\n-            // way the block can be warned about instead of ignoring this\n-            // extraneous block (functions are never warned about).\n-            hir::Unsafety::Unsafe if self.from_fn => self,\n-\n-            unsafety => {\n-                let (unsafety, def) = match blk.rules {\n-                    BlockCheckMode::UnsafeBlock(..) => (hir::Unsafety::Unsafe, blk.hir_id),\n-                    BlockCheckMode::DefaultBlock => (unsafety, self.def),\n-                };\n-                UnsafetyState { def, unsafety, from_fn: false }\n-            }\n-        }\n-    }\n-}\n-\n /// If this `DefId` is a \"primary tables entry\", returns\n /// `Some((body_id, body_ty, fn_sig))`. Otherwise, returns `None`.\n ///"}, {"sha": "97ebed0585579ab99bb60bc2b6eb0889f842261c", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -109,6 +109,7 @@ use rustc_data_structures::{base_n, flock};\n use rustc_errors::ErrorGuaranteed;\n use rustc_fs_util::{link_or_copy, LinkOrCopy};\n use rustc_session::{Session, StableCrateId};\n+use rustc_span::Symbol;\n \n use std::fs as std_fs;\n use std::io::{self, ErrorKind};\n@@ -202,7 +203,7 @@ pub fn in_incr_comp_dir(incr_comp_session_dir: &Path, file_name: &str) -> PathBu\n /// [`rustc_interface::queries::dep_graph`]: ../../rustc_interface/struct.Queries.html#structfield.dep_graph\n pub fn prepare_session_directory(\n     sess: &Session,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     stable_crate_id: StableCrateId,\n ) -> Result<(), ErrorGuaranteed> {\n     if sess.opts.incremental.is_none() {\n@@ -657,7 +658,7 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n     Ok(UNIX_EPOCH + duration)\n }\n \n-fn crate_path(sess: &Session, crate_name: &str, stable_crate_id: StableCrateId) -> PathBuf {\n+fn crate_path(sess: &Session, crate_name: Symbol, stable_crate_id: StableCrateId) -> PathBuf {\n     let incr_dir = sess.opts.incremental.as_ref().unwrap().clone();\n \n     let stable_crate_id = base_n::encode(stable_crate_id.to_u64() as u128, INT_ENCODE_BASE);"}, {"sha": "980a17e41e13f0909df8526f53cb63362ca4483a", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 103, "deletions": 78, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -80,6 +80,7 @@ use rustc_middle::ty::{\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::{ControlFlow, Deref};\n+use std::path::PathBuf;\n use std::{cmp, fmt, iter};\n \n mod note;\n@@ -1352,10 +1353,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             .map(|(mod_str, _)| mod_str.len() + separator_len)\n                             .sum();\n \n-                    debug!(\n-                        \"cmp: separator_len={}, split_idx={}, min_len={}\",\n-                        separator_len, split_idx, min_len\n-                    );\n+                    debug!(?separator_len, ?split_idx, ?min_len, \"cmp\");\n \n                     if split_idx >= min_len {\n                         // paths are identical, highlight everything\n@@ -1366,7 +1364,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     } else {\n                         let (common, uniq1) = t1_str.split_at(split_idx);\n                         let (_, uniq2) = t2_str.split_at(split_idx);\n-                        debug!(\"cmp: common={}, uniq1={}, uniq2={}\", common, uniq1, uniq2);\n+                        debug!(?common, ?uniq1, ?uniq2, \"cmp\");\n \n                         values.0.push_normal(common);\n                         values.0.push_highlighted(uniq1);\n@@ -1659,17 +1657,14 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     }\n                     ValuePairs::Regions(_) => (false, Mismatch::Fixed(\"lifetime\")),\n                 };\n-                let vals = match self.values_str(values) {\n-                    Some((expected, found)) => Some((expected, found)),\n-                    None => {\n-                        // Derived error. Cancel the emitter.\n-                        // NOTE(eddyb) this was `.cancel()`, but `diag`\n-                        // is borrowed, so we can't fully defuse it.\n-                        diag.downgrade_to_delayed_bug();\n-                        return;\n-                    }\n+                let Some(vals) = self.values_str(values) else {\n+                    // Derived error. Cancel the emitter.\n+                    // NOTE(eddyb) this was `.cancel()`, but `diag`\n+                    // is borrowed, so we can't fully defuse it.\n+                    diag.downgrade_to_delayed_bug();\n+                    return;\n                 };\n-                (vals, exp_found, is_simple_error, Some(values))\n+                (Some(vals), exp_found, is_simple_error, Some(values))\n             }\n         };\n \n@@ -1701,7 +1696,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             label_or_note(span, &terr.to_string());\n         }\n \n-        if let Some((expected, found)) = expected_found {\n+        if let Some((expected, found, exp_p, found_p)) = expected_found {\n             let (expected_label, found_label, exp_found) = match exp_found {\n                 Mismatch::Variable(ef) => (\n                     ef.expected.prefix_string(self.tcx),\n@@ -1818,32 +1813,41 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 }\n                 TypeError::Sorts(values) => {\n                     let extra = expected == found;\n-                    let sort_string = |ty: Ty<'tcx>| match (extra, ty.kind()) {\n-                        (true, ty::Opaque(def_id, _)) => {\n-                            let sm = self.tcx.sess.source_map();\n-                            let pos = sm.lookup_char_pos(self.tcx.def_span(*def_id).lo());\n-                            format!(\n-                                \" (opaque type at <{}:{}:{}>)\",\n-                                sm.filename_for_diagnostics(&pos.file.name),\n-                                pos.line,\n-                                pos.col.to_usize() + 1,\n-                            )\n-                        }\n-                        (true, ty::Projection(proj))\n-                            if self.tcx.def_kind(proj.item_def_id)\n-                                == DefKind::ImplTraitPlaceholder =>\n-                        {\n-                            let sm = self.tcx.sess.source_map();\n-                            let pos = sm.lookup_char_pos(self.tcx.def_span(proj.item_def_id).lo());\n-                            format!(\n-                                \" (trait associated opaque type at <{}:{}:{}>)\",\n-                                sm.filename_for_diagnostics(&pos.file.name),\n-                                pos.line,\n-                                pos.col.to_usize() + 1,\n-                            )\n+                    let sort_string = |ty: Ty<'tcx>, path: Option<PathBuf>| {\n+                        let mut s = match (extra, ty.kind()) {\n+                            (true, ty::Opaque(def_id, _)) => {\n+                                let sm = self.tcx.sess.source_map();\n+                                let pos = sm.lookup_char_pos(self.tcx.def_span(*def_id).lo());\n+                                format!(\n+                                    \" (opaque type at <{}:{}:{}>)\",\n+                                    sm.filename_for_diagnostics(&pos.file.name),\n+                                    pos.line,\n+                                    pos.col.to_usize() + 1,\n+                                )\n+                            }\n+                            (true, ty::Projection(proj))\n+                                if self.tcx.def_kind(proj.item_def_id)\n+                                    == DefKind::ImplTraitPlaceholder =>\n+                            {\n+                                let sm = self.tcx.sess.source_map();\n+                                let pos = sm.lookup_char_pos(self.tcx.def_span(proj.item_def_id).lo());\n+                                format!(\n+                                    \" (trait associated opaque type at <{}:{}:{}>)\",\n+                                    sm.filename_for_diagnostics(&pos.file.name),\n+                                    pos.line,\n+                                    pos.col.to_usize() + 1,\n+                                )\n+                            }\n+                            (true, _) => format!(\" ({})\", ty.sort_string(self.tcx)),\n+                            (false, _) => \"\".to_string(),\n+                        };\n+                        if let Some(path) = path {\n+                            s.push_str(&format!(\n+                                \"\\nthe full type name has been written to '{}'\",\n+                                path.display(),\n+                            ));\n                         }\n-                        (true, _) => format!(\" ({})\", ty.sort_string(self.tcx)),\n-                        (false, _) => \"\".to_string(),\n+                        s\n                     };\n                     if !(values.expected.is_simple_text() && values.found.is_simple_text())\n                         || (exp_found.map_or(false, |ef| {\n@@ -1865,8 +1869,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                             expected,\n                             &found_label,\n                             found,\n-                            &sort_string(values.expected),\n-                            &sort_string(values.found),\n+                            &sort_string(values.expected, exp_p),\n+                            &sort_string(values.found, found_p),\n                         );\n                     }\n                 }\n@@ -2339,7 +2343,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 let code = trace.cause.code();\n                 if let &MatchExpressionArm(box MatchExpressionArmCause { source, .. }) = code\n                     && let hir::MatchSource::TryDesugar = source\n-                    && let Some((expected_ty, found_ty)) = self.values_str(trace.values)\n+                    && let Some((expected_ty, found_ty, _, _)) = self.values_str(trace.values)\n                 {\n                     err.note(&format!(\n                         \"`?` operator cannot convert from `{}` to `{}`\",\n@@ -2455,7 +2459,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     fn values_str(\n         &self,\n         values: ValuePairs<'tcx>,\n-    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString, Option<PathBuf>, Option<PathBuf>)>\n+    {\n         match values {\n             infer::Regions(exp_found) => self.expected_found_str(exp_found),\n             infer::Terms(exp_found) => self.expected_found_str_term(exp_found),\n@@ -2465,7 +2470,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     found: exp_found.found.print_only_trait_path(),\n                 };\n                 match self.expected_found_str(pretty_exp_found) {\n-                    Some((expected, found)) if expected == found => {\n+                    Some((expected, found, _, _)) if expected == found => {\n                         self.expected_found_str(exp_found)\n                     }\n                     ret => ret,\n@@ -2477,7 +2482,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     found: exp_found.found.print_only_trait_path(),\n                 };\n                 match self.expected_found_str(pretty_exp_found) {\n-                    Some((expected, found)) if expected == found => {\n+                    Some((expected, found, _, _)) if expected == found => {\n                         self.expected_found_str(exp_found)\n                     }\n                     ret => ret,\n@@ -2489,17 +2494,41 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     fn expected_found_str_term(\n         &self,\n         exp_found: ty::error::ExpectedFound<ty::Term<'tcx>>,\n-    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString, Option<PathBuf>, Option<PathBuf>)>\n+    {\n         let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n \n         Some(match (exp_found.expected.unpack(), exp_found.found.unpack()) {\n-            (ty::TermKind::Ty(expected), ty::TermKind::Ty(found)) => self.cmp(expected, found),\n+            (ty::TermKind::Ty(expected), ty::TermKind::Ty(found)) => {\n+                let (mut exp, mut fnd) = self.cmp(expected, found);\n+                // Use the terminal width as the basis to determine when to compress the printed\n+                // out type, but give ourselves some leeway to avoid ending up creating a file for\n+                // a type that is somewhat shorter than the path we'd write to.\n+                let len = self.tcx.sess().diagnostic_width() + 40;\n+                let exp_s = exp.content();\n+                let fnd_s = fnd.content();\n+                let mut exp_p = None;\n+                let mut fnd_p = None;\n+                if exp_s.len() > len {\n+                    let (exp_s, exp_path) = self.tcx.short_ty_string(expected);\n+                    exp = DiagnosticStyledString::highlighted(exp_s);\n+                    exp_p = exp_path;\n+                }\n+                if fnd_s.len() > len {\n+                    let (fnd_s, fnd_path) = self.tcx.short_ty_string(found);\n+                    fnd = DiagnosticStyledString::highlighted(fnd_s);\n+                    fnd_p = fnd_path;\n+                }\n+                (exp, fnd, exp_p, fnd_p)\n+            }\n             _ => (\n                 DiagnosticStyledString::highlighted(exp_found.expected.to_string()),\n                 DiagnosticStyledString::highlighted(exp_found.found.to_string()),\n+                None,\n+                None,\n             ),\n         })\n     }\n@@ -2508,7 +2537,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: ty::error::ExpectedFound<T>,\n-    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+    ) -> Option<(DiagnosticStyledString, DiagnosticStyledString, Option<PathBuf>, Option<PathBuf>)>\n+    {\n         let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n@@ -2517,6 +2547,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         Some((\n             DiagnosticStyledString::highlighted(exp_found.expected.to_string()),\n             DiagnosticStyledString::highlighted(exp_found.found.to_string()),\n+            None,\n+            None,\n         ))\n     }\n \n@@ -2850,36 +2882,29 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n         debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n \n-        if let (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) =\n-            (&sup_origin, &sub_origin)\n+        if let infer::Subtype(ref sup_trace) = sup_origin\n+            && let infer::Subtype(ref sub_trace) = sub_origin\n+            && let Some((sup_expected, sup_found, _, _)) = self.values_str(sup_trace.values)\n+            && let Some((sub_expected, sub_found, _, _)) = self.values_str(sub_trace.values)\n+            && sub_expected == sup_expected\n+            && sub_found == sup_found\n         {\n-            debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n-            debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n-            debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);\n-            debug!(\"report_sub_sup_conflict: sub_trace.values={:?}\", sub_trace.values);\n-\n-            if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) =\n-                (self.values_str(sup_trace.values), self.values_str(sub_trace.values))\n-            {\n-                if sub_expected == sup_expected && sub_found == sup_found {\n-                    note_and_explain_region(\n-                        self.tcx,\n-                        &mut err,\n-                        \"...but the lifetime must also be valid for \",\n-                        sub_region,\n-                        \"...\",\n-                        None,\n-                    );\n-                    err.span_note(\n-                        sup_trace.cause.span,\n-                        &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n-                    );\n+            note_and_explain_region(\n+                self.tcx,\n+                &mut err,\n+                \"...but the lifetime must also be valid for \",\n+                sub_region,\n+                \"...\",\n+                None,\n+            );\n+            err.span_note(\n+                sup_trace.cause.span,\n+                &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n+            );\n \n-                    err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);\n-                    err.emit();\n-                    return;\n-                }\n-            }\n+            err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);\n+            err.emit();\n+            return;\n         }\n \n         self.note_region_origin(&mut err, &sup_origin);"}, {"sha": "d2dffa4a0b78e5ef1d75606e165b0a137fbf87e0", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -16,7 +16,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n                 span: trace.cause.span,\n                 requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n-                expected_found: self.values_str(trace.values),\n+                expected_found: self.values_str(trace.values).map(|(e, f, _, _)| (e, f)),\n             }\n             .add_to_diagnostic(err),\n             infer::Reborrow(span) => {"}, {"sha": "f808c1438bfc5b91b5b4bed4eaf5acbd7e0960b3", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -158,7 +158,7 @@ pub fn create_resolver(\n     sess: Lrc<Session>,\n     metadata_loader: Box<MetadataLoaderDyn>,\n     krate: &ast::Crate,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> BoxedResolver {\n     trace!(\"create_resolver\");\n     BoxedResolver::new(sess, move |sess, resolver_arenas| {\n@@ -171,7 +171,7 @@ pub fn register_plugins<'a>(\n     metadata_loader: &'a dyn MetadataLoader,\n     register_lints: impl Fn(&Session, &mut LintStore),\n     mut krate: ast::Crate,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> Result<(ast::Crate, LintStore)> {\n     krate = sess.time(\"attributes_injection\", || {\n         rustc_builtin_macros::cmdline_attrs::inject(\n@@ -228,19 +228,21 @@ fn pre_expansion_lint<'a>(\n     lint_store: &LintStore,\n     registered_tools: &RegisteredTools,\n     check_node: impl EarlyCheckNode<'a>,\n-    node_name: &str,\n+    node_name: Symbol,\n ) {\n-    sess.prof.generic_activity_with_arg(\"pre_AST_expansion_lint_checks\", node_name).run(|| {\n-        rustc_lint::check_ast_node(\n-            sess,\n-            true,\n-            lint_store,\n-            registered_tools,\n-            None,\n-            rustc_lint::BuiltinCombinedPreExpansionLintPass::new(),\n-            check_node,\n-        );\n-    });\n+    sess.prof.generic_activity_with_arg(\"pre_AST_expansion_lint_checks\", node_name.as_str()).run(\n+        || {\n+            rustc_lint::check_ast_node(\n+                sess,\n+                true,\n+                lint_store,\n+                registered_tools,\n+                None,\n+                rustc_lint::BuiltinCombinedPreExpansionLintPass::new(),\n+                check_node,\n+            );\n+        },\n+    );\n }\n \n // Cannot implement directly for `LintStore` due to trait coherence.\n@@ -254,7 +256,7 @@ impl LintStoreExpand for LintStoreExpandImpl<'_> {\n         node_id: ast::NodeId,\n         attrs: &[ast::Attribute],\n         items: &[rustc_ast::ptr::P<ast::Item>],\n-        name: &str,\n+        name: Symbol,\n     ) {\n         pre_expansion_lint(sess, self.0, registered_tools, (node_id, attrs, items), name);\n     }\n@@ -268,7 +270,7 @@ pub fn configure_and_expand(\n     sess: &Session,\n     lint_store: &LintStore,\n     mut krate: ast::Crate,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     resolver: &mut Resolver<'_>,\n ) -> Result<ast::Crate> {\n     trace!(\"configure_and_expand\");\n@@ -462,7 +464,7 @@ fn generated_output_paths(\n     sess: &Session,\n     outputs: &OutputFilenames,\n     exact_name: bool,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> Vec<PathBuf> {\n     let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.keys() {\n@@ -661,7 +663,7 @@ pub fn prepare_outputs(\n     compiler: &Compiler,\n     krate: &ast::Crate,\n     boxed_resolver: &RefCell<BoxedResolver>,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> Result<OutputFilenames> {\n     let _timer = sess.timer(\"prepare_outputs\");\n \n@@ -771,7 +773,7 @@ pub fn create_global_ctxt<'tcx>(\n     dep_graph: DepGraph,\n     resolver: Rc<RefCell<BoxedResolver>>,\n     outputs: OutputFilenames,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,"}, {"sha": "39e1f2204b002010176277dadfb531098f096730", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -17,6 +17,7 @@ use rustc_query_impl::Queries as TcxQueries;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n+use rustc_span::Symbol;\n use std::any::Any;\n use std::cell::{Ref, RefCell, RefMut};\n use std::rc::Rc;\n@@ -74,7 +75,7 @@ pub struct Queries<'tcx> {\n \n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n-    crate_name: Query<String>,\n+    crate_name: Query<Symbol>,\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n     expansion: Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n@@ -135,7 +136,7 @@ impl<'tcx> Queries<'tcx> {\n                 &*self.codegen_backend().metadata_loader(),\n                 self.compiler.register_lints.as_deref().unwrap_or_else(|| empty),\n                 krate,\n-                &crate_name,\n+                crate_name,\n             )?;\n \n             // Compute the dependency graph (in the background). We want to do\n@@ -149,7 +150,7 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn crate_name(&self) -> Result<&Query<String>> {\n+    pub fn crate_name(&self) -> Result<&Query<Symbol>> {\n         self.crate_name.compute(|| {\n             Ok({\n                 let parse_result = self.parse()?;\n@@ -165,18 +166,18 @@ impl<'tcx> Queries<'tcx> {\n     ) -> Result<&Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>> {\n         trace!(\"expansion\");\n         self.expansion.compute(|| {\n-            let crate_name = self.crate_name()?.peek().clone();\n+            let crate_name = *self.crate_name()?.peek();\n             let (krate, lint_store) = self.register_plugins()?.take();\n             let _timer = self.session().timer(\"configure_and_expand\");\n             let sess = self.session();\n             let mut resolver = passes::create_resolver(\n                 sess.clone(),\n                 self.codegen_backend().metadata_loader(),\n                 &krate,\n-                &crate_name,\n+                crate_name,\n             );\n             let krate = resolver.access(|resolver| {\n-                passes::configure_and_expand(sess, &lint_store, krate, &crate_name, resolver)\n+                passes::configure_and_expand(sess, &lint_store, krate, crate_name, resolver)\n             })?;\n             Ok((Lrc::new(krate), Rc::new(RefCell::new(resolver)), lint_store))\n         })\n@@ -201,20 +202,20 @@ impl<'tcx> Queries<'tcx> {\n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n         self.prepare_outputs.compute(|| {\n             let (krate, boxed_resolver, _) = &*self.expansion()?.peek();\n-            let crate_name = self.crate_name()?.peek();\n+            let crate_name = *self.crate_name()?.peek();\n             passes::prepare_outputs(\n                 self.session(),\n                 self.compiler,\n                 krate,\n                 &*boxed_resolver,\n-                &crate_name,\n+                crate_name,\n             )\n         })\n     }\n \n     pub fn global_ctxt(&'tcx self) -> Result<&Query<QueryContext<'tcx>>> {\n         self.global_ctxt.compute(|| {\n-            let crate_name = self.crate_name()?.peek().clone();\n+            let crate_name = *self.crate_name()?.peek();\n             let outputs = self.prepare_outputs()?.take();\n             let dep_graph = self.dep_graph()?.peek().clone();\n             let (krate, resolver, lint_store) = self.expansion()?.take();\n@@ -225,7 +226,7 @@ impl<'tcx> Queries<'tcx> {\n                 dep_graph,\n                 resolver,\n                 outputs,\n-                &crate_name,\n+                crate_name,\n                 &self.queries,\n                 &self.gcx,\n                 &self.arena,"}, {"sha": "efeaac8fe9a0f8523c1861ae8dd6fb6160af091b", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -245,15 +245,15 @@ impl<'a> CrateLoader<'a> {\n     pub fn new(\n         sess: &'a Session,\n         metadata_loader: Box<MetadataLoaderDyn>,\n-        local_crate_name: &str,\n+        local_crate_name: Symbol,\n     ) -> Self {\n         let mut stable_crate_ids = FxHashMap::default();\n         stable_crate_ids.insert(sess.local_stable_crate_id(), LOCAL_CRATE);\n \n         CrateLoader {\n             sess,\n             metadata_loader,\n-            local_crate_name: Symbol::intern(local_crate_name),\n+            local_crate_name,\n             cstore: CStore {\n                 // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n                 // order to make array indices in `metas` match with the\n@@ -1000,7 +1000,7 @@ impl<'a> CrateLoader<'a> {\n                 );\n                 let name = match orig_name {\n                     Some(orig_name) => {\n-                        validate_crate_name(self.sess, orig_name.as_str(), Some(item.span));\n+                        validate_crate_name(self.sess, orig_name, Some(item.span));\n                         orig_name\n                     }\n                     None => item.ident.name,"}, {"sha": "7601f6bd3221efaae15ef9b76f4c54366cd9628c", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -61,8 +61,7 @@ pub fn encode_and_write_metadata(tcx: TyCtxt<'_>) -> (EncodedMetadata, bool) {\n         .unwrap_or(MetadataKind::None);\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    let out_filename =\n-        filename_for_metadata(tcx.sess, crate_name.as_str(), tcx.output_filenames(()));\n+    let out_filename = filename_for_metadata(tcx.sess, crate_name, tcx.output_filenames(()));\n     // To avoid races with another rustc process scanning the output directory,\n     // we need to write the file somewhere else and atomically move it to its\n     // final destination, with an `fs::rename` call. In order for the rename to"}, {"sha": "614e0d012b35a672a0da08663ff8ae65a6d02d13", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -400,7 +400,7 @@ impl std::fmt::Display for NonDivergingIntrinsic<'_> {\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, Hash, HashStable)]\n #[rustc_pass_by_value]\n pub enum RetagKind {\n-    /// The initial retag when entering a function.\n+    /// The initial retag of arguments when entering a function.\n     FnEntry,\n     /// Retag preparing for a two-phase borrow.\n     TwoPhase,"}, {"sha": "b44bc14ec26c83bc75bb746d2d831e3634a3159a", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1285,7 +1285,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n         query_kinds: &'tcx [DepKindStruct<'tcx>],\n-        crate_name: &str,\n+        crate_name: Symbol,\n         output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n         let data_layout = s.target.parse_data_layout().unwrap_or_else(|err| {\n@@ -1325,7 +1325,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n-            crate_name: Symbol::intern(crate_name),\n+            crate_name,\n             data_layout,\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             output_filenames: Arc::new(output_filenames),"}, {"sha": "aa61c39b8d81931d9f78c15695641b5873464c47", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -986,23 +986,32 @@ fn foo(&self) -> Self::T { String::new() }\n     }\n \n     pub fn short_ty_string(self, ty: Ty<'tcx>) -> (String, Option<PathBuf>) {\n-        let length_limit = 50;\n-        let type_limit = 4;\n+        let width = self.sess.diagnostic_width();\n+        let length_limit = width.saturating_sub(30);\n+        let mut type_limit = 50;\n         let regular = FmtPrinter::new(self, hir::def::Namespace::TypeNS)\n             .pretty_print_type(ty)\n             .expect(\"could not write to `String`\")\n             .into_buffer();\n-        if regular.len() <= length_limit {\n+        if regular.len() <= width {\n             return (regular, None);\n         }\n-        let short = FmtPrinter::new_with_limit(\n-            self,\n-            hir::def::Namespace::TypeNS,\n-            rustc_session::Limit(type_limit),\n-        )\n-        .pretty_print_type(ty)\n-        .expect(\"could not write to `String`\")\n-        .into_buffer();\n+        let mut short;\n+        loop {\n+            // Look for the longest properly trimmed path that still fits in lenght_limit.\n+            short = FmtPrinter::new_with_limit(\n+                self,\n+                hir::def::Namespace::TypeNS,\n+                rustc_session::Limit(type_limit),\n+            )\n+            .pretty_print_type(ty)\n+            .expect(\"could not write to `String`\")\n+            .into_buffer();\n+            if short.len() <= length_limit || type_limit == 0 {\n+                break;\n+            }\n+            type_limit -= 1;\n+        }\n         if regular == short {\n             return (regular, None);\n         }"}, {"sha": "3d22035f0785ed57509c86c251355156d92d3665", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 13, "deletions": 40, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -10,16 +10,6 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub struct AddRetag;\n \n-/// Determines whether this place is \"stable\": Whether, if we evaluate it again\n-/// after the assignment, we can be sure to obtain the same place value.\n-/// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n-/// copies.  Data races are UB.)\n-fn is_stable(place: PlaceRef<'_>) -> bool {\n-    // Which place this evaluates to can change with any memory write,\n-    // so cannot assume deref to be stable.\n-    !place.has_deref()\n-}\n-\n /// Determine whether this type may contain a reference (or box), and thus needs retagging.\n /// We will only recurse `depth` times into Tuples/ADTs to bound the cost of this.\n fn may_contain_reference<'tcx>(ty: Ty<'tcx>, depth: u32, tcx: TyCtxt<'tcx>) -> bool {\n@@ -69,22 +59,10 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         let basic_blocks = body.basic_blocks.as_mut();\n         let local_decls = &body.local_decls;\n         let needs_retag = |place: &Place<'tcx>| {\n-            // FIXME: Instead of giving up for unstable places, we should introduce\n-            // a temporary and retag on that.\n-            is_stable(place.as_ref())\n+            !place.has_deref() // we're not eally interested in stores to \"outside\" locations, they are hard to keep track of anyway\n                 && may_contain_reference(place.ty(&*local_decls, tcx).ty, /*depth*/ 3, tcx)\n                 && !local_decls[place.local].is_deref_temp()\n         };\n-        let place_base_raw = |place: &Place<'tcx>| {\n-            // If this is a `Deref`, get the type of what we are deref'ing.\n-            if place.has_deref() {\n-                let ty = &local_decls[place.local].ty;\n-                ty.is_unsafe_ptr()\n-            } else {\n-                // Not a deref, and thus not raw.\n-                false\n-            }\n-        };\n \n         // PART 1\n         // Retag arguments at the beginning of the start block.\n@@ -108,7 +86,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         }\n \n         // PART 2\n-        // Retag return values of functions.  Also escape-to-raw the argument of `drop`.\n+        // Retag return values of functions.\n         // We collect the return destinations because we cannot mutate while iterating.\n         let returns = basic_blocks\n             .iter_mut()\n@@ -140,30 +118,25 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         }\n \n         // PART 3\n-        // Add retag after assignment.\n+        // Add retag after assignments where data \"enters\" this function: the RHS is behind a deref and the LHS is not.\n         for block_data in basic_blocks {\n             // We want to insert statements as we iterate.  To this end, we\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {\n-                    // Retag-as-raw after escaping to a raw pointer, if the referent\n-                    // is not already a raw pointer.\n-                    StatementKind::Assign(box (lplace, Rvalue::AddressOf(_, ref rplace)))\n-                        if !place_base_raw(rplace) =>\n-                    {\n-                        (RetagKind::Raw, lplace)\n-                    }\n                     // Retag after assignments of reference type.\n                     StatementKind::Assign(box (ref place, ref rvalue)) if needs_retag(place) => {\n-                        let kind = match rvalue {\n-                            Rvalue::Ref(_, borrow_kind, _)\n-                                if borrow_kind.allows_two_phase_borrow() =>\n-                            {\n-                                RetagKind::TwoPhase\n-                            }\n-                            _ => RetagKind::Default,\n+                        let add_retag = match rvalue {\n+                            // Ptr-creating operations already do their own internal retagging, no\n+                            // need to also add a retag statement.\n+                            Rvalue::Ref(..) | Rvalue::AddressOf(..) => false,\n+                            _ => true,\n                         };\n-                        (kind, *place)\n+                        if add_retag {\n+                            (RetagKind::Default, *place)\n+                        } else {\n+                            continue;\n+                        }\n                     }\n                     // Do nothing for the rest\n                     _ => continue,"}, {"sha": "69f96fe48ea2ff37365b16595428320b8927bac9", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -985,16 +985,6 @@ fn create_generator_drop_shim<'tcx>(\n         tcx.mk_ptr(ty::TypeAndMut { ty: gen_ty, mutbl: hir::Mutability::Mut }),\n         source_info,\n     );\n-    if tcx.sess.opts.unstable_opts.mir_emit_retag {\n-        // Alias tracking must know we changed the type\n-        body.basic_blocks_mut()[START_BLOCK].statements.insert(\n-            0,\n-            Statement {\n-                source_info,\n-                kind: StatementKind::Retag(RetagKind::Raw, Box::new(Place::from(SELF_ARG))),\n-            },\n-        )\n-    }\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function"}, {"sha": "16b7dcad17e77843e6f90a458b5b2441d755542c", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -177,16 +177,6 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     if ty.is_some() {\n         // The first argument (index 0), but add 1 for the return value.\n         let dropee_ptr = Place::from(Local::new(1 + 0));\n-        if tcx.sess.opts.unstable_opts.mir_emit_retag {\n-            // Function arguments should be retagged, and we make this one raw.\n-            body.basic_blocks_mut()[START_BLOCK].statements.insert(\n-                0,\n-                Statement {\n-                    source_info,\n-                    kind: StatementKind::Retag(RetagKind::Raw, Box::new(dropee_ptr)),\n-                },\n-            );\n-        }\n         let patch = {\n             let param_env = tcx.param_env_reveal_all_normalized(def_id);\n             let mut elaborator ="}, {"sha": "82f5d0f534a4bf76d6ca2e37bc7a83015abc92ca", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1196,7 +1196,7 @@ impl<'a> Resolver<'a> {\n     pub fn new(\n         session: &'a Session,\n         krate: &Crate,\n-        crate_name: &str,\n+        crate_name: Symbol,\n         metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a> {"}, {"sha": "9ae07cb005bd41b0db70ee91e528cf9db13bd741", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -111,7 +111,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.save_ctxt.lookup_def_id(ref_id)\n     }\n \n-    pub fn dump_crate_info(&mut self, name: &str) {\n+    pub fn dump_crate_info(&mut self, name: Symbol) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n             let source_file = Path::new(source_file);\n@@ -124,7 +124,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n         let data = CratePreludeData {\n             crate_id: GlobalCrateId {\n-                name: name.into(),\n+                name: name.to_string(),\n                 disambiguator: (self.tcx.sess.local_stable_crate_id().to_u64(), 0),\n             },\n             crate_root: crate_root.unwrap_or_else(|| \"<no source>\".to_owned()),\n@@ -135,7 +135,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.dumper.crate_prelude(data);\n     }\n \n-    pub fn dump_compilation_options(&mut self, input: &Input, crate_name: &str) {\n+    pub fn dump_compilation_options(&mut self, input: &Input, crate_name: Symbol) {\n         // Apply possible `remap-path-prefix` remapping to the input source file\n         // (and don't include remapping args anymore)\n         let (program, arguments) = {"}, {"sha": "7735c571310dd2c4e3018026b956d08e23334754", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -95,7 +95,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     /// Returns path to the compilation output (e.g., libfoo-12345678.rmeta)\n-    pub fn compilation_output(&self, crate_name: &str) -> PathBuf {\n+    pub fn compilation_output(&self, crate_name: Symbol) -> PathBuf {\n         let sess = &self.tcx.sess;\n         // Save-analysis is emitted per whole session, not per each crate type\n         let crate_type = sess.crate_types()[0];\n@@ -894,8 +894,8 @@ pub struct DumpHandler<'a> {\n }\n \n impl<'a> DumpHandler<'a> {\n-    pub fn new(odir: Option<&'a Path>, cratename: &str) -> DumpHandler<'a> {\n-        DumpHandler { odir, cratename: cratename.to_owned() }\n+    pub fn new(odir: Option<&'a Path>, cratename: Symbol) -> DumpHandler<'a> {\n+        DumpHandler { odir, cratename: cratename.to_string() }\n     }\n \n     fn output_file(&self, ctx: &SaveContext<'_>) -> (BufWriter<File>, PathBuf) {\n@@ -960,7 +960,7 @@ impl SaveHandler for CallbackHandler<'_> {\n \n pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n     tcx: TyCtxt<'tcx>,\n-    cratename: &str,\n+    cratename: Symbol,\n     input: &'l Input,\n     config: Option<Config>,\n     mut handler: H,"}, {"sha": "cbbba2252bf600b34b61a783c49c1bded1891f22", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -18,6 +18,7 @@ rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n smallvec = \"1.8.1\"\n+termize = \"0.1.1\"\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\""}, {"sha": "ee492f802a70c08d21fcd119dc81755cb307aa4e", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -129,10 +129,10 @@ pub struct FileIsNotWriteable<'a> {\n \n #[derive(Diagnostic)]\n #[diag(session_crate_name_does_not_match)]\n-pub struct CrateNameDoesNotMatch<'a> {\n+pub struct CrateNameDoesNotMatch {\n     #[primary_span]\n     pub span: Span,\n-    pub s: &'a str,\n+    pub s: Symbol,\n     pub name: Symbol,\n }\n \n@@ -151,11 +151,11 @@ pub struct CrateNameEmpty {\n \n #[derive(Diagnostic)]\n #[diag(session_invalid_character_in_create_name)]\n-pub struct InvalidCharacterInCrateName<'a> {\n+pub struct InvalidCharacterInCrateName {\n     #[primary_span]\n     pub span: Option<Span>,\n     pub character: char,\n-    pub crate_name: &'a str,\n+    pub crate_name: Symbol,\n }\n \n #[derive(Subdiagnostic)]"}, {"sha": "8ee3057de625ef3b08c9faad46c824ae9c685130", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -7,14 +7,14 @@ use crate::errors::{\n use crate::Session;\n use rustc_ast as ast;\n use rustc_span::symbol::sym;\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use std::path::{Path, PathBuf};\n \n pub fn out_filename(\n     sess: &Session,\n     crate_type: CrateType,\n     outputs: &OutputFilenames,\n-    crate_name: &str,\n+    crate_name: Symbol,\n ) -> PathBuf {\n     let default_filename = filename_for_input(sess, crate_type, crate_name, outputs);\n     let out_filename = outputs\n@@ -45,9 +45,9 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n-pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input) -> String {\n-    let validate = |s: String, span: Option<Span>| {\n-        validate_crate_name(sess, &s, span);\n+pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input) -> Symbol {\n+    let validate = |s: Symbol, span: Option<Span>| {\n+        validate_crate_name(sess, s, span);\n         s\n     };\n \n@@ -59,38 +59,39 @@ pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input)\n         sess.find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(ref s) = sess.opts.crate_name {\n+        let s = Symbol::intern(s);\n         if let Some((attr, name)) = attr_crate_name {\n-            if name.as_str() != s {\n+            if name != s {\n                 sess.emit_err(CrateNameDoesNotMatch { span: attr.span, s, name });\n             }\n         }\n-        return validate(s.clone(), None);\n+        return validate(s, None);\n     }\n \n     if let Some((attr, s)) = attr_crate_name {\n-        return validate(s.to_string(), Some(attr.span));\n+        return validate(s, Some(attr.span));\n     }\n     if let Input::File(ref path) = *input {\n         if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n             if s.starts_with('-') {\n                 sess.emit_err(CrateNameInvalid { s });\n             } else {\n-                return validate(s.replace('-', \"_\"), None);\n+                return validate(Symbol::intern(&s.replace('-', \"_\")), None);\n             }\n         }\n     }\n \n-    \"rust_out\".to_string()\n+    Symbol::intern(\"rust_out\")\n }\n \n-pub fn validate_crate_name(sess: &Session, s: &str, sp: Option<Span>) {\n+pub fn validate_crate_name(sess: &Session, s: Symbol, sp: Option<Span>) {\n     let mut err_count = 0;\n     {\n         if s.is_empty() {\n             err_count += 1;\n             sess.emit_err(CrateNameEmpty { span: sp });\n         }\n-        for c in s.chars() {\n+        for c in s.as_str().chars() {\n             if c.is_alphanumeric() {\n                 continue;\n             }\n@@ -109,7 +110,7 @@ pub fn validate_crate_name(sess: &Session, s: &str, sp: Option<Span>) {\n \n pub fn filename_for_metadata(\n     sess: &Session,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     outputs: &OutputFilenames,\n ) -> PathBuf {\n     // If the command-line specified the path, use that directly.\n@@ -132,7 +133,7 @@ pub fn filename_for_metadata(\n pub fn filename_for_input(\n     sess: &Session,\n     crate_type: CrateType,\n-    crate_name: &str,\n+    crate_name: Symbol,\n     outputs: &OutputFilenames,\n ) -> PathBuf {\n     let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);"}, {"sha": "4c049a8d628ef0e4336f111cb57c49fddbd3166d", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -952,6 +952,17 @@ impl Session {\n     ) -> Option<Symbol> {\n         attrs.iter().find(|at| at.has_name(name)).and_then(|at| at.value_str())\n     }\n+\n+    pub fn diagnostic_width(&self) -> usize {\n+        let default_column_width = 140;\n+        if let Some(width) = self.opts.diagnostic_width {\n+            width\n+        } else if self.opts.unstable_opts.ui_testing {\n+            default_column_width\n+        } else {\n+            termize::dimensions().map_or(default_column_width, |(w, _)| w)\n+        }\n+    }\n }\n \n // JUSTIFICATION: defn of the suggested wrapper fns"}, {"sha": "e62ce2c266aa04ca507edd377ab92672d193a336", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1,4 +1,4 @@\n-use crate::HashStableContext;\n+use crate::{HashStableContext, Symbol};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_data_structures::AtomicRef;\n@@ -149,9 +149,11 @@ impl StableCrateId {\n \n     /// Computes the stable ID for a crate with the given name and\n     /// `-Cmetadata` arguments.\n-    pub fn new(crate_name: &str, is_exe: bool, mut metadata: Vec<String>) -> StableCrateId {\n+    pub fn new(crate_name: Symbol, is_exe: bool, mut metadata: Vec<String>) -> StableCrateId {\n         let mut hasher = StableHasher::new();\n-        crate_name.hash(&mut hasher);\n+        // We must hash the string text of the crate name, not the id, as the id is not stable\n+        // across builds.\n+        crate_name.as_str().hash(&mut hasher);\n \n         // We don't want the stable crate ID to depend on the order of\n         // -C metadata arguments, so sort them:"}, {"sha": "06529c2e4039d768b198ecac3558adaf95cda447", "filename": "compiler/rustc_target/src/spec/wasm32_unknown_unknown.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -33,12 +33,6 @@ pub fn target() -> Target {\n             // For now this target just never has an entry symbol no matter the output\n             // type, so unconditionally pass this.\n             \"--no-entry\",\n-            // Rust really needs a way for users to specify exports and imports in\n-            // the source code. --export-dynamic isn't the right tool for this job,\n-            // however it does have the side effect of automatically exporting a lot\n-            // of symbols, which approximates what people want when compiling for\n-            // wasm32-unknown-unknown expect, so use it for now.\n-            \"--export-dynamic\",\n         ],\n     );\n     options.add_pre_link_args(\n@@ -48,7 +42,6 @@ pub fn target() -> Target {\n             // otherwise\n             \"--target=wasm32-unknown-unknown\",\n             \"-Wl,--no-entry\",\n-            \"-Wl,--export-dynamic\",\n         ],\n     );\n "}, {"sha": "ac7f579ebb5aa8bc8cd059b40d8dfab09de89dfb", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -4,12 +4,14 @@\n \n use crate::ascii;\n use crate::convert::TryInto;\n-use crate::error::Error;\n use crate::intrinsics;\n use crate::mem;\n use crate::ops::{Add, Mul, Sub};\n use crate::str::FromStr;\n \n+#[cfg(not(no_fp_fmt_parse))]\n+use crate::error::Error;\n+\n // Used because the `?` operator is not allowed in a const context.\n macro_rules! try_opt {\n     ($e:expr) => {"}, {"sha": "7a47cc6696a34908a0bea6f832dbf14e8b68087d", "filename": "library/std/src/sys/itron/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fcondvar.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -71,7 +71,7 @@ impl Condvar {\n             }\n         }\n \n-        unsafe { mutex.lock() };\n+        mutex.lock();\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n@@ -109,7 +109,7 @@ impl Condvar {\n         // we woke up because of `notify_*`.\n         let success = self.waiters.with_locked(|waiters| unsafe { !waiters.remove(waiter) });\n \n-        unsafe { mutex.lock() };\n+        mutex.lock();\n         success\n     }\n }"}, {"sha": "1f6cc41947602be1a7f81d443972de6e26b78d69", "filename": "library/std/src/sys/itron/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -72,7 +72,7 @@ pub(super) struct MutexGuard<'a>(&'a Mutex);\n impl<'a> MutexGuard<'a> {\n     #[inline]\n     pub(super) fn lock(x: &'a Mutex) -> Self {\n-        unsafe { x.lock() };\n+        x.lock();\n         Self(x)\n     }\n }"}, {"sha": "c2b3668087225cdc884a28d3a15660974c16b98d", "filename": "library/std/src/sys/itron/thread.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -11,18 +11,25 @@ use crate::{\n     ffi::CStr,\n     hint, io,\n     mem::ManuallyDrop,\n+    ptr::NonNull,\n     sync::atomic::{AtomicUsize, Ordering},\n     sys::thread_local_dtor::run_dtors,\n     time::Duration,\n };\n \n pub struct Thread {\n-    inner: ManuallyDrop<Box<ThreadInner>>,\n+    p_inner: NonNull<ThreadInner>,\n \n     /// The ID of the underlying task.\n     task: abi::ID,\n }\n \n+// Safety: There's nothing in `Thread` that ties it to the original creator. It\n+//         can be dropped by any threads.\n+unsafe impl Send for Thread {}\n+// Safety: `Thread` provides no methods that take `&self`.\n+unsafe impl Sync for Thread {}\n+\n /// State data shared between a parent thread and child thread. It's dropped on\n /// a transition to one of the final states.\n struct ThreadInner {\n@@ -90,8 +97,9 @@ impl Thread {\n         });\n \n         unsafe extern \"C\" fn trampoline(exinf: isize) {\n+            let p_inner: *mut ThreadInner = crate::ptr::from_exposed_addr_mut(exinf as usize);\n             // Safety: `ThreadInner` is alive at this point\n-            let inner = unsafe { &*(exinf as *const ThreadInner) };\n+            let inner = unsafe { &*p_inner };\n \n             // Safety: Since `trampoline` is called only once for each\n             //         `ThreadInner` and only `trampoline` touches `start`,\n@@ -119,13 +127,13 @@ impl Thread {\n                     // No one will ever join, so we'll ask the collector task to\n                     // delete the task.\n \n-                    // In this case, `inner`'s ownership has been moved to us,\n-                    // And we are responsible for dropping it. The acquire\n+                    // In this case, `*p_inner`'s ownership has been moved to\n+                    // us, and we are responsible for dropping it. The acquire\n                     // ordering is not necessary because the parent thread made\n                     // no memory access needing synchronization since the call\n                     // to `acre_tsk`.\n                     // Safety: See above.\n-                    let _ = unsafe { Box::from_raw(inner as *const _ as *mut ThreadInner) };\n+                    let _ = unsafe { Box::from_raw(p_inner) };\n \n                     // Safety: There are no pinned references to the stack\n                     unsafe { terminate_and_delete_current_task() };\n@@ -162,13 +170,14 @@ impl Thread {\n             }\n         }\n \n-        let inner_ptr = (&*inner) as *const ThreadInner;\n+        // Safety: `Box::into_raw` returns a non-null pointer\n+        let p_inner = unsafe { NonNull::new_unchecked(Box::into_raw(inner)) };\n \n         let new_task = ItronError::err_if_negative(unsafe {\n             abi::acre_tsk(&abi::T_CTSK {\n                 // Activate this task immediately\n                 tskatr: abi::TA_ACT,\n-                exinf: inner_ptr as abi::EXINF,\n+                exinf: p_inner.as_ptr().expose_addr() as abi::EXINF,\n                 // The entry point\n                 task: Some(trampoline),\n                 // Inherit the calling task's base priority\n@@ -180,7 +189,7 @@ impl Thread {\n         })\n         .map_err(|e| e.as_io_error())?;\n \n-        Ok(Self { inner: ManuallyDrop::new(inner), task: new_task })\n+        Ok(Self { p_inner, task: new_task })\n     }\n \n     pub fn yield_now() {\n@@ -197,8 +206,9 @@ impl Thread {\n         }\n     }\n \n-    pub fn join(mut self) {\n-        let inner = &*self.inner;\n+    pub fn join(self) {\n+        // Safety: `ThreadInner` is alive at this point\n+        let inner = unsafe { self.p_inner.as_ref() };\n         // Get the current task ID. Panicking here would cause a resource leak,\n         // so just abort on failure.\n         let current_task = task::current_task_id_aborting();\n@@ -243,8 +253,8 @@ impl Thread {\n         unsafe { terminate_and_delete_task(self.task) };\n \n         // In either case, we are responsible for dropping `inner`.\n-        // Safety: The contents of `self.inner` will not be accessed hereafter\n-        let _inner = unsafe { ManuallyDrop::take(&mut self.inner) };\n+        // Safety: The contents of `*p_inner` will not be accessed hereafter\n+        let _inner = unsafe { Box::from_raw(self.p_inner.as_ptr()) };\n \n         // Skip the destructor (because it would attempt to detach the thread)\n         crate::mem::forget(self);\n@@ -253,13 +263,16 @@ impl Thread {\n \n impl Drop for Thread {\n     fn drop(&mut self) {\n+        // Safety: `ThreadInner` is alive at this point\n+        let inner = unsafe { self.p_inner.as_ref() };\n+\n         // Detach the thread.\n-        match self.inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::Acquire) {\n+        match inner.lifecycle.swap(LIFECYCLE_DETACHED_OR_JOINED, Ordering::Acquire) {\n             LIFECYCLE_INIT => {\n                 // [INIT \u2192 DETACHED]\n                 // When the time comes, the child will figure out that no\n                 // one will ever join it.\n-                // The ownership of `self.inner` is moved to the child thread.\n+                // The ownership of `*p_inner` is moved to the child thread.\n                 // However, the release ordering is not necessary because we\n                 // made no memory access needing synchronization since the call\n                 // to `acre_tsk`.\n@@ -278,10 +291,9 @@ impl Drop for Thread {\n                 //         delete by entering the `FINISHED` state.\n                 unsafe { terminate_and_delete_task(self.task) };\n \n-                // Wwe are responsible for dropping `inner`.\n-                // Safety: The contents of `self.inner` will not be accessed\n-                //         hereafter\n-                unsafe { ManuallyDrop::drop(&mut self.inner) };\n+                // Wwe are responsible for dropping `*p_inner`.\n+                // Safety: The contents of `*p_inner` will not be accessed hereafter\n+                let _ = unsafe { Box::from_raw(self.p_inner.as_ptr()) };\n             }\n             _ => unsafe { hint::unreachable_unchecked() },\n         }"}, {"sha": "a862bb7870264e72ece3f8ee5c6bfc2a9ef0992f", "filename": "library/std/src/sys/solid/io.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fio.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -75,3 +75,7 @@ impl<'a> IoSliceMut<'a> {\n         unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n     }\n }\n+\n+pub fn is_terminal<T>(_: &T) -> bool {\n+    false\n+}"}, {"sha": "6135921f0b5a89a6694d7d151130255981423c73", "filename": "library/std/src/sys/solid/os.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fos.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1,7 +1,6 @@\n use super::unsupported;\n-use crate::convert::TryFrom;\n use crate::error::Error as StdError;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n+use crate::ffi::{CStr, OsStr, OsString};\n use crate::fmt;\n use crate::io;\n use crate::os::{"}, {"sha": "06f15bd121174eb5a195056bf12e75bfab390775", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-13/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-13%2FDockerfile?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -25,7 +25,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   zlib1g-dev \\\n   xz-utils \\\n   nodejs \\\n-\n+  \\\n # Install powershell so we can test x.ps1 on Linux\n     apt-transport-https software-properties-common && \\\n     curl -s \"https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb\" > packages-microsoft-prod.deb && \\"}, {"sha": "58c0c5db1a5d613a962e15ec93002e0e13b0a0bc", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2FDockerfile?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -15,7 +15,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   sudo \\\n   xz-utils \\\n   tidy \\\n-\n+  \\\n # Install dependencies for chromium browser\n   gconf-service \\\n   libasound2 \\"}, {"sha": "60149ff36064ecc3d87e433209e01328f5dc1843", "filename": "src/test/mir-opt/inline/inline_retag.bar.Inline.after.mir", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -38,9 +38,7 @@ fn bar() -> bool {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(bar, [], Some(promoted[1])) }\n         Retag(_10);                      // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         _4 = &(*_10);                    // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n-        Retag(_4);                       // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         _3 = &(*_4);                     // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n-        Retag(_3);                       // scope 1 at $DIR/inline_retag.rs:+2:7: +2:9\n         StorageLive(_6);                 // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         StorageLive(_7);                 // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _9 = const _;                    // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n@@ -49,9 +47,7 @@ fn bar() -> bool {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(bar, [], Some(promoted[0])) }\n         Retag(_9);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _7 = &(*_9);                     // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n-        Retag(_7);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         _6 = &(*_7);                     // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n-        Retag(_6);                       // scope 1 at $DIR/inline_retag.rs:+2:11: +2:14\n         Retag(_3);                       // scope 2 at $DIR/inline_retag.rs:16:8: 16:9\n         Retag(_6);                       // scope 2 at $DIR/inline_retag.rs:16:17: 16:18\n         StorageLive(_11);                // scope 2 at $DIR/inline_retag.rs:17:5: 17:7"}, {"sha": "7b69b3e07d6c56c6d5b201d3d3da7b29f79751c0", "filename": "src/test/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -68,9 +68,7 @@ fn array_casts() -> () {\n         StorageLive(_3);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         StorageLive(_4);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _4 = &mut _1;                    // scope 1 at $DIR/retag.rs:+2:13: +2:19\n-        Retag(_4);                       // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _3 = &raw mut (*_4);             // scope 1 at $DIR/retag.rs:+2:13: +2:19\n-        Retag([raw] _3);                 // scope 1 at $DIR/retag.rs:+2:13: +2:19\n         _2 = move _3 as *mut usize (Pointer(ArrayToPointer)); // scope 1 at $DIR/retag.rs:+2:13: +2:33\n         StorageDead(_3);                 // scope 1 at $DIR/retag.rs:+2:32: +2:33\n         StorageDead(_4);                 // scope 1 at $DIR/retag.rs:+2:33: +2:34\n@@ -96,9 +94,7 @@ fn array_casts() -> () {\n         StorageLive(_10);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         StorageLive(_11);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _11 = &_8;                       // scope 4 at $DIR/retag.rs:+6:13: +6:15\n-        Retag(_11);                      // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _10 = &raw const (*_11);         // scope 4 at $DIR/retag.rs:+6:13: +6:15\n-        Retag([raw] _10);                // scope 4 at $DIR/retag.rs:+6:13: +6:15\n         _9 = move _10 as *const usize (Pointer(ArrayToPointer)); // scope 4 at $DIR/retag.rs:+6:13: +6:31\n         StorageDead(_10);                // scope 4 at $DIR/retag.rs:+6:30: +6:31\n         StorageDead(_11);                // scope 4 at $DIR/retag.rs:+6:31: +6:32\n@@ -119,15 +115,13 @@ fn array_casts() -> () {\n         StorageDead(_17);                // scope 6 at $DIR/retag.rs:+7:33: +7:34\n         _15 = (*_16);                    // scope 6 at $DIR/retag.rs:+7:25: +7:34\n         _14 = &_15;                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_14);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _35 = const _;                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // + literal: Const { ty: &usize, val: Unevaluated(array_casts, [], Some(promoted[0])) }\n         Retag(_35);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _18 = &(*_35);                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_18);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Deinit(_13);                     // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         (_13.0: &usize) = move _14;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         (_13.1: &usize) = move _18;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -164,15 +158,11 @@ fn array_casts() -> () {\n         StorageLive(_30);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_31);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _31 = &(*_20);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_31);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _30 = &(*_31);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_30);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_32);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_33);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _33 = &(*_21);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_33);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _32 = &(*_33);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Retag(_32);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_34);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Deinit(_34);                     // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         discriminant(_34) = 0;           // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "14f297e948bec91b29791e7fce4c216c06c76458", "filename": "src/test/mir-opt/retag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -6,7 +6,6 @@ fn std::ptr::drop_in_place(_1: *mut Test) -> () {\n     let mut _3: ();                      // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n \n     bb0: {\n-        Retag([raw] _1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n         _2 = &mut (*_1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n         _3 = <Test as Drop>::drop(move _2) -> bb1; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n                                          // mir::Constant"}, {"sha": "9e5c119a2b24e3300dcca541b860c806c37efe34", "filename": "src/test/mir-opt/retag.main-{closure#0}.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main-%7Bclosure%230%7D.SimplifyCfg-elaborate-drops.after.mir?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -15,7 +15,6 @@ fn main::{closure#0}(_1: &[closure@main::{closure#0}], _2: &i32) -> &i32 {\n         _3 = _2;                         // scope 0 at $DIR/retag.rs:+1:18: +1:19\n         Retag(_3);                       // scope 0 at $DIR/retag.rs:+1:18: +1:19\n         _0 = &(*_2);                     // scope 1 at $DIR/retag.rs:+2:9: +2:10\n-        Retag(_0);                       // scope 1 at $DIR/retag.rs:+2:9: +2:10\n         StorageDead(_3);                 // scope 0 at $DIR/retag.rs:+3:5: +3:6\n         return;                          // scope 0 at $DIR/retag.rs:+3:6: +3:6\n     }"}, {"sha": "b853e450541729d82ad1b577e63cd67309746209", "filename": "src/test/mir-opt/retag.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -65,13 +65,10 @@ fn main() -> () {\n         Deinit(_5);                      // scope 1 at $DIR/retag.rs:+3:17: +3:24\n         (_5.0: i32) = const 0_i32;       // scope 1 at $DIR/retag.rs:+3:17: +3:24\n         _4 = &_5;                        // scope 1 at $DIR/retag.rs:+3:17: +3:36\n-        Retag(_4);                       // scope 1 at $DIR/retag.rs:+3:17: +3:36\n         StorageLive(_6);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         StorageLive(_7);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _7 = &mut _1;                    // scope 1 at $DIR/retag.rs:+3:29: +3:35\n-        Retag(_7);                       // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _6 = &mut (*_7);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n-        Retag([2phase] _6);              // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         _3 = Test::foo(move _4, move _6) -> [return: bb1, unwind: bb8]; // scope 1 at $DIR/retag.rs:+3:17: +3:36\n                                          // mir::Constant\n                                          // + span: $DIR/retag.rs:33:25: 33:28\n@@ -93,15 +90,13 @@ fn main() -> () {\n         _9 = move _3;                    // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         Retag(_9);                       // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         _8 = &mut (*_9);                 // scope 2 at $DIR/retag.rs:+4:19: +4:20\n-        Retag(_8);                       // scope 2 at $DIR/retag.rs:+4:19: +4:20\n         StorageDead(_9);                 // scope 2 at $DIR/retag.rs:+4:22: +4:23\n         StorageLive(_10);                // scope 3 at $DIR/retag.rs:+5:13: +5:14\n         _10 = move _8;                   // scope 3 at $DIR/retag.rs:+5:17: +5:18\n         Retag(_10);                      // scope 3 at $DIR/retag.rs:+5:17: +5:18\n         StorageLive(_11);                // scope 4 at $DIR/retag.rs:+7:13: +7:15\n         StorageLive(_12);                // scope 4 at $DIR/retag.rs:+7:18: +7:29\n         _12 = &raw mut (*_10);           // scope 4 at $DIR/retag.rs:+7:18: +7:19\n-        Retag([raw] _12);                // scope 4 at $DIR/retag.rs:+7:18: +7:19\n         _11 = _12;                       // scope 4 at $DIR/retag.rs:+7:18: +7:29\n         StorageDead(_12);                // scope 4 at $DIR/retag.rs:+7:29: +7:30\n         _2 = const ();                   // scope 1 at $DIR/retag.rs:+2:5: +8:6\n@@ -122,9 +117,7 @@ fn main() -> () {\n         StorageLive(_17);                // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         StorageLive(_18);                // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _18 = &_1;                       // scope 6 at $DIR/retag.rs:+15:16: +15:18\n-        Retag(_18);                      // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _17 = &(*_18);                   // scope 6 at $DIR/retag.rs:+15:16: +15:18\n-        Retag(_17);                      // scope 6 at $DIR/retag.rs:+15:16: +15:18\n         _15 = move _16(move _17) -> bb3; // scope 6 at $DIR/retag.rs:+15:14: +15:19\n     }\n \n@@ -139,7 +132,6 @@ fn main() -> () {\n         Deinit(_21);                     // scope 7 at $DIR/retag.rs:+18:5: +18:12\n         (_21.0: i32) = const 0_i32;      // scope 7 at $DIR/retag.rs:+18:5: +18:12\n         _20 = &_21;                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n-        Retag(_20);                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_22);                // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         StorageLive(_23);                // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _28 = const _;                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n@@ -148,9 +140,7 @@ fn main() -> () {\n                                          // + literal: Const { ty: &i32, val: Unevaluated(main, [], Some(promoted[0])) }\n         Retag(_28);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _23 = &(*_28);                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n-        Retag(_23);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _22 = &(*_23);                   // scope 7 at $DIR/retag.rs:+18:21: +18:23\n-        Retag(_22);                      // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         _19 = Test::foo_shr(move _20, move _22) -> [return: bb4, unwind: bb7]; // scope 7 at $DIR/retag.rs:+18:5: +18:24\n                                          // mir::Constant\n                                          // + span: $DIR/retag.rs:48:13: 48:20\n@@ -171,7 +161,6 @@ fn main() -> () {\n         StorageLive(_25);                // scope 7 at $DIR/retag.rs:+21:9: +21:11\n         StorageLive(_26);                // scope 7 at $DIR/retag.rs:+21:14: +21:28\n         _26 = &raw const (*_15);         // scope 7 at $DIR/retag.rs:+21:14: +21:16\n-        Retag([raw] _26);                // scope 7 at $DIR/retag.rs:+21:14: +21:16\n         _25 = _26;                       // scope 7 at $DIR/retag.rs:+21:14: +21:28\n         StorageDead(_26);                // scope 7 at $DIR/retag.rs:+21:28: +21:29\n         StorageLive(_27);                // scope 8 at $DIR/retag.rs:+23:5: +23:18"}, {"sha": "4b50205fa8081ce7e284517a96d9c43f4a013bef", "filename": "src/test/mir-opt/retag.{impl#0}-foo.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.%7Bimpl%230%7D-foo.SimplifyCfg-elaborate-drops.after.mir?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -11,9 +11,7 @@ fn <impl at $DIR/retag.rs:12:1: 12:10>::foo(_1: &Test, _2: &mut i32) -> &mut i32\n         Retag([fn entry] _2);            // scope 0 at $DIR/retag.rs:+0:23: +0:24\n         StorageLive(_3);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         _3 = &mut (*_2);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n-        Retag(_3);                       // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         _0 = &mut (*_3);                 // scope 0 at $DIR/retag.rs:+1:9: +1:10\n-        Retag(_0);                       // scope 0 at $DIR/retag.rs:+1:9: +1:10\n         StorageDead(_3);                 // scope 0 at $DIR/retag.rs:+2:5: +2:6\n         return;                          // scope 0 at $DIR/retag.rs:+2:6: +2:6\n     }"}, {"sha": "3aa57d58908bb7b30d61a7eff9ffff9e7af95eff", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -67,7 +67,7 @@ impl CodegenBackend for TheBackend {\n             if crate_type != CrateType::Rlib {\n                 sess.fatal(&format!(\"Crate type is {:?}\", crate_type));\n             }\n-            let output_name = out_filename(sess, crate_type, &outputs, &*crate_name.as_str());\n+            let output_name = out_filename(sess, crate_type, &outputs, crate_name);\n             let mut out_file = ::std::fs::File::create(output_name).unwrap();\n             write!(out_file, \"This has been \\\"compiled\\\" successfully.\").unwrap();\n         }"}, {"sha": "ae8e0aed0cc53b936f302c5d4b4ac1c6384bf099", "filename": "src/test/ui/async-await/in-trait/nested-rpit.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fnested-rpit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fnested-rpit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fnested-rpit.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+use std::marker::PhantomData;\n+\n+trait Lockable<K, V> {\n+    async fn lock_all_entries(&self) -> impl Future<Output = Guard<'_>>;\n+}\n+\n+struct Guard<'a>(PhantomData<&'a ()>);\n+\n+fn main() {}"}, {"sha": "3fd7a7110fd973191eb0fb6ab0bef6fc09a4cf24", "filename": "src/test/ui/diagnostic-width/long-E0308.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -0,0 +1,86 @@\n+// compile-flags: --diagnostic-width=60\n+// normalize-stderr-test: \"long-type-\\d+\" -> \"long-type-hash\"\n+\n+struct Atype<T, K>(T, K);\n+struct Btype<T, K>(T, K);\n+struct Ctype<T, K>(T, K);\n+\n+fn main() {\n+    let x: Atype<\n+      Btype<\n+        Ctype<\n+          Atype<\n+            Btype<\n+              Ctype<\n+                Atype<\n+                  Btype<\n+                    Ctype<i32, i32>,\n+                    i32\n+                  >,\n+                  i32\n+                >,\n+                i32\n+              >,\n+              i32\n+            >,\n+            i32\n+          >,\n+          i32\n+        >,\n+        i32\n+      >,\n+      i32\n+    > = Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+        Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+            Ok(\"\")\n+        ))))))))))))))))))))))))))))))\n+    ))))))))))))))))))))))))))))));\n+    //~^^^^^ ERROR E0308\n+\n+    let _ = Some(Ok(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(\n+        Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(\n+            Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(Some(\n+                Some(Some(Some(Some(Some(Some(Some(Some(Some(\"\")))))))))\n+            )))))))))))))))))\n+        ))))))))))))))))))\n+    ))))))))))))))))) == Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+        Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+            Ok(Ok(Ok(Ok(Ok(Ok(Ok(\"\")))))))\n+        ))))))))))))))))))))))))))))))\n+    ))))))))))))))))))))))));\n+    //~^^^^^ ERROR E0308\n+\n+    let x: Atype<\n+      Btype<\n+        Ctype<\n+          Atype<\n+            Btype<\n+              Ctype<\n+                Atype<\n+                  Btype<\n+                    Ctype<i32, i32>,\n+                    i32\n+                  >,\n+                  i32\n+                >,\n+                i32\n+              >,\n+              i32\n+            >,\n+            i32\n+          >,\n+          i32\n+        >,\n+        i32\n+      >,\n+      i32\n+    > = ();\n+    //~^ ERROR E0308\n+\n+    let _: () = Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+        Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(\n+            Ok(Ok(Ok(Ok(Ok(Ok(Ok(\"\")))))))\n+        ))))))))))))))))))))))))))))))\n+    ))))))))))))))))))))))));\n+    //~^^^^^ ERROR E0308\n+}"}, {"sha": "487ab23a1c100ea37ce18f68b701a09b563454a7", "filename": "src/test/ui/diagnostic-width/long-E0308.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdiagnostic-width%2Flong-E0308.stderr?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -0,0 +1,80 @@\n+error[E0308]: mismatched types\n+  --> $DIR/long-E0308.rs:33:9\n+   |\n+LL |        let x: Atype<\n+   |  _____________-\n+LL | |        Btype<\n+LL | |          Ctype<\n+LL | |            Atype<\n+...  |\n+LL | |        i32\n+LL | |      > = Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok...\n+   | | _____-___^\n+   | ||_____|\n+   |  |     expected due to this\n+LL |  |         Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok...\n+LL |  |             Ok(\"\")\n+LL |  |         ))))))))))))))))))))))))))))))\n+LL |  |     ))))))))))))))))))))))))))))));\n+   |  |__________________________________^ expected struct `Atype`, found enum `Result`\n+   |\n+   = note: expected struct `Atype<Btype<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+                found enum `Result<Result<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+\n+error[E0308]: mismatched types\n+  --> $DIR/long-E0308.rs:46:26\n+   |\n+LL |       ))))))))))))))))) == Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(O...\n+   |  __________________________^\n+LL | |         Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(...\n+LL | |             Ok(Ok(Ok(Ok(Ok(Ok(Ok(\"\")))))))\n+LL | |         ))))))))))))))))))))))))))))))\n+LL | |     ))))))))))))))))))))))));\n+   | |____________________________^ expected enum `Option`, found enum `Result`\n+   |\n+   = note: expected enum `Option<Result<..., ...>>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+              found enum `Result<Result<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+\n+error[E0308]: mismatched types\n+  --> $DIR/long-E0308.rs:77:9\n+   |\n+LL |       let x: Atype<\n+   |  ____________-\n+LL | |       Btype<\n+LL | |         Ctype<\n+LL | |           Atype<\n+...  |\n+LL | |       i32\n+LL | |     > = ();\n+   | |     -   ^^ expected struct `Atype`, found `()`\n+   | |_____|\n+   |       expected due to this\n+   |\n+   = note: expected struct `Atype<Btype<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+           found unit type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/long-E0308.rs:80:17\n+   |\n+LL |       let _: () = Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(O...\n+   |  ____________--___^\n+   | |            |\n+   | |            expected due to this\n+LL | |         Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(Ok(...\n+LL | |             Ok(Ok(Ok(Ok(Ok(Ok(Ok(\"\")))))))\n+LL | |         ))))))))))))))))))))))))))))))\n+LL | |     ))))))))))))))))))))))));\n+   | |____________________________^ expected `()`, found enum `Result`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<Result<..., ...>, ...>`\n+           the full type name has been written to '$TEST_BUILD_DIR/diagnostic-width/long-E0308/long-E0308.long-type-hash.txt'\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "451a683ac8a6effeec6de3067304913763e77885", "filename": "src/test/ui/error-codes/E0275.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -5,7 +5,7 @@ LL | impl<T> Foo for T where Bar<T>: Foo {}\n    |                                 ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`E0275`)\n-note: required for `Bar<Bar<Bar<Bar<Bar<Bar<...>>>>>>` to implement `Foo`\n+note: required for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<...>>>>>>>>>>>>>>>>>>>>>` to implement `Foo`\n   --> $DIR/E0275.rs:6:9\n    |\n LL | impl<T> Foo for T where Bar<T>: Foo {}"}, {"sha": "760dcb615c87903d522d89eb322e47139b919b82", "filename": "src/test/ui/feature-gates/feature-gate-impl_trait_in_fn_trait_return.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_fn_trait_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_fn_trait_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_fn_trait_return.stderr?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -3,12 +3,18 @@ error[E0562]: `impl Trait` only allowed in function and inherent method return t\n    |\n LL | fn f() -> impl Fn() -> impl Sized { || () }\n    |                        ^^^^^^^^^^\n+   |\n+   = note: see issue #99697 <https://github.com/rust-lang/rust/issues/99697> for more information\n+   = help: add `#![feature(impl_trait_in_fn_trait_return)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in `Fn` trait return\n   --> $DIR/feature-gate-impl_trait_in_fn_trait_return.rs:3:32\n    |\n LL | fn g() -> &'static dyn Fn() -> impl Sized { &|| () }\n    |                                ^^^^^^^^^^\n+   |\n+   = note: see issue #99697 <https://github.com/rust-lang/rust/issues/99697> for more information\n+   = help: add `#![feature(impl_trait_in_fn_trait_return)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n "}, {"sha": "78df445972c94d34102044a095a0c10edc600cb4", "filename": "src/test/ui/issues/issue-20413.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -14,7 +14,7 @@ LL | impl<T> Foo for T where NoData<T>: Foo {\n    |                                    ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_20413`)\n-note: required for `NoData<NoData<NoData<NoData<NoData<NoData<...>>>>>>` to implement `Foo`\n+note: required for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<...>>>>>>>>>>>>>` to implement `Foo`\n   --> $DIR/issue-20413.rs:9:9\n    |\n LL | impl<T> Foo for T where NoData<T>: Foo {\n@@ -30,13 +30,13 @@ LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n    |                                          ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_20413`)\n-note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>` to implement `Bar`\n+note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>` to implement `Bar`\n   --> $DIR/issue-20413.rs:28:9\n    |\n LL | impl<T> Bar for T where EvenLessData<T>: Baz {\n    |         ^^^     ^\n    = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n-note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>` to implement `Baz`\n+note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>` to implement `Baz`\n   --> $DIR/issue-20413.rs:35:9\n    |\n LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n@@ -52,13 +52,13 @@ LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n    |                                          ^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_20413`)\n-note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>` to implement `Baz`\n+note: required for `EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>>` to implement `Baz`\n   --> $DIR/issue-20413.rs:35:9\n    |\n LL | impl<T> Baz for T where AlmostNoData<T>: Bar {\n    |         ^^^     ^\n    = note: the full type name has been written to '$TEST_BUILD_DIR/issues/issue-20413/issue-20413.long-type-hash.txt'\n-note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<...>>>>>>` to implement `Bar`\n+note: required for `AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<EvenLessData<AlmostNoData<...>>>>>>>` to implement `Bar`\n   --> $DIR/issue-20413.rs:28:9\n    |\n LL | impl<T> Bar for T where EvenLessData<T>: Baz {"}, {"sha": "1f50b06a0e4c553fc5b39160878ca3bd22c0d560", "filename": "src/test/ui/issues/issue-23122-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -5,7 +5,7 @@ LL |     type Next = <GetNext<T::Next> as Next>::Next;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_23122_2`)\n-note: required for `GetNext<<<<<<... as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>` to implement `Next`\n+note: required for `GetNext<<<<<<<... as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>` to implement `Next`\n   --> $DIR/issue-23122-2.rs:10:15\n    |\n LL | impl<T: Next> Next for GetNext<T> {"}, {"sha": "dde8ad1b6b327615fe66c1c2c75a644275dd3477", "filename": "src/test/ui/recursion/issue-83150.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Frecursion%2Fissue-83150.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Frecursion%2Fissue-83150.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-83150.stderr?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -12,7 +12,7 @@ LL |     func(&mut iter.map(|x| x + 1))\n error[E0275]: overflow evaluating the requirement `Map<&mut Map<&mut Map<&mut Map<..., ...>, ...>, ...>, ...>: Iterator`\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_83150`)\n-   = note: required for `&mut Map<&mut Map<&mut Map<..., ...>, ...>, ...>` to implement `Iterator`\n+   = note: required for `&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<&mut Map<..., ...>, ...>, ...>, ...>, ...>, ...>, ...>` to implement `Iterator`\n    = note: the full type name has been written to '$TEST_BUILD_DIR/recursion/issue-83150/issue-83150.long-type-hash.txt'\n \n error: aborting due to previous error; 1 warning emitted"}, {"sha": "fd71248d9cb458fc53300679e1d72ea404b778e1", "filename": "src/test/ui/regions/issue-102374.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fregions%2Fissue-102374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fregions%2Fissue-102374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-102374.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1,3 +1,4 @@\n+// normalize-stderr-test: \"long-type-\\d+\" -> \"long-type-hash\"\n use std::cell::Cell;\n \n #[rustfmt::skip]"}, {"sha": "157850693ab506ad96fd63ebed1062efe6ac83c5", "filename": "src/test/ui/regions/issue-102374.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fregions%2Fissue-102374.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Fregions%2Fissue-102374.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-102374.stderr?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1,13 +1,14 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-102374.rs:16:5\n+  --> $DIR/issue-102374.rs:17:5\n    |\n LL | ) -> i32 {\n    |      --- expected `i32` because of return type\n LL |     f\n    |     ^ expected `i32`, found fn pointer\n    |\n    = note:    expected type `i32`\n-           found fn pointer `for<'z1, 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z, 'z0> fn(Cell<(&'z1 i32, &'a i32, &'b i32, &'c i32, &'d i32, &'e i32, &'f i32, &'g i32, &'h i32, &'i i32, &'j i32, &'k i32, &'l i32, &'m i32, &'n i32, &'o i32, &'p i32, &'q i32, &'r i32, &'s i32, &'t i32, &'u i32, &'v i32, &'w i32, &'x i32, &'y i32, &'z i32, &'z0 i32)>)`\n+           found fn pointer `for<'z1, 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z, 'z0> fn(Cell<...>)`\n+           the full type name has been written to '$TEST_BUILD_DIR/regions/issue-102374/issue-102374.long-type-hash.txt'\n \n error: aborting due to previous error\n "}, {"sha": "1f18c5daf66e3dd2c0944da6fe3f8becd61e2552", "filename": "src/test/ui/traits/issue-91949-hangs-on-recursion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftest%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-91949-hangs-on-recursion.stderr?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -17,7 +17,7 @@ error[E0275]: overflow evaluating the requirement `(): Sized`\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"512\"]` attribute to your crate (`issue_91949_hangs_on_recursion`)\n    = note: required for `std::iter::Empty<()>` to implement `Iterator`\n    = note: 171 redundant requirements hidden\n-   = note: required for `IteratorOfWrapped<(), Map<IteratorOfWrapped<(), Map<..., ...>>, ...>>` to implement `Iterator`\n+   = note: required for `IteratorOfWrapped<(), Map<IteratorOfWrapped<(), Map<IteratorOfWrapped<(), Map<..., ...>>, ...>>, ...>>` to implement `Iterator`\n    = note: the full type name has been written to '$TEST_BUILD_DIR/traits/issue-91949-hangs-on-recursion/issue-91949-hangs-on-recursion.long-type-hash.txt'\n \n error: aborting due to previous error; 1 warning emitted"}, {"sha": "f896a337f42caeff8afbbcc98399d6f7c5df0f02", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -11,7 +11,6 @@ use rustc_target::abi::Size;\n \n use crate::*;\n pub mod stacked_borrows;\n-use stacked_borrows::diagnostics::RetagCause;\n \n pub type CallId = NonZeroU64;\n \n@@ -265,11 +264,19 @@ impl GlobalStateInner {\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+    fn retag_ptr_value(&mut self, kind: RetagKind, val: &ImmTy<'tcx, Provenance>) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n-            BorrowTrackerMethod::StackedBorrows => this.sb_retag(kind, place),\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag_ptr_value(kind, val),\n+        }\n+    }\n+\n+    fn retag_place_contents(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag_place_contents(kind, place),\n         }\n     }\n "}, {"sha": "24b3489e0d1d67e61503017feb699a39bfc0b7f7", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -459,10 +459,10 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             Operation::Dealloc(_) => format!(\" due to deallocation\"),\n             Operation::Access(AccessOp { kind, tag, .. }) =>\n                 format!(\" due to {kind:?} access for {tag:?}\"),\n-            Operation::Retag(RetagOp { orig_tag, permission, .. }) => {\n+            Operation::Retag(RetagOp { orig_tag, permission, new_tag, .. }) => {\n                 let permission = permission\n                     .expect(\"start_grant should set the current permission before popping a tag\");\n-                format!(\" due to {permission:?} retag from {orig_tag:?}\")\n+                format!(\" due to {permission:?} retag from {orig_tag:?} (that retag created {new_tag:?})\")\n             }\n         };\n "}, {"sha": "ffbc00864022f4c642d6d9ec6c41f75628d874e4", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 204, "deletions": 165, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -1,9 +1,13 @@\n //! Implements \"Stacked Borrows\".  See <https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md>\n //! for further information.\n \n+pub mod diagnostics;\n+mod item;\n+mod stack;\n+\n use log::trace;\n use std::cmp;\n-use std::fmt::{self, Write};\n+use std::fmt::Write;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::mir::{Mutability, RetagKind};\n@@ -15,15 +19,13 @@ use rustc_target::abi::{Abi, Size};\n \n use crate::borrow_tracker::{\n     stacked_borrows::diagnostics::{AllocHistory, DiagnosticCx, DiagnosticCxBuilder, TagHistory},\n-    AccessKind, GlobalStateInner, ProtectorKind, RetagCause, RetagFields,\n+    AccessKind, GlobalStateInner, ProtectorKind, RetagFields,\n };\n use crate::*;\n \n-mod item;\n+use diagnostics::RetagCause;\n pub use item::{Item, Permission};\n-mod stack;\n pub use stack::Stack;\n-pub mod diagnostics;\n \n pub type AllocState = Stacks;\n \n@@ -40,30 +42,104 @@ pub struct Stacks {\n     modified_since_last_gc: bool,\n }\n \n-/// Indicates which kind of reference is being created.\n-/// Used by high-level `reborrow` to compute which permissions to grant to the\n-/// new pointer.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-enum RefKind {\n-    /// `Box`.\n-    Box,\n-    /// `&mut`.\n-    Unique { two_phase: bool },\n-    /// `&` with or without interior mutability.\n-    Shared,\n-    /// `*mut`/`*const` (raw pointers).\n-    Raw { mutable: bool },\n+/// Indicates which permissions to grant to the retagged pointer.\n+#[derive(Clone, Debug)]\n+enum NewPermission {\n+    Uniform {\n+        perm: Permission,\n+        access: Option<AccessKind>,\n+        protector: Option<ProtectorKind>,\n+    },\n+    FreezeSensitive {\n+        freeze_perm: Permission,\n+        freeze_access: Option<AccessKind>,\n+        freeze_protector: Option<ProtectorKind>,\n+        nonfreeze_perm: Permission,\n+        nonfreeze_access: Option<AccessKind>,\n+        // nonfreeze_protector must always be None\n+    },\n }\n \n-impl fmt::Display for RefKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+impl NewPermission {\n+    /// A key function: determine the permissions to grant at a retag for the given kind of\n+    /// reference/pointer.\n+    fn from_ref_ty<'tcx>(\n+        ty: ty::Ty<'tcx>,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Self {\n+        let protector = (kind == RetagKind::FnEntry).then_some(ProtectorKind::StrongProtector);\n+        match ty.kind() {\n+            ty::Ref(_, pointee, Mutability::Mut) => {\n+                if kind == RetagKind::TwoPhase {\n+                    // We mostly just give up on 2phase-borrows, and treat these exactly like raw pointers.\n+                    assert!(protector.is_none()); // RetagKind can't be both FnEntry and TwoPhase.\n+                    NewPermission::Uniform {\n+                        perm: Permission::SharedReadWrite,\n+                        access: None,\n+                        protector: None,\n+                    }\n+                } else if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n+                    // A regular full mutable reference.\n+                    NewPermission::Uniform {\n+                        perm: Permission::Unique,\n+                        access: Some(AccessKind::Write),\n+                        protector,\n+                    }\n+                } else {\n+                    NewPermission::Uniform {\n+                        perm: Permission::SharedReadWrite,\n+                        // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n+                        // should do fake accesses here. But then we run into\n+                        // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n+                        // we don't do that.\n+                        access: None,\n+                        protector,\n+                    }\n+                }\n+            }\n+            ty::RawPtr(ty::TypeAndMut { mutbl: Mutability::Mut, .. }) => {\n+                assert!(protector.is_none()); // RetagKind can't be both FnEntry and Raw.\n+                // Mutable raw pointer. No access, not protected.\n+                NewPermission::Uniform {\n+                    perm: Permission::SharedReadWrite,\n+                    access: None,\n+                    protector: None,\n+                }\n+            }\n+            ty::Ref(_, _pointee, Mutability::Not) => {\n+                NewPermission::FreezeSensitive {\n+                    freeze_perm: Permission::SharedReadOnly,\n+                    freeze_access: Some(AccessKind::Read),\n+                    freeze_protector: protector,\n+                    nonfreeze_perm: Permission::SharedReadWrite,\n+                    // Inside UnsafeCell, this does *not* count as an access, as there\n+                    // might actually be mutable references further up the stack that\n+                    // we have to keep alive.\n+                    nonfreeze_access: None,\n+                    // We do not protect inside UnsafeCell.\n+                    // This fixes https://github.com/rust-lang/rust/issues/55005.\n+                }\n+            }\n+            ty::RawPtr(ty::TypeAndMut { mutbl: Mutability::Not, .. }) => {\n+                assert!(protector.is_none()); // RetagKind can't be both FnEntry and Raw.\n+                // `*const T`, when freshly created, are read-only in the frozen part.\n+                NewPermission::FreezeSensitive {\n+                    freeze_perm: Permission::SharedReadOnly,\n+                    freeze_access: Some(AccessKind::Read),\n+                    freeze_protector: None,\n+                    nonfreeze_perm: Permission::SharedReadWrite,\n+                    nonfreeze_access: None,\n+                }\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn protector(&self) -> Option<ProtectorKind> {\n         match self {\n-            RefKind::Box => write!(f, \"Box\"),\n-            RefKind::Unique { two_phase: false } => write!(f, \"unique reference\"),\n-            RefKind::Unique { two_phase: true } => write!(f, \"unique reference (two-phase)\"),\n-            RefKind::Shared => write!(f, \"shared reference\"),\n-            RefKind::Raw { mutable: true } => write!(f, \"raw (mutable) pointer\"),\n-            RefKind::Raw { mutable: false } => write!(f, \"raw (constant) pointer\"),\n+            NewPermission::Uniform { protector, .. } => *protector,\n+            NewPermission::FreezeSensitive { freeze_protector, .. } => *freeze_protector,\n         }\n     }\n }\n@@ -518,10 +594,9 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         &mut self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         size: Size,\n-        kind: RefKind,\n-        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n+        new_perm: NewPermission,\n         new_tag: BorTag,\n-        protect: Option<ProtectorKind>,\n+        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n \n@@ -532,20 +607,16 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n             let ty = place.layout.ty;\n             if global.tracked_pointer_tags.contains(&new_tag) {\n-                let mut kind_str = format!(\"{kind}\");\n-                match kind {\n-                    RefKind::Unique { two_phase: false }\n-                        if !ty.is_unpin(*this.tcx, this.param_env()) =>\n-                    {\n-                        write!(kind_str, \" (!Unpin pointee type {ty})\").unwrap()\n-                    },\n-                    RefKind::Shared\n-                        if !ty.is_freeze(*this.tcx, this.param_env()) =>\n-                    {\n-                        write!(kind_str, \" (!Freeze pointee type {ty})\").unwrap()\n-                    },\n-                    _ => write!(kind_str, \" (pointee type {ty})\").unwrap(),\n-                };\n+                let mut kind_str = String::new();\n+                match new_perm {\n+                    NewPermission::Uniform { perm, .. } =>\n+                        write!(kind_str, \"{perm:?} permission\").unwrap(),\n+                    NewPermission::FreezeSensitive { freeze_perm, .. } if ty.is_freeze(*this.tcx, this.param_env()) =>\n+                        write!(kind_str, \"{freeze_perm:?} permission\").unwrap(),\n+                    NewPermission::FreezeSensitive { freeze_perm, nonfreeze_perm, .. }  =>\n+                        write!(kind_str, \"{freeze_perm:?}/{nonfreeze_perm:?} permission for frozen/non-frozen parts\").unwrap(),\n+                }\n+                write!(kind_str, \" (pointee type {ty})\").unwrap();\n                 this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n                     new_tag.inner(),\n                     Some(kind_str),\n@@ -579,7 +650,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     );\n                     let mut dcx = dcx.build(&mut stacked_borrows.history, base_offset);\n                     dcx.log_creation();\n-                    if protect.is_some() {\n+                    if new_perm.protector().is_some() {\n                         dcx.log_protector();\n                     }\n                 },\n@@ -592,8 +663,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n         if size == Size::ZERO {\n             trace!(\n-                \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n-                kind,\n+                \"reborrow of size 0: reference {:?} derived from {:?} (pointee {})\",\n                 new_tag,\n                 place.ptr,\n                 place.layout.ty,\n@@ -630,16 +700,15 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         }\n \n         trace!(\n-            \"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n-            kind,\n+            \"reborrow: reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             new_tag,\n             orig_tag,\n             place.layout.ty,\n             Pointer::new(alloc_id, base_offset),\n             size.bytes()\n         );\n \n-        if let Some(protect) = protect {\n+        if let Some(protect) = new_perm.protector() {\n             // See comment in `Stack::item_invalidated` for why we store the tag twice.\n             this.frame_mut().extra.borrow_tracker.as_mut().unwrap().protected_tags.push(new_tag);\n             this.machine\n@@ -651,30 +720,45 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 .insert(new_tag, protect);\n         }\n \n-        // Update the stacks.\n-        // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n-        // There could be existing unique pointers reborrowed from them that should remain valid!\n-        let (perm, access) = match kind {\n-            RefKind::Unique { two_phase } => {\n-                // Permission is Unique only if the type is `Unpin` and this is not twophase\n-                if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n-                    (Permission::Unique, Some(AccessKind::Write))\n-                } else {\n-                    // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n-                    // should do fake accesses here. But then we run into\n-                    // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n-                    // we don't do that.\n-                    (Permission::SharedReadWrite, None)\n+        // Update the stacks, according to the new permission information we are given.\n+        match new_perm {\n+            NewPermission::Uniform { perm, access, protector } => {\n+                assert!(perm != Permission::SharedReadOnly);\n+                // Here we can avoid `borrow()` calls because we have mutable references.\n+                // Note that this asserts that the allocation is mutable -- but since we are creating a\n+                // mutable pointer, that seems reasonable.\n+                let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n+                let stacked_borrows = alloc_extra.borrow_tracker_sb_mut().get_mut();\n+                let item = Item::new(new_tag, perm, protector.is_some());\n+                let range = alloc_range(base_offset, size);\n+                let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n+                let dcx = DiagnosticCxBuilder::retag(\n+                    machine,\n+                    retag_cause,\n+                    new_tag,\n+                    orig_tag,\n+                    alloc_range(base_offset, size),\n+                );\n+                stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n+                    stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n+                })?;\n+                drop(global);\n+                if let Some(access) = access {\n+                    assert_eq!(access, AccessKind::Write);\n+                    // Make sure the data race model also knows about this.\n+                    if let Some(data_race) = alloc_extra.data_race.as_mut() {\n+                        data_race.write(alloc_id, range, machine)?;\n+                    }\n                 }\n             }\n-            RefKind::Box => (Permission::Unique, Some(AccessKind::Write)),\n-            RefKind::Raw { mutable: true } => {\n-                // Creating a raw ptr does not count as an access\n-                (Permission::SharedReadWrite, None)\n-            }\n-            RefKind::Shared | RefKind::Raw { mutable: false } => {\n-                // Shared references and *const are a whole different kind of game, the\n-                // permission is not uniform across the entire range!\n+            NewPermission::FreezeSensitive {\n+                freeze_perm,\n+                freeze_access,\n+                freeze_protector,\n+                nonfreeze_perm,\n+                nonfreeze_access,\n+            } => {\n+                // The permission is not uniform across the entire range!\n                 // We need a frozen-sensitive reborrow.\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n@@ -684,22 +768,12 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     // Adjust range.\n                     range.start += base_offset;\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n-                    let (perm, access) = if frozen {\n-                        (Permission::SharedReadOnly, Some(AccessKind::Read))\n-                    } else {\n-                        // Inside UnsafeCell, this does *not* count as an access, as there\n-                        // might actually be mutable references further up the stack that\n-                        // we have to keep alive.\n-                        (Permission::SharedReadWrite, None)\n-                    };\n-                    let protected = if frozen {\n-                        protect.is_some()\n+                    let (perm, access, protector) = if frozen {\n+                        (freeze_perm, freeze_access, freeze_protector)\n                     } else {\n-                        // We do not protect inside UnsafeCell.\n-                        // This fixes https://github.com/rust-lang/rust/issues/55005.\n-                        false\n+                        (nonfreeze_perm, nonfreeze_access, None)\n                     };\n-                    let item = Item::new(new_tag, perm, protected);\n+                    let item = Item::new(new_tag, perm, protector.is_some());\n                     let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n                         &this.machine,\n@@ -721,34 +795,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     }\n                     Ok(())\n                 })?;\n-                return Ok(Some(alloc_id));\n-            }\n-        };\n-\n-        // Here we can avoid `borrow()` calls because we have mutable references.\n-        // Note that this asserts that the allocation is mutable -- but since we are creating a\n-        // mutable pointer, that seems reasonable.\n-        let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let stacked_borrows = alloc_extra.borrow_tracker_sb_mut().get_mut();\n-        let item = Item::new(new_tag, perm, protect.is_some());\n-        let range = alloc_range(base_offset, size);\n-        let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n-        let dcx = DiagnosticCxBuilder::retag(\n-            machine,\n-            retag_cause,\n-            new_tag,\n-            orig_tag,\n-            alloc_range(base_offset, size),\n-        );\n-        stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n-        })?;\n-        drop(global);\n-        if let Some(access) = access {\n-            assert_eq!(access, AccessKind::Write);\n-            // Make sure the data race model also knows about this.\n-            if let Some(data_race) = alloc_extra.data_race.as_mut() {\n-                data_race.write(alloc_id, range, machine)?;\n             }\n         }\n \n@@ -760,9 +806,8 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n     fn sb_retag_reference(\n         &mut self,\n         val: &ImmTy<'tcx, Provenance>,\n-        kind: RefKind,\n-        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n-        protect: Option<ProtectorKind>,\n+        new_perm: NewPermission,\n+        cause: RetagCause, // What caused this retag, for diagnostics only\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n@@ -780,7 +825,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let new_tag = this.machine.borrow_tracker.as_mut().unwrap().get_mut().new_ptr();\n \n         // Reborrow.\n-        let alloc_id = this.sb_reborrow(&place, size, kind, retag_cause, new_tag, protect)?;\n+        let alloc_id = this.sb_reborrow(&place, size, new_perm, new_tag, cause)?;\n \n         // Adjust pointer.\n         let new_place = place.map_provenance(|p| {\n@@ -807,17 +852,32 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    fn sb_retag(\n+    fn sb_retag_ptr_value(\n+        &mut self,\n+        kind: RetagKind,\n+        val: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        let new_perm = NewPermission::from_ref_ty(val.layout.ty, kind, this);\n+        let retag_cause = match kind {\n+            RetagKind::TwoPhase { .. } => RetagCause::TwoPhase,\n+            RetagKind::FnEntry => unreachable!(),\n+            RetagKind::Raw | RetagKind::Default => RetagCause::Normal,\n+        };\n+        this.sb_retag_reference(&val, new_perm, retag_cause)\n+    }\n+\n+    fn sb_retag_place_contents(\n         &mut self,\n         kind: RetagKind,\n         place: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let retag_fields = this.machine.borrow_tracker.as_mut().unwrap().get_mut().retag_fields;\n         let retag_cause = match kind {\n-            RetagKind::TwoPhase { .. } => RetagCause::TwoPhase,\n+            RetagKind::Raw | RetagKind::TwoPhase { .. } => unreachable!(), // these can only happen in `retag_ptr_value`\n             RetagKind::FnEntry => RetagCause::FnEntry,\n-            RetagKind::Raw | RetagKind::Default => RetagCause::Normal,\n+            RetagKind::Default => RetagCause::Normal,\n         };\n         let mut visitor = RetagVisitor { ecx: this, kind, retag_cause, retag_fields };\n         return visitor.visit_value(place);\n@@ -831,15 +891,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n         impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n             #[inline(always)] // yes this helps in our benchmarks\n-            fn retag_place(\n+            fn retag_ptr_inplace(\n                 &mut self,\n                 place: &PlaceTy<'tcx, Provenance>,\n-                ref_kind: RefKind,\n+                new_perm: NewPermission,\n                 retag_cause: RetagCause,\n-                protector: Option<ProtectorKind>,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n-                let val = self.ecx.sb_retag_reference(&val, ref_kind, retag_cause, protector)?;\n+                let val = self.ecx.sb_retag_reference(&val, new_perm, retag_cause)?;\n                 self.ecx.write_immediate(*val, place)?;\n                 Ok(())\n             }\n@@ -856,13 +915,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n-                self.retag_place(\n-                    place,\n-                    RefKind::Box,\n-                    self.retag_cause,\n-                    /*protector*/\n-                    (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n-                )\n+                let new_perm = NewPermission::Uniform {\n+                    perm: Permission::Unique,\n+                    access: Some(AccessKind::Write),\n+                    protector: (self.kind == RetagKind::FnEntry)\n+                        .then_some(ProtectorKind::WeakProtector),\n+                };\n+                self.retag_ptr_inplace(place, new_perm, self.retag_cause)\n             }\n \n             fn visit_value(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n@@ -876,36 +935,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                 // Check the type of this value to see what to do with it (retag, or recurse).\n                 match place.layout.ty.kind() {\n-                    ty::Ref(_, _, mutbl) => {\n-                        let ref_kind = match mutbl {\n-                            Mutability::Mut =>\n-                                RefKind::Unique { two_phase: self.kind == RetagKind::TwoPhase },\n-                            Mutability::Not => RefKind::Shared,\n-                        };\n-                        self.retag_place(\n-                            place,\n-                            ref_kind,\n-                            self.retag_cause,\n-                            /*protector*/\n-                            (self.kind == RetagKind::FnEntry)\n-                                .then_some(ProtectorKind::StrongProtector),\n-                        )?;\n+                    ty::Ref(..) => {\n+                        let new_perm =\n+                            NewPermission::from_ref_ty(place.layout.ty, self.kind, self.ecx);\n+                        self.retag_ptr_inplace(place, new_perm, self.retag_cause)?;\n                     }\n-                    ty::RawPtr(tym) => {\n-                        // We definitely do *not* want to recurse into raw pointers -- wide raw\n-                        // pointers have fields, and for dyn Trait pointees those can have reference\n-                        // type!\n-                        if self.kind == RetagKind::Raw {\n-                            // Raw pointers need to be enabled.\n-                            self.retag_place(\n-                                place,\n-                                RefKind::Raw { mutable: tym.mutbl == Mutability::Mut },\n-                                self.retag_cause,\n-                                /*protector*/ None,\n-                            )?;\n-                        }\n+                    ty::RawPtr(..) => {\n+                        // We do *not* want to recurse into raw pointers -- wide raw pointers have\n+                        // fields, and for dyn Trait pointees those can have reference type!\n                     }\n-                    _ if place.layout.ty.ty_adt_def().is_some_and(|adt| adt.is_box()) => {\n+                    ty::Adt(adt, _) if adt.is_box() => {\n                         // Recurse for boxes, they require some tricky handling and will end up in `visit_box` above.\n                         // (Yes this means we technically also recursively retag the allocator itself\n                         // even if field retagging is not enabled. *shrug*)\n@@ -953,12 +992,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n         // Reborrow it. With protection! That is part of the point.\n-        let val = this.sb_retag_reference(\n-            &val,\n-            RefKind::Unique { two_phase: false },\n-            RetagCause::FnReturn,\n-            /*protector*/ Some(ProtectorKind::StrongProtector),\n-        )?;\n+        let new_perm = NewPermission::Uniform {\n+            perm: Permission::Unique,\n+            access: Some(AccessKind::Write),\n+            protector: Some(ProtectorKind::StrongProtector),\n+        };\n+        let val = this.sb_retag_reference(&val, new_perm, RetagCause::FnReturn)?;\n         // And use reborrowed pointer for return place.\n         let return_place = this.ref_to_mplace(&val)?;\n         this.frame_mut().return_place = return_place.into();"}, {"sha": "d0fb9f9b0b5fe7409878f0c6abd96ebcd74e1975", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -63,9 +63,9 @@ impl MachineStopType for TerminationInfo {}\n \n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n-    /// (new_tag, new_kind, (alloc_id, base_offset, orig_tag))\n+    /// (new_tag, new_perm, (alloc_id, base_offset, orig_tag))\n     ///\n-    /// new_kind is `None` for base tags.\n+    /// new_perm is `None` for base tags.\n     CreatedPointerTag(NonZeroU64, Option<String>, Option<(AllocId, AllocRange, ProvenanceExtra)>),\n     /// This `Item` was popped from the borrow stack. The string explains the reason.\n     PoppedPointerTag(Item, String),\n@@ -393,10 +393,10 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n \n         let msg = match &e {\n             CreatedPointerTag(tag, None, _) => format!(\"created base tag {tag:?}\"),\n-            CreatedPointerTag(tag, Some(kind), None) => format!(\"created {tag:?} for {kind}\"),\n-            CreatedPointerTag(tag, Some(kind), Some((alloc_id, range, orig_tag))) =>\n+            CreatedPointerTag(tag, Some(perm), None) => format!(\"created {tag:?} with {perm} derived from unknown tag\"),\n+            CreatedPointerTag(tag, Some(perm), Some((alloc_id, range, orig_tag))) =>\n                 format!(\n-                    \"created tag {tag:?} for {kind} at {alloc_id:?}{range:?} derived from {orig_tag:?}\"\n+                    \"created tag {tag:?} with {perm} at {alloc_id:?}{range:?} derived from {orig_tag:?}\"\n                 ),\n             PoppedPointerTag(item, cause) => format!(\"popped tracked tag for item {item:?}{cause}\"),\n             CreatedCallId(id) => format!(\"function call with id {id}\"),"}, {"sha": "e5b1eb2e4870696691a5f1672ea90f194665a865", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7701a7e7d4eed74a106f39fa64899dffd1e1025f/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=7701a7e7d4eed74a106f39fa64899dffd1e1025f", "patch": "@@ -967,8 +967,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         ptr: Pointer<Self::Provenance>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Provenance::Concrete { alloc_id, tag } =>\n-                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, tag),\n+            Provenance::Concrete { alloc_id, tag } => {\n+                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, tag)\n+            }\n             Provenance::Wildcard => {\n                 // No need to do anything for wildcard pointers as\n                 // their provenances have already been previously exposed.\n@@ -1055,13 +1056,26 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn retag(\n+    fn retag_ptr_value(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        kind: mir::RetagKind,\n+        val: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        if ecx.machine.borrow_tracker.is_some() {\n+            ecx.retag_ptr_value(kind, val)\n+        } else {\n+            Ok(val.clone())\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn retag_place_contents(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         kind: mir::RetagKind,\n         place: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         if ecx.machine.borrow_tracker.is_some() {\n-            ecx.retag(kind, place)?;\n+            ecx.retag_place_contents(kind, place)?;\n         }\n         Ok(())\n     }"}]}