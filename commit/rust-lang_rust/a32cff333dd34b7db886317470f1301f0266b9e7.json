{"sha": "a32cff333dd34b7db886317470f1301f0266b9e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMmNmZjMzM2RkMzRiN2RiODg2MzE3NDcwZjEzMDFmMDI2NmI5ZTc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-14T12:08:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-14T12:15:36Z"}, "message": "Introduce paths crate\n\nIt's a good idea to distinguish between absolute and relative paths at\nthe type level, to avoid accidental dependency on the cwd, which\nreally shouldn't matter for rust-analyzer service", "tree": {"sha": "7531c71ea8bf3b38d28c6ec51be8141ad9384dc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7531c71ea8bf3b38d28c6ec51be8141ad9384dc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a32cff333dd34b7db886317470f1301f0266b9e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a32cff333dd34b7db886317470f1301f0266b9e7", "html_url": "https://github.com/rust-lang/rust/commit/a32cff333dd34b7db886317470f1301f0266b9e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a32cff333dd34b7db886317470f1301f0266b9e7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "url": "https://api.github.com/repos/rust-lang/rust/commits/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a", "html_url": "https://github.com/rust-lang/rust/commit/246c66a7f7fd3f85d7d6e47a36f17bafb0ccb08a"}], "stats": {"total": 135, "additions": 135, "deletions": 0}, "files": [{"sha": "5848e61c7edc683a98ea64b8452b7661d72cb295", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32cff333dd34b7db886317470f1301f0266b9e7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a32cff333dd34b7db886317470f1301f0266b9e7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a32cff333dd34b7db886317470f1301f0266b9e7", "patch": "@@ -834,6 +834,10 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"paths\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"2.1.0\""}, {"sha": "646ee7fd54cf7a882be1a8fdc5466a7c8d81dd1c", "filename": "crates/paths/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a32cff333dd34b7db886317470f1301f0266b9e7/crates%2Fpaths%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a32cff333dd34b7db886317470f1301f0266b9e7/crates%2Fpaths%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2FCargo.toml?ref=a32cff333dd34b7db886317470f1301f0266b9e7", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"paths\"\n+version = \"0.1.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false"}, {"sha": "c7ce0c42f7f80a0cdc4cc7c20ecf71185673a0f4", "filename": "crates/paths/src/lib.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a32cff333dd34b7db886317470f1301f0266b9e7/crates%2Fpaths%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32cff333dd34b7db886317470f1301f0266b9e7/crates%2Fpaths%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2Fsrc%2Flib.rs?ref=a32cff333dd34b7db886317470f1301f0266b9e7", "patch": "@@ -0,0 +1,123 @@\n+//! Thin wrappers around `std::path`, distinguishing between absolute and\n+//! relative paths.\n+use std::{\n+    convert::{TryFrom, TryInto},\n+    ops,\n+    path::{Component, Path, PathBuf},\n+};\n+\n+#[derive(Debug, Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n+pub struct AbsPathBuf(PathBuf);\n+\n+impl From<AbsPathBuf> for PathBuf {\n+    fn from(AbsPathBuf(path_buf): AbsPathBuf) -> PathBuf {\n+        path_buf\n+    }\n+}\n+\n+impl ops::Deref for AbsPathBuf {\n+    type Target = AbsPath;\n+    fn deref(&self) -> &AbsPath {\n+        self.as_path()\n+    }\n+}\n+\n+impl AsRef<Path> for AbsPathBuf {\n+    fn as_ref(&self) -> &Path {\n+        self.0.as_path()\n+    }\n+}\n+\n+impl TryFrom<PathBuf> for AbsPathBuf {\n+    type Error = PathBuf;\n+    fn try_from(path_buf: PathBuf) -> Result<AbsPathBuf, PathBuf> {\n+        if !path_buf.is_absolute() {\n+            return Err(path_buf);\n+        }\n+        Ok(AbsPathBuf(path_buf))\n+    }\n+}\n+\n+impl TryFrom<&str> for AbsPathBuf {\n+    type Error = PathBuf;\n+    fn try_from(path: &str) -> Result<AbsPathBuf, PathBuf> {\n+        AbsPathBuf::try_from(PathBuf::from(path))\n+    }\n+}\n+\n+impl AbsPathBuf {\n+    pub fn as_path(&self) -> &AbsPath {\n+        AbsPath::new_unchecked(self.0.as_path())\n+    }\n+    pub fn pop(&mut self) -> bool {\n+        self.0.pop()\n+    }\n+}\n+\n+#[derive(Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\n+#[repr(transparent)]\n+pub struct AbsPath(Path);\n+\n+impl ops::Deref for AbsPath {\n+    type Target = Path;\n+    fn deref(&self) -> &Path {\n+        &self.0\n+    }\n+}\n+\n+impl AsRef<Path> for AbsPath {\n+    fn as_ref(&self) -> &Path {\n+        &self.0\n+    }\n+}\n+\n+impl<'a> TryFrom<&'a Path> for &'a AbsPath {\n+    type Error = &'a Path;\n+    fn try_from(path: &'a Path) -> Result<&'a AbsPath, &'a Path> {\n+        if !path.is_absolute() {\n+            return Err(path);\n+        }\n+        Ok(AbsPath::new_unchecked(path))\n+    }\n+}\n+\n+impl AbsPath {\n+    fn new_unchecked(path: &Path) -> &AbsPath {\n+        unsafe { &*(path as *const Path as *const AbsPath) }\n+    }\n+\n+    pub fn join(&self, path: impl AsRef<Path>) -> AbsPathBuf {\n+        self.as_ref().join(path).try_into().unwrap()\n+    }\n+    pub fn normalize(&self) -> AbsPathBuf {\n+        AbsPathBuf(normalize_path(&self.0))\n+    }\n+}\n+\n+// https://github.com/rust-lang/cargo/blob/79c769c3d7b4c2cf6a93781575b7f592ef974255/src/cargo/util/paths.rs#L60-L85\n+fn normalize_path(path: &Path) -> PathBuf {\n+    let mut components = path.components().peekable();\n+    let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {\n+        components.next();\n+        PathBuf::from(c.as_os_str())\n+    } else {\n+        PathBuf::new()\n+    };\n+\n+    for component in components {\n+        match component {\n+            Component::Prefix(..) => unreachable!(),\n+            Component::RootDir => {\n+                ret.push(component.as_os_str());\n+            }\n+            Component::CurDir => {}\n+            Component::ParentDir => {\n+                ret.pop();\n+            }\n+            Component::Normal(c) => {\n+                ret.push(c);\n+            }\n+        }\n+    }\n+    ret\n+}"}]}