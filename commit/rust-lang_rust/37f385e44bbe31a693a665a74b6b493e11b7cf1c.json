{"sha": "37f385e44bbe31a693a665a74b6b493e11b7cf1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZjM4NWU0NGJiZTMxYTY5M2E2NjVhNzRiNmI0OTNlMTFiN2NmMWM=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-26T21:20:26Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-01T22:16:01Z"}, "message": "Have linked failure tests run on the new scheduler instead of requiring RUST_NEWRT to test.", "tree": {"sha": "25f552e1a1bc0618f38a264c8a32b501f5113b34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25f552e1a1bc0618f38a264c8a32b501f5113b34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37f385e44bbe31a693a665a74b6b493e11b7cf1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37f385e44bbe31a693a665a74b6b493e11b7cf1c", "html_url": "https://github.com/rust-lang/rust/commit/37f385e44bbe31a693a665a74b6b493e11b7cf1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37f385e44bbe31a693a665a74b6b493e11b7cf1c/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7eed223873a4280c9abea937e60ef1aaedf0162", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7eed223873a4280c9abea937e60ef1aaedf0162", "html_url": "https://github.com/rust-lang/rust/commit/f7eed223873a4280c9abea937e60ef1aaedf0162"}], "stats": {"total": 231, "additions": 152, "deletions": 79}, "files": [{"sha": "5e4d48403ccd62b115d879eb3ec68c14f5e81fd9", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 152, "deletions": 79, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/37f385e44bbe31a693a665a74b6b493e11b7cf1c/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37f385e44bbe31a693a665a74b6b493e11b7cf1c/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=37f385e44bbe31a693a665a74b6b493e11b7cf1c", "patch": "@@ -677,121 +677,190 @@ fn block_forever() { let (po, _ch) = stream::<()>(); po.recv(); }\n \n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n-    let (po, ch) = stream();\n-    let ch = SharedChan::new(ch);\n-    do spawn_unlinked {\n-        let ch = ch.clone();\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let (po, ch) = stream();\n+        let ch = SharedChan::new(ch);\n         do spawn_unlinked {\n-            // Give middle task a chance to fail-but-not-kill-us.\n-            do 16.times { task::yield(); }\n-            ch.send(()); // If killed first, grandparent hangs.\n+            let ch = ch.clone();\n+            do spawn_unlinked {\n+                // Give middle task a chance to fail-but-not-kill-us.\n+                for 16.times { task::yield(); }\n+                ch.send(()); // If killed first, grandparent hangs.\n+            }\n+            fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n         }\n-        fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n+        po.recv();\n     }\n-    po.recv();\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n-    do spawn_unlinked { fail!(); }\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        do spawn_unlinked { fail!(); }\n+    }\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n-    do spawn_supervised { fail!(); }\n-    // Give child a chance to fail-but-not-kill-us.\n-    do 16.times { task::yield(); }\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        do spawn_supervised { fail!(); }\n+        // Give child a chance to fail-but-not-kill-us.\n+        for 16.times { task::yield(); }\n+    }\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_fail_down() {\n-    do spawn_supervised { block_forever(); }\n-    fail!(); // Shouldn't leave a child hanging around.\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            do spawn_supervised { block_forever(); }\n+            fail!(); // Shouldn't leave a child hanging around.\n+        };\n+        assert!(result.is_err());\n+    }\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n-    // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n-    // We have to cheat with opts - the interface doesn't support them because\n-    // they don't make sense (redundant with task().supervised()).\n-    let mut b0 = task();\n-    b0.opts.linked = true;\n-    b0.opts.supervised = true;\n-\n-    do b0.spawn {\n-        fail!();\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n+            // We have to cheat with opts - the interface doesn't support them because\n+            // they don't make sense (redundant with task().supervised()).\n+            let mut b0 = task();\n+            b0.opts.linked = true;\n+            b0.opts.supervised = true;\n+\n+            do b0.spawn {\n+                fail!();\n+            }\n+            block_forever(); // We should get punted awake\n+        };\n+        assert!(result.is_err());\n     }\n-    block_forever(); // We should get punted awake\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n-    // We have to cheat with opts - the interface doesn't support them because\n-    // they don't make sense (redundant with task().supervised()).\n-    let mut b0 = task();\n-    b0.opts.linked = true;\n-    b0.opts.supervised = true;\n-    do b0.spawn { block_forever(); }\n-    fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // We have to cheat with opts - the interface doesn't support them because\n+            // they don't make sense (redundant with task().supervised()).\n+            let mut b0 = task();\n+            b0.opts.linked = true;\n+            b0.opts.supervised = true;\n+            do b0.spawn { block_forever(); }\n+            fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n+        };\n+        assert!(result.is_err());\n+    }\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n-    // Default options are to spawn linked & unsupervised.\n-    do spawn { fail!(); }\n-    block_forever(); // We should get punted awake\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Default options are to spawn linked & unsupervised.\n+            do spawn { fail!(); }\n+            block_forever(); // We should get punted awake\n+        };\n+        assert!(result.is_err());\n+    }\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n-    // Default options are to spawn linked & unsupervised.\n-    do spawn { block_forever(); }\n-    fail!();\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Default options are to spawn linked & unsupervised.\n+            do spawn { block_forever(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n+    }\n }\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n-    // Make sure the above test is the same as this one.\n-    let mut builder = task();\n-    builder.linked();\n-    do builder.spawn { block_forever(); }\n-    fail!();\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Make sure the above test is the same as this one.\n+            let mut builder = task();\n+            builder.linked();\n+            do builder.spawn { block_forever(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n+    }\n }\n \n // A couple bonus linked failure tests - testing for failure propagation even\n // when the middle task exits successfully early before kill signals are sent.\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_grandchild() {\n-    // Middle task exits; does grandparent's failure propagate across the gap?\n-    do spawn_supervised {\n-        do spawn_supervised { block_forever(); }\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Middle task exits; does grandparent's failure propagate across the gap?\n+            do spawn_supervised {\n+                do spawn_supervised { block_forever(); }\n+            }\n+            for 16.times { task::yield(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n     }\n-    do 16.times { task::yield(); }\n-    fail!();\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_secondborn() {\n-    // First-born child exits; does parent's failure propagate to sibling?\n-    do spawn_supervised {\n-        do spawn { block_forever(); } // linked\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // First-born child exits; does parent's failure propagate to sibling?\n+            do spawn_supervised {\n+                do spawn { block_forever(); } // linked\n+            }\n+            for 16.times { task::yield(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n     }\n-    do 16.times { task::yield(); }\n-    fail!();\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_failure_propagate_nephew_or_niece() {\n-    // Our sibling exits; does our failure propagate to sibling's child?\n-    do spawn { // linked\n-        do spawn_supervised { block_forever(); }\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Our sibling exits; does our failure propagate to sibling's child?\n+            do spawn { // linked\n+                do spawn_supervised { block_forever(); }\n+            }\n+            for 16.times { task::yield(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n     }\n-    do 16.times { task::yield(); }\n-    fail!();\n }\n \n-#[test] #[should_fail] #[ignore(cfg(windows))]\n+#[test] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_propagate_sibling() {\n-    // Middle sibling exits - does eldest's failure propagate to youngest?\n-    do spawn { // linked\n-        do spawn { block_forever(); } // linked\n+    use rt::test::run_in_newsched_task;\n+    do run_in_newsched_task {\n+        let result: Result<(),()> = do try {\n+            // Middle sibling exits - does eldest's failure propagate to youngest?\n+            do spawn { // linked\n+                do spawn { block_forever(); } // linked\n+            }\n+            for 16.times { task::yield(); }\n+            fail!();\n+        };\n+        assert!(result.is_err());\n     }\n-    do 16.times { task::yield(); }\n-    fail!();\n }\n \n #[test]\n@@ -1149,11 +1218,15 @@ fn test_child_doesnt_ref_parent() {\n     fn child_no(x: uint) -> ~fn() {\n         return || {\n             if x < generations {\n-                task::spawn(child_no(x+1));\n+                let mut t = task();\n+                t.unwatched();\n+                t.spawn(child_no(x+1));\n             }\n         }\n     }\n-    task::spawn(child_no(0));\n+    let mut t = task();\n+    t.unwatched();\n+    t.spawn(child_no(0));\n }\n \n #[test]\n@@ -1167,9 +1240,9 @@ fn test_simple_newsched_spawn() {\n \n #[test] #[ignore(cfg(windows))]\n fn test_spawn_watched() {\n-    use rt::test::{run_in_newsched_task, spawntask_try};\n+    use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n-        let result = do spawntask_try {\n+        let result = do try {\n             let mut t = task();\n             t.unlinked();\n             t.watched();\n@@ -1189,9 +1262,9 @@ fn test_spawn_watched() {\n \n #[test] #[ignore(cfg(windows))]\n fn test_indestructible() {\n-    use rt::test::{run_in_newsched_task, spawntask_try};\n+    use rt::test::run_in_newsched_task;\n     do run_in_newsched_task {\n-        let result = do spawntask_try {\n+        let result = do try {\n             let mut t = task();\n             t.watched();\n             t.supervised();"}]}