{"sha": "734de8b2b7db58e15706721d0a28d55571850505", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNGRlOGIyYjdkYjU4ZTE1NzA2NzIxZDBhMjhkNTU1NzE4NTA1MDU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-07-05T00:11:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-05T00:11:52Z"}, "message": "Merge pull request #1765 from topecongiro/v-alignment/struct-field\n\nAdd vertical alignment option for struct fields", "tree": {"sha": "afc4e90577fe703c09373d689c71a00e0966e380", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afc4e90577fe703c09373d689c71a00e0966e380"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/734de8b2b7db58e15706721d0a28d55571850505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/734de8b2b7db58e15706721d0a28d55571850505", "html_url": "https://github.com/rust-lang/rust/commit/734de8b2b7db58e15706721d0a28d55571850505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/734de8b2b7db58e15706721d0a28d55571850505/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2400f39f98291d9f62df59bc743798bcaf8db5d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2400f39f98291d9f62df59bc743798bcaf8db5d5", "html_url": "https://github.com/rust-lang/rust/commit/2400f39f98291d9f62df59bc743798bcaf8db5d5"}, {"sha": "2ed6feca83ae13bad5dca63d8f9ed1f1dd0c5b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed6feca83ae13bad5dca63d8f9ed1f1dd0c5b0a", "html_url": "https://github.com/rust-lang/rust/commit/2ed6feca83ae13bad5dca63d8f9ed1f1dd0c5b0a"}], "stats": {"total": 1656, "additions": 1427, "deletions": 229}, "files": [{"sha": "5de757a91685998ab6d0fff1c6ee1311308cdb8f", "filename": "Configurations.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -1209,6 +1209,33 @@ fn lorem<T: Eq>(t: T) {\n \n See also: [`space_before_bound`](#space_before_bound).\n \n+## `struct_field_align_threshold`\n+\n+The maximum diff of width between struct fields to be aligned with each other.\n+\n+- **Default value** : 0\n+- **Possible values**: any positive integer\n+\n+#### `0`:\n+\n+```rust\n+struct Foo {\n+    x: u32,\n+    yy: u32,\n+    zzz: u32,\n+}\n+```\n+\n+#### `20`:\n+\n+```rust\n+struct Foo {\n+    x:   u32,\n+    yy:  u32,\n+    zzz: u32,\n+}\n+```\n+\n ## `space_after_struct_lit_field_colon`\n \n Leave a space after the colon in a struct literal field"}, {"sha": "bc00fd176cf0a97f0f34a48b042f1587e518f9b4", "filename": "src/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -598,7 +598,9 @@ create_config! {\n         \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";\n     condense_wildcard_suffixes: bool, false, \"Replace strings of _ wildcards by a single .. in \\\n                                               tuple patterns\";\n-    combine_control_expr: bool, true, \"Combine control expressions with funciton calls.\"\n+    combine_control_expr: bool, true, \"Combine control expressions with funciton calls.\";\n+    struct_field_align_threshold: usize, 0, \"Align struct fields if their diffs fits within \\\n+                                             threshold.\"\n }\n \n #[cfg(test)]"}, {"sha": "dd0499ebb81701f6de69c8141adcf7afeb0492dd", "filename": "src/expr.rs", "status": "modified", "additions": 104, "deletions": 57, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -30,6 +30,7 @@ use items::{span_lo_for_arg, span_hi_for_arg};\n use chains::rewrite_chain;\n use macros::{rewrite_macro, MacroPosition};\n use patterns::{TuplePatField, can_be_overflowed_pat};\n+use vertical::rewrite_with_alignment;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos};\n@@ -2551,6 +2552,14 @@ fn rewrite_index(\n     }\n }\n \n+fn struct_lit_can_be_aligned(fields: &[ast::Field], base: &Option<&ast::Expr>) -> bool {\n+    if base.is_some() {\n+        return false;\n+    }\n+\n+    fields.iter().all(|field| !field.is_shorthand)\n+}\n+\n fn rewrite_struct_lit<'a>(\n     context: &RewriteContext,\n     path: &ast::Path,\n@@ -2580,76 +2589,100 @@ fn rewrite_struct_lit<'a>(\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n-    let field_iter = fields\n-        .into_iter()\n-        .map(StructLitField::Regular)\n-        .chain(base.into_iter().map(StructLitField::Base));\n-\n     // Foo { a: Foo } - indent is +3, width is -5.\n     let (h_shape, v_shape) = try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, 2));\n \n-    let span_lo = |item: &StructLitField| match *item {\n-        StructLitField::Regular(field) => field.span.lo,\n-        StructLitField::Base(expr) => {\n-            let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n-            let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n-            let pos = snippet.find_uncommented(\"..\").unwrap();\n-            last_field_hi + BytePos(pos as u32)\n-        }\n-    };\n-    let span_hi = |item: &StructLitField| match *item {\n-        StructLitField::Regular(field) => field.span.hi,\n-        StructLitField::Base(expr) => expr.span.hi,\n-    };\n-    let rewrite = |item: &StructLitField| match *item {\n-        StructLitField::Regular(field) => {\n-            // The 1 taken from the v_budget is for the comma.\n-            rewrite_field(context, field, try_opt!(v_shape.sub_width(1)))\n-        }\n-        StructLitField::Base(expr) => {\n-            // 2 = ..\n-            expr.rewrite(context, try_opt!(v_shape.shrink_left(2)))\n-                .map(|s| format!(\"..{}\", s))\n-        }\n+    let one_line_width = h_shape.map_or(0, |shape| shape.width);\n+    let body_lo = context.codemap.span_after(span, \"{\");\n+    let fields_str = if struct_lit_can_be_aligned(fields, &base) &&\n+        context.config.struct_field_align_threshold() > 0\n+    {\n+        try_opt!(rewrite_with_alignment(\n+            fields,\n+            context,\n+            shape,\n+            mk_sp(body_lo, span.hi),\n+            one_line_width,\n+        ))\n+    } else {\n+        let field_iter = fields\n+            .into_iter()\n+            .map(StructLitField::Regular)\n+            .chain(base.into_iter().map(StructLitField::Base));\n+\n+        let span_lo = |item: &StructLitField| match *item {\n+            StructLitField::Regular(field) => field.span().lo,\n+            StructLitField::Base(expr) => {\n+                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                let pos = snippet.find_uncommented(\"..\").unwrap();\n+                last_field_hi + BytePos(pos as u32)\n+            }\n+        };\n+        let span_hi = |item: &StructLitField| match *item {\n+            StructLitField::Regular(field) => field.span().hi,\n+            StructLitField::Base(expr) => expr.span.hi,\n+        };\n+        let rewrite = |item: &StructLitField| match *item {\n+            StructLitField::Regular(field) => {\n+                // The 1 taken from the v_budget is for the comma.\n+                rewrite_field(context, field, try_opt!(v_shape.sub_width(1)), 0)\n+            }\n+            StructLitField::Base(expr) => {\n+                // 2 = ..\n+                expr.rewrite(context, try_opt!(v_shape.shrink_left(2)))\n+                    .map(|s| format!(\"..{}\", s))\n+            }\n+        };\n+\n+        let items = itemize_list(\n+            context.codemap,\n+            field_iter,\n+            \"}\",\n+            span_lo,\n+            span_hi,\n+            rewrite,\n+            body_lo,\n+            span.hi,\n+        );\n+        let item_vec = items.collect::<Vec<_>>();\n+\n+        let tactic = struct_lit_tactic(h_shape, context, &item_vec);\n+        let nested_shape = shape_for_tactic(tactic, h_shape, v_shape);\n+        let fmt = struct_lit_formatting(nested_shape, tactic, context, base.is_some());\n+\n+        try_opt!(write_list(&item_vec, &fmt))\n     };\n \n-    let items = itemize_list(\n-        context.codemap,\n-        field_iter,\n-        \"}\",\n-        span_lo,\n-        span_hi,\n-        rewrite,\n-        context.codemap.span_after(span, \"{\"),\n-        span.hi,\n-    );\n-    let item_vec = items.collect::<Vec<_>>();\n+    let fields_str = wrap_struct_field(context, &fields_str, shape, v_shape, one_line_width);\n+    Some(format!(\"{} {{{}}}\", path_str, fields_str))\n \n-    let tactic = struct_lit_tactic(h_shape, context, &item_vec);\n-    let nested_shape = shape_for_tactic(tactic, h_shape, v_shape);\n-    let fmt = struct_lit_formatting(nested_shape, tactic, context, base.is_some());\n+    // FIXME if context.config.struct_lit_style() == Visual, but we run out\n+    // of space, we should fall back to BlockIndent.\n+}\n \n-    let fields_str = try_opt!(write_list(&item_vec, &fmt));\n-    let fields_str = if context.config.struct_lit_style() == IndentStyle::Block &&\n+pub fn wrap_struct_field(\n+    context: &RewriteContext,\n+    fields_str: &str,\n+    shape: Shape,\n+    nested_shape: Shape,\n+    one_line_width: usize,\n+) -> String {\n+    if context.config.struct_lit_style() == IndentStyle::Block &&\n         (fields_str.contains('\\n') ||\n              context.config.struct_lit_multiline_style() == MultilineStyle::ForceMulti ||\n-             fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0))\n+             fields_str.len() > one_line_width)\n     {\n         format!(\n             \"\\n{}{}\\n{}\",\n-            v_shape.indent.to_string(context.config),\n+            nested_shape.indent.to_string(context.config),\n             fields_str,\n             shape.indent.to_string(context.config)\n         )\n     } else {\n         // One liner or visual indent.\n         format!(\" {} \", fields_str)\n-    };\n-\n-    Some(format!(\"{} {{{}}}\", path_str, fields_str))\n-\n-    // FIXME if context.config.struct_lit_style() == Visual, but we run out\n-    // of space, we should fall back to BlockIndent.\n+    }\n }\n \n pub fn struct_lit_field_separator(config: &Config) -> &str {\n@@ -2659,18 +2692,32 @@ pub fn struct_lit_field_separator(config: &Config) -> &str {\n     )\n }\n \n-fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) -> Option<String> {\n+pub fn rewrite_field(\n+    context: &RewriteContext,\n+    field: &ast::Field,\n+    shape: Shape,\n+    prefix_max_width: usize,\n+) -> Option<String> {\n+    if contains_skip(&field.attrs) {\n+        return wrap_str(\n+            context.snippet(field.span()),\n+            context.config.max_width(),\n+            shape,\n+        );\n+    }\n     let name = &field.ident.node.to_string();\n     if field.is_shorthand {\n         Some(name.to_string())\n     } else {\n-        let separator = struct_lit_field_separator(context.config);\n+        let mut separator = String::from(struct_lit_field_separator(context.config));\n+        for _ in 0..prefix_max_width.checked_sub(name.len()).unwrap_or(0) {\n+            separator.push(' ');\n+        }\n         let overhead = name.len() + separator.len();\n-        let mut expr_shape = try_opt!(shape.sub_width(overhead));\n-        expr_shape.offset += overhead;\n+        let expr_shape = try_opt!(shape.offset_left(overhead));\n         let expr = field.expr.rewrite(context, expr_shape);\n \n-        let mut attrs_str = try_opt!((*field.attrs).rewrite(context, shape));\n+        let mut attrs_str = try_opt!(field.attrs.rewrite(context, shape));\n         if !attrs_str.is_empty() {\n             attrs_str.push_str(&format!(\"\\n{}\", shape.indent.to_string(context.config)));\n         };"}, {"sha": "0e8c10ea1815cefbfa08bd0c584c4544dfdb7292", "filename": "src/items.rs", "status": "modified", "additions": 122, "deletions": 126, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -23,6 +23,7 @@ use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n use config::{Config, IndentStyle, Density, ReturnIndent, BraceStyle, Style};\n use types::join_bounds;\n+use vertical::rewrite_with_alignment;\n \n use syntax::{ast, abi, ptr, symbol};\n use syntax::codemap::{Span, BytePos};\n@@ -1100,49 +1101,14 @@ fn format_struct_struct(\n         return Some(result);\n     }\n \n-    let item_indent = offset.block_indent(context.config);\n-    // 1 = \",\"\n-    let item_budget = try_opt!(\n-        context\n-            .config\n-            .max_width()\n-            .checked_sub(item_indent.width() + 1)\n-    );\n-\n-    let items = itemize_list(\n-        context.codemap,\n-        fields.iter(),\n-        \"}\",\n-        |field| {\n-            // Include attributes and doc comments, if present\n-            if !field.attrs.is_empty() {\n-                field.attrs[0].span.lo\n-            } else {\n-                field.span.lo\n-            }\n-        },\n-        |field| field.ty.span.hi,\n-        |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n-        context.codemap.span_after(span, \"{\"),\n-        span.hi,\n-    ).collect::<Vec<_>>();\n-    // 1 = ,\n-    let budget = context.config.max_width() - offset.width() + context.config.tab_spaces() - 1;\n-\n-    let tactic = match one_line_width {\n-        Some(w) => definitive_tactic(&items, ListTactic::LimitedHorizontalVertical(w), budget),\n-        None => DefinitiveListTactic::Vertical,\n-    };\n+    let items_str = try_opt!(rewrite_with_alignment(\n+        fields,\n+        context,\n+        Shape::indented(offset, context.config),\n+        mk_sp(body_lo, span.hi),\n+        one_line_width.unwrap_or(0),\n+    ));\n \n-    let fmt = ListFormatting {\n-        tactic: tactic,\n-        separator: \",\",\n-        trailing_separator: context.config.trailing_comma(),\n-        shape: Shape::legacy(budget, item_indent),\n-        ends_with_newline: true,\n-        config: context.config,\n-    };\n-    let items_str = try_opt!(write_list(&items, &fmt));\n     if one_line_width.is_some() && !items_str.contains('\\n') {\n         Some(format!(\"{} {} }}\", result, items_str))\n     } else {\n@@ -1257,7 +1223,9 @@ fn format_tuple_struct(\n                 }\n             },\n             |field| field.ty.span.hi,\n-            |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n+            |field| {\n+                rewrite_struct_field(context, field, Shape::legacy(item_budget, item_indent), 0)\n+            },\n             context.codemap.span_after(span, \"(\"),\n             span.hi,\n         );\n@@ -1430,97 +1398,125 @@ fn rewrite_missing_comment_on_field(\n     }\n }\n \n-impl Rewrite for ast::StructField {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        if contains_skip(&self.attrs) {\n-            let span = context.snippet(mk_sp(self.attrs[0].span.lo, self.span.hi));\n-            return wrap_str(span, context.config.max_width(), shape);\n+pub fn rewrite_struct_field_prefix(\n+    context: &RewriteContext,\n+    field: &ast::StructField,\n+    shape: Shape,\n+) -> Option<String> {\n+    let vis = format_visibility(&field.vis);\n+    let mut attr_str = try_opt!(\n+        field\n+            .attrs\n+            .rewrite(context, Shape::indented(shape.indent, context.config))\n+    );\n+    // Try format missing comments after attributes\n+    let missing_comment = if !field.attrs.is_empty() {\n+        rewrite_missing_comment_on_field(\n+            context,\n+            shape,\n+            field.attrs[field.attrs.len() - 1].span.hi,\n+            field.span.lo,\n+            &mut attr_str,\n+        ).unwrap_or(String::new())\n+    } else {\n+        String::new()\n+    };\n+\n+    let type_annotation_spacing = type_annotation_spacing(context.config);\n+    Some(match field.ident {\n+        Some(name) => {\n+            format!(\n+                \"{}{}{}{}{}:\",\n+                attr_str,\n+                missing_comment,\n+                vis,\n+                name,\n+                type_annotation_spacing.0\n+            )\n         }\n+        None => format!(\"{}{}{}\", attr_str, missing_comment, vis),\n+    })\n+}\n \n-        let name = self.ident;\n-        let vis = format_visibility(&self.vis);\n-        let mut attr_str = try_opt!(\n-            self.attrs\n-                .rewrite(context, Shape::indented(shape.indent, context.config))\n-        );\n-        // Try format missing comments after attributes\n-        let missing_comment = if !self.attrs.is_empty() {\n-            rewrite_missing_comment_on_field(\n-                context,\n-                shape,\n-                self.attrs[self.attrs.len() - 1].span.hi,\n-                self.span.lo,\n-                &mut attr_str,\n-            ).unwrap_or(String::new())\n-        } else {\n-            String::new()\n-        };\n+fn rewrite_struct_field_type(\n+    context: &RewriteContext,\n+    last_line_width: usize,\n+    field: &ast::StructField,\n+    spacing: &str,\n+    shape: Shape,\n+) -> Option<String> {\n+    let ty_shape = try_opt!(shape.offset_left(last_line_width + spacing.len()));\n+    field\n+        .ty\n+        .rewrite(context, ty_shape)\n+        .map(|ty| format!(\"{}{}\", spacing, ty))\n+}\n \n-        let type_annotation_spacing = type_annotation_spacing(context.config);\n-        let mut result = match name {\n-            Some(name) => {\n-                format!(\n-                    \"{}{}{}{}{}:\",\n-                    attr_str,\n-                    missing_comment,\n-                    vis,\n-                    name,\n-                    type_annotation_spacing.0\n-                )\n-            }\n-            None => format!(\"{}{}{}\", attr_str, missing_comment, vis),\n-        };\n \n-        let type_offset = shape.indent.block_indent(context.config);\n-        let rewrite_type_in_next_line = || {\n-            self.ty\n-                .rewrite(context, Shape::indented(type_offset, context.config))\n-        };\n+pub fn rewrite_struct_field(\n+    context: &RewriteContext,\n+    field: &ast::StructField,\n+    shape: Shape,\n+    lhs_max_width: usize,\n+) -> Option<String> {\n+    if contains_skip(&field.attrs) {\n+        let span = context.snippet(mk_sp(field.attrs[0].span.lo, field.span.hi));\n+        return wrap_str(span, context.config.max_width(), shape);\n+    }\n \n-        let last_line_width = last_line_width(&result) + type_annotation_spacing.1.len();\n-        let budget = try_opt!(shape.width.checked_sub(last_line_width));\n-        let ty_rewritten = self.ty.rewrite(\n-            context,\n-            Shape::legacy(budget, shape.indent + last_line_width),\n-        );\n-        match ty_rewritten {\n-            Some(ref ty) if ty.contains('\\n') => {\n-                let new_ty = rewrite_type_in_next_line();\n-                match new_ty {\n-                    Some(ref new_ty)\n-                        if !new_ty.contains('\\n') &&\n-                               new_ty.len() + type_offset.width() <= context.config.max_width() => {\n-                        Some(format!(\n-                            \"{}\\n{}{}\",\n-                            result,\n-                            type_offset.to_string(&context.config),\n-                            &new_ty\n-                        ))\n-                    }\n-                    _ => {\n-                        if name.is_some() {\n-                            result.push_str(type_annotation_spacing.1);\n-                        }\n-                        Some(result + &ty)\n-                    }\n-                }\n-            }\n-            Some(ty) => {\n-                if name.is_some() {\n-                    result.push_str(type_annotation_spacing.1);\n+    let type_annotation_spacing = type_annotation_spacing(context.config);\n+    let prefix = try_opt!(rewrite_struct_field_prefix(context, field, shape));\n+\n+    // Try to put everything on a single line.\n+    let last_line_width = last_line_width(&prefix);\n+    let mut spacing = String::from(if field.ident.is_some() {\n+        type_annotation_spacing.1\n+    } else {\n+        \"\"\n+    });\n+    let lhs_offset = lhs_max_width.checked_sub(last_line_width).unwrap_or(0);\n+    for _ in 0..lhs_offset {\n+        spacing.push(' ');\n+    }\n+    let ty_rewritten = rewrite_struct_field_type(context, last_line_width, field, &spacing, shape);\n+    if let Some(ref ty) = ty_rewritten {\n+        if !ty.contains('\\n') {\n+            return Some(prefix + &ty);\n+        }\n+    }\n+\n+    // We must use multiline.\n+    let type_offset = shape.indent.block_indent(context.config);\n+    let rewrite_type_in_next_line = || {\n+        field\n+            .ty\n+            .rewrite(context, Shape::indented(type_offset, context.config))\n+    };\n+\n+    match ty_rewritten {\n+        // If we start from the next line and type fits in a single line, then do so.\n+        Some(ref ty) => {\n+            match rewrite_type_in_next_line() {\n+                Some(ref new_ty) if !new_ty.contains('\\n') => {\n+                    Some(format!(\n+                        \"{}\\n{}{}\",\n+                        prefix,\n+                        type_offset.to_string(&context.config),\n+                        &new_ty\n+                    ))\n                 }\n-                Some(result + &ty)\n-            }\n-            None => {\n-                let ty = try_opt!(rewrite_type_in_next_line());\n-                Some(format!(\n-                    \"{}\\n{}{}\",\n-                    result,\n-                    type_offset.to_string(&context.config),\n-                    &ty\n-                ))\n+                _ => Some(prefix + &ty),\n             }\n         }\n+        _ => {\n+            let ty = try_opt!(rewrite_type_in_next_line());\n+            Some(format!(\n+                \"{}\\n{}{}\",\n+                prefix,\n+                type_offset.to_string(&context.config),\n+                &ty\n+            ))\n+        }\n     }\n }\n "}, {"sha": "f0c3ebf49a1d0248b9d3b1cd17ec75efc3fa0acd", "filename": "src/lib.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -48,6 +48,7 @@ use filemap::FileMap;\n use visitor::FmtVisitor;\n use config::Config;\n use checkstyle::{output_header, output_footer};\n+use utils::mk_sp;\n \n pub use self::summary::Summary;\n \n@@ -75,6 +76,7 @@ mod chains;\n mod macros;\n mod patterns;\n mod summary;\n+mod vertical;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip.\n@@ -112,6 +114,28 @@ impl Spanned for ast::Arg {\n     }\n }\n \n+impl Spanned for ast::StructField {\n+    fn span(&self) -> Span {\n+        if self.attrs.is_empty() {\n+            mk_sp(self.span.lo, self.ty.span.hi)\n+        } else {\n+            // Include attributes and doc comments, if present\n+            mk_sp(self.attrs[0].span.lo, self.ty.span.hi)\n+        }\n+    }\n+}\n+\n+impl Spanned for ast::Field {\n+    fn span(&self) -> Span {\n+        let lo = if self.attrs.is_empty() {\n+            self.span.lo\n+        } else {\n+            self.attrs[0].span.lo\n+        };\n+        mk_sp(lo, self.span.hi)\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct Indent {\n     // Width of the block indent, in characters. Must be a multiple of\n@@ -398,7 +422,9 @@ pub struct FormatReport {\n \n impl FormatReport {\n     fn new() -> FormatReport {\n-        FormatReport { file_error_map: HashMap::new() }\n+        FormatReport {\n+            file_error_map: HashMap::new(),\n+        }\n     }\n \n     pub fn warning_count(&self) -> usize {"}, {"sha": "d6cb00b55cd3c59590fc72415e4252051dc8fbb3", "filename": "src/lists.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -555,8 +555,13 @@ pub fn struct_lit_shape(\n             }\n         }\n     };\n-    let h_shape = shape.sub_width(prefix_width + suffix_width);\n-    Some((h_shape, v_shape))\n+    let shape_width = shape.width.checked_sub(prefix_width + suffix_width);\n+    if let Some(w) = shape_width {\n+        let shape_width = cmp::min(w, context.config.struct_lit_width());\n+        Some((Some(Shape::legacy(shape_width, shape.indent)), v_shape))\n+    } else {\n+        Some((None, v_shape))\n+    }\n }\n \n // Compute the tactic for the internals of a struct-lit-like thing.\n@@ -566,16 +571,10 @@ pub fn struct_lit_tactic(\n     items: &[ListItem],\n ) -> DefinitiveListTactic {\n     if let Some(h_shape) = h_shape {\n-        let mut prelim_tactic = match (context.config.struct_lit_style(), items.len()) {\n+        let prelim_tactic = match (context.config.struct_lit_style(), items.len()) {\n             (IndentStyle::Visual, 1) => ListTactic::HorizontalVertical,\n             _ => context.config.struct_lit_multiline_style().to_list_tactic(),\n         };\n-\n-        if prelim_tactic == ListTactic::HorizontalVertical && items.len() > 1 {\n-            prelim_tactic =\n-                ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width());\n-        }\n-\n         definitive_tactic(items, prelim_tactic, h_shape.width)\n     } else {\n         DefinitiveListTactic::Vertical"}, {"sha": "cda7a108609e5201db3c9f285897a763c990556b", "filename": "src/patterns.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -10,12 +10,12 @@\n \n use Shape;\n use codemap::SpanUtils;\n-use config::{IndentStyle, MultilineStyle};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{wrap_str, format_mutability, mk_sp};\n use lists::{DefinitiveListTactic, SeparatorTactic, itemize_list, struct_lit_shape,\n             struct_lit_tactic, shape_for_tactic, struct_lit_formatting, write_list};\n-use expr::{rewrite_call_inner, rewrite_unary_prefix, rewrite_pair, can_be_overflowed_expr};\n+use expr::{rewrite_call_inner, rewrite_unary_prefix, rewrite_pair, can_be_overflowed_expr,\n+           wrap_struct_field};\n use types::{rewrite_path, PathContext};\n use super::Spanned;\n use comment::FindUncommented;\n@@ -181,9 +181,10 @@ fn rewrite_struct_pat(\n     let fmt = struct_lit_formatting(nested_shape, tactic, context, false);\n \n     let mut fields_str = try_opt!(write_list(&item_vec, &fmt));\n+    let one_line_width = h_shape.map_or(0, |shape| shape.width);\n \n     if elipses {\n-        if fields_str.contains('\\n') {\n+        if fields_str.contains('\\n') || fields_str.len() > one_line_width {\n             // Add a missing trailing comma.\n             if fmt.trailing_separator == SeparatorTactic::Never {\n                 fields_str.push_str(\",\");\n@@ -205,23 +206,7 @@ fn rewrite_struct_pat(\n         }\n     }\n \n-\n-    let fields_str = if context.config.struct_lit_style() == IndentStyle::Block &&\n-        (fields_str.contains('\\n') ||\n-             context.config.struct_lit_multiline_style() == MultilineStyle::ForceMulti ||\n-             fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0))\n-    {\n-        format!(\n-            \"\\n{}{}\\n{}\",\n-            v_shape.indent.to_string(context.config),\n-            fields_str,\n-            shape.indent.to_string(context.config)\n-        )\n-    } else {\n-        // One liner or visual indent.\n-        format!(\" {} \", fields_str)\n-    };\n-\n+    let fields_str = wrap_struct_field(context, &fields_str, shape, v_shape, one_line_width);\n     Some(format!(\"{} {{{}}}\", path_str, fields_str))\n }\n "}, {"sha": "d6b344435186fc2f8f924126ebb65ec8eab79743", "filename": "src/vertical.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -0,0 +1,271 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Format with vertical alignment.\n+\n+use std::cmp;\n+\n+use {Indent, Shape, Spanned};\n+use codemap::SpanUtils;\n+use comment::contains_comment;\n+use expr::rewrite_field;\n+use items::{rewrite_struct_field, rewrite_struct_field_prefix};\n+use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListTactic};\n+use rewrite::{Rewrite, RewriteContext};\n+use utils::{contains_skip, mk_sp};\n+\n+use syntax::ast;\n+use syntax::codemap::{Span, BytePos};\n+\n+pub trait AlignedItem {\n+    fn skip(&self) -> bool;\n+    fn get_span(&self) -> Span;\n+    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String>;\n+    fn rewrite_aligned_item(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        prefix_max_width: usize,\n+    ) -> Option<String>;\n+}\n+\n+impl AlignedItem for ast::StructField {\n+    fn skip(&self) -> bool {\n+        contains_skip(&self.attrs)\n+    }\n+\n+    fn get_span(&self) -> Span {\n+        self.span()\n+    }\n+\n+    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        rewrite_struct_field_prefix(context, self, shape)\n+    }\n+\n+    fn rewrite_aligned_item(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        prefix_max_width: usize,\n+    ) -> Option<String> {\n+        rewrite_struct_field(context, self, shape, prefix_max_width)\n+    }\n+}\n+\n+impl AlignedItem for ast::Field {\n+    fn skip(&self) -> bool {\n+        contains_skip(&self.attrs)\n+    }\n+\n+    fn get_span(&self) -> Span {\n+        self.span()\n+    }\n+\n+    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let mut attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n+        if !attrs_str.is_empty() {\n+            attrs_str.push_str(&format!(\"\\n{}\", shape.indent.to_string(context.config)));\n+        };\n+        let name = &self.ident.node.to_string();\n+        Some(format!(\"{}{}\", attrs_str, name))\n+    }\n+\n+    fn rewrite_aligned_item(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        prefix_max_width: usize,\n+    ) -> Option<String> {\n+        rewrite_field(context, self, shape, prefix_max_width)\n+    }\n+}\n+\n+pub fn rewrite_with_alignment<T: AlignedItem>(\n+    fields: &[T],\n+    context: &RewriteContext,\n+    shape: Shape,\n+    span: Span,\n+    one_line_width: usize,\n+) -> Option<String> {\n+    let (spaces, group_index) = if context.config.struct_field_align_threshold() > 0 {\n+        group_aligned_items(context, fields)\n+    } else {\n+        (\"\", fields.len() - 1)\n+    };\n+    let init = &fields[0..group_index + 1];\n+    let rest = &fields[group_index + 1..];\n+    let init_last_pos = if rest.is_empty() {\n+        span.hi\n+    } else {\n+        // Decide whether the missing comments should stick to init or rest.\n+        let init_hi = init[init.len() - 1].get_span().hi;\n+        let rest_lo = rest[0].get_span().lo;\n+        let missing_span = mk_sp(init_hi, rest_lo);\n+        let missing_span = mk_sp(\n+            context.codemap.span_after(missing_span, \",\"),\n+            missing_span.hi,\n+        );\n+\n+        let snippet = context.snippet(missing_span);\n+        if snippet.trim_left().starts_with(\"//\") {\n+            let offset = snippet.lines().next().map_or(0, |l| l.len());\n+            // 2 = \",\" + \"\\n\"\n+            init_hi + BytePos(offset as u32 + 2)\n+        } else if snippet.trim_left().starts_with(\"/*\") {\n+            let comment_lines = snippet\n+                .lines()\n+                .position(|line| line.trim_right().ends_with(\"*/\"))\n+                .unwrap_or(0);\n+\n+            let offset = snippet\n+                .lines()\n+                .take(comment_lines + 1)\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\")\n+                .len();\n+\n+            init_hi + BytePos(offset as u32 + 2)\n+        } else {\n+            missing_span.lo\n+        }\n+    };\n+    let init_span = mk_sp(span.lo, init_last_pos);\n+    let one_line_width = if rest.is_empty() { one_line_width } else { 0 };\n+    let result = try_opt!(rewrite_aligned_items_inner(\n+        context,\n+        init,\n+        init_span,\n+        shape.indent,\n+        one_line_width,\n+    ));\n+    if rest.is_empty() {\n+        Some(result + spaces)\n+    } else {\n+        let rest_span = mk_sp(init_last_pos, span.hi);\n+        let rest_str = try_opt!(rewrite_with_alignment(\n+            rest,\n+            context,\n+            shape,\n+            rest_span,\n+            one_line_width,\n+        ));\n+        Some(\n+            result + spaces + \"\\n\" +\n+                &shape\n+                    .indent\n+                    .block_indent(context.config)\n+                    .to_string(context.config) + &rest_str,\n+        )\n+    }\n+}\n+\n+fn struct_field_preix_max_min_width<T: AlignedItem>(\n+    context: &RewriteContext,\n+    fields: &[T],\n+    shape: Shape,\n+) -> (usize, usize) {\n+    fields\n+        .iter()\n+        .map(|field| {\n+            field.rewrite_prefix(context, shape).and_then(\n+                |field_str| if field_str.contains('\\n') {\n+                    None\n+                } else {\n+                    Some(field_str.len())\n+                },\n+            )\n+        })\n+        .fold(Some((0, ::std::usize::MAX)), |acc, len| match (acc, len) {\n+            (Some((max_len, min_len)), Some(len)) => {\n+                Some((cmp::max(max_len, len), cmp::min(min_len, len)))\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or((0, 0))\n+}\n+\n+fn rewrite_aligned_items_inner<T: AlignedItem>(\n+    context: &RewriteContext,\n+    fields: &[T],\n+    span: Span,\n+    offset: Indent,\n+    one_line_width: usize,\n+) -> Option<String> {\n+    let item_indent = offset.block_indent(context.config);\n+    // 1 = \",\"\n+    let item_shape = try_opt!(Shape::indented(item_indent, context.config).sub_width(1));\n+    let (mut field_prefix_max_width, field_prefix_min_width) =\n+        struct_field_preix_max_min_width(context, fields, item_shape);\n+    let max_diff = field_prefix_max_width\n+        .checked_sub(field_prefix_min_width)\n+        .unwrap_or(0);\n+    if max_diff > context.config.struct_field_align_threshold() {\n+        field_prefix_max_width = 0;\n+    }\n+\n+    let items = itemize_list(\n+        context.codemap,\n+        fields.iter(),\n+        \"}\",\n+        |field| field.get_span().lo,\n+        |field| field.get_span().hi,\n+        |field| field.rewrite_aligned_item(context, item_shape, field_prefix_max_width),\n+        span.lo,\n+        span.hi,\n+    ).collect::<Vec<_>>();\n+\n+    let tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, one_line_width);\n+\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: context.config.trailing_comma(),\n+        shape: item_shape,\n+        ends_with_newline: true,\n+        config: context.config,\n+    };\n+    write_list(&items, &fmt)\n+}\n+\n+fn group_aligned_items<T: AlignedItem>(\n+    context: &RewriteContext,\n+    fields: &[T],\n+) -> (&'static str, usize) {\n+    let mut index = 0;\n+    for i in 0..fields.len() - 1 {\n+        if fields[i].skip() {\n+            return (\"\", index);\n+        }\n+        // See if there are comments or empty lines between fields.\n+        let span = mk_sp(fields[i].get_span().hi, fields[i + 1].get_span().lo);\n+        let snippet = context\n+            .snippet(span)\n+            .lines()\n+            .skip(1)\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let spacings = if snippet\n+            .lines()\n+            .rev()\n+            .skip(1)\n+            .find(|l| l.trim().is_empty())\n+            .is_some()\n+        {\n+            \"\\n\"\n+        } else {\n+            \"\"\n+        };\n+        if contains_comment(&snippet) || snippet.lines().count() > 1 {\n+            return (spacings, index);\n+        }\n+        index += 1;\n+    }\n+    (\"\", index)\n+}"}, {"sha": "3f37d72f3c6049b1d6eea1d5593e9ffbb7137497", "filename": "tests/source/configs-struct_field_align_threshold-20.rs", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/tests%2Fsource%2Fconfigs-struct_field_align_threshold-20.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/tests%2Fsource%2Fconfigs-struct_field_align_threshold-20.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs-struct_field_align_threshold-20.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -0,0 +1,383 @@\n+// rustfmt-struct_field_align_threshold: 20\n+// rustfmt-normalize_comments: true\n+// rustfmt-wrap_comments: true\n+// rustfmt-error_on_line_overflow: false\n+\n+struct Foo {\n+    x: u32,\n+    yy: u32, // comment\n+    zzz: u32,\n+}\n+\n+pub struct Bar {\n+    x: u32,\n+    yy: u32,\n+    zzz: u32,\n+\n+    xxxxxxx: u32,\n+}\n+\n+fn main() {\n+    let foo = Foo {\n+        x: 0,\n+        yy: 1,\n+        zzz: 2,\n+    };\n+\n+    let bar = Bar {\n+        x: 0,\n+        yy: 1,\n+        zzz: 2,\n+\n+        xxxxxxx: 3,\n+    };\n+}\n+\n+                                                                       /// A Doc comment\n+#[AnAttribute]\n+pub struct Foo {\n+    #[rustfmt_skip]\n+    f :   SomeType, // Comment beside a field\n+    f: SomeType, // Comment beside a field\n+    // Comment on a field\n+    #[AnAttribute]\n+    g: SomeOtherType,\n+      /// A doc comment on a field\n+    h: AThirdType,\n+    pub i: TypeForPublicField\n+}\n+\n+// #1029\n+pub struct Foo {\n+    #[doc(hidden)]\n+    // This will NOT get deleted!\n+    bar: String, // hi\n+}\n+\n+// #1029\n+struct X {\n+    // `x` is an important number.\n+    #[allow(unused)] // TODO: use\n+    x: u32,\n+}\n+\n+// #410\n+#[allow(missing_docs)]\n+pub struct Writebatch<K: Key> {\n+    #[allow(dead_code)] //only used for holding the internal pointer\n+    writebatch: RawWritebatch,\n+    marker: PhantomData<K>,\n+}\n+\n+struct Bar;\n+\n+struct NewType(Type,       OtherType);\n+\n+struct\n+NewInt     <T: Copy>(pub i32, SomeType /* inline comment */, T /* sup */\n+\n+\n+    );\n+\n+struct Qux<'a,\n+           N: Clone + 'a,\n+           E: Clone + 'a,\n+           G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n+           W: Write + Copy>\n+(\n+    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // Comment\n+    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\n+    #[AnAttr]\n+    // Comment\n+    /// Testdoc\n+    G,\n+    pub W,\n+);\n+\n+struct Tuple(/*Comment 1*/ AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n+             /* Comment 2   */ BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,);\n+\n+// With a where clause and generics.\n+pub struct Foo<'a, Y: Baz>\n+    where X: Whatever\n+{\n+    f: SomeType, // Comment beside a field\n+}\n+\n+struct Baz {\n+\n+    a: A,  // Comment A\n+    b: B, // Comment B\n+    c: C,   // Comment C\n+\n+}\n+\n+struct Baz {\n+    a: A,  // Comment A\n+\n+    b: B, // Comment B\n+\n+\n+\n+\n+    c: C,   // Comment C\n+}\n+\n+struct Baz {\n+\n+    a: A,\n+\n+    b: B,\n+    c: C,\n+\n+\n+\n+    \n+    d: D\n+\n+}\n+\n+struct Baz\n+{\n+    // Comment A\n+    a: A,\n+    \n+    // Comment B\n+b: B,\n+    // Comment C\n+      c: C,}\n+\n+// Will this be a one-liner?\n+struct Tuple(\n+    A, //Comment\n+    B\n+);\n+\n+pub struct State<F: FnMut() -> time::Timespec> { now: F }\n+\n+pub struct State<F: FnMut() -> ()> { now: F }\n+\n+pub struct State<F: FnMut()> { now: F }\n+\n+struct Palette { /// A map of indizes in the palette to a count of pixels in approximately that color\n+                    foo: i32}\n+\n+// Splitting a single line comment into a block previously had a misalignment\n+// when the field had attributes\n+struct FieldsWithAttributes {\n+    // Pre Comment\n+    #[rustfmt_skip] pub host:String, // Post comment BBBBBBBBBBBBBB BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBBB BBBBBBBBBBB\n+    //Another pre comment\n+    #[attr1]\n+    #[attr2] pub id: usize // CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCC CCCCCCCCCCCC\n+}\n+\n+struct Deep {\n+    deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeep: node::Handle<IdRef<'id, Node<K, V>>,\n+                                                     Type,\n+                                                     NodeType>,\n+}\n+\n+struct Foo<T>(T);\n+struct Foo<T>(T) where T: Copy, T: Eq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUU);\n+struct Foo<T>(TTTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTT) where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTTTT) where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUU) where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, // Foo\n+              UUUUUUUUUUUUUUUUUUUUUUUU /* Bar */,\n+              // Baz\n+              TTTTTTTTTTTTTTTTTTT,\n+              // Qux (FIXME #572 - doc comment)\n+              UUUUUUUUUUUUUUUUUUU);\n+\n+mod m {\n+    struct X<T> where T: Sized {\n+        a: T,\n+    }\n+}\n+\n+struct Foo<T>(TTTTTTTTTTTTTTTTTTT,\n+              /// Qux\n+    UUUUUUUUUUUUUUUUUUU);\n+\n+struct Issue677 {\n+    pub ptr: *const libc::c_void,\n+    pub trace: fn(  obj: \n+          *const libc::c_void, tracer   : *mut   JSTracer   ),\n+}\n+\n+struct Foo {}\n+struct Foo {\n+    }\n+struct Foo {\n+    // comment\n+    }\n+struct Foo {\n+    // trailing space ->    \n+\n+\n+    }\n+struct Foo { /* comment */ }\n+struct Foo( /* comment */ );\n+\n+struct LongStruct {\n+    a: A,\n+    the_quick_brown_fox_jumps_over_the_lazy_dog:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n+}\n+\n+struct Deep {\n+    deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeep: node::Handle<IdRef<'id, Node<Key, Value>>,\n+                                                                         Type,\n+                                                                         NodeType>,\n+}\n+\n+struct Foo<C=()>(String);\n+\n+// #1364\n+fn foo() {\n+    convex_shape.set_point(0, &Vector2f { x: 400.0, y: 100.0 });\n+    convex_shape.set_point(1, &Vector2f { x: 500.0, y: 70.0 });\n+    convex_shape.set_point(2, &Vector2f { x: 450.0, y: 100.0 });\n+    convex_shape.set_point(3, &Vector2f { x: 580.0, y: 150.0 });\n+}\n+\n+fn main() {\n+    let x = Bar;\n+\n+    // Comment\n+    let y = Foo {a: x };\n+\n+    Foo { a: foo() /* comment*/, /* comment*/ b: bar(), ..something };\n+\n+    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: f(), b: b(), };\n+\n+    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: f(), b: b(), };\n+\n+    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo {\n+        // Comment\n+        a: foo(), // Comment\n+        // Comment\n+        b: bar(), // Comment\n+    };\n+\n+    Foo { a:Bar,\n+          b:f() };\n+\n+    Quux { x: if cond { bar(); }, y: baz() };\n+\n+    A { \n+    // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante hendrerit. Donec et mollis dolor.\n+    first: item(),\n+        // Praesent et diam eget libero egestas mattis sit amet vitae augue.\n+        // Nam tincidunt congue enim, ut porta lorem lacinia consectetur.\n+        second: Item\n+    };\n+\n+    Some(Data::MethodCallData(MethodCallData {\n+        span: sub_span.unwrap(),\n+        scope: self.enclosing_scope(id),\n+        ref_id: def_id,\n+        decl_id: Some(decl_id),\n+    }));\n+\n+    Diagram { /*                 o        This graph demonstrates how                  \n+               *                / \\       significant whitespace is           \n+               *               o   o      preserved.  \n+               *              /|\\   \\\n+               *             o o o   o */\n+              graph: G, }\n+}\n+\n+fn matcher() {\n+    TagTerminatedByteMatcher {\n+        matcher: ByteMatcher {\n+        pattern: b\"<HTML\",\n+        mask: b\"\\xFF\\xDF\\xDF\\xDF\\xDF\\xFF\",\n+    },\n+    };\n+}\n+\n+fn issue177() {\n+    struct Foo<T> { memb: T }\n+    let foo = Foo::<i64> { memb: 10 };\n+}\n+\n+fn issue201() {\n+    let s = S{a:0, ..  b};\n+}\n+\n+fn issue201_2() {\n+    let s = S{a: S2{    .. c}, ..  b};\n+}\n+\n+fn issue278() {\n+    let s = S {\n+        a: 0,\n+        //       \n+        b: 0,\n+    };\n+    let s1 = S {\n+        a: 0,\n+        // foo\n+        //      \n+        // bar\n+        b: 0,\n+    };\n+}\n+\n+fn struct_exprs() {\n+    Foo\n+    { a :  1, b:f( 2)};\n+    Foo{a:1,b:f(2),..g(3)};\n+    LoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooongStruct { ..base };\n+    IntrinsicISizesContribution { content_intrinsic_sizes: IntrinsicISizes { minimum_inline_size: 0, }, };\n+}\n+\n+fn issue123() {\n+    Foo { a: b, c: d, e: f };\n+\n+    Foo { a: bb, c: dd, e: ff };\n+\n+    Foo { a: ddddddddddddddddddddd, b: cccccccccccccccccccccccccccccccccccccc };\n+}\n+\n+fn issue491() {\n+    Foo {\n+        guard: None,\n+        arm: 0, // Comment\n+    };\n+\n+    Foo {\n+        arm: 0, // Comment\n+    };\n+\n+    Foo { a: aaaaaaaaaa, b: bbbbbbbb, c: cccccccccc, d: dddddddddd, /* a comment */\n+      e: eeeeeeeee };\n+}\n+\n+fn issue698() {\n+    Record {\n+        ffffffffffffffffffffffffffields: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    };\n+    Record {\n+        ffffffffffffffffffffffffffields: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    }\n+}\n+\n+fn issue835() {\n+    MyStruct {};\n+    MyStruct { /* a comment */ };\n+    MyStruct {\n+        // Another comment\n+    };\n+    MyStruct {}\n+}\n+\n+fn field_init_shorthand() {\n+    MyStruct { x, y, z };\n+    MyStruct { x, y, z, .. base };\n+    Foo { aaaaaaaaaa, bbbbbbbb, cccccccccc, dddddddddd, /* a comment */\n+        eeeeeeeee };\n+    Record { ffffffffffffffffffffffffffieldsaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa };\n+}"}, {"sha": "bd507667f25116a3f91e933c7f386d9266e09442", "filename": "tests/source/structs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/tests%2Fsource%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/tests%2Fsource%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstructs.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -1,6 +1,5 @@\n // rustfmt-normalize_comments: true\n // rustfmt-wrap_comments: true\n-// rustfmt-error_on_line_overflow: false\n \n                                                                        /// A Doc comment\n #[AnAttribute]"}, {"sha": "fa14f3c86472ba0e0dd7af8b63a86df344de7da1", "filename": "tests/target/attrib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fattrib.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -56,8 +56,12 @@ struct Foo {\n fn foo() {\n     #[cfg(target_os = \"freertos\")]\n     match port_id {\n-        'a' | 'A' => GpioPort { port_address: GPIO_A },\n-        'b' | 'B' => GpioPort { port_address: GPIO_B },\n+        'a' | 'A' => GpioPort {\n+            port_address: GPIO_A,\n+        },\n+        'b' | 'B' => GpioPort {\n+            port_address: GPIO_B,\n+        },\n         _ => panic!(),\n     }\n "}, {"sha": "db3458bda153d2c5c1c0773875ec49f23d9575e6", "filename": "tests/target/configs-struct_field_align_threshold-20.rs", "status": "added", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fconfigs-struct_field_align_threshold-20.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fconfigs-struct_field_align_threshold-20.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-struct_field_align_threshold-20.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -0,0 +1,451 @@\n+// rustfmt-struct_field_align_threshold: 20\n+// rustfmt-normalize_comments: true\n+// rustfmt-wrap_comments: true\n+// rustfmt-error_on_line_overflow: false\n+\n+struct Foo {\n+    x:   u32,\n+    yy:  u32, // comment\n+    zzz: u32,\n+}\n+\n+pub struct Bar {\n+    x:   u32,\n+    yy:  u32,\n+    zzz: u32,\n+\n+    xxxxxxx: u32,\n+}\n+\n+fn main() {\n+    let foo = Foo {\n+        x:   0,\n+        yy:  1,\n+        zzz: 2,\n+    };\n+\n+    let bar = Bar {\n+        x:   0,\n+        yy:  1,\n+        zzz: 2,\n+\n+        xxxxxxx: 3,\n+    };\n+}\n+\n+/// A Doc comment\n+#[AnAttribute]\n+pub struct Foo {\n+    #[rustfmt_skip]\n+    f :   SomeType, // Comment beside a field\n+    f: SomeType, // Comment beside a field\n+    // Comment on a field\n+    #[AnAttribute]\n+    g: SomeOtherType,\n+    /// A doc comment on a field\n+    h: AThirdType,\n+    pub i: TypeForPublicField,\n+}\n+\n+// #1029\n+pub struct Foo {\n+    #[doc(hidden)]\n+    // This will NOT get deleted!\n+    bar: String, // hi\n+}\n+\n+// #1029\n+struct X {\n+    // `x` is an important number.\n+    #[allow(unused)] // TODO: use\n+    x: u32,\n+}\n+\n+// #410\n+#[allow(missing_docs)]\n+pub struct Writebatch<K: Key> {\n+    #[allow(dead_code)] // only used for holding the internal pointer\n+    writebatch: RawWritebatch,\n+    marker: PhantomData<K>,\n+}\n+\n+struct Bar;\n+\n+struct NewType(Type, OtherType);\n+\n+struct NewInt<T: Copy>(pub i32, SomeType /* inline comment */, T /* sup */);\n+\n+struct Qux<'a,\n+           N: Clone + 'a,\n+           E: Clone + 'a,\n+           G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n+           W: Write + Copy>\n+(\n+    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // Comment\n+    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\n+    #[AnAttr]\n+    // Comment\n+    /// Testdoc\n+    G,\n+    pub W,\n+);\n+\n+struct Tuple(\n+    // Comment 1\n+    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n+    // Comment 2\n+    BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+);\n+\n+// With a where clause and generics.\n+pub struct Foo<'a, Y: Baz>\n+where\n+    X: Whatever,\n+{\n+    f: SomeType, // Comment beside a field\n+}\n+\n+struct Baz {\n+    a: A, // Comment A\n+    b: B, // Comment B\n+    c: C, // Comment C\n+}\n+\n+struct Baz {\n+    a: A, // Comment A\n+\n+    b: B, // Comment B\n+\n+    c: C, // Comment C\n+}\n+\n+struct Baz {\n+    a: A,\n+\n+    b: B,\n+    c: C,\n+\n+    d: D,\n+}\n+\n+struct Baz {\n+    // Comment A\n+    a: A,\n+\n+    // Comment B\n+    b: B,\n+    // Comment C\n+    c: C,\n+}\n+\n+// Will this be a one-liner?\n+struct Tuple(A /* Comment */, B);\n+\n+pub struct State<F: FnMut() -> time::Timespec> {\n+    now: F,\n+}\n+\n+pub struct State<F: FnMut() -> ()> {\n+    now: F,\n+}\n+\n+pub struct State<F: FnMut()> {\n+    now: F,\n+}\n+\n+struct Palette {\n+    /// A map of indizes in the palette to a count of pixels in approximately\n+    /// that color\n+    foo: i32,\n+}\n+\n+// Splitting a single line comment into a block previously had a misalignment\n+// when the field had attributes\n+struct FieldsWithAttributes {\n+    // Pre Comment\n+    #[rustfmt_skip] pub host:String, /* Post comment BBBBBBBBBBBBBB BBBBBBBBBBBBBBBB\n+                                      * BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBBB BBBBBBBBBBB */\n+    // Another pre comment\n+    #[attr1]\n+    #[attr2]\n+    pub id: usize, /* CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC\n+                    * CCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCC CCCCCCCCCCCC */\n+}\n+\n+struct Deep {\n+    deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeep:\n+        node::Handle<IdRef<'id, Node<K, V>>, Type, NodeType>,\n+}\n+\n+struct Foo<T>(T);\n+struct Foo<T>(T)\n+where\n+    T: Copy,\n+    T: Eq;\n+struct Foo<T>(\n+    TTTTTTTTTTTTTTTTT,\n+    UUUUUUUUUUUUUUUUUUUUUUUU,\n+    TTTTTTTTTTTTTTTTTTT,\n+    UUUUUUUUUUUUUUUUUUU\n+);\n+struct Foo<T>(TTTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTT)\n+where\n+    T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTTTT)\n+where\n+    T: PartialEq;\n+struct Foo<T>(\n+    TTTTTTTTTTTTTTTTT,\n+    UUUUUUUUUUUUUUUUUUUUUUUU,\n+    TTTTTTTTTTTTTTTTTTT,\n+    UUUUUUUUUUUUUUUUUUU\n+)\n+where\n+    T: PartialEq;\n+struct Foo<T>(\n+    TTTTTTTTTTTTTTTTT, // Foo\n+    UUUUUUUUUUUUUUUUUUUUUUUU, // Bar\n+    // Baz\n+    TTTTTTTTTTTTTTTTTTT,\n+    // Qux (FIXME #572 - doc comment)\n+    UUUUUUUUUUUUUUUUUUU\n+);\n+\n+mod m {\n+    struct X<T>\n+    where\n+        T: Sized,\n+    {\n+        a: T,\n+    }\n+}\n+\n+struct Foo<T>(\n+    TTTTTTTTTTTTTTTTTTT,\n+    /// Qux\n+    UUUUUUUUUUUUUUUUUUU\n+);\n+\n+struct Issue677 {\n+    pub ptr:   *const libc::c_void,\n+    pub trace: fn(obj: *const libc::c_void, tracer: *mut JSTracer),\n+}\n+\n+struct Foo {}\n+struct Foo {}\n+struct Foo {\n+    // comment\n+}\n+struct Foo {\n+    // trailing space ->\n+}\n+struct Foo { /* comment */ }\n+struct Foo( /* comment */ );\n+\n+struct LongStruct {\n+    a: A,\n+    the_quick_brown_fox_jumps_over_the_lazy_dog:\n+        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,\n+}\n+\n+struct Deep {\n+    deeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeep:\n+        node::Handle<IdRef<'id, Node<Key, Value>>, Type, NodeType>,\n+}\n+\n+struct Foo<C = ()>(String);\n+\n+// #1364\n+fn foo() {\n+    convex_shape.set_point(0, &Vector2f { x: 400.0, y: 100.0 });\n+    convex_shape.set_point(1, &Vector2f { x: 500.0, y: 70.0 });\n+    convex_shape.set_point(2, &Vector2f { x: 450.0, y: 100.0 });\n+    convex_shape.set_point(3, &Vector2f { x: 580.0, y: 150.0 });\n+}\n+\n+fn main() {\n+    let x = Bar;\n+\n+    // Comment\n+    let y = Foo { a: x };\n+\n+    Foo {\n+        a: foo(), // comment\n+        // comment\n+        b: bar(),\n+        ..something\n+    };\n+\n+    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: f(), b: b() };\n+\n+    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo {\n+        a: f(),\n+        b: b(),\n+    };\n+\n+    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo {\n+        // Comment\n+        a: foo(), // Comment\n+        // Comment\n+        b: bar(), // Comment\n+    };\n+\n+    Foo { a: Bar, b: f() };\n+\n+    Quux {\n+        x: if cond {\n+            bar();\n+        },\n+        y: baz(),\n+    };\n+\n+    A {\n+        // Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec a diam lectus. Sed sit\n+        // amet ipsum mauris. Maecenas congue ligula ac quam viverra nec consectetur ante\n+        // hendrerit. Donec et mollis dolor.\n+        first: item(),\n+        // Praesent et diam eget libero egestas mattis sit amet vitae augue.\n+        // Nam tincidunt congue enim, ut porta lorem lacinia consectetur.\n+        second: Item,\n+    };\n+\n+    Some(Data::MethodCallData(MethodCallData {\n+        span:    sub_span.unwrap(),\n+        scope:   self.enclosing_scope(id),\n+        ref_id:  def_id,\n+        decl_id: Some(decl_id),\n+    }));\n+\n+    Diagram {\n+        //                 o        This graph demonstrates how\n+        //                / \\       significant whitespace is\n+        //               o   o      preserved.\n+        //              /|\\   \\\n+        //             o o o   o\n+        graph: G,\n+    }\n+}\n+\n+fn matcher() {\n+    TagTerminatedByteMatcher {\n+        matcher: ByteMatcher {\n+            pattern: b\"<HTML\",\n+            mask:    b\"\\xFF\\xDF\\xDF\\xDF\\xDF\\xFF\",\n+        },\n+    };\n+}\n+\n+fn issue177() {\n+    struct Foo<T> {\n+        memb: T,\n+    }\n+    let foo = Foo::<i64> { memb: 10 };\n+}\n+\n+fn issue201() {\n+    let s = S { a: 0, ..b };\n+}\n+\n+fn issue201_2() {\n+    let s = S { a: S2 { ..c }, ..b };\n+}\n+\n+fn issue278() {\n+    let s = S {\n+        a: 0,\n+        //\n+        b: 0,\n+    };\n+    let s1 = S {\n+        a: 0,\n+        // foo\n+        //\n+        // bar\n+        b: 0,\n+    };\n+}\n+\n+fn struct_exprs() {\n+    Foo { a: 1, b: f(2) };\n+    Foo {\n+        a: 1,\n+        b: f(2),\n+        ..g(3)\n+    };\n+    LoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooongStruct {\n+        ..base\n+    };\n+    IntrinsicISizesContribution {\n+        content_intrinsic_sizes: IntrinsicISizes {\n+            minimum_inline_size: 0,\n+        },\n+    };\n+}\n+\n+fn issue123() {\n+    Foo { a: b, c: d, e: f };\n+\n+    Foo {\n+        a: bb,\n+        c: dd,\n+        e: ff,\n+    };\n+\n+    Foo {\n+        a: ddddddddddddddddddddd,\n+        b: cccccccccccccccccccccccccccccccccccccc,\n+    };\n+}\n+\n+fn issue491() {\n+    Foo {\n+        guard: None,\n+        arm:   0, // Comment\n+    };\n+\n+    Foo {\n+        arm: 0, // Comment\n+    };\n+\n+    Foo {\n+        a: aaaaaaaaaa,\n+        b: bbbbbbbb,\n+        c: cccccccccc,\n+        d: dddddddddd, // a comment\n+        e: eeeeeeeee,\n+    };\n+}\n+\n+fn issue698() {\n+    Record {\n+        ffffffffffffffffffffffffffields: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    };\n+    Record {\n+        ffffffffffffffffffffffffffields:\n+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    }\n+}\n+\n+fn issue835() {\n+    MyStruct {};\n+    MyStruct { /* a comment */ };\n+    MyStruct {\n+        // Another comment\n+    };\n+    MyStruct {}\n+}\n+\n+fn field_init_shorthand() {\n+    MyStruct { x, y, z };\n+    MyStruct { x, y, z, ..base };\n+    Foo {\n+        aaaaaaaaaa,\n+        bbbbbbbb,\n+        cccccccccc,\n+        dddddddddd, // a comment\n+        eeeeeeeee,\n+    };\n+    Record {\n+        ffffffffffffffffffffffffffieldsaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+    };\n+}"}, {"sha": "86b7a78411f3250e223f7fe1a2233fdd2ea1b684", "filename": "tests/target/issue-1397.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fissue-1397.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fissue-1397.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1397.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -12,7 +12,8 @@ fn baz(p: Packet) {\n             loop {\n                 loop {\n                     if let Packet::Transaction {\n-                        state: TransactionState::Committed(ts, ..), ..\n+                        state: TransactionState::Committed(ts, ..),\n+                        ..\n                     } = p\n                     {\n                         unreachable!()"}, {"sha": "dc5600c7d5d9bf0698f75725e247f20e24296feb", "filename": "tests/target/issue-855.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fissue-855.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fissue-855.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-855.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -3,7 +3,10 @@ fn main() {\n         for event in event_pump.poll_iter() {\n             match event {\n                 Event::Quit { .. } |\n-                Event::KeyDown { keycode: Some(Keycode::Escape), .. } => break 'running,\n+                Event::KeyDown {\n+                    keycode: Some(Keycode::Escape),\n+                    ..\n+                } => break 'running,\n             }\n         }\n     }\n@@ -14,9 +17,10 @@ fn main2() {\n         for event in event_pump.poll_iter() {\n             match event {\n                 Event::Quit { .. } |\n-                Event::KeyDownXXXXXXXXXXXXX { keycode: Some(Keycode::Escape), .. } => {\n-                    break 'running\n-                }\n+                Event::KeyDownXXXXXXXXXXXXX {\n+                    keycode: Some(Keycode::Escape),\n+                    ..\n+                } => break 'running,\n             }\n         }\n     }"}, {"sha": "648c723d35738d8578b269607c4ce3d8e6dfa752", "filename": "tests/target/struct_lits.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstruct_lits.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -116,7 +116,9 @@ fn struct_exprs() {\n         ..base\n     };\n     IntrinsicISizesContribution {\n-        content_intrinsic_sizes: IntrinsicISizes { minimum_inline_size: 0 },\n+        content_intrinsic_sizes: IntrinsicISizes {\n+            minimum_inline_size: 0,\n+        },\n     };\n }\n \n@@ -141,7 +143,9 @@ fn issue491() {\n         arm: 0, // Comment\n     };\n \n-    Foo { arm: 0 /* Comment */ };\n+    Foo {\n+        arm: 0, // Comment\n+    };\n \n     Foo {\n         a: aaaaaaaaaa,"}, {"sha": "541abd36c7c2c77797259ff1b21caabf3bb4c8a0", "filename": "tests/target/structs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734de8b2b7db58e15706721d0a28d55571850505/tests%2Ftarget%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstructs.rs?ref=734de8b2b7db58e15706721d0a28d55571850505", "patch": "@@ -1,6 +1,5 @@\n // rustfmt-normalize_comments: true\n // rustfmt-wrap_comments: true\n-// rustfmt-error_on_line_overflow: false\n \n /// A Doc comment\n #[AnAttribute]\n@@ -132,13 +131,13 @@ struct Palette {\n // when the field had attributes\n struct FieldsWithAttributes {\n     // Pre Comment\n-    #[rustfmt_skip] pub host:String, /* Post comment BBBBBBBBBBBBBB BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBB\n-                                      * BBBBBBBBBBBBBBBBB BBBBBBBBBBB */\n+    #[rustfmt_skip] pub host:String, /* Post comment BBBBBBBBBBBBBB BBBBBBBBBBBBBBBB\n+                                      * BBBBBBBBBBBBBBBB BBBBBBBBBBBBBBBBB BBBBBBBBBBB */\n     // Another pre comment\n     #[attr1]\n     #[attr2]\n-    pub id: usize, /* CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCC\n-                    * CCCCCCCCCCCCCC CCCCCCCCCCCC */\n+    pub id: usize, /* CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCCCC\n+                    * CCCCCCCCCCCCCCCCCC CCCCCCCCCCCCCC CCCCCCCCCCCC */\n }\n \n struct Deep {"}]}