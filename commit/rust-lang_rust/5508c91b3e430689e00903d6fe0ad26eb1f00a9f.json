{"sha": "5508c91b3e430689e00903d6fe0ad26eb1f00a9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MDhjOTFiM2U0MzA2ODllMDA5MDNkNmZlMGFkMjZlYjFmMDBhOWY=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "github@adolfo.ochagavia.xyz", "date": "2018-10-11T14:45:52Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "github@adolfo.ochagavia.xyz", "date": "2018-10-11T14:45:52Z"}, "message": "Remove nesting", "tree": {"sha": "803ef73137440c2b788b1680eb5ce76800e8d847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/803ef73137440c2b788b1680eb5ce76800e8d847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5508c91b3e430689e00903d6fe0ad26eb1f00a9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5508c91b3e430689e00903d6fe0ad26eb1f00a9f", "html_url": "https://github.com/rust-lang/rust/commit/5508c91b3e430689e00903d6fe0ad26eb1f00a9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5508c91b3e430689e00903d6fe0ad26eb1f00a9f/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f88e13f5393c75b02c3619ec432675c3316ee6e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88e13f5393c75b02c3619ec432675c3316ee6e5", "html_url": "https://github.com/rust-lang/rust/commit/f88e13f5393c75b02c3619ec432675c3316ee6e5"}], "stats": {"total": 143, "additions": 68, "deletions": 75}, "files": [{"sha": "3ebdf153e48bb8f8ecea9ee90c6c9551192a04bc", "filename": "crates/ra_editor/src/typing.rs", "status": "modified", "additions": 68, "deletions": 75, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/5508c91b3e430689e00903d6fe0ad26eb1f00a9f/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5508c91b3e430689e00903d6fe0ad26eb1f00a9f/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftyping.rs?ref=5508c91b3e430689e00903d6fe0ad26eb1f00a9f", "patch": "@@ -131,78 +131,77 @@ fn remove_newline(\n     node_text: &str,\n     offset: TextUnit,\n ) {\n-    if node.kind() == WHITESPACE && node_text.bytes().filter(|&b| b == b'\\n').count() == 1 {\n-        // Special case that turns something like:\n-        //\n-        // ```\n-        // my_function({<|>\n-        //    <some-expr>\n-        // })\n-        // ```\n-        //\n-        // into `my_function(<some-expr>)`\n-        if join_single_expr_block(edit, node).is_some() {\n-            return\n-        }\n+    if node.kind() != WHITESPACE || node_text.bytes().filter(|&b| b == b'\\n').count() != 1 {\n+        // The node is either the first or the last in the file\n+        let suff = &node_text[TextRange::from_to(\n+            offset - node.range().start() + TextUnit::of_char('\\n'),\n+            TextUnit::of_str(node_text),\n+        )];\n+        let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n+\n+        edit.replace(\n+            TextRange::offset_len(offset, ((spaces + 1) as u32).into()),\n+            \" \".to_string(),\n+        );\n+        return;\n+    }\n \n-        if let (Some(prev), Some(next)) = (node.prev_sibling(), node.next_sibling()) {\n-            let range = TextRange::from_to(prev.range().start(), node.range().end());\n-            if is_trailing_comma(prev.kind(), next.kind()) {\n-                // Removes: trailing comma, newline (incl. surrounding whitespace)\n-                edit.delete(range);\n-            } else if no_space_required(prev.kind(), next.kind()) {\n-                // Removes: newline (incl. surrounding whitespace)\n-                edit.delete(node.range());\n-            } else if prev.kind() == COMMA && next.kind() == R_CURLY {\n-                // Removes: comma, newline (incl. surrounding whitespace)\n-                // Adds: a single whitespace\n-                edit.replace(range, \" \".to_string());\n-            } else if let (Some(_), Some(next)) = (ast::Comment::cast(prev), ast::Comment::cast(next)) {\n-                // Removes: newline (incl. surrounding whitespace), start of the next comment\n-                let comment_text = next.text();\n-                if let Some(newline_pos) = comment_text.find('\\n') {\n-                    // Special case for multi-line c-like comments: join the comment content but\n-                    // keep the leading `/*`\n-\n-                    let newline_offset = next.syntax().range().start()\n-                                        + TextUnit::from(newline_pos as u32)\n-                                        + TextUnit::of_char('\\n');\n-\n-                    edit.insert(newline_offset, \"/*\".to_string());\n-                    edit.delete(TextRange::from_to(\n-                        node.range().start(),\n-                        next.syntax().range().start() + TextUnit::of_str(next.prefix())\n-                    ));\n-                } else {\n-                    // Single-line comments\n-                    edit.delete(TextRange::from_to(\n-                        node.range().start(),\n-                        next.syntax().range().start() + TextUnit::of_str(next.prefix())\n-                    ));\n-                }\n-            } else {\n-                // Remove newline but add a computed amount of whitespace characters\n-                edit.replace(\n-                    node.range(),\n-                    compute_ws(prev, next).to_string(),\n-                );\n-            }\n+    // Special case that turns something like:\n+    //\n+    // ```\n+    // my_function({<|>\n+    //    <some-expr>\n+    // })\n+    // ```\n+    //\n+    // into `my_function(<some-expr>)`\n+    if join_single_expr_block(edit, node).is_some() {\n+        return\n+    }\n \n-            return;\n+    // The node is between two other nodes\n+    let prev = node.prev_sibling().unwrap();\n+    let next = node.next_sibling().unwrap();\n+    if is_trailing_comma(prev.kind(), next.kind()) {\n+        // Removes: trailing comma, newline (incl. surrounding whitespace)\n+        edit.delete(TextRange::from_to(prev.range().start(), node.range().end()));\n+    } else if prev.kind() == COMMA && next.kind() == R_CURLY {\n+        // Removes: comma, newline (incl. surrounding whitespace)\n+        // Adds: a single whitespace\n+        edit.replace(\n+            TextRange::from_to(prev.range().start(), node.range().end()),\n+            \" \".to_string()\n+        );\n+    } else if let (Some(_), Some(next)) = (ast::Comment::cast(prev), ast::Comment::cast(next)) {\n+        // Removes: newline (incl. surrounding whitespace), start of the next comment\n+        let comment_text = next.text();\n+        if let Some(newline_pos) = comment_text.find('\\n') {\n+            // Special case for multiline comments: join the comment content but\n+            // keep the leading `/*`\n+\n+            let newline_offset = next.syntax().range().start()\n+                                + TextUnit::from(newline_pos as u32)\n+                                + TextUnit::of_char('\\n');\n+\n+            edit.insert(newline_offset, \"/*\".to_string());\n+            edit.delete(TextRange::from_to(\n+                node.range().start(),\n+                next.syntax().range().start() + TextUnit::of_str(next.prefix())\n+            ));\n+        } else {\n+            // Single-line comments\n+            edit.delete(TextRange::from_to(\n+                node.range().start(),\n+                next.syntax().range().start() + TextUnit::of_str(next.prefix())\n+            ));\n         }\n+    } else {\n+        // Remove newline but add a computed amount of whitespace characters\n+        edit.replace(\n+            node.range(),\n+            compute_ws(prev, next).to_string(),\n+        );\n     }\n-\n-    // The node is either the first or the last in the file\n-    let suff = &node_text[TextRange::from_to(\n-        offset - node.range().start() + TextUnit::of_char('\\n'),\n-        TextUnit::of_str(node_text),\n-    )];\n-    let spaces = suff.bytes().take_while(|&b| b == b' ').count();\n-\n-    edit.replace(\n-        TextRange::offset_len(offset, ((spaces + 1) as u32).into()),\n-        \" \".to_string(),\n-    );\n }\n \n fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n@@ -212,13 +211,6 @@ fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n     }\n }\n \n-fn no_space_required(left: SyntaxKind, right: SyntaxKind) -> bool {\n-    match (left, right) {\n-       (_, DOT) => true,\n-        _ => false\n-    }\n-}\n-\n fn join_single_expr_block(\n     edit: &mut EditBuilder,\n     node: SyntaxNodeRef,\n@@ -260,6 +252,7 @@ fn compute_ws(left: SyntaxNodeRef, right: SyntaxNodeRef) -> &'static str {\n     }\n     match right.kind() {\n         R_PAREN | R_BRACK => return \"\",\n+        DOT => return \"\",\n         _ => (),\n     }\n     \" \""}]}