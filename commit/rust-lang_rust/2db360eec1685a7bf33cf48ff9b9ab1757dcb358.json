{"sha": "2db360eec1685a7bf33cf48ff9b9ab1757dcb358", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYjM2MGVlYzE2ODVhN2JmMzNjZjQ4ZmY5YjlhYjE3NTdkY2IzNTg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-12T08:38:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-12T08:38:36Z"}, "message": "Rollup merge of #37190 - QuietMisdreavus:rustdoc-where-newline, r=GuillaumeGomez\n\nrustdoc: add line breaks to where clauses a la rustfmt\n\nMuch like my last PR for rustdoc (#36679), this adds line breaks to certain statements based on their line length. Here the focus was on where clauses.\n\nSome examples:\n- [Where clause in a trait function](https://shiva.icesoldier.me/custom-std/std/iter/trait.Iterator.html?search=#method.unzip) (also in the trait header block at the top of the page)\n- [Where clause on a bare function](https://shiva.icesoldier.me/doc-custom2/petgraph/visit/fn.depth_first_search.html)\n- [Where clauses in trait impls on a struct](https://shiva.icesoldier.me/custom-std/std/collections/struct.HashMap.html) (scroll to the bottom) These are regularly not on their own line, but will be given their own line now if their \"prefix text\" doesn't give them enough room to sensibly print their constraints. HashMap's trait impls provide some examples of both behaviors.\n\nThe libstd links above are the whole docs rendered with this, and the \"bare function\" link above is in another set that pulls some notable crates together. `petgraph` was the one that brought this request up, and that collection also includes [itertools](https://shiva.icesoldier.me/doc-custom2/itertools/trait.Itertools.html) which provided an easy sample to test with.\n\nr? @GuillaumeGomez", "tree": {"sha": "9a1a082687486baa9bd72c8f35ebfa651a148dda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a1a082687486baa9bd72c8f35ebfa651a148dda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2db360eec1685a7bf33cf48ff9b9ab1757dcb358", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2db360eec1685a7bf33cf48ff9b9ab1757dcb358", "html_url": "https://github.com/rust-lang/rust/commit/2db360eec1685a7bf33cf48ff9b9ab1757dcb358", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b33873f5411d4ad6a3bd5a4a18dffce8a960a316", "url": "https://api.github.com/repos/rust-lang/rust/commits/b33873f5411d4ad6a3bd5a4a18dffce8a960a316", "html_url": "https://github.com/rust-lang/rust/commit/b33873f5411d4ad6a3bd5a4a18dffce8a960a316"}, {"sha": "61cc8700dfcecde9e7de132356f3c32eb01b147e", "url": "https://api.github.com/repos/rust-lang/rust/commits/61cc8700dfcecde9e7de132356f3c32eb01b147e", "html_url": "https://github.com/rust-lang/rust/commit/61cc8700dfcecde9e7de132356f3c32eb01b147e"}], "stats": {"total": 208, "additions": 156, "deletions": 52}, "files": [{"sha": "eef530081abe358b00ec2da39f707682f4fc76f1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2db360eec1685a7bf33cf48ff9b9ab1757dcb358", "patch": "@@ -42,15 +42,15 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(pub &'a clean::FnDecl, pub &'a str);\n+pub struct Method<'a>(pub &'a clean::FnDecl, pub usize);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct RawMutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting a where clause from Generics.\n-pub struct WhereClause<'a>(pub &'a clean::Generics);\n+pub struct WhereClause<'a>(pub &'a clean::Generics, pub usize);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n /// Wrapper struct for emitting a comma-separated list of items\n@@ -157,52 +157,71 @@ impl fmt::Display for clean::Generics {\n \n impl<'a> fmt::Display for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let &WhereClause(gens) = self;\n+        let &WhereClause(gens, pad) = self;\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n+        let mut clause = String::new();\n         if f.alternate() {\n-            f.write_str(\" \")?;\n+            clause.push_str(\" where \");\n         } else {\n-            f.write_str(\" <span class='where'>where \")?;\n+            clause.push_str(\" <span class='where'>where \");\n         }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n-                f.write_str(\", \")?;\n+                if f.alternate() {\n+                    clause.push_str(\", \");\n+                } else {\n+                    clause.push_str(\",<br>\");\n+                }\n             }\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n                     if f.alternate() {\n-                        write!(f, \"{:#}: {:#}\", ty, TyParamBounds(bounds))?;\n+                        clause.push_str(&format!(\"{:#}: {:#}\", ty, TyParamBounds(bounds)));\n                     } else {\n-                        write!(f, \"{}: {}\", ty, TyParamBounds(bounds))?;\n+                        clause.push_str(&format!(\"{}: {}\", ty, TyParamBounds(bounds)));\n                     }\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime,\n                                                           ref bounds } => {\n-                    write!(f, \"{}: \", lifetime)?;\n+                    clause.push_str(&format!(\"{}: \", lifetime));\n                     for (i, lifetime) in bounds.iter().enumerate() {\n                         if i > 0 {\n-                            f.write_str(\" + \")?;\n+                            clause.push_str(\" + \");\n                         }\n \n-                        write!(f, \"{}\", lifetime)?;\n+                        clause.push_str(&format!(\"{}\", lifetime));\n                     }\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n                     if f.alternate() {\n-                        write!(f, \"{:#} == {:#}\", lhs, rhs)?;\n+                        clause.push_str(&format!(\"{:#} == {:#}\", lhs, rhs));\n                     } else {\n-                        write!(f, \"{} == {}\", lhs, rhs)?;\n+                        clause.push_str(&format!(\"{} == {}\", lhs, rhs));\n                     }\n                 }\n             }\n         }\n         if !f.alternate() {\n-            f.write_str(\"</span>\")?;\n+            clause.push_str(\"</span>\");\n+            let plain = format!(\"{:#}\", self);\n+            if plain.len() > 80 {\n+                //break it onto its own line regardless, but make sure method impls and trait\n+                //blocks keep their fixed padding (2 and 9, respectively)\n+                let padding = if pad > 10 {\n+                    clause = clause.replace(\"class='where'\", \"class='where fmt-newline'\");\n+                    repeat(\"&nbsp;\").take(8).collect::<String>()\n+                } else {\n+                    repeat(\"&nbsp;\").take(pad + 6).collect::<String>()\n+                };\n+                clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n+            } else {\n+                clause = clause.replace(\"<br>\", \" \");\n+            }\n         }\n-        Ok(())\n+        write!(f, \"{}\", clause)\n     }\n }\n \n@@ -718,30 +737,43 @@ impl fmt::Display for clean::Type {\n }\n \n fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::Result {\n+    let mut plain = String::new();\n+\n     if f.alternate() {\n         write!(f, \"impl{:#} \", i.generics)?;\n     } else {\n         write!(f, \"impl{} \", i.generics)?;\n     }\n+    plain.push_str(&format!(\"impl{:#} \", i.generics));\n+\n     if let Some(ref ty) = i.trait_ {\n-        write!(f, \"{}\",\n-               if i.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" })?;\n+        if i.polarity == Some(clean::ImplPolarity::Negative) {\n+            write!(f, \"!\")?;\n+            plain.push_str(\"!\");\n+        }\n+\n         if link_trait {\n             fmt::Display::fmt(ty, f)?;\n+            plain.push_str(&format!(\"{:#}\", ty));\n         } else {\n             match *ty {\n                 clean::ResolvedPath{ typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n                     fmt::Display::fmt(&last.params, f)?;\n+                    plain.push_str(&format!(\"{:#}{:#}\", last.name, last.params));\n                 }\n                 _ => unreachable!(),\n             }\n         }\n         write!(f, \" for \")?;\n+        plain.push_str(\" for \");\n     }\n+\n     fmt::Display::fmt(&i.for_, f)?;\n-    fmt::Display::fmt(&WhereClause(&i.generics), f)?;\n+    plain.push_str(&format!(\"{:#}\", i.for_));\n+\n+    fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;\n     Ok(())\n }\n \n@@ -870,24 +902,30 @@ impl<'a> fmt::Display for Method<'a> {\n \n         let mut output: String;\n         let plain: String;\n+        let pad = repeat(\" \").take(indent).collect::<String>();\n         if arrow.is_empty() {\n             output = format!(\"({})\", args);\n-            plain = format!(\"{}({})\", indent.replace(\"&nbsp;\", \" \"), args_plain);\n+            plain = format!(\"{}({})\", pad, args_plain);\n         } else {\n             output = format!(\"({args})<br>{arrow}\", args = args, arrow = arrow);\n-            plain = format!(\"{indent}({args}){arrow}\",\n-                            indent = indent.replace(\"&nbsp;\", \" \"),\n+            plain = format!(\"{pad}({args}){arrow}\",\n+                            pad = pad,\n                             args = args_plain,\n                             arrow = arrow_plain);\n         }\n \n         if plain.len() > 80 {\n-            let pad = format!(\"<br>{}\", indent);\n+            let pad = repeat(\"&nbsp;\").take(indent).collect::<String>();\n+            let pad = format!(\"<br>{}\", pad);\n             output = output.replace(\"<br>\", &pad);\n         } else {\n             output = output.replace(\"<br>\", \"\");\n         }\n-        write!(f, \"{}\", output)\n+        if f.alternate() {\n+            write!(f, \"{}\", output.replace(\"<br>\", \"\\n\"))\n+        } else {\n+            write!(f, \"{}\", output)\n+        }\n     }\n }\n "}, {"sha": "93827a01038f95011edac5232954ed6d9618228a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 66, "deletions": 27, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2db360eec1685a7bf33cf48ff9b9ab1757dcb358", "patch": "@@ -1972,14 +1972,13 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         UnstableFeatures::Allow => f.constness,\n         _ => hir::Constness::NotConst\n     };\n-    let prefix = format!(\"{}{}{}{:#}fn {}{:#}\",\n+    let indent = format!(\"{}{}{}{:#}fn {}{:#}\",\n                          VisSpace(&it.visibility),\n                          ConstnessSpace(vis_constness),\n                          UnsafetySpace(f.unsafety),\n                          AbiSpace(f.abi),\n                          it.name.as_ref().unwrap(),\n-                         f.generics);\n-    let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n+                         f.generics).len();\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(&it.visibility),\n@@ -1988,22 +1987,29 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            abi = AbiSpace(f.abi),\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n-           where_clause = WhereClause(&f.generics),\n-           decl = Method(&f.decl, &indent))?;\n+           where_clause = WhereClause(&f.generics, 2),\n+           decl = Method(&f.decl, indent))?;\n     document(w, cx, it)\n }\n \n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut bounds = String::new();\n+    let mut bounds_plain = String::new();\n     if !t.bounds.is_empty() {\n         if !bounds.is_empty() {\n             bounds.push(' ');\n+            bounds_plain.push(' ');\n         }\n         bounds.push_str(\": \");\n+        bounds_plain.push_str(\": \");\n         for (i, p) in t.bounds.iter().enumerate() {\n-            if i > 0 { bounds.push_str(\" + \"); }\n+            if i > 0 {\n+                bounds.push_str(\" + \");\n+                bounds_plain.push_str(\" + \");\n+            }\n             bounds.push_str(&format!(\"{}\", *p));\n+            bounds_plain.push_str(&format!(\"{:#}\", *p));\n         }\n     }\n \n@@ -2014,7 +2020,8 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            it.name.as_ref().unwrap(),\n            t.generics,\n            bounds,\n-           WhereClause(&t.generics))?;\n+           // Where clauses in traits are indented nine spaces, per rustdoc.css\n+           WhereClause(&t.generics, 9))?;\n \n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2028,31 +2035,31 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         write!(w, \"{{\\n\")?;\n         for t in &types {\n             write!(w, \"    \")?;\n-            render_assoc_item(w, t, AssocItemLink::Anchor(None))?;\n+            render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n             write!(w, \";\\n\")?;\n         }\n         if !types.is_empty() && !consts.is_empty() {\n             w.write_str(\"\\n\")?;\n         }\n         for t in &consts {\n             write!(w, \"    \")?;\n-            render_assoc_item(w, t, AssocItemLink::Anchor(None))?;\n+            render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n             write!(w, \";\\n\")?;\n         }\n         if !consts.is_empty() && !required.is_empty() {\n             w.write_str(\"\\n\")?;\n         }\n         for m in &required {\n             write!(w, \"    \")?;\n-            render_assoc_item(w, m, AssocItemLink::Anchor(None))?;\n+            render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n             write!(w, \";\\n\")?;\n         }\n         if !required.is_empty() && !provided.is_empty() {\n             w.write_str(\"\\n\")?;\n         }\n         for m in &provided {\n             write!(w, \"    \")?;\n-            render_assoc_item(w, m, AssocItemLink::Anchor(None))?;\n+            render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n             write!(w, \" {{ ... }}\\n\")?;\n         }\n         write!(w, \"}}\")?;\n@@ -2073,7 +2080,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                id = id,\n                stab = m.stability_class(),\n                ns_id = ns_id)?;\n-        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)))?;\n+        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl)?;\n         write!(w, \"</code>\")?;\n         render_stability_since(w, m, t)?;\n         write!(w, \"</span></h3>\")?;\n@@ -2227,15 +2234,17 @@ fn render_stability_since(w: &mut fmt::Formatter,\n \n fn render_assoc_item(w: &mut fmt::Formatter,\n                      item: &clean::Item,\n-                     link: AssocItemLink) -> fmt::Result {\n+                     link: AssocItemLink,\n+                     parent: ItemType) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter,\n               meth: &clean::Item,\n               unsafety: hir::Unsafety,\n               constness: hir::Constness,\n               abi: abi::Abi,\n               g: &clean::Generics,\n               d: &clean::FnDecl,\n-              link: AssocItemLink)\n+              link: AssocItemLink,\n+              parent: ItemType)\n               -> fmt::Result {\n         let name = meth.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", meth.type_(), name);\n@@ -2265,7 +2274,16 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                              AbiSpace(abi),\n                              name,\n                              *g);\n-        let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n+        let mut indent = prefix.len();\n+        let where_indent = if parent == ItemType::Trait {\n+            indent += 4;\n+            8\n+        } else if parent == ItemType::Impl {\n+            2\n+        } else {\n+            let prefix = prefix + &format!(\"{:#}\", Method(d, indent));\n+            prefix.lines().last().unwrap().len() + 1\n+        };\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                ConstnessSpace(vis_constness),\n@@ -2274,19 +2292,18 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                href = href,\n                name = name,\n                generics = *g,\n-               decl = Method(d, &indent),\n-               where_clause = WhereClause(g))\n+               decl = Method(d, indent),\n+               where_clause = WhereClause(g, where_indent))\n     }\n     match item.inner {\n         clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.unsafety, hir::Constness::NotConst,\n-                   m.abi, &m.generics, &m.decl, link)\n+                   m.abi, &m.generics, &m.decl, link, parent)\n         }\n         clean::MethodItem(ref m) => {\n             method(w, item, m.unsafety, m.constness,\n-                   m.abi, &m.generics, &m.decl,\n-                   link)\n+                   m.abi, &m.generics, &m.decl, link, parent)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n             assoc_const(w, item, ty, default.as_ref(), link)\n@@ -2383,11 +2400,15 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     write!(w, \"<pre class='rust enum'>\")?;\n     render_attributes(w, it)?;\n+    let padding = format!(\"{}enum {}{:#} \",\n+                          VisSpace(&it.visibility),\n+                          it.name.as_ref().unwrap(),\n+                          e.generics).len();\n     write!(w, \"{}enum {}{}{}\",\n            VisSpace(&it.visibility),\n            it.name.as_ref().unwrap(),\n            e.generics,\n-           WhereClause(&e.generics))?;\n+           WhereClause(&e.generics, padding))?;\n     if e.variants.is_empty() && !e.variants_stripped {\n         write!(w, \" {{}}\")?;\n     } else {\n@@ -2559,17 +2580,23 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  fields: &[clean::Item],\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n+    let mut plain = String::new();\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n+    plain.push_str(&format!(\"{}{}{}\",\n+                            VisSpace(&it.visibility),\n+                            if structhead {\"struct \"} else {\"\"},\n+                            it.name.as_ref().unwrap()));\n     if let Some(g) = g {\n+        plain.push_str(&format!(\"{:#}\", g));\n         write!(w, \"{}\", g)?\n     }\n     match ty {\n         doctree::Plain => {\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             let mut has_visible_fields = false;\n             write!(w, \" {{\")?;\n@@ -2598,30 +2625,35 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         }\n         doctree::Tuple => {\n             write!(w, \"(\")?;\n+            plain.push_str(\"(\");\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n                     write!(w, \", \")?;\n+                    plain.push_str(\", \");\n                 }\n                 match field.inner {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => {\n+                        plain.push_str(\"_\");\n                         write!(w, \"_\")?\n                     }\n                     clean::StructFieldItem(ref ty) => {\n+                        plain.push_str(&format!(\"{}{:#}\", VisSpace(&field.visibility), *ty));\n                         write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n                 }\n             }\n             write!(w, \")\")?;\n+            plain.push_str(\")\");\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             write!(w, \";\")?;\n         }\n         doctree::Unit => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause(g))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             write!(w, \";\")?;\n         }\n@@ -2634,13 +2666,19 @@ fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n                 fields: &[clean::Item],\n                 tab: &str,\n                 structhead: bool) -> fmt::Result {\n+    let mut plain = String::new();\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"union \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n+    plain.push_str(&format!(\"{}{}{}\",\n+                            VisSpace(&it.visibility),\n+                            if structhead {\"union \"} else {\"\"},\n+                            it.name.as_ref().unwrap()));\n     if let Some(g) = g {\n         write!(w, \"{}\", g)?;\n-        write!(w, \"{}\", WhereClause(g))?;\n+        plain.push_str(&format!(\"{:#}\", g));\n+        write!(w, \"{}\", WhereClause(g, plain.len() + 1))?;\n     }\n \n     write!(w, \" {{\\n{}\", tab)?;\n@@ -2831,7 +2869,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                     write!(w, \"<h4 id='{}' class='{}'>\", id, item_type)?;\n                     write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n                     write!(w, \"<code>\")?;\n-                    render_assoc_item(w, item, link.anchor(&id))?;\n+                    render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n                     write!(w, \"</code>\")?;\n                     render_stability_since_raw(w, item.stable_since(), outer_version)?;\n                     write!(w, \"</span></h4>\\n\")?;\n@@ -2941,10 +2979,11 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n+    let indent = format!(\"type {}{:#} \", it.name.as_ref().unwrap(), t.generics).len();\n     write!(w, \"<pre class='rust typedef'>type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n-           where_clause = WhereClause(&t.generics),\n+           where_clause = WhereClause(&t.generics, indent),\n            type_ = t.type_)?;\n \n     document(w, cx, it)"}, {"sha": "917b5f4fadc07a75dd1e1445c47298a922a9d270", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=2db360eec1685a7bf33cf48ff9b9ab1757dcb358", "patch": "@@ -361,9 +361,17 @@ h4 > code, h3 > code, .invisible > code {\n \tposition: relative;\n }\n /* Shift \"where ...\" part of method or fn definition down a line */\n-.content .method .where, .content .fn .where { display: block; }\n+.content .method .where,\n+.content .fn .where,\n+.content .where.fmt-newline {\n+    display: block;\n+}\n /* Bit of whitespace to indent it */\n-.content .method .where::before, .content .fn .where::before { content: '  '; }\n+.content .method .where::before,\n+.content .fn .where::before,\n+.content .where.fmt-newline::before {\n+    content: '  ';\n+}\n \n .content .methods > div { margin-left: 40px; }\n "}, {"sha": "a1eabb515a5ce28cd9c7214fe4943fcf8a2d7d2e", "filename": "src/test/rustdoc/line-breaks.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/src%2Ftest%2Frustdoc%2Fline-breaks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2db360eec1685a7bf33cf48ff9b9ab1757dcb358/src%2Ftest%2Frustdoc%2Fline-breaks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fline-breaks.rs?ref=2db360eec1685a7bf33cf48ff9b9ab1757dcb358", "patch": "@@ -10,6 +10,9 @@\n \n #![crate_name = \"foo\"]\n \n+use std::ops::Add;\n+use std::fmt::Display;\n+\n //@count foo/fn.function_with_a_really_long_name.html //pre/br 2\n pub fn function_with_a_really_long_name(parameter_one: i32,\n                                         parameter_two: i32)\n@@ -19,3 +22,19 @@ pub fn function_with_a_really_long_name(parameter_one: i32,\n \n //@count foo/fn.short_name.html //pre/br 0\n pub fn short_name(param: i32) -> i32 { param + 1 }\n+\n+//@count foo/fn.where_clause.html //pre/br 4\n+pub fn where_clause<T, U>(param_one: T,\n+                          param_two: U)\n+    where T: Add<U> + Display + Copy,\n+          U: Add<T> + Display + Copy,\n+          T::Output: Display + Add<U::Output> + Copy,\n+          <T::Output as Add<U::Output>>::Output: Display,\n+          U::Output: Display + Copy\n+{\n+    let x = param_one + param_two;\n+    println!(\"{} + {} = {}\", param_one, param_two, x);\n+    let y = param_two + param_one;\n+    println!(\"{} + {} = {}\", param_two, param_one, y);\n+    println!(\"{} + {} = {}\", x, y, x + y);\n+}"}]}