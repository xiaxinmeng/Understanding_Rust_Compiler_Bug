{"sha": "b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "node_id": "C_kwDOAAsO6NoAKGIyMWJmMjVhMDdlZjRjZmY4ZTllMzhmNDRmOWY0MDdiYjJiZDIwN2Q", "commit": {"author": {"name": "unexge", "email": "unexge@gmail.com", "date": "2022-09-21T22:05:30Z"}, "committer": {"name": "unexge", "email": "unexge@gmail.com", "date": "2022-09-26T18:06:29Z"}, "message": "Collect diagnostics in queries instead of nameres", "tree": {"sha": "80a8939079c0a9e5ba9a37c1cb8a248215e2f2ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80a8939079c0a9e5ba9a37c1cb8a248215e2f2ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "html_url": "https://github.com/rust-lang/rust/commit/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/comments", "author": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "unexge", "id": 16212576, "node_id": "MDQ6VXNlcjE2MjEyNTc2", "avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/unexge", "html_url": "https://github.com/unexge", "followers_url": "https://api.github.com/users/unexge/followers", "following_url": "https://api.github.com/users/unexge/following{/other_user}", "gists_url": "https://api.github.com/users/unexge/gists{/gist_id}", "starred_url": "https://api.github.com/users/unexge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/unexge/subscriptions", "organizations_url": "https://api.github.com/users/unexge/orgs", "repos_url": "https://api.github.com/users/unexge/repos", "events_url": "https://api.github.com/users/unexge/events{/privacy}", "received_events_url": "https://api.github.com/users/unexge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89107d5469dfe978efafe57d70b6f1525b060d46", "url": "https://api.github.com/repos/rust-lang/rust/commits/89107d5469dfe978efafe57d70b6f1525b060d46", "html_url": "https://github.com/rust-lang/rust/commit/89107d5469dfe978efafe57d70b6f1525b060d46"}], "stats": {"total": 310, "additions": 194, "deletions": 116}, "files": [{"sha": "af8ca8571ba20ffccc678180cd7eda70711abe26", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 129, "deletions": 35, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "patch": "@@ -6,7 +6,7 @@ use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     name::{AsName, Name},\n-    InFile,\n+    HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n use syntax::ast::{self, HasName, HasVisibility};\n@@ -17,13 +17,15 @@ use crate::{\n     builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     intern::Interned,\n-    item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem, RawVisibilityId},\n+    item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n+    nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n     type_ref::TypeRef,\n     visibility::RawVisibility,\n-    EnumId, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n+    EnumId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StructId, UnionId,\n+    VariantId,\n };\n use cfg::CfgOptions;\n \n@@ -143,43 +145,87 @@ fn parse_repr_tt(tt: &Subtree) -> Option<ReprData> {\n \n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n+        db.struct_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn struct_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: StructId,\n+    ) -> (Arc<StructData>, Arc<Vec<DefDiagnostic>>) {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let strukt = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &strukt.fields, None);\n-        Arc::new(StructData {\n-            name: strukt.name.clone(),\n-            variant_data: Arc::new(variant_data),\n-            repr,\n-            visibility: item_tree[strukt.visibility].clone(),\n-        })\n+        let (variant_data, diagnostics) = lower_fields(\n+            db,\n+            krate,\n+            loc.id.file_id(),\n+            loc.container.local_id,\n+            &item_tree,\n+            &cfg_options,\n+            &strukt.fields,\n+            None,\n+        );\n+        (\n+            Arc::new(StructData {\n+                name: strukt.name.clone(),\n+                variant_data: Arc::new(variant_data),\n+                repr,\n+                visibility: item_tree[strukt.visibility].clone(),\n+            }),\n+            Arc::new(diagnostics),\n+        )\n     }\n \n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n+        db.union_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn union_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: UnionId,\n+    ) -> (Arc<StructData>, Arc<Vec<DefDiagnostic>>) {\n         let loc = id.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n         let union = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &union.fields, None);\n-\n-        Arc::new(StructData {\n-            name: union.name.clone(),\n-            variant_data: Arc::new(variant_data),\n-            repr,\n-            visibility: item_tree[union.visibility].clone(),\n-        })\n+        let (variant_data, diagnostics) = lower_fields(\n+            db,\n+            krate,\n+            loc.id.file_id(),\n+            loc.container.local_id,\n+            &item_tree,\n+            &cfg_options,\n+            &union.fields,\n+            None,\n+        );\n+        (\n+            Arc::new(StructData {\n+                name: union.name.clone(),\n+                variant_data: Arc::new(variant_data),\n+                repr,\n+                visibility: item_tree[union.visibility].clone(),\n+            }),\n+            Arc::new(diagnostics),\n+        )\n     }\n }\n \n impl EnumData {\n     pub(crate) fn enum_data_query(db: &dyn DefDatabase, e: EnumId) -> Arc<EnumData> {\n+        db.enum_data_with_diagnostics(e).0\n+    }\n+\n+    pub(crate) fn enum_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        e: EnumId,\n+    ) -> (Arc<EnumData>, Arc<Vec<DefDiagnostic>>) {\n         let loc = e.lookup(db);\n         let krate = loc.container.krate;\n         let item_tree = loc.id.item_tree(db);\n@@ -188,31 +234,46 @@ impl EnumData {\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n+        let mut diagnostics = Vec::new();\n         for tree_id in enum_.variants.clone() {\n-            if item_tree.attrs(db, krate, tree_id.into()).is_cfg_enabled(&cfg_options) {\n-                let var = &item_tree[tree_id];\n-                let var_data = lower_fields(\n+            let attrs = item_tree.attrs(db, krate, tree_id.into());\n+            let var = &item_tree[tree_id];\n+            if attrs.is_cfg_enabled(&cfg_options) {\n+                let (var_data, field_diagnostics) = lower_fields(\n                     db,\n                     krate,\n+                    loc.id.file_id(),\n+                    loc.container.local_id,\n                     &item_tree,\n                     &cfg_options,\n                     &var.fields,\n                     Some(enum_.visibility),\n                 );\n+                diagnostics.extend(field_diagnostics);\n \n                 variants.alloc(EnumVariantData {\n                     name: var.name.clone(),\n                     variant_data: Arc::new(var_data),\n                 });\n+            } else {\n+                diagnostics.push(DefDiagnostic::unconfigured_code(\n+                    loc.container.local_id,\n+                    InFile::new(loc.id.file_id(), var.ast_id.upcast()),\n+                    attrs.cfg().unwrap(),\n+                    cfg_options.clone(),\n+                ))\n             }\n         }\n \n-        Arc::new(EnumData {\n-            name: enum_.name.clone(),\n-            variants,\n-            repr,\n-            visibility: item_tree[enum_.visibility].clone(),\n-        })\n+        (\n+            Arc::new(EnumData {\n+                name: enum_.name.clone(),\n+                variants,\n+                repr,\n+                visibility: item_tree[enum_.visibility].clone(),\n+            }),\n+            Arc::new(diagnostics),\n+        )\n     }\n \n     pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n@@ -384,31 +445,64 @@ fn lower_struct(\n fn lower_fields(\n     db: &dyn DefDatabase,\n     krate: CrateId,\n+    current_file_id: HirFileId,\n+    container: LocalModuleId,\n     item_tree: &ItemTree,\n     cfg_options: &CfgOptions,\n     fields: &Fields,\n     override_visibility: Option<RawVisibilityId>,\n-) -> VariantData {\n+) -> (VariantData, Vec<DefDiagnostic>) {\n+    let mut diagnostics = Vec::new();\n     match fields {\n         Fields::Record(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n-                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                let attrs = item_tree.attrs(db, krate, field_id.into());\n+                let field = &item_tree[field_id];\n+                if attrs.is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, field, override_visibility));\n+                } else {\n+                    diagnostics.push(DefDiagnostic::unconfigured_code(\n+                        container,\n+                        InFile::new(\n+                            current_file_id,\n+                            match field.ast_id {\n+                                FieldAstId::Record(it) => it.upcast(),\n+                                FieldAstId::Tuple(it) => it.upcast(),\n+                            },\n+                        ),\n+                        attrs.cfg().unwrap(),\n+                        cfg_options.clone(),\n+                    ))\n                 }\n             }\n-            VariantData::Record(arena)\n+            (VariantData::Record(arena), diagnostics)\n         }\n         Fields::Tuple(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n-                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                let attrs = item_tree.attrs(db, krate, field_id.into());\n+                let field = &item_tree[field_id];\n+                if attrs.is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, field, override_visibility));\n+                } else {\n+                    diagnostics.push(DefDiagnostic::unconfigured_code(\n+                        container,\n+                        InFile::new(\n+                            current_file_id,\n+                            match field.ast_id {\n+                                FieldAstId::Record(it) => it.upcast(),\n+                                FieldAstId::Tuple(it) => it.upcast(),\n+                            },\n+                        ),\n+                        attrs.cfg().unwrap(),\n+                        cfg_options.clone(),\n+                    ))\n                 }\n             }\n-            VariantData::Tuple(arena)\n+            (VariantData::Tuple(arena), diagnostics)\n         }\n-        Fields::Unit => VariantData::Unit,\n+        Fields::Unit => (VariantData::Unit, diagnostics),\n     }\n }\n "}, {"sha": "93ffe29a1fe820ca3f40014fabccece95c99c7d2", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "patch": "@@ -97,12 +97,27 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(StructData::struct_data_query)]\n     fn struct_data(&self, id: StructId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::struct_data_with_diagnostics_query)]\n+    fn struct_data_with_diagnostics(\n+        &self,\n+        id: StructId,\n+    ) -> (Arc<StructData>, Arc<Vec<DefDiagnostic>>);\n+\n     #[salsa::invoke(StructData::union_data_query)]\n     fn union_data(&self, id: UnionId) -> Arc<StructData>;\n \n+    #[salsa::invoke(StructData::union_data_with_diagnostics_query)]\n+    fn union_data_with_diagnostics(\n+        &self,\n+        id: UnionId,\n+    ) -> (Arc<StructData>, Arc<Vec<DefDiagnostic>>);\n+\n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n \n+    #[salsa::invoke(EnumData::enum_data_with_diagnostics_query)]\n+    fn enum_data_with_diagnostics(&self, e: EnumId) -> (Arc<EnumData>, Arc<Vec<DefDiagnostic>>);\n+\n     #[salsa::invoke(ImplData::impl_data_query)]\n     fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n "}, {"sha": "9ffc218818ca164cd91f0609941b3a7f5e80d8a2", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 22, "deletions": 77, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "patch": "@@ -32,8 +32,8 @@ use crate::{\n     derive_macro_as_call_id,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n-        self, FieldAstId, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode,\n-        MacroCall, MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n+        self, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, ItemTreeNode, MacroCall,\n+        MacroDef, MacroRules, Mod, ModItem, ModKind, TreeId,\n     },\n     macro_call_as_call_id, macro_id_to_def_id,\n     nameres::{\n@@ -1511,10 +1511,7 @@ impl ModCollector<'_, '_> {\n             let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n             if let Some(cfg) = attrs.cfg() {\n                 if !self.is_cfg_enabled(&cfg) {\n-                    self.emit_unconfigured_diagnostic(\n-                        InFile::new(self.file_id(), item.ast_id(&self.item_tree).upcast()),\n-                        &cfg,\n-                    );\n+                    self.emit_unconfigured_diagnostic(item, &cfg);\n                     continue;\n                 }\n             }\n@@ -1526,20 +1523,22 @@ impl ModCollector<'_, '_> {\n             }\n \n             let db = self.def_collector.db;\n-            let module_id = self.module_id;\n-            let module = self.def_collector.def_map.module_id(module_id);\n+            let module = self.def_collector.def_map.module_id(self.module_id);\n+            let def_map = &mut self.def_collector.def_map;\n             let update_def =\n                 |def_collector: &mut DefCollector<'_>, id, name: &Name, vis, has_constructor| {\n-                    def_collector.def_map.modules[module_id].scope.declare(id);\n+                    def_collector.def_map.modules[self.module_id].scope.declare(id);\n                     def_collector.update(\n-                        module_id,\n+                        self.module_id,\n                         &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n                         vis,\n                         ImportType::Named,\n                     )\n                 };\n             let resolve_vis = |def_map: &DefMap, visibility| {\n-                def_map.resolve_visibility(db, module_id, visibility).unwrap_or(Visibility::Public)\n+                def_map\n+                    .resolve_visibility(db, self.module_id, visibility)\n+                    .unwrap_or(Visibility::Public)\n             };\n \n             match item {\n@@ -1595,7 +1594,6 @@ impl ModCollector<'_, '_> {\n                     let fn_id =\n                         FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n-                    let def_map = &self.def_collector.def_map;\n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     if self.def_collector.is_proc_macro {\n                         if self.module_id == def_map.root {\n@@ -1616,10 +1614,7 @@ impl ModCollector<'_, '_> {\n                 ModItem::Struct(id) => {\n                     let it = &self.item_tree[id];\n \n-                    self.process_fields(&it.fields);\n-\n-                    let vis =\n-                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         StructLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1633,10 +1628,7 @@ impl ModCollector<'_, '_> {\n                 ModItem::Union(id) => {\n                     let it = &self.item_tree[id];\n \n-                    self.process_fields(&it.fields);\n-\n-                    let vis =\n-                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         UnionLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1650,21 +1642,7 @@ impl ModCollector<'_, '_> {\n                 ModItem::Enum(id) => {\n                     let it = &self.item_tree[id];\n \n-                    for id in it.variants.clone() {\n-                        let variant = &self.item_tree[id];\n-                        let attrs = self.item_tree.attrs(self.def_collector.db, krate, id.into());\n-                        if let Some(cfg) = attrs.cfg() {\n-                            if !self.is_cfg_enabled(&cfg) {\n-                                self.emit_unconfigured_diagnostic(\n-                                    InFile::new(self.file_id(), variant.ast_id.upcast()),\n-                                    &cfg,\n-                                );\n-                            }\n-                        }\n-                    }\n-\n-                    let vis =\n-                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         EnumLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1682,10 +1660,7 @@ impl ModCollector<'_, '_> {\n \n                     match &it.name {\n                         Some(name) => {\n-                            let vis = resolve_vis(\n-                                &self.def_collector.def_map,\n-                                &self.item_tree[it.visibility],\n-                            );\n+                            let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                             update_def(self.def_collector, const_id.into(), name, vis, false);\n                         }\n                         None => {\n@@ -1699,8 +1674,7 @@ impl ModCollector<'_, '_> {\n                 ModItem::Static(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis =\n-                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         StaticLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1714,8 +1688,7 @@ impl ModCollector<'_, '_> {\n                 ModItem::Trait(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis =\n-                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         TraitLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n@@ -1729,8 +1702,7 @@ impl ModCollector<'_, '_> {\n                 ModItem::TypeAlias(id) => {\n                     let it = &self.item_tree[id];\n \n-                    let vis =\n-                        resolve_vis(&self.def_collector.def_map, &self.item_tree[it.visibility]);\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n                     update_def(\n                         self.def_collector,\n                         TypeAliasLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n@@ -2143,44 +2115,17 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n-    fn process_fields(&mut self, fields: &Fields) {\n-        match fields {\n-            Fields::Record(range) | Fields::Tuple(range) => {\n-                for id in range.clone() {\n-                    let field = &self.item_tree[id];\n-                    let attrs = self.item_tree.attrs(\n-                        self.def_collector.db,\n-                        self.def_collector.def_map.krate,\n-                        id.into(),\n-                    );\n-                    if let Some(cfg) = attrs.cfg() {\n-                        if !self.is_cfg_enabled(&cfg) {\n-                            self.emit_unconfigured_diagnostic(\n-                                InFile::new(\n-                                    self.file_id(),\n-                                    match field.ast_id {\n-                                        FieldAstId::Record(it) => it.upcast(),\n-                                        FieldAstId::Tuple(it) => it.upcast(),\n-                                    },\n-                                ),\n-                                &cfg,\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-            Fields::Unit => {}\n-        }\n-    }\n-\n     fn is_cfg_enabled(&self, cfg: &CfgExpr) -> bool {\n         self.def_collector.cfg_options.check(cfg) != Some(false)\n     }\n \n-    fn emit_unconfigured_diagnostic(&mut self, ast: AstId<ast::AnyHasAttrs>, cfg: &CfgExpr) {\n+    fn emit_unconfigured_diagnostic(&mut self, item: ModItem, cfg: &CfgExpr) {\n+        let ast_id = item.ast_id(self.item_tree);\n+\n+        let ast_id = InFile::new(self.file_id(), ast_id.upcast());\n         self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(\n             self.module_id,\n-            ast,\n+            ast_id,\n             cfg.clone(),\n             self.def_collector.cfg_options.clone(),\n         ));"}, {"sha": "d1c8fa59aef473b850f52bfd4993932514d75fcb", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "patch": "@@ -540,9 +540,27 @@ impl Module {\n                     }\n                     acc.extend(decl.diagnostics(db))\n                 }\n-                ModuleDef::Adt(Adt::Enum(e)) => {\n-                    for v in e.variants(db) {\n-                        acc.extend(ModuleDef::Variant(v).diagnostics(db));\n+                ModuleDef::Adt(adt) => {\n+                    match adt {\n+                        Adt::Struct(s) => {\n+                            for diag in db.struct_data_with_diagnostics(s.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                        Adt::Union(u) => {\n+                            for diag in db.union_data_with_diagnostics(u.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n+                        Adt::Enum(e) => {\n+                            for v in e.variants(db) {\n+                                acc.extend(ModuleDef::Variant(v).diagnostics(db));\n+                            }\n+\n+                            for diag in db.enum_data_with_diagnostics(e.id).1.iter() {\n+                                emit_def_diagnostic(db, acc, diag);\n+                            }\n+                        }\n                     }\n                     acc.extend(decl.diagnostics(db))\n                 }"}, {"sha": "f558b7256a4c6473aad6f452d57aea3a0bca0fa1", "filename": "crates/ide-diagnostics/src/handlers/inactive_code.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=b21bf25a07ef4cff8e9e38f44f9f407bb2bd207d", "patch": "@@ -142,12 +142,18 @@ trait Bar {\n     }\n \n     #[test]\n-    fn inactive_fields() {\n+    fn inactive_fields_and_variants() {\n         check(\n             r#\"\n enum Foo {\n   #[cfg(a)] Bar,\n //^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+  Baz {\n+    #[cfg(a)] baz: String,\n+  //^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n+  },\n+  Qux(#[cfg(a)] String),\n+    //^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives: a is disabled\n }\n \n struct Baz {"}]}