{"sha": "35f975b83881106e0fde729b8c1361c9cf6d2778", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1Zjk3NWI4Mzg4MTEwNmUwZmRlNzI5YjhjMTM2MWM5Y2Y2ZDI3Nzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-27T04:25:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-27T04:25:55Z"}, "message": "auto merge of #8700 : alexcrichton/rust/better-llvm, r=thestinger\n\nBeforehand, it was unclear whether rust was performing the \"recommended set\" of\r\noptimizations provided by LLVM for code. This commit changes the way we run\r\npasses to closely mirror that of clang, which in theory does it correctly. The\r\nnotable changes include:\r\n\r\n* Passes are no longer explicitly added one by one. This would be difficult to\r\n  keep up with as LLVM changes and we don't guaranteed always know the best\r\n  order in which to run passes\r\n* Passes are now managed by LLVM's PassManagerBuilder object. This is then used\r\n  to populate the various pass managers run.\r\n* We now run both a FunctionPassManager and a module-wide PassManager. This is\r\n  what clang does, and I presume that we *may* see a speed boost from the\r\n  module-wide passes just having to do less work. I have no measured this.\r\n* The codegen pass manager has been extracted to its own separate pass manager\r\n  to not get mixed up with the other passes\r\n* All pass managers now include passes for target-specific data layout and\r\n  analysis passes\r\n\r\nSome new features include:\r\n\r\n* You can now print all passes being run with `-Z print-llvm-passes`\r\n* When specifying passes via `--passes`, the passes are now appended to the\r\n  default list of passes instead of overwriting them.\r\n* The output of `--passes list` is now generated by LLVM instead of maintaining\r\n  a list of passes ourselves\r\n* Loop vectorization is turned on by default as an optimization pass and can be\r\n  disabled with `-Z no-vectorize-loops`\r\n\r\n\r\nAll of these \"copies\" of clang are based off their [source code](http://clang.llvm.org/doxygen/BackendUtil_8cpp_source.html) in case anyone is curious what my source is. I was hoping that this would fix #8665, but this does not help the performance issues found there. Hopefully i'll allow us to tweak passes or see what's going on to try to debug that problem.", "tree": {"sha": "8d9fcdd4e2cfcdf471232ff8e32701ed93043318", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d9fcdd4e2cfcdf471232ff8e32701ed93043318"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35f975b83881106e0fde729b8c1361c9cf6d2778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35f975b83881106e0fde729b8c1361c9cf6d2778", "html_url": "https://github.com/rust-lang/rust/commit/35f975b83881106e0fde729b8c1361c9cf6d2778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35f975b83881106e0fde729b8c1361c9cf6d2778/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0aadfd76c33ccc26f5e1672243add2e2f73e923", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0aadfd76c33ccc26f5e1672243add2e2f73e923", "html_url": "https://github.com/rust-lang/rust/commit/c0aadfd76c33ccc26f5e1672243add2e2f73e923"}, {"sha": "73540551e5051c524b5533a5ab3eb991dda4eaac", "url": "https://api.github.com/repos/rust-lang/rust/commits/73540551e5051c524b5533a5ab3eb991dda4eaac", "html_url": "https://github.com/rust-lang/rust/commit/73540551e5051c524b5533a5ab3eb991dda4eaac"}], "stats": {"total": 1235, "additions": 477, "deletions": 758}, "files": [{"sha": "ccebf88ec38b64bb69a982e54260f9aafcdc9f44", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 165, "deletions": 179, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -27,7 +27,6 @@ use std::char;\n use std::hash::Streaming;\n use std::hash;\n use std::io;\n-use std::libc::{c_int, c_uint};\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::os;\n use std::ptr;\n@@ -67,37 +66,19 @@ pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n     }\n }\n \n-pub fn WriteOutputFile(sess: Session,\n-        PM: lib::llvm::PassManagerRef, M: ModuleRef,\n-        Triple: &str,\n-        Cpu: &str,\n-        Feature: &str,\n+pub fn WriteOutputFile(\n+        sess: Session,\n+        Target: lib::llvm::TargetMachineRef,\n+        PM: lib::llvm::PassManagerRef,\n+        M: ModuleRef,\n         Output: &str,\n-        // FIXME: When #2334 is fixed, change\n-        // c_uint to FileType\n-        FileType: c_uint,\n-        OptLevel: c_int,\n-        EnableSegmentedStacks: bool) {\n+        FileType: lib::llvm::FileType) {\n     unsafe {\n-        do Triple.with_c_str |Triple| {\n-            do Cpu.with_c_str |Cpu| {\n-                do Feature.with_c_str |Feature| {\n-                    do Output.with_c_str |Output| {\n-                        let result = llvm::LLVMRustWriteOutputFile(\n-                                PM,\n-                                M,\n-                                Triple,\n-                                Cpu,\n-                                Feature,\n-                                Output,\n-                                FileType,\n-                                OptLevel,\n-                                EnableSegmentedStacks);\n-                        if (!result) {\n-                            llvm_err(sess, ~\"Could not write output\");\n-                        }\n-                    }\n-                }\n+        do Output.with_c_str |Output| {\n+            let result = llvm::LLVMRustWriteOutputFile(\n+                    Target, PM, M, Output, FileType);\n+            if !result {\n+                llvm_err(sess, ~\"Could not write output\");\n             }\n         }\n     }\n@@ -231,25 +212,15 @@ pub mod write {\n     use driver::session::Session;\n     use driver::session;\n     use lib::llvm::llvm;\n-    use lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data};\n-    use lib::llvm::{ContextRef};\n+    use lib::llvm::{ModuleRef, ContextRef};\n     use lib;\n \n-    use back::passes;\n-\n     use std::c_str::ToCStr;\n-    use std::libc::{c_int, c_uint};\n+    use std::libc::c_uint;\n     use std::path::Path;\n     use std::run;\n     use std::str;\n \n-    pub fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n-        match ot {\n-            output_type_assembly | output_type_object | output_type_exe => true,\n-            _ => false\n-        }\n-    }\n-\n     pub fn run_passes(sess: Session,\n                       llcx: ContextRef,\n                       llmod: ModuleRef,\n@@ -258,163 +229,178 @@ pub mod write {\n         unsafe {\n             llvm::LLVMInitializePasses();\n \n-            let opts = sess.opts;\n-            if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }\n-            let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n-            let pm = mk_pass_manager();\n-            llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n-\n-            // Generate a pre-optimization intermediate file if -save-temps\n-            // was specified.\n-            if opts.save_temps {\n-                match output_type {\n-                  output_type_bitcode => {\n-                    if opts.optimize != session::No {\n-                        let filename = output.with_filetype(\"no-opt.bc\");\n-                        do filename.with_c_str |buf| {\n-                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        }\n-                    }\n-                  }\n-                  _ => {\n-                    let filename = output.with_filetype(\"bc\");\n-                    do filename.with_c_str |buf| {\n-                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                    }\n-                  }\n+            // Only initialize the platforms supported by Rust here, because\n+            // using --llvm-root will have multiple platforms that rustllvm\n+            // doesn't actually link to and it's pointless to put target info\n+            // into the registry that Rust can not generate machine code for.\n+            llvm::LLVMInitializeX86TargetInfo();\n+            llvm::LLVMInitializeX86Target();\n+            llvm::LLVMInitializeX86TargetMC();\n+            llvm::LLVMInitializeX86AsmPrinter();\n+            llvm::LLVMInitializeX86AsmParser();\n+\n+            llvm::LLVMInitializeARMTargetInfo();\n+            llvm::LLVMInitializeARMTarget();\n+            llvm::LLVMInitializeARMTargetMC();\n+            llvm::LLVMInitializeARMAsmPrinter();\n+            llvm::LLVMInitializeARMAsmParser();\n+\n+            llvm::LLVMInitializeMipsTargetInfo();\n+            llvm::LLVMInitializeMipsTarget();\n+            llvm::LLVMInitializeMipsTargetMC();\n+            llvm::LLVMInitializeMipsAsmPrinter();\n+            llvm::LLVMInitializeMipsAsmParser();\n+\n+            if sess.opts.save_temps {\n+                do output.with_filetype(\"no-opt.bc\").with_c_str |buf| {\n+                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n                 }\n             }\n \n-            let mut mpm = passes::PassManager::new(td.lltd);\n-\n-            if !sess.no_verify() {\n-                mpm.add_pass_from_name(\"verify\");\n-            }\n+            // Copy what clan does by turning on loop vectorization at O2 and\n+            // slp vectorization at O3\n+            let vectorize_loop = !sess.no_vectorize_loops() &&\n+                                 (sess.opts.optimize == session::Default ||\n+                                  sess.opts.optimize == session::Aggressive);\n+            let vectorize_slp = !sess.no_vectorize_slp() &&\n+                                sess.opts.optimize == session::Aggressive;\n+            llvm::LLVMRustSetLLVMOptions(sess.print_llvm_passes(),\n+                                         vectorize_loop,\n+                                         vectorize_slp,\n+                                         sess.time_llvm_passes());\n+\n+            let OptLevel = match sess.opts.optimize {\n+              session::No => lib::llvm::CodeGenLevelNone,\n+              session::Less => lib::llvm::CodeGenLevelLess,\n+              session::Default => lib::llvm::CodeGenLevelDefault,\n+              session::Aggressive => lib::llvm::CodeGenLevelAggressive,\n+            };\n \n-            let passes = if sess.opts.custom_passes.len() > 0 {\n-                sess.opts.custom_passes.clone()\n-            } else {\n-                if sess.lint_llvm() {\n-                    mpm.add_pass_from_name(\"lint\");\n+            let tm = do sess.targ_cfg.target_strs.target_triple.with_c_str |T| {\n+                do sess.opts.target_cpu.with_c_str |CPU| {\n+                    do sess.opts.target_feature.with_c_str |Features| {\n+                        llvm::LLVMRustCreateTargetMachine(\n+                            T, CPU, Features,\n+                            lib::llvm::CodeModelDefault,\n+                            lib::llvm::RelocPIC,\n+                            OptLevel,\n+                            true\n+                        )\n+                    }\n                 }\n-                passes::create_standard_passes(opts.optimize)\n             };\n \n+            // Create the two optimizing pass managers. These mirror what clang\n+            // does, and are by populated by LLVM's default PassManagerBuilder.\n+            // Each manager has a different set of passes, but they also share\n+            // some common passes. Each one is initialized with the analyis\n+            // passes the target requires, and then further passes are added.\n+            let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n+            let mpm = llvm::LLVMCreatePassManager();\n+            llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n+            llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n+\n+            // If we're verifying or linting, add them to the function pass\n+            // manager.\n+            let addpass = |pass: &str| {\n+                do pass.with_c_str |s| { llvm::LLVMRustAddPass(fpm, s) }\n+            };\n+            if !sess.no_verify() { assert!(addpass(\"verify\")); }\n+            if sess.lint_llvm()  { assert!(addpass(\"lint\"));   }\n+\n+            // Create the PassManagerBuilder for LLVM. We configure it with\n+            // reasonable defaults and prepare it to actually populate the pass\n+            // manager.\n+            let builder = llvm::LLVMPassManagerBuilderCreate();\n+            match sess.opts.optimize {\n+                session::No => {\n+                    // Don't add lifetime intrinsics add O0\n+                    llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n+                }\n+                // numeric values copied from clang\n+                session::Less => {\n+                    llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n+                                                                        225);\n+                }\n+                session::Default | session::Aggressive => {\n+                    llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n+                                                                        275);\n+                }\n+            }\n+            llvm::LLVMPassManagerBuilderSetOptLevel(builder, OptLevel as c_uint);\n+            llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod);\n+\n+            // Use the builder to populate the function/module pass managers.\n+            llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n+            llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n+            llvm::LLVMPassManagerBuilderDispose(builder);\n+\n+            for pass in sess.opts.custom_passes.iter() {\n+                do pass.with_c_str |s| {\n+                    if !llvm::LLVMRustAddPass(mpm, s) {\n+                        sess.warn(fmt!(\"Unknown pass %s, ignoring\", *pass));\n+                    }\n+                }\n+            }\n+\n+            // Finally, run the actual optimization passes\n+            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n+            llvm::LLVMRunPassManager(mpm, llmod);\n \n-            debug!(\"Passes: %?\", passes);\n-            passes::populate_pass_manager(sess, &mut mpm, passes);\n+            // Deallocate managers that we're now done with\n+            llvm::LLVMDisposePassManager(fpm);\n+            llvm::LLVMDisposePassManager(mpm);\n \n-            debug!(\"Running Module Optimization Pass\");\n-            mpm.run(llmod);\n+            if sess.opts.save_temps {\n+                do output.with_filetype(\"bc\").with_c_str |buf| {\n+                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                }\n+            }\n \n-            if opts.jit {\n+            if sess.opts.jit {\n                 // If we are using JIT, go ahead and create and execute the\n-                // engine now.  JIT execution takes ownership of the module and\n-                // context, so don't dispose and return.\n+                // engine now. JIT execution takes ownership of the module and\n+                // context, so don't dispose\n                 jit::exec(sess, llcx, llmod, true);\n+            } else {\n+                // Create a codegen-specific pass manager to emit the actual\n+                // assembly or object files. This may not end up getting used,\n+                // but we make it anyway for good measure.\n+                let cpm = llvm::LLVMCreatePassManager();\n+                llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+                llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n \n-                if sess.time_llvm_passes() {\n-                    llvm::LLVMRustPrintPassTimings();\n-                }\n-                return;\n-            } else if is_object_or_assembly_or_exe(output_type) {\n-                let LLVMOptNone       = 0 as c_int; // -O0\n-                let LLVMOptLess       = 1 as c_int; // -O1\n-                let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n-                let LLVMOptAggressive = 3 as c_int; // -O3\n-\n-                let CodeGenOptLevel = match opts.optimize {\n-                  session::No => LLVMOptNone,\n-                  session::Less => LLVMOptLess,\n-                  session::Default => LLVMOptDefault,\n-                  session::Aggressive => LLVMOptAggressive\n-                };\n-\n-                let FileType = match output_type {\n-                    output_type_object | output_type_exe => lib::llvm::ObjectFile,\n-                    _ => lib::llvm::AssemblyFile\n-                };\n-\n-                // Write optimized bitcode if --save-temps was on.\n-\n-                if opts.save_temps {\n-                    // Always output the bitcode file with --save-temps\n-\n-                    let filename = output.with_filetype(\"opt.bc\");\n-                    do filename.with_c_str |buf| {\n-                        llvm::LLVMWriteBitcodeToFile(llmod, buf)\n-                    };\n-                    // Save the assembly file if -S is used\n-                    if output_type == output_type_assembly {\n-                        WriteOutputFile(\n-                            sess,\n-                            pm.llpm,\n-                            llmod,\n-                            sess.targ_cfg.target_strs.target_triple,\n-                            opts.target_cpu,\n-                            opts.target_feature,\n-                            output.to_str(),\n-                            lib::llvm::AssemblyFile as c_uint,\n-                            CodeGenOptLevel,\n-                            true);\n+                match output_type {\n+                    output_type_none => {}\n+                    output_type_bitcode => {\n+                        do output.with_c_str |buf| {\n+                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                        }\n                     }\n-\n-                    // Save the object file for -c or --save-temps alone\n-                    // This .o is needed when an exe is built\n-                    if output_type == output_type_object ||\n-                           output_type == output_type_exe {\n-                        WriteOutputFile(\n-                            sess,\n-                            pm.llpm,\n-                            llmod,\n-                            sess.targ_cfg.target_strs.target_triple,\n-                            opts.target_cpu,\n-                            opts.target_feature,\n-                            output.to_str(),\n-                            lib::llvm::ObjectFile as c_uint,\n-                            CodeGenOptLevel,\n-                            true);\n+                    output_type_llvm_assembly => {\n+                        do output.with_c_str |output| {\n+                            llvm::LLVMRustPrintModule(cpm, llmod, output)\n+                        }\n+                    }\n+                    output_type_assembly => {\n+                        WriteOutputFile(sess, tm, cpm, llmod, output.to_str(),\n+                                        lib::llvm::AssemblyFile);\n+                    }\n+                    output_type_exe | output_type_object => {\n+                        WriteOutputFile(sess, tm, cpm, llmod, output.to_str(),\n+                                        lib::llvm::ObjectFile);\n                     }\n-                } else {\n-                    // If we aren't saving temps then just output the file\n-                    // type corresponding to the '-c' or '-S' flag used\n-                    WriteOutputFile(\n-                        sess,\n-                        pm.llpm,\n-                        llmod,\n-                        sess.targ_cfg.target_strs.target_triple,\n-                        opts.target_cpu,\n-                        opts.target_feature,\n-                        output.to_str(),\n-                        FileType as c_uint,\n-                        CodeGenOptLevel,\n-                        true);\n                 }\n-                // Clean up and return\n \n-                llvm::LLVMDisposeModule(llmod);\n-                llvm::LLVMContextDispose(llcx);\n-                if sess.time_llvm_passes() {\n-                    llvm::LLVMRustPrintPassTimings();\n-                }\n-                return;\n+                llvm::LLVMDisposePassManager(cpm);\n             }\n \n-            if output_type == output_type_llvm_assembly {\n-                // Given options \"-S --emit-llvm\": output LLVM assembly\n-                do output.with_c_str |buf_o| {\n-                    llvm::LLVMRustAddPrintModulePass(pm.llpm, llmod, buf_o);\n-                }\n-            } else {\n-                // If only a bitcode file is asked for by using the\n-                // '--emit-llvm' flag, then output it here\n-                do output.with_c_str |buf| {\n-                    llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                }\n+            llvm::LLVMRustDisposeTargetMachine(tm);\n+            // the jit takes ownership of these two items\n+            if !sess.opts.jit {\n+                llvm::LLVMDisposeModule(llmod);\n+                llvm::LLVMContextDispose(llcx);\n             }\n-\n-            llvm::LLVMDisposeModule(llmod);\n-            llvm::LLVMContextDispose(llcx);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n         }\n     }"}, {"sha": "bb5ddc1ae7715f9377cf737d31ed2e68895d0c43", "filename": "src/librustc/back/passes.rs", "status": "removed", "additions": 0, "deletions": 349, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/c0aadfd76c33ccc26f5e1672243add2e2f73e923/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0aadfd76c33ccc26f5e1672243add2e2f73e923/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=c0aadfd76c33ccc26f5e1672243add2e2f73e923", "patch": "@@ -1,349 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::c_str::ToCStr;\n-use std::io;\n-\n-use driver::session::{OptLevel, No, Less, Aggressive};\n-use driver::session::{Session};\n-use lib::llvm::{PassRef, ModuleRef,PassManagerRef,TargetDataRef};\n-use lib::llvm::llvm;\n-use lib;\n-\n-pub struct PassManager {\n-    priv llpm: PassManagerRef\n-}\n-\n-impl Drop for PassManager {\n-    fn drop(&self) {\n-        unsafe {\n-            llvm::LLVMDisposePassManager(self.llpm);\n-        }\n-    }\n-}\n-\n-impl PassManager {\n-    pub fn new(td: TargetDataRef) -> PassManager {\n-        unsafe {\n-            let pm = PassManager {\n-                llpm: llvm::LLVMCreatePassManager()\n-            };\n-            llvm::LLVMAddTargetData(td, pm.llpm);\n-\n-            return pm;\n-        }\n-    }\n-\n-    pub fn add_pass(&mut self, pass:PassRef) {\n-        unsafe {\n-            llvm::LLVMAddPass(self.llpm, pass);\n-        }\n-    }\n-\n-    pub fn add_pass_from_name(&mut self, name:&str) {\n-        let pass = create_pass(name).unwrap();\n-        self.add_pass(pass);\n-    }\n-\n-    pub fn run(&self, md:ModuleRef) -> bool {\n-        unsafe {\n-            llvm::LLVMRunPassManager(self.llpm, md) == lib::llvm::True\n-        }\n-    }\n-}\n-\n-pub fn create_standard_passes(level: OptLevel) -> ~[~str] {\n-    let mut passes = ~[];\n-\n-    // mostly identical to clang 3.3, all differences are documented with comments\n-\n-    if level != No {\n-        passes.push(~\"targetlibinfo\");\n-        passes.push(~\"no-aa\");\n-        // \"tbaa\" omitted, we don't emit clang-style type-based alias analysis information\n-        passes.push(~\"basicaa\");\n-        passes.push(~\"globalopt\");\n-        passes.push(~\"ipsccp\");\n-        passes.push(~\"deadargelim\");\n-        passes.push(~\"instcombine\");\n-        passes.push(~\"simplifycfg\");\n-    }\n-\n-    passes.push(~\"basiccg\");\n-\n-    if level != No {\n-        passes.push(~\"prune-eh\");\n-    }\n-\n-    passes.push(~\"inline-cost\");\n-\n-    if level == No || level == Less {\n-        passes.push(~\"always-inline\");\n-    } else {\n-        passes.push(~\"inline\");\n-    }\n-\n-    if level != No {\n-        passes.push(~\"functionattrs\");\n-        if level == Aggressive {\n-            passes.push(~\"argpromotion\");\n-        }\n-        passes.push(~\"sroa\");\n-        passes.push(~\"domtree\");\n-        passes.push(~\"early-cse\");\n-        passes.push(~\"lazy-value-info\");\n-        passes.push(~\"jump-threading\");\n-        passes.push(~\"correlated-propagation\");\n-        passes.push(~\"simplifycfg\");\n-        passes.push(~\"instcombine\");\n-        passes.push(~\"tailcallelim\");\n-        passes.push(~\"simplifycfg\");\n-        passes.push(~\"reassociate\");\n-        passes.push(~\"domtree\");\n-        passes.push(~\"loops\");\n-        passes.push(~\"loop-simplify\");\n-        passes.push(~\"lcssa\");\n-        passes.push(~\"loop-rotate\");\n-        passes.push(~\"licm\");\n-        passes.push(~\"lcssa\");\n-        passes.push(~\"loop-unswitch\");\n-        passes.push(~\"instcombine\");\n-        passes.push(~\"scalar-evolution\");\n-        passes.push(~\"loop-simplify\");\n-        passes.push(~\"lcssa\");\n-        passes.push(~\"indvars\");\n-        passes.push(~\"loop-idiom\");\n-        passes.push(~\"loop-deletion\");\n-        if level == Aggressive {\n-            passes.push(~\"loop-simplify\");\n-            passes.push(~\"lcssa\");\n-            passes.push(~\"loop-vectorize\");\n-            passes.push(~\"loop-simplify\");\n-            passes.push(~\"lcssa\");\n-            passes.push(~\"scalar-evolution\");\n-            passes.push(~\"loop-simplify\");\n-            passes.push(~\"lcssa\");\n-        }\n-        if level != Less {\n-            passes.push(~\"loop-unroll\");\n-            passes.push(~\"memdep\");\n-            passes.push(~\"gvn\");\n-        }\n-        passes.push(~\"memdep\");\n-        passes.push(~\"memcpyopt\");\n-        passes.push(~\"sccp\");\n-        passes.push(~\"instcombine\");\n-        passes.push(~\"lazy-value-info\");\n-        passes.push(~\"jump-threading\");\n-        passes.push(~\"correlated-propagation\");\n-        passes.push(~\"domtree\");\n-        passes.push(~\"memdep\");\n-        passes.push(~\"dse\");\n-        passes.push(~\"adce\");\n-        passes.push(~\"simplifycfg\");\n-        passes.push(~\"instcombine\");\n-        // clang does `strip-dead-prototypes` here, since it does not emit them\n-    }\n-\n-    // rustc emits dead prototypes, so always ask LLVM to strip them\n-    passes.push(~\"strip-dead-prototypes\");\n-\n-    if level != Less {\n-        passes.push(~\"globaldce\");\n-        passes.push(~\"constmerge\");\n-    }\n-\n-    passes\n-}\n-\n-pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~str]) {\n-    for nm in pass_list.iter() {\n-        match create_pass(*nm) {\n-            Some(p) => pm.add_pass(p),\n-            None    => sess.warn(fmt!(\"Unknown pass %s\", *nm))\n-        }\n-    }\n-}\n-\n-pub fn create_pass(name:&str) -> Option<PassRef> {\n-    do name.with_c_str |s| {\n-        unsafe {\n-            let p = llvm::LLVMCreatePass(s);\n-            if p.is_null() {\n-                None\n-            } else {\n-                Some(p)\n-            }\n-        }\n-    }\n-}\n-\n-pub fn list_passes() {\n-    io::println(\"\\nAvailable Passes:\");\n-\n-    io::println(\"\\nAnalysis Passes:\");\n-    for &(name, desc) in analysis_passes.iter() {\n-        printfln!(\"    %-30s -- %s\", name, desc);\n-    }\n-    io::println(\"\\nTransformation Passes:\");\n-    for &(name, desc) in transform_passes.iter() {\n-        printfln!(\"    %-30s -- %s\", name, desc);\n-    }\n-    io::println(\"\\nUtility Passes:\");\n-    for &(name, desc) in utility_passes.iter() {\n-        printfln!(\"    %-30s -- %s\", name, desc);\n-    }\n-}\n-\n-/** Analysis Passes */\n-pub static analysis_passes : &'static [(&'static str, &'static str)] = &'static [\n-    (\"aa-eval\",                         \"Exhausive Alias Analysis Precision Evaluator\"),\n-    (\"asan\",                            \"AddressSanitizer\"),\n-    (\"basicaa\",                         \"Basic Alias Analysis\"),\n-    (\"basiccg\",                         \"Basic CallGraph Construction\"),\n-    (\"block-freq\",                      \"Block Frequency Analysis\"),\n-    (\"cost-model\",                      \"Cost Model Analysis\"),\n-    (\"count-aa\",                        \"Count Alias Analysis Query Responses\"),\n-    (\"da\",                              \"Dependence Analysis\"),\n-    (\"debug-aa\",                        \"AA Use Debugger\"),\n-    (\"domfrontier\",                     \"Dominance Frontier Construction\"),\n-    (\"domtree\",                         \"Dominator Tree Construction\"),\n-    (\"globalsmodref-aa\",                \"Simple mod/ref analysis for globals\"),\n-    (\"instcount\",                       \"Count the various types of Instructions\"),\n-    (\"intervals\",                       \"Interval Partition Construction\"),\n-    (\"iv-users\",                        \"Induction Variable Users\"),\n-    (\"lazy-value-info\",                 \"Lazy Value Information Analysis\"),\n-    (\"libcall-aa\",                      \"LibCall Alias Analysis\"),\n-    (\"lint\",                            \"Statically lint-check LLVM IR\"),\n-    (\"loops\",                           \"Natural Loop Information\"),\n-    (\"memdep\",                          \"Memory Dependence Analysis\"),\n-    (\"module-debuginfo\",                \"Decodes module-level debug info\"),\n-    (\"profile-estimator\",               \"Estimate profiling information\"),\n-    (\"profile-loader\",                  \"Load profile information from llvmprof.out\"),\n-    (\"profile-verifier\",                \"Verify profiling information\"),\n-    (\"regions\",                         \"Detect single entry single exit regions\"),\n-    (\"scalar-evolution\",                \"Scalar Evolution Analysis\"),\n-    (\"scev-aa\",                         \"Scalar Evolution-based Alias Analysis\"),\n-    (\"tbaa\",                            \"Type-Based Alias Analysis\"),\n-    (\"tsan\",                            \"ThreadSanitizer\"),\n-];\n-\n-/** Transformation Passes */\n-pub static transform_passes : &'static [(&'static str, &'static str)] = &'static [\n-    (\"adce\",                            \"Aggressive Dead Code Elimination\"),\n-    (\"always-inline\",                   \"Inliner for #[inline] functions\"),\n-    (\"argpromotion\",                    \"Promote 'by reference' arguments to scalars\"),\n-    (\"bb-vectorize\",                    \"Basic-Block Vectorization\"),\n-    (\"block-placement\",                 \"Profile Guided Basic Block Placement\"),\n-    (\"bounds-checking\",                 \"Run-time bounds checking\"),\n-    (\"break-crit-edges\",                \"Break critical edges in CFG\"),\n-    (\"codegenprepare\",                  \"Optimize for code generation\"),\n-    (\"constmerge\",                      \"Merge Duplicate Global Constants\"),\n-    (\"constprop\",                       \"Simple constant propagation\"),\n-    (\"correlated-propagation\",          \"Value Propagation\"),\n-    (\"da\",                              \"Data Layout\"),\n-    (\"dce\",                             \"Dead Code Elimination\"),\n-    (\"deadargelim\",                     \"Dead Argument Elimination\"),\n-    (\"die\",                             \"Dead Instruction Elimination\"),\n-    (\"dse\",                             \"Dead Store Elimination\"),\n-    (\"early-cse\",                       \"Early CSE\"),\n-    (\"functionattrs\",                   \"Deduce function attributes\"),\n-    (\"globaldce\",                       \"Dead Global Elimination\"),\n-    (\"globalopt\",                       \"Global Variable Optimizer\"),\n-    (\"gvn\",                             \"Global Value Numbering\"),\n-    (\"indvars\",                         \"Canonicalize Induction Variables\"),\n-    (\"inline\",                          \"Function Integration/Inlining\"),\n-    (\"insert-edge-profiling\",           \"Insert instrumentation for edge profiling\"),\n-    (\"insert-gcov-profiling\",           \"Insert instrumentation for GCOV profiling\"),\n-    (\"insert-optimal-edge-profiling\",   \"Insert optimal instrumentation for edge profiling\"),\n-    (\"instcombine\",                     \"Combine redundant instructions\"),\n-    (\"instsimplify\",                    \"Remove redundant instructions\"),\n-    (\"ipconstprop\",                     \"Interprocedural constant propagation\"),\n-    (\"ipsccp\",                          \"Interprocedural Sparse Conditional Constant Propagation\"),\n-    (\"jump-threading\",                  \"Jump Threading\"),\n-    (\"lcssa\",                           \"Loop-Closed SSA Form Pass\"),\n-    (\"licm\",                            \"Loop Invariant Code Motion\"),\n-    (\"loop-deletion\",                   \"Delete dead loops\"),\n-    (\"loop-extract\",                    \"Extract loops into new functions\"),\n-    (\"loop-extract-single\",             \"Extract at most one loop into a new function\"),\n-    (\"loop-idiom\",                      \"Recognise loop idioms\"),\n-    (\"loop-instsimplify\",               \"Simplify instructions in loops\"),\n-    (\"loop-reduce\",                     \"Loop Strength Reduction\"),\n-    (\"loop-rotate\",                     \"Rotate Loops\"),\n-    (\"loop-simplify\",                   \"Canonicalize natural loops\"),\n-    (\"loop-unroll\",                     \"Unroll loops\"),\n-    (\"loop-unswitch\",                   \"Unswitch loops\"),\n-    (\"loop-vectorize\",                  \"Loop Vectorization\"),\n-    (\"lower-expect\",                    \"Lower 'expect' Intrinsics\"),\n-    (\"mem2reg\",                         \"Promote Memory to Register\"),\n-    (\"memcpyopt\",                       \"MemCpy Optimization\"),\n-    (\"mergefunc\",                       \"Merge Functions\"),\n-    (\"mergereturn\",                     \"Unify function exit nodes\"),\n-    (\"partial-inliner\",                 \"Partial Inliner\"),\n-    (\"prune-eh\",                        \"Remove unused exception handling info\"),\n-    (\"reassociate\",                     \"Reassociate expressions\"),\n-    (\"reg2mem\",                         \"Demote all values to stack slots\"),\n-    (\"scalarrepl\",                      \"Scalar Replacement of Aggregates (DT)\"),\n-    (\"scalarrepl-ssa\",                  \"Scalar Replacement of Aggregates (SSAUp)\"),\n-    (\"sccp\",                            \"Sparse Conditional Constant Propagation\"),\n-    (\"simplifycfg\",                     \"Simplify the CFG\"),\n-    (\"sink\",                            \"Code sinking\"),\n-    (\"strip\",                           \"Strip all symbols from a module\"),\n-    (\"strip-dead-debug-info\",           \"Strip debug info for unused symbols\"),\n-    (\"strip-dead-prototypes\",           \"Strip Unused Function Prototypes\"),\n-    (\"strip-debug-declare\",             \"Strip all llvm.dbg.declare intrinsics\"),\n-    (\"strip-nondebug\",                  \"Strip all symbols, except dbg symbols, from a module\"),\n-    (\"sroa\",                            \"Scalar Replacement of Aggregates\"),\n-    (\"tailcallelim\",                    \"Tail Call Elimination\"),\n-];\n-\n-/** Utility Passes */\n-static utility_passes : &'static [(&'static str, &'static str)] = &'static [\n-    (\"instnamer\",                       \"Assign names to anonymous instructions\"),\n-    (\"verify\",                          \"Module Verifier\"),\n-];\n-\n-#[test]\n-fn passes_exist() {\n-    let mut failed = ~[];\n-    unsafe { llvm::LLVMInitializePasses(); }\n-    for &(name,_) in analysis_passes.iter() {\n-        let pass = create_pass(name);\n-        if !pass.is_some() {\n-            failed.push(name);\n-        } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n-        }\n-    }\n-    for &(name,_) in transform_passes.iter() {\n-        let pass = create_pass(name);\n-        if !pass.is_some() {\n-            failed.push(name);\n-        } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n-        }\n-    }\n-    for &(name,_) in utility_passes.iter() {\n-        let pass = create_pass(name);\n-        if !pass.is_some() {\n-            failed.push(name);\n-        } else {\n-            unsafe { llvm::LLVMDestroyPass(pass.unwrap()) }\n-        }\n-    }\n-\n-    if failed.len() > 0 {\n-        io::println(\"Some passes don't exist:\");\n-        for &n in failed.iter() {\n-            printfln!(\"    %s\", n);\n-        }\n-        fail!();\n-    }\n-}"}, {"sha": "003840b85a16744b063e9fe57bf8c4785be398cf", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -848,8 +848,9 @@ pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n   optopt(\"\", \"opt-level\",\n                         \"Optimize with possible levels 0-3\", \"LEVEL\"),\n   optopt(\"\", \"passes\", \"Comma or space separated list of pass names to use. \\\n-                        Overrides the default passes for optimization levels,\\n\\\n-                        a value of \\\"list\\\" will list the available passes.\", \"NAMES\"),\n+                        Appends to the default list of passes to run for the \\\n+                        specified current optimization level. A value of \\\n+                        \\\"list\\\" will list all of the available passes\", \"NAMES\"),\n   optopt( \"\",  \"out-dir\",\n                         \"Write output to compiler-chosen filename\n                           in <dir>\", \"DIR\"),"}, {"sha": "912fc606f0a344d6e126c4f39c561002c0970b81", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -76,6 +76,9 @@ pub static print_link_args:         uint = 1 << 23;\n pub static no_debug_borrows:        uint = 1 << 24;\n pub static lint_llvm:               uint = 1 << 25;\n pub static once_fns:                uint = 1 << 26;\n+pub static print_llvm_passes:       uint = 1 << 27;\n+pub static no_vectorize_loops:      uint = 1 << 28;\n+pub static no_vectorize_slp:        uint = 1 << 29;\n \n pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n     ~[(~\"verbose\", ~\"in general, enable more debug printouts\", verbose),\n@@ -120,6 +123,15 @@ pub fn debugging_opts_map() -> ~[(~str, ~str, uint)] {\n      (~\"once-fns\",\n       ~\"Allow 'once fn' closures to deinitialize captured variables\",\n       once_fns),\n+     (~\"print-llvm-passes\",\n+      ~\"Prints the llvm optimization passes being run\",\n+      print_llvm_passes),\n+     (~\"no-vectorize-loops\",\n+      ~\"Don't run the loop vectorization optimization passes\",\n+      no_vectorize_loops),\n+     (~\"no-vectorize-slp\",\n+      ~\"Don't run LLVM's SLP vectorization passes\",\n+      no_vectorize_slp),\n     ]\n }\n \n@@ -305,6 +317,15 @@ impl Session_ {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }\n     pub fn once_fns(@self) -> bool { self.debugging_opt(once_fns) }\n+    pub fn print_llvm_passes(@self) -> bool {\n+        self.debugging_opt(print_llvm_passes)\n+    }\n+    pub fn no_vectorize_loops(@self) -> bool {\n+        self.debugging_opt(no_vectorize_loops)\n+    }\n+    pub fn no_vectorize_slp(@self) -> bool {\n+        self.debugging_opt(no_vectorize_slp)\n+    }\n \n     // pointless function, now...\n     pub fn str_of(@self, id: ast::ident) -> @str {"}, {"sha": "220b082fab1cf986fd7fa8318a3f853b1d50d4f5", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 77, "deletions": 44, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -170,7 +170,6 @@ pub enum AtomicOrdering {\n     SequentiallyConsistent = 7\n }\n \n-// FIXME: Not used right now, but will be once #2334 is fixed\n // Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n pub enum FileType {\n     AssemblyFile = 0,\n@@ -192,6 +191,29 @@ pub enum AsmDialect {\n     AD_Intel = 1\n }\n \n+pub enum CodeGenOptLevel {\n+    CodeGenLevelNone = 0,\n+    CodeGenLevelLess = 1,\n+    CodeGenLevelDefault = 2,\n+    CodeGenLevelAggressive = 3,\n+}\n+\n+pub enum RelocMode {\n+    RelocDefault = 0,\n+    RelocStatic = 1,\n+    RelocPIC = 2,\n+    RelocDynamicNoPic = 3,\n+}\n+\n+pub enum CodeGenModel {\n+    CodeModelDefault = 0,\n+    CodeModelJITDefault = 1,\n+    CodeModelSmall = 2,\n+    CodeModelKernel = 3,\n+    CodeModelMedium = 4,\n+    CodeModelLarge = 5,\n+}\n+\n // Opaque pointer types\n pub enum Module_opaque {}\n pub type ModuleRef = *Module_opaque;\n@@ -223,6 +245,8 @@ pub enum SectionIterator_opaque {}\n pub type SectionIteratorRef = *SectionIterator_opaque;\n pub enum Pass_opaque {}\n pub type PassRef = *Pass_opaque;\n+pub enum TargetMachine_opaque {}\n+pub type TargetMachineRef = *TargetMachine_opaque;\n \n pub mod debuginfo {\n     use super::{ValueRef};\n@@ -266,7 +290,8 @@ pub mod llvm {\n     use super::{Bool, BuilderRef, ContextRef, MemoryBufferRef, ModuleRef};\n     use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n-    use super::{ValueRef, PassRef};\n+    use super::{ValueRef, TargetMachineRef, FileType};\n+    use super::{CodeGenModel, RelocMode, CodeGenOptLevel};\n     use super::debuginfo::*;\n     use std::libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong};\n \n@@ -1614,6 +1639,7 @@ pub mod llvm {\n         /** Creates a pass manager. */\n         #[fast_ffi]\n         pub fn LLVMCreatePassManager() -> PassManagerRef;\n+\n         /** Creates a function-by-function pass manager */\n         #[fast_ffi]\n         pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n@@ -1643,15 +1669,6 @@ pub mod llvm {\n         #[fast_ffi]\n         pub fn LLVMInitializePasses();\n \n-        #[fast_ffi]\n-        pub fn LLVMAddPass(PM: PassManagerRef, P: PassRef);\n-\n-        #[fast_ffi]\n-        pub fn LLVMCreatePass(PassName: *c_char) -> PassRef;\n-\n-        #[fast_ffi]\n-        pub fn LLVMDestroyPass(P: PassRef);\n-\n         /** Adds a verification pass. */\n         #[fast_ffi]\n         pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n@@ -1808,20 +1825,6 @@ pub mod llvm {\n         pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *c_char)\n             -> MemoryBufferRef;\n \n-        #[fast_ffi]\n-        pub fn LLVMRustWriteOutputFile(PM: PassManagerRef,\n-                                       M: ModuleRef,\n-                                       Triple: *c_char,\n-                                       Cpu: *c_char,\n-                                       Feature: *c_char,\n-                                       Output: *c_char,\n-                                       // FIXME: When #2334 is fixed,\n-                                       // change c_uint to FileType\n-                                       FileType: c_uint,\n-                                       OptLevel: c_int,\n-                                       EnableSegmentedStacks: bool)\n-                                       -> bool;\n-\n         /** Returns a string describing the last error caused by an LLVMRust*\n             call. */\n         #[fast_ffi]\n@@ -1842,24 +1845,6 @@ pub mod llvm {\n                                 EnableSegmentedStacks: bool)\n                                 -> ExecutionEngineRef;\n \n-        /** Parses the bitcode in the given memory buffer. */\n-        #[fast_ffi]\n-        pub fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef) -> ModuleRef;\n-\n-        /** Parses LLVM asm in the given file */\n-        #[fast_ffi]\n-        pub fn LLVMRustParseAssemblyFile(Filename: *c_char, C: ContextRef)\n-                                         -> ModuleRef;\n-\n-        #[fast_ffi]\n-        pub fn LLVMRustAddPrintModulePass(PM: PassManagerRef,\n-                                          M: ModuleRef,\n-                                          Output: *c_char);\n-\n-        /** Turn on LLVM pass-timing. */\n-        #[fast_ffi]\n-        pub fn LLVMRustEnableTimePasses();\n-\n         /// Print the pass timings since static dtors aren't picking them up.\n         #[fast_ffi]\n         pub fn LLVMRustPrintPassTimings();\n@@ -2097,6 +2082,55 @@ pub mod llvm {\n                                                         LineNo: c_uint,\n                                                         ColumnNo: c_uint)\n                                                         -> ValueRef;\n+\n+        pub fn LLVMInitializeX86TargetInfo();\n+        pub fn LLVMInitializeX86Target();\n+        pub fn LLVMInitializeX86TargetMC();\n+        pub fn LLVMInitializeX86AsmPrinter();\n+        pub fn LLVMInitializeX86AsmParser();\n+        pub fn LLVMInitializeARMTargetInfo();\n+        pub fn LLVMInitializeARMTarget();\n+        pub fn LLVMInitializeARMTargetMC();\n+        pub fn LLVMInitializeARMAsmPrinter();\n+        pub fn LLVMInitializeARMAsmParser();\n+        pub fn LLVMInitializeMipsTargetInfo();\n+        pub fn LLVMInitializeMipsTarget();\n+        pub fn LLVMInitializeMipsTargetMC();\n+        pub fn LLVMInitializeMipsAsmPrinter();\n+        pub fn LLVMInitializeMipsAsmParser();\n+\n+        pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: *c_char) -> bool;\n+        pub fn LLVMRustCreateTargetMachine(Triple: *c_char,\n+                                           CPU: *c_char,\n+                                           Features: *c_char,\n+                                           Model: CodeGenModel,\n+                                           Reloc: RelocMode,\n+                                           Level: CodeGenOptLevel,\n+                                           EnableSegstk: bool) -> TargetMachineRef;\n+        pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n+        pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n+                                         PM: PassManagerRef,\n+                                         M: ModuleRef);\n+        pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n+                                             M: ModuleRef);\n+        pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef);\n+        pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n+        pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n+                                       PM: PassManagerRef,\n+                                       M: ModuleRef,\n+                                       Output: *c_char,\n+                                       FileType: FileType) -> bool;\n+        pub fn LLVMRustPrintModule(PM: PassManagerRef,\n+                                   M: ModuleRef,\n+                                   Output: *c_char);\n+        pub fn LLVMRustSetLLVMOptions(PrintPasses: bool,\n+                                      VectorizeLoops: bool,\n+                                      VectorizeSLP: bool,\n+                                      TimePasses: bool);\n+        pub fn LLVMRustPrintPasses();\n+        pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *c_char);\n+        pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n+                                           AddLifetimes: bool);\n     }\n }\n \n@@ -2244,7 +2278,6 @@ impl TypeNames {\n     }\n }\n \n-\n /* Memory-managed interface to target data. */\n \n pub struct target_data_res {"}, {"sha": "9f99a0c92e534b12d77e56decf1aa87fc5df230f", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -137,7 +137,7 @@ impl CrateContext {\n                 llvm::LLVMSetDataLayout(llmod, buf)\n             };\n             do targ_triple.with_c_str |buf| {\n-                llvm::LLVMSetTarget(llmod, buf)\n+                llvm::LLVMRustSetNormalizedTarget(llmod, buf)\n             };\n             let targ_cfg = sess.targ_cfg;\n "}, {"sha": "06b3f6aae2710b142f11e20b24d16e6b2e85e7fd", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -92,7 +92,6 @@ pub mod back {\n     pub mod x86_64;\n     pub mod rpath;\n     pub mod target_strs;\n-    pub mod passes;\n }\n \n pub mod metadata;\n@@ -232,7 +231,7 @@ pub fn run_compiler(args: &[~str], demitter: diagnostic::Emitter) {\n     }\n \n     if getopts::opt_maybe_str(matches, \"passes\") == Some(~\"list\") {\n-        back::passes::list_passes();\n+        unsafe { lib::llvm::llvm::LLVMRustPrintPasses(); }\n         return;\n     }\n "}, {"sha": "a538566fa189822b1da848a41208098a025df4ea", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -57,6 +57,7 @@ impl<'self> Repr<Slice<u8>> for &'self str {}\n impl<T> Repr<*Box<T>> for @T {}\n impl<T> Repr<*Box<Vec<T>>> for @[T] {}\n impl Repr<*String> for ~str {}\n+impl Repr<*Box<String>> for @str {}\n \n // sure would be nice to have this\n // impl<T> Repr<*Vec<T>> for ~[T] {}"}, {"sha": "56ba56cf89377fb2ea265ce1dca82df995bb5c70", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 190, "deletions": 31, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -8,29 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#include <stdio.h>\n+\n #include \"rustllvm.h\"\n \n-using namespace llvm;\n+#include \"llvm/Support/CBindingWrapping.h\"\n+#include \"llvm/Target/TargetLibraryInfo.h\"\n+#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n \n-// Pass conversion fns\n-typedef struct LLVMOpaquePass *LLVMPassRef;\n+#include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n-inline Pass *unwrap(LLVMPassRef P) {\n-    return reinterpret_cast<Pass*>(P);\n-}\n+using namespace llvm;\n \n-inline LLVMPassRef wrap(const Pass *P) {\n-    return reinterpret_cast<LLVMPassRef>(const_cast<Pass*>(P));\n-}\n+extern cl::opt<bool> EnableARMEHABI;\n \n-template<typename T>\n-inline T *unwrap(LLVMPassRef P) {\n-    T *Q = (T*)unwrap(P);\n-    assert(Q && \"Invalid cast!\");\n-    return Q;\n-}\n+typedef struct LLVMOpaquePass *LLVMPassRef;\n+typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n+\n+DEFINE_STDCXX_CONVERSION_FUNCTIONS(Pass, LLVMPassRef)\n+DEFINE_STDCXX_CONVERSION_FUNCTIONS(TargetMachine, LLVMTargetMachineRef)\n+DEFINE_STDCXX_CONVERSION_FUNCTIONS(PassManagerBuilder, LLVMPassManagerBuilderRef)\n \n-extern \"C\" void LLVMInitializePasses() {\n+extern \"C\" void\n+LLVMInitializePasses() {\n   PassRegistry &Registry = *PassRegistry::getPassRegistry();\n   initializeCore(Registry);\n   initializeCodeGen(Registry);\n@@ -45,26 +45,185 @@ extern \"C\" void LLVMInitializePasses() {\n   initializeTarget(Registry);\n }\n \n-extern \"C\" void LLVMAddPass(LLVMPassManagerRef PM, LLVMPassRef P) {\n-    PassManagerBase * pm = unwrap(PM);\n-    Pass * p = unwrap(P);\n-\n-    pm->add(p);\n-}\n+extern \"C\" bool\n+LLVMRustAddPass(LLVMPassManagerRef PM, const char *PassName) {\n+    PassManagerBase *pm = unwrap(PM);\n \n-extern \"C\" LLVMPassRef LLVMCreatePass(const char * PassName) {\n     StringRef SR(PassName);\n-    PassRegistry * PR = PassRegistry::getPassRegistry();\n+    PassRegistry *PR = PassRegistry::getPassRegistry();\n \n-    const PassInfo * PI = PR->getPassInfo(SR);\n+    const PassInfo *PI = PR->getPassInfo(SR);\n     if (PI) {\n-        return wrap(PI->createPass());\n-    } else {\n-        return (LLVMPassRef)0;\n+        pm->add(PI->createPass());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+extern \"C\" LLVMTargetMachineRef\n+LLVMRustCreateTargetMachine(const char *triple,\n+                            const char *cpu,\n+                            const char *feature,\n+                            CodeModel::Model CM,\n+                            Reloc::Model RM,\n+                            CodeGenOpt::Level OptLevel,\n+                            bool EnableSegmentedStacks) {\n+    std::string Error;\n+    Triple Trip(Triple::normalize(triple));\n+    const llvm::Target *TheTarget = TargetRegistry::lookupTarget(Trip.getTriple(),\n+                                                                 Error);\n+    if (TheTarget == NULL) {\n+        LLVMRustError = Error.c_str();\n+        return NULL;\n+    }\n+\n+    TargetOptions Options;\n+    Options.EnableSegmentedStacks = EnableSegmentedStacks;\n+    Options.FixedStackSegmentSize = 2 * 1024 * 1024; // XXX: This is too big.\n+    Options.FloatABIType =\n+         (Trip.getEnvironment() == Triple::GNUEABIHF) ? FloatABI::Hard :\n+                                                        FloatABI::Default;\n+\n+    TargetMachine *TM = TheTarget->createTargetMachine(Trip.getTriple(),\n+                                                       cpu,\n+                                                       feature,\n+                                                       Options,\n+                                                       RM,\n+                                                       CM,\n+                                                       OptLevel);\n+    return wrap(TM);\n+}\n+\n+extern \"C\" void\n+LLVMRustDisposeTargetMachine(LLVMTargetMachineRef TM) {\n+    delete unwrap(TM);\n+}\n+\n+// Unfortunately, LLVM doesn't expose a C API to add the corresponding analysis\n+// passes for a target to a pass manager. We export that functionality through\n+// this function.\n+extern \"C\" void\n+LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n+                          LLVMPassManagerRef PMR,\n+                          LLVMModuleRef M) {\n+    PassManagerBase *PM = unwrap(PMR);\n+    PM->add(new DataLayout(unwrap(M)));\n+    unwrap(TM)->addAnalysisPasses(*PM);\n+}\n+\n+// Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n+// field of a PassManagerBuilder, we expose our own method of doing so.\n+extern \"C\" void\n+LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB, LLVMModuleRef M) {\n+    Triple TargetTriple(unwrap(M)->getTargetTriple());\n+    unwrap(PMB)->LibraryInfo = new TargetLibraryInfo(TargetTriple);\n+}\n+\n+// Unfortunately, the LLVM C API doesn't provide a way to create the\n+// TargetLibraryInfo pass, so we use this method to do so.\n+extern \"C\" void\n+LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB, LLVMModuleRef M) {\n+    Triple TargetTriple(unwrap(M)->getTargetTriple());\n+    unwrap(PMB)->add(new TargetLibraryInfo(TargetTriple));\n+}\n+\n+// Unfortunately, the LLVM C API doesn't provide an easy way of iterating over\n+// all the functions in a module, so we do that manually here. You'll find\n+// similar code in clang's BackendUtil.cpp file.\n+extern \"C\" void\n+LLVMRustRunFunctionPassManager(LLVMPassManagerRef PM, LLVMModuleRef M) {\n+    FunctionPassManager *P = unwrap<FunctionPassManager>(PM);\n+    P->doInitialization();\n+    for (Module::iterator I = unwrap(M)->begin(),\n+         E = unwrap(M)->end(); I != E; ++I)\n+        if (!I->isDeclaration())\n+            P->run(*I);\n+    P->doFinalization();\n+}\n+\n+extern \"C\" void\n+LLVMRustSetLLVMOptions(bool PrintPasses,\n+                       bool VectorizeLoops,\n+                       bool VectorizeSLP,\n+                       bool TimePasses) {\n+    // Initializing the command-line options more than once is not allowed. So,\n+    // check if they've already been initialized.  (This could happen if we're\n+    // being called from rustpkg, for example). If the arguments change, then\n+    // that's just kinda unfortunate.\n+    static bool initialized = false;\n+    if (initialized) return;\n+\n+    int argc = 3;\n+    const char *argv[20] = {\"rustc\",\n+                            \"-arm-enable-ehabi\",\n+                            \"-arm-enable-ehabi-descriptors\"};\n+    if (PrintPasses) {\n+        argv[argc++] = \"-debug-pass\";\n+        argv[argc++] = \"Structure\";\n+    }\n+    if (VectorizeLoops) {\n+        argv[argc++] = \"-vectorize-loops\";\n+    }\n+    if (VectorizeSLP) {\n+        argv[argc++] = \"-vectorize-slp\";\n     }\n+    if (TimePasses) {\n+        argv[argc++] = \"-time-passes\";\n+    }\n+    cl::ParseCommandLineOptions(argc, argv);\n+    initialized = true;\n+}\n+\n+extern \"C\" bool\n+LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n+                        LLVMPassManagerRef PMR,\n+                        LLVMModuleRef M,\n+                        const char *path,\n+                        TargetMachine::CodeGenFileType FileType) {\n+  PassManager *PM = unwrap<PassManager>(PMR);\n+\n+  std::string ErrorInfo;\n+  raw_fd_ostream OS(path, ErrorInfo, sys::fs::F_Binary);\n+  if (ErrorInfo != \"\") {\n+    LLVMRustError = ErrorInfo.c_str();\n+    return false;\n+  }\n+  formatted_raw_ostream FOS(OS);\n+\n+  unwrap(Target)->addPassesToEmitFile(*PM, FOS, FileType, false);\n+  PM->run(*unwrap(M));\n+  return true;\n+}\n+\n+extern \"C\" void\n+LLVMRustPrintModule(LLVMPassManagerRef PMR,\n+                    LLVMModuleRef M,\n+                    const char* path) {\n+  PassManager *PM = unwrap<PassManager>(PMR);\n+  std::string ErrorInfo;\n+  raw_fd_ostream OS(path, ErrorInfo, sys::fs::F_Binary);\n+  formatted_raw_ostream FOS(OS);\n+  PM->add(createPrintModulePass(&FOS));\n+  PM->run(*unwrap(M));\n+}\n+\n+extern \"C\" void\n+LLVMRustPrintPasses() {\n+    LLVMInitializePasses();\n+    struct MyListener : PassRegistrationListener {\n+        void passEnumerate(const PassInfo *info) {\n+            if (info->getPassArgument() && *info->getPassArgument()) {\n+                printf(\"%15s - %s\\n\", info->getPassArgument(),\n+                       info->getPassName());\n+            }\n+        }\n+    } listener;\n+\n+    PassRegistry *PR = PassRegistry::getPassRegistry();\n+    PR->enumerateWith(&listener);\n }\n \n-extern \"C\" void LLVMDestroyPass(LLVMPassRef PassRef) {\n-    Pass *p = unwrap(PassRef);\n-    delete p;\n+extern \"C\" void\n+LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB, bool AddLifetimes) {\n+    unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n }"}, {"sha": "40ee486ec2d9c6a2906e75f4ce132bc58024b1d1", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 143, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -20,9 +20,7 @@\n using namespace llvm;\n using namespace llvm::sys;\n \n-static const char *LLVMRustError;\n-\n-extern cl::opt<bool> EnableARMEHABI;\n+const char *LLVMRustError;\n \n extern \"C\" LLVMMemoryBufferRef\n LLVMRustCreateMemoryBufferWithContentsOfFile(const char *Path) {\n@@ -36,62 +34,6 @@ extern \"C\" const char *LLVMRustGetLastError(void) {\n   return LLVMRustError;\n }\n \n-extern \"C\" void LLVMAddBasicAliasAnalysisPass(LLVMPassManagerRef PM);\n-\n-extern \"C\" void LLVMRustAddPrintModulePass(LLVMPassManagerRef PMR,\n-                                           LLVMModuleRef M,\n-                                           const char* path) {\n-  PassManager *PM = unwrap<PassManager>(PMR);\n-  std::string ErrorInfo;\n-  raw_fd_ostream OS(path, ErrorInfo, sys::fs::F_Binary);\n-  formatted_raw_ostream FOS(OS);\n-  PM->add(createPrintModulePass(&FOS));\n-  PM->run(*unwrap(M));\n-}\n-\n-void LLVMInitializeX86TargetInfo();\n-void LLVMInitializeX86Target();\n-void LLVMInitializeX86TargetMC();\n-void LLVMInitializeX86AsmPrinter();\n-void LLVMInitializeX86AsmParser();\n-\n-\n-void LLVMInitializeARMTargetInfo();\n-void LLVMInitializeARMTarget();\n-void LLVMInitializeARMTargetMC();\n-void LLVMInitializeARMAsmPrinter();\n-void LLVMInitializeARMAsmParser();\n-\n-void LLVMInitializeMipsTargetInfo();\n-void LLVMInitializeMipsTarget();\n-void LLVMInitializeMipsTargetMC();\n-void LLVMInitializeMipsAsmPrinter();\n-void LLVMInitializeMipsAsmParser();\n-// Only initialize the platforms supported by Rust here,\n-// because using --llvm-root will have multiple platforms\n-// that rustllvm doesn't actually link to and it's pointless to put target info\n-// into the registry that Rust can not generate machine code for.\n-\n-void LLVMRustInitializeTargets() {\n-  LLVMInitializeX86TargetInfo();\n-  LLVMInitializeX86Target();\n-  LLVMInitializeX86TargetMC();\n-  LLVMInitializeX86AsmPrinter();\n-  LLVMInitializeX86AsmParser();\n-\n-  LLVMInitializeARMTargetInfo();\n-  LLVMInitializeARMTarget();\n-  LLVMInitializeARMTargetMC();\n-  LLVMInitializeARMAsmPrinter();\n-  LLVMInitializeARMAsmParser();\n-\n-  LLVMInitializeMipsTargetInfo();\n-  LLVMInitializeMipsTarget();\n-  LLVMInitializeMipsTargetMC();\n-  LLVMInitializeMipsAsmPrinter();\n-  LLVMInitializeMipsAsmParser();\n-}\n-\n // Custom memory manager for MCJITting. It needs special features\n // that the generic JIT memory manager doesn't entail. Based on\n // code from LLI, change where needed for Rust.\n@@ -367,85 +309,9 @@ LLVMRustBuildJIT(void* mem,\n   return wrap(EE);\n }\n \n-extern \"C\" bool\n-LLVMRustWriteOutputFile(LLVMPassManagerRef PMR,\n-                        LLVMModuleRef M,\n-                        const char *triple,\n-                        const char *cpu,\n-                        const char *feature,\n-                        const char *path,\n-                        TargetMachine::CodeGenFileType FileType,\n-                        CodeGenOpt::Level OptLevel,\n-      bool EnableSegmentedStacks) {\n-\n-  LLVMRustInitializeTargets();\n-\n-  // Initializing the command-line options more than once is not\n-  // allowed. So, check if they've already been initialized.\n-  // (This could happen if we're being called from rustpkg, for\n-  // example.)\n-  if (!EnableARMEHABI) {\n-    int argc = 3;\n-    const char* argv[] = {\"rustc\", \"-arm-enable-ehabi\",\n-        \"-arm-enable-ehabi-descriptors\"};\n-    cl::ParseCommandLineOptions(argc, argv);\n-  }\n-\n-  Triple Trip(Triple::normalize(triple));\n-\n-  TargetOptions Options;\n-  Options.EnableSegmentedStacks = EnableSegmentedStacks;\n-  Options.FixedStackSegmentSize = 2 * 1024 * 1024;  // XXX: This is too big.\n-  Options.FloatABIType =\n-      (Trip.getEnvironment() == Triple::GNUEABIHF) ? FloatABI::Hard :\n-                                                     FloatABI::Default;\n-\n-  PassManager *PM = unwrap<PassManager>(PMR);\n-\n-  std::string Err;\n-  std::string FeaturesStr(feature);\n-  std::string CPUStr(cpu);\n-  const Target *TheTarget = TargetRegistry::lookupTarget(Trip.getTriple(), Err);\n-  TargetMachine *Target =\n-    TheTarget->createTargetMachine(Trip.getTriple(), CPUStr, FeaturesStr,\n-           Options, Reloc::PIC_,\n-           CodeModel::Default, OptLevel);\n-  Target->addAnalysisPasses(*PM);\n-\n-  bool NoVerify = false;\n-  std::string ErrorInfo;\n-  raw_fd_ostream OS(path, ErrorInfo,\n-                    sys::fs::F_Binary);\n-  if (ErrorInfo != \"\") {\n-    LLVMRustError = ErrorInfo.c_str();\n-    return false;\n-  }\n-  formatted_raw_ostream FOS(OS);\n-\n-  bool foo = Target->addPassesToEmitFile(*PM, FOS, FileType, NoVerify);\n-  assert(!foo);\n-  (void)foo;\n-  PM->run(*unwrap(M));\n-  delete Target;\n-  return true;\n-}\n-\n-extern \"C\" LLVMModuleRef LLVMRustParseAssemblyFile(LLVMContextRef C,\n-                                                   const char *Filename) {\n-  SMDiagnostic d;\n-  Module *m = ParseAssemblyFile(Filename, d, *unwrap(C));\n-  if (m) {\n-    return wrap(m);\n-  } else {\n-    LLVMRustError = d.getMessage().str().c_str();\n-    return NULL;\n-  }\n-}\n-\n-extern \"C\" LLVMModuleRef LLVMRustParseBitcode(LLVMMemoryBufferRef MemBuf) {\n-  LLVMModuleRef M;\n-  return LLVMParseBitcode(MemBuf, &M, const_cast<char **>(&LLVMRustError))\n-         ? NULL : M;\n+extern \"C\" void\n+LLVMRustSetNormalizedTarget(LLVMModuleRef M, const char *triple) {\n+    unwrap(M)->setTargetTriple(Triple::normalize(triple));\n }\n \n extern \"C\" LLVMValueRef LLVMRustConstSmallInt(LLVMTypeRef IntTy, unsigned N,\n@@ -463,11 +329,6 @@ extern \"C\" LLVMValueRef LLVMRustConstInt(LLVMTypeRef IntTy,\n   return LLVMConstInt(IntTy, N, SignExtend);\n }\n \n-extern bool llvm::TimePassesIsEnabled;\n-extern \"C\" void LLVMRustEnableTimePasses() {\n-  TimePassesIsEnabled = true;\n-}\n-\n extern \"C\" void LLVMRustPrintPassTimings() {\n   raw_fd_ostream OS (2, false); // stderr.\n   TimerGroup::printAll(OS);"}, {"sha": "e2cec6a04f346001e6a03dbbddca691e59a6ef6a", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -1,14 +1,11 @@\n LLVMRustCreateMemoryBufferWithContentsOfFile\n-LLVMRustEnableTimePasses\n LLVMRustWriteOutputFile\n LLVMRustGetLastError\n LLVMRustConstSmallInt\n LLVMRustConstInt\n LLVMRustLoadCrate\n LLVMRustPrepareJIT\n LLVMRustBuildJIT\n-LLVMRustParseBitcode\n-LLVMRustParseAssemblyFile\n LLVMRustPrintPassTimings\n LLVMRustStartMultithreading\n LLVMCreateObjectFile\n@@ -28,7 +25,6 @@ LLVMAddAlias\n LLVMAddArgumentPromotionPass\n LLVMAddAttribute\n LLVMAddBasicAliasAnalysisPass\n-LLVMRustAddPrintModulePass\n LLVMAddCFGSimplificationPass\n LLVMAddCase\n LLVMAddClause\n@@ -589,9 +585,6 @@ LLVMStructCreateNamed\n LLVMStructSetBody\n LLVMInlineAsm\n LLVMInitializePasses\n-LLVMAddPass\n-LLVMCreatePass\n-LLVMDestroyPass\n LLVMDIBuilderCreate\n LLVMDIBuilderDispose\n LLVMDIBuilderFinalize\n@@ -616,3 +609,15 @@ LLVMDIBuilderCreateEnumerationType\n LLVMDIBuilderCreateUnionType\n LLVMDIBuilderCreateTemplateTypeParameter\n LLVMSetUnnamedAddr\n+LLVMRustAddPass\n+LLVMRustAddAnalysisPasses\n+LLVMRustAddLibraryInfo\n+LLVMRustCreateTargetMachine\n+LLVMRustRunFunctionPassManager\n+LLVMRustPrintModule\n+LLVMRustDisposeTargetMachine\n+LLVMRustAddBuilderLibraryInfo\n+LLVMRustSetLLVMOptions\n+LLVMRustPrintPasses\n+LLVMRustSetNormalizedTarget\n+LLVMRustAddAlwaysInlinePass"}, {"sha": "94bb00aab77577cc4871d4c9d42cd6af762e33dd", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/35f975b83881106e0fde729b8c1361c9cf6d2778/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=35f975b83881106e0fde729b8c1361c9cf6d2778", "patch": "@@ -59,3 +59,5 @@\n #include <fcntl.h>\n #include <unistd.h>\n #endif\n+\n+extern const char* LLVMRustError;"}]}