{"sha": "5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZjZhZjA5ZTNiOWRmM2RkMDFmMGU0ZDUzMTc2YjBhNzJjZTU3MjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T00:56:18Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T02:50:57Z"}, "message": "rustc: move defaulting's use of &mut Substs from InferCtxt to typeck.", "tree": {"sha": "c02afa31af0009a0ee632c7eb159bc14aa77ec2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c02afa31af0009a0ee632c7eb159bc14aa77ec2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "html_url": "https://github.com/rust-lang/rust/commit/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c87063f07e8f74c1950f3fd099fb578a833682c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c87063f07e8f74c1950f3fd099fb578a833682c5", "html_url": "https://github.com/rust-lang/rust/commit/c87063f07e8f74c1950f3fd099fb578a833682c5"}], "stats": {"total": 445, "additions": 213, "deletions": 232}, "files": [{"sha": "79eea7314cdf3ae1f5b6d29d47461f306baad147", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 59, "deletions": 63, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -1172,15 +1172,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(false))\n     }\n \n-    pub fn next_ty_var_with_default(&self,\n-                                    default: Option<type_variable::Default<'tcx>>) -> Ty<'tcx> {\n-        let ty_var_id = self.type_variables\n-                            .borrow_mut()\n-                            .new_var(false, default);\n-\n-        self.tcx.mk_var(ty_var_id)\n-    }\n-\n     pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n@@ -1205,35 +1196,49 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         ty::ReVar(self.region_vars.new_region_var(origin))\n     }\n \n+    /// Create a region inference variable for the given\n+    /// region parameter definition.\n+    pub fn region_var_for_def(&self,\n+                              span: Span,\n+                              def: &ty::RegionParameterDef)\n+                              -> ty::Region {\n+        self.next_region_var(EarlyBoundRegion(span, def.name))\n+    }\n+\n+    /// Create a type inference variable for the given\n+    /// type parameter definition. The substitutions are\n+    /// for actual parameters that may be referred to by\n+    /// the default of this type parameter, if it exists.\n+    /// E.g. `struct Foo<A, B, C = (A, B)>(...);` when\n+    /// used in a path such as `Foo::<T, U>::new()` will\n+    /// use an inference variable for `C` with `[T, U]`\n+    /// as the substitutions for the default, `(T, U)`.\n+    pub fn type_var_for_def(&self,\n+                            span: Span,\n+                            def: &ty::TypeParameterDef<'tcx>,\n+                            substs: &Substs<'tcx>)\n+                            -> Ty<'tcx> {\n+        let default = def.default.map(|default| {\n+            type_variable::Default {\n+                ty: default.subst_spanned(self.tcx, substs, Some(span)),\n+                origin_span: span,\n+                def_id: def.default_def_id\n+            }\n+        });\n+\n+\n+        let ty_var_id = self.type_variables\n+                            .borrow_mut()\n+                            .new_var(false, default);\n+\n+        self.tcx.mk_var(ty_var_id)\n+    }\n+\n     pub fn region_vars_for_defs(&self,\n                                 span: Span,\n                                 defs: &[ty::RegionParameterDef])\n                                 -> Vec<ty::Region> {\n-        defs.iter()\n-            .map(|d| self.next_region_var(EarlyBoundRegion(span, d.name)))\n-            .collect()\n-    }\n-\n-    // We have to take `&mut Substs` in order to provide the correct substitutions for defaults\n-    // along the way, for this reason we don't return them.\n-    pub fn type_vars_for_defs(&self,\n-                              span: Span,\n-                              space: subst::ParamSpace,\n-                              substs: &mut Substs<'tcx>,\n-                              defs: &[ty::TypeParameterDef<'tcx>]) {\n-\n-        for def in defs.iter() {\n-            let default = def.default.map(|default| {\n-                type_variable::Default {\n-                    ty: default.subst_spanned(self.tcx, substs, Some(span)),\n-                    origin_span: span,\n-                    def_id: def.default_def_id\n-                }\n-            });\n-\n-            let ty_var = self.next_ty_var_with_default(default);\n-            substs.types.push(space, ty_var);\n-        }\n+        defs.iter().map(|def| self.region_var_for_def(span, def)).collect()\n     }\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n@@ -1243,21 +1248,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                      generics: &ty::Generics<'tcx>)\n                                      -> &'tcx subst::Substs<'tcx>\n     {\n-        let type_params = subst::VecPerParamSpace::empty();\n-\n-        let region_params =\n-            generics.regions.map(\n-                |d| self.next_region_var(EarlyBoundRegion(span, d.name)));\n-\n-        let mut substs = subst::Substs::new(type_params, region_params);\n-\n-        for space in subst::ParamSpace::all().iter() {\n-            self.type_vars_for_defs(\n-                span,\n-                *space,\n-                &mut substs,\n-                generics.types.get_slice(*space));\n-        }\n+        let type_defs = generics.types.as_full_slice();\n+        let region_defs = generics.regions.as_full_slice();\n+        let substs = Substs::from_param_defs(region_defs, type_defs, |def| {\n+            self.region_var_for_def(span, def)\n+        }, |def, substs| {\n+            self.type_var_for_def(span, def, substs)\n+        });\n \n         self.tcx.mk_substs(substs)\n     }\n@@ -1269,25 +1266,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   span: Span,\n                                   generics: &ty::Generics<'tcx>,\n                                   self_ty: Ty<'tcx>)\n-                                  -> subst::Substs<'tcx>\n+                                  -> &'tcx subst::Substs<'tcx>\n     {\n-\n         assert!(generics.types.len(subst::SelfSpace) == 1);\n         assert!(generics.types.len(subst::FnSpace) == 0);\n-        assert!(generics.regions.len(subst::SelfSpace) == 0);\n-        assert!(generics.regions.len(subst::FnSpace) == 0);\n-\n-        let type_params = Vec::new();\n-\n-        let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n-        let regions = self.region_vars_for_defs(span, region_param_defs);\n \n-        let mut substs = subst::Substs::new_trait(type_params, regions, self_ty);\n-\n-        let type_parameter_defs = generics.types.get_slice(subst::TypeSpace);\n-        self.type_vars_for_defs(span, subst::TypeSpace, &mut substs, type_parameter_defs);\n+        let type_defs = generics.types.as_full_slice();\n+        let region_defs = generics.regions.as_full_slice();\n+        let substs = Substs::from_param_defs(region_defs, type_defs, |def| {\n+            self.region_var_for_def(span, def)\n+        }, |def, substs| {\n+            if def.space == subst::SelfSpace {\n+                self_ty\n+            } else {\n+                self.type_var_for_def(span, def, substs)\n+            }\n+        });\n \n-        return substs;\n+        self.tcx.mk_substs(substs)\n     }\n \n     pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {"}, {"sha": "5d50eac1716a35e3045d7c440bf786bb2873a0f3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -31,7 +31,7 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n-use ty::subst::{self, Subst, TypeSpace};\n+use ty::subst::{Subst, TypeSpace};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n@@ -167,27 +167,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    fn impl_substs(&self,\n-                   did: DefId,\n-                   obligation: PredicateObligation<'tcx>)\n-                   -> subst::Substs<'tcx> {\n-        let tcx = self.tcx;\n-\n-        let ity = tcx.lookup_item_type(did);\n-        let (tps, rps, _) =\n-            (ity.generics.types.get_slice(TypeSpace),\n-             ity.generics.regions.get_slice(TypeSpace),\n-             ity.ty);\n-\n-        let rps = self.region_vars_for_defs(obligation.cause.span, rps);\n-        let mut substs = subst::Substs::new_type(vec![], rps);\n-        self.type_vars_for_defs(obligation.cause.span,\n-                                TypeSpace,\n-                                &mut substs,\n-                                tps);\n-        substs\n-    }\n-\n     fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         /// returns the fuzzy category of a given type, or None\n         /// if the type can be equated to any type.\n@@ -242,10 +221,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.lookup_trait_def(trait_ref.def_id)\n             .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n+                let ity = tcx.lookup_item_type(def_id);\n+                let impl_substs = self.fresh_substs_for_generics(obligation.cause.span,\n+                                                                 &ity.generics);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()\n-                    .subst(tcx, &self.impl_substs(def_id, obligation.clone()));\n+                    .subst(tcx, impl_substs);\n \n                 let impl_self_ty = impl_trait_ref.self_ty();\n "}, {"sha": "80a3ad9122bd1205fa42d56d4f26d1183bedd340", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -358,8 +358,7 @@ pub fn fresh_type_vars_for_impl<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n                                                 impl_def_id: DefId)\n                                                 -> &'tcx Substs<'tcx>\n {\n-    let tcx = infcx.tcx;\n-    let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n+    let impl_generics = infcx.tcx.lookup_item_type(impl_def_id).generics;\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n "}, {"sha": "34e7899e2fddb8749412f51b5ee926f6a86dec58", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -73,6 +73,33 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         }\n     }\n \n+    /// Creates a Substs for generic parameter definitions,\n+    /// by calling closures to obtain each region and type.\n+    /// The closures get to observe the Substs as they're\n+    /// being built, which can be used to correctly\n+    /// substitute defaults of type parameters.\n+    pub fn from_generics<FR, FT>(generics: &ty::Generics<'tcx>,\n+                                 mut mk_region: FR,\n+                                 mut mk_type: FT)\n+                                 -> Substs<'tcx>\n+    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n+        let mut substs = Substs::empty();\n+        for &space in &ParamSpace::all() {\n+            for def in generics.regions.get_slice(space) {\n+                let region = mk_region(def, &substs);\n+                assert_eq!(substs.regions.len(def.space), def.index as usize);\n+                substs.regions.push(def.space, region);\n+            }\n+            for def in generics.types.get_slice(space) {\n+                let ty = mk_type(def, &substs);\n+                assert_eq!(substs.types.len(def.space), def.index as usize);\n+                substs.types.push(def.space, ty);\n+            }\n+        }\n+        substs\n+    }\n+\n     pub fn is_noop(&self) -> bool {\n         self.regions.is_empty() && self.types.is_empty()\n     }\n@@ -81,6 +108,10 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         *self.types.get(ty_param_def.space, ty_param_def.index as usize)\n     }\n \n+    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region {\n+        *self.regions.get(def.space, def.index as usize)\n+    }\n+\n     pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         self.types.get_self().cloned()\n     }"}, {"sha": "ea7b447632c077afd06bd21bed257acedd235756", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -55,7 +55,7 @@ use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n-use rustc::ty::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n+use rustc::ty::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -115,11 +115,15 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>>;\n \n     /// What type should we use when a type is omitted?\n-    fn ty_infer(&self,\n-                param_and_substs: Option<ty::TypeParameterDef<'tcx>>,\n-                substs: Option<&mut Substs<'tcx>>,\n-                space: Option<ParamSpace>,\n-                span: Span) -> Ty<'tcx>;\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n+\n+    /// Same as ty_infer, but with a known type parameter definition.\n+    fn ty_infer_for_def(&self,\n+                        _def: &ty::TypeParameterDef<'tcx>,\n+                        _substs: &Substs<'tcx>,\n+                        span: Span) -> Ty<'tcx> {\n+        self.ty_infer(span)\n+    }\n \n     /// Projecting an associated type from a (potentially)\n     /// higher-ranked trait reference is more complicated, because of\n@@ -535,26 +539,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                 self_ty: Option<Ty<'tcx>>)\n                                 -> Vec<Ty<'tcx>>\n     {\n-        fn default_type_parameter<'tcx>(p: &ty::TypeParameterDef<'tcx>, self_ty: Option<Ty<'tcx>>)\n-                                        -> Option<ty::TypeParameterDef<'tcx>>\n-        {\n+        let use_default = |p: &ty::TypeParameterDef<'tcx>| {\n             if let Some(ref default) = p.default {\n                 if self_ty.is_none() && default.has_self_ty() {\n                     // There is no suitable inference default for a type parameter\n                     // that references self with no self-type provided.\n-                    return None;\n+                    return false;\n                 }\n             }\n \n-            Some(p.clone())\n-        }\n+            true\n+        };\n \n         if param_mode == PathParamMode::Optional && types_provided.is_empty() {\n-            ty_param_defs\n-                .iter()\n-                .map(|p| self.ty_infer(default_type_parameter(p, self_ty), Some(&mut substs),\n-                                       Some(TypeSpace), span))\n-                .collect()\n+            ty_param_defs.iter().map(|def| {\n+                let ty_var = if use_default(def) {\n+                    self.ty_infer_for_def(def, &substs, span)\n+                } else {\n+                    self.ty_infer(span)\n+                };\n+                substs.types.push(def.space, ty_var);\n+                ty_var\n+            }).collect()\n         } else {\n             types_provided\n         }\n@@ -1828,7 +1834,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // values in a ExprClosure, or as\n                 // the type of local variables. Both of these cases are\n                 // handled specially and will not descend into this routine.\n-                self.ty_infer(None, None, None, ast_ty.span)\n+                self.ty_infer(ast_ty.span)\n             }\n         };\n \n@@ -1845,7 +1851,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     {\n         match a.ty.node {\n             hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n-            hir::TyInfer => self.ty_infer(None, None, None, a.ty.span),\n+            hir::TyInfer => self.ty_infer(a.ty.span),\n             _ => self.ast_ty_to_ty(rscope, &a.ty),\n         }\n     }\n@@ -2067,8 +2073,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let output_ty = match decl.output {\n             _ if is_infer && expected_ret_ty.is_some() =>\n                 expected_ret_ty.unwrap(),\n-            _ if is_infer =>\n-                self.ty_infer(None, None, None, decl.output.span()),\n+            _ if is_infer => self.ty_infer(decl.output.span()),\n             hir::Return(ref output) =>\n                 self.ast_ty_to_ty(&rb, &output),\n             hir::DefaultReturn(..) => bug!(),"}, {"sha": "d1d7259955576fd9fe9db2cd9033bdb828f20f76", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     fn fresh_receiver_substs(&mut self,\n                              self_ty: Ty<'tcx>,\n                              pick: &probe::Pick<'tcx>)\n-                             -> subst::Substs<'tcx>\n+                             -> &'tcx subst::Substs<'tcx>\n     {\n         match pick.kind {\n             probe::InherentImplPick => {\n@@ -231,7 +231,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                            original_poly_trait_ref,\n                            upcast_trait_ref,\n                            trait_def_id);\n-                    upcast_trait_ref.substs.clone()\n+                    upcast_trait_ref.substs\n                 })\n             }\n \n@@ -249,9 +249,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 let impl_trait_ref =\n                     self.instantiate_type_scheme(\n                         self.span,\n-                        &impl_polytype.substs,\n+                        impl_polytype.substs,\n                         &self.tcx.impl_trait_ref(impl_def_id).unwrap());\n-                impl_trait_ref.substs.clone()\n+                impl_trait_ref.substs\n             }\n \n             probe::TraitPick => {\n@@ -271,7 +271,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             probe::WhereClausePick(ref poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                self.replace_late_bound_regions_with_fresh_var(&poly_trait_ref).substs.clone()\n+                self.replace_late_bound_regions_with_fresh_var(&poly_trait_ref).substs\n             }\n         }\n     }\n@@ -303,59 +303,51 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n     fn instantiate_method_substs(&mut self,\n                                  pick: &probe::Pick<'tcx>,\n-                                 supplied_method_types: Vec<Ty<'tcx>>,\n-                                 substs: subst::Substs<'tcx>)\n+                                 mut supplied_method_types: Vec<Ty<'tcx>>,\n+                                 substs: &subst::Substs<'tcx>)\n                                  -> subst::Substs<'tcx>\n     {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n         let method = pick.item.as_opt_method().unwrap();\n-        let method_types = method.generics.types.get_slice(subst::FnSpace);\n-        let num_method_types = method_types.len();\n-\n+        let num_method_types = method.generics.types.len(subst::FnSpace);\n+\n+        if num_supplied_types > 0 && num_supplied_types != num_method_types {\n+            if num_method_types == 0 {\n+                span_err!(self.tcx.sess, self.span, E0035,\n+                    \"does not take type parameters\");\n+            } else {\n+                span_err!(self.tcx.sess, self.span, E0036,\n+                    \"incorrect number of type parameters given for this method: \\\n+                     expected {}, found {}\",\n+                    num_method_types, num_supplied_types);\n+            }\n+            supplied_method_types = vec![self.tcx.types.err; num_method_types];\n+        }\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n-        let method_regions =\n-            self.region_vars_for_defs(\n-                self.span,\n-                pick.item.as_opt_method().unwrap()\n-                    .generics.regions.get_slice(subst::FnSpace));\n-\n-        let subst::Substs { types, regions } = substs;\n-        let regions = regions.with_slice(subst::FnSpace, &method_regions);\n-        let mut final_substs = subst::Substs { types: types, regions: regions };\n-\n-        if num_supplied_types == 0 {\n-            self.type_vars_for_defs(\n-                self.span,\n-                subst::FnSpace,\n-                &mut final_substs,\n-                method_types);\n-        } else if num_method_types == 0 {\n-            span_err!(self.tcx.sess, self.span, E0035,\n-                \"does not take type parameters\");\n-            self.type_vars_for_defs(\n-                self.span,\n-                subst::FnSpace,\n-                &mut final_substs,\n-                method_types);\n-        } else if num_supplied_types != num_method_types {\n-            span_err!(self.tcx.sess, self.span, E0036,\n-                \"incorrect number of type parameters given for this method: expected {}, found {}\",\n-                num_method_types, num_supplied_types);\n-            final_substs.types.replace(\n-                subst::FnSpace,\n-                vec![self.tcx.types.err; num_method_types]);\n-        } else {\n-            final_substs.types.replace(subst::FnSpace, supplied_method_types);\n-        }\n-\n-        return final_substs;\n+        let type_defs = method.generics.types.as_full_slice();\n+        let region_defs = method.generics.regions.as_full_slice();\n+        subst::Substs::from_param_defs(region_defs, type_defs, |def| {\n+            if def.space != subst::FnSpace {\n+                substs.region_for_def(def)\n+            } else {\n+                self.region_var_for_def(self.span, def)\n+            }\n+        }, |def, cur_substs| {\n+            if def.space != subst::FnSpace {\n+                substs.type_for_def(def)\n+            } else if supplied_method_types.is_empty() {\n+                self.type_var_for_def(self.span, def, cur_substs)\n+            } else {\n+                supplied_method_types[def.index as usize]\n+            }\n+        })\n     }\n \n     fn unify_receivers(&mut self,"}, {"sha": "532a5c0de4e460267d3ccf360a72c8a72681881d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -182,29 +182,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n-        let type_parameter_defs = trait_def.generics.types.get_slice(subst::TypeSpace);\n-        let expected_number_of_input_types = type_parameter_defs.len();\n-\n+        if let Some(ref input_types) = opt_input_types {\n+            assert_eq!(trait_def.generics.types.len(subst::TypeSpace), input_types.len());\n+        }\n         assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n         assert!(trait_def.generics.regions.is_empty());\n \n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n-        let mut substs = subst::Substs::new_trait(Vec::new(), Vec::new(), self_ty);\n-\n-        match opt_input_types {\n-            Some(input_types) => {\n-                assert_eq!(expected_number_of_input_types, input_types.len());\n-                substs.types.replace(subst::ParamSpace::TypeSpace, input_types);\n+        let type_defs = trait_def.generics.types.as_full_slice();\n+        let region_defs = trait_def.generics.regions.as_full_slice();\n+        let substs = subst::Substs::from_param_defs(region_defs, type_defs, |def| {\n+            self.region_var_for_def(span, def)\n+        }, |def, substs| {\n+            if def.space == subst::SelfSpace {\n+                self_ty\n+            } else if let Some(ref input_types) = opt_input_types {\n+                input_types[def.index as usize]\n+            } else {\n+                self.type_var_for_def(span, def, substs)\n             }\n-\n-            None => {\n-                self.type_vars_for_defs(\n-                    span,\n-                    subst::ParamSpace::TypeSpace,\n-                    &mut substs,\n-                    type_parameter_defs);\n-            }\n-        }\n+        });\n \n         let trait_ref = ty::TraitRef::new(trait_def_id, self.tcx.mk_substs(substs));\n "}, {"sha": "44e371482c55c8b4f94725e165cb305b28ed04e3", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -1227,28 +1227,29 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return impl_ty;\n         }\n \n-        let mut placeholder;\n+        let placeholder;\n         let mut substs = substs;\n         if\n             !method.generics.types.is_empty_in(subst::FnSpace) ||\n             !method.generics.regions.is_empty_in(subst::FnSpace)\n         {\n-            // In general, during probe we erase regions. See\n-            // `impl_self_ty()` for an explanation.\n-            let method_regions =\n-                method.generics.regions.get_slice(subst::FnSpace)\n-                .iter()\n-                .map(|_| ty::ReErased)\n-                .collect();\n-\n-            placeholder = (*substs).clone().with_method(Vec::new(), method_regions);\n-\n-            self.type_vars_for_defs(\n-                self.span,\n-                subst::FnSpace,\n-                &mut placeholder,\n-                method.generics.types.get_slice(subst::FnSpace));\n-\n+            let type_defs = method.generics.types.as_full_slice();\n+            let region_defs = method.generics.regions.as_full_slice();\n+            placeholder = subst::Substs::from_param_defs(region_defs, type_defs, |def| {\n+                if def.space != subst::FnSpace {\n+                    substs.region_for_def(def)\n+                } else {\n+                    // In general, during probe we erase regions. See\n+                    // `impl_self_ty()` for an explanation.\n+                    ty::ReErased\n+                }\n+            }, |def, cur_substs| {\n+                if def.space != subst::FnSpace {\n+                    substs.type_for_def(def)\n+                } else {\n+                    self.type_var_for_def(self.span, def, cur_substs)\n+                }\n+            });\n             substs = &placeholder;\n         }\n "}, {"sha": "b5018d51b7f56de5b78b638615127dd48c884a2f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -1358,27 +1358,15 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         trait_def.associated_type_names.contains(&assoc_name)\n     }\n \n-    fn ty_infer(&self,\n-                ty_param_def: Option<ty::TypeParameterDef<'tcx>>,\n-                substs: Option<&mut subst::Substs<'tcx>>,\n-                space: Option<subst::ParamSpace>,\n-                span: Span) -> Ty<'tcx> {\n-        // Grab the default doing subsitution\n-        let default = ty_param_def.and_then(|def| {\n-            def.default.map(|ty| type_variable::Default {\n-                ty: ty.subst_spanned(self.tcx(), substs.as_ref().unwrap(), Some(span)),\n-                origin_span: span,\n-                def_id: def.default_def_id\n-            })\n-        });\n-\n-        let ty_var = self.next_ty_var_with_default(default);\n+    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n+        self.next_ty_var()\n+    }\n \n-        // Finally we add the type variable to the substs\n-        match substs {\n-            None => ty_var,\n-            Some(substs) => { substs.types.push(space.unwrap(), ty_var); ty_var }\n-        }\n+    fn ty_infer_for_def(&self,\n+                        ty_param_def: &ty::TypeParameterDef<'tcx>,\n+                        substs: &subst::Substs<'tcx>,\n+                        span: Span) -> Ty<'tcx> {\n+        self.type_var_for_def(span, ty_param_def, substs)\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -2785,20 +2773,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span, // (potential) receiver for this impl\n                         did: DefId)\n                         -> TypeAndSubsts<'tcx> {\n-        let tcx = self.tcx;\n-\n-        let ity = tcx.lookup_item_type(did);\n-        let (tps, rps, raw_ty) =\n-            (ity.generics.types.get_slice(subst::TypeSpace),\n-             ity.generics.regions.get_slice(subst::TypeSpace),\n-             ity.ty);\n+        let ity = self.tcx.lookup_item_type(did);\n+        debug!(\"impl_self_ty: ity={:?}\", ity);\n \n-        debug!(\"impl_self_ty: tps={:?} rps={:?} raw_ty={:?}\", tps, rps, raw_ty);\n-\n-        let rps = self.region_vars_for_defs(span, rps);\n-        let mut substs = subst::Substs::new_type(vec![], rps);\n-        self.type_vars_for_defs(span, ParamSpace::TypeSpace, &mut substs, tps);\n-        let substd_ty = self.instantiate_type_scheme(span, &substs, &raw_ty);\n+        let substs = self.fresh_substs_for_generics(span, &ity.generics);\n+        let substd_ty = self.instantiate_type_scheme(span, &substs, &ity.ty);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n     }\n@@ -4532,7 +4511,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // everything.\n         if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n             substs.types.replace(space, Vec::new());\n-            self.type_vars_for_defs(span, space, substs, &desired[..]);\n+            for def in desired {\n+                let ty_var = self.type_var_for_def(span, def, substs);\n+                substs.types.push(def.space, ty_var);\n+            }\n             return;\n         }\n "}, {"sha": "0ddc051d4a868415592fbba07a59618f590bacf9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -362,11 +362,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         None\n     }\n \n-    fn ty_infer(&self,\n-                _ty_param_def: Option<ty::TypeParameterDef<'tcx>>,\n-                _substs: Option<&mut Substs<'tcx>>,\n-                _space: Option<ParamSpace>,\n-                span: Span) -> Ty<'tcx> {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         struct_span_err!(\n             self.tcx().sess,\n             span,"}, {"sha": "4ce6f8210c3c5a38a16a0ae849bf8e218ec1a9b9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -132,7 +132,7 @@ pub mod coherence;\n pub mod variance;\n \n pub struct TypeAndSubsts<'tcx> {\n-    pub substs: Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n     pub ty: Ty<'tcx>,\n }\n "}, {"sha": "50c568cfef8f6c8dc0c4566aefccac569beffdd0", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=5ef6af09e3b9df3dd01f0e4d53176b0a72ce5722", "patch": "@@ -464,7 +464,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n                                        p.space, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = *substs.types.get(p.space, p.index as usize);\n+            let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl, variance_i);\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.declared_variance(p.def_id, def_id,\n                                        RegionParam, p.space, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = *substs.regions.get(p.space, p.index as usize);\n+            let substs_r = substs.region_for_def(p);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n         }\n     }"}]}