{"sha": "9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMmU3NTNiMmZkMWY2MTRjNjRiYTQ1MWZmODE2ZjUwYTNhYzJlZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-11T03:50:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-11T03:50:28Z"}, "message": "Auto merge of #86965 - sexxi-goose:rfc2229-improve-lint, r=nikomatsakis,lqd\n\nImproves migrations lint for RFC2229\n\nThis PR improves the current disjoint capture migration lint by providing more information on why drop order or auto trait implementation for a closure is impacted by the use of the new feature.\n\nThe drop order migration lint will now look something like this:\n```\nerror: changes to closure capture in Rust 2021 will affect drop order\n  --> $DIR/significant_drop.rs:163:21\n   |\nLL |             let c = || {\n   |                     ^^\n...\nLL |                 tuple.0;\n   |                 ------- in Rust 2018, closure captures all of `tuple`, but in Rust 2021, it only captures `tuple.0`\n...\nLL |         }\n   |         - in Rust 2018, `tuple` would be dropped here, but in Rust 2021, only `tuple.0` would be dropped here alongside the closure\n```\n\nThe auto trait migration lint will now look something like this:\n```\nerror: changes to closure capture in Rust 2021 will affect `Send` trait implementation for closure\n  --> $DIR/auto_traits.rs:14:19\n   |\nLL |     thread::spawn(move || unsafe {\n   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure would implement `Send` as `fptr` implements `Send`, but in Rust 2021, this closure would no longer implement `Send` as `fptr.0` does not implement `Send`\n...\nLL |         *fptr.0 = 20;\n   |         ------- in Rust 2018, closure captures all of `fptr`, but in Rust 2021, it only captures `fptr.0`\n```\n\nr? `@nikomatsakis`\n\nCloses https://github.com/rust-lang/project-rfc-2229/issues/54", "tree": {"sha": "fdc8ab47b9a2482b94bd24d5f715afba918f1189", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdc8ab47b9a2482b94bd24d5f715afba918f1189"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "html_url": "https://github.com/rust-lang/rust/commit/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99f8efec46c72cb11418f858ae142baa5f3582a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/99f8efec46c72cb11418f858ae142baa5f3582a9", "html_url": "https://github.com/rust-lang/rust/commit/99f8efec46c72cb11418f858ae142baa5f3582a9"}, {"sha": "08c616741c6eff64443cc50d2ec8db9663ff61d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/08c616741c6eff64443cc50d2ec8db9663ff61d8", "html_url": "https://github.com/rust-lang/rust/commit/08c616741c6eff64443cc50d2ec8db9663ff61d8"}], "stats": {"total": 1718, "additions": 1274, "deletions": 444}, "files": [{"sha": "c42ca936e9758beca9f2fedf5f2b00ad75993681", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 243, "deletions": 154, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -50,6 +50,7 @@ use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n+use rustc_data_structures::stable_map::FxHashMap;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_index::vec::Idx;\n use rustc_target::abi::VariantIdx;\n@@ -81,6 +82,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n+/// Intermediate format to store the hir_id pointing to the use that resulted in the\n+/// corresponding place being captured and a String which contains the captured value's\n+/// name (i.e: a.b.c)\n+type CapturesInfo = (Option<hir::HirId>, String);\n+\n+/// Intermediate format to store information needed to generate migration lint. The tuple\n+/// contains the hir_id pointing to the use that resulted in the\n+/// corresponding place being captured, a String which contains the captured value's\n+/// name (i.e: a.b.c) and a String which contains the reason why migration is needed for that\n+/// capture\n+type MigrationNeededForCapture = (Option<hir::HirId>, String, String);\n+\n+/// Intermediate format to store the hir id of the root variable and a HashSet containing\n+/// information on why the root variable should be fully captured\n+type MigrationDiagnosticInfo = (hir::HirId, Vec<MigrationNeededForCapture>);\n+\n struct InferBorrowKindVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n }\n@@ -498,18 +515,58 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let local_def_id = closure_def_id.expect_local();\n             let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+            let closure_span = self.tcx.hir().span(closure_hir_id);\n+            let closure_head_span = self.tcx.sess.source_map().guess_head_span(closure_span);\n             self.tcx.struct_span_lint_hir(\n                 lint::builtin::RUST_2021_INCOMPATIBLE_CLOSURE_CAPTURES,\n                 closure_hir_id,\n-                span,\n+                closure_head_span,\n                 |lint| {\n                     let mut diagnostics_builder = lint.build(\n                         format!(\n-                            \"{} will change in Rust 2021\",\n+                            \"changes to closure capture in Rust 2021 will affect {}\",\n                             reasons\n                         )\n                         .as_str(),\n                     );\n+                    for (var_hir_id, diagnostics_info) in need_migrations.iter() {\n+                        // Labels all the usage of the captured variable and why they are responsible\n+                        // for migration being needed\n+                        for (captured_hir_id, captured_name, reasons) in diagnostics_info.iter() {\n+                            if let Some(captured_hir_id) = captured_hir_id {\n+                                let cause_span = self.tcx.hir().span(*captured_hir_id);\n+                                diagnostics_builder.span_label(cause_span, format!(\"in Rust 2018, closure captures all of `{}`, but in Rust 2021, it only captures `{}`\",\n+                                    self.tcx.hir().name(*var_hir_id),\n+                                    captured_name,\n+                                ));\n+                            }\n+\n+                            // Add a label pointing to where a captured variable affected by drop order\n+                            // is dropped\n+                            if reasons.contains(\"drop order\") {\n+                                let drop_location_span = drop_location_span(self.tcx, &closure_hir_id);\n+\n+                                diagnostics_builder.span_label(drop_location_span, format!(\"in Rust 2018, `{}` would be dropped here, but in Rust 2021, only `{}` would be dropped here alongside the closure\",\n+                                    self.tcx.hir().name(*var_hir_id),\n+                                    captured_name,\n+                                ));\n+                            }\n+\n+                            // Add a label explaining why a closure no longer implements a trait\n+                            if reasons.contains(\"trait implementation\") {\n+                                let missing_trait = &reasons[..reasons.find(\"trait implementation\").unwrap() - 1];\n+\n+                                diagnostics_builder.span_label(closure_head_span, format!(\"in Rust 2018, this closure would implement {} as `{}` implements {}, but in Rust 2021, this closure would no longer implement {} as `{}` does not implement {}\",\n+                                    missing_trait,\n+                                    self.tcx.hir().name(*var_hir_id),\n+                                    missing_trait,\n+                                    missing_trait,\n+                                    captured_name,\n+                                    missing_trait,\n+                                ));\n+                            }\n+                        }\n+                    }\n                     diagnostics_builder.note(\"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\");\n                     let closure_body_span = self.tcx.hir().span(body_id.hir_id);\n                     let (sugg, app) =\n@@ -556,13 +613,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if auto_trait_reasons.len() > 0 {\n             reasons = format!(\n-                \"{} trait implementation\",\n+                \"{} trait implementation for closure\",\n                 auto_trait_reasons.clone().into_iter().collect::<Vec<&str>>().join(\", \")\n             );\n         }\n \n         if auto_trait_reasons.len() > 0 && drop_reason {\n-            reasons = format!(\"{}, and \", reasons);\n+            reasons = format!(\"{} and \", reasons);\n         }\n \n         if drop_reason {\n@@ -572,20 +629,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         reasons\n     }\n \n-    /// Returns true if migration is needed for trait for the provided var_hir_id\n-    fn need_2229_migrations_for_trait(\n+    /// Figures out the list of root variables (and their types) that aren't completely\n+    /// captured by the closure when `capture_disjoint_fields` is enabled and auto-traits\n+    /// differ between the root variable and the captured paths.\n+    ///\n+    /// Returns a tuple containing a HashMap of CapturesInfo that maps to a HashSet of trait names\n+    /// if migration is needed for traits for the provided var_hir_id, otherwise returns None\n+    fn compute_2229_migrations_for_trait(\n         &self,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         var_hir_id: hir::HirId,\n-        check_trait: Option<DefId>,\n         closure_clause: hir::CaptureBy,\n-    ) -> bool {\n+    ) -> Option<FxHashMap<CapturesInfo, FxHashSet<&str>>> {\n+        let auto_traits_def_id = vec![\n+            self.tcx.lang_items().clone_trait(),\n+            self.tcx.lang_items().sync_trait(),\n+            self.tcx.get_diagnostic_item(sym::send_trait),\n+            self.tcx.lang_items().unpin_trait(),\n+            self.tcx.get_diagnostic_item(sym::unwind_safe_trait),\n+            self.tcx.get_diagnostic_item(sym::ref_unwind_safe_trait),\n+        ];\n+        let auto_traits =\n+            vec![\"`Clone`\", \"`Sync`\", \"`Send`\", \"`Unpin`\", \"`UnwindSafe`\", \"`RefUnwindSafe`\"];\n+\n         let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n             min_captures.and_then(|m| m.get(&var_hir_id))\n         {\n             root_var_min_capture_list\n         } else {\n-            return false;\n+            return None;\n         };\n \n         let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n@@ -604,19 +676,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let obligation_should_hold = check_trait\n-            .map(|check_trait| {\n-                self.infcx\n-                    .type_implements_trait(\n-                        check_trait,\n-                        ty,\n-                        self.tcx.mk_substs_trait(ty, &[]),\n-                        self.param_env,\n-                    )\n-                    .must_apply_modulo_regions()\n-            })\n-            .unwrap_or(false);\n+        let mut obligations_should_hold = Vec::new();\n+        // Checks if a root variable implements any of the auto traits\n+        for check_trait in auto_traits_def_id.iter() {\n+            obligations_should_hold.push(\n+                check_trait\n+                    .map(|check_trait| {\n+                        self.infcx\n+                            .type_implements_trait(\n+                                check_trait,\n+                                ty,\n+                                self.tcx.mk_substs_trait(ty, &[]),\n+                                self.param_env,\n+                            )\n+                            .must_apply_modulo_regions()\n+                    })\n+                    .unwrap_or(false),\n+            );\n+        }\n \n+        let mut problematic_captures = FxHashMap::default();\n         // Check whether captured fields also implement the trait\n         for capture in root_var_min_capture_list.iter() {\n             let ty = apply_capture_kind_on_capture_ty(\n@@ -625,106 +704,46 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 capture.info.capture_kind,\n             );\n \n-            let obligation_holds_for_capture = check_trait\n-                .map(|check_trait| {\n-                    self.infcx\n-                        .type_implements_trait(\n-                            check_trait,\n-                            ty,\n-                            self.tcx.mk_substs_trait(ty, &[]),\n-                            self.param_env,\n-                        )\n-                        .must_apply_modulo_regions()\n-                })\n-                .unwrap_or(false);\n-\n-            if !obligation_holds_for_capture && obligation_should_hold {\n-                return true;\n+            // Checks if a capture implements any of the auto traits\n+            let mut obligations_holds_for_capture = Vec::new();\n+            for check_trait in auto_traits_def_id.iter() {\n+                obligations_holds_for_capture.push(\n+                    check_trait\n+                        .map(|check_trait| {\n+                            self.infcx\n+                                .type_implements_trait(\n+                                    check_trait,\n+                                    ty,\n+                                    self.tcx.mk_substs_trait(ty, &[]),\n+                                    self.param_env,\n+                                )\n+                                .must_apply_modulo_regions()\n+                        })\n+                        .unwrap_or(false),\n+                );\n             }\n-        }\n-        false\n-    }\n-\n-    /// Figures out the list of root variables (and their types) that aren't completely\n-    /// captured by the closure when `capture_disjoint_fields` is enabled and auto-traits\n-    /// differ between the root variable and the captured paths.\n-    ///\n-    /// The output list would include a root variable if:\n-    /// - It would have been captured into the closure when `capture_disjoint_fields` wasn't\n-    ///   enabled, **and**\n-    /// - It wasn't completely captured by the closure, **and**\n-    /// - One of the paths captured does not implement all the auto-traits its root variable\n-    ///   implements.\n-    fn compute_2229_migrations_for_trait(\n-        &self,\n-        min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-        var_hir_id: hir::HirId,\n-        closure_clause: hir::CaptureBy,\n-    ) -> Option<FxHashSet<&str>> {\n-        let tcx = self.infcx.tcx;\n-\n-        // Check whether catpured fields also implement the trait\n-        let mut auto_trait_reasons = FxHashSet::default();\n-\n-        if self.need_2229_migrations_for_trait(\n-            min_captures,\n-            var_hir_id,\n-            tcx.lang_items().clone_trait(),\n-            closure_clause,\n-        ) {\n-            auto_trait_reasons.insert(\"`Clone`\");\n-        }\n-\n-        if self.need_2229_migrations_for_trait(\n-            min_captures,\n-            var_hir_id,\n-            tcx.lang_items().sync_trait(),\n-            closure_clause,\n-        ) {\n-            auto_trait_reasons.insert(\"`Sync`\");\n-        }\n \n-        if self.need_2229_migrations_for_trait(\n-            min_captures,\n-            var_hir_id,\n-            tcx.get_diagnostic_item(sym::send_trait),\n-            closure_clause,\n-        ) {\n-            auto_trait_reasons.insert(\"`Send`\");\n-        }\n+            let mut capture_problems = FxHashSet::default();\n \n-        if self.need_2229_migrations_for_trait(\n-            min_captures,\n-            var_hir_id,\n-            tcx.lang_items().unpin_trait(),\n-            closure_clause,\n-        ) {\n-            auto_trait_reasons.insert(\"`Unpin`\");\n-        }\n-\n-        if self.need_2229_migrations_for_trait(\n-            min_captures,\n-            var_hir_id,\n-            tcx.get_diagnostic_item(sym::unwind_safe_trait),\n-            closure_clause,\n-        ) {\n-            auto_trait_reasons.insert(\"`UnwindSafe`\");\n-        }\n+            // Checks if for any of the auto traits, one or more trait is implemented\n+            // by the root variable but not by the capture\n+            for (idx, _) in obligations_should_hold.iter().enumerate() {\n+                if !obligations_holds_for_capture[idx] && obligations_should_hold[idx] {\n+                    capture_problems.insert(auto_traits[idx]);\n+                }\n+            }\n \n-        if self.need_2229_migrations_for_trait(\n-            min_captures,\n-            var_hir_id,\n-            tcx.get_diagnostic_item(sym::ref_unwind_safe_trait),\n-            closure_clause,\n-        ) {\n-            auto_trait_reasons.insert(\"`RefUnwindSafe`\");\n+            if capture_problems.len() > 0 {\n+                problematic_captures.insert(\n+                    (capture.info.path_expr_id, capture.to_string(self.tcx)),\n+                    capture_problems,\n+                );\n+            }\n         }\n-\n-        if auto_trait_reasons.len() > 0 {\n-            return Some(auto_trait_reasons);\n+        if problematic_captures.len() > 0 {\n+            return Some(problematic_captures);\n         }\n-\n-        return None;\n+        None\n     }\n \n     /// Figures out the list of root variables (and their types) that aren't completely\n@@ -737,20 +756,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - It wasn't completely captured by the closure, **and**\n     /// - One of the paths starting at this root variable, that is not captured needs Drop.\n     ///\n-    /// This function only returns true for significant drops. A type is considerent to have a\n-    /// significant drop if it's Drop implementation is not annotated by `rustc_insignificant_dtor`.\n+    /// This function only returns a HashSet of CapturesInfo for significant drops. If there\n+    /// are no significant drops than None is returned\n     fn compute_2229_migrations_for_drop(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         closure_clause: hir::CaptureBy,\n         var_hir_id: hir::HirId,\n-    ) -> bool {\n+    ) -> Option<FxHashSet<CapturesInfo>> {\n         let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n         if !ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n-            return false;\n+            return None;\n         }\n \n         let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n@@ -763,21 +782,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             match closure_clause {\n                 // Only migrate if closure is a move closure\n-                hir::CaptureBy::Value => return true,\n+                hir::CaptureBy::Value => return Some(FxHashSet::default()),\n                 hir::CaptureBy::Ref => {}\n             }\n \n-            return false;\n+            return None;\n         };\n \n-        let projections_list = root_var_min_capture_list\n-            .iter()\n-            .filter_map(|captured_place| match captured_place.info.capture_kind {\n+        let mut projections_list = Vec::new();\n+        let mut diagnostics_info = FxHashSet::default();\n+\n+        for captured_place in root_var_min_capture_list.iter() {\n+            match captured_place.info.capture_kind {\n                 // Only care about captures that are moved into the closure\n-                ty::UpvarCapture::ByValue(..) => Some(captured_place.place.projections.as_slice()),\n-                ty::UpvarCapture::ByRef(..) => None,\n-            })\n-            .collect::<Vec<_>>();\n+                ty::UpvarCapture::ByValue(..) => {\n+                    projections_list.push(captured_place.place.projections.as_slice());\n+                    diagnostics_info.insert((\n+                        captured_place.info.path_expr_id,\n+                        captured_place.to_string(self.tcx),\n+                    ));\n+                }\n+                ty::UpvarCapture::ByRef(..) => {}\n+            }\n+        }\n \n         let is_moved = !projections_list.is_empty();\n \n@@ -793,10 +820,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 projections_list,\n             )\n         {\n-            return true;\n+            return Some(diagnostics_info);\n         }\n \n-        return false;\n+        return None;\n     }\n \n     /// Figures out the list of root variables (and their types) that aren't completely\n@@ -812,54 +839,96 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// - One of the paths captured does not implement all the auto-traits its root variable\n     ///   implements.\n     ///\n-    /// Returns a tuple containing a vector of HirIds as well as a String containing the reason\n-    /// why root variables whose HirId is contained in the vector should be fully captured.\n+    /// Returns a tuple containing a vector of MigrationDiagnosticInfo, as well as a String\n+    /// containing the reason why root variables whose HirId is contained in the vector should\n+    /// be captured\n     fn compute_2229_migrations(\n         &self,\n         closure_def_id: DefId,\n         closure_span: Span,\n         closure_clause: hir::CaptureBy,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n-    ) -> (Vec<hir::HirId>, String) {\n+    ) -> (Vec<MigrationDiagnosticInfo>, String) {\n         let upvars = if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n             upvars\n         } else {\n             return (Vec::new(), format!(\"\"));\n         };\n \n         let mut need_migrations = Vec::new();\n-        let mut auto_trait_reasons = FxHashSet::default();\n-        let mut drop_reorder_reason = false;\n+        let mut auto_trait_migration_reasons = FxHashSet::default();\n+        let mut drop_migration_needed = false;\n \n         // Perform auto-trait analysis\n         for (&var_hir_id, _) in upvars.iter() {\n-            let mut need_migration = false;\n-            if let Some(trait_migration_cause) =\n+            let mut responsible_captured_hir_ids = Vec::new();\n+\n+            let auto_trait_diagnostic = if let Some(diagnostics_info) =\n                 self.compute_2229_migrations_for_trait(min_captures, var_hir_id, closure_clause)\n             {\n-                need_migration = true;\n-                auto_trait_reasons.extend(trait_migration_cause);\n+                diagnostics_info\n+            } else {\n+                FxHashMap::default()\n+            };\n+\n+            let drop_reorder_diagnostic = if let Some(diagnostics_info) = self\n+                .compute_2229_migrations_for_drop(\n+                    closure_def_id,\n+                    closure_span,\n+                    min_captures,\n+                    closure_clause,\n+                    var_hir_id,\n+                ) {\n+                drop_migration_needed = true;\n+                diagnostics_info\n+            } else {\n+                FxHashSet::default()\n+            };\n+\n+            // Combine all the captures responsible for needing migrations into one HashSet\n+            let mut capture_diagnostic = drop_reorder_diagnostic.clone();\n+            for key in auto_trait_diagnostic.keys() {\n+                capture_diagnostic.insert(key.clone());\n             }\n \n-            if self.compute_2229_migrations_for_drop(\n-                closure_def_id,\n-                closure_span,\n-                min_captures,\n-                closure_clause,\n-                var_hir_id,\n-            ) {\n-                need_migration = true;\n-                drop_reorder_reason = true;\n+            let mut capture_diagnostic = capture_diagnostic.into_iter().collect::<Vec<_>>();\n+            capture_diagnostic.sort();\n+            for captured_info in capture_diagnostic.iter() {\n+                // Get the auto trait reasons of why migration is needed because of that capture, if there are any\n+                let capture_trait_reasons =\n+                    if let Some(reasons) = auto_trait_diagnostic.get(captured_info) {\n+                        reasons.clone()\n+                    } else {\n+                        FxHashSet::default()\n+                    };\n+\n+                // Check if migration is needed because of drop reorder as a result of that capture\n+                let capture_drop_reorder_reason = drop_reorder_diagnostic.contains(captured_info);\n+\n+                // Combine all the reasons of why the root variable should be captured as a result of\n+                // auto trait implementation issues\n+                auto_trait_migration_reasons.extend(capture_trait_reasons.clone());\n+\n+                responsible_captured_hir_ids.push((\n+                    captured_info.0,\n+                    captured_info.1.clone(),\n+                    self.compute_2229_migrations_reasons(\n+                        capture_trait_reasons,\n+                        capture_drop_reorder_reason,\n+                    ),\n+                ));\n             }\n \n-            if need_migration {\n-                need_migrations.push(var_hir_id);\n+            if capture_diagnostic.len() > 0 {\n+                need_migrations.push((var_hir_id, responsible_captured_hir_ids));\n             }\n         }\n-\n         (\n             need_migrations,\n-            self.compute_2229_migrations_reasons(auto_trait_reasons, drop_reorder_reason),\n+            self.compute_2229_migrations_reasons(\n+                auto_trait_migration_reasons,\n+                drop_migration_needed,\n+            ),\n         )\n     }\n \n@@ -1320,6 +1389,26 @@ fn apply_capture_kind_on_capture_ty(\n     }\n }\n \n+/// Returns the Span of where the value with the provided HirId would be dropped\n+fn drop_location_span(tcx: TyCtxt<'tcx>, hir_id: &hir::HirId) -> Span {\n+    let owner_id = tcx.hir().get_enclosing_scope(*hir_id).unwrap();\n+\n+    let owner_node = tcx.hir().get(owner_id);\n+    let owner_span = match owner_node {\n+        hir::Node::Item(item) => match item.kind {\n+            hir::ItemKind::Fn(_, _, owner_id) => tcx.hir().span(owner_id.hir_id),\n+            _ => {\n+                bug!(\"Drop location span error: need to handle more ItemKind {:?}\", item.kind);\n+            }\n+        },\n+        hir::Node::Block(block) => tcx.hir().span(block.hir_id),\n+        _ => {\n+            bug!(\"Drop location span error: need to handle more Node {:?}\", owner_node);\n+        }\n+    };\n+    tcx.sess.source_map().end_point(owner_span)\n+}\n+\n struct InferBorrowKind<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n@@ -1877,10 +1966,10 @@ fn should_do_rust_2021_incompatible_closure_captures_analysis(\n /// - s2: Comma separated names of the variables being migrated.\n fn migration_suggestion_for_2229(\n     tcx: TyCtxt<'_>,\n-    need_migrations: &Vec<hir::HirId>,\n+    need_migrations: &Vec<MigrationDiagnosticInfo>,\n ) -> (String, String) {\n     let need_migrations_variables =\n-        need_migrations.iter().map(|v| var_name(tcx, *v)).collect::<Vec<_>>();\n+        need_migrations.iter().map(|(v, _)| var_name(tcx, *v)).collect::<Vec<_>>();\n \n     let migration_ref_concat =\n         need_migrations_variables.iter().map(|v| format!(\"&{}\", v)).collect::<Vec<_>>().join(\", \");"}, {"sha": "e2b7b8f0275204194965c83012005aba659739bd", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.fixed", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE: the lint level is defined here\n \n use std::thread;\n \n@@ -11,9 +12,12 @@ fn test_send_trait() {\n     let mut f = 10;\n     let fptr = SendPointer(&mut f as *mut i32);\n     thread::spawn(move || { let _ = &fptr; unsafe {\n-        //~^ ERROR: `Send` trait implementation\n+        //~^ ERROR: `Send` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Send` as `fptr` implements `Send`, but in Rust 2021, this closure would no longer implement `Send` as `fptr.0` does not implement `Send`\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n+        //~^ NOTE: in Rust 2018, closure captures all of `fptr`, but in Rust 2021, it only captures `fptr.0`\n     } });\n }\n \n@@ -28,9 +32,12 @@ fn test_sync_trait() {\n     let f = CustomInt(&mut f as *mut i32);\n     let fptr = SyncPointer(f);\n     thread::spawn(move || { let _ = &fptr; unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation\n+        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure would no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n+        //~^ NOTE: in Rust 2018, closure captures all of `fptr`, but in Rust 2021, it only captures `fptr.0.0`\n     } });\n }\n \n@@ -49,16 +56,20 @@ impl Clone for U {\n fn test_clone_trait() {\n     let f = U(S(String::from(\"Hello World\")), T(0));\n     let c = || { let _ = &f; \n-        //~^ ERROR: `Clone` trait implementation, and drop order\n+        //~^ ERROR: `Clone` trait implementation for closure and drop order\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f.1` does not implement `Clone`\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         let f_1 = f.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f`, but in Rust 2021, it only captures `f.1`\n         println!(\"{:?}\", f_1.0);\n     };\n \n     let c_clone = c.clone();\n \n     c_clone();\n }\n+//~^ NOTE: in Rust 2018, `f` would be dropped here, but in Rust 2021, only `f.1` would be dropped here alongside the closure\n \n fn main() {\n     test_send_trait();"}, {"sha": "6c56ca27475a3d177492a48885e29ea70989b66d", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n #![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE: the lint level is defined here\n \n use std::thread;\n \n@@ -11,9 +12,12 @@ fn test_send_trait() {\n     let mut f = 10;\n     let fptr = SendPointer(&mut f as *mut i32);\n     thread::spawn(move || unsafe {\n-        //~^ ERROR: `Send` trait implementation\n+        //~^ ERROR: `Send` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Send` as `fptr` implements `Send`, but in Rust 2021, this closure would no longer implement `Send` as `fptr.0` does not implement `Send`\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0 = 20;\n+        //~^ NOTE: in Rust 2018, closure captures all of `fptr`, but in Rust 2021, it only captures `fptr.0`\n     });\n }\n \n@@ -28,9 +32,12 @@ fn test_sync_trait() {\n     let f = CustomInt(&mut f as *mut i32);\n     let fptr = SyncPointer(f);\n     thread::spawn(move || unsafe {\n-        //~^ ERROR: `Sync`, `Send` trait implementation\n+        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure would no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `fptr` to be fully captured\n         *fptr.0.0 = 20;\n+        //~^ NOTE: in Rust 2018, closure captures all of `fptr`, but in Rust 2021, it only captures `fptr.0.0`\n     });\n }\n \n@@ -49,16 +56,20 @@ impl Clone for U {\n fn test_clone_trait() {\n     let f = U(S(String::from(\"Hello World\")), T(0));\n     let c = || {\n-        //~^ ERROR: `Clone` trait implementation, and drop order\n+        //~^ ERROR: `Clone` trait implementation for closure and drop order\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f.1` does not implement `Clone`\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         let f_1 = f.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f`, but in Rust 2021, it only captures `f.1`\n         println!(\"{:?}\", f_1.0);\n     };\n \n     let c_clone = c.clone();\n \n     c_clone();\n }\n+//~^ NOTE: in Rust 2018, `f` would be dropped here, but in Rust 2021, only `f.1` would be dropped here alongside the closure\n \n fn main() {\n     test_send_trait();"}, {"sha": "9c954b1465d837e5a3d8293382a76323d92eae2b", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,13 +1,11 @@\n-error: `Send` trait implementation will change in Rust 2021\n-  --> $DIR/auto_traits.rs:13:19\n+error: changes to closure capture in Rust 2021 will affect `Send` trait implementation for closure\n+  --> $DIR/auto_traits.rs:14:19\n    |\n-LL |       thread::spawn(move || unsafe {\n-   |  ___________________^\n-LL | |\n-LL | |\n-LL | |         *fptr.0 = 20;\n-LL | |     });\n-   | |_____^\n+LL |     thread::spawn(move || unsafe {\n+   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure would implement `Send` as `fptr` implements `Send`, but in Rust 2021, this closure would no longer implement `Send` as `fptr.0` does not implement `Send`\n+...\n+LL |         *fptr.0 = 20;\n+   |         ------- in Rust 2018, closure captures all of `fptr`, but in Rust 2021, it only captures `fptr.0`\n    |\n note: the lint level is defined here\n   --> $DIR/auto_traits.rs:2:9\n@@ -20,53 +18,53 @@ help: add a dummy let to cause `fptr` to be fully captured\n LL |     thread::spawn(move || { let _ = &fptr; unsafe {\n LL |\n LL |\n+LL |\n+LL |\n LL |         *fptr.0 = 20;\n-LL |     } });\n-   |\n+ ...\n \n-error: `Sync`, `Send` trait implementation will change in Rust 2021\n-  --> $DIR/auto_traits.rs:30:19\n+error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n+  --> $DIR/auto_traits.rs:34:19\n    |\n-LL |       thread::spawn(move || unsafe {\n-   |  ___________________^\n-LL | |\n-LL | |\n-LL | |         *fptr.0.0 = 20;\n-LL | |     });\n-   | |_____^\n+LL |     thread::spawn(move || unsafe {\n+   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure would implement `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure would no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n+...\n+LL |         *fptr.0.0 = 20;\n+   |         --------- in Rust 2018, closure captures all of `fptr`, but in Rust 2021, it only captures `fptr.0.0`\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `fptr` to be fully captured\n    |\n LL |     thread::spawn(move || { let _ = &fptr; unsafe {\n LL |\n LL |\n+LL |\n+LL |\n LL |         *fptr.0.0 = 20;\n-LL |     } });\n-   |\n+ ...\n \n-error: `Clone` trait implementation, and drop order will change in Rust 2021\n-  --> $DIR/auto_traits.rs:51:13\n+error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n+  --> $DIR/auto_traits.rs:58:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |         let f_1 = f.1;\n-LL | |         println!(\"{:?}\", f_1.0);\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^ in Rust 2018, this closure would implement `Clone` as `f` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f.1` does not implement `Clone`\n+...\n+LL |         let f_1 = f.1;\n+   |                   --- in Rust 2018, closure captures all of `f`, but in Rust 2021, it only captures `f.1`\n+...\n+LL | }\n+   | - in Rust 2018, `f` would be dropped here, but in Rust 2021, only `f.1` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `f` to be fully captured\n    |\n LL |     let c = || { let _ = &f; \n LL |\n LL |\n+LL |\n+LL |\n LL |         let f_1 = f.1;\n-LL |         println!(\"{:?}\", f_1.0);\n-LL |     };\n-   |\n+ ...\n \n error: aborting due to 3 previous errors\n "}, {"sha": "e836f27cd7af1ff1ae363ceceeb32bf8f33807b8", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.fixed", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -18,12 +18,18 @@ fn test1_all_need_migration() {\n         //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n \n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n         let _t2 = t2.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t2`, but in Rust 2021, it only captures `t2.0`\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+//~| in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n+//~| in Rust 2018, `t2` would be dropped here, but in Rust 2021, only `t2.0` would be dropped here alongside the closure\n \n // String implements drop and therefore should be migrated.\n // But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n@@ -37,12 +43,16 @@ fn test2_only_precise_paths_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n         let _t2 = t2;\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+//~| in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n \n // If a variable would've not been captured by value then it would've not been\n // dropped with the closure and therefore doesn't need migration.\n@@ -54,11 +64,13 @@ fn test3_only_by_value_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         println!(\"{}\", t1.1);\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Copy types get copied into the closure instead of move. Therefore we don't need to\n // migrate then as their drop order isn't tied to the closure.\n@@ -73,11 +85,13 @@ fn test4_only_non_copy_types_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n fn test5_only_drop_types_need_migration() {\n     struct S(i32, i32);\n@@ -92,11 +106,13 @@ fn test5_only_drop_types_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _s = s.0;\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Since we are using a move closure here, both `t` and `t1` get moved\n // even though they are being used by ref inside the closure.\n@@ -108,10 +124,14 @@ fn test6_move_closures_non_copy_types_might_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n         println!(\"{} {}\", t1.1, t.1);\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n+        //~| NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.1`\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n+//~| in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.1` would be dropped here alongside the closure\n \n // Test migration analysis in case of Drop + Non Drop aggregates.\n // Note we need migration here only because the non-copy (because Drop type) is captured,\n@@ -124,10 +144,12 @@ fn test7_drop_non_drop_aggregate_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n fn main() {\n     test1_all_need_migration();"}, {"sha": "fbf9b983f07a265092cae5b2d56ed935b75db791", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -18,12 +18,18 @@ fn test1_all_need_migration() {\n         //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n \n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n         let _t2 = t2.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t2`, but in Rust 2021, it only captures `t2.0`\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+//~| in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n+//~| in Rust 2018, `t2` would be dropped here, but in Rust 2021, only `t2.0` would be dropped here alongside the closure\n \n // String implements drop and therefore should be migrated.\n // But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n@@ -37,12 +43,16 @@ fn test2_only_precise_paths_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n         let _t2 = t2;\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+//~| in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n \n // If a variable would've not been captured by value then it would've not been\n // dropped with the closure and therefore doesn't need migration.\n@@ -54,11 +64,13 @@ fn test3_only_by_value_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         println!(\"{}\", t1.1);\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Copy types get copied into the closure instead of move. Therefore we don't need to\n // migrate then as their drop order isn't tied to the closure.\n@@ -73,11 +85,13 @@ fn test4_only_non_copy_types_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n fn test5_only_drop_types_need_migration() {\n     struct S(i32, i32);\n@@ -92,11 +106,13 @@ fn test5_only_drop_types_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _s = s.0;\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Since we are using a move closure here, both `t` and `t1` get moved\n // even though they are being used by ref inside the closure.\n@@ -108,10 +124,14 @@ fn test6_move_closures_non_copy_types_might_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n         println!(\"{} {}\", t1.1, t.1);\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n+        //~| NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.1`\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n+//~| in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.1` would be dropped here alongside the closure\n \n // Test migration analysis in case of Drop + Non Drop aggregates.\n // Note we need migration here only because the non-copy (because Drop type) is captured,\n@@ -124,10 +144,12 @@ fn test7_drop_non_drop_aggregate_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n fn main() {\n     test1_all_need_migration();"}, {"sha": "e9e4794cff5f797c76a2af945130ebf14ebc871a", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "modified", "additions": 103, "deletions": 87, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,15 +1,24 @@\n-error: drop order will change in Rust 2021\n+error: changes to closure capture in Rust 2021 will affect drop order\n   --> $DIR/insignificant_drop.rs:15:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |         let _t2 = t2.0;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+LL |\n+LL |         let _t1 = t1.0;\n+   |                   ---- in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n+LL |\n+LL |         let _t2 = t2.0;\n+   |                   ---- in Rust 2018, closure captures all of `t2`, but in Rust 2021, it only captures `t2.0`\n+...\n+LL | }\n+   | -\n+   | |\n+   | in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+   | in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n+   | in Rust 2018, `t2` would be dropped here, but in Rust 2021, only `t2.0` would be dropped here alongside the closure\n    |\n note: the lint level is defined here\n   --> $DIR/insignificant_drop.rs:3:9\n@@ -27,18 +36,23 @@ LL |\n LL |         let _t = t.0;\n  ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/insignificant_drop.rs:35:13\n-   |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |         let _t2 = t2;\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/insignificant_drop.rs:41:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+LL |\n+LL |         let _t1 = t1.0;\n+   |                   ---- in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n+...\n+LL | }\n+   | -\n+   | |\n+   | in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+   | in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t`, `t1` to be fully captured\n@@ -48,21 +62,20 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |         let _t1 = t1.0;\n+LL |\n  ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/insignificant_drop.rs:52:13\n-   |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |         println!(\"{}\", t1.1);\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/insignificant_drop.rs:62:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -72,21 +85,20 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |         println!(\"{}\", t1.1);\n+LL |\n  ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/insignificant_drop.rs:71:13\n-   |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |         let _t1 = t1.0;\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/insignificant_drop.rs:83:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -96,21 +108,20 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |         let _t1 = t1.0;\n+LL |\n  ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/insignificant_drop.rs:90:13\n-   |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |         let _s = s.0;\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/insignificant_drop.rs:104:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -120,20 +131,25 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |         let _s = s.0;\n+LL |\n  ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/insignificant_drop.rs:106:13\n-   |\n-LL |       let c = move || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         println!(\"{} {}\", t1.1, t.1);\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/insignificant_drop.rs:122:13\n+   |\n+LL |     let c = move || {\n+   |             ^^^^^^^\n+...\n+LL |         println!(\"{} {}\", t1.1, t.1);\n+   |                           ----  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n+   |                           |\n+   |                           in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.1`\n+...\n+LL | }\n+   | -\n+   | |\n+   | in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.1` would be dropped here alongside the closure\n+   | in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t1`, `t` to be fully captured\n@@ -143,20 +159,20 @@ LL |\n LL |\n LL |\n LL |         println!(\"{} {}\", t1.1, t.1);\n-LL |     };\n-   |\n+LL |\n+ ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/insignificant_drop.rs:122:13\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/insignificant_drop.rs:142:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -166,8 +182,8 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |     };\n-   |\n+LL |\n+ ...\n \n error: aborting due to 7 previous errors\n "}, {"sha": "4626c04e9ba6ea3a51b342b471f74aa6d5cd7cac", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.fixed", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -39,10 +39,12 @@ fn significant_drop_needs_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Even if a type implements an insignificant drop, if it's\n // elements have a significant drop then the overall type is\n@@ -57,10 +59,12 @@ fn generic_struct_with_significant_drop_needs_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n \n fn main() {\n     significant_drop_needs_migration();"}, {"sha": "ebcf1551bacf62d9547e53fbd5750c76fb47ab9f", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -39,10 +39,12 @@ fn significant_drop_needs_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Even if a type implements an insignificant drop, if it's\n // elements have a significant drop then the overall type is\n@@ -57,10 +59,12 @@ fn generic_struct_with_significant_drop_needs_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n \n fn main() {\n     significant_drop_needs_migration();"}, {"sha": "1e97ca34d162e3f3c58f4ac27514a3f9701ab15c", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,14 +1,14 @@\n-error: drop order will change in Rust 2021\n+error: changes to closure capture in Rust 2021 will affect drop order\n   --> $DIR/insignificant_drop_attr_migrations.rs:37:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n note: the lint level is defined here\n   --> $DIR/insignificant_drop_attr_migrations.rs:3:9\n@@ -23,20 +23,20 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |     };\n-   |\n+LL |\n+ ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/insignificant_drop_attr_migrations.rs:55:13\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/insignificant_drop_attr_migrations.rs:57:13\n    |\n-LL |       let c = move || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.1;\n-LL | |     };\n-   | |_____^\n+LL |     let c = move || {\n+   |             ^^^^^^^\n+...\n+LL |         let _t = t.1;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -46,8 +46,8 @@ LL |\n LL |\n LL |\n LL |         let _t = t.1;\n-LL |     };\n-   |\n+LL |\n+ ...\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f3c15a2e6b676e08dc3966c66b644365f4912241", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.fixed", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.fixed?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -21,20 +21,24 @@ fn closure_contains_block() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n fn closure_doesnt_contain_block() {\n     let t = (Foo(0), Foo(0));\n     let c = || { let _ = &t; t.0 };\n     //~^ ERROR: drop order\n+    //~| NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     //~| NOTE: for more information, see\n     //~| HELP: add a dummy let to cause `t` to be fully captured\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n fn main() {\n     closure_contains_block();"}, {"sha": "50936d15302b7914e36f1abd1dd8a134c68912da", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -21,20 +21,24 @@ fn closure_contains_block() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n fn closure_doesnt_contain_block() {\n     let t = (Foo(0), Foo(0));\n     let c = || t.0;\n     //~^ ERROR: drop order\n+    //~| NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     //~| NOTE: for more information, see\n     //~| HELP: add a dummy let to cause `t` to be fully captured\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n fn main() {\n     closure_contains_block();"}, {"sha": "f8f72d1580ca9df798300436768020562789e41e", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/migrations_rustfix.stderr", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmigrations_rustfix.stderr?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,14 +1,14 @@\n-error: drop order will change in Rust 2021\n+error: changes to closure capture in Rust 2021 will affect drop order\n   --> $DIR/migrations_rustfix.rs:19:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n note: the lint level is defined here\n   --> $DIR/migrations_rustfix.rs:2:9\n@@ -23,14 +23,19 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |     };\n-   |\n+LL |\n+ ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/migrations_rustfix.rs:31:13\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/migrations_rustfix.rs:33:13\n    |\n LL |     let c = || t.0;\n-   |             ^^^^^^\n+   |             ^^^---\n+   |                |\n+   |                in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured"}, {"sha": "f24804018cd85ca10427cb560f13c865089cfd43", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.fixed", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.fixed?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE: the lint level is defined here\n // ignore-wasm32-bare compiled with panic=abort by default\n #![feature(fn_traits)]\n #![feature(never_type)]\n@@ -17,9 +18,12 @@ where\n {\n     let f = panic::AssertUnwindSafe(f);\n     let result = panic::catch_unwind(move || { let _ = &f; \n-        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation\n+        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure would no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         f.0()\n+        //~^ NOTE: in Rust 2018, closure captures all of `f`, but in Rust 2021, it only captures `f.0`\n     });\n     if let Ok(..) = result {\n         panic!(\"diverging function returned\");"}, {"sha": "6a6a51c51322d8a3c163eb0a49e8ab378153be06", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE: the lint level is defined here\n // ignore-wasm32-bare compiled with panic=abort by default\n #![feature(fn_traits)]\n #![feature(never_type)]\n@@ -17,9 +18,12 @@ where\n {\n     let f = panic::AssertUnwindSafe(f);\n     let result = panic::catch_unwind(move || {\n-        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation\n+        //~^ ERROR: `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure would no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `f` to be fully captured\n         f.0()\n+        //~^ NOTE: in Rust 2018, closure captures all of `f`, but in Rust 2021, it only captures `f.0`\n     });\n     if let Ok(..) = result {\n         panic!(\"diverging function returned\");"}, {"sha": "6ee0d0d252aba783b11a1747133ca92481651fbe", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/mir_calls_to_shims.stderr", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmir_calls_to_shims.stderr?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,13 +1,11 @@\n-error: `UnwindSafe`, `RefUnwindSafe` trait implementation will change in Rust 2021\n-  --> $DIR/mir_calls_to_shims.rs:19:38\n+error: changes to closure capture in Rust 2021 will affect `UnwindSafe`, `RefUnwindSafe` trait implementation for closure\n+  --> $DIR/mir_calls_to_shims.rs:20:38\n    |\n-LL |       let result = panic::catch_unwind(move || {\n-   |  ______________________________________^\n-LL | |\n-LL | |\n-LL | |         f.0()\n-LL | |     });\n-   | |_____^\n+LL |     let result = panic::catch_unwind(move || {\n+   |                                      ^^^^^^^ in Rust 2018, this closure would implement `UnwindSafe`, `RefUnwindSafe` as `f` implements `UnwindSafe`, `RefUnwindSafe`, but in Rust 2021, this closure would no longer implement `UnwindSafe`, `RefUnwindSafe` as `f.0` does not implement `UnwindSafe`, `RefUnwindSafe`\n+...\n+LL |         f.0()\n+   |         --- in Rust 2018, closure captures all of `f`, but in Rust 2021, it only captures `f.0`\n    |\n note: the lint level is defined here\n   --> $DIR/mir_calls_to_shims.rs:3:9\n@@ -20,9 +18,10 @@ help: add a dummy let to cause `f` to be fully captured\n LL |     let result = panic::catch_unwind(move || { let _ = &f; \n LL |\n LL |\n+LL |\n+LL |\n LL |         f.0()\n-LL |     });\n-   |\n+ ...\n \n error: aborting due to previous error\n "}, {"sha": "98f578abc44dcc1cac03f97d0b8c0fd7da012528", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.fixed", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -0,0 +1,138 @@\n+// run-rustfix\n+#![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE: the lint level is defined here\n+\n+use std::thread;\n+\n+struct S(String);\n+\n+#[derive(Clone)]\n+struct T(i32);\n+\n+struct U(S, T);\n+\n+impl Clone for U {\n+    fn clone(&self) -> Self {\n+        U(S(String::from(\"Hello World\")), T(0))\n+    }\n+}\n+\n+fn test_multi_issues() {\n+    let f1 = U(S(String::from(\"foo\")), T(0));\n+    let f2 = U(S(String::from(\"bar\")), T(0));\n+    let c = || { let _ = (&f1, &f2); \n+        //~^ ERROR: `Clone` trait implementation for closure and drop order\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `f1`, `f2` to be fully captured\n+        let _f_1 = f1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+        let _f_2 = f2.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f2`, but in Rust 2021, it only captures `f2.1`\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+//~^ NOTE: in Rust 2018, `f2` would be dropped here, but in Rust 2021, only `f2.1` would be dropped here alongside the closure\n+\n+fn test_capturing_all_disjoint_fields_individually() {\n+    let f1 = U(S(String::from(\"foo\")), T(0));\n+    let c = || { let _ = &f1; \n+        //~^ ERROR: `Clone` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `f1` to be fully captured\n+        let _f_1 = f1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+        let _f_2 = f1.1;\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+\n+struct U1(S, T, S);\n+\n+impl Clone for U1 {\n+    fn clone(&self) -> Self {\n+        U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")))\n+    }\n+}\n+\n+fn test_capturing_several_disjoint_fields_individually_1() {\n+    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let c = || { let _ = &f1; \n+        //~^ ERROR: `Clone` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.2` does not implement `Clone`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `f1` to be fully captured\n+        let _f_0 = f1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+        let _f_2 = f1.2;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.2`\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+\n+fn test_capturing_several_disjoint_fields_individually_2() {\n+    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let c = || { let _ = &f1; \n+        //~^ ERROR: `Clone` trait implementation for closure and drop order\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `f1` to be fully captured\n+        let _f_0 = f1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+        let _f_1 = f1.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.1`\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+//~^ NOTE: in Rust 2018, `f1` would be dropped here, but in Rust 2021, only `f1.1` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `f1` would be dropped here, but in Rust 2021, only `f1.0` would be dropped here alongside the closure\n+\n+struct SendPointer(*mut i32);\n+unsafe impl Send for SendPointer {}\n+\n+struct CustomInt(*mut i32);\n+struct SyncPointer(CustomInt);\n+unsafe impl Sync for SyncPointer {}\n+unsafe impl Send for CustomInt {}\n+\n+fn test_multi_traits_issues() {\n+    let mut f1 = 10;\n+    let f1 = CustomInt(&mut f1 as *mut i32);\n+    let fptr1 = SyncPointer(f1);\n+\n+    let mut f2 = 10;\n+    let fptr2 = SendPointer(&mut f2 as *mut i32);\n+    thread::spawn(move || { let _ = (&fptr1, &fptr2); unsafe {\n+        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure would no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n+        //~| NOTE: in Rust 2018, this closure would implement `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure would no longer implement `Send` as `fptr2.0` does not implement `Send`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `fptr1`, `fptr2` to be fully captured\n+        *fptr1.0.0 = 20;\n+        //~^ NOTE: in Rust 2018, closure captures all of `fptr1`, but in Rust 2021, it only captures `fptr1.0.0`\n+        *fptr2.0 = 20;\n+        //~^ NOTE: in Rust 2018, closure captures all of `fptr2`, but in Rust 2021, it only captures `fptr2.0`\n+    } });\n+}\n+\n+fn main() {\n+    test_multi_issues();\n+    test_capturing_all_disjoint_fields_individually();\n+    test_capturing_several_disjoint_fields_individually_1();\n+    test_capturing_several_disjoint_fields_individually_2();\n+    test_multi_traits_issues();\n+}"}, {"sha": "1577b91c960185a04f71084cbd96ae9c72301190", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -0,0 +1,138 @@\n+// run-rustfix\n+#![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE: the lint level is defined here\n+\n+use std::thread;\n+\n+struct S(String);\n+\n+#[derive(Clone)]\n+struct T(i32);\n+\n+struct U(S, T);\n+\n+impl Clone for U {\n+    fn clone(&self) -> Self {\n+        U(S(String::from(\"Hello World\")), T(0))\n+    }\n+}\n+\n+fn test_multi_issues() {\n+    let f1 = U(S(String::from(\"foo\")), T(0));\n+    let f2 = U(S(String::from(\"bar\")), T(0));\n+    let c = || {\n+        //~^ ERROR: `Clone` trait implementation for closure and drop order\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `f1`, `f2` to be fully captured\n+        let _f_1 = f1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+        let _f_2 = f2.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f2`, but in Rust 2021, it only captures `f2.1`\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+//~^ NOTE: in Rust 2018, `f2` would be dropped here, but in Rust 2021, only `f2.1` would be dropped here alongside the closure\n+\n+fn test_capturing_all_disjoint_fields_individually() {\n+    let f1 = U(S(String::from(\"foo\")), T(0));\n+    let c = || {\n+        //~^ ERROR: `Clone` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `f1` to be fully captured\n+        let _f_1 = f1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+        let _f_2 = f1.1;\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+\n+struct U1(S, T, S);\n+\n+impl Clone for U1 {\n+    fn clone(&self) -> Self {\n+        U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")))\n+    }\n+}\n+\n+fn test_capturing_several_disjoint_fields_individually_1() {\n+    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let c = || {\n+        //~^ ERROR: `Clone` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.2` does not implement `Clone`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `f1` to be fully captured\n+        let _f_0 = f1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+        let _f_2 = f1.2;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.2`\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+\n+fn test_capturing_several_disjoint_fields_individually_2() {\n+    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let c = || {\n+        //~^ ERROR: `Clone` trait implementation for closure and drop order\n+        //~| NOTE: in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `f1` to be fully captured\n+        let _f_0 = f1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+        let _f_1 = f1.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.1`\n+    };\n+\n+    let c_clone = c.clone();\n+\n+    c_clone();\n+}\n+//~^ NOTE: in Rust 2018, `f1` would be dropped here, but in Rust 2021, only `f1.1` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `f1` would be dropped here, but in Rust 2021, only `f1.0` would be dropped here alongside the closure\n+\n+struct SendPointer(*mut i32);\n+unsafe impl Send for SendPointer {}\n+\n+struct CustomInt(*mut i32);\n+struct SyncPointer(CustomInt);\n+unsafe impl Sync for SyncPointer {}\n+unsafe impl Send for CustomInt {}\n+\n+fn test_multi_traits_issues() {\n+    let mut f1 = 10;\n+    let f1 = CustomInt(&mut f1 as *mut i32);\n+    let fptr1 = SyncPointer(f1);\n+\n+    let mut f2 = 10;\n+    let fptr2 = SendPointer(&mut f2 as *mut i32);\n+    thread::spawn(move || unsafe {\n+        //~^ ERROR: `Sync`, `Send` trait implementation for closure\n+        //~| NOTE: in Rust 2018, this closure would implement `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure would no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n+        //~| NOTE: in Rust 2018, this closure would implement `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure would no longer implement `Send` as `fptr2.0` does not implement `Send`\n+        //~| NOTE: for more information, see\n+        //~| HELP: add a dummy let to cause `fptr1`, `fptr2` to be fully captured\n+        *fptr1.0.0 = 20;\n+        //~^ NOTE: in Rust 2018, closure captures all of `fptr1`, but in Rust 2021, it only captures `fptr1.0.0`\n+        *fptr2.0 = 20;\n+        //~^ NOTE: in Rust 2018, closure captures all of `fptr2`, but in Rust 2021, it only captures `fptr2.0`\n+    });\n+}\n+\n+fn main() {\n+    test_multi_issues();\n+    test_capturing_all_disjoint_fields_individually();\n+    test_capturing_several_disjoint_fields_individually_1();\n+    test_capturing_several_disjoint_fields_individually_2();\n+    test_multi_traits_issues();\n+}"}, {"sha": "8a42683c1df9f9df0c93f4f6a89c0a200117560c", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.stderr", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -0,0 +1,134 @@\n+error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n+  --> $DIR/multi_diagnostics.rs:23:13\n+   |\n+LL |     let c = || {\n+   |             ^^ in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+...\n+LL |         let _f_1 = f1.0;\n+   |                    ---- in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+LL |\n+LL |         let _f_2 = f2.1;\n+   |                    ---- in Rust 2018, closure captures all of `f2`, but in Rust 2021, it only captures `f2.1`\n+...\n+LL | }\n+   | - in Rust 2018, `f2` would be dropped here, but in Rust 2021, only `f2.1` would be dropped here alongside the closure\n+   |\n+note: the lint level is defined here\n+  --> $DIR/multi_diagnostics.rs:2:9\n+   |\n+LL | #![deny(rust_2021_incompatible_closure_captures)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `f1`, `f2` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&f1, &f2); \n+LL |\n+LL |\n+LL |\n+LL |\n+LL |         let _f_1 = f1.0;\n+ ...\n+\n+error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n+  --> $DIR/multi_diagnostics.rs:42:13\n+   |\n+LL |     let c = || {\n+   |             ^^ in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+...\n+LL |         let _f_1 = f1.0;\n+   |                    ---- in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+   |\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `f1` to be fully captured\n+   |\n+LL |     let c = || { let _ = &f1; \n+LL |\n+LL |\n+LL |\n+LL |\n+LL |         let _f_1 = f1.0;\n+ ...\n+\n+error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n+  --> $DIR/multi_diagnostics.rs:67:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+   |             |\n+   |             in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+   |             in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.2` does not implement `Clone`\n+...\n+LL |         let _f_0 = f1.0;\n+   |                    ---- in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+LL |\n+LL |         let _f_2 = f1.2;\n+   |                    ---- in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.2`\n+   |\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `f1` to be fully captured\n+   |\n+LL |     let c = || { let _ = &f1; \n+LL |\n+LL |\n+LL |\n+LL |\n+LL |\n+ ...\n+\n+error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n+  --> $DIR/multi_diagnostics.rs:86:13\n+   |\n+LL |     let c = || {\n+   |             ^^ in Rust 2018, this closure would implement `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure would no longer implement `Clone` as `f1.0` does not implement `Clone`\n+...\n+LL |         let _f_0 = f1.0;\n+   |                    ---- in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.0`\n+LL |\n+LL |         let _f_1 = f1.1;\n+   |                    ---- in Rust 2018, closure captures all of `f1`, but in Rust 2021, it only captures `f1.1`\n+...\n+LL | }\n+   | -\n+   | |\n+   | in Rust 2018, `f1` would be dropped here, but in Rust 2021, only `f1.0` would be dropped here alongside the closure\n+   | in Rust 2018, `f1` would be dropped here, but in Rust 2021, only `f1.1` would be dropped here alongside the closure\n+   |\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `f1` to be fully captured\n+   |\n+LL |     let c = || { let _ = &f1; \n+LL |\n+LL |\n+LL |\n+LL |\n+LL |         let _f_0 = f1.0;\n+ ...\n+\n+error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n+  --> $DIR/multi_diagnostics.rs:119:19\n+   |\n+LL |     thread::spawn(move || unsafe {\n+   |                   ^^^^^^^^^^^^^^\n+   |                   |\n+   |                   in Rust 2018, this closure would implement `Sync`, `Send` as `fptr1` implements `Sync`, `Send`, but in Rust 2021, this closure would no longer implement `Sync`, `Send` as `fptr1.0.0` does not implement `Sync`, `Send`\n+   |                   in Rust 2018, this closure would implement `Send` as `fptr2` implements `Send`, but in Rust 2021, this closure would no longer implement `Send` as `fptr2.0` does not implement `Send`\n+...\n+LL |         *fptr1.0.0 = 20;\n+   |         ---------- in Rust 2018, closure captures all of `fptr1`, but in Rust 2021, it only captures `fptr1.0.0`\n+LL |\n+LL |         *fptr2.0 = 20;\n+   |         -------- in Rust 2018, closure captures all of `fptr2`, but in Rust 2021, it only captures `fptr2.0`\n+   |\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `fptr1`, `fptr2` to be fully captured\n+   |\n+LL |     thread::spawn(move || { let _ = (&fptr1, &fptr2); unsafe {\n+LL |\n+LL |\n+LL |\n+LL |\n+LL |\n+ ...\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "226172fb93eb12575d2bdea6e081dafa66f68076", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.fixed", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE: the lint level is defined here\n \n #[derive(Debug)]\n struct Foo(i32);\n@@ -18,13 +19,16 @@ fn test_precise_analysis_drop_paths_not_captured_by_move() {\n \n     let c = || { let _ = &t; \n         //~^ ERROR: drop order\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t = &t.1;\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n struct S;\n impl Drop for S {\n@@ -40,14 +44,22 @@ fn test_precise_analysis_long_path_missing() {\n \n     let c = || { let _ = &u; \n         //~^ ERROR: drop order\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `u` to be fully captured\n         let _x = u.0.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.0.0`\n         let _x = u.0.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.0.1`\n         let _x = u.1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.1.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.0.0` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.0.1` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.1.0` would be dropped here alongside the closure\n+\n \n fn main() {\n     test_precise_analysis_drop_paths_not_captured_by_move();"}, {"sha": "7035abe6de0a29ef3d37275431ddf7f318a12d8f", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(rust_2021_incompatible_closure_captures)]\n+//~^ NOTE: the lint level is defined here\n \n #[derive(Debug)]\n struct Foo(i32);\n@@ -18,13 +19,16 @@ fn test_precise_analysis_drop_paths_not_captured_by_move() {\n \n     let c = || {\n         //~^ ERROR: drop order\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t = &t.1;\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n struct S;\n impl Drop for S {\n@@ -40,14 +44,22 @@ fn test_precise_analysis_long_path_missing() {\n \n     let c = || {\n         //~^ ERROR: drop order\n+        //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `u` to be fully captured\n         let _x = u.0.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.0.0`\n         let _x = u.0.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.0.1`\n         let _x = u.1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.1.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.0.0` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.0.1` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.1.0` would be dropped here alongside the closure\n+\n \n fn main() {\n     test_precise_analysis_drop_paths_not_captured_by_move();"}, {"sha": "5bf73ccc55400edbdc5f1c2a98ab8735cd4608f5", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.stderr", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,14 +1,14 @@\n-error: drop order will change in Rust 2021\n-  --> $DIR/precise.rs:19:13\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/precise.rs:20:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |         let _t = &t.1;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n note: the lint level is defined here\n   --> $DIR/precise.rs:3:9\n@@ -21,33 +21,42 @@ help: add a dummy let to cause `t` to be fully captured\n LL |     let c = || { let _ = &t; \n LL |\n LL |\n+LL |\n LL |         let _t = t.0;\n-LL |         let _t = &t.1;\n-LL |     };\n-   |\n+LL |\n+ ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/precise.rs:41:13\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/precise.rs:45:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |         let _x = u.0.0;\n-LL | |         let _x = u.0.1;\n-LL | |         let _x = u.1.0;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _x = u.0.0;\n+   |                  ----- in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.0.0`\n+LL |\n+LL |         let _x = u.0.1;\n+   |                  ----- in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.0.1`\n+LL |\n+LL |         let _x = u.1.0;\n+   |                  ----- in Rust 2018, closure captures all of `u`, but in Rust 2021, it only captures `u.1.0`\n+...\n+LL | }\n+   | -\n+   | |\n+   | in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.0.0` would be dropped here alongside the closure\n+   | in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.0.1` would be dropped here alongside the closure\n+   | in Rust 2018, `u` would be dropped here, but in Rust 2021, only `u.1.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `u` to be fully captured\n    |\n LL |     let c = || { let _ = &u; \n LL |\n LL |\n+LL |\n LL |         let _x = u.0.0;\n-LL |         let _x = u.0.1;\n-LL |         let _x = u.1.0;\n+LL |\n  ...\n \n error: aborting due to 2 previous errors"}, {"sha": "236fdb9e26ea2b3972400e0e992529c7f356b8e2", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.fixed", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -27,12 +27,18 @@ fn test1_all_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n         let _t2 = t2.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t2`, but in Rust 2021, it only captures `t2.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `t2` would be dropped here, but in Rust 2021, only `t2.0` would be dropped here alongside the closure\n \n // String implements drop and therefore should be migrated.\n // But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n@@ -46,12 +52,16 @@ fn test2_only_precise_paths_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n         let _t2 = t2;\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n \n // If a variable would've not been captured by value then it would've not been\n // dropped with the closure and therefore doesn't need migration.\n@@ -63,11 +73,13 @@ fn test3_only_by_value_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         println!(\"{:?}\", t1.1);\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // The root variable might not implement drop themselves but some path starting\n // at the root variable might implement Drop.\n@@ -81,10 +93,12 @@ fn test4_type_contains_drop_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Test migration analysis in case of Drop + Non Drop aggregates.\n // Note we need migration here only because the non-copy (because Drop type) is captured,\n@@ -97,10 +111,12 @@ fn test5_drop_non_drop_aggregate_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Test migration analysis in case of Significant and Insignificant Drop aggregates.\n fn test6_significant_insignificant_drop_aggregate_need_migration() {\n@@ -111,10 +127,12 @@ fn test6_significant_insignificant_drop_aggregate_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n \n // Since we are using a move closure here, both `t` and `t1` get moved\n // even though they are being used by ref inside the closure.\n@@ -127,10 +145,53 @@ fn test7_move_closures_non_copy_types_might_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n         println!(\"{:?} {:?}\", t1.1, t.1);\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.1`\n+        //~| NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.1` would be dropped here alongside the closure\n+\n+\n+fn test8_drop_order_and_blocks() {\n+    {\n+        let tuple =\n+          (String::from(\"foo\"), String::from(\"bar\"));\n+        {\n+            let c = || { let _ = &tuple; \n+                //~^ ERROR: drop order\n+                //~| NOTE: for more information, see\n+                //~| HELP: add a dummy let to cause `tuple` to be fully captured\n+                tuple.0;\n+                //~^ NOTE: in Rust 2018, closure captures all of `tuple`, but in Rust 2021, it only captures `tuple.0`\n+            };\n+\n+            c();\n+        }\n+        //~^ NOTE: in Rust 2018, `tuple` would be dropped here, but in Rust 2021, only `tuple.0` would be dropped here alongside the closure\n+    }\n+}\n+\n+fn test9_drop_order_and_nested_closures() {\n+    let tuple =\n+        (String::from(\"foo\"), String::from(\"bar\"));\n+    let b = || {\n+        let c = || { let _ = &tuple; \n+            //~^ ERROR: drop order\n+            //~| NOTE: for more information, see\n+            //~| HELP: add a dummy let to cause `tuple` to be fully captured\n+            tuple.0;\n+            //~^ NOTE: in Rust 2018, closure captures all of `tuple`, but in Rust 2021, it only captures `tuple.0`\n+        };\n+\n+        c();\n+    };\n+    //~^ NOTE: in Rust 2018, `tuple` would be dropped here, but in Rust 2021, only `tuple.0` would be dropped here alongside the closure\n+\n+    b();\n+}\n \n fn main() {\n     test1_all_need_migration();\n@@ -140,4 +201,6 @@ fn main() {\n     test5_drop_non_drop_aggregate_need_migration();\n     test6_significant_insignificant_drop_aggregate_need_migration();\n     test7_move_closures_non_copy_types_might_need_migration();\n+    test8_drop_order_and_blocks();\n+    test9_drop_order_and_nested_closures();\n }"}, {"sha": "a57f7aa565e120788fd2994648d502bc7fc8125e", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -27,12 +27,18 @@ fn test1_all_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n         let _t2 = t2.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t2`, but in Rust 2021, it only captures `t2.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `t2` would be dropped here, but in Rust 2021, only `t2.0` would be dropped here alongside the closure\n \n // String implements drop and therefore should be migrated.\n // But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n@@ -46,12 +52,16 @@ fn test2_only_precise_paths_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         let _t1 = t1.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n         let _t2 = t2;\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n \n // If a variable would've not been captured by value then it would've not been\n // dropped with the closure and therefore doesn't need migration.\n@@ -63,11 +73,13 @@ fn test3_only_by_value_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n         println!(\"{:?}\", t1.1);\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // The root variable might not implement drop themselves but some path starting\n // at the root variable might implement Drop.\n@@ -81,10 +93,12 @@ fn test4_type_contains_drop_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Test migration analysis in case of Drop + Non Drop aggregates.\n // Note we need migration here only because the non-copy (because Drop type) is captured,\n@@ -97,10 +111,12 @@ fn test5_drop_non_drop_aggregate_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.0;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n \n // Test migration analysis in case of Significant and Insignificant Drop aggregates.\n fn test6_significant_insignificant_drop_aggregate_need_migration() {\n@@ -111,10 +127,12 @@ fn test6_significant_insignificant_drop_aggregate_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n         let _t = t.1;\n+        //~^ NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n \n // Since we are using a move closure here, both `t` and `t1` get moved\n // even though they are being used by ref inside the closure.\n@@ -127,10 +145,53 @@ fn test7_move_closures_non_copy_types_might_need_migration() {\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n         println!(\"{:?} {:?}\", t1.1, t.1);\n+        //~^ NOTE: in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.1`\n+        //~| NOTE: in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n     };\n \n     c();\n }\n+//~^ NOTE: in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n+//~| NOTE: in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.1` would be dropped here alongside the closure\n+\n+\n+fn test8_drop_order_and_blocks() {\n+    {\n+        let tuple =\n+          (String::from(\"foo\"), String::from(\"bar\"));\n+        {\n+            let c = || {\n+                //~^ ERROR: drop order\n+                //~| NOTE: for more information, see\n+                //~| HELP: add a dummy let to cause `tuple` to be fully captured\n+                tuple.0;\n+                //~^ NOTE: in Rust 2018, closure captures all of `tuple`, but in Rust 2021, it only captures `tuple.0`\n+            };\n+\n+            c();\n+        }\n+        //~^ NOTE: in Rust 2018, `tuple` would be dropped here, but in Rust 2021, only `tuple.0` would be dropped here alongside the closure\n+    }\n+}\n+\n+fn test9_drop_order_and_nested_closures() {\n+    let tuple =\n+        (String::from(\"foo\"), String::from(\"bar\"));\n+    let b = || {\n+        let c = || {\n+            //~^ ERROR: drop order\n+            //~| NOTE: for more information, see\n+            //~| HELP: add a dummy let to cause `tuple` to be fully captured\n+            tuple.0;\n+            //~^ NOTE: in Rust 2018, closure captures all of `tuple`, but in Rust 2021, it only captures `tuple.0`\n+        };\n+\n+        c();\n+    };\n+    //~^ NOTE: in Rust 2018, `tuple` would be dropped here, but in Rust 2021, only `tuple.0` would be dropped here alongside the closure\n+\n+    b();\n+}\n \n fn main() {\n     test1_all_need_migration();\n@@ -140,4 +201,6 @@ fn main() {\n     test5_drop_non_drop_aggregate_need_migration();\n     test6_significant_insignificant_drop_aggregate_need_migration();\n     test7_move_closures_non_copy_types_might_need_migration();\n+    test8_drop_order_and_blocks();\n+    test9_drop_order_and_nested_closures();\n }"}, {"sha": "b2b9ae8fd12f51b4274ea3b549821e2443d26b36", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.stderr", "status": "modified", "additions": 150, "deletions": 86, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f2e753b2fd1f614c64ba451ff816f50a3ac2edd/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr?ref=9f2e753b2fd1f614c64ba451ff816f50a3ac2edd", "patch": "@@ -1,15 +1,24 @@\n-error: drop order will change in Rust 2021\n+error: changes to closure capture in Rust 2021 will affect drop order\n   --> $DIR/significant_drop.rs:25:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |         let _t2 = t2.0;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+LL |\n+LL |         let _t1 = t1.0;\n+   |                   ---- in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n+LL |\n+LL |         let _t2 = t2.0;\n+   |                   ---- in Rust 2018, closure captures all of `t2`, but in Rust 2021, it only captures `t2.0`\n+...\n+LL | }\n+   | -\n+   | |\n+   | in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+   | in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n+   | in Rust 2018, `t2` would be dropped here, but in Rust 2021, only `t2.0` would be dropped here alongside the closure\n    |\n note: the lint level is defined here\n   --> $DIR/significant_drop.rs:2:9\n@@ -24,21 +33,26 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |         let _t1 = t1.0;\n+LL |\n  ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/significant_drop.rs:44:13\n-   |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |         let _t2 = t2;\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:50:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+LL |\n+LL |         let _t1 = t1.0;\n+   |                   ---- in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.0`\n+...\n+LL | }\n+   | -\n+   | |\n+   | in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n+   | in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t`, `t1` to be fully captured\n@@ -48,21 +62,20 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |         let _t1 = t1.0;\n+LL |\n  ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/significant_drop.rs:61:13\n-   |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |         println!(\"{:?}\", t1.1);\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:71:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -72,20 +85,20 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |         println!(\"{:?}\", t1.1);\n+LL |\n  ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/significant_drop.rs:79:13\n-   |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:91:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -95,20 +108,20 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |     };\n-   |\n+LL |\n+ ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/significant_drop.rs:95:13\n-   |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |     };\n-   | |_____^\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:109:13\n+   |\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.0;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.0`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.0` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -118,20 +131,20 @@ LL |\n LL |\n LL |\n LL |         let _t = t.0;\n-LL |     };\n-   |\n+LL |\n+ ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/significant_drop.rs:109:13\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:125:13\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         let _t = t.1;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || {\n+   |             ^^\n+...\n+LL |         let _t = t.1;\n+   |                  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n+...\n+LL | }\n+   | - in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t` to be fully captured\n@@ -141,20 +154,25 @@ LL |\n LL |\n LL |\n LL |         let _t = t.1;\n-LL |     };\n-   |\n+LL |\n+ ...\n \n-error: drop order will change in Rust 2021\n-  --> $DIR/significant_drop.rs:125:13\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:143:13\n    |\n-LL |       let c = move || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |         println!(\"{:?} {:?}\", t1.1, t.1);\n-LL | |     };\n-   | |_____^\n+LL |     let c = move || {\n+   |             ^^^^^^^\n+...\n+LL |         println!(\"{:?} {:?}\", t1.1, t.1);\n+   |                               ----  --- in Rust 2018, closure captures all of `t`, but in Rust 2021, it only captures `t.1`\n+   |                               |\n+   |                               in Rust 2018, closure captures all of `t1`, but in Rust 2021, it only captures `t1.1`\n+...\n+LL | }\n+   | -\n+   | |\n+   | in Rust 2018, `t1` would be dropped here, but in Rust 2021, only `t1.1` would be dropped here alongside the closure\n+   | in Rust 2018, `t` would be dropped here, but in Rust 2021, only `t.1` would be dropped here alongside the closure\n    |\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n help: add a dummy let to cause `t1`, `t` to be fully captured\n@@ -164,8 +182,54 @@ LL |\n LL |\n LL |\n LL |         println!(\"{:?} {:?}\", t1.1, t.1);\n+LL |\n+ ...\n+\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:163:21\n+   |\n+LL |             let c = || {\n+   |                     ^^\n+...\n+LL |                 tuple.0;\n+   |                 ------- in Rust 2018, closure captures all of `tuple`, but in Rust 2021, it only captures `tuple.0`\n+...\n+LL |         }\n+   |         - in Rust 2018, `tuple` would be dropped here, but in Rust 2021, only `tuple.0` would be dropped here alongside the closure\n+   |\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `tuple` to be fully captured\n+   |\n+LL |             let c = || { let _ = &tuple; \n+LL |\n+LL |\n+LL |\n+LL |                 tuple.0;\n+LL |\n+ ...\n+\n+error: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/significant_drop.rs:181:17\n+   |\n+LL |         let c = || {\n+   |                 ^^\n+...\n+LL |             tuple.0;\n+   |             ------- in Rust 2018, closure captures all of `tuple`, but in Rust 2021, it only captures `tuple.0`\n+...\n LL |     };\n+   |     - in Rust 2018, `tuple` would be dropped here, but in Rust 2021, only `tuple.0` would be dropped here alongside the closure\n    |\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+help: add a dummy let to cause `tuple` to be fully captured\n+   |\n+LL |         let c = || { let _ = &tuple; \n+LL |\n+LL |\n+LL |\n+LL |             tuple.0;\n+LL |\n+ ...\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 9 previous errors\n "}]}