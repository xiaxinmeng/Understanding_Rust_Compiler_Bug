{"sha": "c4e0cd966062ca67daed20775f4e8a60c28e57df", "node_id": "C_kwDOAAsO6NoAKGM0ZTBjZDk2NjA2MmNhNjdkYWVkMjA3NzVmNGU4YTYwYzI4ZTU3ZGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-26T12:40:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-26T12:40:05Z"}, "message": "Auto merge of #108488 - matthiaskrgr:rollup-i61epcw, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #107941 (Treat `str` as containing `[u8]` for auto trait purposes)\n - #108299 (Require `literal`s for some `(u)int_impl!` parameters)\n - #108337 (hir-analysis: make a helpful note)\n - #108379 (Add `ErrorGuaranteed` to `hir::{Expr,Ty}Kind::Err` variants)\n - #108418 (Replace parse_[sth]_expr with parse_expr_[sth] function names)\n - #108424 (rustc_infer: Consolidate obligation elaboration de-duplication)\n - #108475 (Fix `VecDeque::shrink_to` and add tests.)\n - #108482 (statically guarantee that current error codes are documented)\n - #108484 (Remove `from` lang item)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a76fa48fe30ba83326439fadaae6a62890573e4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a76fa48fe30ba83326439fadaae6a62890573e4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4e0cd966062ca67daed20775f4e8a60c28e57df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4e0cd966062ca67daed20775f4e8a60c28e57df", "html_url": "https://github.com/rust-lang/rust/commit/c4e0cd966062ca67daed20775f4e8a60c28e57df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4e0cd966062ca67daed20775f4e8a60c28e57df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43ee4d15bf201f72c36abd7f02961df87dead441", "url": "https://api.github.com/repos/rust-lang/rust/commits/43ee4d15bf201f72c36abd7f02961df87dead441", "html_url": "https://github.com/rust-lang/rust/commit/43ee4d15bf201f72c36abd7f02961df87dead441"}, {"sha": "9c27fc7d34512a6b3d34247beab4a6ada2476c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c27fc7d34512a6b3d34247beab4a6ada2476c58", "html_url": "https://github.com/rust-lang/rust/commit/9c27fc7d34512a6b3d34247beab4a6ada2476c58"}], "stats": {"total": 919, "additions": 492, "deletions": 427}, "files": [{"sha": "9e5deedb66fff860078878c56e9641789fb45d1d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -1445,6 +1445,7 @@ name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n  \"mdbook\",\n+ \"rustc_error_codes\",\n ]\n \n [[package]]"}, {"sha": "d4fafe38638a42139f6e41b9c674da24d1f1da97", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -88,8 +88,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n-                            self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n-                            hir::ExprKind::Err\n+                            let guar = self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n+                            hir::ExprKind::Err(guar)\n                         }\n                     } else if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n                         self.lower_legacy_const_generics((**f).clone(), args.clone(), &legacy_args)\n@@ -266,8 +266,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), *lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n-                    hir::ExprKind::Err\n+                    let guar = self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n+                    hir::ExprKind::Err(guar)\n                 }\n                 ExprKind::Path(qself, path) => {\n                     let qpath = self.lower_qpath(\n@@ -299,8 +299,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n-                            Some(&*self.arena.alloc(self.expr_err(*sp)))\n+                            let guar =\n+                                self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n+                            Some(&*self.arena.alloc(self.expr_err(*sp, guar)))\n                         }\n                         StructRest::None => None,\n                     };\n@@ -318,7 +319,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     )\n                 }\n                 ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n-                ExprKind::Err => hir::ExprKind::Err,\n+                ExprKind::Err => hir::ExprKind::Err(\n+                    self.tcx.sess.delay_span_bug(e.span, \"lowered ExprKind::Err\"),\n+                ),\n                 ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n \n                 ExprKind::Paren(_) | ExprKind::ForLoop(..) => unreachable!(\"already handled\"),\n@@ -761,7 +764,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.expr_ident_mut(span, task_context_ident, task_context_hid)\n             } else {\n                 // Use of `await` outside of an async context, we cannot use `task_context` here.\n-                self.expr_err(span)\n+                self.expr_err(span, self.tcx.sess.delay_span_bug(span, \"no task_context hir id\"))\n             };\n             let new_unchecked = self.expr_call_lang_item_fn_mut(\n                 span,"}, {"sha": "4095e225a8019ea846a88b67e70cc470863c1f5c", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -102,7 +102,12 @@ fn make_count<'hir>(\n                 let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, i)]);\n                 ctx.expr_call_mut(sp, count_param, value)\n             } else {\n-                ctx.expr(sp, hir::ExprKind::Err)\n+                ctx.expr(\n+                    sp,\n+                    hir::ExprKind::Err(\n+                        ctx.tcx.sess.delay_span_bug(sp, \"lowered bad format_args count\"),\n+                    ),\n+                )\n             }\n         }\n         None => ctx.expr_lang_item_type_relative(sp, hir::LangItem::FormatCount, sym::Implied),\n@@ -135,7 +140,10 @@ fn make_format_spec<'hir>(\n                 argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n             ctx.expr_usize(sp, i)\n         }\n-        Err(_) => ctx.expr(sp, hir::ExprKind::Err),\n+        Err(_) => ctx.expr(\n+            sp,\n+            hir::ExprKind::Err(ctx.tcx.sess.delay_span_bug(sp, \"lowered bad format_args count\")),\n+        ),\n     };\n     let &FormatOptions {\n         ref width,\n@@ -294,7 +302,12 @@ fn expand_format_args<'hir>(\n                 ));\n                 make_argument(ctx, sp, arg, ty)\n             } else {\n-                ctx.expr(macsp, hir::ExprKind::Err)\n+                ctx.expr(\n+                    macsp,\n+                    hir::ExprKind::Err(\n+                        ctx.tcx.sess.delay_span_bug(macsp, format!(\"no arg at {arg_index}\")),\n+                    ),\n+                )\n             }\n         }));\n         let elements: Vec<_> = arguments"}, {"sha": "7325bce6055923cf73af599e43a6eb7ba651136d", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -7,6 +7,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -284,7 +285,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n             },\n             ItemKind::GlobalAsm(asm) => hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm)),\n-            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: Some(ty), .. }) => {\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty, .. }) => {\n                 // We lower\n                 //\n                 // type Foo = impl Trait\n@@ -299,18 +300,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &generics,\n                     id,\n                     &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n-                );\n-                hir::ItemKind::TyAlias(ty, generics)\n-            }\n-            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: None, .. }) => {\n-                let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n-                let (generics, ty) = self.lower_generics(\n-                    &generics,\n-                    id,\n-                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.arena.alloc(this.ty(span, hir::TyKind::Err)),\n+                    |this| match ty {\n+                        None => {\n+                            let guar = this.tcx.sess.delay_span_bug(\n+                                span,\n+                                \"expected to lower type alias type, but it was missing\",\n+                            );\n+                            this.arena.alloc(this.ty(span, hir::TyKind::Err(guar)))\n+                        }\n+                        Some(ty) => this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n+                    },\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n@@ -798,8 +797,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    pub(crate) fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Err)\n+    pub(crate) fn expr_err(&mut self, span: Span, guar: ErrorGuaranteed) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::Err(guar))\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n@@ -847,7 +846,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| match ty {\n                         None => {\n-                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err));\n+                            let guar = this.tcx.sess.delay_span_bug(\n+                                i.span,\n+                                \"expected to lower associated type, but it was missing\",\n+                            );\n+                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err(guar)));\n                             hir::ImplItemKind::Type(ty)\n                         }\n                         Some(ty) => {\n@@ -973,7 +976,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr<'hir> {\n         match block {\n             Some(block) => self.lower_block_expr(block),\n-            None => self.expr_err(span),\n+            None => self.expr_err(span, self.tcx.sess.delay_span_bug(span, \"no block\")),\n         }\n     }\n \n@@ -983,7 +986,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 &[],\n                 match expr {\n                     Some(expr) => this.lower_expr_mut(expr),\n-                    None => this.expr_err(span),\n+                    None => this.expr_err(span, this.tcx.sess.delay_span_bug(span, \"no block\")),\n                 },\n             )\n         })"}, {"sha": "5d78d914b6d7f7c67ab46bfa7d3ad832a9b494cb", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -1082,11 +1082,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         hir::TypeBindingKind::Constraint { bounds }\n                     }\n                     DesugarKind::Error(position) => {\n-                        self.tcx.sess.emit_err(errors::MisplacedAssocTyBinding {\n+                        let guar = self.tcx.sess.emit_err(errors::MisplacedAssocTyBinding {\n                             span: constraint.span,\n                             position: DiagnosticArgFromDisplay(position),\n                         });\n-                        let err_ty = &*self.arena.alloc(self.ty(constraint.span, hir::TyKind::Err));\n+                        let err_ty =\n+                            &*self.arena.alloc(self.ty(constraint.span, hir::TyKind::Err(guar)));\n                         hir::TypeBindingKind::Equality { term: err_ty.into() }\n                     }\n                 }\n@@ -1255,7 +1256,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_ty_direct(&mut self, t: &Ty, itctx: &ImplTraitContext) -> hir::Ty<'hir> {\n         let kind = match &t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n-            TyKind::Err => hir::TyKind::Err,\n+            TyKind::Err => {\n+                hir::TyKind::Err(self.tcx.sess.delay_span_bug(t.span, \"TyKind::Err lowered\"))\n+            }\n             TyKind::Slice(ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Ref(region, mt) => {\n@@ -1381,7 +1384,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         path\n                     }\n                     ImplTraitContext::FeatureGated(position, feature) => {\n-                        self.tcx\n+                        let guar = self\n+                            .tcx\n                             .sess\n                             .create_feature_err(\n                                 MisplacedImplTrait {\n@@ -1391,24 +1395,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 *feature,\n                             )\n                             .emit();\n-                        hir::TyKind::Err\n+                        hir::TyKind::Err(guar)\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n-                        self.tcx.sess.emit_err(MisplacedImplTrait {\n+                        let guar = self.tcx.sess.emit_err(MisplacedImplTrait {\n                             span: t.span,\n                             position: DiagnosticArgFromDisplay(position),\n                         });\n-                        hir::TyKind::Err\n+                        hir::TyKind::Err(guar)\n                     }\n                 }\n             }\n             TyKind::MacCall(_) => panic!(\"`TyKind::MacCall` should have been expanded by now\"),\n             TyKind::CVarArgs => {\n-                self.tcx.sess.delay_span_bug(\n+                let guar = self.tcx.sess.delay_span_bug(\n                     t.span,\n                     \"`TyKind::CVarArgs` should have been handled elsewhere\",\n                 );\n-                hir::TyKind::Err\n+                hir::TyKind::Err(guar)\n             }\n         };\n "}, {"sha": "2509b70563956758860d1f855675d71d5e2c68f7", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -330,8 +330,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n-                self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n-                return self.arena.alloc(self.expr_err(expr.span));\n+                let guar = self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n+                return self.arena.alloc(self.expr_err(expr.span, guar));\n             }\n         }\n         self.lower_expr(expr)"}, {"sha": "3fdbc9715275fff1f343ba025eb958b55563b93a", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -152,7 +152,7 @@ pub fn parse_asm_args<'a>(\n                 ast::InlineAsmOperand::InOut { reg, expr, late: true }\n             }\n         } else if p.eat_keyword(kw::Const) {\n-            let anon_const = p.parse_anon_const_expr()?;\n+            let anon_const = p.parse_expr_anon_const()?;\n             ast::InlineAsmOperand::Const { anon_const }\n         } else if p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;"}, {"sha": "464ddae476a5e0ed7460e1023d7c78b41c8881d9", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -485,7 +485,7 @@ fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n     let normalised =\n         if upper_cased_code.starts_with('E') { upper_cased_code } else { format!(\"E{code:0>4}\") };\n     match registry.try_find_description(&normalised) {\n-        Ok(Some(description)) => {\n+        Ok(description) => {\n             let mut is_in_code_block = false;\n             let mut text = String::new();\n             // Slice off the leading newline and print.\n@@ -509,9 +509,6 @@ fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n                 print!(\"{text}\");\n             }\n         }\n-        Ok(None) => {\n-            early_error(output, &format!(\"no extended information for {code}\"));\n-        }\n         Err(InvalidErrorCode) => {\n             early_error(output, &format!(\"{code} is not a valid error code\"));\n         }"}, {"sha": "df857be85adabf8bc9dfe9da11b26848cdf633d7", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -513,7 +513,9 @@ E0790: include_str!(\"./error_codes/E0790.md\"),\n E0791: include_str!(\"./error_codes/E0791.md\"),\n E0792: include_str!(\"./error_codes/E0792.md\"),\n E0793: include_str!(\"./error_codes/E0793.md\"),\n-;\n+}\n+\n+// Undocumented removed error codes. Note that many removed error codes are documented.\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard\n //  E0019, // merged into E0015\n@@ -570,7 +572,7 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0246, // invalid recursive type\n //  E0247,\n //  E0248, // value used as a type, now reported earlier during resolution\n-           // as E0412\n+//         // as E0412\n //  E0249,\n //  E0257,\n //  E0258,\n@@ -631,14 +633,14 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0558, // replaced with a generic attribute input check\n //  E0563, // cannot determine a type for this `impl Trait` removed in 6383de15\n //  E0564, // only named lifetimes are allowed in `impl Trait`,\n-           // but `{}` was found in the type `{}`\n+//         // but `{}` was found in the type `{}`\n //  E0598, // lifetime of {} is too short to guarantee its contents can be...\n //  E0611, // merged into E0616\n //  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)\n //  E0629, // missing 'feature' (rustc_const_unstable)\n //  E0630, // rustc_const_unstable attribute must be paired with stable/unstable\n-           // attribute\n+//         // attribute\n //  E0645, // trait aliases not finished\n //  E0694, // an unknown tool name found in scoped attributes\n //  E0702, // replaced with a generic attribute input check\n@@ -647,4 +649,3 @@ E0793: include_str!(\"./error_codes/E0793.md\"),\n //  E0721, // `await` keyword\n //  E0723, // unstable feature in `const` context\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n-}"}, {"sha": "d6b120e4dfcf23b81c3f029707beefdfb412cd35", "filename": "compiler/rustc_error_codes/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -5,10 +5,9 @@\n //! the goal being to make their maintenance easier.\n \n macro_rules! register_diagnostics {\n-    ($($ecode:ident: $message:expr,)* ; $($code:ident,)*) => (\n-        pub static DIAGNOSTICS: &[(&str, Option<&str>)] = &[\n-            $( (stringify!($ecode), Some($message)), )*\n-            $( (stringify!($code), None), )*\n+    ($($ecode:ident: $message:expr,)*) => (\n+        pub static DIAGNOSTICS: &[(&str, &str)] = &[\n+            $( (stringify!($ecode), $message), )*\n         ];\n     )\n }"}, {"sha": "f32d6b96b9b2429d13e47d61f29789c23daaf392", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -580,7 +580,7 @@ impl DiagnosticCode {\n             let je_result =\n                 je.registry.as_ref().map(|registry| registry.try_find_description(&s)).unwrap();\n \n-            DiagnosticCode { code: s, explanation: je_result.unwrap_or(None) }\n+            DiagnosticCode { code: s, explanation: je_result.ok() }\n         })\n     }\n }"}, {"sha": "cbf595089ccc68c7e874ef5c2250ca810ca28a73", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -42,7 +42,7 @@ pub use rustc_error_messages::{\n pub use rustc_lint_defs::{pluralize, Applicability};\n use rustc_macros::fluent_messages;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::HashStableContext;\n+pub use rustc_span::ErrorGuaranteed;\n use rustc_span::{Loc, Span};\n \n use std::borrow::Cow;\n@@ -1477,9 +1477,7 @@ impl HandlerInner {\n                 .emitted_diagnostic_codes\n                 .iter()\n                 .filter_map(|x| match &x {\n-                    DiagnosticId::Error(s)\n-                        if registry.try_find_description(s).map_or(false, |o| o.is_some()) =>\n-                    {\n+                    DiagnosticId::Error(s) if registry.try_find_description(s).is_ok() => {\n                         Some(s.clone())\n                     }\n                     _ => None,\n@@ -1846,17 +1844,3 @@ pub enum TerminalUrl {\n     Yes,\n     Auto,\n }\n-\n-/// Useful type to use with `Result<>` indicate that an error has already\n-/// been reported to the user, so no need to continue checking.\n-#[derive(Clone, Copy, Debug, Encodable, Decodable, Hash, PartialEq, Eq, PartialOrd, Ord)]\n-#[derive(HashStable_Generic)]\n-pub struct ErrorGuaranteed(());\n-\n-impl ErrorGuaranteed {\n-    /// To be used only if you really know what you are doing... ideally, we would find a way to\n-    /// eliminate all calls to this method.\n-    pub fn unchecked_claim_error_was_emitted() -> Self {\n-        ErrorGuaranteed(())\n-    }\n-}"}, {"sha": "f26d8e7ebdc34241da30bda5d32d0eefd5d48a7f", "filename": "compiler/rustc_errors/src/registry.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -5,21 +5,17 @@ pub struct InvalidErrorCode;\n \n #[derive(Clone)]\n pub struct Registry {\n-    long_descriptions: FxHashMap<&'static str, Option<&'static str>>,\n+    long_descriptions: FxHashMap<&'static str, &'static str>,\n }\n \n impl Registry {\n-    pub fn new(long_descriptions: &[(&'static str, Option<&'static str>)]) -> Registry {\n+    pub fn new(long_descriptions: &[(&'static str, &'static str)]) -> Registry {\n         Registry { long_descriptions: long_descriptions.iter().copied().collect() }\n     }\n \n     /// Returns `InvalidErrorCode` if the code requested does not exist in the\n-    /// registry. Otherwise, returns an `Option` where `None` means the error\n-    /// code is valid but has no extended information.\n-    pub fn try_find_description(\n-        &self,\n-        code: &str,\n-    ) -> Result<Option<&'static str>, InvalidErrorCode> {\n+    /// registry.\n+    pub fn try_find_description(&self, code: &str) -> Result<&'static str, InvalidErrorCode> {\n         self.long_descriptions.get(code).copied().ok_or(InvalidErrorCode)\n     }\n }"}, {"sha": "72e9f7c13437e3366e0ecfd8bc16fd3251ac974b", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -369,10 +369,10 @@ impl<'hir> GenericArgs<'hir> {\n \n     pub fn has_err(&self) -> bool {\n         self.args.iter().any(|arg| match arg {\n-            GenericArg::Type(ty) => matches!(ty.kind, TyKind::Err),\n+            GenericArg::Type(ty) => matches!(ty.kind, TyKind::Err(_)),\n             _ => false,\n         }) || self.bindings.iter().any(|arg| match arg.kind {\n-            TypeBindingKind::Equality { term: Term::Ty(ty) } => matches!(ty.kind, TyKind::Err),\n+            TypeBindingKind::Equality { term: Term::Ty(ty) } => matches!(ty.kind, TyKind::Err(_)),\n             _ => false,\n         })\n     }\n@@ -1688,7 +1688,7 @@ impl Expr<'_> {\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n-            ExprKind::Err => ExprPrecedence::Err,\n+            ExprKind::Err(_) => ExprPrecedence::Err,\n         }\n     }\n \n@@ -1754,7 +1754,7 @@ impl Expr<'_> {\n             | ExprKind::Yield(..)\n             | ExprKind::Cast(..)\n             | ExprKind::DropTemps(..)\n-            | ExprKind::Err => false,\n+            | ExprKind::Err(_) => false,\n         }\n     }\n \n@@ -1840,7 +1840,7 @@ impl Expr<'_> {\n             | ExprKind::Binary(..)\n             | ExprKind::Yield(..)\n             | ExprKind::DropTemps(..)\n-            | ExprKind::Err => true,\n+            | ExprKind::Err(_) => true,\n         }\n     }\n \n@@ -2013,7 +2013,7 @@ pub enum ExprKind<'hir> {\n     Yield(&'hir Expr<'hir>, YieldSource),\n \n     /// A placeholder for an expression that wasn't syntactically well formed in some way.\n-    Err,\n+    Err(rustc_span::ErrorGuaranteed),\n }\n \n /// Represents an optionally `Self`-qualified value/type path or associated extension.\n@@ -2676,7 +2676,7 @@ pub enum TyKind<'hir> {\n     /// specified. This can appear anywhere in a type.\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n-    Err,\n+    Err(rustc_span::ErrorGuaranteed),\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "cc0f64017e426d7c78111475e0d7bab4711ecd13", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -790,7 +790,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::Err(_) => {}\n     }\n }\n \n@@ -844,7 +844,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n             visitor.visit_lifetime(lifetime);\n         }\n         TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n-        TyKind::Infer | TyKind::Err => {}\n+        TyKind::Infer | TyKind::Err(_) => {}\n     }\n }\n "}, {"sha": "60fa5a99e103c7296699d5fdf7095fc2ef2bc207", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -302,8 +302,6 @@ language_item_table! {\n     Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n-    FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n-\n     OptionSome,              sym::Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n     OptionNone,              sym::None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n "}, {"sha": "50b0816889ba2120dd9c4dd18716301dd9379cb1", "filename": "compiler/rustc_hir_analysis/locales/en-US.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -131,7 +131,7 @@ hir_analysis_where_clause_on_main = `main` function is not allowed to have a `wh\n     .label = `main` cannot have a `where` clause\n \n hir_analysis_track_caller_on_main = `main` function is not allowed to be `#[track_caller]`\n-    .label = `main` function is not allowed to be `#[track_caller]`\n+    .suggestion = remove this annotation\n \n hir_analysis_start_not_track_caller = `start` is not allowed to be `#[track_caller]`\n     .label = `start` is not allowed to be `#[track_caller]`"}, {"sha": "a15cf454df72f30ead7aabfafb1f3fe92611e90b", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -3113,7 +3113,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // handled specially and will not descend into this routine.\n                 self.ty_infer(None, ast_ty.span)\n             }\n-            hir::TyKind::Err => tcx.ty_error_misc(),\n+            hir::TyKind::Err(guar) => tcx.ty_error(*guar),\n         };\n \n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);"}, {"sha": "a566e73912e4586a68874dca1a940d6525174050", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -329,8 +329,9 @@ pub(crate) struct WhereClauseOnMain {\n #[diag(hir_analysis_track_caller_on_main)]\n pub(crate) struct TrackCallerOnMain {\n     #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"\")]\n     pub span: Span,\n-    #[label]\n+    #[label(hir_analysis_track_caller_on_main)]\n     pub annotated: Span,\n }\n "}, {"sha": "c021fca71339038652d8047d74df664f864285c4", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -358,7 +358,7 @@ impl<'a> State<'a> {\n                 self.print_anon_const(e);\n                 self.word(\")\");\n             }\n-            hir::TyKind::Err => {\n+            hir::TyKind::Err(_) => {\n                 self.popen();\n                 self.word(\"/*ERROR*/\");\n                 self.pclose();\n@@ -1559,7 +1559,7 @@ impl<'a> State<'a> {\n                 self.word_space(\"yield\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n             }\n-            hir::ExprKind::Err => {\n+            hir::ExprKind::Err(_) => {\n                 self.popen();\n                 self.word(\"/*ERROR*/\");\n                 self.pclose();"}, {"sha": "7fc4ccb04ee0bd1b49991451f4aecd164a2ba880", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -354,7 +354,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Field(base, field) => self.check_field(expr, &base, field, expected),\n             ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n-            hir::ExprKind::Err => tcx.ty_error_misc(),\n+            hir::ExprKind::Err(guar) => tcx.ty_error(guar),\n         }\n     }\n "}, {"sha": "b9a058d6bba2c8732779a6a214c04f06497c4392", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::Continue(..)\n             | hir::ExprKind::Lit(..)\n             | hir::ExprKind::ConstBlock(..)\n-            | hir::ExprKind::Err => {}\n+            | hir::ExprKind::Err(_) => {}\n \n             hir::ExprKind::Loop(blk, ..) => {\n                 self.walk_block(blk);"}, {"sha": "7c0402b1c7fb86c8c16aca1bfd5931d59f3610a2", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             | ExprKind::Struct(..)\n             | ExprKind::Repeat(..)\n             | ExprKind::Yield(..)\n-            | ExprKind::Err => (),\n+            | ExprKind::Err(_) => (),\n         }\n     }\n \n@@ -483,7 +483,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n             | ExprKind::Closure { .. }\n             | ExprKind::ConstBlock(..)\n             | ExprKind::DropTemps(..)\n-            | ExprKind::Err\n+            | ExprKind::Err(_)\n             | ExprKind::Field(..)\n             | ExprKind::Index(..)\n             | ExprKind::InlineAsm(..)"}, {"sha": "bcfc61bffb2c66038c2b4964d1fd16b67724e542", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -383,7 +383,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | hir::ExprKind::Repeat(..)\n             | hir::ExprKind::InlineAsm(..)\n             | hir::ExprKind::Box(..)\n-            | hir::ExprKind::Err => Ok(self.cat_rvalue(expr.hir_id, expr.span, expr_ty)),\n+            | hir::ExprKind::Err(_) => Ok(self.cat_rvalue(expr.hir_id, expr.span, expr_ty)),\n         }\n     }\n "}, {"sha": "c07ff516579947859dd597b946a467b43abf893b", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -116,11 +116,11 @@ pub fn elaborate_predicates_with_span<'tcx>(\n \n pub fn elaborate_obligations<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    mut obligations: Vec<PredicateObligation<'tcx>>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let mut visited = PredicateSet::new(tcx);\n-    obligations.retain(|obligation| visited.insert(obligation.predicate));\n-    Elaborator { stack: obligations, visited }\n+    let mut elaborator = Elaborator { stack: Vec::new(), visited: PredicateSet::new(tcx) };\n+    elaborator.extend_deduped(obligations);\n+    elaborator\n }\n \n fn predicate_obligation<'tcx>(\n@@ -132,6 +132,15 @@ fn predicate_obligation<'tcx>(\n }\n \n impl<'tcx> Elaborator<'tcx> {\n+    fn extend_deduped(&mut self, obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>) {\n+        // Only keep those bounds that we haven't already seen.\n+        // This is necessary to prevent infinite recursion in some\n+        // cases. One common case is when people define\n+        // `trait Sized: Sized { }` rather than `trait Sized { }`.\n+        // let visited = &mut self.visited;\n+        self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate)));\n+    }\n+\n     pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n         FilterToTraits::new(self)\n     }\n@@ -172,15 +181,7 @@ impl<'tcx> Elaborator<'tcx> {\n                         )\n                     });\n                 debug!(?data, ?obligations, \"super_predicates\");\n-\n-                // Only keep those bounds that we haven't already seen.\n-                // This is necessary to prevent infinite recursion in some\n-                // cases. One common case is when people define\n-                // `trait Sized: Sized { }` rather than `trait Sized { }`.\n-                let visited = &mut self.visited;\n-                let obligations = obligations.filter(|o| visited.insert(o.predicate));\n-\n-                self.stack.extend(obligations);\n+                self.extend_deduped(obligations);\n             }\n             ty::PredicateKind::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n@@ -237,10 +238,9 @@ impl<'tcx> Elaborator<'tcx> {\n                     return;\n                 }\n \n-                let visited = &mut self.visited;\n                 let mut components = smallvec![];\n                 push_outlives_components(tcx, ty_max, &mut components);\n-                self.stack.extend(\n+                self.extend_deduped(\n                     components\n                         .into_iter()\n                         .filter_map(|component| match component {\n@@ -280,7 +280,6 @@ impl<'tcx> Elaborator<'tcx> {\n                         .map(|predicate_kind| {\n                             bound_predicate.rebind(predicate_kind).to_predicate(tcx)\n                         })\n-                        .filter(|&predicate| visited.insert(predicate))\n                         .map(|predicate| {\n                             predicate_obligation(\n                                 predicate,"}, {"sha": "ae203233bd568e6b7e136b19f7916fdb50f2b15f", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -758,7 +758,7 @@ impl<'tcx> Cx<'tcx> {\n             hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: self.mirror_exprs(fields) },\n \n             hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: self.mirror_expr(v) },\n-            hir::ExprKind::Err => unreachable!(),\n+            hir::ExprKind::Err(_) => unreachable!(),\n         };\n \n         Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind }"}, {"sha": "b4948dddcc95c024a69d948bddd497e76c71962a", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -693,7 +693,7 @@ impl<'a> Parser<'a> {\n                 span: self.prev_token.span.shrink_to_lo(),\n                 tokens: None,\n             };\n-            let struct_expr = snapshot.parse_struct_expr(None, path, false);\n+            let struct_expr = snapshot.parse_expr_struct(None, path, false);\n             let block_tail = self.parse_block_tail(lo, s, AttemptLocalParseRecovery::No);\n             return Some(match (struct_expr, block_tail) {\n                 (Ok(expr), Err(mut err)) => {\n@@ -1624,7 +1624,7 @@ impl<'a> Parser<'a> {\n             // Handle `await { <expr> }`.\n             // This needs to be handled separately from the next arm to avoid\n             // interpreting `await { <expr> }?` as `<expr>?.await`.\n-            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default)\n+            self.parse_expr_block(None, self.token.span, BlockCheckMode::Default)\n         } else {\n             self.parse_expr()\n         }"}, {"sha": "33254d034c9dbdef4f26353f4eb38af7df02e3b8", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 118, "deletions": 118, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -103,7 +103,7 @@ impl<'a> Parser<'a> {\n         self.collect_tokens_no_attrs(|this| this.parse_expr())\n     }\n \n-    pub fn parse_anon_const_expr(&mut self) -> PResult<'a, AnonConst> {\n+    pub fn parse_expr_anon_const(&mut self) -> PResult<'a, AnonConst> {\n         self.parse_expr().map(|value| AnonConst { id: DUMMY_NODE_ID, value })\n     }\n \n@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a sequence of expressions delimited by parentheses.\n-    fn parse_paren_expr_seq(&mut self) -> PResult<'a, ThinVec<P<Expr>>> {\n+    fn parse_expr_paren_seq(&mut self) -> PResult<'a, ThinVec<P<Expr>>> {\n         self.parse_paren_comma_seq(|p| p.parse_expr_catch_underscore()).map(|(r, _)| r)\n     }\n \n@@ -136,23 +136,23 @@ impl<'a> Parser<'a> {\n         r: Restrictions,\n         already_parsed_attrs: Option<AttrWrapper>,\n     ) -> PResult<'a, P<Expr>> {\n-        self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n+        self.with_res(r, |this| this.parse_expr_assoc(already_parsed_attrs))\n     }\n \n     /// Parses an associative expression.\n     ///\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n     #[inline]\n-    fn parse_assoc_expr(\n+    fn parse_expr_assoc(\n         &mut self,\n         already_parsed_attrs: Option<AttrWrapper>,\n     ) -> PResult<'a, P<Expr>> {\n-        self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n+        self.parse_expr_assoc_with(0, already_parsed_attrs.into())\n     }\n \n     /// Parses an associative expression with operators of at least `min_prec` precedence.\n-    pub(super) fn parse_assoc_expr_with(\n+    pub(super) fn parse_expr_assoc_with(\n         &mut self,\n         min_prec: usize,\n         lhs: LhsExpr,\n@@ -167,9 +167,9 @@ impl<'a> Parser<'a> {\n                 _ => None,\n             };\n             if self.token.is_range_separator() {\n-                return self.parse_prefix_range_expr(attrs);\n+                return self.parse_expr_prefix_range(attrs);\n             } else {\n-                self.parse_prefix_expr(attrs)?\n+                self.parse_expr_prefix(attrs)?\n             }\n         };\n         let last_type_ascription_set = self.last_type_ascription.is_some();\n@@ -293,7 +293,7 @@ impl<'a> Parser<'a> {\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn't have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n-                lhs = self.parse_range_expr(prec, lhs, op, cur_op_span)?;\n+                lhs = self.parse_expr_range(prec, lhs, op, cur_op_span)?;\n                 break;\n             }\n \n@@ -306,7 +306,7 @@ impl<'a> Parser<'a> {\n                 Fixity::None => 1,\n             };\n             let rhs = self.with_res(restrictions - Restrictions::STMT_EXPR, |this| {\n-                this.parse_assoc_expr_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n+                this.parse_expr_assoc_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n             })?;\n \n             let span = self.mk_expr_sp(&lhs, lhs_span, rhs.span);\n@@ -458,15 +458,15 @@ impl<'a> Parser<'a> {\n \n     /// Parses `x..y`, `x..=y`, and `x..`/`x..=`.\n     /// The other two variants are handled in `parse_prefix_range_expr` below.\n-    fn parse_range_expr(\n+    fn parse_expr_range(\n         &mut self,\n         prec: usize,\n         lhs: P<Expr>,\n         op: AssocOp,\n         cur_op_span: Span,\n     ) -> PResult<'a, P<Expr>> {\n         let rhs = if self.is_at_start_of_range_notation_rhs() {\n-            Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n+            Some(self.parse_expr_assoc_with(prec + 1, LhsExpr::NotYetParsed)?)\n         } else {\n             None\n         };\n@@ -491,7 +491,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses prefix-forms of range notation: `..expr`, `..`, `..=expr`.\n-    fn parse_prefix_range_expr(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_prefix_range(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n         // Check for deprecated `...` syntax.\n         if self.token == token::DotDotDot {\n             self.err_dotdotdot_syntax(self.token.span);\n@@ -518,7 +518,7 @@ impl<'a> Parser<'a> {\n             this.bump();\n             let (span, opt_end) = if this.is_at_start_of_range_notation_rhs() {\n                 // RHS must be parsed with more associativity than the dots.\n-                this.parse_assoc_expr_with(op.unwrap().precedence() + 1, LhsExpr::NotYetParsed)\n+                this.parse_expr_assoc_with(op.unwrap().precedence() + 1, LhsExpr::NotYetParsed)\n                     .map(|x| (lo.to(x.span), Some(x)))?\n             } else {\n                 (lo, None)\n@@ -529,7 +529,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a prefix-unary-operator expr.\n-    fn parse_prefix_expr(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_prefix(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n \n@@ -547,20 +547,20 @@ impl<'a> Parser<'a> {\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n         match this.token.uninterpolate().kind {\n             // `!expr`\n-            token::Not => make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Not)),\n+            token::Not => make_it!(this, attrs, |this, _| this.parse_expr_unary(lo, UnOp::Not)),\n             // `~expr`\n             token::Tilde => make_it!(this, attrs, |this, _| this.recover_tilde_expr(lo)),\n             // `-expr`\n             token::BinOp(token::Minus) => {\n-                make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Neg))\n+                make_it!(this, attrs, |this, _| this.parse_expr_unary(lo, UnOp::Neg))\n             }\n             // `*expr`\n             token::BinOp(token::Star) => {\n-                make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Deref))\n+                make_it!(this, attrs, |this, _| this.parse_expr_unary(lo, UnOp::Deref))\n             }\n             // `&expr` and `&&expr`\n             token::BinOp(token::And) | token::AndAnd => {\n-                make_it!(this, attrs, |this, _| this.parse_borrow_expr(lo))\n+                make_it!(this, attrs, |this, _| this.parse_expr_borrow(lo))\n             }\n             // `+lit`\n             token::BinOp(token::Plus) if this.look_ahead(1, |tok| tok.is_numeric_lit()) => {\n@@ -579,7 +579,7 @@ impl<'a> Parser<'a> {\n                 this.sess.emit_err(err);\n \n                 this.bump();\n-                this.parse_prefix_expr(None)\n+                this.parse_expr_prefix(None)\n             }\n             // Recover from `++x`:\n             token::BinOp(token::Plus)\n@@ -592,41 +592,41 @@ impl<'a> Parser<'a> {\n                 this.bump();\n                 this.bump();\n \n-                let operand_expr = this.parse_dot_or_call_expr(Default::default())?;\n+                let operand_expr = this.parse_expr_dot_or_call(Default::default())?;\n                 this.recover_from_prefix_increment(operand_expr, pre_span, starts_stmt)\n             }\n             token::Ident(..) if this.token.is_keyword(kw::Box) => {\n-                make_it!(this, attrs, |this, _| this.parse_box_expr(lo))\n+                make_it!(this, attrs, |this, _| this.parse_expr_box(lo))\n             }\n             token::Ident(..) if this.may_recover() && this.is_mistaken_not_ident_negation() => {\n                 make_it!(this, attrs, |this, _| this.recover_not_expr(lo))\n             }\n-            _ => return this.parse_dot_or_call_expr(Some(attrs)),\n+            _ => return this.parse_expr_dot_or_call(Some(attrs)),\n         }\n     }\n \n-    fn parse_prefix_expr_common(&mut self, lo: Span) -> PResult<'a, (Span, P<Expr>)> {\n+    fn parse_expr_prefix_common(&mut self, lo: Span) -> PResult<'a, (Span, P<Expr>)> {\n         self.bump();\n-        let expr = self.parse_prefix_expr(None);\n+        let expr = self.parse_expr_prefix(None);\n         let (span, expr) = self.interpolated_or_expr_span(expr)?;\n         Ok((lo.to(span), expr))\n     }\n \n-    fn parse_unary_expr(&mut self, lo: Span, op: UnOp) -> PResult<'a, (Span, ExprKind)> {\n-        let (span, expr) = self.parse_prefix_expr_common(lo)?;\n+    fn parse_expr_unary(&mut self, lo: Span, op: UnOp) -> PResult<'a, (Span, ExprKind)> {\n+        let (span, expr) = self.parse_expr_prefix_common(lo)?;\n         Ok((span, self.mk_unary(op, expr)))\n     }\n \n     /// Recover on `~expr` in favor of `!expr`.\n     fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.sess.emit_err(errors::TildeAsUnaryOperator(lo));\n \n-        self.parse_unary_expr(lo, UnOp::Not)\n+        self.parse_expr_unary(lo, UnOp::Not)\n     }\n \n     /// Parse `box expr`.\n-    fn parse_box_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        let (span, expr) = self.parse_prefix_expr_common(lo)?;\n+    fn parse_expr_box(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+        let (span, expr) = self.parse_expr_prefix_common(lo)?;\n         self.sess.gated_spans.gate(sym::box_syntax, span);\n         Ok((span, ExprKind::Box(expr)))\n     }\n@@ -664,7 +664,7 @@ impl<'a> Parser<'a> {\n             ),\n         });\n \n-        self.parse_unary_expr(lo, UnOp::Not)\n+        self.parse_expr_unary(lo, UnOp::Not)\n     }\n \n     /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n@@ -722,7 +722,7 @@ impl<'a> Parser<'a> {\n                                 segments[0].ident.span,\n                             ),\n                         };\n-                        match self.parse_labeled_expr(label, false) {\n+                        match self.parse_expr_labeled(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n                                 self.sess.emit_err(errors::MalformedLoopLabel {\n@@ -816,7 +816,7 @@ impl<'a> Parser<'a> {\n                 (\"cast\", None)\n             };\n \n-        let with_postfix = self.parse_dot_or_call_expr_with_(cast_expr, span)?;\n+        let with_postfix = self.parse_expr_dot_or_call_with_(cast_expr, span)?;\n \n         // Check if an illegal postfix operator has been added after the cast.\n         // If the resulting expression is not a cast, it is an illegal postfix operator.\n@@ -887,15 +887,15 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n-    fn parse_borrow_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+    fn parse_expr_borrow(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.expect_and()?;\n         let has_lifetime = self.token.is_lifetime() && self.look_ahead(1, |t| t != &token::Colon);\n         let lifetime = has_lifetime.then(|| self.expect_lifetime()); // For recovery, see below.\n         let (borrow_kind, mutbl) = self.parse_borrow_modifiers(lo);\n         let expr = if self.token.is_range_separator() {\n-            self.parse_prefix_range_expr(None)\n+            self.parse_expr_prefix_range(None)\n         } else {\n-            self.parse_prefix_expr(None)\n+            self.parse_expr_prefix(None)\n         };\n         let (hi, expr) = self.interpolated_or_expr_span(expr)?;\n         let span = lo.to(hi);\n@@ -925,16 +925,16 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n-    fn parse_dot_or_call_expr(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_dot_or_call(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         self.collect_tokens_for_expr(attrs, |this, attrs| {\n-            let base = this.parse_bottom_expr();\n+            let base = this.parse_expr_bottom();\n             let (span, base) = this.interpolated_or_expr_span(base)?;\n-            this.parse_dot_or_call_expr_with(base, span, attrs)\n+            this.parse_expr_dot_or_call_with(base, span, attrs)\n         })\n     }\n \n-    pub(super) fn parse_dot_or_call_expr_with(\n+    pub(super) fn parse_expr_dot_or_call_with(\n         &mut self,\n         e0: P<Expr>,\n         lo: Span,\n@@ -943,7 +943,7 @@ impl<'a> Parser<'a> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n-        let res = self.parse_dot_or_call_expr_with_(e0, lo);\n+        let res = self.parse_expr_dot_or_call_with_(e0, lo);\n         if attrs.is_empty() {\n             res\n         } else {\n@@ -957,7 +957,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_dot_or_call_expr_with_(&mut self, mut e: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_dot_or_call_with_(&mut self, mut e: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         loop {\n             let has_question = if self.prev_token.kind == TokenKind::Ident(kw::Return, false) {\n                 // we are using noexpect here because we don't expect a `?` directly after a `return`\n@@ -980,15 +980,15 @@ impl<'a> Parser<'a> {\n             };\n             if has_dot {\n                 // expr.f\n-                e = self.parse_dot_suffix_expr(lo, e)?;\n+                e = self.parse_expr_dot_suffix(lo, e)?;\n                 continue;\n             }\n             if self.expr_is_complete(&e) {\n                 return Ok(e);\n             }\n             e = match self.token.kind {\n-                token::OpenDelim(Delimiter::Parenthesis) => self.parse_fn_call_expr(lo, e),\n-                token::OpenDelim(Delimiter::Bracket) => self.parse_index_expr(lo, e)?,\n+                token::OpenDelim(Delimiter::Parenthesis) => self.parse_expr_fn_call(lo, e),\n+                token::OpenDelim(Delimiter::Bracket) => self.parse_expr_index(lo, e)?,\n                 _ => return Ok(e),\n             }\n         }\n@@ -1000,14 +1000,14 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(3, |t| t.can_begin_expr())\n     }\n \n-    fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_dot_suffix(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n         match self.token.uninterpolate().kind {\n             token::Ident(..) => self.parse_dot_suffix(base, lo),\n             token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n-                Ok(self.parse_tuple_field_access_expr(lo, base, symbol, suffix, None))\n+                Ok(self.parse_expr_tuple_field_access(lo, base, symbol, suffix, None))\n             }\n             token::Literal(token::Lit { kind: token::Float, symbol, suffix }) => {\n-                Ok(self.parse_tuple_field_access_expr_float(lo, base, symbol, suffix))\n+                Ok(self.parse_expr_tuple_field_access_float(lo, base, symbol, suffix))\n             }\n             _ => {\n                 self.error_unexpected_after_dot();\n@@ -1029,7 +1029,7 @@ impl<'a> Parser<'a> {\n     // support pushing \"future tokens\" (would be also helpful to `break_and_eat`), or\n     // we should break everything including floats into more basic proc-macro style\n     // tokens in the lexer (probably preferable).\n-    fn parse_tuple_field_access_expr_float(\n+    fn parse_expr_tuple_field_access_float(\n         &mut self,\n         lo: Span,\n         base: P<Expr>,\n@@ -1072,7 +1072,7 @@ impl<'a> Parser<'a> {\n         match &*components {\n             // 1e2\n             [IdentLike(i)] => {\n-                self.parse_tuple_field_access_expr(lo, base, Symbol::intern(&i), suffix, None)\n+                self.parse_expr_tuple_field_access(lo, base, Symbol::intern(&i), suffix, None)\n             }\n             // 1.\n             [IdentLike(i), Punct('.')] => {\n@@ -1088,7 +1088,7 @@ impl<'a> Parser<'a> {\n                 let symbol = Symbol::intern(&i);\n                 self.token = Token::new(token::Ident(symbol, false), ident_span);\n                 let next_token = (Token::new(token::Dot, dot_span), self.token_spacing);\n-                self.parse_tuple_field_access_expr(lo, base, symbol, None, Some(next_token))\n+                self.parse_expr_tuple_field_access(lo, base, symbol, None, Some(next_token))\n             }\n             // 1.2 | 1.2e3\n             [IdentLike(i1), Punct('.'), IdentLike(i2)] => {\n@@ -1109,11 +1109,11 @@ impl<'a> Parser<'a> {\n                 // See issue #76399 and PR #76285 for more details\n                 let next_token1 = (Token::new(token::Dot, dot_span), Spacing::Alone);\n                 let base1 =\n-                    self.parse_tuple_field_access_expr(lo, base, symbol1, None, Some(next_token1));\n+                    self.parse_expr_tuple_field_access(lo, base, symbol1, None, Some(next_token1));\n                 let symbol2 = Symbol::intern(&i2);\n                 let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n                 self.bump_with((next_token2, self.token_spacing)); // `.`\n-                self.parse_tuple_field_access_expr(lo, base1, symbol2, suffix, None)\n+                self.parse_expr_tuple_field_access(lo, base1, symbol2, suffix, None)\n             }\n             // 1e+ | 1e- (recovered)\n             [IdentLike(_), Punct('+' | '-')] |\n@@ -1131,7 +1131,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_tuple_field_access_expr(\n+    fn parse_expr_tuple_field_access(\n         &mut self,\n         lo: Span,\n         base: P<Expr>,\n@@ -1152,7 +1152,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a function call expression, `expr(...)`.\n-    fn parse_fn_call_expr(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n+    fn parse_expr_fn_call(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n         let snapshot = if self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n             && self.look_ahead_type_ascription_as_field()\n         {\n@@ -1163,7 +1163,7 @@ impl<'a> Parser<'a> {\n         let open_paren = self.token.span;\n \n         let mut seq = self\n-            .parse_paren_expr_seq()\n+            .parse_expr_paren_seq()\n             .map(|args| self.mk_expr(lo.to(self.prev_token.span), self.mk_call(fun, args)));\n         if let Some(expr) =\n             self.maybe_recover_struct_lit_bad_delims(lo, open_paren, &mut seq, snapshot)\n@@ -1236,7 +1236,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an indexing expression `expr[...]`.\n-    fn parse_index_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_index(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n         let prev_span = self.prev_token.span;\n         let open_delim_span = self.token.span;\n         self.bump(); // `[`\n@@ -1259,7 +1259,7 @@ impl<'a> Parser<'a> {\n \n         if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // Method call `expr.f()`\n-            let args = self.parse_paren_expr_seq()?;\n+            let args = self.parse_expr_paren_seq()?;\n             let fn_span = fn_span_lo.to(self.prev_token.span);\n             let span = lo.to(self.prev_token.span);\n             Ok(self.mk_expr(\n@@ -1287,7 +1287,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// N.B., this does not parse outer attributes, and is private because it only works\n     /// correctly if called from `parse_dot_or_call_expr()`.\n-    fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_bottom(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole_expr!(self);\n \n@@ -1300,13 +1300,13 @@ impl<'a> Parser<'a> {\n             // This match arm is a special-case of the `_` match arm below and\n             // could be removed without changing functionality, but it's faster\n             // to have it here, especially for programs with large constants.\n-            self.parse_lit_expr()\n+            self.parse_expr_lit()\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n-            self.parse_tuple_parens_expr()\n+            self.parse_expr_tuple_parens()\n         } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-            self.parse_block_expr(None, lo, BlockCheckMode::Default)\n+            self.parse_expr_block(None, lo, BlockCheckMode::Default)\n         } else if self.check(&token::BinOp(token::Or)) || self.check(&token::OrOr) {\n-            self.parse_closure_expr().map_err(|mut err| {\n+            self.parse_expr_closure().map_err(|mut err| {\n                 // If the input is something like `if a { 1 } else { 2 } | if a { 3 } else { 4 }`\n                 // then suggest parens around the lhs.\n                 if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n@@ -1315,42 +1315,42 @@ impl<'a> Parser<'a> {\n                 err\n             })\n         } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n-            self.parse_array_or_repeat_expr(Delimiter::Bracket)\n+            self.parse_expr_array_or_repeat(Delimiter::Bracket)\n         } else if self.check_path() {\n-            self.parse_path_start_expr()\n+            self.parse_expr_path_start()\n         } else if self.check_keyword(kw::Move)\n             || self.check_keyword(kw::Static)\n             || self.check_const_closure()\n         {\n-            self.parse_closure_expr()\n+            self.parse_expr_closure()\n         } else if self.eat_keyword(kw::If) {\n-            self.parse_if_expr()\n+            self.parse_expr_if()\n         } else if self.check_keyword(kw::For) {\n             if self.choose_generics_over_qpath(1) {\n-                self.parse_closure_expr()\n+                self.parse_expr_closure()\n             } else {\n                 assert!(self.eat_keyword(kw::For));\n-                self.parse_for_expr(None, self.prev_token.span)\n+                self.parse_expr_for(None, self.prev_token.span)\n             }\n         } else if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(None, self.prev_token.span)\n+            self.parse_expr_while(None, self.prev_token.span)\n         } else if let Some(label) = self.eat_label() {\n-            self.parse_labeled_expr(label, true)\n+            self.parse_expr_labeled(label, true)\n         } else if self.eat_keyword(kw::Loop) {\n             let sp = self.prev_token.span;\n-            self.parse_loop_expr(None, self.prev_token.span).map_err(|mut err| {\n+            self.parse_expr_loop(None, self.prev_token.span).map_err(|mut err| {\n                 err.span_label(sp, \"while parsing this `loop` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Match) {\n             let match_sp = self.prev_token.span;\n-            self.parse_match_expr().map_err(|mut err| {\n+            self.parse_expr_match().map_err(|mut err| {\n                 err.span_label(match_sp, \"while parsing this `match` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Unsafe) {\n             let sp = self.prev_token.span;\n-            self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided)).map_err(\n+            self.parse_expr_block(None, lo, BlockCheckMode::Unsafe(ast::UserProvided)).map_err(\n                 |mut err| {\n                     err.span_label(sp, \"while parsing this `unsafe` expression\");\n                     err\n@@ -1364,17 +1364,17 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(kw::Try)?;\n             self.parse_try_block(lo)\n         } else if self.eat_keyword(kw::Return) {\n-            self.parse_return_expr()\n+            self.parse_expr_return()\n         } else if self.eat_keyword(kw::Continue) {\n-            self.parse_continue_expr(lo)\n+            self.parse_expr_continue(lo)\n         } else if self.eat_keyword(kw::Break) {\n-            self.parse_break_expr()\n+            self.parse_expr_break()\n         } else if self.eat_keyword(kw::Yield) {\n-            self.parse_yield_expr()\n+            self.parse_expr_yield()\n         } else if self.is_do_yeet() {\n-            self.parse_yeet_expr()\n+            self.parse_expr_yeet()\n         } else if self.check_keyword(kw::Let) {\n-            self.parse_let_expr()\n+            self.parse_expr_let()\n         } else if self.eat_keyword(kw::Underscore) {\n             Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore))\n         } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n@@ -1397,19 +1397,19 @@ impl<'a> Parser<'a> {\n                     // Check for `async {` and `async move {`.\n                     self.parse_async_block()\n                 } else {\n-                    self.parse_closure_expr()\n+                    self.parse_expr_closure()\n                 }\n             } else if self.eat_keyword(kw::Await) {\n                 self.recover_incorrect_await_syntax(lo, self.prev_token.span)\n             } else {\n-                self.parse_lit_expr()\n+                self.parse_expr_lit()\n             }\n         } else {\n-            self.parse_lit_expr()\n+            self.parse_expr_lit()\n         }\n     }\n \n-    fn parse_lit_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_lit(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         match self.parse_opt_token_lit() {\n             Some((token_lit, _)) => {\n@@ -1420,7 +1420,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_tuple_parens_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_tuple_parens(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n         let (es, trailing_comma) = match self.parse_seq_to_end(\n@@ -1444,7 +1444,7 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n-    fn parse_array_or_repeat_expr(&mut self, close_delim: Delimiter) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_array_or_repeat(&mut self, close_delim: Delimiter) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.bump(); // `[` or other open delim\n \n@@ -1457,7 +1457,7 @@ impl<'a> Parser<'a> {\n             let first_expr = self.parse_expr()?;\n             if self.eat(&token::Semi) {\n                 // Repeating array syntax: `[ 0; 512 ]`\n-                let count = self.parse_anon_const_expr()?;\n+                let count = self.parse_expr_anon_const()?;\n                 self.expect(close)?;\n                 ExprKind::Repeat(first_expr, count)\n             } else if self.eat(&token::Comma) {\n@@ -1476,7 +1476,7 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n-    fn parse_path_start_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_path_start(&mut self) -> PResult<'a, P<Expr>> {\n         let (qself, path) = if self.eat_lt() {\n             let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n             (Some(qself), path)\n@@ -1513,7 +1513,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n-    fn parse_labeled_expr(\n+    fn parse_expr_labeled(\n         &mut self,\n         label_: Label,\n         mut consume_colon: bool,\n@@ -1522,15 +1522,15 @@ impl<'a> Parser<'a> {\n         let label = Some(label_);\n         let ate_colon = self.eat(&token::Colon);\n         let expr = if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(label, lo)\n+            self.parse_expr_while(label, lo)\n         } else if self.eat_keyword(kw::For) {\n-            self.parse_for_expr(label, lo)\n+            self.parse_expr_for(label, lo)\n         } else if self.eat_keyword(kw::Loop) {\n-            self.parse_loop_expr(label, lo)\n+            self.parse_expr_loop(label, lo)\n         } else if self.check_noexpect(&token::OpenDelim(Delimiter::Brace))\n             || self.token.is_whole_block()\n         {\n-            self.parse_block_expr(label, lo, BlockCheckMode::Default)\n+            self.parse_expr_block(label, lo, BlockCheckMode::Default)\n         } else if !ate_colon\n             && self.may_recover()\n             && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n@@ -1670,15 +1670,15 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"return\" expr?`.\n-    fn parse_return_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_return(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"do\" \"yeet\" expr?`.\n-    fn parse_yeet_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_yeet(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n@@ -1700,13 +1700,13 @@ impl<'a> Parser<'a> {\n     /// `break 'lbl: loop {}`); a labeled break with an unlabeled loop as its value\n     /// expression only gets a warning for compatibility reasons; and a labeled break\n     /// with a labeled loop does not even get a warning because there is no ambiguity.\n-    fn parse_break_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_break(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let mut label = self.eat_label();\n         let kind = if self.token == token::Colon && let Some(label) = label.take() {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n-            let lexpr = self.parse_labeled_expr(label, true)?;\n+            let lexpr = self.parse_expr_labeled(label, true)?;\n             self.sess.emit_err(errors::LabeledLoopInBreak {\n                 span: lexpr.span,\n                 sub: errors::WrapExpressionInParentheses {\n@@ -1759,7 +1759,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"continue\" label?`.\n-    fn parse_continue_expr(&mut self, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_continue(&mut self, lo: Span) -> PResult<'a, P<Expr>> {\n         let mut label = self.eat_label();\n \n         // Recover `continue label` -> `continue 'label`\n@@ -1776,7 +1776,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"yield\" expr?`.\n-    fn parse_yield_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_yield(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Yield(self.parse_expr_opt()?);\n         let span = lo.to(self.prev_token.span);\n@@ -1993,7 +1993,7 @@ impl<'a> Parser<'a> {\n     /// expression.\n     fn maybe_suggest_brackets_instead_of_braces(&mut self, lo: Span) -> Option<P<Expr>> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n-        match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n+        match snapshot.parse_expr_array_or_repeat(Delimiter::Brace) {\n             Ok(arr) => {\n                 self.sess.emit_err(errors::ArrayBracketsInsteadOfSpaces {\n                     span: arr.span,\n@@ -2056,7 +2056,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block or unsafe block.\n-    pub(super) fn parse_block_expr(\n+    pub(super) fn parse_expr_block(\n         &mut self,\n         opt_label: Option<Label>,\n         lo: Span,\n@@ -2086,7 +2086,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a closure expression (e.g., `move |args| expr`).\n-    fn parse_closure_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_closure(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         let binder = if self.check_keyword(kw::For) {\n@@ -2123,7 +2123,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 // If an explicit return type is given, require a block to appear (RFC 968).\n                 let body_lo = self.token.span;\n-                self.parse_block_expr(None, body_lo, BlockCheckMode::Default)?\n+                self.parse_expr_block(None, body_lo, BlockCheckMode::Default)?\n             }\n         };\n \n@@ -2236,9 +2236,9 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `if` expression (`if` token already eaten).\n-    fn parse_if_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_if(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n-        let cond = self.parse_cond_expr()?;\n+        let cond = self.parse_expr_cond()?;\n         self.parse_if_after_cond(lo, cond)\n     }\n \n@@ -2316,12 +2316,12 @@ impl<'a> Parser<'a> {\n             self.error_on_if_block_attrs(lo, false, block.span, attrs);\n             block\n         };\n-        let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n+        let els = if self.eat_keyword(kw::Else) { Some(self.parse_expr_else()?) } else { None };\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els)))\n     }\n \n     /// Parses the condition of a `if` or `while` expression.\n-    fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_cond(&mut self) -> PResult<'a, P<Expr>> {\n         let cond =\n             self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL | Restrictions::ALLOW_LET, None)?;\n \n@@ -2334,7 +2334,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `let $pat = $expr` pseudo-expression.\n-    fn parse_let_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_let(&mut self) -> PResult<'a, P<Expr>> {\n         // This is a *approximate* heuristic that detects if `let` chains are\n         // being parsed in the right position. It's approximate because it\n         // doesn't deny all invalid `let` expressions, just completely wrong usages.\n@@ -2364,19 +2364,19 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Eq)?;\n         }\n         let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n-            this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n+            this.parse_expr_assoc_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         })?;\n         let span = lo.to(expr.span);\n         self.sess.gated_spans.gate(sym::let_chains, span);\n         Ok(self.mk_expr(span, ExprKind::Let(pat, expr, span)))\n     }\n \n     /// Parses an `else { ... }` expression (`else` token already eaten).\n-    fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_else(&mut self) -> PResult<'a, P<Expr>> {\n         let else_span = self.prev_token.span; // `else`\n         let attrs = self.parse_outer_attributes()?; // For recovery.\n         let expr = if self.eat_keyword(kw::If) {\n-            self.parse_if_expr()?\n+            self.parse_expr_if()?\n         } else if self.check(&TokenKind::OpenDelim(Delimiter::Brace)) {\n             self.parse_simple_block()?\n         } else {\n@@ -2450,7 +2450,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten).\n-    fn parse_for_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_for(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         // Record whether we are about to parse `for (`.\n         // This is used below for recovery in case of `for ( $stuff ) $block`\n         // in which case we will suggest `for $stuff $block`.\n@@ -2508,8 +2508,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n-    fn parse_while_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let cond = self.parse_cond_expr().map_err(|mut err| {\n+    fn parse_expr_while(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let cond = self.parse_expr_cond().map_err(|mut err| {\n             err.span_label(lo, \"while parsing the condition of this `while` expression\");\n             err\n         })?;\n@@ -2526,7 +2526,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `loop { ... }` (`loop` token already eaten).\n-    fn parse_loop_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_loop(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         let loop_span = self.prev_token.span;\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         Ok(self.mk_expr_with_attrs(\n@@ -2544,7 +2544,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n-    fn parse_match_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_match(&mut self) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_token.span;\n         let lo = self.prev_token.span;\n         let scrutinee = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n@@ -2914,7 +2914,7 @@ impl<'a> Parser<'a> {\n             if let Err(err) = self.expect(&token::OpenDelim(Delimiter::Brace)) {\n                 return Some(Err(err));\n             }\n-            let expr = self.parse_struct_expr(qself.clone(), path.clone(), true);\n+            let expr = self.parse_expr_struct(qself.clone(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n                 self.sess.emit_err(errors::StructLiteralNotAllowedHere {\n@@ -3043,7 +3043,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Precondition: already parsed the '{'.\n-    pub(super) fn parse_struct_expr(\n+    pub(super) fn parse_expr_struct(\n         &mut self,\n         qself: Option<P<ast::QSelf>>,\n         pth: ast::Path,"}, {"sha": "9d9ae154ad42ee10f96f278990b6f732d6fcd704", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -1331,7 +1331,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let disr_expr =\n-                    if this.eat(&token::Eq) { Some(this.parse_anon_const_expr()?) } else { None };\n+                    if this.eat(&token::Eq) { Some(this.parse_expr_anon_const()?) } else { None };\n \n                 let vr = ast::Variant {\n                     ident,\n@@ -1722,7 +1722,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.token.kind == token::Eq {\n             self.bump();\n-            let const_expr = self.parse_anon_const_expr()?;\n+            let const_expr = self.parse_expr_anon_const()?;\n             let sp = ty.span.shrink_to_hi().to(const_expr.value.span);\n             self.struct_span_err(sp, \"default values on `struct` fields aren't supported\")\n                 .span_suggestion("}, {"sha": "b50d2984a4ec03ab08c99af2b598a494fa54bed8", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -653,7 +653,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_const_arg(&mut self) -> PResult<'a, AnonConst> {\n         // Parse const argument.\n         let value = if let token::OpenDelim(Delimiter::Brace) = self.token.kind {\n-            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default)?\n+            self.parse_expr_block(None, self.token.span, BlockCheckMode::Default)?\n         } else {\n             self.handle_unambiguous_unbraced_const_arg()?\n         };"}, {"sha": "92a22ffc2b07bffcd452e2cfaa276ba31b962ce0", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -146,14 +146,14 @@ impl<'a> Parser<'a> {\n             }\n \n             let expr = if this.eat(&token::OpenDelim(Delimiter::Brace)) {\n-                this.parse_struct_expr(None, path, true)?\n+                this.parse_expr_struct(None, path, true)?\n             } else {\n                 let hi = this.prev_token.span;\n                 this.mk_expr(lo.to(hi), ExprKind::Path(None, path))\n             };\n \n             let expr = this.with_res(Restrictions::STMT_EXPR, |this| {\n-                this.parse_dot_or_call_expr_with(expr, lo, attrs)\n+                this.parse_expr_dot_or_call_with(expr, lo, attrs)\n             })?;\n             // `DUMMY_SP` will get overwritten later in this function\n             Ok((this.mk_stmt(rustc_span::DUMMY_SP, StmtKind::Expr(expr)), TrailingToken::None))\n@@ -163,7 +163,7 @@ impl<'a> Parser<'a> {\n             // Perform this outside of the `collect_tokens_trailing_token` closure,\n             // since our outer attributes do not apply to this part of the expression\n             let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n-                this.parse_assoc_expr_with(\n+                this.parse_expr_assoc_with(\n                     0,\n                     LhsExpr::AlreadyParsed { expr, starts_statement: true },\n                 )\n@@ -199,8 +199,8 @@ impl<'a> Parser<'a> {\n             // Since none of the above applied, this is an expression statement macro.\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac));\n             let e = self.maybe_recover_from_bad_qpath(e)?;\n-            let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-            let e = self.parse_assoc_expr_with(\n+            let e = self.parse_expr_dot_or_call_with(e, lo, attrs)?;\n+            let e = self.parse_expr_assoc_with(\n                 0,\n                 LhsExpr::AlreadyParsed { expr: e, starts_statement: false },\n             )?;"}, {"sha": "6fe4da71f6b13398f18fe7fb2d12fd62d9d06ec7", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -433,7 +433,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let ty = if self.eat(&token::Semi) {\n-            let mut length = self.parse_anon_const_expr()?;\n+            let mut length = self.parse_expr_anon_const()?;\n             if let Err(e) = self.expect(&token::CloseDelim(Delimiter::Bracket)) {\n                 // Try to recover from `X<Y, ...>` when `X::<Y, ...>` works\n                 self.check_mistyped_turbofish_with_multiple_type_params(e, &mut length.value)?;\n@@ -494,7 +494,7 @@ impl<'a> Parser<'a> {\n     // To avoid ambiguity, the type is surrounded by parentheses.\n     fn parse_typeof_ty(&mut self) -> PResult<'a, TyKind> {\n         self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n-        let expr = self.parse_anon_const_expr()?;\n+        let expr = self.parse_expr_anon_const()?;\n         self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n         Ok(TyKind::Typeof(expr))\n     }"}, {"sha": "df5c8f53ec1c5ae1566d2f90a11a7a9011853346", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -475,7 +475,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n             | hir::ExprKind::InlineAsm(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::Type(..)\n-            | hir::ExprKind::Err\n+            | hir::ExprKind::Err(_)\n             | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n             | hir::ExprKind::Path(hir::QPath::LangItem(..)) => {\n                 intravisit::walk_expr(self, expr);\n@@ -1129,7 +1129,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Lit(..)\n             | hir::ExprKind::ConstBlock(..)\n-            | hir::ExprKind::Err\n+            | hir::ExprKind::Err(_)\n             | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n             | hir::ExprKind::Path(hir::QPath::LangItem(..)) => succ,\n \n@@ -1427,7 +1427,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n         | hir::ExprKind::Yield(..)\n         | hir::ExprKind::Box(..)\n         | hir::ExprKind::Type(..)\n-        | hir::ExprKind::Err => {}\n+        | hir::ExprKind::Err(_) => {}\n     }\n }\n "}, {"sha": "c5b5cf7f5a963ffa70ede4bd6f5064a1348f98ce", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -219,7 +219,7 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n                 hir::intravisit::walk_expr(self, expr);\n             }\n \n-            ExprKind::Err => {\n+            ExprKind::Err(_) => {\n                 self.items.push((ItemKind::Err, span));\n             }\n         }"}, {"sha": "873cd33f6a4f288698a11158b11b8d83b1474623", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -2149,3 +2149,17 @@ where\n         Hash::hash(&len, hasher);\n     }\n }\n+\n+/// Useful type to use with `Result<>` indicate that an error has already\n+/// been reported to the user, so no need to continue checking.\n+#[derive(Clone, Copy, Debug, Encodable, Decodable, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(HashStable_Generic)]\n+pub struct ErrorGuaranteed(());\n+\n+impl ErrorGuaranteed {\n+    /// To be used only if you really know what you are doing... ideally, we would find a way to\n+    /// eliminate all calls to this method.\n+    pub fn unchecked_claim_error_was_emitted() -> Self {\n+        ErrorGuaranteed(())\n+    }\n+}"}, {"sha": "fb579e4ff772adf315b5adc8658120743f370ddb", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -740,6 +740,7 @@ symbols! {\n         frem_fast,\n         from,\n         from_desugaring,\n+        from_fn,\n         from_iter,\n         from_method,\n         from_output,"}, {"sha": "d7d93377cf164e87d9db98d7888ddc82cf448dfb", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -21,12 +21,14 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         | ty::Float(_)\n         | ty::FnDef(..)\n         | ty::FnPtr(_)\n-        | ty::Str\n         | ty::Error(_)\n         | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n         | ty::Never\n         | ty::Char => Ok(vec![]),\n \n+        // Treat this like `struct str([u8]);`\n+        ty::Str => Ok(vec![tcx.mk_slice(tcx.types.u8)]),\n+\n         ty::Dynamic(..)\n         | ty::Param(..)\n         | ty::Foreign(..)"}, {"sha": "66d74fd05a67f908cd005f8ab8f382a02e0a097a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -3107,6 +3107,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 self.tcx.def_span(def_id),\n                                 \"required because it's used within this closure\",\n                             ),\n+                            ty::Str => err.note(\"`str` is considered to contain a `[u8]` slice for auto trait purposes\"),\n                             _ => err.note(&msg),\n                         };\n                     }"}, {"sha": "01c1ad3a4cef3890458cf7cc2cde2d8af2c7f5a1", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -2300,12 +2300,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Float(_)\n             | ty::FnDef(..)\n             | ty::FnPtr(_)\n-            | ty::Str\n             | ty::Error(_)\n             | ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Never\n             | ty::Char => ty::Binder::dummy(Vec::new()),\n \n+            // Treat this like `struct str([u8]);`\n+            ty::Str => ty::Binder::dummy(vec![self.tcx().mk_slice(self.tcx().types.u8)]),\n+\n             ty::Placeholder(..)\n             | ty::Dynamic(..)\n             | ty::Param(..)"}, {"sha": "d4a12509b1cf2127c059958279b24e7907d68d5b", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -944,65 +944,72 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             return;\n         }\n \n-        if target_cap < self.capacity() {\n-            // There are three cases of interest:\n-            //   All elements are out of desired bounds\n-            //   Elements are contiguous, and head is out of desired bounds\n-            //   Elements are discontiguous, and tail is out of desired bounds\n+        // There are three cases of interest:\n+        //   All elements are out of desired bounds\n+        //   Elements are contiguous, and tail is out of desired bounds\n+        //   Elements are discontiguous\n+        //\n+        // At all other times, element positions are unaffected.\n+\n+        // `head` and `len` are at most `isize::MAX` and `target_cap < self.capacity()`, so nothing can\n+        // overflow.\n+        let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n+\n+        if self.len == 0 {\n+            self.head = 0;\n+        } else if self.head >= target_cap && tail_outside {\n+            // Head and tail are both out of bounds, so copy all of them to the front.\n             //\n-            // At all other times, element positions are unaffected.\n+            //  H := head\n+            //  L := last element\n+            //                    H           L\n+            //   [. . . . . . . . o o o o o o o . ]\n+            //    H           L\n+            //   [o o o o o o o . ]\n+            unsafe {\n+                // nonoverlapping because `self.head >= target_cap >= self.len`.\n+                self.copy_nonoverlapping(self.head, 0, self.len);\n+            }\n+            self.head = 0;\n+        } else if self.head < target_cap && tail_outside {\n+            // Head is in bounds, tail is out of bounds.\n+            // Copy the overflowing part to the beginning of the\n+            // buffer. This won't overlap because `target_cap >= self.len`.\n             //\n-            // Indicates that elements at the head should be moved.\n-\n-            let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n-            // Move elements from out of desired bounds (positions after target_cap)\n-            if self.len == 0 {\n-                self.head = 0;\n-            } else if self.head >= target_cap && tail_outside {\n-                //  H := head\n-                //  L := last element\n-                //                    H           L\n-                //   [. . . . . . . . o o o o o o o . ]\n-                //    H           L\n-                //   [o o o o o o o . ]\n-                unsafe {\n-                    // nonoverlapping because self.head >= target_cap >= self.len\n-                    self.copy_nonoverlapping(self.head, 0, self.len);\n-                }\n-                self.head = 0;\n-            } else if self.head < target_cap && tail_outside {\n-                //  H := head\n-                //  L := last element\n-                //          H           L\n-                //   [. . . o o o o o o o . . . . . . ]\n-                //      L   H\n-                //   [o o . o o o o o ]\n-                let len = self.head + self.len - target_cap;\n-                unsafe {\n-                    self.copy_nonoverlapping(target_cap, 0, len);\n-                }\n-            } else if self.head >= target_cap {\n-                //  H := head\n-                //  L := last element\n-                //            L                   H\n-                //   [o o o o o . . . . . . . . . o o ]\n-                //            L   H\n-                //   [o o o o o . o o ]\n-                let len = self.capacity() - self.head;\n-                let new_head = target_cap - len;\n-                unsafe {\n-                    // can't use copy_nonoverlapping here for the same reason\n-                    // as in `handle_capacity_increase()`\n-                    self.copy(self.head, new_head, len);\n-                }\n-                self.head = new_head;\n+            //  H := head\n+            //  L := last element\n+            //          H           L\n+            //   [. . . o o o o o o o . . . . . . ]\n+            //      L   H\n+            //   [o o . o o o o o ]\n+            let len = self.head + self.len - target_cap;\n+            unsafe {\n+                self.copy_nonoverlapping(target_cap, 0, len);\n             }\n-\n-            self.buf.shrink_to_fit(target_cap);\n-\n-            debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n-            debug_assert!(self.len <= self.capacity());\n+        } else if !self.is_contiguous() {\n+            // The head slice is at least partially out of bounds, tail is in bounds.\n+            // Copy the head backwards so it lines up with the target capacity.\n+            // This won't overlap because `target_cap >= self.len`.\n+            //\n+            //  H := head\n+            //  L := last element\n+            //            L                   H\n+            //   [o o o o o . . . . . . . . . o o ]\n+            //            L   H\n+            //   [o o o o o . o o ]\n+            let head_len = self.capacity() - self.head;\n+            let new_head = target_cap - head_len;\n+            unsafe {\n+                // can't use `copy_nonoverlapping()` here because the new and old\n+                // regions for the head might overlap.\n+                self.copy(self.head, new_head, head_len);\n+            }\n+            self.head = new_head;\n         }\n+        self.buf.shrink_to_fit(target_cap);\n+\n+        debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n+        debug_assert!(self.len <= self.capacity());\n     }\n \n     /// Shortens the deque, keeping the first `len` elements and dropping"}, {"sha": "205a8ff3c19a8cf3242fd97efd23756eb753ae20", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -748,6 +748,48 @@ fn test_drain() {\n     }\n }\n \n+#[test]\n+fn issue_108453() {\n+    let mut deque = VecDeque::with_capacity(10);\n+\n+    deque.push_back(1u8);\n+    deque.push_back(2);\n+    deque.push_back(3);\n+\n+    deque.push_front(10);\n+    deque.push_front(9);\n+\n+    deque.shrink_to(9);\n+\n+    assert_eq!(deque.into_iter().collect::<Vec<_>>(), vec![9, 10, 1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_shrink_to() {\n+    // test deques with capacity 16 with all possible head positions, lengths and target capacities.\n+    let cap = 16;\n+\n+    for len in 0..cap {\n+        for head in 0..cap {\n+            let expected = (1..=len).collect::<VecDeque<_>>();\n+\n+            for target_cap in len..cap {\n+                let mut deque = VecDeque::with_capacity(cap);\n+                // currently, `with_capacity` always allocates the exact capacity if it's greater than 8.\n+                assert_eq!(deque.capacity(), cap);\n+\n+                // we can let the head point anywhere in the buffer since the deque is empty.\n+                deque.head = head;\n+                deque.extend(1..=len);\n+\n+                deque.shrink_to(target_cap);\n+\n+                assert_eq!(deque, expected);\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_shrink_to_fit() {\n     // This test checks that every single combination of head and tail position,"}, {"sha": "805354be089a5d917faac0991518e26da4516757", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -542,7 +542,7 @@ pub trait Into<T>: Sized {\n #[const_trait]\n pub trait From<T>: Sized {\n     /// Converts to this type from the input type.\n-    #[lang = \"from\"]\n+    #[rustc_diagnostic_item = \"from_fn\"]\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from(value: T) -> Self;"}, {"sha": "aec15212d7ff7fd4d352b0350f06fd2144e1c2c1", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -3,21 +3,26 @@ macro_rules! int_impl {\n         Self = $SelfT:ty,\n         ActualT = $ActualT:ident,\n         UnsignedT = $UnsignedT:ty,\n-        BITS = $BITS:expr,\n-        BITS_MINUS_ONE = $BITS_MINUS_ONE:expr,\n-        Min = $Min:expr,\n-        Max = $Max:expr,\n-        rot = $rot:expr,\n-        rot_op = $rot_op:expr,\n-        rot_result = $rot_result:expr,\n-        swap_op = $swap_op:expr,\n-        swapped = $swapped:expr,\n-        reversed = $reversed:expr,\n-        le_bytes = $le_bytes:expr,\n-        be_bytes = $be_bytes:expr,\n+\n+        // There are all for use *only* in doc comments.\n+        // As such, they're all passed as literals -- passing them as a string\n+        // literal is fine if they need to be multiple code tokens.\n+        // In non-comments, use the associated constants rather than these.\n+        BITS = $BITS:literal,\n+        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n+        Min = $Min:literal,\n+        Max = $Max:literal,\n+        rot = $rot:literal,\n+        rot_op = $rot_op:literal,\n+        rot_result = $rot_result:literal,\n+        swap_op = $swap_op:literal,\n+        swapped = $swapped:literal,\n+        reversed = $reversed:literal,\n+        le_bytes = $le_bytes:literal,\n+        be_bytes = $be_bytes:literal,\n         to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n         from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n-        bound_condition = $bound_condition:expr,\n+        bound_condition = $bound_condition:literal,\n     ) => {\n         /// The smallest value that can be represented by this integer type\n         #[doc = concat!(\"(&minus;2<sup>\", $BITS_MINUS_ONE, \"</sup>\", $bound_condition, \").\")]\n@@ -30,7 +35,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\")]\n         /// ```\n         #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n-        pub const MIN: Self = !0 ^ ((!0 as $UnsignedT) >> 1) as Self;\n+        pub const MIN: Self = !Self::MAX;\n \n         /// The largest value that can be represented by this integer type\n         #[doc = concat!(\"(2<sup>\", $BITS_MINUS_ONE, \"</sup> &minus; 1\", $bound_condition, \").\")]\n@@ -43,7 +48,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\")]\n         /// ```\n         #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n-        pub const MAX: Self = !Self::MIN;\n+        pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self;\n \n         /// The size of this integer type in bits.\n         ///\n@@ -53,7 +58,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n         /// ```\n         #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n-        pub const BITS: u32 = $BITS;\n+        pub const BITS: u32 = <$UnsignedT>::BITS;\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n@@ -1380,7 +1385,7 @@ macro_rules! int_impl {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                self.unchecked_shl(rhs & ($BITS - 1))\n+                self.unchecked_shl(rhs & (Self::BITS - 1))\n             }\n         }\n \n@@ -1410,7 +1415,7 @@ macro_rules! int_impl {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                self.unchecked_shr(rhs & ($BITS - 1))\n+                self.unchecked_shr(rhs & (Self::BITS - 1))\n             }\n         }\n \n@@ -1916,7 +1921,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n         }\n \n         /// Shifts self right by `rhs` bits.\n@@ -1939,7 +1944,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n         }\n \n         /// Computes the absolute value of `self`."}, {"sha": "932038a0b012a1a86e82781c4870346fcb43b7af", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -4,19 +4,24 @@ macro_rules! uint_impl {\n         ActualT = $ActualT:ident,\n         SignedT = $SignedT:ident,\n         NonZeroT = $NonZeroT:ident,\n-        BITS = $BITS:expr,\n-        MAX = $MaxV:expr,\n-        rot = $rot:expr,\n-        rot_op = $rot_op:expr,\n-        rot_result = $rot_result:expr,\n-        swap_op = $swap_op:expr,\n-        swapped = $swapped:expr,\n-        reversed = $reversed:expr,\n-        le_bytes = $le_bytes:expr,\n-        be_bytes = $be_bytes:expr,\n+\n+        // There are all for use *only* in doc comments.\n+        // As such, they're all passed as literals -- passing them as a string\n+        // literal is fine if they need to be multiple code tokens.\n+        // In non-comments, use the associated constants rather than these.\n+        BITS = $BITS:literal,\n+        MAX = $MaxV:literal,\n+        rot = $rot:literal,\n+        rot_op = $rot_op:literal,\n+        rot_result = $rot_result:literal,\n+        swap_op = $swap_op:literal,\n+        swapped = $swapped:literal,\n+        reversed = $reversed:literal,\n+        le_bytes = $le_bytes:literal,\n+        be_bytes = $be_bytes:literal,\n         to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n         from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n-        bound_condition = $bound_condition:expr,\n+        bound_condition = $bound_condition:literal,\n     ) => {\n         /// The smallest value that can be represented by this integer type.\n         ///\n@@ -51,7 +56,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n         /// ```\n         #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n-        pub const BITS: u32 = $BITS;\n+        pub const BITS: u32 = Self::MAX.count_ones();\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n@@ -1403,7 +1408,7 @@ macro_rules! uint_impl {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                self.unchecked_shl(rhs & ($BITS - 1))\n+                self.unchecked_shl(rhs & (Self::BITS - 1))\n             }\n         }\n \n@@ -1436,7 +1441,7 @@ macro_rules! uint_impl {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                self.unchecked_shr(rhs & ($BITS - 1))\n+                self.unchecked_shr(rhs & (Self::BITS - 1))\n             }\n         }\n \n@@ -1860,7 +1865,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline(always)]\n         pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n         }\n \n         /// Shifts self right by `rhs` bits.\n@@ -1885,7 +1890,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline(always)]\n         pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n         }\n \n         /// Raises self to the power of `exp`, using exponentiation by squaring."}, {"sha": "0e8f0cfc5185dcaa4491ecc5d7bf5ecac08c0ec0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -1661,7 +1661,7 @@ pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> T\n         }\n         TyKind::BareFn(barefn) => BareFunction(Box::new(clean_bare_fn_ty(barefn, cx))),\n         // Rustdoc handles `TyKind::Err`s by turning them into `Type::Infer`s.\n-        TyKind::Infer | TyKind::Err | TyKind::Typeof(..) => Infer,\n+        TyKind::Infer | TyKind::Err(_) | TyKind::Typeof(..) => Infer,\n     }\n }\n "}, {"sha": "644604a2e3f8475c4f48d4315aab909a53f3c82f", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -1022,7 +1022,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                     ))\n                     .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n             ),\n-            TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::TraitObject(..) | TyKind::Err => {\n+            TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::TraitObject(..) | TyKind::Err(_) => {\n                 Position::ReborrowStable(precedence)\n             },\n         };\n@@ -1038,7 +1038,7 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n             if self.0\n                 || matches!(\n                     ty.kind,\n-                    TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(_) | TyKind::Err\n+                    TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(_) | TyKind::Err(_)\n                 )\n             {\n                 self.0 = true;"}, {"sha": "d7e000473124eadb1c74c0c55836687a26b7d0b7", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -224,7 +224,7 @@ fn never_loop_expr(expr: &Expr<'_>, ignore_ids: &mut Vec<HirId>, main_loop_id: H\n         | ExprKind::Path(_)\n         | ExprKind::ConstBlock(_)\n         | ExprKind::Lit(_)\n-        | ExprKind::Err => NeverLoopResult::Otherwise,\n+        | ExprKind::Err(_) => NeverLoopResult::Otherwise,\n     }\n }\n "}, {"sha": "b33a247817292d753689db1fa6a9753582a926c3", "filename": "src/tools/clippy/clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SigDropHelper<'a, 'tcx> {\n             ExprKind::ConstBlock(_) |\n             ExprKind::Continue(_) |\n             ExprKind::DropTemps(_) |\n-            ExprKind::Err |\n+            ExprKind::Err(_) |\n             ExprKind::InlineAsm(_) |\n             ExprKind::Let(_) |\n             ExprKind::Lit(_) |"}, {"sha": "d3de9699fe9d9c8dc044d835b436071a77858503", "filename": "src/tools/clippy/clippy_lints/src/operators/cmp_owned.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -49,10 +49,10 @@ fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool)\n             (arg, arg.span)\n         },\n         ExprKind::Call(path, [arg])\n-            if path_def_id(cx, path).map_or(false, |id| {\n-                if match_def_path(cx, id, &paths::FROM_STR_METHOD) {\n+            if path_def_id(cx, path).map_or(false, |did| {\n+                if match_def_path(cx, did, &paths::FROM_STR_METHOD) {\n                     true\n-                } else if cx.tcx.lang_items().from_fn() == Some(id) {\n+                } else if cx.tcx.is_diagnostic_item(sym::from_fn, did) {\n                     !is_copy(cx, typeck.expr_ty(expr))\n                 } else {\n                     false"}, {"sha": "6e802794f5aa341c482e1dbe2ca8795d524b1cc8", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_owned_empty_strings.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -54,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryOwnedEmptyStrings {\n                         );\n                 } else {\n                     if_chain! {\n-                        if Some(fun_def_id) == cx.tcx.lang_items().from_fn();\n+                        if cx.tcx.is_diagnostic_item(sym::from_fn, fun_def_id);\n                         if let [.., last_arg] = args;\n                         if let ExprKind::Lit(spanned) = &last_arg.kind;\n                         if let LitKind::Str(symbol, _) = spanned.node;"}, {"sha": "fede625f72a89e690d5adbdbbc0b95313bb3a0d8", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -161,7 +161,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         }\n \n                         if_chain! {\n-                            if Some(def_id) == cx.tcx.lang_items().from_fn();\n+                            if cx.tcx.is_diagnostic_item(sym::from_fn, def_id);\n                             if same_type_and_consts(a, b);\n \n                             then {"}, {"sha": "c37e5bb6716e984066c57341be81b826eb61a28b", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -588,7 +588,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                     },\n                 }\n             },\n-            ExprKind::Err => kind!(\"Err\"),\n+            ExprKind::Err(_) => kind!(\"Err\"),\n             ExprKind::DropTemps(expr) => {\n                 bind!(self, expr);\n                 kind!(\"DropTemps({expr})\");"}, {"sha": "ee2f816f181ba9c71fd4eb781c24ef08e0014da8", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -193,7 +193,7 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                 | ExprKind::Ret(_)\n                 | ExprKind::InlineAsm(_)\n                 | ExprKind::Yield(..)\n-                | ExprKind::Err => {\n+                | ExprKind::Err(_) => {\n                     self.eagerness = ForceNoChange;\n                     return;\n                 },"}, {"sha": "0603755f8a94174bce12b9190e04f2e4ef54fa67", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -714,7 +714,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 }\n                 self.hash_pat(pat);\n             },\n-            ExprKind::Err => {},\n+            ExprKind::Err(_) => {},\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);\n             },\n@@ -986,7 +986,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             TyKind::Typeof(anon_const) => {\n                 self.hash_body(anon_const.body);\n             },\n-            TyKind::Err | TyKind::Infer | TyKind::Never => {},\n+            TyKind::Err(_) | TyKind::Infer | TyKind::Never => {},\n         }\n     }\n "}, {"sha": "11ca81cfe6c1899b4392ac9041696071d3195c6d", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -157,7 +157,7 @@ impl<'a> Sugg<'a> {\n             | hir::ExprKind::Ret(..)\n             | hir::ExprKind::Struct(..)\n             | hir::ExprKind::Tup(..)\n-            | hir::ExprKind::Err => Sugg::NonParen(get_snippet(expr.span)),\n+            | hir::ExprKind::Err(_) => Sugg::NonParen(get_snippet(expr.span)),\n             hir::ExprKind::DropTemps(inner) => Self::hir_from_snippet(inner, get_snippet),\n             hir::ExprKind::Assign(lhs, rhs, _) => {\n                 Sugg::BinOp(AssocOp::Assign, get_snippet(lhs.span), get_snippet(rhs.span))"}, {"sha": "d27a20bd4dfa71cc9f80e092b0f6291ac9e2edaf", "filename": "src/tools/clippy/clippy_utils/src/visitors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -665,7 +665,7 @@ pub fn for_each_unconsumed_temporary<'tcx, B>(\n             | ExprKind::Path(_)\n             | ExprKind::Continue(_)\n             | ExprKind::InlineAsm(_)\n-            | ExprKind::Err => (),\n+            | ExprKind::Err(_) => (),\n         }\n         ControlFlow::Continue(())\n     }"}, {"sha": "76c2e330b2100236b1b8fddd1640ccbb8b7cca97", "filename": "src/tools/error_index_generator/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Ferror_index_generator%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Ferror_index_generator%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2FCargo.toml?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -5,6 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n mdbook = { version = \"0.4\", default-features = false, features = [\"search\"] }\n+rustc_error_codes = { version = \"0.0.0\", path = \"../../../compiler/rustc_error_codes\" }\n \n [[bin]]\n name = \"error_index_generator\""}, {"sha": "f984275b164cc0be8f643903b323662f98331a35", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 16, "deletions": 42, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -2,9 +2,6 @@\n \n extern crate rustc_driver;\n \n-// We use the function we generate from `register_diagnostics!`.\n-use crate::error_codes::error_codes;\n-\n use std::env;\n use std::error::Error;\n use std::fs::{self, File};\n@@ -17,22 +14,6 @@ use std::str::FromStr;\n use mdbook::book::{parse_summary, BookItem, Chapter};\n use mdbook::{Config, MDBook};\n \n-macro_rules! register_diagnostics {\n-    ($($error_code:ident: $message:expr,)+ ; $($undocumented:ident,)* ) => {\n-        pub fn error_codes() -> Vec<(&'static str, Option<&'static str>)> {\n-            let mut errors: Vec<(&str, Option<&str>)> = vec![\n-                $((stringify!($error_code), Some($message)),)+\n-                $((stringify!($undocumented), None),)*\n-            ];\n-            errors.sort();\n-            errors\n-        }\n-    }\n-}\n-\n-#[path = \"../../../compiler/rustc_error_codes/src/error_codes.rs\"]\n-mod error_codes;\n-\n enum OutputFormat {\n     HTML,\n     Markdown,\n@@ -55,11 +36,8 @@ fn render_markdown(output_path: &Path) -> Result<(), Box<dyn Error>> {\n \n     write!(output_file, \"# Rust Compiler Error Index\\n\")?;\n \n-    for (err_code, description) in error_codes().iter() {\n-        match description {\n-            Some(ref desc) => write!(output_file, \"## {}\\n{}\\n\", err_code, desc)?,\n-            None => {}\n-        }\n+    for (err_code, description) in rustc_error_codes::DIAGNOSTICS.iter() {\n+        write!(output_file, \"## {}\\n{}\\n\", err_code, description)?\n     }\n \n     Ok(())\n@@ -105,27 +83,23 @@ This page lists all the error codes emitted by the Rust compiler.\n \"\n     );\n \n-    let err_codes = error_codes();\n+    let err_codes = rustc_error_codes::DIAGNOSTICS;\n     let mut chapters = Vec::with_capacity(err_codes.len());\n \n     for (err_code, explanation) in err_codes.iter() {\n-        if let Some(explanation) = explanation {\n-            introduction.push_str(&format!(\" * [{0}](./{0}.html)\\n\", err_code));\n-\n-            let content = add_rust_attribute_on_codeblock(explanation);\n-            chapters.push(BookItem::Chapter(Chapter {\n-                name: err_code.to_string(),\n-                content: format!(\"# Error code {}\\n\\n{}\\n\", err_code, content),\n-                number: None,\n-                sub_items: Vec::new(),\n-                // We generate it into the `error_codes` folder.\n-                path: Some(PathBuf::from(&format!(\"{}.html\", err_code))),\n-                source_path: None,\n-                parent_names: Vec::new(),\n-            }));\n-        } else {\n-            introduction.push_str(&format!(\" * {}\\n\", err_code));\n-        }\n+        introduction.push_str(&format!(\" * [{0}](./{0}.html)\\n\", err_code));\n+\n+        let content = add_rust_attribute_on_codeblock(explanation);\n+        chapters.push(BookItem::Chapter(Chapter {\n+            name: err_code.to_string(),\n+            content: format!(\"# Error code {}\\n\\n{}\\n\", err_code, content),\n+            number: None,\n+            sub_items: Vec::new(),\n+            // We generate it into the `error_codes` folder.\n+            path: Some(PathBuf::from(&format!(\"{}.html\", err_code))),\n+            source_path: None,\n+            parent_names: Vec::new(),\n+        }));\n     }\n \n     let mut config = Config::from_str(include_str!(\"book_config.toml\"))?;"}, {"sha": "c60caa0d49c6a2383154b326a59b893429fe15e2", "filename": "src/tools/tidy/src/error_codes.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -45,7 +45,7 @@ pub fn check(root_path: &Path, search_paths: &[&Path], verbose: bool, bad: &mut\n     let mut errors = Vec::new();\n \n     // Stage 1: create list\n-    let error_codes = extract_error_codes(root_path, &mut errors, verbose);\n+    let error_codes = extract_error_codes(root_path, &mut errors);\n     println!(\"Found {} error codes\", error_codes.len());\n     println!(\"Highest error code: `{}`\", error_codes.iter().max().unwrap());\n \n@@ -65,18 +65,17 @@ pub fn check(root_path: &Path, search_paths: &[&Path], verbose: bool, bad: &mut\n }\n \n /// Stage 1: Parses a list of error codes from `error_codes.rs`.\n-fn extract_error_codes(root_path: &Path, errors: &mut Vec<String>, verbose: bool) -> Vec<String> {\n+fn extract_error_codes(root_path: &Path, errors: &mut Vec<String>) -> Vec<String> {\n     let path = root_path.join(Path::new(ERROR_CODES_PATH));\n     let file =\n         fs::read_to_string(&path).unwrap_or_else(|e| panic!(\"failed to read `{path:?}`: {e}\"));\n \n     let mut error_codes = Vec::new();\n-    let mut reached_undocumented_codes = false;\n \n     for line in file.lines() {\n         let line = line.trim();\n \n-        if !reached_undocumented_codes && line.starts_with('E') {\n+        if line.starts_with('E') {\n             let split_line = line.split_once(':');\n \n             // Extract the error code from the line, emitting a fatal error if it is not in a correct format.\n@@ -111,23 +110,6 @@ fn extract_error_codes(root_path: &Path, errors: &mut Vec<String>, verbose: bool\n             }\n \n             error_codes.push(err_code);\n-        } else if reached_undocumented_codes && line.starts_with('E') {\n-            let err_code = match line.split_once(',') {\n-                None => line,\n-                Some((err_code, _)) => err_code,\n-            }\n-            .to_string();\n-\n-            verbose_print!(verbose, \"warning: Error code `{}` is undocumented.\", err_code);\n-\n-            if error_codes.contains(&err_code) {\n-                errors.push(format!(\"Found duplicate error code: `{}`\", err_code));\n-            }\n-\n-            error_codes.push(err_code);\n-        } else if line == \";\" {\n-            // Once we reach the undocumented error codes, adapt to different syntax.\n-            reached_undocumented_codes = true;\n         }\n     }\n "}, {"sha": "6a16fdcf2842f77a65d249f4f3788ab46650bf9c", "filename": "tests/ui/auto-traits/str-contains-slice-conceptually.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/tests%2Fui%2Fauto-traits%2Fstr-contains-slice-conceptually.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/tests%2Fui%2Fauto-traits%2Fstr-contains-slice-conceptually.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fstr-contains-slice-conceptually.rs?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -0,0 +1,13 @@\n+#![feature(negative_impls)]\n+#![feature(auto_traits)]\n+\n+auto trait AutoTrait {}\n+\n+impl<T> !AutoTrait for [T] {}\n+\n+fn needs_auto_trait<T: AutoTrait + ?Sized>() {}\n+\n+fn main() {\n+  needs_auto_trait::<str>();\n+  //~^ ERROR the trait bound `[u8]: AutoTrait` is not satisfied in `str`\n+}"}, {"sha": "1cf16cebddd15321a7c940c07cbd19e9c18c98a5", "filename": "tests/ui/auto-traits/str-contains-slice-conceptually.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/tests%2Fui%2Fauto-traits%2Fstr-contains-slice-conceptually.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/tests%2Fui%2Fauto-traits%2Fstr-contains-slice-conceptually.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fstr-contains-slice-conceptually.stderr?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: the trait bound `[u8]: AutoTrait` is not satisfied in `str`\n+  --> $DIR/str-contains-slice-conceptually.rs:11:22\n+   |\n+LL |   needs_auto_trait::<str>();\n+   |                      ^^^ within `str`, the trait `AutoTrait` is not implemented for `[u8]`\n+   |\n+   = note: `str` is considered to contain a `[u8]` slice for auto trait purposes\n+note: required by a bound in `needs_auto_trait`\n+  --> $DIR/str-contains-slice-conceptually.rs:8:24\n+   |\n+LL | fn needs_auto_trait<T: AutoTrait + ?Sized>() {}\n+   |                        ^^^^^^^^^ required by this bound in `needs_auto_trait`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "6d6562dae3b6704fd3a582790272debd9fd88267", "filename": "tests/ui/rfc-2091-track-caller/error-with-main.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4e0cd966062ca67daed20775f4e8a60c28e57df/tests%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4e0cd966062ca67daed20775f4e8a60c28e57df/tests%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2091-track-caller%2Ferror-with-main.stderr?ref=c4e0cd966062ca67daed20775f4e8a60c28e57df", "patch": "@@ -2,7 +2,7 @@ error: `main` function is not allowed to be `#[track_caller]`\n   --> $DIR/error-with-main.rs:1:1\n    |\n LL | #[track_caller]\n-   | ^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^ help: remove this annotation\n LL | fn main() {\n    | --------- `main` function is not allowed to be `#[track_caller]`\n "}]}