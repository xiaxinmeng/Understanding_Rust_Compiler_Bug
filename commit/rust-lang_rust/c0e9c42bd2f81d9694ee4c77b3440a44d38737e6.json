{"sha": "c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZTljNDJiZDJmODFkOTY5NGVlNGM3N2IzNDQwYTQ0ZDM4NzM3ZTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-10-15T03:38:24Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-02T21:14:19Z"}, "message": "thread the context through so that int can be 64 bits on x86_64", "tree": {"sha": "2750c94a7d0b134940962ab7dd18db0b4b4e9ff5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2750c94a7d0b134940962ab7dd18db0b4b4e9ff5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "html_url": "https://github.com/rust-lang/rust/commit/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2521cda1ec5e24cce81e25fcf64281584fcfdb5d", "html_url": "https://github.com/rust-lang/rust/commit/2521cda1ec5e24cce81e25fcf64281584fcfdb5d"}], "stats": {"total": 248, "additions": 149, "deletions": 99}, "files": [{"sha": "9d67aea59d946b5570284d01cf9203f024c5efc5", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "patch": "@@ -1,5 +1,6 @@\n \n import std::str;\n+import driver::session;\n import middle::trans;\n import trans::decl_cdecl_fn;\n import middle::trans_common::{T_f32, T_f64, T_fn, T_bool, T_i1, T_i8, T_i32,\n@@ -32,7 +33,9 @@ type upcalls =\n      call_c_stack_float: ValueRef,\n      rust_personality: ValueRef};\n \n-fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n+fn declare_upcalls(targ_cfg: @session::config,\n+                   _tn: type_names,\n+                   tydesc_type: TypeRef,\n                    llmod: ModuleRef) -> @upcalls {\n     fn decl(llmod: ModuleRef, name: str, tys: [TypeRef], rv: TypeRef) ->\n        ValueRef {\n@@ -44,25 +47,35 @@ fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n     let d = bind decl(llmod, _, _, _);\n     let dv = bind decl(llmod, _, _, T_void());\n \n-    ret @{_fail: dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n+    let int_t = T_int(targ_cfg);\n+    let size_t = T_size_t(targ_cfg);\n+    let opaque_vec_t = T_opaque_vec(targ_cfg);\n+\n+    ret @{_fail: dv(\"fail\", [T_ptr(T_i8()),\n+                             T_ptr(T_i8()),\n+                             size_t]),\n           malloc:\n-              d(\"malloc\", [T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n-          free: dv(\"free\", [T_ptr(T_i8()), T_int()]),\n+              d(\"malloc\", [size_t, T_ptr(tydesc_type)],\n+                T_ptr(T_i8())),\n+          free: dv(\"free\", [T_ptr(T_i8()), int_t]),\n           shared_malloc:\n-              d(\"shared_malloc\", [T_size_t(), T_ptr(tydesc_type)],\n+              d(\"shared_malloc\", [size_t, T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n           shared_free: dv(\"shared_free\", [T_ptr(T_i8())]),\n-          mark: d(\"mark\", [T_ptr(T_i8())], T_int()),\n+          mark: d(\"mark\", [T_ptr(T_i8())], int_t),\n           get_type_desc:\n               d(\"get_type_desc\",\n-                [T_ptr(T_nil()), T_size_t(), T_size_t(), T_size_t(),\n-                 T_ptr(T_ptr(tydesc_type)), T_int()], T_ptr(tydesc_type)),\n+                [T_ptr(T_nil()), size_t,\n+                 size_t, size_t,\n+                 T_ptr(T_ptr(tydesc_type)), int_t],\n+                T_ptr(tydesc_type)),\n           vec_grow:\n-              dv(\"vec_grow\", [T_ptr(T_ptr(T_opaque_vec())), T_int()]),\n+              dv(\"vec_grow\", [T_ptr(T_ptr(opaque_vec_t)),\n+                              int_t]),\n           vec_push:\n               dv(\"vec_push\",\n-                 [T_ptr(T_ptr(T_opaque_vec())), T_ptr(tydesc_type),\n-                  T_ptr(T_i8())]),\n+                [T_ptr(T_ptr(opaque_vec_t)), T_ptr(tydesc_type),\n+                 T_ptr(T_i8())]),\n           cmp_type:\n               dv(\"cmp_type\",\n                  [T_ptr(T_i1()), T_ptr(tydesc_type),\n@@ -72,13 +85,13 @@ fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n               dv(\"log_type\", [T_ptr(tydesc_type), T_ptr(T_i8()), T_i32()]),\n           dynastack_mark: d(\"dynastack_mark\", [], T_ptr(T_i8())),\n           dynastack_alloc:\n-              d(\"dynastack_alloc_2\", [T_size_t(), T_ptr(tydesc_type)],\n+              d(\"dynastack_alloc_2\", [size_t, T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n           dynastack_free: dv(\"dynastack_free\", [T_ptr(T_i8())]),\n           alloc_c_stack: d(\"alloc_c_stack\", [T_size_t()], T_ptr(T_i8())),\n           call_c_stack: d(\"call_c_stack\",\n                               [T_ptr(T_fn([], T_int())), T_ptr(T_i8())],\n-                              T_int()),\n+                              int_t),\n           call_c_stack_i64: d(\"call_c_stack_i64\",\n                               [T_ptr(T_fn([], T_int())), T_ptr(T_i8())],\n                               T_i64()),"}, {"sha": "833864a8e7af680f848f241a61fa9ae6343ee824", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "patch": "@@ -29,6 +29,7 @@ fn add_global(ccx: @crate_ctxt, llval: ValueRef, name: str) -> ValueRef {\n \n fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     let bcx = cx;\n+    let ccx = bcx_ccx(cx);\n     if !type_is_gc_relevant(bcx_tcx(cx), ty) ||\n            ty::type_has_dynamic_size(bcx_tcx(cx), ty) {\n         ret bcx;\n@@ -61,10 +62,12 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n         gc_cx.next_tydesc_num += 1u;\n \n         let lldestindex =\n-            add_global(bcx_ccx(bcx), C_struct([C_int(0), C_uint(number)]),\n+            add_global(bcx_ccx(bcx), C_struct([C_int(ccx, 0),\n+                                               C_uint(ccx, number)]),\n                        \"rust_gc_tydesc_dest_index\");\n         let llsrcindex =\n-            add_global(bcx_ccx(bcx), C_struct([C_int(1), C_uint(number)]),\n+            add_global(bcx_ccx(bcx), C_struct([C_int(ccx, 1),\n+                                               C_uint(ccx, number)]),\n                        \"rust_gc_tydesc_src_index\");\n \n         lldestindex = lll::LLVMConstPointerCast(lldestindex, T_ptr(T_i8()));\n@@ -85,7 +88,7 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n         // Static type descriptor.\n \n         let llstaticgcmeta =\n-            add_global(bcx_ccx(bcx), C_struct([C_int(2), lltydesc]),\n+            add_global(bcx_ccx(bcx), C_struct([C_int(ccx, 2), lltydesc]),\n                        \"rust_gc_tydesc_static_gc_meta\");\n         let llstaticgcmetaptr =\n             lll::LLVMConstPointerCast(llstaticgcmeta, T_ptr(T_i8()));"}, {"sha": "f4009a929e303b62a3aaa757b6a85ddce8b19d52", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "patch": "@@ -161,7 +161,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n       ty::ty_vec(mt) {\n         let mt_ty = mt.ty;\n         if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n-            T_ptr(T_opaque_vec(cx))\n+            T_ptr(cx.opaque_vec_type)\n         } else {\n             // should be unnecessary\n             check non_ty_var(cx, mt_ty);\n@@ -359,7 +359,7 @@ fn trans_native_call(cx: @block_ctxt, externs: hashmap<str, ValueRef>,\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n     let call_args: [ValueRef] = [];\n     for a: ValueRef in args {\n-        call_args += [ZExtOrBitCast(cx, a, T_int(bcx_ccx(cx)))];\n+        call_args += [ZExtOrBitCast(cx, a, bcx_ccx(cx).int_type)];\n     }\n     ret Call(cx, llnative, call_args);\n }\n@@ -2616,7 +2616,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let seq_ty = ty::expr_ty(bcx_tcx(cx), seq);\n     let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n-    let seq = PointerCast(bcx, seq, T_ptr(T_opaque_vec(ccx)));\n+    let seq = PointerCast(bcx, seq, T_ptr(ccx.opaque_vec_type));\n     let fill = tvec::get_fill(bcx, seq);\n     if ty::type_is_str(bcx_tcx(bcx), seq_ty) {\n         fill = Sub(bcx, fill, C_int(ccx, 1));\n@@ -6075,7 +6075,7 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     llvm::LLVMSetLinkage(map,\n                          lib::llvm::LLVMExternalLinkage as llvm::Linkage);\n     llvm::LLVMSetInitializer(map,\n-                             C_struct([p2i(create_module_map(ccx)),\n+                             C_struct([p2i(ccx, create_module_map(ccx)),\n                                        C_array(ccx.int_type, subcrates)]));\n     ret map;\n >>>>>>> work on making the size of ints depend on the target arch\n@@ -6129,15 +6129,16 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     let _: () =\n         str::as_buf(sess.get_targ_cfg().target_strs.target_triple,\n                     {|buf| llvm::LLVMSetTarget(llmod, buf) });\n+    let targ_cfg = sess.get_targ_cfg();\n     let td = mk_target_data(sess.get_targ_cfg().target_strs.data_layout);\n     let tn = mk_type_names();\n     let intrinsics = declare_intrinsics(llmod);\n-    let int_type = T_int(sess.get_targ_cfg().arch);\n-    let float_type = T_float(sess.get_targ_cfg().arch);\n-    let task_type = T_task(sess.get_targ_cfg().arch);\n+    let int_type = T_int(targ_cfg);\n+    let float_type = T_float(targ_cfg);\n+    let task_type = T_task(targ_cfg);\n     let taskptr_type = T_ptr(task_type);\n     tn.associate(\"taskptr\", taskptr_type);\n-    let tydesc_type = T_tydesc(taskptr_type);\n+    let tydesc_type = T_tydesc(targ_cfg, taskptr_type);\n     tn.associate(\"tydesc\", tydesc_type);\n     let hasher = ty::hash_ty;\n     let eqer = ty::eq_ty;\n@@ -6184,12 +6185,14 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                mutable n_real_glues: 0u,\n                fn_times: @mutable []},\n           upcalls:\n-              upcall::declare_upcalls(tn, tydesc_type, llmod),\n+              upcall::declare_upcalls(targ_cfg, tn, tydesc_type,\n+                                      llmod),\n           rust_object_type: T_rust_object(),\n           tydesc_type: tydesc_type,\n           int_type: int_type,\n           float_type: float_type,\n           task_type: task_type,\n+          opaque_vec_type: T_opaque_vec(targ_cfg),\n           builder: BuilderRef_res(llvm::LLVMCreateBuilder()),\n           shape_cx: shape::mk_ctxt(llmod),\n           gc_cx: gc::mk_ctxt(),"}, {"sha": "517192d580dd06a2c1bddd14940813d050ff7e95", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "patch": "@@ -44,6 +44,7 @@ tag opt_result {\n     range_result(result, result);\n }\n fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n+    let ccx = bcx_ccx(bcx);\n     alt o {\n       lit(l) {\n         alt l.node {\n@@ -56,11 +57,11 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n           }\n           _ {\n             ret single_result(\n-                rslt(bcx, trans::trans_crate_lit(bcx_ccx(bcx), *l)));\n+                rslt(bcx, trans::trans_crate_lit(ccx, *l)));\n           }\n         }\n       }\n-      var(id, _) { ret single_result(rslt(bcx, C_int(id as int))); }\n+      var(id, _) { ret single_result(rslt(bcx, C_int(ccx, id as int))); }\n       range(l1, l2) {\n         let cell1 = trans::empty_dest_cell();\n         let cell2 = trans::empty_dest_cell();\n@@ -257,8 +258,8 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n         vec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n     if size > 0u && vec::len(variants) != 1u {\n         let tagptr =\n-            PointerCast(bcx, val, trans_common::T_opaque_tag_ptr(ccx.tn));\n-        blobptr = GEP(bcx, tagptr, [C_int(0), C_int(1)]);\n+            PointerCast(bcx, val, trans_common::T_opaque_tag_ptr(ccx));\n+        blobptr = GEP(bcx, tagptr, [C_int(ccx, 0), C_int(ccx, 1)]);\n     }\n     let i = 0u;\n     let vdefs_tg = vdefs.tg;\n@@ -439,7 +440,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         let box = Load(bcx, val);\n         let unboxed =\n             InBoundsGEP(bcx, box,\n-                        [C_int(0), C_int(back::abi::box_rc_field_body)]);\n+                        [C_int(ccx, 0),\n+                         C_int(ccx, back::abi::box_rc_field_body)]);\n         compile_submatch(bcx, enter_box(m, col, val), [unboxed] + vals_left,\n                          f, exits);\n         ret;\n@@ -465,8 +467,9 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n             } else {\n                 let tagptr =\n                     PointerCast(bcx, val,\n-                                trans_common::T_opaque_tag_ptr(ccx.tn));\n-                let discrimptr = GEP(bcx, tagptr, [C_int(0), C_int(0)]);\n+                                trans_common::T_opaque_tag_ptr(ccx));\n+                let discrimptr = GEP(bcx, tagptr, [C_int(ccx, 0),\n+                                                   C_int(ccx, 0)]);\n                 test_val = Load(bcx, discrimptr);\n                 kind = switch;\n             }\n@@ -505,7 +508,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n         // holding a corrupted value (when the compiler is optimized).\n         // This can be removed after our next LLVM upgrade.\n         val_ty(sw);\n-    } else { sw = C_int(0); } // Placeholder for when not using a switch\n+    } else { sw = C_int(ccx, 0); } // Placeholder for when not using a switch\n \n      // Compile subtrees for each option\n     for opt: opt in opts {\n@@ -736,7 +739,8 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         let box = Load(bcx, val);\n         let unboxed =\n             InBoundsGEP(bcx, box,\n-                        [C_int(0), C_int(back::abi::box_rc_field_body)]);\n+                        [C_int(ccx, 0),\n+                         C_int(ccx, back::abi::box_rc_field_body)]);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) {"}, {"sha": "8e289d756a384c5ce6ce36cf527394f1e2bf5dd8", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "patch": "@@ -123,6 +123,7 @@ type crate_ctxt =\n      int_type: TypeRef,\n      float_type: TypeRef,\n      task_type: TypeRef,\n+     opaque_vec_type: TypeRef,\n      builder: BuilderRef_res,\n      shape_cx: shape::ctxt,\n      gc_cx: gc::ctxt,\n@@ -490,26 +491,26 @@ fn T_f64() -> TypeRef { ret llvm::LLVMDoubleType(); }\n \n fn T_bool() -> TypeRef { ret T_i1(); }\n \n-fn T_int(arch: session::arch) -> TypeRef {\n-    ret alt arch {\n-      arch_x86 { T_i32() }\n-      arch_x86_64 { T_i64() }\n-      arch_arm { T_i32() }\n+fn T_int(targ_cfg: @session::config) -> TypeRef {\n+    ret alt targ_cfg.arch {\n+      session::arch_x86. { T_i32() }\n+      session::arch_x86_64. { T_i64() }\n+      session::arch_arm. { T_i32() }\n     };\n }\n \n-fn T_float(arch: session::arch) -> TypeRef {\n-    ret alt arch {\n-      arch_x86 { T_f64() }\n-      arch_x86_64 { T_f64() }\n-      arch_arm { T_f64() }\n+fn T_float(targ_cfg: @session::config) -> TypeRef {\n+    ret alt targ_cfg.arch {\n+      session::arch_x86. { T_f64() }\n+      session::arch_x86_64. { T_f64() }\n+      session::arch_arm. { T_f64() }\n     };\n }\n \n fn T_char() -> TypeRef { ret T_i32(); }\n \n-fn T_size_t(cx: @crate_ctxt) -> TypeRef {\n-    ret cx.int_type;\n+fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n+    ret T_int(targ_cfg);\n }\n \n fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n@@ -553,7 +554,7 @@ fn T_rust_object() -> TypeRef {\n     ret t;\n }\n \n-fn T_task(arch: session::arch) -> TypeRef {\n+fn T_task(targ_cfg: @session::config) -> TypeRef {\n     let t = T_named_struct(\"task\");\n \n     // Refcount\n@@ -567,7 +568,7 @@ fn T_task(arch: session::arch) -> TypeRef {\n     // Domain pointer\n     // Crate cache pointer\n \n-    let t_int = T_int(arch);\n+    let t_int = T_int(targ_cfg);\n     let elems =\n         [t_int, t_int, t_int, t_int,\n          t_int, t_int, t_int, t_int];\n@@ -603,7 +604,7 @@ fn T_cmp_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc(cx: @crate_ctxt) -> TypeRef {\n+fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n     let tydesc = T_named_struct(\"tydesc\");\n     let tydescpp = T_ptr(T_ptr(tydesc));\n     let pvoid = T_ptr(T_i8());\n@@ -614,29 +615,35 @@ fn T_tydesc(cx: @crate_ctxt) -> TypeRef {\n         T_ptr(T_fn([T_ptr(T_i1()), T_ptr(tydesc), tydescpp,\n                     pvoid, pvoid, T_i8()], T_void()));\n \n+    let int_type = T_int(targ_cfg);\n     let elems =\n-        [tydescpp, cx.int_type, cx.int_type,\n+        [tydescpp, int_type, int_type,\n          glue_fn_ty, glue_fn_ty, glue_fn_ty,\n          T_ptr(T_i8()), glue_fn_ty, glue_fn_ty, glue_fn_ty, cmp_glue_fn_ty,\n-         T_ptr(T_i8()), T_ptr(T_i8()), cx.int_type, cx.int_type];\n+         T_ptr(T_i8()), T_ptr(T_i8()), int_type, int_type];\n     set_struct_body(tydesc, elems);\n     ret tydesc;\n }\n \n fn T_array(t: TypeRef, n: uint) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n \n-\n // Interior vector.\n //\n // TODO: Support user-defined vector sizes.\n-fn T_vec(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n-    ret T_struct([cx.int_type, // fill\n-                  cx.int_type, // alloc\n+fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n+    ret T_struct([T_int(targ_cfg), // fill\n+                  T_int(targ_cfg), // alloc\n                   T_array(t, 0u)]); // elements\n }\n \n+fn T_vec(ccx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+    ret T_vec2(ccx.sess.get_targ_cfg(), t);\n+}\n+\n // Note that the size of this one is in bytes.\n-fn T_opaque_vec(cx: @crate_ctxt) -> TypeRef { ret T_vec(cx, T_i8()); }\n+fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n+    ret T_vec2(targ_cfg, T_i8());\n+}\n \n fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n     ret T_struct([cx.int_type, t]);"}, {"sha": "526f60dd88abd28fd83f5dafe979539a809e55c4", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "patch": "@@ -70,8 +70,8 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n     // Grab onto the first and second elements of the pair.\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n-    let pair_vtbl = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n-    let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n+    let pair_vtbl = GEPi(bcx, pair, [0, abi::obj_field_vtbl]);\n+    let pair_box = GEPi(bcx, pair, [0, abi::obj_field_box]);\n \n     // Make a vtable for this object: a static array of pointers to functions.\n     // It will be located in the read-only memory of the executable we're\n@@ -375,9 +375,9 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n         box = PointerCast(bcx, box, llbox_ty);\n     }\n     let pair = trans::get_dest_addr(dest);\n-    let pair_vtbl = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+    let pair_vtbl = GEPi(bcx, pair, [0, abi::obj_field_vtbl]);\n     Store(bcx, vtbl, pair_vtbl);\n-    let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);\n+    let pair_box = GEPi(bcx, pair, [0, abi::obj_field_box]);\n     Store(bcx, box, pair_box);\n     ret bcx;\n }\n@@ -627,7 +627,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n         PointerCast(bcx, fcx.llenv,\n                     T_ptr(T_struct([cx.ccx.rust_object_type,\n                                     T_ptr(cx.ccx.rust_object_type)])));\n-    let llself_obj_ptr = GEP(bcx, llenv, [C_int(0), C_int(1)]);\n+    let llself_obj_ptr = GEPi(bcx, llenv, [0, 1]);\n     llself_obj_ptr = Load(bcx, llself_obj_ptr);\n \n     // Cast it back to pointer-to-object-type, so LLVM won't complain.\n@@ -663,12 +663,12 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     let vtbl_type = T_ptr(T_array(T_ptr(T_nil()), ix + 1u));\n \n     let llouter_obj_vtbl =\n-        GEP(bcx, llself_obj_ptr, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+        GEPi(bcx, llself_obj_ptr, [0, abi::obj_field_vtbl]);\n     llouter_obj_vtbl = Load(bcx, llouter_obj_vtbl);\n     llouter_obj_vtbl = PointerCast(bcx, llouter_obj_vtbl, vtbl_type);\n \n     let llouter_mthd =\n-        GEP(bcx, llouter_obj_vtbl, [C_int(0), C_int(ix as int)]);\n+        GEPi(bcx, llouter_obj_vtbl, [0, ix as int]);\n \n     // Set up the outer method to be called.\n     let llouter_mthd_ty = type_of_meth(bcx_ccx(bcx), sp, m, ty_params);\n@@ -746,16 +746,16 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     // First, grab the box out of the self_obj.  It contains a refcount and a\n     // body.\n     let llself_obj_box =\n-        GEP(bcx, llself_obj_ptr, [C_int(0), C_int(abi::obj_field_box)]);\n+        GEPi(bcx, llself_obj_ptr, [0, abi::obj_field_box]);\n     llself_obj_box = Load(bcx, llself_obj_box);\n \n     let ccx = bcx_ccx(bcx);\n-    let llbox_ty = T_opaque_obj_ptr(*ccx);\n+    let llbox_ty = T_opaque_obj_ptr(ccx);\n     llself_obj_box = PointerCast(bcx, llself_obj_box, llbox_ty);\n \n     // Now, reach into the box and grab the body.\n     let llself_obj_body =\n-        GEP(bcx, llself_obj_box, [C_int(0), C_int(abi::box_rc_field_body)]);\n+        GEPi(bcx, llself_obj_box, [0, abi::box_rc_field_body]);\n \n     // Now, we need to figure out exactly what type the body is supposed to be\n     // cast to.\n@@ -784,11 +784,11 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     // method's entry out of the vtable so that the forwarding function can\n     // call it.\n     let llinner_obj_vtbl =\n-        GEP(bcx, llinner_obj.val, [C_int(0), C_int(abi::obj_field_vtbl)]);\n+        GEPi(bcx, llinner_obj.val, [0, abi::obj_field_vtbl]);\n     llinner_obj_vtbl = Load(bcx, llinner_obj_vtbl);\n \n     let llinner_obj_body =\n-        GEP(bcx, llinner_obj.val, [C_int(0), C_int(abi::obj_field_box)]);\n+        GEPi(bcx, llinner_obj.val, [0, abi::obj_field_box]);\n     llinner_obj_body = Load(bcx, llinner_obj_body);\n \n     // Get the index of the method we want.\n@@ -809,7 +809,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     llinner_obj_vtbl = PointerCast(bcx, llinner_obj_vtbl, vtbl_type);\n \n     let llorig_mthd =\n-        GEP(bcx, llinner_obj_vtbl, [C_int(0), C_int(ix as int)]);\n+        GEPi(bcx, llinner_obj_vtbl, [0, ix as int]);\n \n     // Set up the original method to be called.\n     let llorig_mthd_ty = type_of_meth(bcx_ccx(bcx), sp, m, ty_params);\n@@ -920,18 +920,18 @@ fn populate_self_stack(bcx: @block_ctxt, self_stack: ValueRef,\n                        inner_obj_body: ValueRef) -> ValueRef {\n \n     // Drop the outer obj into the second slot.\n-    let self_pair_ptr = GEP(bcx, self_stack, [C_int(0), C_int(1)]);\n+    let self_pair_ptr = GEPi(bcx, self_stack, [0, 1]);\n     Store(bcx, outer_obj, self_pair_ptr);\n \n     // Drop in the backwarding vtbl.\n-    let wrapper_pair = GEP(bcx, self_stack, [C_int(0), C_int(0)]);\n-    let wrapper_vtbl_ptr = GEP(bcx, wrapper_pair, [C_int(0), C_int(0)]);\n+    let wrapper_pair = GEPi(bcx, self_stack, [0, 0]);\n+    let wrapper_vtbl_ptr = GEPi(bcx, wrapper_pair, [0, 0]);\n     let backwarding_vtbl_cast =\n         PointerCast(bcx, backwarding_vtbl, T_ptr(T_empty_struct()));\n     Store(bcx, backwarding_vtbl_cast, wrapper_vtbl_ptr);\n \n     // Drop in the inner obj body.\n-    let wrapper_body_ptr = GEP(bcx, wrapper_pair, [C_int(0), C_int(1)]);\n+    let wrapper_body_ptr = GEPi(bcx, wrapper_pair, [0, 1]);\n     Store(bcx, inner_obj_body, wrapper_body_ptr);\n \n     ret self_stack;"}, {"sha": "dbb49b48849608f774bf17b98c66b47c125e8312", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "patch": "@@ -28,14 +28,17 @@ fn pointer_add(bcx: @block_ctxt, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n }\n \n fn alloc_raw(bcx: @block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n-    let llvecty = T_opaque_vec();\n-    let vecsize = Add(bcx, alloc, llsize_of(llvecty));\n+    let ccx = bcx_ccx(bcx);\n+    let llvecty = ccx.opaque_vec_type;\n+    let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n     let {bcx: bcx, val: vecptr} =\n         trans_shared_malloc(bcx, T_ptr(llvecty), vecsize);\n     Store(bcx, fill,\n-          InBoundsGEP(bcx, vecptr, [C_int(0), C_uint(abi::vec_elt_fill)]));\n+          InBoundsGEP(bcx, vecptr, [C_int(ccx, 0),\n+                                    C_uint(ccx, abi::vec_elt_fill)]));\n     Store(bcx, alloc,\n-          InBoundsGEP(bcx, vecptr, [C_int(0), C_uint(abi::vec_elt_alloc)]));\n+          InBoundsGEP(bcx, vecptr, [C_int(ccx, 0),\n+                                    C_uint(ccx, abi::vec_elt_alloc)]));\n     ret {bcx: bcx, val: vecptr};\n }\n \n@@ -47,13 +50,18 @@ type alloc_result =\n      llunitty: TypeRef};\n \n fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n+    let ccx = bcx_ccx(bcx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n-    let llvecty = T_vec(llunitty);\n+    let llvecty = T_vec(ccx, llunitty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n \n-    let fill = Mul(bcx, C_uint(elts), unit_sz);\n-    let alloc = if elts < 4u { Mul(bcx, C_int(4), unit_sz) } else { fill };\n+    let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n+    let alloc = if elts < 4u {\n+                    Mul(bcx, C_int(ccx, 4), unit_sz)\n+                } else {\n+                    fill\n+                };\n     let {bcx: bcx, val: vptr} = alloc_raw(bcx, fill, alloc);\n     let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n \n@@ -65,14 +73,16 @@ fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n }\n \n fn duplicate(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) -> result {\n+    let ccx = bcx_ccx(bcx);\n     let fill = get_fill(bcx, vptr);\n-    let size = Add(bcx, fill, llsize_of(T_opaque_vec()));\n+    let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n     let {bcx: bcx, val: newptr} =\n         trans_shared_malloc(bcx, val_ty(vptr), size);\n     let bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     Store(bcx, fill,\n-          InBoundsGEP(bcx, newptr, [C_int(0), C_uint(abi::vec_elt_alloc)]));\n+          InBoundsGEP(bcx, newptr, [C_int(ccx, 0),\n+                                    C_uint(ccx, abi::vec_elt_alloc)]));\n     if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n         bcx = iter_vec(bcx, newptr, vec_ty, trans::take_ty);\n     }\n@@ -95,6 +105,7 @@ fn make_free_glue(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) ->\n \n fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n+    let ccx = bcx_ccx(bcx);\n     if dest == trans::ignore {\n         for arg in args {\n             bcx = trans::trans_expr(bcx, arg, trans::ignore);\n@@ -115,8 +126,8 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n     let i = 0u, temp_cleanups = [vptr];\n     for e in args {\n         let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-            InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n-        } else { InBoundsGEP(bcx, dataptr, [C_uint(i)]) };\n+            InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(ccx, i), llunitsz)])\n+        } else { InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]) };\n         bcx = trans::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         temp_cleanups += [lleltptr];\n@@ -131,21 +142,23 @@ fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n     let {bcx: bcx, val: sptr, _} =\n         alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen);\n \n-    let llcstr = C_cstr(bcx_ccx(bcx), s);\n+    let ccx = bcx_ccx(bcx);\n+    let llcstr = C_cstr(ccx, s);\n     let bcx =\n         call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n-                     C_uint(veclen)).bcx;\n+                     C_uint(ccx, veclen)).bcx;\n     ret trans::store_in_dest(bcx, sptr, dest);\n }\n \n fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n                 rhs: ValueRef) -> @block_ctxt {\n     // Cast to opaque interior vector types if necessary.\n+    let ccx = bcx_ccx(cx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n     let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n     if dynamic {\n-        lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n-        rhs = PointerCast(cx, rhs, T_ptr(T_opaque_vec()));\n+        lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type)));\n+        rhs = PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type));\n     }\n     let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n       ty::ty_str. { true }\n@@ -160,8 +173,9 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let lfill = get_fill(bcx, lhs);\n     let rfill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lfill, rfill);\n-    if strings { new_fill = Sub(bcx, new_fill, C_int(1)); }\n-    let opaque_lhs = PointerCast(bcx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n+    if strings { new_fill = Sub(bcx, new_fill, C_int(ccx, 1)); }\n+    let opaque_lhs = PointerCast(bcx, lhsptr,\n+                                 T_ptr(T_ptr(ccx.opaque_vec_type)));\n     Call(bcx, bcx_ccx(cx).upcalls.vec_grow,\n          [opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n@@ -170,7 +184,7 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n \n     let lhs_data = get_dataptr(bcx, lhs, llunitty);\n     let lhs_off = lfill;\n-    if strings { lhs_off = Sub(bcx, lhs_off, C_int(1)); }\n+    if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n     let bcx = iter_vec_raw(bcx, rhs, vec_ty, rfill,\n@@ -181,7 +195,7 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n                              copy_val(bcx, INIT, write_ptr,\n                                       load_if_immediate(bcx, addr, unit_ty),\n                                       unit_ty);\n-                         let incr = dynamic ? unit_sz : C_int(1);\n+                         let incr = dynamic ? unit_sz : C_int(ccx, 1);\n                          Store(bcx, InBoundsGEP(bcx, write_ptr, [incr]),\n                                write_ptr_ptr);\n                          ret bcx;\n@@ -191,12 +205,14 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n \n fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n                         vals: [@ast::expr]) -> @block_ctxt {\n+    let ccx = bcx_ccx(bcx);\n     let elt_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let ti = none;\n     let {bcx: bcx, val: td} =\n         get_tydesc(bcx, elt_ty, false, tps_normal, ti).result;\n     trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n-    let opaque_v = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec())));\n+    let opaque_v = PointerCast(bcx, vptrptr,\n+                               T_ptr(T_ptr(ccx.opaque_vec_type)));\n     for val in vals {\n         let {bcx: e_bcx, val: elt} = trans::trans_temp_expr(bcx, val);\n         bcx = e_bcx;\n@@ -211,6 +227,7 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n \n fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n              rhs: ValueRef, dest: dest) -> @block_ctxt {\n+    let ccx = bcx_ccx(bcx);\n     let strings = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n       ty::ty_str. { true }\n       ty::ty_vec(_) { false }\n@@ -220,25 +237,26 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n \n     let lhs_fill = get_fill(bcx, lhs);\n-    if strings { lhs_fill = Sub(bcx, lhs_fill, C_int(1)); }\n+    if strings { lhs_fill = Sub(bcx, lhs_fill, C_int(ccx, 1)); }\n     let rhs_fill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let {bcx: bcx, val: new_vec_ptr} = alloc_raw(bcx, new_fill, new_fill);\n-    new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(llunitty)));\n+    new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(ccx, llunitty)));\n \n     let write_ptr_ptr = do_spill_noroot\n         (bcx, get_dataptr(bcx, new_vec_ptr, llunitty));\n     let copy_fn =\n         bind fn (bcx: @block_ctxt, addr: ValueRef, _ty: ty::t,\n                  write_ptr_ptr: ValueRef, unit_ty: ty::t, llunitsz: ValueRef)\n                 -> @block_ctxt {\n+                 let ccx = bcx_ccx(bcx);\n                  let write_ptr = Load(bcx, write_ptr_ptr);\n                  let bcx =\n                      copy_val(bcx, INIT, write_ptr,\n                               load_if_immediate(bcx, addr, unit_ty), unit_ty);\n                  let incr =\n                      ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) ?\n-                         llunitsz : C_int(1);\n+                         llunitsz : C_int(ccx, 1);\n                  Store(bcx, InBoundsGEP(bcx, write_ptr, [incr]),\n                        write_ptr_ptr);\n                  ret bcx;\n@@ -255,10 +273,11 @@ type iter_vec_block = block(@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> @block_ctxt {\n+    let ccx = bcx_ccx(bcx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n-    vptr = PointerCast(bcx, vptr, T_ptr(T_vec(llunitty)));\n+    vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n     // Calculate the last pointer address we want to handle.\n@@ -279,7 +298,7 @@ fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     let increment =\n         if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n             unit_sz\n-        } else { C_int(1) };\n+        } else { C_int(ccx, 1) };\n     AddIncomingToPhi(data_ptr, InBoundsGEP(body_cx, data_ptr, [increment]),\n                      body_cx.llbb);\n     Br(body_cx, header_cx.llbb);\n@@ -288,7 +307,8 @@ fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n \n fn iter_vec(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> @block_ctxt {\n-    vptr = PointerCast(bcx, vptr, T_ptr(T_opaque_vec()));\n+    let ccx = bcx_ccx(bcx);\n+    vptr = PointerCast(bcx, vptr, T_ptr(ccx.opaque_vec_type));\n     ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n }\n "}]}