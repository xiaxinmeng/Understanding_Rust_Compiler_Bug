{"sha": "1540e8cac0a7723a79a0601004f58574367c7eca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NDBlOGNhYzBhNzcyM2E3OWEwNjAxMDA0ZjU4NTc0MzY3YzdlY2E=", "commit": {"author": {"name": "BurntPizza", "email": "xburntpizza@gmail.com", "date": "2018-08-17T06:59:55Z"}, "committer": {"name": "BurntPizza", "email": "xburntpizza@gmail.com", "date": "2018-08-17T06:59:55Z"}, "message": "Remove inline attribute on generic functions", "tree": {"sha": "5c6bc9be0637feffd128dc5460c11416224bce9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c6bc9be0637feffd128dc5460c11416224bce9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1540e8cac0a7723a79a0601004f58574367c7eca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1540e8cac0a7723a79a0601004f58574367c7eca", "html_url": "https://github.com/rust-lang/rust/commit/1540e8cac0a7723a79a0601004f58574367c7eca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1540e8cac0a7723a79a0601004f58574367c7eca/comments", "author": {"login": "BurntPizza", "id": 4973668, "node_id": "MDQ6VXNlcjQ5NzM2Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/4973668?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BurntPizza", "html_url": "https://github.com/BurntPizza", "followers_url": "https://api.github.com/users/BurntPizza/followers", "following_url": "https://api.github.com/users/BurntPizza/following{/other_user}", "gists_url": "https://api.github.com/users/BurntPizza/gists{/gist_id}", "starred_url": "https://api.github.com/users/BurntPizza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BurntPizza/subscriptions", "organizations_url": "https://api.github.com/users/BurntPizza/orgs", "repos_url": "https://api.github.com/users/BurntPizza/repos", "events_url": "https://api.github.com/users/BurntPizza/events{/privacy}", "received_events_url": "https://api.github.com/users/BurntPizza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BurntPizza", "id": 4973668, "node_id": "MDQ6VXNlcjQ5NzM2Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/4973668?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BurntPizza", "html_url": "https://github.com/BurntPizza", "followers_url": "https://api.github.com/users/BurntPizza/followers", "following_url": "https://api.github.com/users/BurntPizza/following{/other_user}", "gists_url": "https://api.github.com/users/BurntPizza/gists{/gist_id}", "starred_url": "https://api.github.com/users/BurntPizza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BurntPizza/subscriptions", "organizations_url": "https://api.github.com/users/BurntPizza/orgs", "repos_url": "https://api.github.com/users/BurntPizza/repos", "events_url": "https://api.github.com/users/BurntPizza/events{/privacy}", "received_events_url": "https://api.github.com/users/BurntPizza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc900f5323ac7817788da201e0c703f04b1bd37d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc900f5323ac7817788da201e0c703f04b1bd37d", "html_url": "https://github.com/rust-lang/rust/commit/bc900f5323ac7817788da201e0c703f04b1bd37d"}], "stats": {"total": 156, "additions": 18, "deletions": 138}, "files": [{"sha": "9748a5063925bc8d86a9dc2656ca7dfe531d2ac3", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1540e8cac0a7723a79a0601004f58574367c7eca/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1540e8cac0a7723a79a0601004f58574367c7eca/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=1540e8cac0a7723a79a0601004f58574367c7eca", "patch": "@@ -17,10 +17,7 @@ use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSe\n use std::rc::Rc;\n use std::sync::Arc;\n \n-impl<\n-    T: Encodable\n-> Encodable for LinkedList<T> {\n-    #[inline]\n+impl<T: Encodable> Encodable for LinkedList<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -32,7 +29,6 @@ impl<\n }\n \n impl<T:Decodable> Decodable for LinkedList<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = LinkedList::new();\n@@ -45,7 +41,6 @@ impl<T:Decodable> Decodable for LinkedList<T> {\n }\n \n impl<T: Encodable> Encodable for VecDeque<T> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -57,7 +52,6 @@ impl<T: Encodable> Encodable for VecDeque<T> {\n }\n \n impl<T:Decodable> Decodable for VecDeque<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: VecDeque<T> = VecDeque::new();\n@@ -69,11 +63,10 @@ impl<T:Decodable> Decodable for VecDeque<T> {\n     }\n }\n \n-impl<\n-    K: Encodable + PartialEq + Ord,\n-    V: Encodable\n-> Encodable for BTreeMap<K, V> {\n-    #[inline]\n+impl<K, V> Encodable for BTreeMap<K, V>\n+    where K: Encodable + PartialEq + Ord,\n+          V: Encodable\n+{\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n@@ -87,11 +80,10 @@ impl<\n     }\n }\n \n-impl<\n-    K: Decodable + PartialEq + Ord,\n-    V: Decodable\n-> Decodable for BTreeMap<K, V> {\n-    #[inline]\n+impl<K, V> Decodable for BTreeMap<K, V>\n+    where K: Decodable + PartialEq + Ord,\n+          V: Decodable\n+{\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n@@ -105,10 +97,9 @@ impl<\n     }\n }\n \n-impl<\n-    T: Encodable + PartialEq + Ord\n-> Encodable for BTreeSet<T> {\n-    #[inline]\n+impl<T> Encodable for BTreeSet<T>\n+    where T: Encodable + PartialEq + Ord\n+{\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n@@ -121,10 +112,9 @@ impl<\n     }\n }\n \n-impl<\n-    T: Decodable + PartialEq + Ord\n-> Decodable for BTreeSet<T> {\n-    #[inline]\n+impl<T> Decodable for BTreeSet<T>\n+    where T: Decodable + PartialEq + Ord\n+{\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n@@ -141,7 +131,6 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n           V: Encodable,\n           S: BuildHasher,\n {\n-    #[inline]\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n@@ -160,7 +149,6 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n           V: Decodable,\n           S: BuildHasher + Default,\n {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n@@ -179,7 +167,6 @@ impl<T, S> Encodable for HashSet<T, S>\n     where T: Encodable + Hash + Eq,\n           S: BuildHasher,\n {\n-    #[inline]\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n@@ -196,7 +183,6 @@ impl<T, S> Decodable for HashSet<T, S>\n     where T: Decodable + Hash + Eq,\n           S: BuildHasher + Default,\n {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n@@ -210,7 +196,6 @@ impl<T, S> Decodable for HashSet<T, S>\n }\n \n impl<T: Encodable> Encodable for Rc<[T]> {\n-    #[inline]\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (index, e) in self.iter().enumerate() {\n@@ -222,7 +207,6 @@ impl<T: Encodable> Encodable for Rc<[T]> {\n }\n \n impl<T: Decodable> Decodable for Rc<[T]> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Rc<[T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = Vec::with_capacity(len);\n@@ -235,7 +219,6 @@ impl<T: Decodable> Decodable for Rc<[T]> {\n }\n \n impl<T: Encodable> Encodable for Arc<[T]> {\n-    #[inline]\n     fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (index, e) in self.iter().enumerate() {\n@@ -247,7 +230,6 @@ impl<T: Encodable> Encodable for Arc<[T]> {\n }\n \n impl<T: Decodable> Decodable for Arc<[T]> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Arc<[T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = Vec::with_capacity(len);"}, {"sha": "60bb5a0fec2cdba8f5b8822af8631cd5f6113205", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 3, "deletions": 105, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1540e8cac0a7723a79a0601004f58574367c7eca/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1540e8cac0a7723a79a0601004f58574367c7eca/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=1540e8cac0a7723a79a0601004f58574367c7eca", "patch": "@@ -45,86 +45,74 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n \n     // Compound types:\n-    #[inline]\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_enum_variant<F>(&mut self, _v_name: &str, v_id: usize, _len: usize, f: F)\n         -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_usize(v_id)?;\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_enum_struct_variant<F>(&mut self, v_name: &str, v_id: usize, len: usize, f: F)\n         -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum_variant(v_name, v_id, len, f)\n     }\n \n-    #[inline]\n     fn emit_enum_struct_variant_field<F>(&mut self, _f_name: &str, f_idx: usize, f: F)\n         -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum_variant_arg(f_idx, f)\n     }\n \n-    #[inline]\n     fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_struct_field<F>(&mut self, _f_name: &str, _f_idx: usize, f: F)\n         -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_tuple<F>(&mut self, _len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_tuple_arg<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_tuple(len, f)\n     }\n \n-    #[inline]\n     fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_tuple_arg(f_idx, f)\n     }\n \n     // Specialized types:\n-    #[inline]\n     fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n@@ -136,44 +124,38 @@ pub trait Encoder {\n         self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n     }\n \n-    #[inline]\n     fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum_variant(\"Some\", 1, 1, f)\n     }\n \n-    #[inline]\n     fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_usize(len)?;\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_usize(len)?;\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n@@ -205,86 +187,74 @@ pub trait Decoder {\n     fn read_str(&mut self) -> Result<Cow<str>, Self::Error>;\n \n     // Compound types:\n-    #[inline]\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         let disr = self.read_usize()?;\n         f(self, disr)\n     }\n \n-    #[inline]\n     fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         self.read_enum_variant(names, f)\n     }\n \n-    #[inline]\n     fn read_enum_struct_variant_field<T, F>(&mut self, _f_name: &str, f_idx: usize, f: F)\n         -> Result<T, Self::Error> where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_enum_variant_arg(f_idx, f)\n     }\n \n-    #[inline]\n     fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn read_struct_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, f: F)\n         -> Result<T, Self::Error> where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_tuple(len, f)\n     }\n \n-    #[inline]\n     fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_tuple_arg(a_idx, f)\n     }\n \n     // Specialized types:\n-    #[inline]\n     fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>\n     {\n@@ -299,37 +269,32 @@ pub trait Decoder {\n         })\n     }\n \n-    #[inline]\n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         let len = self.read_usize()?;\n         f(self, len)\n     }\n \n-    #[inline]\n     fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         let len = self.read_usize()?;\n         f(self, len)\n     }\n \n-    #[inline]\n     fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         f(self)\n     }\n \n-    #[inline]\n     fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n@@ -349,309 +314,265 @@ pub trait Decodable: Sized {\n }\n \n impl Encodable for usize {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_usize(*self)\n     }\n }\n \n impl Decodable for usize {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<usize, D::Error> {\n         d.read_usize()\n     }\n }\n \n impl Encodable for u8 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u8(*self)\n     }\n }\n \n impl Decodable for u8 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u8, D::Error> {\n         d.read_u8()\n     }\n }\n \n impl Encodable for u16 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u16(*self)\n     }\n }\n \n impl Decodable for u16 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u16, D::Error> {\n         d.read_u16()\n     }\n }\n \n impl Encodable for u32 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(*self)\n     }\n }\n \n impl Decodable for u32 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u32, D::Error> {\n         d.read_u32()\n     }\n }\n \n impl Encodable for u64 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u64(*self)\n     }\n }\n \n impl Decodable for u64 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u64, D::Error> {\n         d.read_u64()\n     }\n }\n \n impl Encodable for u128 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u128(*self)\n     }\n }\n \n impl Decodable for u128 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<u128, D::Error> {\n         d.read_u128()\n     }\n }\n \n impl Encodable for isize {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_isize(*self)\n     }\n }\n \n impl Decodable for isize {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<isize, D::Error> {\n         d.read_isize()\n     }\n }\n \n impl Encodable for i8 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i8(*self)\n     }\n }\n \n impl Decodable for i8 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i8, D::Error> {\n         d.read_i8()\n     }\n }\n \n impl Encodable for i16 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i16(*self)\n     }\n }\n \n impl Decodable for i16 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i16, D::Error> {\n         d.read_i16()\n     }\n }\n \n impl Encodable for i32 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i32(*self)\n     }\n }\n \n impl Decodable for i32 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i32, D::Error> {\n         d.read_i32()\n     }\n }\n \n impl Encodable for i64 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i64(*self)\n     }\n }\n \n impl Decodable for i64 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i64, D::Error> {\n         d.read_i64()\n     }\n }\n \n impl Encodable for i128 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i128(*self)\n     }\n }\n \n impl Decodable for i128 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<i128, D::Error> {\n         d.read_i128()\n     }\n }\n \n impl Encodable for str {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self)\n     }\n }\n \n impl Encodable for String {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(&self[..])\n     }\n }\n \n impl Decodable for String {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<String, D::Error> {\n         Ok(d.read_str()?.into_owned())\n     }\n }\n \n impl Encodable for f32 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_f32(*self)\n     }\n }\n \n impl Decodable for f32 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<f32, D::Error> {\n         d.read_f32()\n     }\n }\n \n impl Encodable for f64 {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_f64(*self)\n     }\n }\n \n impl Decodable for f64 {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<f64, D::Error> {\n         d.read_f64()\n     }\n }\n \n impl Encodable for bool {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_bool(*self)\n     }\n }\n \n impl Decodable for bool {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<bool, D::Error> {\n         d.read_bool()\n     }\n }\n \n impl Encodable for char {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_char(*self)\n     }\n }\n \n impl Decodable for char {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<char, D::Error> {\n         d.read_char()\n     }\n }\n \n impl Encodable for () {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_nil()\n     }\n }\n \n impl Decodable for () {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<(), D::Error> {\n         d.read_nil()\n     }\n }\n \n impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n impl<T: ?Sized + Encodable> Encodable for Box<T> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n impl< T: Decodable> Decodable for Box<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n         Ok(box Decodable::decode(d)?)\n     }\n }\n \n impl< T: Decodable> Decodable for Box<[T]> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> {\n         let v: Vec<T> = Decodable::decode(d)?;\n         Ok(v.into_boxed_slice())\n     }\n }\n \n impl<T:Encodable> Encodable for Rc<T> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n impl<T:Decodable> Decodable for Rc<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Rc<T>, D::Error> {\n         Ok(Rc::new(Decodable::decode(d)?))\n     }\n }\n \n impl<T:Encodable> Encodable for [T] {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -663,7 +584,6 @@ impl<T:Encodable> Encodable for [T] {\n }\n \n impl<T:Encodable> Encodable for Vec<T> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -675,7 +595,6 @@ impl<T:Encodable> Encodable for Vec<T> {\n }\n \n impl<T:Decodable> Decodable for Vec<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n@@ -688,7 +607,6 @@ impl<T:Decodable> Decodable for Vec<T> {\n }\n \n impl<'a, T:Encodable> Encodable for Cow<'a, [T]> where [T]: ToOwned<Owned = Vec<T>> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -699,8 +617,9 @@ impl<'a, T:Encodable> Encodable for Cow<'a, [T]> where [T]: ToOwned<Owned = Vec<\n     }\n }\n \n-impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]> where [T]: ToOwned<Owned = Vec<T>> {\n-    #[inline]\n+impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]>\n+    where [T]: ToOwned<Owned = Vec<T>>\n+{\n     fn decode<D: Decoder>(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n@@ -714,7 +633,6 @@ impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]> where [T]: ToOwned<Own\n \n \n impl<T:Encodable> Encodable for Option<T> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| {\n             match *self {\n@@ -726,7 +644,6 @@ impl<T:Encodable> Encodable for Option<T> {\n }\n \n impl<T:Decodable> Decodable for Option<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Option<T>, D::Error> {\n         d.read_option(|d, b| {\n             if b {\n@@ -739,7 +656,6 @@ impl<T:Decodable> Decodable for Option<T> {\n }\n \n impl<T1: Encodable, T2: Encodable> Encodable for Result<T1, T2> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_enum(\"Result\", |s| {\n             match *self {\n@@ -763,7 +679,6 @@ impl<T1: Encodable, T2: Encodable> Encodable for Result<T1, T2> {\n }\n \n impl<T1:Decodable, T2:Decodable> Decodable for Result<T1, T2> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n         d.read_enum(\"Result\", |d| {\n             d.read_enum_variant(&[\"Ok\", \"Err\"], |d, disr| {\n@@ -803,7 +718,6 @@ macro_rules! tuple {\n     ( $($name:ident,)+ ) => (\n         impl<$($name:Decodable),*> Decodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n-            #[inline]\n             fn decode<D: Decoder>(d: &mut D) -> Result<($($name,)*), D::Error> {\n                 let len: usize = count_idents!($($name,)*);\n                 d.read_tuple(len, |d| {\n@@ -817,7 +731,6 @@ macro_rules! tuple {\n         }\n         impl<$($name:Encodable),*> Encodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n-            #[inline]\n             fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)*) = *self;\n                 let mut n = 0;\n@@ -836,29 +749,25 @@ macro_rules! tuple {\n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n impl Encodable for path::PathBuf {\n-    #[inline]\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.to_str().unwrap().encode(e)\n     }\n }\n \n impl Decodable for path::PathBuf {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> {\n         let bytes: String = Decodable::decode(d)?;\n         Ok(path::PathBuf::from(bytes))\n     }\n }\n \n impl<T: Encodable + Copy> Encodable for Cell<T> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.get().encode(s)\n     }\n }\n \n impl<T: Decodable + Copy> Decodable for Cell<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Cell<T>, D::Error> {\n         Ok(Cell::new(Decodable::decode(d)?))\n     }\n@@ -870,28 +779,24 @@ impl<T: Decodable + Copy> Decodable for Cell<T> {\n // from `encode` when `try_borrow` returns `None`.\n \n impl<T: Encodable> Encodable for RefCell<T> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.borrow().encode(s)\n     }\n }\n \n impl<T: Decodable> Decodable for RefCell<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<RefCell<T>, D::Error> {\n         Ok(RefCell::new(Decodable::decode(d)?))\n     }\n }\n \n impl<T:Encodable> Encodable for Arc<T> {\n-    #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n impl<T:Decodable> Decodable for Arc<T> {\n-    #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Arc<T>, D::Error> {\n         Ok(Arc::new(Decodable::decode(d)?))\n     }\n@@ -913,7 +818,6 @@ pub trait SpecializationError {\n }\n \n impl<E> SpecializationError for E {\n-    #[inline]\n     default fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> E {\n         panic!(\"missing specialization: `<{} as {}<{}>>::{}` not overridden\",\n                unsafe { intrinsics::type_name::<S>() },\n@@ -932,7 +836,6 @@ pub trait SpecializedEncoder<T: ?Sized + UseSpecializedEncodable>: Encoder {\n }\n \n impl<E: Encoder, T: ?Sized + UseSpecializedEncodable> SpecializedEncoder<T> for E {\n-    #[inline]\n     default fn specialized_encode(&mut self, value: &T) -> Result<(), E::Error> {\n         value.default_encode(self)\n     }\n@@ -947,7 +850,6 @@ pub trait SpecializedDecoder<T: UseSpecializedDecodable>: Decoder {\n }\n \n impl<D: Decoder, T: UseSpecializedDecodable> SpecializedDecoder<T> for D {\n-    #[inline]\n     default fn specialized_decode(&mut self) -> Result<T, D::Error> {\n         T::default_decode(self)\n     }\n@@ -957,14 +859,12 @@ impl<D: Decoder, T: UseSpecializedDecodable> SpecializedDecoder<T> for D {\n /// implementation which goes through `SpecializedEncoder`.\n pub trait UseSpecializedEncodable {\n     /// Defaults to returning an error (see `SpecializationError`).\n-    #[inline]\n     fn default_encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n         Err(E::Error::not_found::<E, Self>(\"SpecializedEncoder\", \"specialized_encode\"))\n     }\n }\n \n impl<T: ?Sized + UseSpecializedEncodable> Encodable for T {\n-    #[inline]\n     default fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         E::specialized_encode(e, self)\n     }\n@@ -974,14 +874,12 @@ impl<T: ?Sized + UseSpecializedEncodable> Encodable for T {\n /// implementation which goes through `SpecializedDecoder`.\n pub trait UseSpecializedDecodable: Sized {\n     /// Defaults to returning an error (see `SpecializationError`).\n-    #[inline]\n     fn default_decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n         Err(D::Error::not_found::<D, Self>(\"SpecializedDecoder\", \"specialized_decode\"))\n     }\n }\n \n impl<T: UseSpecializedDecodable> Decodable for T {\n-    #[inline]\n     default fn decode<D: Decoder>(d: &mut D) -> Result<T, D::Error> {\n         D::specialized_decode(d)\n     }"}]}