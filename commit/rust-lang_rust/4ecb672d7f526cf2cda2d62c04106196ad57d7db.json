{"sha": "4ecb672d7f526cf2cda2d62c04106196ad57d7db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlY2I2NzJkN2Y1MjZjZjJjZGEyZDYyYzA0MTA2MTk2YWQ1N2Q3ZGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-27T02:42:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-01T01:28:04Z"}, "message": "Remove legacy object creation mode, and convert remaining uses of it", "tree": {"sha": "5575dfefa4247b4f64e24e57f70fdead59e97eb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5575dfefa4247b4f64e24e57f70fdead59e97eb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ecb672d7f526cf2cda2d62c04106196ad57d7db", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ecb672d7f526cf2cda2d62c04106196ad57d7db", "html_url": "https://github.com/rust-lang/rust/commit/4ecb672d7f526cf2cda2d62c04106196ad57d7db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ecb672d7f526cf2cda2d62c04106196ad57d7db/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5680ec027088c57f8b9fa3a9aa91daaf2428a57c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5680ec027088c57f8b9fa3a9aa91daaf2428a57c", "html_url": "https://github.com/rust-lang/rust/commit/5680ec027088c57f8b9fa3a9aa91daaf2428a57c"}], "stats": {"total": 649, "additions": 295, "deletions": 354}, "files": [{"sha": "fdb622f653937a74e7675f8f564191b10247f929", "filename": "src/libcore/io.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -504,7 +504,7 @@ pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> @Reader {\n \n pub fn stdin() -> @Reader {\n     unsafe {\n-        rustrt::rust_get_stdin() as @Reader\n+        @rustrt::rust_get_stdin() as @Reader\n     }\n }\n \n@@ -642,11 +642,11 @@ impl Writer for *libc::FILE {\n     }\n }\n \n-pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n+pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> @Writer {\n     if cleanup {\n-        Wrapper { base: f, cleanup: FILERes(f) } as Writer\n+        @Wrapper { base: f, cleanup: FILERes(f) } as @Writer\n     } else {\n-        f as Writer\n+        @f as @Writer\n     }\n }\n \n@@ -702,11 +702,11 @@ pub fn FdRes(fd: fd_t) -> FdRes {\n     }\n }\n \n-pub fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n+pub fn fd_writer(fd: fd_t, cleanup: bool) -> @Writer {\n     if cleanup {\n-        Wrapper { base: fd, cleanup: FdRes(fd) } as Writer\n+        @Wrapper { base: fd, cleanup: FdRes(fd) } as @Writer\n     } else {\n-        fd as Writer\n+        @fd as @Writer\n     }\n }\n "}, {"sha": "d9c2b91fb972207a813406ba3d8a88009b47dfac", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -412,8 +412,8 @@ pub fn Rng() -> Rng {\n  * all other generators constructed with the same seed. The seed may be any\n  * length.\n  */\n-pub fn seeded_rng(seed: &[u8]) -> Rng {\n-    seeded_randres(seed) as Rng\n+pub fn seeded_rng(seed: &[u8]) -> @Rng {\n+    @seeded_randres(seed) as @Rng\n }\n \n fn seeded_randres(seed: &[u8]) -> @RandRes {\n@@ -449,8 +449,8 @@ pub pure fn xorshift() -> Rng {\n     seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n }\n \n-pub pure fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng {\n-    XorShiftState { x: x, y: y, z: z, w: w } as Rng\n+pub pure fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> @Rng {\n+    @XorShiftState { x: x, y: y, z: z, w: w } as @Rng\n }\n \n \n@@ -472,10 +472,10 @@ pub fn task_rng() -> Rng {\n             unsafe {\n                 let rng = seeded_randres(seed());\n                 task::local_data::local_data_set(tls_rng_state, rng);\n-                rng as Rng\n+                @rng as @Rng\n             }\n         }\n-        Some(rng) => rng as Rng\n+        Some(rng) => @rng as @Rng\n     }\n }\n "}, {"sha": "af135339b2e6f71cf3d00b19ede74680639fbb43", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -201,7 +201,7 @@ pub impl ReprVisitor {\n         unsafe {\n             let mut u = ReprVisitor(ptr, self.writer);\n             let v = reflect::MovePtrAdaptor(u);\n-            visit_tydesc(inner, (v) as @TyVisitor);\n+            visit_tydesc(inner, @v as @TyVisitor);\n             true\n         }\n     }\n@@ -570,7 +570,7 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n         let tydesc = intrinsic::get_tydesc::<T>();\n         let mut u = ReprVisitor(ptr, writer);\n         let v = reflect::MovePtrAdaptor(u);\n-        visit_tydesc(tydesc, (v) as @TyVisitor)\n+        visit_tydesc(tydesc, @v as @TyVisitor)\n     }\n }\n "}, {"sha": "e8cd9caaef66859434b6e7856102f0207f6c7e3b", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -288,7 +288,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n         finished: false,\n     };\n \n-    ProgRes(repr) as Program\n+    @ProgRes(repr) as @Program\n }\n \n fn read_all(rd: io::Reader) -> ~str {"}, {"sha": "df5a5af74cabfe15a07003c72f6ef58e59b2b01d", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -155,7 +155,7 @@ pub unsafe fn local_set<T:Durable>(\n     // does not have a reference associated with it, so it may become invalid\n     // when the box is destroyed.\n     let data_ptr = cast::reinterpret_cast(&data);\n-    let data_box = data as LocalData;\n+    let data_box = @data as @LocalData;\n     // Construct new entry to store in the map.\n     let new_entry = Some((keyval, data_ptr, data_box));\n     // Find a place to put it."}, {"sha": "daf369f727991579af6189304712432f4633f71e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -132,9 +132,8 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_method_map = 0x60,\n     tag_table_vtable_map = 0x61,\n     tag_table_adjustments = 0x62,\n-    tag_table_legacy_boxed_trait = 0x63,\n-    tag_table_moves_map = 0x64,\n-    tag_table_capture_map = 0x65\n+    tag_table_moves_map = 0x63,\n+    tag_table_capture_map = 0x64\n }\n \n pub const tag_item_trait_method_sort: uint = 0x70;"}, {"sha": "1a7c7b0793a422f8cf33e419c43e1f9143345d14", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -71,11 +71,11 @@ pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n \n     let sysroot = get_sysroot(maybe_sysroot);\n     debug!(\"using sysroot = %s\", sysroot.to_str());\n-    FileSearchImpl {\n+    @FileSearchImpl {\n         sysroot: sysroot,\n         addl_lib_search_paths: addl_lib_search_paths,\n         target_triple: str::from_slice(target_triple)\n-    } as FileSearch\n+    } as @FileSearch\n }\n \n pub fn search<T:Copy>(filesearch: FileSearch, pick: pick<T>) -> Option<T> {"}, {"sha": "47e0b3d26abf891f82303deacd23fd8e87b47625", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -966,12 +966,6 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n         }\n     }\n \n-    do option::iter(&tcx.legacy_boxed_traits.find(&id)) |_x| {\n-        do ebml_w.tag(c::tag_table_legacy_boxed_trait) {\n-            ebml_w.id(id);\n-        }\n-    }\n-\n     for maps.moves_map.find(&id).each |_| {\n         do ebml_w.tag(c::tag_table_moves_map) {\n             ebml_w.id(id);\n@@ -1121,8 +1115,6 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n \n         if tag == (c::tag_table_mutbl as uint) {\n             dcx.maps.mutbl_map.insert(id, ());\n-        } else if tag == (c::tag_table_legacy_boxed_trait as uint) {\n-            dcx.tcx.legacy_boxed_traits.insert(id, ());\n         } else if tag == (c::tag_table_moves_map as uint) {\n             dcx.maps.moves_map.insert(id, ());\n         } else {\n@@ -1230,7 +1222,7 @@ impl fake_ext_ctxt for fake_session {\n \n #[cfg(test)]\n fn mk_ctxt() -> fake_ext_ctxt {\n-    parse::new_parse_sess(None) as fake_ext_ctxt\n+    @parse::new_parse_sess(None) as fake_ext_ctxt\n }\n \n #[cfg(test)]"}, {"sha": "bbc19cf86eaac5509b45512416a03147ee8e3d79", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -209,8 +209,8 @@ impl ABIInfo for LLVM_ABIInfo {\n     }\n }\n \n-pub fn llvm_abi_info() -> ABIInfo {\n-    return LLVM_ABIInfo as ABIInfo;\n+pub fn llvm_abi_info() -> @ABIInfo {\n+    return @LLVM_ABIInfo as @ABIInfo;\n }\n \n "}, {"sha": "a16b3672b7afe9e4ce7450ab04a8b86c1b42db21", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -159,6 +159,6 @@ impl ABIInfo for ARM_ABIInfo {\n     }\n }\n \n-pub fn abi_info() -> ABIInfo {\n-    return ARM_ABIInfo as ABIInfo;\n+pub fn abi_info() -> @ABIInfo {\n+    return @ARM_ABIInfo as @ABIInfo;\n }"}, {"sha": "562009dc2ca10607183f7553ecaa3139b9d3dc5d", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -408,5 +408,5 @@ impl ABIInfo for X86_64_ABIInfo {\n }\n \n pub fn x86_64_abi_info() -> ABIInfo {\n-    return X86_64_ABIInfo as ABIInfo;\n+    return @X86_64_ABIInfo as @ABIInfo;\n }"}, {"sha": "be1a3b90b4c37e235f175feabebcd650a1ebd6c8", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -870,26 +870,11 @@ pub fn trans_trait_cast(bcx: block,\n     match vstore {\n         ty::vstore_slice(*) | ty::vstore_box => {\n             let mut llboxdest = GEPi(bcx, lldest, [0u, 1u]);\n-            if bcx.tcx().legacy_boxed_traits.contains_key(&id) {\n-                // Allocate an @ box and store the value into it\n-                let MallocResult {bcx: new_bcx, box: llbox, body: body} =\n-                    malloc_boxed(bcx, v_ty);\n-                bcx = new_bcx;\n-                add_clean_free(bcx, llbox, heap_managed);\n-                bcx = expr::trans_into(bcx, val, SaveIn(body));\n-                revoke_clean(bcx, llbox);\n-\n-                // Store the @ box into the pair\n-                Store(bcx, llbox, PointerCast(bcx,\n-                                              llboxdest,\n-                                              T_ptr(val_ty(llbox))));\n-            } else {\n-                // Just store the pointer into the pair.\n-                llboxdest = PointerCast(bcx,\n-                                        llboxdest,\n-                                        T_ptr(type_of(bcx.ccx(), v_ty)));\n-                bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n-            }\n+            // Just store the pointer into the pair.\n+            llboxdest = PointerCast(bcx,\n+                                    llboxdest,\n+                                    T_ptr(type_of(bcx.ccx(), v_ty)));\n+            bcx = expr::trans_into(bcx, val, SaveIn(llboxdest));\n         }\n         ty::vstore_uniq => {\n             // Translate the uniquely-owned value into the second element of"}, {"sha": "8bca7f42b48ed424711a54e72334a446bbc91f54", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -269,7 +269,6 @@ struct ctxt_ {\n     adjustments: HashMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n-    legacy_boxed_traits: HashMap<node_id, ()>,\n     // A mapping from an implementation ID to the method info and trait\n     // method ID of the provided (a.k.a. default) methods in the traits that\n     // that implementation implements.\n@@ -831,7 +830,6 @@ pub fn mk_ctxt(s: session::Session,\n         adjustments: HashMap(),\n         normalized_cache: new_ty_hash(),\n         lang_items: lang_items,\n-        legacy_boxed_traits: HashMap(),\n         provided_methods: HashMap(),\n         provided_method_sources: HashMap(),\n         supertraits: HashMap(),"}, {"sha": "5ed247eb447a285f9083695bddfa6a5e34a2d058", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 97, "deletions": 133, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -97,8 +97,8 @@ pub fn lookup_vtables(vcx: &VtableContext,\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n         for ty::iter_bound_traits_and_supertraits(\n-            tcx, bounds[i]) |trait_ty| {\n-\n+            tcx, bounds[i]) |trait_ty|\n+        {\n             debug!(\"about to subst: %?, %?\",\n                    ppaux::ty_to_str(tcx, trait_ty),\n                    ty::substs_to_str(tcx, substs));\n@@ -585,138 +585,102 @@ pub fn early_resolve_expr(ex: @ast::expr,\n         }\n       }\n       ast::expr_cast(src, _) => {\n-        let target_ty = fcx.expr_ty(ex);\n-        match ty::get(target_ty).sty {\n-          ty::ty_trait(_, _, vstore) => {\n-            // Look up vtables for the type we're casting to, passing in the\n-            // source and target type.\n-            //\n-            // XXX: This is invariant and shouldn't be. --pcw\n-\n-            let ty = fcx.expr_ty(src);\n-            let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n-            let vtable_opt =\n-                lookup_vtable(&vcx,\n-                              &location_info_for_expr(ex),\n-                              ty,\n-                              target_ty,\n-                              true,\n-                              is_early);\n-            match vtable_opt {\n-                None => {\n-                    // Try the new-style boxed trait; \"@int as @Trait\".\n-                    // Or the new-style region trait; \"&int as &Trait\".\n-                    // Or the new-style uniquely-owned trait; \"~int as\n-                    // ~Trait\".\n-                    let mut err = false;\n-                    let ty = structurally_resolved_type(fcx, ex.span, ty);\n-                    match ty::get(ty).sty {\n-                        ty::ty_box(mt) | ty::ty_rptr(_, mt) |\n-                        ty::ty_uniq(mt) => {\n-                            // Ensure that the trait vstore and the pointer\n-                            // type match.\n-                            match (&ty::get(ty).sty, vstore) {\n-                                (&ty::ty_box(_), ty::vstore_box) |\n-                                (&ty::ty_uniq(_), ty::vstore_uniq) |\n-                                (&ty::ty_rptr(*), ty::vstore_slice(*)) => {\n-                                    let location_info =\n-                                        &location_info_for_expr(ex);\n-                                    let vtable_opt =\n-                                        lookup_vtable(&vcx,\n-                                                      location_info,\n-                                                      mt.ty,\n-                                                      target_ty,\n-                                                      true,\n-                                                      is_early);\n-                                    match vtable_opt {\n-                                        Some(vtable) => {\n-                                            // Map this expression to that\n-                                            // vtable (that is: \"ex has vtable\n-                                            // <vtable>\")\n-                                            if !is_early {\n-                                                let vtable_map =\n-                                                    cx.vtable_map;\n-                                                vtable_map.insert(ex.id,\n-                                                                  @~[vtable]);\n-                                            }\n-                                        }\n-                                        None => err = true\n-                                    }\n-\n-                                    // Now, if this is &trait, we need to link\n-                                    // the regions.\n-                                    match (&ty::get(ty).sty, vstore) {\n-                                        (&ty::ty_rptr(ra, _),\n-                                         ty::vstore_slice(rb)) => {\n-                                            infer::mk_subr(fcx.infcx(),\n-                                                           false,\n-                                                           ex.span,\n-                                                           rb,\n-                                                           ra);\n-                                        }\n-                                        _ => {}\n-                                    }\n-                                }\n-                                (&ty::ty_box(_), _) => {\n-                                    fcx.ccx.tcx.sess.span_err(ex.span,\n-                                                              ~\"must cast \\\n-                                                                a boxed \\\n-                                                                pointer to \\\n-                                                                a boxed\n-                                                                trait\");\n-                                    err = true;\n-                                }\n-                                (&ty::ty_rptr(*), _) => {\n-                                    fcx.ccx.tcx.sess.span_err(ex.span,\n-                                                              ~\"must cast \\\n-                                                                a borrowed \\\n-                                                                pointer to \\\n-                                                                a borrowed \\\n-                                                                trait\");\n-                                }\n-                                (&ty::ty_uniq(*), _) => {\n-                                    fcx.ccx.tcx.sess.span_err(ex.span,\n-                                                              ~\"must cast \\\n-                                                                a unique \\\n-                                                                pointer to \\\n-                                                                a uniquely-\\\n-                                                                owned trait\");\n-                                }\n-                                _ => {\n-                                    fcx.ccx.tcx.sess.impossible_case(\n-                                        ex.span,\n-                                        ~\"impossible combination of type and \\\n-                                          trait vstore\");\n-                                }\n-                            }\n-                        }\n-                        _ => err = true\n-                    }\n-\n-                    if err {\n-                        fcx.tcx().sess.span_fatal(\n-                            ex.span,\n-                            fmt!(\"failed to find an implementation of trait \\\n-                                  %s for %s\",\n-                                 fcx.infcx().ty_to_str(target_ty),\n-                                 fcx.infcx().ty_to_str(ty)));\n-                    }\n-                }\n-                Some(vtable) => {\n-                    /*\n-                    Map this expression to that vtable (that is: \"ex has\n-                    vtable <vtable>\")\n-                    */\n-                    if !is_early {\n-                        let vtable_map = cx.vtable_map;\n-                        vtable_map.insert(ex.id, @~[vtable]);\n-                    }\n-                    fcx.tcx().legacy_boxed_traits.insert(ex.id, ());\n-                }\n-            }\n+          let target_ty = fcx.expr_ty(ex);\n+          match ty::get(target_ty).sty {\n+              ty::ty_trait(_, _, vstore) => {\n+                  // Look up vtables for the type we're casting to,\n+                  // passing in the source and target type.  The source\n+                  // must be a pointer type suitable to the object sigil,\n+                  // e.g.: `@x as @Trait`, `&x as &Trait` or `~x as ~Trait`\n+                  let ty = structurally_resolved_type(fcx, ex.span,\n+                                                      fcx.expr_ty(src));\n+                  match (&ty::get(ty).sty, vstore) {\n+                      (&ty::ty_box(mt), ty::vstore_box) |\n+                      (&ty::ty_uniq(mt), ty::vstore_uniq) |\n+                      (&ty::ty_rptr(_, mt), ty::vstore_slice(*)) => {\n+                          let location_info =\n+                              &location_info_for_expr(ex);\n+                          let vcx = VtableContext {\n+                              ccx: fcx.ccx,\n+                              infcx: fcx.infcx()\n+                          };\n+                          let vtable_opt =\n+                              lookup_vtable(&vcx,\n+                                            location_info,\n+                                            mt.ty,\n+                                            target_ty,\n+                                            true,\n+                                            is_early);\n+                          match vtable_opt {\n+                              Some(vtable) => {\n+                                  // Map this expression to that\n+                                  // vtable (that is: \"ex has vtable\n+                                  // <vtable>\")\n+                                  if !is_early {\n+                                      let vtable_map =\n+                                          cx.vtable_map;\n+                                      vtable_map.insert(ex.id,\n+                                                        @~[vtable]);\n+                                  }\n+                              }\n+                              None => {\n+                                  fcx.tcx().sess.span_err(\n+                                      ex.span,\n+                                      fmt!(\"failed to find an implementation \\\n+                                            of trait %s for %s\",\n+                                           fcx.infcx().ty_to_str(target_ty),\n+                                           fcx.infcx().ty_to_str(mt.ty)));\n+                              }\n+                          }\n+\n+                          // Now, if this is &trait, we need to link the\n+                          // regions.\n+                          match (&ty::get(ty).sty, vstore) {\n+                              (&ty::ty_rptr(ra, _),\n+                               ty::vstore_slice(rb)) => {\n+                                  infer::mk_subr(fcx.infcx(),\n+                                                 false,\n+                                                 ex.span,\n+                                                 rb,\n+                                                 ra);\n+                              }\n+                              _ => {}\n+                          }\n+                      }\n+\n+                      (_, ty::vstore_box(*)) => {\n+                          fcx.ccx.tcx.sess.span_err(\n+                              ex.span,\n+                              fmt!(\"can only cast an @-pointer \\\n+                                    to an @-object, not a %s\",\n+                                   ty::ty_sort_str(fcx.tcx(), ty)));\n+                      }\n+\n+                      (_, ty::vstore_uniq(*)) => {\n+                          fcx.ccx.tcx.sess.span_err(\n+                              ex.span,\n+                              fmt!(\"can only cast an ~-pointer \\\n+                                    to a ~-object, not a %s\",\n+                                   ty::ty_sort_str(fcx.tcx(), ty)));\n+                      }\n+\n+                      (_, ty::vstore_slice(*)) => {\n+                          fcx.ccx.tcx.sess.span_err(\n+                              ex.span,\n+                              fmt!(\"can only cast an &-pointer \\\n+                                    to an &-object, not a %s\",\n+                                   ty::ty_sort_str(fcx.tcx(), ty)));\n+                      }\n+\n+                      (_, ty::vstore_fixed(*)) => {\n+                          fcx.tcx().sess.span_bug(\n+                              ex.span,\n+                              fmt!(\"trait with fixed vstore\"));\n+                      }\n+                  }\n+              }\n+              _ => { /* not a cast to a trait; ignore */ }\n           }\n-          _ => ()\n-        }\n       }\n       _ => ()\n     }"}, {"sha": "d82667285ff3367b90a9a932c0869b12c1de3016", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -70,11 +70,11 @@ pub fn bound_self_region(rp: Option<ty::region_variance>)\n     }\n }\n \n-pub struct anon_rscope { anon: ty::Region, base: region_scope }\n+pub struct anon_rscope { anon: ty::Region, base: @region_scope }\n pub fn in_anon_rscope<RS:region_scope + Copy + Durable>(self: RS,\n                                                         r: ty::Region)\n                                                      -> @anon_rscope {\n-    @anon_rscope {anon: r, base: self as region_scope}\n+    @anon_rscope {anon: r, base: @self as @region_scope}\n }\n \n impl region_scope for @anon_rscope {\n@@ -97,7 +97,7 @@ pub struct binding_rscope {\n \n pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: RS)\n     -> @mut binding_rscope {\n-    let base = self as region_scope;\n+    let base = @self as @region_scope;\n     @mut binding_rscope { base: base, anon_bindings: 0 }\n }\n "}, {"sha": "e8c1413e90a82fbc8211b7cd7805cc83ad5b9d16", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -63,7 +63,7 @@ const k3: u32 = 0xCA62C1D6u32;\n \n \n /// Construct a `sha` object\n-pub fn sha1() -> Sha1 {\n+pub fn sha1() -> @Sha1 {\n     struct Sha1State\n         { h: ~[u32],\n           len_low: u32,\n@@ -269,7 +269,7 @@ pub fn sha1() -> Sha1 {\n          computed: false,\n          work_buf: @mut vec::from_elem(work_buf_len, 0u32)\n     };\n-    let mut sh = (st) as Sha1;\n+    let mut sh = @st as @Sha1;\n     sh.reset();\n     return sh;\n }"}, {"sha": "5f076136271307941d1b0241980901c232e5e4ec", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -1296,7 +1296,7 @@ mod test {\n     }\n \n \n-    fn to_call_log (val: Encodable<TestEncoder>) -> ~[call] {\n+    fn to_call_log<E:Encodable<TestEncoder>>(val: E) -> ~[call] {\n         let mut te = TestEncoder {call_log: @mut ~[]};\n         val.encode(&te);\n         copy *te.call_log\n@@ -1309,8 +1309,7 @@ mod test {\n     }\n \n     #[test] fn encode_enum_test () {\n-        check_equal (to_call_log(Book(34,44)\n-                                 as Encodable::<TestEncoder>),\n+        check_equal (to_call_log(Book(34,44)),\n                      ~[CallToEmitEnum (~\"Written\"),\n                        CallToEmitEnumVariant (~\"Book\",0,2),\n                        CallToEmitEnumVariantArg (0),\n@@ -1325,8 +1324,7 @@ mod test {\n     pub struct HasPos { pos : BPos }\n \n     #[test] fn encode_newtype_test () {\n-        check_equal (to_call_log (HasPos {pos:BPos(48)}\n-                                 as Encodable::<TestEncoder>),\n+        check_equal (to_call_log (HasPos {pos:BPos(48)}),\n                     ~[CallToEmitStruct(~\"HasPos\",1),\n                       CallToEmitField(~\"pos\",0),\n                       CallToEmitUint(48)]);"}, {"sha": "eb9dd0ec03ce509f0409e61d7df4cbacd3008f48", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 113, "deletions": 108, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -19,29 +19,29 @@ use core::option;\n use core::vec;\n \n pub trait ast_fold {\n-    fn fold_crate(crate) -> crate;\n-    fn fold_view_item(&&v: @view_item) -> @view_item;\n-    fn fold_foreign_item(&&v: @foreign_item) -> @foreign_item;\n-    fn fold_item(&&v: @item) -> Option<@item>;\n-    fn fold_struct_field(&&v: @struct_field) -> @struct_field;\n-    fn fold_item_underscore(item_) -> item_;\n-    fn fold_method(&&v: @method) -> @method;\n-    fn fold_block(blk) -> blk;\n-    fn fold_stmt(&&v: @stmt) -> @stmt;\n-    fn fold_arm(arm) -> arm;\n-    fn fold_pat(&&v: @pat) -> @pat;\n-    fn fold_decl(&&v: @decl) -> @decl;\n-    fn fold_expr(&&v: @expr) -> @expr;\n-    fn fold_ty(&&v: @Ty) -> @Ty;\n-    fn fold_mod(_mod) -> _mod;\n-    fn fold_foreign_mod(foreign_mod) -> foreign_mod;\n-    fn fold_variant(variant) -> variant;\n-    fn fold_ident(&&v: ident) -> ident;\n-    fn fold_path(&&v: @path) -> @path;\n-    fn fold_local(&&v: @local) -> @local;\n-    fn map_exprs(fn@(&&v: @expr) -> @expr, ~[@expr]) -> ~[@expr];\n-    fn new_id(node_id) -> node_id;\n-    fn new_span(span) -> span;\n+    fn fold_crate(@self, crate) -> crate;\n+    fn fold_view_item(@self, &&v: @view_item) -> @view_item;\n+    fn fold_foreign_item(@self, &&v: @foreign_item) -> @foreign_item;\n+    fn fold_item(@self, &&v: @item) -> Option<@item>;\n+    fn fold_struct_field(@self, &&v: @struct_field) -> @struct_field;\n+    fn fold_item_underscore(@self, item_) -> item_;\n+    fn fold_method(@self, &&v: @method) -> @method;\n+    fn fold_block(@self, blk) -> blk;\n+    fn fold_stmt(@self, &&v: @stmt) -> @stmt;\n+    fn fold_arm(@self, arm) -> arm;\n+    fn fold_pat(@self, &&v: @pat) -> @pat;\n+    fn fold_decl(@self, &&v: @decl) -> @decl;\n+    fn fold_expr(@self, &&v: @expr) -> @expr;\n+    fn fold_ty(@self, &&v: @Ty) -> @Ty;\n+    fn fold_mod(@self, _mod) -> _mod;\n+    fn fold_foreign_mod(@self, foreign_mod) -> foreign_mod;\n+    fn fold_variant(@self, variant) -> variant;\n+    fn fold_ident(@self, &&v: ident) -> ident;\n+    fn fold_path(@self, &&v: @path) -> @path;\n+    fn fold_local(@self, &&v: @local) -> @local;\n+    fn map_exprs(@self, fn@(&&v: @expr) -> @expr, ~[@expr]) -> ~[@expr];\n+    fn new_id(@self, node_id) -> node_id;\n+    fn new_span(@self, span) -> span;\n }\n \n // We may eventually want to be able to fold over type parameters, too\n@@ -78,7 +78,7 @@ pub type ast_fold_fns = @AstFoldFns;\n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n+fn fold_meta_item_(&&mi: @meta_item, fld: @ast_fold) -> @meta_item {\n     @spanned {\n         node:\n             match mi.node {\n@@ -95,7 +95,7 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n         span: fld.new_span(mi.span) }\n }\n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(at: attribute, fld: ast_fold) -> attribute {\n+fn fold_attribute_(at: attribute, fld: @ast_fold) -> attribute {\n     spanned {\n         node: ast::attribute_ {\n             style: at.node.style,\n@@ -106,7 +106,7 @@ fn fold_attribute_(at: attribute, fld: ast_fold) -> attribute {\n     }\n }\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n-fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n+fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     ast::arg {\n         mode: a.mode,\n         is_mutbl: a.is_mutbl,\n@@ -116,56 +116,59 @@ fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n     }\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n-fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n+fn fold_mac_(m: mac, fld: @ast_fold) -> mac {\n     spanned { node: match m.node {\n                         mac_invoc_tt(*) => m.node,\n                     },\n               span: fld.new_span(m.span) }\n }\n \n-pub fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n+pub fn fold_fn_decl(decl: ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n         inputs: decl.inputs.map(|x| fold_arg_(*x, fld)),\n         output: fld.fold_ty(decl.output),\n         cf: decl.cf,\n     }\n }\n \n-fn fold_ty_param_bound(tpb: TyParamBound, fld: ast_fold) -> TyParamBound {\n+fn fold_ty_param_bound(tpb: TyParamBound,\n+                       fld: @ast_fold) -> TyParamBound {\n     match tpb {\n         TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_ty(ty)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n \n-pub fn fold_ty_param(tp: TyParam, fld: ast_fold) -> TyParam {\n+pub fn fold_ty_param(tp: TyParam,\n+                     fld: @ast_fold) -> TyParam {\n     TyParam {ident: tp.ident,\n              id: fld.new_id(tp.id),\n              bounds: @tp.bounds.map(|x| fold_ty_param_bound(*x, fld))}\n }\n \n pub fn fold_ty_params(tps: &OptVec<TyParam>,\n-                      fld: ast_fold) -> OptVec<TyParam> {\n+                      fld: @ast_fold) -> OptVec<TyParam> {\n     tps.map(|tp| fold_ty_param(*tp, fld))\n }\n \n-pub fn fold_lifetime(l: &Lifetime, fld: ast_fold) -> Lifetime {\n+pub fn fold_lifetime(l: &Lifetime,\n+                     fld: @ast_fold) -> Lifetime {\n     Lifetime {id: fld.new_id(l.id),\n               span: fld.new_span(l.span),\n               ident: l.ident}\n }\n \n pub fn fold_lifetimes(lts: &OptVec<Lifetime>,\n-                      fld: ast_fold) -> OptVec<Lifetime> {\n+                      fld: @ast_fold) -> OptVec<Lifetime> {\n     lts.map(|l| fold_lifetime(l, fld))\n }\n \n-pub fn fold_generics(generics: &Generics, fld: ast_fold) -> Generics {\n+pub fn fold_generics(generics: &Generics, fld: @ast_fold) -> Generics {\n     Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n-pub fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n+pub fn noop_fold_crate(c: crate_, fld: @ast_fold) -> crate_ {\n     let fold_meta_item = |x| fold_meta_item_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n@@ -176,12 +179,12 @@ pub fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     }\n }\n \n-fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n+fn noop_fold_view_item(vi: view_item_, _fld: @ast_fold) -> view_item_ {\n     return /* FIXME (#2543) */ copy vi;\n }\n \n \n-fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n+fn noop_fold_foreign_item(&&ni: @foreign_item, fld: @ast_fold)\n     -> @foreign_item {\n     let fold_arg = |x| fold_arg_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n@@ -211,7 +214,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n     }\n }\n \n-pub fn noop_fold_item(&&i: @item, fld: ast_fold) -> Option<@item> {\n+pub fn noop_fold_item(&&i: @item, fld: @ast_fold) -> Option<@item> {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     Some(@ast::item { ident: fld.fold_ident(i.ident),\n@@ -222,15 +225,15 @@ pub fn noop_fold_item(&&i: @item, fld: ast_fold) -> Option<@item> {\n                       span: fld.new_span(i.span) })\n }\n \n-fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n+fn noop_fold_struct_field(&&sf: @struct_field, fld: @ast_fold)\n                        -> @struct_field {\n     @spanned { node: ast::struct_field_ { kind: copy sf.node.kind,\n                                           id: sf.node.id,\n                                           ty: fld.fold_ty(sf.node.ty) },\n                span: sf.span }\n }\n \n-pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n+pub fn noop_fold_item_underscore(i: item_, fld: @ast_fold) -> item_ {\n     match i {\n         item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n         item_fn(ref decl, purity, ref typms, ref body) => {\n@@ -281,7 +284,7 @@ pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n     }\n }\n \n-fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n+fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n                 -> @ast::struct_def {\n     let dtor = do option::map(&struct_def.dtor) |dtor| {\n         let dtor_body = fld.fold_block(dtor.node.body);\n@@ -298,21 +301,21 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n     }\n }\n \n-fn fold_trait_ref(&&p: @trait_ref, fld: ast_fold) -> @trait_ref {\n+fn fold_trait_ref(&&p: @trait_ref, fld: @ast_fold) -> @trait_ref {\n     @ast::trait_ref {\n         path: fld.fold_path(p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-fn fold_struct_field(&&f: @struct_field, fld: ast_fold) -> @struct_field {\n+fn fold_struct_field(&&f: @struct_field, fld: @ast_fold) -> @struct_field {\n     @spanned { node: ast::struct_field_ { kind: copy f.node.kind,\n                                           id: fld.new_id(f.node.id),\n                                           ty: fld.fold_ty(f.node.ty) },\n                span: fld.new_span(f.span) }\n }\n \n-fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n+fn noop_fold_method(&&m: @method, fld: @ast_fold) -> @method {\n     @ast::method {\n         ident: fld.fold_ident(m.ident),\n         attrs: /* FIXME (#2543) */ copy m.attrs,\n@@ -329,7 +332,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n }\n \n \n-pub fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n+pub fn noop_fold_block(b: blk_, fld: @ast_fold) -> blk_ {\n     ast::blk_ {\n         view_items: b.view_items.map(|x| fld.fold_view_item(*x)),\n         stmts: b.stmts.map(|x| fld.fold_stmt(*x)),\n@@ -339,7 +342,7 @@ pub fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n     }\n }\n \n-fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n+fn noop_fold_stmt(s: stmt_, fld: @ast_fold) -> stmt_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n     return match s {\n       stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n@@ -349,15 +352,15 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n     };\n }\n \n-fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n+fn noop_fold_arm(a: arm, fld: @ast_fold) -> arm {\n     arm {\n         pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n         guard: option::map(&a.guard, |x| fld.fold_expr(*x)),\n         body: fld.fold_block(a.body),\n     }\n }\n \n-pub fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n+pub fn noop_fold_pat(p: pat_, fld: @ast_fold) -> pat_ {\n     return match p {\n           pat_wild => pat_wild,\n           pat_ident(binding_mode, pth, sub) => {\n@@ -403,7 +406,7 @@ pub fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n         };\n }\n \n-fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n+fn noop_fold_decl(d: decl_, fld: @ast_fold) -> decl_ {\n     match d {\n       decl_local(ls) => decl_local(vec::map(ls, |x| fld.fold_local(*x))),\n       decl_item(it) => match fld.fold_item(it) {\n@@ -416,13 +419,13 @@ fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n pub fn wrap<T>(f: fn@(T, ast_fold) -> T)\n     -> fn@(T, span, ast_fold) -> (T, span)\n {\n-    return fn@(x: T, s: span, fld: ast_fold) -> (T, span) {\n+    return fn@(x: T, s: span, fld: @ast_fold) -> (T, span) {\n         (f(x, fld), s)\n     }\n }\n \n-pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n-    fn fold_field_(field: field, fld: ast_fold) -> field {\n+pub fn noop_fold_expr(e: expr_, fld: @ast_fold) -> expr_ {\n+    fn fold_field_(field: field, fld: @ast_fold) -> field {\n         spanned {\n             node: ast::field_ {\n                 mutbl: field.node.mutbl,\n@@ -533,12 +536,12 @@ pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n         }\n }\n \n-pub fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n+pub fn noop_fold_ty(t: ty_, fld: @ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n-    fn fold_mt(mt: mt, fld: ast_fold) -> mt {\n+    fn fold_mt(mt: mt, fld: @ast_fold) -> mt {\n         mt { ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl }\n     }\n-    fn fold_field(f: ty_field, fld: ast_fold) -> ty_field {\n+    fn fold_field(f: ty_field, fld: @ast_fold) -> ty_field {\n         spanned {\n             node: ast::ty_field_ {\n                 ident: fld.fold_ident(f.node.ident),\n@@ -579,14 +582,14 @@ pub fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n }\n \n // ...nor do modules\n-pub fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n+pub fn noop_fold_mod(m: _mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n         view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n         items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n     }\n }\n \n-fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {\n+fn noop_fold_foreign_mod(nm: foreign_mod, fld: @ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n         abi: nm.abi,\n@@ -595,8 +598,8 @@ fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {\n     }\n }\n \n-fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n-    fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n+fn noop_fold_variant(v: variant_, fld: @ast_fold) -> variant_ {\n+    fn fold_variant_arg_(va: variant_arg, fld: @ast_fold) -> variant_arg {\n         ast::variant_arg { ty: fld.fold_ty(va.ty), id: fld.new_id(va.id) }\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n@@ -654,19 +657,19 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     }\n }\n \n-fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n+fn noop_fold_ident(&&i: ident, _fld: @ast_fold) -> ident {\n     return /* FIXME (#2543) */ copy i;\n }\n \n-fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n+fn noop_fold_path(&&p: path, fld: @ast_fold) -> path {\n     ast::path { span: fld.new_span(p.span),\n                 global: p.global,\n                 idents: p.idents.map(|x| fld.fold_ident(*x)),\n                 rp: p.rp,\n                 types: p.types.map(|x| fld.fold_ty(*x)) }\n }\n \n-fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n+fn noop_fold_local(l: local_, fld: @ast_fold) -> local_ {\n     local_ {\n         is_mutbl: l.is_mutbl,\n         ty: fld.fold_ty(l.ty),\n@@ -712,116 +715,118 @@ pub fn default_ast_fold() -> ast_fold_fns {\n           new_span: noop_span};\n }\n \n-impl ast_fold for ast_fold_fns {\n+impl ast_fold for AstFoldFns {\n     /* naturally, a macro to write these would be nice */\n-    fn fold_crate(c: crate) -> crate {\n-        let (n, s) = (self.fold_crate)(c.node, c.span, self as ast_fold);\n+    fn fold_crate(@self, c: crate) -> crate {\n+        let (n, s) = (self.fold_crate)(c.node, c.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_view_item(&&x: @view_item) ->\n+    fn fold_view_item(@self, &&x: @view_item) ->\n        @view_item {\n         @ast::view_item {\n-            node: (self.fold_view_item)(x.node, self as ast_fold),\n+            node: (self.fold_view_item)(x.node, self as @ast_fold),\n             attrs: vec::map(x.attrs, |a|\n-                  fold_attribute_(*a, self as ast_fold)),\n+                  fold_attribute_(*a, self as @ast_fold)),\n             vis: x.vis,\n             span: (self.new_span)(x.span),\n         }\n     }\n-    fn fold_foreign_item(&&x: @foreign_item)\n+    fn fold_foreign_item(@self, &&x: @foreign_item)\n         -> @foreign_item {\n-        return (self.fold_foreign_item)(x, self as ast_fold);\n+        return (self.fold_foreign_item)(x, self as @ast_fold);\n     }\n-    fn fold_item(&&i: @item) -> Option<@item> {\n-        return (self.fold_item)(i, self as ast_fold);\n+    fn fold_item(@self, &&i: @item) -> Option<@item> {\n+        return (self.fold_item)(i, self as @ast_fold);\n     }\n-    fn fold_struct_field(&&sf: @struct_field) -> @struct_field {\n+    fn fold_struct_field(@self, &&sf: @struct_field) -> @struct_field {\n         @spanned {\n             node: ast::struct_field_ {\n                 kind: copy sf.node.kind,\n                 id: sf.node.id,\n-                ty: (self as ast_fold).fold_ty(sf.node.ty),\n+                ty: (self as @ast_fold).fold_ty(sf.node.ty),\n             },\n             span: (self.new_span)(sf.span),\n         }\n     }\n-    fn fold_item_underscore(i: item_) ->\n+    fn fold_item_underscore(@self, i: item_) ->\n        item_ {\n-        return (self.fold_item_underscore)(i, self as ast_fold);\n+        return (self.fold_item_underscore)(i, self as @ast_fold);\n     }\n-    fn fold_method(&&x: @method)\n+    fn fold_method(@self, &&x: @method)\n         -> @method {\n-        return (self.fold_method)(x, self as ast_fold);\n+        return (self.fold_method)(x, self as @ast_fold);\n     }\n-    fn fold_block(x: blk) -> blk {\n-        let (n, s) = (self.fold_block)(x.node, x.span, self as ast_fold);\n+    fn fold_block(@self, x: blk) -> blk {\n+        let (n, s) = (self.fold_block)(x.node, x.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_stmt(&&x: @stmt) -> @stmt {\n-        let (n, s) = (self.fold_stmt)(x.node, x.span, self as ast_fold);\n+    fn fold_stmt(@self, &&x: @stmt) -> @stmt {\n+        let (n, s) = (self.fold_stmt)(x.node, x.span, self as @ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_arm(x: arm) -> arm {\n-        return (self.fold_arm)(x, self as ast_fold);\n+    fn fold_arm(@self, x: arm) -> arm {\n+        return (self.fold_arm)(x, self as @ast_fold);\n     }\n-    fn fold_pat(&&x: @pat) -> @pat {\n-        let (n, s) =  (self.fold_pat)(x.node, x.span, self as ast_fold);\n+    fn fold_pat(@self, &&x: @pat) -> @pat {\n+        let (n, s) =  (self.fold_pat)(x.node, x.span, self as @ast_fold);\n         @pat {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_decl(&&x: @decl) -> @decl {\n-        let (n, s) = (self.fold_decl)(x.node, x.span, self as ast_fold);\n+    fn fold_decl(@self, &&x: @decl) -> @decl {\n+        let (n, s) = (self.fold_decl)(x.node, x.span, self as @ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_expr(&&x: @expr) -> @expr {\n-        let (n, s) = (self.fold_expr)(x.node, x.span, self as ast_fold);\n+    fn fold_expr(@self, &&x: @expr) -> @expr {\n+        let (n, s) = (self.fold_expr)(x.node, x.span, self as @ast_fold);\n         @expr {\n             id: (self.new_id)(x.id),\n             callee_id: (self.new_id)(x.callee_id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_ty(&&x: @Ty) -> @Ty {\n-        let (n, s) = (self.fold_ty)(x.node, x.span, self as ast_fold);\n+    fn fold_ty(@self, &&x: @Ty) -> @Ty {\n+        let (n, s) = (self.fold_ty)(x.node, x.span, self as @ast_fold);\n         @Ty {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_mod(x: _mod) -> _mod {\n-        return (self.fold_mod)(x, self as ast_fold);\n+    fn fold_mod(@self, x: _mod) -> _mod {\n+        return (self.fold_mod)(x, self as @ast_fold);\n     }\n-    fn fold_foreign_mod(x: foreign_mod) ->\n+    fn fold_foreign_mod(@self, x: foreign_mod) ->\n        foreign_mod {\n-        return (self.fold_foreign_mod)(x, self as ast_fold);\n+        return (self.fold_foreign_mod)(x, self as @ast_fold);\n     }\n-    fn fold_variant(x: variant) ->\n+    fn fold_variant(@self, x: variant) ->\n        variant {\n-        let (n, s) = (self.fold_variant)(x.node, x.span, self as ast_fold);\n+        let (n, s) = (self.fold_variant)(x.node, x.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_ident(&&x: ident) -> ident {\n-        return (self.fold_ident)(x, self as ast_fold);\n+    fn fold_ident(@self, &&x: ident) -> ident {\n+        return (self.fold_ident)(x, self as @ast_fold);\n     }\n-    fn fold_path(&&x: @path) -> @path {\n-        @(self.fold_path)(*x, self as ast_fold)\n+    fn fold_path(@self, &&x: @path) -> @path {\n+        @(self.fold_path)(*x, self as @ast_fold)\n     }\n-    fn fold_local(&&x: @local) -> @local {\n-        let (n, s) = (self.fold_local)(x.node, x.span, self as ast_fold);\n+    fn fold_local(@self, &&x: @local) -> @local {\n+        let (n, s) = (self.fold_local)(x.node, x.span, self as @ast_fold);\n         @spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn map_exprs(f: fn@(&&v: @expr) -> @expr, e: ~[@expr]) -> ~[@expr] {\n+    fn map_exprs(@self,\n+                 f: fn@(&&v: @expr) -> @expr,\n+                 e: ~[@expr]) -> ~[@expr] {\n         (self.map_exprs)(f, e)\n     }\n-    fn new_id(node_id: ast::node_id) -> node_id {\n+    fn new_id(@self, node_id: ast::node_id) -> node_id {\n         (self.new_id)(node_id)\n     }\n-    fn new_span(span: span) -> span {\n+    fn new_span(@self, span: span) -> span {\n         (self.new_span)(span)\n     }\n }\n@@ -833,7 +838,7 @@ pub impl ast_fold {\n }\n \n pub fn make_fold(afp: ast_fold_fns) -> ast_fold {\n-    afp as ast_fold\n+    afp as @ast_fold\n }\n \n //"}, {"sha": "923bc738cf0deb7dc60289f6c414f50d55aadaaa", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -251,7 +251,7 @@ mod test {\n             @~\"fn foo (x : int) { x; }\",\n             ~[],\n             new_parse_sess(None));\n-        check_equal(to_json_str(tts as Encodable::<std::json::Encoder>),\n+        check_equal(to_json_str(@tts as Encodable::<std::json::Encoder>),\n                     ~\"[[\\\"tt_tok\\\",[,[\\\"IDENT\\\",[\\\"fn\\\",false]]]],\\\n                       [\\\"tt_tok\\\",[,[\\\"IDENT\\\",[\\\"foo\\\",false]]]],\\\n                       [\\\"tt_delim\\\",[[[\\\"tt_tok\\\",[,[\\\"LPAREN\\\",[]]]],\\"}, {"sha": "afe7d4a6e8b2c655cdae2bb6477ebcfcd8e2162b", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -16,5 +16,5 @@ pub trait i<T> { }\n pub fn f<T>() -> i<T> {\n     impl<T> i<T> for () { }\n \n-    () as i::<T>\n+    @() as @i<T>\n }"}, {"sha": "a52b7889017cc20194254caa5321a8be55c74082", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -112,7 +112,7 @@ fn writer(path: ~str, pport: comm::Port<Line>, size: uint)\n {\n     let cout: io::Writer = match path {\n         ~\"\" => {\n-            Devnull as io::Writer\n+            @Devnull as @io::Writer\n         }\n         ~\"-\" => {\n             io::stdout()"}, {"sha": "092fb4a5b6675c2f34ff19db1f309c0e32d43713", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -58,6 +58,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n fn main() {\n-  let nyan : noisy  = cat(0, 2, ~\"nyan\") as noisy;\n+  let nyan : noisy  = @cat(0, 2, ~\"nyan\") as @noisy;\n   nyan.eat(); //~ ERROR type `@noisy` does not implement any method in scope named `eat`\n }"}, {"sha": "f369e765d694772de6918435d52fa0012ff7f1bd", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -16,7 +16,7 @@ impl<A:Copy> repeat<A> for @A {\n \n fn repeater<A:Copy>(v: @A) -> repeat<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n-    v as repeat::<A> // No\n+    @v as repeat::<A> // No\n }\n \n fn main() {"}, {"sha": "2e0f27748619571fa07dda7d08261b4a29b2b793", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -26,22 +26,22 @@ fn to_foo<T:Copy>(t: T) {\n     // the fn body itself.\n     let v = &3;\n     struct F<T> { f: T }\n-    let x = F {f:t} as foo;\n+    let x = @F {f:t} as foo;\n     assert x.foo(v) == 3;\n }\n \n fn to_foo_2<T:Copy>(t: T) -> foo {\n     // Not OK---T may contain borrowed ptrs and it is going to escape\n     // as part of the returned foo value\n     struct F<T> { f: T }\n-    F {f:t} as foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n+    @F {f:t} as foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n }\n \n fn to_foo_3<T:Copy + &static>(t: T) -> foo {\n     // OK---T may escape as part of the returned foo value, but it is\n     // owned and hence does not contain borrowed ptrs\n     struct F<T> { f: T }\n-    F {f:t} as foo\n+    @F {f:t} as foo\n }\n \n fn main() {"}, {"sha": "30f6a5f9b2dd732709d709d31574408c747494c7", "filename": "src/test/compile-fail/kindck-owned-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -11,11 +11,11 @@\n trait foo { fn foo(); }\n \n fn to_foo<T:Copy + foo>(t: T) -> foo {\n-    t as foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n+    @t as @foo //~ ERROR value may contain borrowed pointers; use `&static` bound\n }\n \n fn to_foo2<T:Copy + foo + &static>(t: T) -> foo {\n-    t as foo\n+    @t as @foo\n }\n \n fn main() {}"}, {"sha": "8512e8d13dc79a9bbe0a1f9d3a5ee0e3d9d0bc1f", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -14,8 +14,8 @@ use core::hashmap::linear::LinearMap;\n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: Map<~str, ~str> = LinearMap::new::<~str, ~str>() as\n+    let x: @Map<~str, ~str> = @LinearMap::new::<~str, ~str>() as\n         Map::<~str, ~str>;\n-    let y: Map<uint, ~str> = x;\n+    let y: @Map<uint, ~str> = @x;\n     //~^ ERROR mismatched types: expected `@core::container::Map/&<uint,~str>`\n }"}, {"sha": "811d7c452e38666b5173eeb658893cbdd92a7c12", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -34,5 +34,5 @@ fn get_v(gc: get_ctxt) -> uint {\n fn main() {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n-    assert get_v(hc as get_ctxt) == 22u;\n+    assert get_v(@hc as get_ctxt) == 22u;\n }"}, {"sha": "c5978e55fb3e404a1f96db60ec21d2df08506e2f", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -23,7 +23,7 @@ impl get_ctxt for has_ctxt {\n fn make_gc() -> get_ctxt  {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt }; //~ ERROR illegal borrow\n-    return hc as get_ctxt;\n+    return @hc as get_ctxt;\n }\n \n fn main() {"}, {"sha": "0ddaf25710c94ec16c697e07ab604232a7f0a8e7", "filename": "src/test/compile-fail/regions-trait-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -17,7 +17,7 @@ fn make_gc1(gc: get_ctxt/&a) -> get_ctxt/&b  {\n }\n \n fn make_gc2(gc: get_ctxt/&a) -> get_ctxt/&b  {\n-    return gc as get_ctxt; //~ ERROR cannot infer an appropriate lifetime\n+    return @gc as get_ctxt; //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "08b6c0f71fe6e34134601a1755b7ebfa67c7f49e", "filename": "src/test/compile-fail/selftype-astparam.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-astparam.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -19,7 +19,7 @@ impl add for int {\n fn do_add<A:add>(x: A, y: A) -> A { x.plus(y) }\n \n fn main() {\n-    let x = 3 as add;\n-    let y = 4 as add;\n+    let x = @3 as @add;\n+    let y = @4 as @add;\n     do_add(x, y); //~ ERROR a boxed trait with self types may not be passed as a bounded type\n }"}, {"sha": "94bcea8f1d3bfc989c40704f73bf28e3474afbe4", "filename": "src/test/compile-fail/tps-invariant-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -34,7 +34,7 @@ fn set_box_impl<T>(b: box_impl<@const T>, v: @const T) {\n \n fn main() {\n     let b = box_impl::<@int>(box::<@int> {f: @3});\n-    set_box_trait(b as box_trait::<@int>, @mut 5);\n+    set_box_trait(@b as box_trait::<@int>, @mut 5);\n     //~^ ERROR values differ in mutability\n     set_box_impl(b, @mut 5);\n     //~^ ERROR values differ in mutability"}, {"sha": "d0738be09c7cdb48cd652c281dafe2090604f949", "filename": "src/test/compile-fail/trait-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-cast.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -11,7 +11,7 @@\n trait foo<T> { }\n \n fn bar(x: foo<uint>) -> foo<int> {\n-    return (x as foo::<int>);\n+    return (@x as foo::<int>);\n     //~^ ERROR mismatched types: expected `@foo<int>` but found `@foo<uint>`\n     //~^^ ERROR mismatched types: expected `@foo<int>` but found `@foo<uint>`\n     // This is unfortunate -- new handling of parens means the error message"}, {"sha": "a00e63b60d7d52156749fd50d8a12c97a1377a5d", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -15,5 +15,5 @@ impl bar for uint { fn dup() -> uint { self } fn blah<X>() {} }\n fn main() {\n     10i.dup::<int>(); //~ ERROR does not take type parameters\n     10i.blah::<int, int>(); //~ ERROR incorrect number of type parameters\n-    (10 as bar).dup(); //~ ERROR contains a self-type\n+    (@10 as bar).dup(); //~ ERROR contains a self-type\n }"}, {"sha": "905670f8fb7b67beba0f16fcf54e4012eb167a86", "filename": "src/test/run-fail/unwind-box-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-fail%2Funwind-box-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-fail%2Funwind-box-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-trait.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -23,7 +23,7 @@ impl i for ~int {\n }\n \n fn main() {\n-    let x = ~0 as i;\n+    let x = @~0 as @i;\n     failfn();\n     log(error, x);\n }"}, {"sha": "bfde19993e9e0a757c43d74d2a7914b6f60a4b7c", "filename": "src/test/run-pass/autoderef-method-on-trait-monomorphized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait-monomorphized.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -21,6 +21,6 @@ fn is_equal<D:double>(x: @D, exp: uint) {\n }\n \n pub fn main() {\n-    let x = @(3u as double);\n+    let x = @(@3u as @double);\n     is_equal(x, 6);\n }"}, {"sha": "65a274d7764576b2293c05a3844b70c750ec01ba", "filename": "src/test/run-pass/autoderef-method-on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -17,6 +17,6 @@ impl double for uint {\n }\n \n pub fn main() {\n-    let x = @(3u as double);\n+    let x = @(@3u as @double);\n     assert x.double() == 6u;\n }"}, {"sha": "1d2c30108f1d554988443a1cf7fdfb7f33c809b3", "filename": "src/test/run-pass/boxed-trait-with-vstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fboxed-trait-with-vstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fboxed-trait-with-vstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fboxed-trait-with-vstore.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -19,7 +19,7 @@ impl Foo for int {\n }\n \n pub fn main() {\n-    let x = 3 as @Foo;\n+    let x = @3 as @Foo;\n     x.foo();\n }\n "}, {"sha": "1db3d4b38d7978db70acf38b9ffd57d69b5985c9", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -21,7 +21,7 @@ fn print_out<T:ToStr>(thing: T, expected: ~str) {\n }\n \n pub fn main() {\n-  let nyan : ToStr  = cat(0u, 2, ~\"nyan\") as ToStr;\n+  let nyan : @ToStr = @cat(0u, 2, ~\"nyan\") as @ToStr;\n   print_out(nyan, ~\"nyan\");\n }\n "}, {"sha": "5cf68174075fac58fd886ab8965fad8e2f95a3f6", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -86,8 +86,8 @@ fn annoy_neighbors<T:noisy>(critter: T) {\n pub fn main() {\n   let nyan : cat  = cat(0u, 2, ~\"nyan\");\n   let whitefang : dog = dog();\n-  annoy_neighbors((copy nyan) as noisy);\n-  annoy_neighbors((copy whitefang) as noisy);\n+  annoy_neighbors(@(copy nyan) as @noisy);\n+  annoy_neighbors(@(copy whitefang) as @noisy);\n   assert(nyan.meow_count() == 10u);\n   assert(*whitefang.volume == 1);\n }"}, {"sha": "a15afa60c7522367434a9d7b09d45c372e6848a2", "filename": "src/test/run-pass/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -56,6 +56,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n \n \n pub fn main() {\n-  let mut nyan: noisy = cat(0u, 2, ~\"nyan\") as noisy;\n+  let mut nyan: @noisy = @cat(0u, 2, ~\"nyan\") as @noisy;\n   nyan.speak();\n }"}, {"sha": "b232be3255025ef7e6145ad507fc3a897538dfb5", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -63,6 +63,6 @@ fn print_out<T:ToStr>(thing: T, expected: ~str) {\n }\n \n pub fn main() {\n-  let mut nyan : ToStr = cat(0u, 2, ~\"nyan\") as ToStr;\n+  let mut nyan : @ToStr = @cat(0u, 2, ~\"nyan\") as @ToStr;\n   print_out(nyan, ~\"nyan\");\n }"}, {"sha": "92f745d7d5384da040b970c6207362cfa52cc92b", "filename": "src/test/run-pass/explicit-self-objects-ext-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -34,6 +34,6 @@ impl Reader for S {\n \n pub fn main() {\n     let x = S { x: 1, y: 2 };\n-    let x = x as @Reader;\n+    let x = @x as @Reader;\n     x.read_bytes(0);\n }"}, {"sha": "92f745d7d5384da040b970c6207362cfa52cc92b", "filename": "src/test/run-pass/explicit-self-objects-ext-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -34,6 +34,6 @@ impl Reader for S {\n \n pub fn main() {\n     let x = S { x: 1, y: 2 };\n-    let x = x as @Reader;\n+    let x = @x as @Reader;\n     x.read_bytes(0);\n }"}, {"sha": "2cfd327dc4e5388edc00e107179f28d7d7dbf53c", "filename": "src/test/run-pass/explicit-self-objects-ext-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -34,6 +34,6 @@ impl Reader for S {\n \n pub fn main() {\n     let x = S { x: 1, y: 2 };\n-    let x = x as @Reader;\n+    let x = @x as @Reader;\n     x.read_bytes(0);\n }"}, {"sha": "3945be779041defc34a9f394023067ddc81b5227", "filename": "src/test/run-pass/explicit-self-objects-ext-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -34,6 +34,6 @@ impl Reader for S {\n \n pub fn main() {\n     let x = S { x: 1, y: 2 };\n-    let x = x as @Reader;\n+    let x = @x as @Reader;\n     x.read_bytes(0);\n }"}, {"sha": "85ed524118b4f004209b4231e8ccb0f14c2c1e8b", "filename": "src/test/run-pass/issue-2288.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2288.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -33,6 +33,6 @@ fn f<A:Copy>(x: clam<A>, a: A) {\n pub fn main() {\n \n   let c = foo(42);\n-  let d: clam<int> = c as clam::<int>;\n+  let d: clam<int> = @c as clam::<int>;\n   f(d, c.x);\n }"}, {"sha": "a76d2242b402c0a4de9b16b9f94f008c945ec526", "filename": "src/test/run-pass/issue-2734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2734.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -12,7 +12,7 @@ trait hax { }\n impl<A> hax for A { } \n \n fn perform_hax<T:&static>(x: @T) -> hax {\n-    x as hax \n+    @x as @hax\n }\n \n fn deadcode() {"}, {"sha": "14e27dce63d15b0f079c3c7f5fc660524be94641", "filename": "src/test/run-pass/issue-2735.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait hax { } \n-impl<A> hax for A { } \n+trait hax { }\n+impl<A> hax for A { }\n \n fn perform_hax<T:&static>(x: @T) -> hax {\n-    x as hax \n+    @x as @hax\n }\n \n fn deadcode() {"}, {"sha": "3ed7d2f842d12b77adfea305036aa95b3fba7e3c", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -60,7 +60,7 @@ fn square_from_char(c: char) -> square {\n }\n \n fn read_board_grid<rdr: &static + io::Reader>(+in: rdr) -> ~[~[square]] {\n-    let in = (in) as io::Reader;\n+    let in = @in as @io::Reader;\n     let mut grid = ~[];\n     for in.each_line |line| {\n         let mut row = ~[];"}, {"sha": "64af4de46a242766276765844151462aa6f5fd52", "filename": "src/test/run-pass/issue-2935.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-2935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2935.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n   //   let y = @({a: 4i});\n   //    let z = @({a: 4i} as it);\n   //    let z = @({a: true} as it);\n-    let z = @(true as it);\n+    let z = @(@true as it);\n     //  x.f();\n     // y.f();\n     // (*z).f();"}, {"sha": "bfde19993e9e0a757c43d74d2a7914b6f60a4b7c", "filename": "src/test/run-pass/issue-3305.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-3305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fissue-3305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3305.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -21,6 +21,6 @@ fn is_equal<D:double>(x: @D, exp: uint) {\n }\n \n pub fn main() {\n-    let x = @(3u as double);\n+    let x = @(@3u as @double);\n     is_equal(x, 6);\n }"}, {"sha": "0ef09d396634315c740055434aee2fbb48aa391c", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -16,7 +16,7 @@ impl<A:Copy> repeat<A> for @A {\n \n fn repeater<A:Copy>(v: @A) -> repeat<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n-    v as repeat::<A> // No\n+    @v as repeat::<A> // No\n }\n \n pub fn main() {"}, {"sha": "c472e5305840503a957e109f0b24f7ce50cd4e02", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -489,7 +489,7 @@ pub impl my_visitor {\n         unsafe {\n             let u = my_visitor(*self);\n             let v = ptr_visit_adaptor::<my_visitor>(Inner {inner: u});\n-            visit_tydesc(inner, v as TyVisitor);\n+            visit_tydesc(inner, @v as @TyVisitor);\n             true\n         }\n     }\n@@ -644,7 +644,7 @@ pub fn main() {\n         let td = get_tydesc_for(r);\n         unsafe { error!(\"tydesc sz: %u, align: %u\",\n                         (*td).size, (*td).align); }\n-        let v = v as TyVisitor;\n+        let v = @v as @TyVisitor;\n         visit_tydesc(td, v);\n \n         for (copy u.vals).each |s| {"}, {"sha": "2b9930778b2490ba37cb2eed6c933ea6b04c6911", "filename": "src/test/run-pass/regions-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ecb672d7f526cf2cda2d62c04106196ad57d7db/src%2Ftest%2Frun-pass%2Fregions-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-trait.rs?ref=4ecb672d7f526cf2cda2d62c04106196ad57d7db", "patch": "@@ -30,5 +30,5 @@ pub fn main() {\n     let ctxt = Ctxt { v: 22 };\n     let hc = HasCtxt { c: &ctxt };\n \n-    assert get_v(hc as get_ctxt) == 22;\n+    assert get_v(@hc as @get_ctxt) == 22;\n }"}]}