{"sha": "3698d04fefaa72a1418986aede9cc1d05b6b899b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2OThkMDRmZWZhYTcyYTE0MTg5ODZhZWRlOWNjMWQwNWI2Yjg5OWI=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-17T23:25:39Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-28T14:06:52Z"}, "message": "Pass current qualification state in a separate parameter", "tree": {"sha": "de80092ea6daa111f6f42b3169c69e5c48a11b22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de80092ea6daa111f6f42b3169c69e5c48a11b22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3698d04fefaa72a1418986aede9cc1d05b6b899b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3698d04fefaa72a1418986aede9cc1d05b6b899b", "html_url": "https://github.com/rust-lang/rust/commit/3698d04fefaa72a1418986aede9cc1d05b6b899b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3698d04fefaa72a1418986aede9cc1d05b6b899b/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "908dcb80b7e828ad7ecb312388533b9996281293", "url": "https://api.github.com/repos/rust-lang/rust/commits/908dcb80b7e828ad7ecb312388533b9996281293", "html_url": "https://github.com/rust-lang/rust/commit/908dcb80b7e828ad7ecb312388533b9996281293"}], "stats": {"total": 61, "additions": 36, "deletions": 25}, "files": [{"sha": "232a5401d73fae5cc6906086cf7281c479708b26", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3698d04fefaa72a1418986aede9cc1d05b6b899b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3698d04fefaa72a1418986aede9cc1d05b6b899b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=3698d04fefaa72a1418986aede9cc1d05b6b899b", "patch": "@@ -40,21 +40,18 @@ pub trait Qualif {\n         Self::in_any_value_of_ty(cx, ty).unwrap_or(true)\n     }\n \n-    fn in_local(cx: &ConstCx<'_, '_>, local: Local) -> bool {\n-        cx.per_local.0[Self::IDX].contains(local)\n-    }\n-\n     fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n         // FIXME(eddyb) should we do anything here for value properties?\n         false\n     }\n \n     fn in_projection_structurally(\n         cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n         if let [proj_base @ .., elem] = place.projection {\n-            let base_qualif = Self::in_place(cx, PlaceRef {\n+            let base_qualif = Self::in_place(cx, per_local, PlaceRef {\n                 base: place.base,\n                 projection: proj_base,\n             });\n@@ -71,7 +68,7 @@ pub trait Qualif {\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Downcast(..) => qualif,\n \n-                ProjectionElem::Index(local) => qualif || Self::in_local(cx, *local),\n+                ProjectionElem::Index(local) => qualif || per_local.contains(*local),\n             }\n         } else {\n             bug!(\"This should be called if projection is not empty\");\n@@ -80,17 +77,22 @@ pub trait Qualif {\n \n     fn in_projection(\n         cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n-        Self::in_projection_structurally(cx, place)\n+        Self::in_projection_structurally(cx, per_local, place)\n     }\n \n-    fn in_place(cx: &ConstCx<'_, 'tcx>, place: PlaceRef<'_, 'tcx>) -> bool {\n+    fn in_place(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n+        place: PlaceRef<'_, 'tcx>,\n+    ) -> bool {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n-            } => Self::in_local(cx, *local),\n+            } => per_local.contains(*local),\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n                     kind: StaticKind::Promoted(..),\n@@ -107,14 +109,18 @@ pub trait Qualif {\n             PlaceRef {\n                 base: _,\n                 projection: [.., _],\n-            } => Self::in_projection(cx, place),\n+            } => Self::in_projection(cx, per_local, place),\n         }\n     }\n \n-    fn in_operand(cx: &ConstCx<'_, 'tcx>, operand: &Operand<'tcx>) -> bool {\n+    fn in_operand(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n+        operand: &Operand<'tcx>,\n+    ) -> bool {\n         match *operand {\n             Operand::Copy(ref place) |\n-            Operand::Move(ref place) => Self::in_place(cx, place.as_ref()),\n+            Operand::Move(ref place) => Self::in_place(cx, per_local, place.as_ref()),\n \n             Operand::Constant(ref constant) => {\n                 if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n@@ -138,21 +144,25 @@ pub trait Qualif {\n         }\n     }\n \n-    fn in_rvalue_structurally(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue_structurally(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> bool {\n         match *rvalue {\n             Rvalue::NullaryOp(..) => false,\n \n             Rvalue::Discriminant(ref place) |\n-            Rvalue::Len(ref place) => Self::in_place(cx, place.as_ref()),\n+            Rvalue::Len(ref place) => Self::in_place(cx, per_local, place.as_ref()),\n \n             Rvalue::Use(ref operand) |\n             Rvalue::Repeat(ref operand, _) |\n             Rvalue::UnaryOp(_, ref operand) |\n-            Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, operand),\n+            Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, per_local, operand),\n \n             Rvalue::BinaryOp(_, ref lhs, ref rhs) |\n             Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n-                Self::in_operand(cx, lhs) || Self::in_operand(cx, rhs)\n+                Self::in_operand(cx, per_local, lhs) || Self::in_operand(cx, per_local, rhs)\n             }\n \n             Rvalue::Ref(_, _, ref place) => {\n@@ -161,29 +171,30 @@ pub trait Qualif {\n                     if ProjectionElem::Deref == *elem {\n                         let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.sty {\n-                            return Self::in_place(cx, PlaceRef {\n+                            return Self::in_place(cx, per_local, PlaceRef {\n                                 base: &place.base,\n                                 projection: proj_base,\n                             });\n                         }\n                     }\n                 }\n \n-                Self::in_place(cx, place.as_ref())\n+                Self::in_place(cx, per_local, place.as_ref())\n             }\n \n             Rvalue::Aggregate(_, ref operands) => {\n-                operands.iter().any(|o| Self::in_operand(cx, o))\n+                operands.iter().any(|o| Self::in_operand(cx, per_local, o))\n             }\n         }\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n-        Self::in_rvalue_structurally(cx, rvalue)\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+        Self::in_rvalue_structurally(cx, per_local, rvalue)\n     }\n \n     fn in_call(\n         cx: &ConstCx<'_, 'tcx>,\n+        _per_local: &BitSet<Local>,\n         _callee: &Operand<'tcx>,\n         _args: &[Operand<'tcx>],\n         return_ty: Ty<'tcx>,\n@@ -207,7 +218,7 @@ impl Qualif for HasMutInterior {\n         Some(!ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP))\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n         match *rvalue {\n             // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n             // allowed in constants (and the `Checker` will error), and/or it\n@@ -247,7 +258,7 @@ impl Qualif for HasMutInterior {\n             _ => {}\n         }\n \n-        Self::in_rvalue_structurally(cx, rvalue)\n+        Self::in_rvalue_structurally(cx, per_local, rvalue)\n     }\n }\n \n@@ -265,7 +276,7 @@ impl Qualif for NeedsDrop {\n         Some(ty.needs_drop(cx.tcx, cx.param_env))\n     }\n \n-    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n         if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n             if let AggregateKind::Adt(def, ..) = **kind {\n                 if def.has_dtor(cx.tcx) {\n@@ -274,6 +285,6 @@ impl Qualif for NeedsDrop {\n             }\n         }\n \n-        Self::in_rvalue_structurally(cx, rvalue)\n+        Self::in_rvalue_structurally(cx, per_local, rvalue)\n     }\n }"}]}