{"sha": "881ebeb776cf4062a85a20b15f64c7349319518c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MWViZWI3NzZjZjQwNjJhODVhMjBiMTVmNjRjNzM0OTMxOTUxOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-04T21:06:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-04T21:06:50Z"}, "message": "Auto merge of #65874 - Nadrieril:clarify-usefulness, r=varkor\n\nClarify pattern-matching usefulness algorithm\n\nThis PR clarifies a bit the usefulness algorithm by emphasizing that each row of the matrix can be seen as a sort of stack from which we pop constructors. It also moves code around to increase separation of concerns.\n\nThis is part of my splitting of https://github.com/rust-lang/rust/pull/65160 into smaller PRs.", "tree": {"sha": "05433f9166309ea01e430a7d99fe90c899e07bf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05433f9166309ea01e430a7d99fe90c899e07bf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/881ebeb776cf4062a85a20b15f64c7349319518c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/881ebeb776cf4062a85a20b15f64c7349319518c", "html_url": "https://github.com/rust-lang/rust/commit/881ebeb776cf4062a85a20b15f64c7349319518c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/881ebeb776cf4062a85a20b15f64c7349319518c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2477e2493e67527fc282c7239e019f7ebd513a1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2477e2493e67527fc282c7239e019f7ebd513a1a", "html_url": "https://github.com/rust-lang/rust/commit/2477e2493e67527fc282c7239e019f7ebd513a1a"}, {"sha": "a96d7005c6d1e4b1977e8bf93e28a886ceb443eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a96d7005c6d1e4b1977e8bf93e28a886ceb443eb", "html_url": "https://github.com/rust-lang/rust/commit/a96d7005c6d1e4b1977e8bf93e28a886ceb443eb"}], "stats": {"total": 1845, "additions": 1047, "deletions": 798}, "files": [{"sha": "8989d2e15de997a3df7910c41402332f211e1795", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 911, "deletions": 690, "changes": 1601, "blob_url": "https://github.com/rust-lang/rust/blob/881ebeb776cf4062a85a20b15f64c7349319518c/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881ebeb776cf4062a85a20b15f64c7349319518c/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=881ebeb776cf4062a85a20b15f64c7349319518c", "patch": "@@ -14,20 +14,24 @@\n /// (without being so rigorous).\n ///\n /// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-/// are trying to compute a predicate `U(P, p_{m + 1})` where `P` is a list of patterns\n-/// of length `m` for a compound (product) type with `n` components (we refer to this as\n-/// a matrix). `U(P, p_{m + 1})` represents whether, given an existing list of patterns\n-/// `p_1 ..= p_m`, adding a new pattern will be \"useful\" (that is, cover previously-\n+/// are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n+/// a matrix). `U(P, p)` represents whether, given an existing list of patterns\n+/// `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n /// uncovered values of the type).\n ///\n /// If we have this predicate, then we can easily compute both exhaustiveness of an\n /// entire set of patterns and the individual usefulness of each one.\n /// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n /// match doesn't increase the number of values we're matching)\n-/// (b) a pattern `p_i` is not useful if `U(P[0..=(i-1), p_i)` is false (i.e., adding a\n+/// (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n /// pattern to those that have come before it doesn't increase the number of values\n /// we're matching).\n ///\n+/// During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n+/// but rather partially-deconstructed patterns in the form of a list of patterns. The paper\n+/// calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n+/// new pattern `p`.\n+///\n /// For example, say we have the following:\n /// ```\n ///     // x: (Option<bool>, Result<()>)\n@@ -37,93 +41,155 @@\n ///         (None, Err(_)) => {}\n ///     }\n /// ```\n-/// Here, the matrix `P` is 3 x 2 (rows x columns).\n+/// Here, the matrix `P` starts as:\n /// [\n-///     [Some(true), _],\n-///     [None, Err(())],\n-///     [None, Err(_)],\n+///     [(Some(true), _)],\n+///     [(None, Err(()))],\n+///     [(None, Err(_))],\n /// ]\n /// We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-/// `[Some(false), _]`, for instance). In addition, row 3 is not useful, because\n+/// `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n /// all the values it covers are already covered by row 2.\n ///\n-/// To compute `U`, we must have two other concepts.\n-///     1. `S(c, P)` is a \"specialized matrix\", where `c` is a constructor (like `Some` or\n-///        `None`). You can think of it as filtering `P` to just the rows whose *first* pattern\n-///        can cover `c` (and expanding OR-patterns into distinct patterns), and then expanding\n-///        the constructor into all of its components.\n-///        The specialization of a row vector is computed by `specialize`.\n+/// A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n+/// the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n+/// To match the paper, the top of the stack is at the beginning / on the left.\n+///\n+/// There are two important operations on pattern-stacks necessary to understand the algorithm:\n+///     1. We can pop a given constructor off the top of a stack. This operation is called\n+///        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+///        `None`) and `p` a pattern-stack.\n+///        If the pattern on top of the stack can cover `c`, this removes the constructor and\n+///        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+///        Otherwise the pattern-stack is discarded.\n+///        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+///        discards the others.\n+///\n+///        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+///        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+///        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+///        nothing back.\n ///\n-///        It is computed as follows. For each row `p_i` of P, we have four cases:\n-///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `S(c, P)` has a corresponding row:\n-///                     r_1, .., r_a, p_(i,2), .., p_(i,n)\n-///             1.2. `p_(i,1) = c'(r_1, .., r_a')` where `c \u2260 c'`. Then `S(c, P)` has no\n-///                  corresponding row.\n-///             1.3. `p_(i,1) = _`. Then `S(c, P)` has a corresponding row:\n-///                     _, .., _, p_(i,2), .., p_(i,n)\n-///             1.4. `p_(i,1) = r_1 | r_2`. Then `S(c, P)` has corresponding rows inlined from:\n-///                     S(c, (r_1, p_(i,2), .., p_(i,n)))\n-///                     S(c, (r_2, p_(i,2), .., p_(i,n)))\n+///        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+///        on top of the stack, and we have four cases:\n+///             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+///                  push onto the stack the arguments of this constructor, and return the result:\n+///                     r_1, .., r_a, p_2, .., p_n\n+///             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+///                  return nothing.\n+///             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+///                  arguments (its arity), and return the resulting stack:\n+///                     _, .., _, p_2, .., p_n\n+///             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+///                  stack:\n+///                     S(c, (r_1, p_2, .., p_n))\n+///                     S(c, (r_2, p_2, .., p_n))\n ///\n-///     2. `D(P)` is a \"default matrix\". This is used when we know there are missing\n-///        constructor cases, but there might be existing wildcard patterns, so to check the\n-///        usefulness of the matrix, we have to check all its *other* components.\n-///        The default matrix is computed inline in `is_useful`.\n+///     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+///        a pattern-stack.\n+///        This is used when we know there are missing constructor cases, but there might be\n+///        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+///        all its *other* components.\n ///\n-///         It is computed as follows. For each row `p_i` of P, we have three cases:\n-///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `D(P)` has no corresponding row.\n-///             1.2. `p_(i,1) = _`. Then `D(P)` has a corresponding row:\n-///                     p_(i,2), .., p_(i,n)\n-///             1.3. `p_(i,1) = r_1 | r_2`. Then `D(P)` has corresponding rows inlined from:\n-///                     D((r_1, p_(i,2), .., p_(i,n)))\n-///                     D((r_2, p_(i,2), .., p_(i,n)))\n+///        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+///        and we have three cases:\n+///             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+///             1.2. `p_1 = _`. We return the rest of the stack:\n+///                     p_2, .., p_n\n+///             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+///               stack.\n+///                     D((r_1, p_2, .., p_n))\n+///                     D((r_2, p_2, .., p_n))\n+///\n+///     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+///     exhaustive integer matching rules, so they're written here for posterity.\n+///\n+/// Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n+/// working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n+/// the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n ///\n-///     Note that the OR-patterns are not always used directly in Rust, but are used to derive\n-///     the exhaustive integer matching rules, so they're written here for posterity.\n ///\n /// The algorithm for computing `U`\n /// -------------------------------\n /// The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n /// That means we're going to check the components from left-to-right, so the algorithm\n-/// operates principally on the first component of the matrix and new pattern `p_{m + 1}`.\n+/// operates principally on the first component of the matrix and new pattern-stack `p`.\n /// This algorithm is realised in the `is_useful` function.\n ///\n /// Base case. (`n = 0`, i.e., an empty tuple pattern)\n ///     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n-///       then `U(P, p_{m + 1})` is false.\n-///     - Otherwise, `P` must be empty, so `U(P, p_{m + 1})` is true.\n+///       then `U(P, p)` is false.\n+///     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n ///\n /// Inductive step. (`n > 0`, i.e., whether there's at least one column\n ///                  [which may then be expanded into further columns later])\n-///     We're going to match on the new pattern, `p_{m + 1}`.\n-///         - If `p_{m + 1} == c(r_1, .., r_a)`, then we have a constructor pattern.\n-///           Thus, the usefulness of `p_{m + 1}` can be reduced to whether it is useful when\n-///           we ignore all the patterns in `P` that involve other constructors. This is where\n-///           `S(c, P)` comes in:\n-///           `U(P, p_{m + 1}) := U(S(c, P), S(c, p_{m + 1}))`\n+///     We're going to match on the top of the new pattern-stack, `p_1`.\n+///         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+///           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+///           we ignore all the patterns in the first column of `P` that involve other constructors.\n+///           This is where `S(c, P)` comes in:\n+///           `U(P, p) := U(S(c, P), S(c, p))`\n ///           This special case is handled in `is_useful_specialized`.\n-///         - If `p_{m + 1} == _`, then we have two more cases:\n-///             + All the constructors of the first component of the type exist within\n-///               all the rows (after having expanded OR-patterns). In this case:\n-///               `U(P, p_{m + 1}) := \u2228(k \u03f5 constructors) U(S(k, P), S(k, p_{m + 1}))`\n-///               I.e., the pattern `p_{m + 1}` is only useful when all the constructors are\n-///               present *if* its later components are useful for the respective constructors\n-///               covered by `p_{m + 1}` (usually a single constructor, but all in the case of `_`).\n-///             + Some constructors are not present in the existing rows (after having expanded\n-///               OR-patterns). However, there might be wildcard patterns (`_`) present. Thus, we\n-///               are only really concerned with the other patterns leading with wildcards. This is\n-///               where `D` comes in:\n-///               `U(P, p_{m + 1}) := U(D(P), p_({m + 1},2), ..,  p_({m + 1},n))`\n-///         - If `p_{m + 1} == r_1 | r_2`, then the usefulness depends on each separately:\n-///           `U(P, p_{m + 1}) := U(P, (r_1, p_({m + 1},2), .., p_({m + 1},n)))\n-///                            || U(P, (r_2, p_({m + 1},2), .., p_({m + 1},n)))`\n+///\n+///           For example, if `P` is:\n+///           [\n+///               [Some(true), _],\n+///               [None, 0],\n+///           ]\n+///           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+///           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+///           arguments of `Some` to know whether some new value is covered. So we compute\n+///           `U([[true, _]], [false, 0])`.\n+///\n+///         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+///               component of the rows of `P`:\n+///             + If there are some constructors that aren't present, then we might think that the\n+///               wildcard `_` is useful, since it covers those constructors that weren't covered\n+///               before.\n+///               That's almost correct, but only works if there were no wildcards in those first\n+///               components. So we need to check that `p` is useful with respect to the rows that\n+///               start with a wildcard, if there are any. This is where `D` comes in:\n+///               `U(P, p) := U(D(P), D(p))`\n+///\n+///               For example, if `P` is:\n+///               [\n+///                   [_, true, _],\n+///                   [None, false, 1],\n+///               ]\n+///               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+///               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+///               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+///\n+///             + Otherwise, all possible constructors (for the relevant type) are present. In this\n+///               case we must check whether the wildcard pattern covers any unmatched value. For\n+///               that, we can think of the `_` pattern as a big OR-pattern that covers all\n+///               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+///               example. The wildcard pattern is useful in this case if it is useful when\n+///               specialized to one of the possible constructors. So we compute:\n+///               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+///\n+///               For example, if `P` is:\n+///               [\n+///                   [Some(true), _],\n+///                   [None, false],\n+///               ]\n+///               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+///               components of `P`. We will therefore try popping both constructors in turn: we\n+///               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n+///               [false]) for the `None` constructor. The first case returns true, so we know that\n+///               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+///               before.\n+///\n+///         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+///           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+///                    || U(P, (r_2, p_2, .., p_n))`\n ///\n /// Modifications to the algorithm\n /// ------------------------------\n /// The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n /// example uninhabited types and variable-length slice patterns. These are drawn attention to\n-/// throughout the code below. I'll make a quick note here about how exhaustive integer matching\n-/// is accounted for, though.\n+/// throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n+/// accounted for, though.\n ///\n /// Exhaustive integer matching\n /// ---------------------------\n@@ -153,44 +219,44 @@\n ///       invalid, because we want a disjunction over every *integer* in each range, not just a\n ///       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n ///       to form equivalence classes of subranges of the constructor range for which the behaviour\n-///       of the matrix `P` and new pattern `p_{m + 1}` are the same. This is described in more\n+///       of the matrix `P` and new pattern `p` are the same. This is described in more\n ///       detail in `split_grouped_constructors`.\n ///     + If some constructors are missing from the matrix, it turns out we don't need to do\n ///       anything special (because we know none of the integers are actually wildcards: i.e., we\n ///       can't span wildcards using ranges).\n-\n use self::Constructor::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n \n+use super::{compare_const_vals, PatternFoldable, PatternFolder};\n use super::{FieldPat, Pat, PatKind, PatRange};\n-use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n-use rustc::hir::{RangeEnd, HirId};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n-use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n+use rustc::hir::{HirId, RangeEnd};\n+use rustc::ty::layout::{Integer, IntegerExt, Size, VariantIdx};\n+use rustc::ty::{self, Const, Ty, TyCtxt, TypeFoldable};\n \n+use rustc::lint;\n+use rustc::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Scalar, truncate, AllocId, Pointer};\n+use rustc::util::captures::Captures;\n use rustc::util::common::ErrorReported;\n-use rustc::lint;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n \n-use smallvec::{SmallVec, smallvec};\n-use std::cmp::{self, Ordering, min, max};\n+use smallvec::{smallvec, SmallVec};\n+use std::cmp::{self, max, min, Ordering};\n+use std::convert::TryInto;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n use std::u128;\n-use std::convert::TryInto;\n \n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n     LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat)\n@@ -219,11 +285,8 @@ impl LiteralExpander<'tcx> {\n             // the easy case, deref a reference\n             (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n                 let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n-                ConstValue::ByRef {\n-                    alloc,\n-                    offset: p.offset,\n-                }\n-            },\n+                ConstValue::ByRef { alloc, offset: p.offset }\n+            }\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n@@ -232,12 +295,11 @@ impl LiteralExpander<'tcx> {\n                     start: p.offset.bytes().try_into().unwrap(),\n                     end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n                 }\n-            },\n+            }\n             // fat pointers stay the same\n-            | (ConstValue::Slice { .. }, _, _)\n+            (ConstValue::Slice { .. }, _, _)\n             | (_, ty::Slice(_), ty::Slice(_))\n-            | (_, ty::Str, ty::Str)\n-            => val,\n+            | (_, ty::Str, ty::Str) => val,\n             // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n             _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n         }\n@@ -250,84 +312,184 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n         match (&pat.ty.kind, &*pat.kind) {\n             (\n                 &ty::Ref(_, rty, _),\n-                &PatKind::Constant { value: Const {\n-                    val,\n-                    ty: ty::TyS { kind: ty::Ref(_, crty, _), .. },\n-                } },\n-            ) => {\n-                Pat {\n-                    ty: pat.ty,\n-                    span: pat.span,\n-                    kind: box PatKind::Deref {\n-                        subpattern: Pat {\n-                            ty: rty,\n-                            span: pat.span,\n-                            kind: box PatKind::Constant { value: self.tcx.mk_const(Const {\n+                &PatKind::Constant {\n+                    value: Const { val, ty: ty::TyS { kind: ty::Ref(_, crty, _), .. } },\n+                },\n+            ) => Pat {\n+                ty: pat.ty,\n+                span: pat.span,\n+                kind: box PatKind::Deref {\n+                    subpattern: Pat {\n+                        ty: rty,\n+                        span: pat.span,\n+                        kind: box PatKind::Constant {\n+                            value: self.tcx.mk_const(Const {\n                                 val: self.fold_const_value_deref(*val, rty, crty),\n                                 ty: rty,\n-                            }) },\n-                        }\n-                    }\n-                }\n-            }\n-            (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => {\n-                s.fold_with(self)\n-            }\n-            _ => pat.super_fold_with(self)\n+                            }),\n+                        },\n+                    },\n+                },\n+            },\n+            (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n+            _ => pat.super_fold_with(self),\n         }\n     }\n }\n \n impl<'tcx> Pat<'tcx> {\n     fn is_wildcard(&self) -> bool {\n         match *self.kind {\n-            PatKind::Binding { subpattern: None, .. } | PatKind::Wild =>\n-                true,\n-            _ => false\n+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => true,\n+            _ => false,\n         }\n     }\n }\n \n-/// A 2D matrix. Nx1 matrices are very common, which is why `SmallVec[_; 2]`\n-/// works well for each row.\n-pub struct Matrix<'p, 'tcx>(Vec<SmallVec<[&'p Pat<'tcx>; 2]>>);\n+/// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n+/// works well.\n+#[derive(Debug, Clone)]\n+pub struct PatStack<'p, 'tcx>(SmallVec<[&'p Pat<'tcx>; 2]>);\n+\n+impl<'p, 'tcx> PatStack<'p, 'tcx> {\n+    pub fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n+        PatStack(smallvec![pat])\n+    }\n+\n+    fn from_vec(vec: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n+        PatStack(vec)\n+    }\n+\n+    fn from_slice(s: &[&'p Pat<'tcx>]) -> Self {\n+        PatStack(SmallVec::from_slice(s))\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    fn head(&self) -> &'p Pat<'tcx> {\n+        self.0[0]\n+    }\n+\n+    fn to_tail(&self) -> Self {\n+        PatStack::from_slice(&self.0[1..])\n+    }\n+\n+    fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n+        self.0.iter().map(|p| *p)\n+    }\n+\n+    /// This computes `D(self)`. See top of the file for explanations.\n+    fn specialize_wildcard(&self) -> Option<Self> {\n+        if self.head().is_wildcard() { Some(self.to_tail()) } else { None }\n+    }\n+\n+    /// This computes `S(constructor, self)`. See top of the file for explanations.\n+    fn specialize_constructor<'a, 'q>(\n+        &self,\n+        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        constructor: &Constructor<'tcx>,\n+        ctor_wild_subpatterns: &[&'q Pat<'tcx>],\n+    ) -> Option<PatStack<'q, 'tcx>>\n+    where\n+        'a: 'q,\n+        'p: 'q,\n+    {\n+        let new_heads = specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns);\n+        new_heads.map(|mut new_head| {\n+            new_head.0.extend_from_slice(&self.0[1..]);\n+            new_head\n+        })\n+    }\n+}\n+\n+impl<'p, 'tcx> Default for PatStack<'p, 'tcx> {\n+    fn default() -> Self {\n+        PatStack(smallvec![])\n+    }\n+}\n+\n+impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n+    fn from_iter<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<Item = &'p Pat<'tcx>>,\n+    {\n+        PatStack(iter.into_iter().collect())\n+    }\n+}\n+\n+/// A 2D matrix.\n+pub struct Matrix<'p, 'tcx>(Vec<PatStack<'p, 'tcx>>);\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     pub fn empty() -> Self {\n         Matrix(vec![])\n     }\n \n-    pub fn push(&mut self, row: SmallVec<[&'p Pat<'tcx>; 2]>) {\n+    pub fn push(&mut self, row: PatStack<'p, 'tcx>) {\n         self.0.push(row)\n     }\n+\n+    /// Iterate over the first component of each row\n+    fn heads<'a>(&'a self) -> impl Iterator<Item = &'a Pat<'tcx>> + Captures<'p> {\n+        self.0.iter().map(|r| r.head())\n+    }\n+\n+    /// This computes `D(self)`. See top of the file for explanations.\n+    fn specialize_wildcard(&self) -> Self {\n+        self.0.iter().filter_map(|r| r.specialize_wildcard()).collect()\n+    }\n+\n+    /// This computes `S(constructor, self)`. See top of the file for explanations.\n+    fn specialize_constructor<'a, 'q>(\n+        &self,\n+        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        constructor: &Constructor<'tcx>,\n+        ctor_wild_subpatterns: &[&'q Pat<'tcx>],\n+    ) -> Matrix<'q, 'tcx>\n+    where\n+        'a: 'q,\n+        'p: 'q,\n+    {\n+        Matrix(\n+            self.0\n+                .iter()\n+                .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n+                .collect(),\n+        )\n+    }\n }\n \n /// Pretty-printer for matrices of patterns, example:\n-/// ++++++++++++++++++++++++++\n-/// + _     + []             +\n-/// ++++++++++++++++++++++++++\n-/// + true  + [First]        +\n-/// ++++++++++++++++++++++++++\n-/// + true  + [Second(true)] +\n-/// ++++++++++++++++++++++++++\n-/// + false + [_]            +\n-/// ++++++++++++++++++++++++++\n-/// + _     + [_, _, ..tail] +\n-/// ++++++++++++++++++++++++++\n+/// +++++++++++++++++++++++++++++\n+/// + _     + []                +\n+/// +++++++++++++++++++++++++++++\n+/// + true  + [First]           +\n+/// +++++++++++++++++++++++++++++\n+/// + true  + [Second(true)]    +\n+/// +++++++++++++++++++++++++++++\n+/// + false + [_]               +\n+/// +++++++++++++++++++++++++++++\n+/// + _     + [_, _, tail @ ..] +\n+/// +++++++++++++++++++++++++++++\n impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\n\")?;\n \n         let &Matrix(ref m) = self;\n-        let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n-            row.iter().map(|pat| format!(\"{:?}\", pat)).collect()\n-        }).collect();\n+        let pretty_printed_matrix: Vec<Vec<String>> =\n+            m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n \n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n-        let column_widths: Vec<usize> = (0..column_count).map(|col| {\n-            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n-        }).collect();\n+        let column_widths: Vec<usize> = (0..column_count)\n+            .map(|col| pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0))\n+            .collect();\n \n         let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n         let br = \"+\".repeat(total_width);\n@@ -346,9 +508,10 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     }\n }\n \n-impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pat<'tcx>; 2]>> for Matrix<'p, 'tcx> {\n+impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     fn from_iter<T>(iter: T) -> Self\n-        where T: IntoIterator<Item=SmallVec<[&'p Pat<'tcx>; 2]>>\n+    where\n+        T: IntoIterator<Item = PatStack<'p, 'tcx>>,\n     {\n         Matrix(iter.into_iter().collect())\n     }\n@@ -464,7 +627,7 @@ impl<'tcx> Constructor<'tcx> {\n                 VariantIdx::new(0)\n             }\n             ConstantValue(c, _) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n-            _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n+            _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n     }\n \n@@ -485,28 +648,237 @@ impl<'tcx> Constructor<'tcx> {\n             _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n         }\n     }\n+\n+    // Returns the set of constructors covered by `self` but not by\n+    // anything in `other_ctors`.\n+    fn subtract_ctors(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        other_ctors: &Vec<Constructor<'tcx>>,\n+    ) -> Vec<Constructor<'tcx>> {\n+        let mut refined_ctors = vec![self.clone()];\n+        for other_ctor in other_ctors {\n+            if other_ctor == self {\n+                // If a constructor appears in a `match` arm, we can\n+                // eliminate it straight away.\n+                refined_ctors = vec![]\n+            } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, other_ctor) {\n+                // Refine the required constructors for the type by subtracting\n+                // the range defined by the current constructor pattern.\n+                refined_ctors = interval.subtract_from(tcx, param_env, refined_ctors);\n+            }\n+\n+            // If the constructor patterns that have been considered so far\n+            // already cover the entire range of values, then we know the\n+            // constructor is not missing, and we can move on to the next one.\n+            if refined_ctors.is_empty() {\n+                break;\n+            }\n+        }\n+\n+        // If a constructor has not been matched, then it is missing.\n+        // We add `refined_ctors` instead of `self`, because then we can\n+        // provide more detailed error information about precisely which\n+        // ranges have been omitted.\n+        refined_ctors\n+    }\n+\n+    /// This returns one wildcard pattern for each argument to this constructor.\n+    fn wildcard_subpatterns<'a>(\n+        &self,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> impl Iterator<Item = Pat<'tcx>> + DoubleEndedIterator {\n+        constructor_sub_pattern_tys(cx, self, ty).into_iter().map(|ty| Pat {\n+            ty,\n+            span: DUMMY_SP,\n+            kind: box PatKind::Wild,\n+        })\n+    }\n+\n+    /// This computes the arity of a constructor. The arity of a constructor\n+    /// is how many subpattern patterns of that constructor should be expanded to.\n+    ///\n+    /// For instance, a tuple pattern `(_, 42, Some([]))` has the arity of 3.\n+    /// A struct pattern's arity is the number of fields it contains, etc.\n+    fn arity<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> u64 {\n+        debug!(\"Constructor::arity({:#?}, {:?})\", self, ty);\n+        match ty.kind {\n+            ty::Tuple(ref fs) => fs.len() as u64,\n+            ty::Slice(..) | ty::Array(..) => match *self {\n+                Slice(length) => length,\n+                ConstantValue(..) => 0,\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n+            ty::Ref(..) => 1,\n+            ty::Adt(adt, _) => {\n+                adt.variants[self.variant_index_for_adt(cx, adt)].fields.len() as u64\n+            }\n+            _ => 0,\n+        }\n+    }\n+\n+    /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n+    /// must have as many elements as this constructor's arity.\n+    ///\n+    /// Examples:\n+    /// `self`: `Constructor::Single`\n+    /// `ty`: `(u32, u32, u32)`\n+    /// `pats`: `[10, 20, _]`\n+    /// returns `(10, 20, _)`\n+    ///\n+    /// `self`: `Constructor::Variant(Option::Some)`\n+    /// `ty`: `Option<bool>`\n+    /// `pats`: `[false]`\n+    /// returns `Some(false)`\n+    fn apply<'a>(\n+        &self,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+        pats: impl IntoIterator<Item = Pat<'tcx>>,\n+    ) -> Pat<'tcx> {\n+        let mut subpatterns = pats.into_iter();\n+        let pat = match ty.kind {\n+            ty::Adt(..) | ty::Tuple(..) => {\n+                let subpatterns = subpatterns\n+                    .enumerate()\n+                    .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                    .collect();\n+\n+                if let ty::Adt(adt, substs) = ty.kind {\n+                    if adt.is_enum() {\n+                        PatKind::Variant {\n+                            adt_def: adt,\n+                            substs,\n+                            variant_index: self.variant_index_for_adt(cx, adt),\n+                            subpatterns,\n+                        }\n+                    } else {\n+                        PatKind::Leaf { subpatterns }\n+                    }\n+                } else {\n+                    PatKind::Leaf { subpatterns }\n+                }\n+            }\n+\n+            ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.nth(0).unwrap() },\n+\n+            ty::Slice(_) | ty::Array(..) => {\n+                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+            }\n+\n+            _ => match *self {\n+                ConstantValue(value, _) => PatKind::Constant { value },\n+                ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n+                    lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n+                    hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n+                    end,\n+                }),\n+                _ => PatKind::Wild,\n+            },\n+        };\n+\n+        Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n+    }\n+\n+    /// Like `apply`, but where all the subpatterns are wildcards `_`.\n+    fn apply_wildcards<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n+        let subpatterns = self.wildcard_subpatterns(cx, ty).rev();\n+        self.apply(cx, ty, subpatterns)\n+    }\n }\n \n #[derive(Clone, Debug)]\n pub enum Usefulness<'tcx> {\n     Useful,\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n-    NotUseful\n+    NotUseful,\n }\n \n impl<'tcx> Usefulness<'tcx> {\n+    fn new_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n+            LeaveOutWitness => Useful,\n+        }\n+    }\n+\n     fn is_useful(&self) -> bool {\n         match *self {\n             NotUseful => false,\n-            _ => true\n+            _ => true,\n+        }\n+    }\n+\n+    fn apply_constructor(\n+        self,\n+        cx: &MatchCheckCtxt<'_, 'tcx>,\n+        ctor: &Constructor<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n+        match self {\n+            UsefulWithWitness(witnesses) => UsefulWithWitness(\n+                witnesses\n+                    .into_iter()\n+                    .map(|witness| witness.apply_constructor(cx, &ctor, ty))\n+                    .collect(),\n+            ),\n+            x => x,\n+        }\n+    }\n+\n+    fn apply_wildcard(self, ty: Ty<'tcx>) -> Self {\n+        match self {\n+            UsefulWithWitness(witnesses) => {\n+                let wild = Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n+                UsefulWithWitness(\n+                    witnesses\n+                        .into_iter()\n+                        .map(|mut witness| {\n+                            witness.0.push(wild.clone());\n+                            witness\n+                        })\n+                        .collect(),\n+                )\n+            }\n+            x => x,\n+        }\n+    }\n+\n+    fn apply_missing_ctors(\n+        self,\n+        cx: &MatchCheckCtxt<'_, 'tcx>,\n+        ty: Ty<'tcx>,\n+        missing_ctors: &MissingConstructors<'tcx>,\n+    ) -> Self {\n+        match self {\n+            UsefulWithWitness(witnesses) => {\n+                let new_patterns: Vec<_> =\n+                    missing_ctors.iter().map(|ctor| ctor.apply_wildcards(cx, ty)).collect();\n+                // Add the new patterns to each witness\n+                UsefulWithWitness(\n+                    witnesses\n+                        .into_iter()\n+                        .flat_map(|witness| {\n+                            new_patterns.iter().map(move |pat| {\n+                                let mut witness = witness.clone();\n+                                witness.0.push(pat.clone());\n+                                witness\n+                            })\n+                        })\n+                        .collect(),\n+                )\n+            }\n+            x => x,\n         }\n     }\n }\n \n #[derive(Copy, Clone, Debug)]\n pub enum WitnessPreference {\n     ConstructWitness,\n-    LeaveOutWitness\n+    LeaveOutWitness,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -557,24 +929,6 @@ impl<'tcx> Witness<'tcx> {\n         self.0.into_iter().next().unwrap()\n     }\n \n-    fn push_wild_constructor<'a>(\n-        mut self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n-        ctor: &Constructor<'tcx>,\n-        ty: Ty<'tcx>)\n-        -> Self\n-    {\n-        let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n-        self.0.extend(sub_pattern_tys.into_iter().map(|ty| {\n-            Pat {\n-                ty,\n-                span: DUMMY_SP,\n-                kind: box PatKind::Wild,\n-            }\n-        }));\n-        self.apply_constructor(cx, ctor, ty)\n-    }\n-\n     /// Constructs a partial witness for a pattern given a list of\n     /// patterns expanded by the specialization step.\n     ///\n@@ -590,73 +944,18 @@ impl<'tcx> Witness<'tcx> {\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n     fn apply_constructor<'a>(\n         mut self,\n-        cx: &MatchCheckCtxt<'a,'tcx>,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n         ctor: &Constructor<'tcx>,\n-        ty: Ty<'tcx>)\n-        -> Self\n-    {\n-        let arity = constructor_arity(cx, ctor, ty);\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n+        let arity = ctor.arity(cx, ty);\n         let pat = {\n             let len = self.0.len() as u64;\n-            let mut pats = self.0.drain((len - arity) as usize..).rev();\n-\n-            match ty.kind {\n-                ty::Adt(..) |\n-                ty::Tuple(..) => {\n-                    let pats = pats.enumerate().map(|(i, p)| {\n-                        FieldPat {\n-                            field: Field::new(i),\n-                            pattern: p\n-                        }\n-                    }).collect();\n-\n-                    if let ty::Adt(adt, substs) = ty.kind {\n-                        if adt.is_enum() {\n-                            PatKind::Variant {\n-                                adt_def: adt,\n-                                substs,\n-                                variant_index: ctor.variant_index_for_adt(cx, adt),\n-                                subpatterns: pats\n-                            }\n-                        } else {\n-                            PatKind::Leaf { subpatterns: pats }\n-                        }\n-                    } else {\n-                        PatKind::Leaf { subpatterns: pats }\n-                    }\n-                }\n-\n-                ty::Ref(..) => {\n-                    PatKind::Deref { subpattern: pats.nth(0).unwrap() }\n-                }\n-\n-                ty::Slice(_) | ty::Array(..) => {\n-                    PatKind::Slice {\n-                        prefix: pats.collect(),\n-                        slice: None,\n-                        suffix: vec![]\n-                    }\n-                }\n-\n-                _ => {\n-                    match *ctor {\n-                        ConstantValue(value, _) => PatKind::Constant { value },\n-                        ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n-                            lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n-                            hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                            end,\n-                        }),\n-                        _ => PatKind::Wild,\n-                    }\n-                }\n-            }\n+            let pats = self.0.drain((len - arity) as usize..).rev();\n+            ctor.apply(cx, ty, pats)\n         };\n \n-        self.0.push(Pat {\n-            ty,\n-            span: DUMMY_SP,\n-            kind: Box::new(pat),\n-        });\n+        self.0.push(pat);\n \n         self\n     }\n@@ -675,37 +974,33 @@ fn all_constructors<'a, 'tcx>(\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     let ctors = match pcx.ty.kind {\n-        ty::Bool => {\n-            [true, false].iter().map(|&b| {\n-                ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span)\n-            }).collect()\n-        }\n+        ty::Bool => [true, false]\n+            .iter()\n+            .map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span))\n+            .collect(),\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) {\n-                vec![]\n-            } else {\n-                vec![Slice(len)]\n-            }\n+            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![Slice(len)] }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n-        ty::Array(ref sub_ty, _) |\n-        ty::Slice(ref sub_ty) => {\n+        ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n-                (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n+                (0..pcx.max_slice_length + 1).map(|length| Slice(length)).collect()\n             }\n         }\n-        ty::Adt(def, substs) if def.is_enum() => {\n-            def.variants.iter()\n-                .filter(|v| {\n-                    !cx.tcx.features().exhaustive_patterns ||\n-                    !v.uninhabited_from(cx.tcx, substs, def.adt_kind()).contains(cx.tcx, cx.module)\n-                })\n-                .map(|v| Variant(v.def_id))\n-                .collect()\n-        }\n+        ty::Adt(def, substs) if def.is_enum() => def\n+            .variants\n+            .iter()\n+            .filter(|v| {\n+                !cx.tcx.features().exhaustive_patterns\n+                    || !v\n+                        .uninhabited_from(cx.tcx, substs, def.adt_kind())\n+                        .contains(cx.tcx, cx.module)\n+            })\n+            .map(|v| Variant(v.def_id))\n+            .collect(),\n         ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n@@ -825,15 +1120,13 @@ where\n             PatKind::Constant { value } => {\n                 // extract the length of an array/slice from a constant\n                 match (value.val, &value.ty.kind) {\n-                    (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n-                        max_fixed_len,\n-                        n.eval_usize(cx.tcx, cx.param_env),\n-                    ),\n-                    (ConstValue::Slice{ start, end, .. }, ty::Slice(_)) => max_fixed_len = cmp::max(\n-                        max_fixed_len,\n-                        (end - start) as u64,\n-                    ),\n-                    _ => {},\n+                    (_, ty::Array(_, n)) => {\n+                        max_fixed_len = cmp::max(max_fixed_len, n.eval_usize(cx.tcx, cx.param_env))\n+                    }\n+                    (ConstValue::Slice { start, end, .. }, ty::Slice(_)) => {\n+                        max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n+                    }\n+                    _ => {}\n                 }\n             }\n             PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n@@ -910,7 +1203,7 @@ impl<'tcx> IntRange<'tcx> {\n                 // This is a more general form of the previous branch.\n                 val\n             } else {\n-                return None\n+                return None;\n             };\n             let val = val ^ bias;\n             Some(IntRange { range: val..=val, ty, span })\n@@ -981,7 +1274,7 @@ impl<'tcx> IntRange<'tcx> {\n                 }\n                 box PatKind::AscribeUserType { ref subpattern, .. } => {\n                     pat = subpattern;\n-                },\n+                }\n                 _ => return None,\n             }\n         }\n@@ -994,7 +1287,7 @@ impl<'tcx> IntRange<'tcx> {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n                 1u128 << (bits - 1)\n             }\n-            _ => 0\n+            _ => 0,\n         }\n     }\n \n@@ -1023,34 +1316,43 @@ impl<'tcx> IntRange<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         ranges: Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n-        let ranges = ranges.into_iter().filter_map(|r| {\n-            IntRange::from_ctor(tcx, param_env, &r).map(|i| i.range)\n-        });\n+        let ranges = ranges\n+            .into_iter()\n+            .filter_map(|r| IntRange::from_ctor(tcx, param_env, &r).map(|i| i.range));\n         let mut remaining_ranges = vec![];\n         let ty = self.ty;\n         let (lo, hi) = self.range.into_inner();\n         for subrange in ranges {\n             let (subrange_lo, subrange_hi) = subrange.into_inner();\n-            if lo > subrange_hi || subrange_lo > hi  {\n+            if lo > subrange_hi || subrange_lo > hi {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(\n-                    Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi, self.span),\n-                );\n+                remaining_ranges.push(Self::range_to_ctor(\n+                    tcx,\n+                    ty,\n+                    subrange_lo..=subrange_hi,\n+                    self.span,\n+                ));\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(\n-                        Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1), self.span),\n-                    );\n+                    remaining_ranges.push(Self::range_to_ctor(\n+                        tcx,\n+                        ty,\n+                        subrange_lo..=(lo - 1),\n+                        self.span,\n+                    ));\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push(\n-                        Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi, self.span),\n-                    );\n+                    remaining_ranges.push(Self::range_to_ctor(\n+                        tcx,\n+                        ty,\n+                        (hi + 1)..=subrange_hi,\n+                        self.span,\n+                    ));\n                 }\n             }\n         }\n@@ -1087,79 +1389,49 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n-// A request for missing constructor data in terms of either:\n-// - whether or not there any missing constructors; or\n-// - the actual set of missing constructors.\n-#[derive(PartialEq)]\n-enum MissingCtorsInfo {\n-    Emptiness,\n-    Ctors,\n+// A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n+struct MissingConstructors<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    all_ctors: Vec<Constructor<'tcx>>,\n+    used_ctors: Vec<Constructor<'tcx>>,\n }\n \n-// Used by `compute_missing_ctors`.\n-#[derive(Debug, PartialEq)]\n-enum MissingCtors<'tcx> {\n-    Empty,\n-    NonEmpty,\n+impl<'tcx> MissingConstructors<'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        all_ctors: Vec<Constructor<'tcx>>,\n+        used_ctors: Vec<Constructor<'tcx>>,\n+    ) -> Self {\n+        MissingConstructors { tcx, param_env, all_ctors, used_ctors }\n+    }\n \n-    // Note that the Vec can be empty.\n-    Ctors(Vec<Constructor<'tcx>>),\n-}\n+    fn into_inner(self) -> (Vec<Constructor<'tcx>>, Vec<Constructor<'tcx>>) {\n+        (self.all_ctors, self.used_ctors)\n+    }\n \n-// When `info` is `MissingCtorsInfo::Ctors`, compute a set of constructors\n-// equivalent to `all_ctors \\ used_ctors`. When `info` is\n-// `MissingCtorsInfo::Emptiness`, just determines if that set is empty or not.\n-// (The split logic gives a performance win, because we always need to know if\n-// the set is empty, but we rarely need the full set, and it can be expensive\n-// to compute the full set.)\n-fn compute_missing_ctors<'tcx>(\n-    info: MissingCtorsInfo,\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    all_ctors: &Vec<Constructor<'tcx>>,\n-    used_ctors: &Vec<Constructor<'tcx>>,\n-) -> MissingCtors<'tcx> {\n-    let mut missing_ctors = vec![];\n-\n-    for req_ctor in all_ctors {\n-        let mut refined_ctors = vec![req_ctor.clone()];\n-        for used_ctor in used_ctors {\n-            if used_ctor == req_ctor {\n-                // If a constructor appears in a `match` arm, we can\n-                // eliminate it straight away.\n-                refined_ctors = vec![]\n-            } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, used_ctor) {\n-                // Refine the required constructors for the type by subtracting\n-                // the range defined by the current constructor pattern.\n-                refined_ctors = interval.subtract_from(tcx, param_env, refined_ctors);\n-            }\n+    fn is_empty(&self) -> bool {\n+        self.iter().next().is_none()\n+    }\n+    /// Whether this contains all the constructors for the given type or only a\n+    /// subset.\n+    fn all_ctors_are_missing(&self) -> bool {\n+        self.used_ctors.is_empty()\n+    }\n \n-            // If the constructor patterns that have been considered so far\n-            // already cover the entire range of values, then we the\n-            // constructor is not missing, and we can move on to the next one.\n-            if refined_ctors.is_empty() {\n-                break;\n-            }\n-        }\n-        // If a constructor has not been matched, then it is missing.\n-        // We add `refined_ctors` instead of `req_ctor`, because then we can\n-        // provide more detailed error information about precisely which\n-        // ranges have been omitted.\n-        if info == MissingCtorsInfo::Emptiness {\n-            if !refined_ctors.is_empty() {\n-                // The set is non-empty; return early.\n-                return MissingCtors::NonEmpty;\n-            }\n-        } else {\n-            missing_ctors.extend(refined_ctors);\n-        }\n+    /// Iterate over all_ctors \\ used_ctors\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Constructor<'tcx>> + Captures<'a> {\n+        self.all_ctors.iter().flat_map(move |req_ctor| {\n+            req_ctor.subtract_ctors(self.tcx, self.param_env, &self.used_ctors)\n+        })\n     }\n+}\n \n-    if info == MissingCtorsInfo::Emptiness {\n-        // If we reached here, the set is empty.\n-        MissingCtors::Empty\n-    } else {\n-        MissingCtors::Ctors(missing_ctors)\n+impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let ctors: Vec<_> = self.iter().collect();\n+        write!(f, \"{:?}\", ctors)\n     }\n }\n \n@@ -1188,8 +1460,8 @@ fn compute_missing_ctors<'tcx>(\n pub fn is_useful<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &[&Pat<'tcx>],\n-    witness: WitnessPreference,\n+    v: &PatStack<'_, 'tcx>,\n+    witness_preference: WitnessPreference,\n     hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n@@ -1202,21 +1474,19 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     // the type of the tuple we're checking is inhabited or not.\n     if v.is_empty() {\n         return if rows.is_empty() {\n-            match witness {\n-                ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-                LeaveOutWitness => Useful,\n-            }\n+            Usefulness::new_useful(witness_preference)\n         } else {\n             NotUseful\n-        }\n+        };\n     };\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-    let (ty, span) = rows.iter()\n-        .map(|r| (r[0].ty, r[0].span))\n+    let (ty, span) = matrix\n+        .heads()\n+        .map(|r| (r.ty, r.span))\n         .find(|(ty, _)| !ty.references_error())\n-        .unwrap_or((v[0].ty, v[0].span));\n+        .unwrap_or((v.head().ty, v.head().span));\n     let pcx = PatCtxt {\n         // TyErr is used to represent the type of wildcard patterns matching\n         // against inaccessible (private) fields of structs, so that we won't\n@@ -1238,31 +1508,41 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n         ty,\n-        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0]))),\n+        max_slice_length: max_slice_length(cx, matrix.heads().chain(Some(v.head()))),\n         span,\n     };\n \n-    debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n+    debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n-    if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n+    if let Some(constructors) = pat_constructors(cx, v.head(), pcx) {\n         debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n         split_grouped_constructors(\n-            cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n-        ).into_iter().map(|c|\n-            is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n-        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n+            cx.tcx,\n+            cx.param_env,\n+            constructors,\n+            matrix,\n+            pcx.ty,\n+            pcx.span,\n+            Some(hir_id),\n+        )\n+        .into_iter()\n+        .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id))\n+        .find(|result| result.is_useful())\n+        .unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n-        let used_ctors: Vec<Constructor<'_>> = rows.iter().flat_map(|row| {\n-            pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n-        }).collect();\n+        let used_ctors: Vec<Constructor<'_>> =\n+            matrix.heads().flat_map(|p| pat_constructors(cx, p, pcx).unwrap_or(vec![])).collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n         let all_ctors = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n \n+        let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+        let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n+\n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n         // from the first column.\n@@ -1283,118 +1563,98 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // needed for that case.\n \n         // Missing constructors are those that are not matched by any\n-        // non-wildcard patterns in the current column. We always determine if\n-        // the set is empty, but we only fully construct them on-demand,\n-        // because they're rarely used and can be big.\n-        let cheap_missing_ctors = compute_missing_ctors(\n-            MissingCtorsInfo::Emptiness, cx.tcx, cx.param_env, &all_ctors, &used_ctors,\n+        // non-wildcard patterns in the current column. To determine if\n+        // the set is empty, we can check that `.peek().is_none()`, so\n+        // we only fully construct them on-demand, because they're rarely used and can be big.\n+        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n+\n+        debug!(\n+            \"missing_ctors.empty()={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n+            missing_ctors.is_empty(),\n+            is_privately_empty,\n+            is_declared_nonexhaustive\n         );\n \n-        let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-        let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-        debug!(\"cheap_missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n-               cheap_missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n-\n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n         // `_` constructor for the type, so we can never match over all constructors.\n-        let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive ||\n-            (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n+        let is_non_exhaustive = is_privately_empty\n+            || is_declared_nonexhaustive\n+            || (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n-        if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n+        if missing_ctors.is_empty() && !is_non_exhaustive {\n+            let (all_ctors, _) = missing_ctors.into_inner();\n             split_grouped_constructors(\n-                cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty, DUMMY_SP, None,\n+                cx.tcx,\n+                cx.param_env,\n+                all_ctors,\n+                matrix,\n+                pcx.ty,\n+                DUMMY_SP,\n+                None,\n             )\n-                .into_iter()\n-                .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id))\n-                .find(|result| result.is_useful())\n-                .unwrap_or(NotUseful)\n+            .into_iter()\n+            .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id))\n+            .find(|result| result.is_useful())\n+            .unwrap_or(NotUseful)\n         } else {\n-            let matrix = rows.iter().filter_map(|r| {\n-                if r[0].is_wildcard() {\n-                    Some(SmallVec::from_slice(&r[1..]))\n-                } else {\n-                    None\n-                }\n-            }).collect();\n-            match is_useful(cx, &matrix, &v[1..], witness, hir_id) {\n-                UsefulWithWitness(pats) => {\n-                    let cx = &*cx;\n-                    // In this case, there's at least one \"free\"\n-                    // constructor that is only matched against by\n-                    // wildcard patterns.\n-                    //\n-                    // There are 2 ways we can report a witness here.\n-                    // Commonly, we can report all the \"free\"\n-                    // constructors as witnesses, e.g., if we have:\n-                    //\n-                    // ```\n-                    //     enum Direction { N, S, E, W }\n-                    //     let Direction::N = ...;\n-                    // ```\n-                    //\n-                    // we can report 3 witnesses: `S`, `E`, and `W`.\n-                    //\n-                    // However, there are 2 cases where we don't want\n-                    // to do this and instead report a single `_` witness:\n-                    //\n-                    // 1) If the user is matching against a non-exhaustive\n-                    // enum, there is no point in enumerating all possible\n-                    // variants, because the user can't actually match\n-                    // against them himself, e.g., in an example like:\n-                    // ```\n-                    //     let err: io::ErrorKind = ...;\n-                    //     match err {\n-                    //         io::ErrorKind::NotFound => {},\n-                    //     }\n-                    // ```\n-                    // we don't want to show every possible IO error,\n-                    // but instead have `_` as the witness (this is\n-                    // actually *required* if the user specified *all*\n-                    // IO errors, but is probably what we want in every\n-                    // case).\n-                    //\n-                    // 2) If the user didn't actually specify a constructor\n-                    // in this arm, e.g., in\n-                    // ```\n-                    //     let x: (Direction, Direction, bool) = ...;\n-                    //     let (_, _, false) = x;\n-                    // ```\n-                    // we don't want to show all 16 possible witnesses\n-                    // `(<direction-1>, <direction-2>, true)` - we are\n-                    // satisfied with `(_, _, true)`. In this case,\n-                    // `used_ctors` is empty.\n-                    let new_witnesses = if is_non_exhaustive || used_ctors.is_empty() {\n-                        // All constructors are unused. Add wild patterns\n-                        // rather than each individual constructor.\n-                        pats.into_iter().map(|mut witness| {\n-                            witness.0.push(Pat {\n-                                ty: pcx.ty,\n-                                span: DUMMY_SP,\n-                                kind: box PatKind::Wild,\n-                            });\n-                            witness\n-                        }).collect()\n-                    } else {\n-                        let expensive_missing_ctors = compute_missing_ctors(\n-                            MissingCtorsInfo::Ctors, cx.tcx, cx.param_env, &all_ctors, &used_ctors,\n-                        );\n-                        if let MissingCtors::Ctors(missing_ctors) = expensive_missing_ctors {\n-                            pats.into_iter().flat_map(|witness| {\n-                                missing_ctors.iter().map(move |ctor| {\n-                                    // Extends the witness with a \"wild\" version of this\n-                                    // constructor, that matches everything that can be built with\n-                                    // it. For example, if `ctor` is a `Constructor::Variant` for\n-                                    // `Option::Some`, this pushes the witness for `Some(_)`.\n-                                    witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n-                                })\n-                            }).collect()\n-                        } else {\n-                            bug!(\"cheap missing ctors\")\n-                        }\n-                    };\n-                    UsefulWithWitness(new_witnesses)\n-                }\n-                result => result\n+            let matrix = matrix.specialize_wildcard();\n+            let v = v.to_tail();\n+            let usefulness = is_useful(cx, &matrix, &v, witness_preference, hir_id);\n+\n+            // In this case, there's at least one \"free\"\n+            // constructor that is only matched against by\n+            // wildcard patterns.\n+            //\n+            // There are 2 ways we can report a witness here.\n+            // Commonly, we can report all the \"free\"\n+            // constructors as witnesses, e.g., if we have:\n+            //\n+            // ```\n+            //     enum Direction { N, S, E, W }\n+            //     let Direction::N = ...;\n+            // ```\n+            //\n+            // we can report 3 witnesses: `S`, `E`, and `W`.\n+            //\n+            // However, there are 2 cases where we don't want\n+            // to do this and instead report a single `_` witness:\n+            //\n+            // 1) If the user is matching against a non-exhaustive\n+            // enum, there is no point in enumerating all possible\n+            // variants, because the user can't actually match\n+            // against them themselves, e.g., in an example like:\n+            // ```\n+            //     let err: io::ErrorKind = ...;\n+            //     match err {\n+            //         io::ErrorKind::NotFound => {},\n+            //     }\n+            // ```\n+            // we don't want to show every possible IO error,\n+            // but instead have `_` as the witness (this is\n+            // actually *required* if the user specified *all*\n+            // IO errors, but is probably what we want in every\n+            // case).\n+            //\n+            // 2) If the user didn't actually specify a constructor\n+            // in this arm, e.g., in\n+            // ```\n+            //     let x: (Direction, Direction, bool) = ...;\n+            //     let (_, _, false) = x;\n+            // ```\n+            // we don't want to show all 16 possible witnesses\n+            // `(<direction-1>, <direction-2>, true)` - we are\n+            // satisfied with `(_, _, true)`. In this case,\n+            // `used_ctors` is empty.\n+            if is_non_exhaustive || missing_ctors.all_ctors_are_missing() {\n+                // All constructors are unused. Add a wild pattern\n+                // rather than each individual constructor.\n+                usefulness.apply_wildcard(pcx.ty)\n+            } else {\n+                // Construct for each missing constructor a \"wild\" version of this\n+                // constructor, that matches everything that can be built with\n+                // it. For example, if `ctor` is a `Constructor::Variant` for\n+                // `Option::Some`, we get the pattern `Some(_)`.\n+                usefulness.apply_missing_ctors(cx, pcx.ty, &missing_ctors)\n             }\n         }\n     }\n@@ -1404,47 +1664,30 @@ pub fn is_useful<'p, 'a, 'tcx>(\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n fn is_useful_specialized<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    &Matrix(ref m): &Matrix<'p, 'tcx>,\n-    v: &[&Pat<'tcx>],\n+    matrix: &Matrix<'p, 'tcx>,\n+    v: &PatStack<'_, 'tcx>,\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n-    witness: WitnessPreference,\n+    witness_preference: WitnessPreference,\n     hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n-    let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n-    let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n-        Pat {\n-            ty,\n-            span: DUMMY_SP,\n-            kind: box PatKind::Wild,\n-        }\n-    }).collect();\n-    let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n-    let matrix = Matrix(\n-        m.iter()\n-            .filter_map(|r| specialize(cx, &r, &ctor, &wild_patterns))\n-            .collect()\n-    );\n-    match specialize(cx, v, &ctor, &wild_patterns) {\n-        Some(v) => match is_useful(cx, &matrix, &v, witness, hir_id) {\n-            UsefulWithWitness(witnesses) => UsefulWithWitness(\n-                witnesses.into_iter()\n-                    .map(|witness| witness.apply_constructor(cx, &ctor, lty))\n-                    .collect()\n-            ),\n-            result => result\n-        }\n-        None => NotUseful\n-    }\n+\n+    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty).collect();\n+    let ctor_wild_subpatterns: Vec<_> = ctor_wild_subpatterns_owned.iter().collect();\n+    let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n+    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+        .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id))\n+        .map(|u| u.apply_constructor(cx, &ctor, lty))\n+        .unwrap_or(NotUseful)\n }\n \n /// Determines the constructors that the given pattern can be specialized to.\n ///\n /// In most cases, there's only one constructor that a specific pattern\n /// represents, such as a specific enum variant or a specific literal value.\n /// Slice patterns, however, can match slices of different lengths. For instance,\n-/// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n+/// `[a, b, tail @ ..]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructors<'tcx>(\n@@ -1453,32 +1696,28 @@ fn pat_constructors<'tcx>(\n     pcx: PatCtxt<'tcx>,\n ) -> Option<Vec<Constructor<'tcx>>> {\n     match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } =>\n-            pat_constructors(cx, subpattern, pcx),\n+        PatKind::AscribeUserType { ref subpattern, .. } => pat_constructors(cx, subpattern, pcx),\n         PatKind::Binding { .. } | PatKind::Wild => None,\n         PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(vec![Single]),\n         PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n         PatKind::Constant { value } => Some(vec![ConstantValue(value, pat.span)]),\n-        PatKind::Range(PatRange { lo, hi, end }) =>\n-            Some(vec![ConstantRange(\n-                lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n-                hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n-                lo.ty,\n-                end,\n-                pat.span,\n-            )]),\n+        PatKind::Range(PatRange { lo, hi, end }) => Some(vec![ConstantRange(\n+            lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n+            hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n+            lo.ty,\n+            end,\n+            pat.span,\n+        )]),\n         PatKind::Array { .. } => match pcx.ty.kind {\n-            ty::Array(_, length) => Some(vec![\n-                Slice(length.eval_usize(cx.tcx, cx.param_env))\n-            ]),\n-            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n+            ty::Array(_, length) => Some(vec![Slice(length.eval_usize(cx.tcx, cx.param_env))]),\n+            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty),\n         },\n         PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let pat_len = prefix.len() as u64 + suffix.len() as u64;\n             if slice.is_some() {\n-                Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n+                Some((pat_len..pcx.max_slice_length + 1).map(Slice).collect())\n             } else {\n                 Some(vec![Slice(pat_len)])\n             }\n@@ -1489,28 +1728,6 @@ fn pat_constructors<'tcx>(\n     }\n }\n \n-/// This computes the arity of a constructor. The arity of a constructor\n-/// is how many subpattern patterns of that constructor should be expanded to.\n-///\n-/// For instance, a tuple pattern `(_, 42, Some([]))` has the arity of 3.\n-/// A struct pattern's arity is the number of fields it contains, etc.\n-fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty: Ty<'tcx>) -> u64 {\n-    debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n-    match ty.kind {\n-        ty::Tuple(ref fs) => fs.len() as u64,\n-        ty::Slice(..) | ty::Array(..) => match *ctor {\n-            Slice(length) => length,\n-            ConstantValue(..) => 0,\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n-        }\n-        ty::Ref(..) => 1,\n-        ty::Adt(adt, _) => {\n-            adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.len() as u64\n-        }\n-        _ => 0\n-    }\n-}\n-\n /// This computes the types of the sub patterns that a constructor should be\n /// expanded to.\n ///\n@@ -1526,8 +1743,8 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(..) => vec![],\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n-        }\n+            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n+        },\n         ty::Ref(_, rty, _) => vec![rty],\n         ty::Adt(adt, substs) => {\n             if adt.is_box() {\n@@ -1536,30 +1753,37 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n             } else {\n                 let variant = &adt.variants[ctor.variant_index_for_adt(cx, adt)];\n                 let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n-                variant.fields.iter().map(|field| {\n-                    let is_visible = adt.is_enum()\n-                        || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                    let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n-                    match (is_visible, is_non_exhaustive, is_uninhabited) {\n-                        // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n-                        (_, true, true) => cx.tcx.types.err,\n-                        // Treat all non-visible fields as `TyErr`. They can't appear in any\n-                        // other pattern from this match (because they are private), so their\n-                        // type does not matter - but we don't want to know they are uninhabited.\n-                        (false, ..) => cx.tcx.types.err,\n-                        (true, ..) => {\n-                            let ty = field.ty(cx.tcx, substs);\n-                            match ty.kind {\n-                                // If the field type returned is an array of an unknown\n-                                // size return an TyErr.\n-                                ty::Array(_, len)\n-                                    if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n-                                    cx.tcx.types.err,\n-                                _ => ty,\n+                variant\n+                    .fields\n+                    .iter()\n+                    .map(|field| {\n+                        let is_visible =\n+                            adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                        let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                        match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                            // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n+                            (_, true, true) => cx.tcx.types.err,\n+                            // Treat all non-visible fields as `TyErr`. They can't appear in any\n+                            // other pattern from this match (because they are private), so their\n+                            // type does not matter - but we don't want to know they are\n+                            // uninhabited.\n+                            (false, ..) => cx.tcx.types.err,\n+                            (true, ..) => {\n+                                let ty = field.ty(cx.tcx, substs);\n+                                match ty.kind {\n+                                    // If the field type returned is an array of an unknown size\n+                                    // return an TyErr.\n+                                    ty::Array(_, len)\n+                                        if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n+                                    {\n+                                        cx.tcx.types.err\n+                                    }\n+                                    _ => ty,\n+                                }\n                             }\n-                        },\n-                    }\n-                }).collect()\n+                        }\n+                    })\n+                    .collect()\n             }\n         }\n         _ => vec![],\n@@ -1584,17 +1808,20 @@ fn slice_pat_covered_by_const<'tcx>(\n             let n = n.eval_usize(tcx, param_env);\n             let ptr = Pointer::new(AllocId(0), offset);\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n-        },\n+        }\n         (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n             assert_eq!(*t, tcx.types.u8);\n             let ptr = Pointer::new(AllocId(0), Size::from_bytes(start as u64));\n             data.get_bytes(&tcx, ptr, Size::from_bytes((end - start) as u64)).unwrap()\n-        },\n+        }\n         // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n         (_, ty::Slice(_)) => return Ok(false),\n         _ => bug!(\n             \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val, prefix, slice, suffix,\n+            const_val,\n+            prefix,\n+            slice,\n+            suffix,\n         ),\n     };\n \n@@ -1603,9 +1830,10 @@ fn slice_pat_covered_by_const<'tcx>(\n         return Ok(false);\n     }\n \n-    for (ch, pat) in\n-        data[..prefix.len()].iter().zip(prefix).chain(\n-            data[data.len()-suffix.len()..].iter().zip(suffix))\n+    for (ch, pat) in data[..prefix.len()]\n+        .iter()\n+        .zip(prefix)\n+        .chain(data[data.len() - suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n             box PatKind::Constant { value } => {\n@@ -1676,7 +1904,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n-    &Matrix(ref m): &Matrix<'p, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n     hir_id: Option<HirId>,\n@@ -1718,9 +1946,11 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 let mut overlaps = vec![];\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n-                let row_borders = m.iter()\n+                let row_borders = matrix\n+                    .0\n+                    .iter()\n                     .flat_map(|row| {\n-                        IntRange::from_pat(tcx, param_env, row[0]).map(|r| (r, row.len()))\n+                        IntRange::from_pat(tcx, param_env, row.head()).map(|r| (r, row.len()))\n                     })\n                     .flat_map(|(range, row_len)| {\n                         let intersection = ctor_range.intersection(&range);\n@@ -1745,11 +1975,11 @@ fn split_grouped_constructors<'p, 'tcx>(\n \n                 lint_overlapping_patterns(tcx, hir_id, ctor_range, ty, overlaps);\n \n-                // We're going to iterate through every pair of borders, making sure that each\n-                // represents an interval of nonnegative length, and convert each such interval\n-                // into a constructor.\n-                for IntRange { range, .. } in borders.windows(2).filter_map(|window| {\n-                    match (window[0], window[1]) {\n+                // We're going to iterate through every adjacent pair of borders, making sure that\n+                // each represents an interval of nonnegative length, and convert each such\n+                // interval into a constructor.\n+                for IntRange { range, .. } in\n+                    borders.windows(2).filter_map(|window| match (window[0], window[1]) {\n                         (Border::JustBefore(n), Border::JustBefore(m)) => {\n                             if n < m {\n                                 Some(IntRange { range: n..=(m - 1), ty, span })\n@@ -1761,8 +1991,8 @@ fn split_grouped_constructors<'p, 'tcx>(\n                             Some(IntRange { range: n..=u128::MAX, ty, span })\n                         }\n                         (Border::AfterMax, _) => None,\n-                    }\n-                }) {\n+                    })\n+                {\n                     split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n@@ -1791,10 +2021,13 @@ fn lint_overlapping_patterns(\n         err.span_label(ctor_range.span, \"overlapping patterns\");\n         for int_range in overlaps {\n             // Use the real type for user display of the ranges:\n-            err.span_label(int_range.span, &format!(\n-                \"this range overlaps on `{}`\",\n-                IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP).display(tcx),\n-            ));\n+            err.span_label(\n+                int_range.span,\n+                &format!(\n+                    \"this range overlaps on `{}`\",\n+                    IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP).display(tcx),\n+                ),\n+            );\n         }\n         err.emit();\n     }\n@@ -1812,8 +2045,9 @@ fn constructor_covered_by_range<'tcx>(\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n-    let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, param_env, ty)\n-        .map(|res| res != Ordering::Less);\n+    let cmp_from = |c_from| {\n+        compare_const_vals(tcx, c_from, from, param_env, ty).map(|res| res != Ordering::Less)\n+    };\n     let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, param_env, ty);\n     macro_rules! some_or_ok {\n         ($e:expr) => {\n@@ -1826,37 +2060,31 @@ fn constructor_covered_by_range<'tcx>(\n     match *ctor {\n         ConstantValue(value, _) => {\n             let to = some_or_ok!(cmp_to(value));\n-            let end = (to == Ordering::Less) ||\n-                      (end == RangeEnd::Included && to == Ordering::Equal);\n+            let end =\n+                (to == Ordering::Less) || (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(value)) && end)\n-        },\n+        }\n         ConstantRange(from, to, ty, RangeEnd::Included, _) => {\n-            let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n-                tcx,\n-                to,\n-                ty::ParamEnv::empty().and(ty),\n-            )));\n-            let end = (to == Ordering::Less) ||\n-                      (end == RangeEnd::Included && to == Ordering::Equal);\n+            let to =\n+                some_or_ok!(cmp_to(ty::Const::from_bits(tcx, to, ty::ParamEnv::empty().and(ty),)));\n+            let end =\n+                (to == Ordering::Less) || (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n                 tcx,\n                 from,\n                 ty::ParamEnv::empty().and(ty),\n             ))) && end)\n-        },\n+        }\n         ConstantRange(from, to, ty, RangeEnd::Excluded, _) => {\n-            let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n-                tcx,\n-                to,\n-                ty::ParamEnv::empty().and(ty)\n-            )));\n-            let end = (to == Ordering::Less) ||\n-                      (end == RangeEnd::Excluded && to == Ordering::Equal);\n+            let to =\n+                some_or_ok!(cmp_to(ty::Const::from_bits(tcx, to, ty::ParamEnv::empty().and(ty))));\n+            let end =\n+                (to == Ordering::Less) || (end == RangeEnd::Excluded && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n                 tcx,\n                 from,\n-                ty::ParamEnv::empty().and(ty)))\n-            ) && end)\n+                ty::ParamEnv::empty().and(ty)\n+            ))) && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),\n@@ -1866,147 +2094,133 @@ fn constructor_covered_by_range<'tcx>(\n fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     subpatterns: &'p [FieldPat<'tcx>],\n-    wild_patterns: &[&'p Pat<'tcx>],\n+    ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n     is_non_exhaustive: bool,\n-) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n-    let mut result = SmallVec::from_slice(wild_patterns);\n+) -> PatStack<'p, 'tcx> {\n+    let mut result = SmallVec::from_slice(ctor_wild_subpatterns);\n \n     for subpat in subpatterns {\n         if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n             result[subpat.field.index()] = &subpat.pattern;\n         }\n     }\n \n-    debug!(\"patterns_for_variant({:#?}, {:#?}) = {:#?}\", subpatterns, wild_patterns, result);\n-    result\n+    debug!(\n+        \"patterns_for_variant({:#?}, {:#?}) = {:#?}\",\n+        subpatterns, ctor_wild_subpatterns, result\n+    );\n+    PatStack::from_vec(result)\n }\n \n-/// This is the main specialization step. It expands the first pattern in the given row\n+/// This is the main specialization step. It expands the pattern\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n+/// Returns `None` if the pattern does not have the given constructor.\n ///\n-/// OTOH, slice patterns with a subslice pattern (..tail) can be expanded into multiple\n+/// OTOH, slice patterns with a subslice pattern (tail @ ..) can be expanded into multiple\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize<'p, 'a: 'p, 'tcx>(\n+fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    r: &[&'p Pat<'tcx>],\n+    pat: &'q Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n-    wild_patterns: &[&'p Pat<'tcx>],\n-) -> Option<SmallVec<[&'p Pat<'tcx>; 2]>> {\n-    let pat = &r[0];\n-\n-    let head = match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } => {\n-            specialize(cx, ::std::slice::from_ref(&subpattern), constructor, wild_patterns)\n-        }\n+    ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n+) -> Option<PatStack<'p, 'tcx>> {\n+    let result = match *pat.kind {\n+        PatKind::AscribeUserType { ref subpattern, .. } => PatStack::from_pattern(subpattern)\n+            .specialize_constructor(cx, constructor, ctor_wild_subpatterns),\n \n         PatKind::Binding { .. } | PatKind::Wild => {\n-            Some(SmallVec::from_slice(wild_patterns))\n+            Some(PatStack::from_slice(ctor_wild_subpatterns))\n         }\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n             let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(pat.ty);\n             Some(Variant(variant.def_id))\n                 .filter(|variant_constructor| variant_constructor == constructor)\n-                .map(|_| patterns_for_variant(cx, subpatterns, wild_patterns, is_non_exhaustive))\n+                .map(|_| {\n+                    patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, is_non_exhaustive)\n+                })\n         }\n \n         PatKind::Leaf { ref subpatterns } => {\n-            Some(patterns_for_variant(cx, subpatterns, wild_patterns, false))\n+            Some(patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, false))\n         }\n \n-        PatKind::Deref { ref subpattern } => {\n-            Some(smallvec![subpattern])\n-        }\n+        PatKind::Deref { ref subpattern } => Some(PatStack::from_pattern(subpattern)),\n \n         PatKind::Constant { value } if constructor.is_slice() => {\n             // We extract an `Option` for the pointer because slices of zero\n             // elements don't necessarily point to memory, they are usually\n             // just integers. The only time they should be pointing to memory\n             // is when they are subslices of nonzero slices.\n             let (alloc, offset, n, ty) = match value.ty.kind {\n-                ty::Array(t, n) => {\n-                    match value.val {\n-                        ConstValue::ByRef { offset, alloc, .. } => (\n-                            alloc,\n-                            offset,\n-                            n.eval_usize(cx.tcx, cx.param_env),\n-                            t,\n-                        ),\n-                        _ => span_bug!(\n-                            pat.span,\n-                            \"array pattern is {:?}\", value,\n-                        ),\n+                ty::Array(t, n) => match value.val {\n+                    ConstValue::ByRef { offset, alloc, .. } => {\n+                        (alloc, offset, n.eval_usize(cx.tcx, cx.param_env), t)\n                     }\n+                    _ => span_bug!(pat.span, \"array pattern is {:?}\", value,),\n                 },\n                 ty::Slice(t) => {\n                     match value.val {\n-                        ConstValue::Slice { data, start, end } => (\n-                            data,\n-                            Size::from_bytes(start as u64),\n-                            (end - start) as u64,\n-                            t,\n-                        ),\n+                        ConstValue::Slice { data, start, end } => {\n+                            (data, Size::from_bytes(start as u64), (end - start) as u64, t)\n+                        }\n                         ConstValue::ByRef { .. } => {\n                             // FIXME(oli-obk): implement `deref` for `ConstValue`\n                             return None;\n-                        },\n+                        }\n                         _ => span_bug!(\n                             pat.span,\n                             \"slice pattern constant must be scalar pair but is {:?}\",\n                             value,\n                         ),\n                     }\n-                },\n+                }\n                 _ => span_bug!(\n                     pat.span,\n                     \"unexpected const-val {:?} with ctor {:?}\",\n                     value,\n                     constructor,\n                 ),\n             };\n-            if wild_patterns.len() as u64 == n {\n+            if ctor_wild_subpatterns.len() as u64 == n {\n                 // convert a constant slice/array pattern to a list of patterns.\n                 let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n                 let ptr = Pointer::new(AllocId(0), offset);\n-                (0..n).map(|i| {\n-                    let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                    let scalar = alloc.read_scalar(\n-                        &cx.tcx, ptr, layout.size,\n-                    ).ok()?;\n-                    let scalar = scalar.not_undef().ok()?;\n-                    let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                    let pattern = Pat {\n-                        ty,\n-                        span: pat.span,\n-                        kind: box PatKind::Constant { value },\n-                    };\n-                    Some(&*cx.pattern_arena.alloc(pattern))\n-                }).collect()\n+                (0..n)\n+                    .map(|i| {\n+                        let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                        let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n+                        let scalar = scalar.not_undef().ok()?;\n+                        let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                        let pattern =\n+                            Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n+                        Some(&*cx.pattern_arena.alloc(pattern))\n+                    })\n+                    .collect()\n             } else {\n                 None\n             }\n         }\n \n-        PatKind::Constant { .. } |\n-        PatKind::Range { .. } => {\n+        PatKind::Constant { .. } | PatKind::Range { .. } => {\n             // If the constructor is a:\n             // - Single value: add a row if the pattern contains the constructor.\n             // - Range: add a row if the constructor intersects the pattern.\n             if should_treat_range_exhaustively(cx.tcx, constructor) {\n-                match (IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n-                       IntRange::from_pat(cx.tcx, cx.param_env, pat)) {\n-                    (Some(ctor), Some(pat)) => {\n-                        ctor.intersection(&pat).map(|_| {\n-                            let (pat_lo, pat_hi) = pat.range.into_inner();\n-                            let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n-                            assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n-                            smallvec![]\n-                        })\n-                    }\n+                match (\n+                    IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n+                    IntRange::from_pat(cx.tcx, cx.param_env, pat),\n+                ) {\n+                    (Some(ctor), Some(pat)) => ctor.intersection(&pat).map(|_| {\n+                        let (pat_lo, pat_hi) = pat.range.into_inner();\n+                        let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n+                        assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n+                        PatStack::default()\n+                    }),\n                     _ => None,\n                 }\n             } else {\n@@ -2016,54 +2230,61 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                 // range so intersection actually devolves into being covered\n                 // by the pattern.\n                 match constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat) {\n-                    Ok(true) => Some(smallvec![]),\n+                    Ok(true) => Some(PatStack::default()),\n                     Ok(false) | Err(ErrorReported) => None,\n                 }\n             }\n         }\n \n-        PatKind::Array { ref prefix, ref slice, ref suffix } |\n-        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            match *constructor {\n-                Slice(..) => {\n-                    let pat_len = prefix.len() + suffix.len();\n-                    if let Some(slice_count) = wild_patterns.len().checked_sub(pat_len) {\n-                        if slice_count == 0 || slice.is_some() {\n-                            Some(prefix.iter().chain(\n-                                    wild_patterns.iter().map(|p| *p)\n-                                                 .skip(prefix.len())\n-                                                 .take(slice_count)\n-                                                 .chain(suffix.iter())\n-                            ).collect())\n-                        } else {\n-                            None\n-                        }\n+        PatKind::Array { ref prefix, ref slice, ref suffix }\n+        | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n+            Slice(..) => {\n+                let pat_len = prefix.len() + suffix.len();\n+                if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n+                    if slice_count == 0 || slice.is_some() {\n+                        Some(\n+                            prefix\n+                                .iter()\n+                                .chain(\n+                                    ctor_wild_subpatterns\n+                                        .iter()\n+                                        .map(|p| *p)\n+                                        .skip(prefix.len())\n+                                        .take(slice_count)\n+                                        .chain(suffix.iter()),\n+                                )\n+                                .collect(),\n+                        )\n                     } else {\n                         None\n                     }\n+                } else {\n+                    None\n                 }\n-                ConstantValue(cv, _) => {\n-                    match slice_pat_covered_by_const(\n-                        cx.tcx, pat.span, cv, prefix, slice, suffix, cx.param_env,\n-                    ) {\n-                        Ok(true) => Some(smallvec![]),\n-                        Ok(false) => None,\n-                        Err(ErrorReported) => None\n-                    }\n+            }\n+            ConstantValue(cv, _) => {\n+                match slice_pat_covered_by_const(\n+                    cx.tcx,\n+                    pat.span,\n+                    cv,\n+                    prefix,\n+                    slice,\n+                    suffix,\n+                    cx.param_env,\n+                ) {\n+                    Ok(true) => Some(PatStack::default()),\n+                    Ok(false) => None,\n+                    Err(ErrorReported) => None,\n                 }\n-                _ => span_bug!(pat.span,\n-                    \"unexpected ctor {:?} for slice pat\", constructor)\n             }\n-        }\n+            _ => span_bug!(pat.span, \"unexpected ctor {:?} for slice pat\", constructor),\n+        },\n \n         PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n         }\n     };\n-    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r[0], wild_patterns, head);\n+    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", pat, ctor_wild_subpatterns, result);\n \n-    head.map(|mut head| {\n-        head.extend_from_slice(&r[1 ..]);\n-        head\n-    })\n+    result\n }"}, {"sha": "9d370554e86b40c30d82e2c488ae6328ebdfc8b0", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 136, "deletions": 108, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/881ebeb776cf4062a85a20b15f64c7349319518c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881ebeb776cf4062a85a20b15f64c7349319518c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=881ebeb776cf4062a85a20b15f64c7349319518c", "patch": "@@ -1,25 +1,24 @@\n-use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n+use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack};\n \n-use super::{PatCtxt, PatternError, PatKind};\n+use super::{PatCtxt, PatKind, PatternError};\n \n+use rustc::lint;\n use rustc::session::Session;\n-use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc::lint;\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n \n-use rustc::hir::HirId;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::HirId;\n use rustc::hir::{self, Pat};\n \n-use smallvec::smallvec;\n use std::slice;\n \n-use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match tcx.hir().as_local_hir_id(def_id) {\n@@ -100,13 +99,15 @@ impl PatCtxt<'_, '_> {\n                     ::rustc::mir::interpret::struct_error(\n                         self.tcx.at(pat_span),\n                         \"could not evaluate float literal (see issue #31407)\",\n-                    ).emit();\n+                    )\n+                    .emit();\n                 }\n                 PatternError::NonConstPath(span) => {\n                     ::rustc::mir::interpret::struct_error(\n                         self.tcx.at(span),\n                         \"runtime values cannot be referenced in patterns\",\n-                    ).emit();\n+                    )\n+                    .emit();\n                 }\n             }\n         }\n@@ -123,12 +124,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         check_legality_of_bindings_in_at_patterns(self, pat);\n     }\n \n-    fn check_match(\n-        &mut self,\n-        scrut: &hir::Expr,\n-        arms: &'tcx [hir::Arm],\n-        source: hir::MatchSource\n-    ) {\n+    fn check_match(&mut self, scrut: &hir::Expr, arms: &'tcx [hir::Arm], source: hir::MatchSource) {\n         for arm in arms {\n             // First, check legality of move bindings.\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n@@ -141,31 +137,41 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n-            let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n-                // HACK(or_patterns; Centril | dlrobertson): Remove this and\n-                // correctly handle exhaustiveness checking for nested or-patterns.\n-                match &arm.pat.kind {\n-                    hir::PatKind::Or(pats) => pats,\n-                    _ => std::slice::from_ref(&arm.pat),\n-                }.iter().map(|pat| {\n-                    let mut patcx = PatCtxt::new(\n-                        self.tcx,\n-                        self.param_env.and(self.identity_substs),\n-                        self.tables\n-                    );\n-                    patcx.include_lint_checks();\n-                    let pattern =\n-                        cx.pattern_arena.alloc(expand_pattern(cx, patcx.lower_pattern(&pat))) as &_;\n-                    if !patcx.errors.is_empty() {\n-                        patcx.report_inlining_errors(pat.span);\n-                        have_errors = true;\n-                    }\n-                    (pattern, &**pat)\n-                }).collect(),\n-                arm.guard.as_ref().map(|g| match g {\n-                    hir::Guard::If(ref e) => &**e,\n+            let inlined_arms: Vec<(Vec<_>, _)> = arms\n+                .iter()\n+                .map(|arm| {\n+                    (\n+                        // HACK(or_patterns; Centril | dlrobertson): Remove this and\n+                        // correctly handle exhaustiveness checking for nested or-patterns.\n+                        match &arm.pat.kind {\n+                            hir::PatKind::Or(pats) => pats,\n+                            _ => std::slice::from_ref(&arm.pat),\n+                        }\n+                        .iter()\n+                        .map(|pat| {\n+                            let mut patcx = PatCtxt::new(\n+                                self.tcx,\n+                                self.param_env.and(self.identity_substs),\n+                                self.tables,\n+                            );\n+                            patcx.include_lint_checks();\n+                            let pattern = cx\n+                                .pattern_arena\n+                                .alloc(expand_pattern(cx, patcx.lower_pattern(&pat)))\n+                                as &_;\n+                            if !patcx.errors.is_empty() {\n+                                patcx.report_inlining_errors(pat.span);\n+                                have_errors = true;\n+                            }\n+                            (pattern, &**pat)\n+                        })\n+                        .collect(),\n+                        arm.guard.as_ref().map(|g| match g {\n+                            hir::Guard::If(ref e) => &**e,\n+                        }),\n+                    )\n                 })\n-            )).collect();\n+                .collect();\n \n             // Bail out early if inlining failed.\n             if have_errors {\n@@ -191,36 +197,42 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                             def_span = self.tcx.hir().span_if_local(def.did);\n                             if def.variants.len() < 4 && !def.variants.is_empty() {\n                                 // keep around to point at the definition of non-covered variants\n-                                missing_variants = def.variants.iter()\n-                                    .map(|variant| variant.ident)\n-                                    .collect();\n+                                missing_variants =\n+                                    def.variants.iter().map(|variant| variant.ident).collect();\n                             }\n \n                             let is_non_exhaustive_and_non_local =\n                                 def.is_variant_list_non_exhaustive() && !def.did.is_local();\n \n                             !(is_non_exhaustive_and_non_local) && def.variants.is_empty()\n-                        },\n-                        _ => false\n+                        }\n+                        _ => false,\n                     }\n                 };\n                 if !scrutinee_is_uninhabited {\n                     // We know the type is inhabited, so this must be wrong\n                     let mut err = create_e0004(\n                         self.tcx.sess,\n                         scrut.span,\n-                        format!(\"non-exhaustive patterns: {}\", match missing_variants.len() {\n-                            0 => format!(\"type `{}` is non-empty\", pat_ty),\n-                            1 => format!(\n-                                \"pattern `{}` of type `{}` is not handled\",\n-                                missing_variants[0].name,\n-                                pat_ty,\n-                            ),\n-                            _ => format!(\"multiple patterns of type `{}` are not handled\", pat_ty),\n-                        }),\n+                        format!(\n+                            \"non-exhaustive patterns: {}\",\n+                            match missing_variants.len() {\n+                                0 => format!(\"type `{}` is non-empty\", pat_ty),\n+                                1 => format!(\n+                                    \"pattern `{}` of type `{}` is not handled\",\n+                                    missing_variants[0].name, pat_ty,\n+                                ),\n+                                _ => format!(\n+                                    \"multiple patterns of type `{}` are not handled\",\n+                                    pat_ty\n+                                ),\n+                            }\n+                        ),\n+                    );\n+                    err.help(\n+                        \"ensure that all possible cases are being handled, \\\n+                         possibly by adding wildcards or more match arms\",\n                     );\n-                    err.help(\"ensure that all possible cases are being handled, \\\n-                              possibly by adding wildcards or more match arms\");\n                     if let Some(sp) = def_span {\n                         err.span_label(sp, format!(\"`{}` defined here\", pat_ty));\n                     }\n@@ -238,7 +250,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n-                .map(|pat| smallvec![pat.0])\n+                .map(|pat| PatStack::from_pattern(pat.0))\n                 .collect();\n             let scrut_ty = self.tables.node_type(scrut.hir_id);\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n@@ -248,16 +260,13 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n-            let mut patcx = PatCtxt::new(self.tcx,\n-                                                self.param_env.and(self.identity_substs),\n-                                                self.tables);\n+            let mut patcx =\n+                PatCtxt::new(self.tcx, self.param_env.and(self.identity_substs), self.tables);\n             patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n             let pattern = expand_pattern(cx, pattern);\n-            let pats: Matrix<'_, '_> = vec![smallvec![\n-                &pattern\n-            ]].into_iter().collect();\n+            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(&pattern)].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n@@ -266,9 +275,12 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n             let joined_patterns = joined_uncovered_patterns(&witnesses);\n             let mut err = struct_span_err!(\n-                self.tcx.sess, pat.span, E0005,\n+                self.tcx.sess,\n+                pat.span,\n+                E0005,\n                 \"refutable pattern in {}: {} not covered\",\n-                origin, joined_patterns\n+                origin,\n+                joined_patterns\n             );\n             let suggest_if_let = match &pat.kind {\n                 hir::PatKind::Path(hir::QPath::Resolved(None, path))\n@@ -287,8 +299,10 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             };\n \n             if let (Some(span), true) = (sp, suggest_if_let) {\n-                err.note(\"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                          an `enum` with only one variant\");\n+                err.note(\n+                    \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n+                     an `enum` with only one variant\",\n+                );\n                 if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                     err.span_suggestion(\n                         span,\n@@ -297,8 +311,10 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                         Applicability::HasPlaceholders,\n                     );\n                 }\n-                err.note(\"for more information, visit \\\n-                          https://doc.rust-lang.org/book/ch18-02-refutability.html\");\n+                err.note(\n+                    \"for more information, visit \\\n+                     https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n+                );\n             }\n \n             adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n@@ -311,11 +327,10 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n /// This caused an irrefutable match failure in e.g. `let`.\n fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, path: &hir::Path) {\n     let descr = path.res.descr();\n-    err.span_label(pat.span, format!(\n-        \"interpreted as {} {} pattern, not a new variable\",\n-        path.res.article(),\n-        descr,\n-    ));\n+    err.span_label(\n+        pat.span,\n+        format!(\"interpreted as {} {} pattern, not a new variable\", path.res.article(), descr,),\n+    );\n \n     err.span_suggestion(\n         pat.span,\n@@ -342,19 +357,26 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                 }\n                 let pat_ty = cx.tables.pat_ty(p);\n                 if let ty::Adt(edef, _) = pat_ty.kind {\n-                    if edef.is_enum() && edef.variants.iter().any(|variant| {\n-                        variant.ident == ident && variant.ctor_kind == CtorKind::Const\n-                    }) {\n+                    if edef.is_enum()\n+                        && edef.variants.iter().any(|variant| {\n+                            variant.ident == ident && variant.ctor_kind == CtorKind::Const\n+                        })\n+                    {\n                         let ty_path = cx.tcx.def_path_str(edef.did);\n-                        let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                        let mut err = struct_span_warn!(\n+                            cx.tcx.sess,\n+                            p.span,\n+                            E0170,\n                             \"pattern binding `{}` is named the same as one \\\n-                            of the variants of the type `{}`\",\n-                            ident, ty_path);\n+                             of the variants of the type `{}`\",\n+                            ident,\n+                            ty_path\n+                        );\n                         err.span_suggestion(\n                             p.span,\n                             \"to match on the variant, qualify the path\",\n                             format!(\"{}::{}\", ty_path, ident),\n-                            Applicability::MachineApplicable\n+                            Applicability::MachineApplicable,\n                         );\n                         err.emit();\n                     }\n@@ -373,10 +395,8 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n         hir::PatKind::Binding(.., None) => true,\n         hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n         hir::PatKind::Ref(ref s, _) => pat_is_catchall(s),\n-        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n-            pat_is_catchall(&p)\n-        }),\n-        _ => false\n+        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(&p)),\n+        _ => false,\n     }\n }\n \n@@ -390,13 +410,14 @@ fn check_arms<'tcx>(\n     let mut catchall = None;\n     for (arm_index, &(ref pats, guard)) in arms.iter().enumerate() {\n         for &(pat, hir_pat) in pats {\n-            let v = smallvec![pat];\n+            let v = PatStack::from_pattern(pat);\n \n             match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n                 NotUseful => {\n                     match source {\n-                        hir::MatchSource::IfDesugar { .. } |\n-                        hir::MatchSource::WhileDesugar => bug!(),\n+                        hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => {\n+                            bug!()\n+                        }\n                         hir::MatchSource::IfLetDesugar { .. } => {\n                             cx.tcx.lint_hir(\n                                 lint::builtin::IRREFUTABLE_LET_PATTERNS,\n@@ -413,9 +434,11 @@ fn check_arms<'tcx>(\n                                 0 => {\n                                     cx.tcx.lint_hir(\n                                         lint::builtin::UNREACHABLE_PATTERNS,\n-                                        hir_pat.hir_id, pat.span,\n-                                        \"unreachable pattern\");\n-                                },\n+                                        hir_pat.hir_id,\n+                                        pat.span,\n+                                        \"unreachable pattern\",\n+                                    );\n+                                }\n                                 // The arm with the wildcard pattern.\n                                 1 => {\n                                     cx.tcx.lint_hir(\n@@ -424,13 +447,12 @@ fn check_arms<'tcx>(\n                                         pat.span,\n                                         \"irrefutable while-let pattern\",\n                                     );\n-                                },\n+                                }\n                                 _ => bug!(),\n                             }\n                         }\n \n-                        hir::MatchSource::ForLoopDesugar |\n-                        hir::MatchSource::Normal => {\n+                        hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n                             let mut err = cx.tcx.struct_span_lint_hir(\n                                 lint::builtin::UNREACHABLE_PATTERNS,\n                                 hir_pat.hir_id,\n@@ -447,12 +469,11 @@ fn check_arms<'tcx>(\n \n                         // Unreachable patterns in try and await expressions occur when one of\n                         // the arms are an uninhabited type. Which is OK.\n-                        hir::MatchSource::AwaitDesugar |\n-                        hir::MatchSource::TryDesugar => {}\n+                        hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                     }\n                 }\n                 Useful => (),\n-                UsefulWithWitness(_) => bug!()\n+                UsefulWithWitness(_) => bug!(),\n             }\n             if guard.is_none() {\n                 seen.push(v);\n@@ -471,7 +492,7 @@ fn check_not_useful(\n     hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n     let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n-    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness, hir_id) {\n+    match is_useful(cx, matrix, &PatStack::from_pattern(&wild_pattern), ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n             vec![wild_pattern]\n@@ -496,14 +517,15 @@ fn check_exhaustive<'tcx>(\n \n     let joined_patterns = joined_uncovered_patterns(&witnesses);\n     let mut err = create_e0004(\n-        cx.tcx.sess, sp,\n+        cx.tcx.sess,\n+        sp,\n         format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n     );\n     err.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n     adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n     err.help(\n         \"ensure that all possible cases are being handled, \\\n-        possibly by adding wildcards or more match arms\"\n+         possibly by adding wildcards or more match arms\",\n     )\n     .emit();\n }\n@@ -556,7 +578,7 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n         // Don't point at variants that have already been covered due to other patterns to avoid\n         // visual clutter.\n         for pattern in patterns {\n-            use PatKind::{AscribeUserType, Deref, Variant, Or, Leaf};\n+            use PatKind::{AscribeUserType, Deref, Leaf, Or, Variant};\n             match &*pattern.kind {\n                 AscribeUserType { subpattern, .. } | Deref { subpattern } => {\n                     covered.extend(maybe_point_at_variant(ty, slice::from_ref(&subpattern)));\n@@ -568,13 +590,15 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n                     }\n                     covered.push(sp);\n \n-                    let pats = subpatterns.iter()\n+                    let pats = subpatterns\n+                        .iter()\n                         .map(|field_pattern| field_pattern.pattern.clone())\n                         .collect::<Box<[_]>>();\n                     covered.extend(maybe_point_at_variant(ty, &pats));\n                 }\n                 Leaf { subpatterns } => {\n-                    let pats = subpatterns.iter()\n+                    let pats = subpatterns\n+                        .iter()\n                         .map(|field_pattern| field_pattern.pattern.clone())\n                         .collect::<Box<[_]>>();\n                     covered.extend(maybe_point_at_variant(ty, &pats));\n@@ -659,7 +683,7 @@ fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pa\n \n struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     cx: &'a MatchVisitor<'b, 'tcx>,\n-    bindings_allowed: bool\n+    bindings_allowed: bool,\n }\n \n impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n@@ -671,10 +695,14 @@ impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n         match pat.kind {\n             hir::PatKind::Binding(.., ref subpat) => {\n                 if !self.bindings_allowed {\n-                    struct_span_err!(self.cx.tcx.sess, pat.span, E0303,\n-                                     \"pattern bindings are not allowed after an `@`\")\n-                        .span_label(pat.span,  \"not allowed after `@`\")\n-                        .emit();\n+                    struct_span_err!(\n+                        self.cx.tcx.sess,\n+                        pat.span,\n+                        E0303,\n+                        \"pattern bindings are not allowed after an `@`\"\n+                    )\n+                    .span_label(pat.span, \"not allowed after `@`\")\n+                    .emit();\n                 }\n \n                 if subpat.is_some() {"}]}