{"sha": "c244fd79f22f7a78016f20fa252d93bae474f4bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNDRmZDc5ZjIyZjdhNzgwMTZmMjBmYTI1MmQ5M2JhZTQ3NGY0YmQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-15T15:55:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-31T16:11:02Z"}, "message": "kill old-style-lub warnings", "tree": {"sha": "a1967b84d5604e9b7ad447f46dad5a0139647a6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1967b84d5604e9b7ad447f46dad5a0139647a6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c244fd79f22f7a78016f20fa252d93bae474f4bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c244fd79f22f7a78016f20fa252d93bae474f4bd", "html_url": "https://github.com/rust-lang/rust/commit/c244fd79f22f7a78016f20fa252d93bae474f4bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c244fd79f22f7a78016f20fa252d93bae474f4bd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "740117f905b5e0c49659574087f6f7c80edf631a", "url": "https://api.github.com/repos/rust-lang/rust/commits/740117f905b5e0c49659574087f6f7c80edf631a", "html_url": "https://github.com/rust-lang/rust/commit/740117f905b5e0c49659574087f6f7c80edf631a"}], "stats": {"total": 321, "additions": 4, "deletions": 317}, "files": [{"sha": "8968c5949b617b8ccb8c525e547d78e6826c5b7c", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=c244fd79f22f7a78016f20fa252d93bae474f4bd", "patch": "@@ -15,7 +15,6 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n@@ -76,31 +75,12 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         where T: Relate<'tcx>\n     {\n         debug!(\"binders(a={:?}, b={:?})\", a, b);\n-        let was_error = self.infcx().probe(|_snapshot| {\n-            // Subtle: use a fresh combine-fields here because we recover\n-            // from Err. Doing otherwise could propagate obligations out\n-            // through our `self.obligations` field.\n-            self.infcx()\n-                .combine_fields(self.fields.trace.clone(), self.fields.param_env)\n-                .higher_ranked_glb(a, b, self.a_is_expected)\n-                .is_err()\n-        });\n-        debug!(\"binders: was_error={:?}\", was_error);\n \n         // When higher-ranked types are involved, computing the LUB is\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n-        match self.relate_with_variance(ty::Variance::Invariant, a, b) {\n-            Ok(_) => Ok(a.clone()),\n-            Err(err) => {\n-                debug!(\"binders: error occurred, was_error={:?}\", was_error);\n-                if !was_error {\n-                    Err(TypeError::OldStyleLUB(Box::new(err)))\n-                } else {\n-                    Err(err)\n-                }\n-            }\n-        }\n+        self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n+        Ok(a.clone())\n     }\n }\n "}, {"sha": "3e08a4e021aedb5660041fbed31271699adc7781", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 0, "deletions": 256, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=c244fd79f22f7a78016f20fa252d93bae474f4bd", "patch": "@@ -22,7 +22,6 @@ use super::region_constraints::{TaintDirections};\n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use std::collections::BTreeMap;\n use syntax_pos::Span;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -202,261 +201,6 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             Ok(HrMatchResult { value: a_value })\n         });\n     }\n-\n-    pub fn higher_ranked_lub<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n-                                -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'tcx>\n-    {\n-        // Start a snapshot so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        return self.infcx.commit_if_ok(|snapshot| {\n-            // Instantiate each bound region with a fresh region variable.\n-            let span = self.trace.cause.span;\n-            let (a_with_fresh, a_map) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    span, HigherRankedType, a);\n-            let (b_with_fresh, _) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    span, HigherRankedType, b);\n-\n-            // Collect constraints.\n-            let result0 =\n-                self.lub(a_is_expected).relate(&a_with_fresh, &b_with_fresh)?;\n-            let result0 =\n-                self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"lub result0 = {:?}\", result0);\n-\n-            // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace.cause.span;\n-            let result1 =\n-                fold_regions_in(\n-                    self.tcx(),\n-                    &result0,\n-                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n-                                                    &new_vars, &a_map, r));\n-\n-            debug!(\"lub({:?},{:?}) = {:?}\",\n-                   a,\n-                   b,\n-                   result1);\n-\n-            Ok(ty::Binder::bind(result1))\n-        });\n-\n-        fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             span: Span,\n-                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n-                                             debruijn: ty::DebruijnIndex,\n-                                             new_vars: &[ty::RegionVid],\n-                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n-                                             r0: ty::Region<'tcx>)\n-                                             -> ty::Region<'tcx> {\n-            // Regions that pre-dated the LUB computation stay as they are.\n-            if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_late_bound());\n-                debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n-                return r0;\n-            }\n-\n-            let tainted = infcx.tainted_regions(snapshot, r0, TaintDirections::both());\n-\n-            // Variables created during LUB computation which are\n-            // *related* to regions that pre-date the LUB computation\n-            // stay as they are.\n-            if !tainted.iter().all(|&r| is_var_in_set(new_vars, r)) {\n-                debug!(\"generalize_region(r0={:?}): \\\n-                        non-new-variables found in {:?}\",\n-                       r0, tainted);\n-                assert!(!r0.is_late_bound());\n-                return r0;\n-            }\n-\n-            // Otherwise, the variable must be associated with at\n-            // least one of the variables representing bound regions\n-            // in both A and B.  Replace the variable with the \"first\"\n-            // bound region from A that we find it to be associated\n-            // with.\n-            for (a_br, a_r) in a_map {\n-                if tainted.iter().any(|x| x == a_r) {\n-                    debug!(\"generalize_region(r0={:?}): \\\n-                            replacing with {:?}, tainted={:?}\",\n-                           r0, *a_br, tainted);\n-                    return infcx.tcx.mk_region(ty::ReLateBound(debruijn, *a_br));\n-                }\n-            }\n-\n-            span_bug!(\n-                span,\n-                \"region {:?} is not associated with any bound region from A!\",\n-                r0)\n-        }\n-    }\n-\n-    pub fn higher_ranked_glb<T>(&mut self, a: &Binder<T>, b: &Binder<T>, a_is_expected: bool)\n-                                -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'tcx>\n-    {\n-        debug!(\"higher_ranked_glb({:?}, {:?})\",\n-               a, b);\n-\n-        // Make a snapshot so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        return self.infcx.commit_if_ok(|snapshot| {\n-            // Instantiate each bound region with a fresh region variable.\n-            let (a_with_fresh, a_map) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.cause.span, HigherRankedType, a);\n-            let (b_with_fresh, b_map) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.cause.span, HigherRankedType, b);\n-            let a_vars = var_ids(self, &a_map);\n-            let b_vars = var_ids(self, &b_map);\n-\n-            // Collect constraints.\n-            let result0 =\n-                self.glb(a_is_expected).relate(&a_with_fresh, &b_with_fresh)?;\n-            let result0 =\n-                self.infcx.resolve_type_vars_if_possible(&result0);\n-            debug!(\"glb result0 = {:?}\", result0);\n-\n-            // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace.cause.span;\n-            let result1 =\n-                fold_regions_in(\n-                    self.tcx(),\n-                    &result0,\n-                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n-                                                    &new_vars,\n-                                                    &a_map, &a_vars, &b_vars,\n-                                                    r));\n-\n-            debug!(\"glb({:?},{:?}) = {:?}\",\n-                   a,\n-                   b,\n-                   result1);\n-\n-            Ok(ty::Binder::bind(result1))\n-        });\n-\n-        fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             span: Span,\n-                                             snapshot: &CombinedSnapshot<'a, 'tcx>,\n-                                             debruijn: ty::DebruijnIndex,\n-                                             new_vars: &[ty::RegionVid],\n-                                             a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n-                                             a_vars: &[ty::RegionVid],\n-                                             b_vars: &[ty::RegionVid],\n-                                             r0: ty::Region<'tcx>)\n-                                             -> ty::Region<'tcx> {\n-            if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_late_bound());\n-                return r0;\n-            }\n-\n-            let tainted = infcx.tainted_regions(snapshot, r0, TaintDirections::both());\n-\n-            let mut a_r = None;\n-            let mut b_r = None;\n-            let mut only_new_vars = true;\n-            for r in &tainted {\n-                if is_var_in_set(a_vars, *r) {\n-                    if a_r.is_some() {\n-                        return fresh_bound_variable(infcx, debruijn);\n-                    } else {\n-                        a_r = Some(*r);\n-                    }\n-                } else if is_var_in_set(b_vars, *r) {\n-                    if b_r.is_some() {\n-                        return fresh_bound_variable(infcx, debruijn);\n-                    } else {\n-                        b_r = Some(*r);\n-                    }\n-                } else if !is_var_in_set(new_vars, *r) {\n-                    only_new_vars = false;\n-                }\n-            }\n-\n-            // NB---I do not believe this algorithm computes\n-            // (necessarily) the GLB.  As written it can\n-            // spuriously fail. In particular, if there is a case\n-            // like: |fn(&a)| and fn(fn(&b)), where a and b are\n-            // free, it will return fn(&c) where c = GLB(a,b).  If\n-            // however this GLB is not defined, then the result is\n-            // an error, even though something like\n-            // \"fn<X>(fn(&X))\" where X is bound would be a\n-            // subtype of both of those.\n-            //\n-            // The problem is that if we were to return a bound\n-            // variable, we'd be computing a lower-bound, but not\n-            // necessarily the *greatest* lower-bound.\n-            //\n-            // Unfortunately, this problem is non-trivial to solve,\n-            // because we do not know at the time of computing the GLB\n-            // whether a GLB(a,b) exists or not, because we haven't\n-            // run region inference (or indeed, even fully computed\n-            // the region hierarchy!). The current algorithm seems to\n-            // works ok in practice.\n-\n-            if a_r.is_some() && b_r.is_some() && only_new_vars {\n-                // Related to exactly one bound variable from each fn:\n-                return rev_lookup(infcx, span, a_map, a_r.unwrap());\n-            } else if a_r.is_none() && b_r.is_none() {\n-                // Not related to bound variables from either fn:\n-                assert!(!r0.is_late_bound());\n-                return r0;\n-            } else {\n-                // Other:\n-                return fresh_bound_variable(infcx, debruijn);\n-            }\n-        }\n-\n-        fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                      span: Span,\n-                                      a_map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>,\n-                                      r: ty::Region<'tcx>) -> ty::Region<'tcx>\n-        {\n-            for (a_br, a_r) in a_map {\n-                if *a_r == r {\n-                    return infcx.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, *a_br));\n-                }\n-            }\n-            span_bug!(\n-                span,\n-                \"could not find original bound region for {:?}\",\n-                r);\n-        }\n-\n-        fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                debruijn: ty::DebruijnIndex)\n-                                                -> ty::Region<'tcx> {\n-            infcx.borrow_region_constraints().new_bound(infcx.tcx, debruijn)\n-        }\n-    }\n-}\n-\n-fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-                           -> Vec<ty::RegionVid> {\n-    map.iter()\n-       .map(|(_, &r)| match *r {\n-           ty::ReVar(r) => { r }\n-           _ => {\n-               span_bug!(\n-                   fields.trace.cause.span,\n-                   \"found non-region-vid: {:?}\",\n-                   r);\n-           }\n-       })\n-       .collect()\n-}\n-\n-fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region<'_>) -> bool {\n-    match *r {\n-        ty::ReVar(ref v) => new_vars.iter().any(|x| x == v),\n-        _ => false\n-    }\n }\n \n fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "8875b4169dd6e796028916f558fc9ae009e3858d", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=c244fd79f22f7a78016f20fa252d93bae474f4bd", "patch": "@@ -15,7 +15,6 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n@@ -76,31 +75,12 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         where T: Relate<'tcx>\n     {\n         debug!(\"binders(a={:?}, b={:?})\", a, b);\n-        let was_error = self.infcx().probe(|_snapshot| {\n-            // Subtle: use a fresh combine-fields here because we recover\n-            // from Err. Doing otherwise could propagate obligations out\n-            // through our `self.obligations` field.\n-            self.infcx()\n-                .combine_fields(self.fields.trace.clone(), self.fields.param_env)\n-                .higher_ranked_lub(a, b, self.a_is_expected)\n-                .is_err()\n-        });\n-        debug!(\"binders: was_error={:?}\", was_error);\n \n         // When higher-ranked types are involved, computing the LUB is\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n-        match self.relate_with_variance(ty::Variance::Invariant, a, b) {\n-            Ok(_) => Ok(a.clone()),\n-            Err(err) => {\n-                debug!(\"binders: error occurred, was_error={:?}\", was_error);\n-                if !was_error {\n-                    Err(TypeError::OldStyleLUB(Box::new(err)))\n-                } else {\n-                    Err(err)\n-                }\n-            }\n-        }\n+        self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n+        Ok(a.clone())\n     }\n }\n "}, {"sha": "855983042c026cec3b38f9d37029e052c0b3c72b", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c244fd79f22f7a78016f20fa252d93bae474f4bd", "patch": "@@ -53,8 +53,6 @@ pub enum TypeError<'tcx> {\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n-\n-    OldStyleLUB(Box<TypeError<'tcx>>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -166,9 +164,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 report_maybe_different(f, &format!(\"trait `{}`\", values.expected),\n                                        &format!(\"trait `{}`\", values.found))\n             }\n-            OldStyleLUB(ref err) => {\n-                write!(f, \"{}\", err)\n-            }\n         }\n     }\n }\n@@ -266,12 +261,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             },\n-            OldStyleLUB(err) => {\n-                db.note(\"this was previously accepted by the compiler but has been phased out\");\n-                db.note(\"for more information, see https://github.com/rust-lang/rust/issues/45852\");\n-\n-                self.note_and_explain_type_err(db, &err, sp);\n-            }\n             CyclicTy(ty) => {\n                 // Watch out for various cases of cyclic types and try to explain.\n                 if ty.is_closure() || ty.is_generator() {"}, {"sha": "9e2c0ca86c10f0784173db4c5189938726dbf3cd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c244fd79f22f7a78016f20fa252d93bae474f4bd", "patch": "@@ -455,7 +455,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n-            OldStyleLUB(ref x) => return tcx.lift(x).map(OldStyleLUB),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n         })\n     }\n@@ -1000,7 +999,6 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::ProjectionBoundsLength)(x),\n         (ty::error::TypeError::Sorts)(x),\n         (ty::error::TypeError::ExistentialMismatch)(x),\n-        (ty::error::TypeError::OldStyleLUB)(x),\n     }\n }\n "}, {"sha": "4182b5258884f55b8ef205d0640cd4d88f007a32", "filename": "src/test/ui/lub-glb/old-lub-glb-hr.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-hr.stderr?ref=c244fd79f22f7a78016f20fa252d93bae474f4bd", "patch": "@@ -11,8 +11,6 @@ LL | |     };\n    |\n    = note: expected type `for<'r, 's> fn(&'r u8, &'s u8)`\n               found type `for<'a> fn(&'a u8, &'a u8)`\n-   = note: this was previously accepted by the compiler but has been phased out\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/45852\n \n error: aborting due to previous error\n "}, {"sha": "bb8cb45eec39711c88b4e2ba14365c712a537248", "filename": "src/test/ui/lub-glb/old-lub-glb-object.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c244fd79f22f7a78016f20fa252d93bae474f4bd/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flub-glb%2Fold-lub-glb-object.stderr?ref=c244fd79f22f7a78016f20fa252d93bae474f4bd", "patch": "@@ -11,8 +11,6 @@ LL | |     };\n    |\n    = note: expected type `&dyn for<'a, 'b> Foo<&'a u8, &'b u8>`\n               found type `&dyn for<'a> Foo<&'a u8, &'a u8>`\n-   = note: this was previously accepted by the compiler but has been phased out\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/45852\n \n error: aborting due to previous error\n "}]}