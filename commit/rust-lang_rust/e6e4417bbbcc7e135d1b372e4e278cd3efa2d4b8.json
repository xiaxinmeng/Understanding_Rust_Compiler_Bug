{"sha": "e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZTQ0MTdiYmJjYzdlMTM1ZDFiMzcyZTRlMjc4Y2QzZWZhMmQ0Yjg=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-23T16:36:43Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-23T16:36:43Z"}, "message": "Remove SyntaxRewriter::from_fn", "tree": {"sha": "0f749fe589658f0d2535a1940ec0bd3a9af7225e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f749fe589658f0d2535a1940ec0bd3a9af7225e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "html_url": "https://github.com/rust-lang/rust/commit/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20f82191a038b05ead5c4d666fcd75f053a2dc6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/20f82191a038b05ead5c4d666fcd75f053a2dc6c", "html_url": "https://github.com/rust-lang/rust/commit/20f82191a038b05ead5c4d666fcd75f053a2dc6c"}], "stats": {"total": 55, "additions": 24, "deletions": 31}, "files": [{"sha": "e5ae718c9fd148292bb2b62ad9a0a244e2e90a11", "filename": "crates/ide_assists/src/ast_transform.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8/crates%2Fide_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8/crates%2Fide_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fast_transform.rs?ref=e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "patch": "@@ -3,20 +3,27 @@ use hir::{HirDisplay, PathResolution, SemanticsScope};\n use ide_db::helpers::mod_path_to_ast;\n use rustc_hash::FxHashMap;\n use syntax::{\n-    algo::SyntaxRewriter,\n     ast::{self, AstNode},\n-    SyntaxNode,\n+    ted, SyntaxNode,\n };\n \n-pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n-    SyntaxRewriter::from_fn(|element| match element {\n-        syntax::SyntaxElement::Node(n) => {\n-            let replacement = transformer.get_substitution(&n, transformer)?;\n-            Some(replacement.into())\n+pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: &N) {\n+    let mut skip_to = None;\n+    for event in node.syntax().preorder() {\n+        match event {\n+            syntax::WalkEvent::Enter(node) if skip_to.is_none() => {\n+                skip_to = transformer.get_substitution(&node, transformer).zip(Some(node));\n+            }\n+            syntax::WalkEvent::Enter(_) => (),\n+            syntax::WalkEvent::Leave(node) => match &skip_to {\n+                Some((replacement, skip_target)) if *skip_target == node => {\n+                    ted::replace(node, replacement.clone_for_update());\n+                    skip_to.take();\n+                }\n+                _ => (),\n+            },\n         }\n-        _ => None,\n-    })\n-    .rewrite_ast(&node)\n+    }\n }\n \n /// `AstTransform` helps with applying bulk transformations to syntax nodes.\n@@ -191,11 +198,9 @@ impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n                 let found_path = from.find_use_path(self.source_scope.db.upcast(), def)?;\n                 let mut path = mod_path_to_ast(&found_path);\n \n-                let type_args = p\n-                    .segment()\n-                    .and_then(|s| s.generic_arg_list())\n-                    .map(|arg_list| apply(recur, arg_list));\n+                let type_args = p.segment().and_then(|s| s.generic_arg_list());\n                 if let Some(type_args) = type_args {\n+                    apply(recur, &type_args);\n                     let last_segment = path.segment().unwrap();\n                     path = path.with_segment(last_segment.with_generic_args(type_args))\n                 }"}, {"sha": "5a90ad715b16d29f85bce9b5c16bf82e8a5c9c80", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "patch": "@@ -140,7 +140,8 @@ pub fn add_trait_assoc_items_to_impl(\n \n     let items = items\n         .into_iter()\n-        .map(|it| ast_transform::apply(&*ast_transform, it))\n+        .map(|it| it.clone_for_update())\n+        .inspect(|it| ast_transform::apply(&*ast_transform, it))\n         .map(|it| match it {\n             ast::AssocItem::Fn(def) => ast::AssocItem::Fn(add_body(def)),\n             ast::AssocItem::TypeAlias(def) => ast::AssocItem::TypeAlias(def.remove_bounds()),"}, {"sha": "c9229c4e07dabfa7e943740bdf3e18355c1bef22", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=e6e4417bbbcc7e135d1b372e4e278cd3efa2d4b8", "patch": "@@ -342,10 +342,10 @@ enum InsertPos {\n \n #[derive(Default)]\n pub struct SyntaxRewriter<'a> {\n-    f: Option<Box<dyn Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a>>,\n     //FIXME: add debug_assertions that all elements are in fact from the same file.\n     replacements: FxHashMap<SyntaxElement, Replacement>,\n     insertions: IndexMap<InsertPos, Vec<SyntaxElement>>,\n+    _pd: std::marker::PhantomData<&'a ()>,\n }\n \n impl fmt::Debug for SyntaxRewriter<'_> {\n@@ -357,14 +357,7 @@ impl fmt::Debug for SyntaxRewriter<'_> {\n     }\n }\n \n-impl<'a> SyntaxRewriter<'a> {\n-    pub fn from_fn(f: impl Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a) -> SyntaxRewriter<'a> {\n-        SyntaxRewriter {\n-            f: Some(Box::new(f)),\n-            replacements: FxHashMap::default(),\n-            insertions: IndexMap::default(),\n-        }\n-    }\n+impl SyntaxRewriter<'_> {\n     pub fn delete<T: Clone + Into<SyntaxElement>>(&mut self, what: &T) {\n         let what = what.clone().into();\n         let replacement = Replacement::Delete;\n@@ -470,7 +463,7 @@ impl<'a> SyntaxRewriter<'a> {\n     pub fn rewrite(&self, node: &SyntaxNode) -> SyntaxNode {\n         let _p = profile::span(\"rewrite\");\n \n-        if self.f.is_none() && self.replacements.is_empty() && self.insertions.is_empty() {\n+        if self.replacements.is_empty() && self.insertions.is_empty() {\n             return node.clone();\n         }\n         let green = self.rewrite_children(node);\n@@ -495,7 +488,6 @@ impl<'a> SyntaxRewriter<'a> {\n             }\n         }\n \n-        assert!(self.f.is_none());\n         self.replacements\n             .keys()\n             .filter_map(element_to_node_or_parent)\n@@ -510,10 +502,6 @@ impl<'a> SyntaxRewriter<'a> {\n     }\n \n     fn replacement(&self, element: &SyntaxElement) -> Option<Replacement> {\n-        if let Some(f) = &self.f {\n-            assert!(self.replacements.is_empty());\n-            return f(element).map(Replacement::Single);\n-        }\n         self.replacements.get(element).cloned()\n     }\n \n@@ -574,7 +562,6 @@ fn element_to_green(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, row\n \n impl ops::AddAssign for SyntaxRewriter<'_> {\n     fn add_assign(&mut self, rhs: SyntaxRewriter) {\n-        assert!(rhs.f.is_none());\n         self.replacements.extend(rhs.replacements);\n         for (pos, insertions) in rhs.insertions.into_iter() {\n             match self.insertions.entry(pos) {"}]}