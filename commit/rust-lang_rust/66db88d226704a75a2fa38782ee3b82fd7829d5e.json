{"sha": "66db88d226704a75a2fa38782ee3b82fd7829d5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZGI4OGQyMjY3MDRhNzVhMmZhMzg3ODJlZTNiODJmZDc4MjlkNWU=", "commit": {"author": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-05-06T22:10:56Z"}, "committer": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-05-10T14:51:12Z"}, "message": "Trigger change_visibility assist when on an invisible struct field\n\nUnion fields apparently don't work :(", "tree": {"sha": "e569045d0889a9def6a5e316cd9c9a5cea6eebca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e569045d0889a9def6a5e316cd9c9a5cea6eebca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66db88d226704a75a2fa38782ee3b82fd7829d5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66db88d226704a75a2fa38782ee3b82fd7829d5e", "html_url": "https://github.com/rust-lang/rust/commit/66db88d226704a75a2fa38782ee3b82fd7829d5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66db88d226704a75a2fa38782ee3b82fd7829d5e/comments", "author": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7568d0770934345be183670652e8064c06c05caf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7568d0770934345be183670652e8064c06c05caf", "html_url": "https://github.com/rust-lang/rust/commit/7568d0770934345be183670652e8064c06c05caf"}], "stats": {"total": 309, "additions": 248, "deletions": 61}, "files": [{"sha": "40cf4b42299fa8a3e24a9f8b72f49601ac86b8f3", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 248, "deletions": 61, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/66db88d226704a75a2fa38782ee3b82fd7829d5e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66db88d226704a75a2fa38782ee3b82fd7829d5e/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=66db88d226704a75a2fa38782ee3b82fd7829d5e", "patch": "@@ -8,10 +8,11 @@ use ra_syntax::{\n     SyntaxNode, TextRange, TextSize, T,\n };\n \n-use hir::{db::HirDatabase, HasSource, PathResolution};\n+use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n use test_utils::tested_by;\n \n use crate::{AssistContext, AssistId, Assists};\n+use ra_db::FileId;\n \n // Assist: change_visibility\n //\n@@ -29,6 +30,8 @@ pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Optio\n         return change_vis(acc, vis);\n     }\n     add_vis(acc, ctx)\n+        .or_else(|| add_vis_to_referenced_module_def(acc, ctx))\n+        .or_else(|| add_vis_to_referenced_record_field(acc, ctx))\n }\n \n fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -74,86 +77,141 @@ fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     })\n }\n \n-fn add_missing_vis(ctx: AssistCtx) -> Option<Assist> {\n+fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n-    let path_res = dbg!(ctx.sema.resolve_path(&path))?;\n+    let path_res = ctx.sema.resolve_path(&path)?;\n     let def = match path_res {\n         PathResolution::Def(def) => def,\n         _ => return None,\n     };\n-    dbg!(&def);\n \n-    let current_module = dbg!(ctx.sema.scope(&path.syntax()).module())?;\n-    let target_module = dbg!(def.module(ctx.db))?;\n+    let current_module = ctx.sema.scope(&path.syntax()).module()?;\n+    let target_module = def.module(ctx.db)?;\n \n-    let vis = dbg!(target_module.visibility_of(ctx.db, &def))?;\n+    let vis = target_module.visibility_of(ctx.db, &def)?;\n     if vis.is_visible_from(ctx.db, current_module.into()) {\n         return None;\n     };\n-    let target_name;\n \n-    let (offset, target) = match def {\n+    let (offset, target, target_file, target_name) = target_data_for_def(ctx.db, def)?;\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+\n+    let assist_label = match target_name {\n+        None => format!(\"Change visibility to {}\", missing_visibility),\n+        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n+    };\n+\n+    acc.add(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n+        edit.set_file(target_file);\n+        edit.insert(offset, format!(\"{} \", missing_visibility));\n+        edit.set_cursor(offset);\n+    })\n+}\n+\n+fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let record_field: ast::RecordField = ctx.find_node_at_offset()?;\n+    let (record_field_def, _) = ctx.sema.resolve_record_field(&record_field)?;\n+\n+    let current_module = ctx.sema.scope(record_field.syntax()).module()?;\n+    let visibility = record_field_def.visibility(ctx.db);\n+    if visibility.is_visible_from(ctx.db, current_module.into()) {\n+        return None;\n+    }\n+\n+    let parent = record_field_def.parent_def(ctx.db);\n+    let parent_name = parent.name(ctx.db);\n+    let target_module = parent.module(ctx.db);\n+\n+    let in_file_source = record_field_def.source(ctx.db);\n+    let (offset, target) = match in_file_source.value {\n+        hir::FieldSource::Named(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+        hir::FieldSource::Pos(it) => {\n+            let s = it.syntax();\n+            (vis_offset(s), s.text_range())\n+        }\n+    };\n+\n+    let missing_visibility =\n+        if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n+    let target_file = in_file_source.file_id.original_file(ctx.db);\n+\n+    let target_name = record_field_def.name(ctx.db);\n+    let assist_label =\n+        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n+\n+    acc.add(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n+        edit.set_file(target_file);\n+        edit.insert(offset, format!(\"{} \", missing_visibility));\n+        edit.set_cursor(offset)\n+    })\n+}\n+\n+fn target_data_for_def(\n+    db: &dyn HirDatabase,\n+    def: hir::ModuleDef,\n+) -> Option<(TextSize, TextRange, FileId, Option<hir::Name>)> {\n+    fn offset_target_and_file_id<S, Ast>(\n+        db: &dyn HirDatabase,\n+        x: S,\n+    ) -> (TextSize, TextRange, FileId)\n+    where\n+        S: HasSource<Ast = Ast>,\n+        Ast: AstNode,\n+    {\n+        let source = x.source(db);\n+        let in_file_syntax = source.syntax();\n+        let file_id = in_file_syntax.file_id;\n+        let syntax = in_file_syntax.value;\n+        (vis_offset(syntax), syntax.text_range(), file_id.original_file(db.upcast()))\n+    }\n+\n+    let target_name;\n+    let (offset, target, target_file) = match def {\n         hir::ModuleDef::Function(f) => {\n-            target_name = Some(f.name(ctx.db));\n-            offset_and_target(ctx.db, f)\n+            target_name = Some(f.name(db));\n+            offset_target_and_file_id(db, f)\n         }\n         hir::ModuleDef::Adt(adt) => {\n-            target_name = Some(adt.name(ctx.db));\n+            target_name = Some(adt.name(db));\n             match adt {\n-                hir::Adt::Struct(s) => offset_and_target(ctx.db, s),\n-                hir::Adt::Union(u) => offset_and_target(ctx.db, u),\n-                hir::Adt::Enum(e) => offset_and_target(ctx.db, e),\n+                hir::Adt::Struct(s) => offset_target_and_file_id(db, s),\n+                hir::Adt::Union(u) => offset_target_and_file_id(db, u),\n+                hir::Adt::Enum(e) => offset_target_and_file_id(db, e),\n             }\n         }\n         hir::ModuleDef::Const(c) => {\n-            target_name = c.name(ctx.db);\n-            offset_and_target(ctx.db, c)\n+            target_name = c.name(db);\n+            offset_target_and_file_id(db, c)\n         }\n         hir::ModuleDef::Static(s) => {\n-            target_name = s.name(ctx.db);\n-            offset_and_target(ctx.db, s)\n+            target_name = s.name(db);\n+            offset_target_and_file_id(db, s)\n         }\n         hir::ModuleDef::Trait(t) => {\n-            target_name = Some(t.name(ctx.db));\n-            offset_and_target(ctx.db, t)\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n         }\n         hir::ModuleDef::TypeAlias(t) => {\n-            target_name = Some(t.name(ctx.db));\n-            offset_and_target(ctx.db, t)\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)\n         }\n         hir::ModuleDef::Module(m) => {\n-            target_name = m.name(ctx.db);\n-            let source = dbg!(m.declaration_source(ctx.db))?.value;\n-            let syntax = source.syntax();\n-            (vis_offset(syntax), syntax.text_range())\n+            target_name = m.name(db);\n+            let in_file_source = m.declaration_source(db)?;\n+            let file_id = in_file_source.file_id.original_file(db.upcast());\n+            let syntax = in_file_source.value.syntax();\n+            (vis_offset(syntax), syntax.text_range(), file_id)\n         }\n         // Enum variants can't be private, we can't modify builtin types\n         hir::ModuleDef::EnumVariant(_) | hir::ModuleDef::BuiltinType(_) => return None,\n     };\n \n-    // FIXME if target is in another crate, add `pub` instead of `pub(crate)`\n-\n-    let assist_label = match target_name {\n-        None => \"Change visibility to pub(crate)\".to_string(),\n-        Some(name) => format!(\"Change visibility of {} to pub(crate)\", name),\n-    };\n-    let target_file = target_module.definition_source(ctx.db).file_id.original_file(ctx.db);\n-\n-    ctx.add_assist(AssistId(\"change_visibility\"), assist_label, target, |edit| {\n-        edit.set_file(target_file);\n-        edit.insert(offset, \"pub(crate) \");\n-        edit.set_cursor(offset);\n-    })\n-}\n-\n-fn offset_and_target<S, Ast>(db: &dyn HirDatabase, x: S) -> (TextSize, TextRange)\n-where\n-    S: HasSource<Ast = Ast>,\n-    Ast: AstNode,\n-{\n-    let source = x.source(db);\n-    let syntax = source.syntax().value;\n-    (vis_offset(syntax), syntax.text_range())\n+    Some((offset, target, target_file, target_name))\n }\n \n fn vis_offset(node: &SyntaxNode) -> TextSize {\n@@ -350,7 +408,6 @@ mod tests {\n     }\n \n     #[test]\n-    // FIXME this requires a separate implementation, struct fields are not a ast::Path\n     fn change_visibility_of_struct_field_via_path() {\n         check_assist(\n             change_visibility,\n@@ -359,11 +416,108 @@ mod tests {\n             r\"mod foo { pub struct Foo { <|>pub(crate) bar: (), } }\n               fn main() { foo::Foo { bar: () }; } \",\n         );\n+        check_assist(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { bar: () }\n+              \",\n+            r\"pub struct Foo { <|>pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub struct Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    fn change_visibility_of_enum_variant_field_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { pub enum Foo { Bar { bar: () } } }\n+              fn main() { foo::Foo::Bar { <|>bar: () }; } \",\n+            r\"mod foo { pub enum Foo { Bar { <|>pub(crate) bar: () } } }\n+              fn main() { foo::Foo::Bar { bar: () }; } \",\n+        );\n+        check_assist(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo::Bar { <|>bar: () }; }\n+              //- /foo.rs\n+              pub enum Foo { Bar { bar: () } }\n+              \",\n+            r\"pub enum Foo { Bar { <|>pub(crate) bar: () } }\n+\n+\",\n+        );\n         check_assist_not_applicable(\n             change_visibility,\n             r\"mod foo { pub struct Foo { pub bar: (), } }\n               fn main() { foo::Foo { <|>bar: () }; } \",\n         );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub struct Foo { pub bar: () }\n+              \",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    // FIXME reenable this test when `Semantics::resolve_record_field` works with union fields\n+    fn change_visibility_of_union_field_via_path() {\n+        check_assist(\n+            change_visibility,\n+            r\"mod foo { pub union Foo { bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+            r\"mod foo { pub union Foo { <|>pub(crate) bar: (), } }\n+              fn main() { foo::Foo { bar: () }; } \",\n+        );\n+        check_assist(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { bar: () }\n+              \",\n+            r\"pub union Foo { <|>pub(crate) bar: () }\n+\n+\",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"mod foo { pub union Foo { pub bar: (), } }\n+              fn main() { foo::Foo { <|>bar: () }; } \",\n+        );\n+        check_assist_not_applicable(\n+            change_visibility,\n+            r\"//- /lib.rs\n+              mod foo;\n+              fn main() { foo::Foo { <|>bar: () }; }\n+              //- /foo.rs\n+              pub union Foo { pub bar: () }\n+              \",\n+        );\n     }\n \n     #[test]\n@@ -500,24 +654,57 @@ mod tests {\n     fn change_visibility_of_module_declaration_in_other_file_via_path() {\n         check_assist(\n             change_visibility,\n-            r\"\n-            //- /main.rs\n-            mod foo;\n-            fn main() { foo::bar<|>>::baz(); }\n+            r\"//- /main.rs\n+              mod foo;\n+              fn main() { foo::bar<|>>::baz(); }\n \n-            //- /foo.rs\n-            mod bar {\n-                pub fn baz() {}\n-            }\n-            \",\n+              //- /foo.rs\n+              mod bar {\n+                  pub fn baz() {}\n+              }\",\n             r\"<|>pub(crate) mod bar {\n     pub fn baz() {}\n }\n-\n \",\n         );\n     }\n \n+    #[test]\n+    #[ignore]\n+    // FIXME handle reexports properly\n+    fn change_visibility_of_reexport() {\n+        check_assist(\n+            change_visibility,\n+            r\"\n+            mod foo {\n+                use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz<|>\n+            \",\n+            r\"\n+            mod foo {\n+                <|>pub(crate) use bar::Baz;\n+                mod bar { pub(super) struct Baz; }\n+            }\n+            foo::Baz\n+            \",\n+        )\n+    }\n+\n+    #[test]\n+    fn adds_pub_when_target_is_in_another_crate() {\n+        check_assist(\n+            change_visibility,\n+            r\"//- /main.rs crate:a deps:foo\n+              foo::Bar<|>\n+              //- /lib.rs crate:foo\n+              struct Bar;\",\n+            r\"<|>pub struct Bar;\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn change_visibility_target() {\n         check_assist_target(change_visibility, \"<|>fn foo() {}\", \"fn\");"}]}