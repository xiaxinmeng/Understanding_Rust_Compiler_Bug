{"sha": "67feeebfadbb69b437281ad2e0b30b27289b436d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZmVlZWJmYWRiYjY5YjQzNzI4MWFkMmUwYjMwYjI3Mjg5YjQzNmQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-03T16:41:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-18T10:49:31Z"}, "message": "resolve: Stop generating uniform path canaries", "tree": {"sha": "4da83dbd8725147dbfdcff9c8989e0ba72a9ef88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4da83dbd8725147dbfdcff9c8989e0ba72a9ef88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67feeebfadbb69b437281ad2e0b30b27289b436d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67feeebfadbb69b437281ad2e0b30b27289b436d", "html_url": "https://github.com/rust-lang/rust/commit/67feeebfadbb69b437281ad2e0b30b27289b436d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67feeebfadbb69b437281ad2e0b30b27289b436d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f37247f885026d29bf26fd4aed6e9135e4f32ebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f37247f885026d29bf26fd4aed6e9135e4f32ebf", "html_url": "https://github.com/rust-lang/rust/commit/f37247f885026d29bf26fd4aed6e9135e4f32ebf"}], "stats": {"total": 282, "additions": 13, "deletions": 269}, "files": [{"sha": "858e6dc623248db8e7a9f2c8d73d3faf5887803e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 107, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/67feeebfadbb69b437281ad2e0b30b27289b436d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67feeebfadbb69b437281ad2e0b30b27289b436d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=67feeebfadbb69b437281ad2e0b30b27289b436d", "patch": "@@ -116,17 +116,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         id: NodeId,\n         parent_prefix: &[Segment],\n         nested: bool,\n-        mut uniform_paths_canary_emitted: bool,\n         // The whole `use` item\n         parent_scope: ParentScope<'a>,\n         item: &Item,\n         vis: ty::Visibility,\n         root_span: Span,\n     ) {\n-        debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, \\\n-                uniform_paths_canary_emitted={}, \\\n-                use_tree={:?}, nested={})\",\n-               parent_prefix, uniform_paths_canary_emitted, use_tree, nested);\n+        debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, use_tree={:?}, nested={})\",\n+               parent_prefix, use_tree, nested);\n \n         let uniform_paths =\n             self.session.rust_2018() &&\n@@ -158,101 +155,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let prefix: Vec<_> = root.into_iter().chain(prefix_iter()).collect();\n \n         debug!(\"build_reduced_graph_for_use_tree: prefix={:?}\", prefix);\n-\n-        // `#[feature(uniform_paths)]` allows an unqualified import path,\n-        // e.g. `use x::...;` to resolve not just globally (`use ::x::...;`)\n-        // but also relatively (`use self::x::...;`). To catch ambiguities\n-        // that might arise from both of these being available and resolution\n-        // silently picking one of them, an artificial `use self::x as _;`\n-        // import is injected as a \"canary\", and an error is emitted if it\n-        // successfully resolves while an `x` external crate exists.\n-        //\n-        // For each block scope around the `use` item, one special canary\n-        // import of the form `use x as _;` is also injected, having its\n-        // parent set to that scope; `resolve_imports` will only resolve\n-        // it within its appropriate scope; if any of them successfully\n-        // resolve, an ambiguity error is emitted, since the original\n-        // import can't see the item in the block scope (`self::x` only\n-        // looks in the enclosing module), but a non-`use` path could.\n-        //\n-        // Additionally, the canary might be able to catch limitations of the\n-        // current implementation, where `::x` may be chosen due to `self::x`\n-        // not existing, but `self::x` could appear later, from macro expansion.\n-        //\n-        // NB. The canary currently only errors if the `x::...` path *could*\n-        // resolve as a relative path through the extern crate, i.e. `x` is\n-        // in `extern_prelude`, *even though* `::x` might still forcefully\n-        // load a non-`extern_prelude` crate.\n-        // While always producing an ambiguity errors if `self::x` exists and\n-        // a crate *could* be loaded, would be more conservative, imports for\n-        // local modules named `test` (or less commonly, `syntax` or `log`),\n-        // would need to be qualified (e.g. `self::test`), which is considered\n-        // ergonomically unacceptable.\n-        let emit_uniform_paths_canary =\n-            !uniform_paths_canary_emitted &&\n-            self.session.rust_2018() &&\n-            starts_with_non_keyword;\n-        if emit_uniform_paths_canary {\n-            let source = prefix_start.unwrap();\n-\n-            // Helper closure to emit a canary with the given base path.\n-            let emit = |this: &mut Self, base: Option<Segment>| {\n-                let subclass = SingleImport {\n-                    target: Ident {\n-                        name: keywords::Underscore.name().gensymed(),\n-                        span: source.ident.span,\n-                    },\n-                    source: source.ident,\n-                    result: PerNS {\n-                        type_ns: Cell::new(Err(Undetermined)),\n-                        value_ns: Cell::new(Err(Undetermined)),\n-                        macro_ns: Cell::new(Err(Undetermined)),\n-                    },\n-                    type_ns_only: false,\n-                };\n-                this.add_import_directive(\n-                    base.into_iter().collect(),\n-                    subclass,\n-                    source.ident.span,\n-                    id,\n-                    root_span,\n-                    item.id,\n-                    ty::Visibility::Invisible,\n-                    parent_scope.clone(),\n-                    true, // is_uniform_paths_canary\n-                );\n-            };\n-\n-            // A single simple `self::x` canary.\n-            emit(self, Some(Segment {\n-                ident: Ident {\n-                    name: keywords::SelfValue.name(),\n-                    span: source.ident.span,\n-                },\n-                id: source.id\n-            }));\n-\n-            // One special unprefixed canary per block scope around\n-            // the import, to detect items unreachable by `self::x`.\n-            let orig_current_module = self.current_module;\n-            let mut span = source.ident.span.modern();\n-            loop {\n-                match self.current_module.kind {\n-                    ModuleKind::Block(..) => emit(self, None),\n-                    ModuleKind::Def(..) => break,\n-                }\n-                match self.hygienic_lexical_parent(self.current_module, &mut span) {\n-                    Some(module) => {\n-                        self.current_module = module;\n-                    }\n-                    None => break,\n-                }\n-            }\n-            self.current_module = orig_current_module;\n-\n-            uniform_paths_canary_emitted = true;\n-        }\n-\n         let empty_for_self = |prefix: &[Segment]| {\n             prefix.is_empty() ||\n             prefix.len() == 1 && prefix[0].ident.name == keywords::CrateRoot.name()\n@@ -350,7 +252,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     item.id,\n                     vis,\n                     parent_scope,\n-                    false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n@@ -367,7 +268,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     item.id,\n                     vis,\n                     parent_scope,\n-                    false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n@@ -396,7 +296,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 for &(ref tree, id) in items {\n                     self.build_reduced_graph_for_use_tree(\n                         // This particular use tree\n-                        tree, id, &prefix, true, uniform_paths_canary_emitted,\n+                        tree, id, &prefix, true,\n                         // The whole `use` item\n                         parent_scope.clone(), item, vis, root_span,\n                     );\n@@ -420,7 +320,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     };\n                     self.build_reduced_graph_for_use_tree(\n                         // This particular use tree\n-                        &tree, id, &prefix, true, uniform_paths_canary_emitted,\n+                        &tree, id, &prefix, true,\n                         // The whole `use` item\n                         parent_scope.clone(), item, ty::Visibility::Invisible, root_span,\n                     );\n@@ -441,7 +341,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             ItemKind::Use(ref use_tree) => {\n                 self.build_reduced_graph_for_use_tree(\n                     // This particular use tree\n-                    use_tree, item.id, &[], false, false,\n+                    use_tree, item.id, &[], false,\n                     // The whole `use` item\n                     parent_scope, item, vis, use_tree.span,\n                 );\n@@ -492,7 +392,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     module_path: Vec::new(),\n                     vis: Cell::new(vis),\n                     used: Cell::new(used),\n-                    is_uniform_paths_canary: false,\n                 });\n                 self.potentially_unused_imports.push(directive);\n                 let imported_binding = self.import(binding, directive);\n@@ -905,7 +804,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             module_path: Vec::new(),\n             vis: Cell::new(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))),\n             used: Cell::new(false),\n-            is_uniform_paths_canary: false,\n         });\n \n         let allow_shadowing = parent_scope.expansion == Mark::root();"}, {"sha": "ece057358e6b52160239bc8f2176117bede29fe3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 162, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/67feeebfadbb69b437281ad2e0b30b27289b436d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67feeebfadbb69b437281ad2e0b30b27289b436d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=67feeebfadbb69b437281ad2e0b30b27289b436d", "patch": "@@ -35,7 +35,6 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{MultiSpan, Span};\n \n use std::cell::{Cell, RefCell};\n-use std::collections::BTreeMap;\n use std::{mem, ptr};\n \n /// Contains data for specific types of import directives.\n@@ -95,13 +94,6 @@ pub struct ImportDirective<'a> {\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n     pub used: Cell<bool>,\n-\n-    /// Whether this import is a \"canary\" for the `uniform_paths` feature,\n-    /// i.e. `use x::...;` results in an `use self::x as _;` canary.\n-    /// This flag affects diagnostics: an error is reported if and only if\n-    /// the import resolves successfully and an external crate with the same\n-    /// name (`x` above) also exists; any resolution failures are ignored.\n-    pub is_uniform_paths_canary: bool,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -188,11 +180,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                     // But when a crate does exist, it will get chosen even when\n                     // macro expansion could result in a success from the lookup\n                     // in the `self` module, later on.\n-                    //\n-                    // NB. This is currently alleviated by the \"ambiguity canaries\"\n-                    // (see `is_uniform_paths_canary`) that get introduced for the\n-                    // maybe-relative imports handled here: if the false negative\n-                    // case were to arise, it would *also* cause an ambiguity error.\n                     if binding.is_ok() {\n                         return binding;\n                     }\n@@ -404,8 +391,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                 root_span: Span,\n                                 root_id: NodeId,\n                                 vis: ty::Visibility,\n-                                parent_scope: ParentScope<'a>,\n-                                is_uniform_paths_canary: bool) {\n+                                parent_scope: ParentScope<'a>) {\n         let current_module = parent_scope.module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             parent_scope,\n@@ -418,7 +404,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             root_id,\n             vis: Cell::new(vis),\n             used: Cell::new(false),\n-            is_uniform_paths_canary,\n         });\n \n         debug!(\"add_import_directive({:?})\", directive);\n@@ -648,65 +633,14 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             self.finalize_resolutions_in(module);\n         }\n \n-        struct UniformPathsCanaryResults<'a> {\n-            name: Name,\n-            module_scope: Option<&'a NameBinding<'a>>,\n-            block_scopes: Vec<&'a NameBinding<'a>>,\n-        }\n-\n-        // Collect all tripped `uniform_paths` canaries separately.\n-        let mut uniform_paths_canaries: BTreeMap<\n-            (Span, NodeId, Namespace),\n-            UniformPathsCanaryResults,\n-        > = BTreeMap::new();\n-\n         let mut errors = false;\n         let mut seen_spans = FxHashSet::default();\n         let mut error_vec = Vec::new();\n         let mut prev_root_id: NodeId = NodeId::from_u32(0);\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n             let error = self.finalize_import(import);\n-\n-            // For a `#![feature(uniform_paths)]` `use self::x as _` canary,\n-            // failure is ignored, while success may cause an ambiguity error.\n-            if import.is_uniform_paths_canary {\n-                if error.is_some() {\n-                    continue;\n-                }\n-\n-                let (name, result) = match import.subclass {\n-                    SingleImport { source, ref result, .. } => (source.name, result),\n-                    _ => bug!(),\n-                };\n-\n-                let has_explicit_self =\n-                    !import.module_path.is_empty() &&\n-                    import.module_path[0].ident.name == keywords::SelfValue.name();\n-\n-                self.per_ns(|_, ns| {\n-                    if let Some(result) = result[ns].get().ok() {\n-                        let canary_results =\n-                            uniform_paths_canaries.entry((import.span, import.id, ns))\n-                                .or_insert(UniformPathsCanaryResults {\n-                                    name,\n-                                    module_scope: None,\n-                                    block_scopes: vec![],\n-                                });\n-\n-                        // All the canaries with the same `id` should have the same `name`.\n-                        assert_eq!(canary_results.name, name);\n-\n-                        if has_explicit_self {\n-                            // There should only be one `self::x` (module-scoped) canary.\n-                            assert!(canary_results.module_scope.is_none());\n-                            canary_results.module_scope = Some(result);\n-                        } else {\n-                            canary_results.block_scopes.push(result);\n-                        }\n-                    }\n-                });\n-            } else if let Some((span, err, note)) = error {\n+            if let Some((span, err, note)) = error {\n                 errors = true;\n \n                 if let SingleImport { source, ref result, .. } = import.subclass {\n@@ -743,71 +677,6 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n-        let uniform_paths_feature = self.session.features_untracked().uniform_paths;\n-        for ((span, _, ns), results) in uniform_paths_canaries {\n-            let name = results.name;\n-            let external_crate = if ns == TypeNS {\n-                self.extern_prelude_get(Ident::with_empty_ctxt(name), true, false)\n-                    .map(|binding| binding.def())\n-            } else {\n-                None\n-            };\n-\n-            // Currently imports can't resolve in non-module scopes,\n-            // we only have canaries in them for future-proofing.\n-            if external_crate.is_none() && results.module_scope.is_none() {\n-                continue;\n-            }\n-\n-            {\n-                let mut all_results = external_crate.into_iter().chain(\n-                    results.module_scope.iter()\n-                        .chain(&results.block_scopes)\n-                        .map(|binding| binding.def())\n-                );\n-                let first = all_results.next().unwrap();\n-\n-                // An ambiguity requires more than one *distinct* possible resolution.\n-                let possible_resultions =\n-                    1 + all_results.filter(|&def| def != first).count();\n-                if possible_resultions <= 1 {\n-                    continue;\n-                }\n-            }\n-\n-            errors = true;\n-\n-            let msg = format!(\"`{}` import is ambiguous\", name);\n-            let mut err = self.session.struct_span_err(span, &msg);\n-            let mut suggestion_choices = vec![];\n-            if external_crate.is_some() {\n-                suggestion_choices.push(format!(\"`::{}`\", name));\n-                err.span_label(span,\n-                    format!(\"can refer to external crate `::{}`\", name));\n-            }\n-            if let Some(result) = results.module_scope {\n-                suggestion_choices.push(format!(\"`self::{}`\", name));\n-                if uniform_paths_feature {\n-                    err.span_label(result.span,\n-                        format!(\"can refer to `self::{}`\", name));\n-                } else {\n-                    err.span_label(result.span,\n-                        format!(\"may refer to `self::{}` in the future\", name));\n-                }\n-            }\n-            for result in results.block_scopes {\n-                err.span_label(result.span,\n-                    format!(\"shadowed by block-scoped `{}`\", name));\n-            }\n-            err.help(&format!(\"write {} explicitly instead\", suggestion_choices.join(\" or \")));\n-            if uniform_paths_feature {\n-                err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n-            } else {\n-                err.note(\"in the future, `#![feature(uniform_paths)]` may become the default\");\n-            }\n-            err.emit();\n-        }\n-\n         if !error_vec.is_empty() {\n             self.throw_unresolved_import_error(error_vec.clone(), None);\n         }\n@@ -816,9 +685,6 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         // to avoid generating multiple errors on the same import.\n         if !errors {\n             for import in &self.indeterminate_imports {\n-                if import.is_uniform_paths_canary {\n-                    continue;\n-                }\n                 self.throw_unresolved_import_error(error_vec, Some(MultiSpan::from(import.span)));\n                 break;\n             }\n@@ -884,11 +750,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n             let result = self.resolve_path(\n-                Some(if directive.is_uniform_paths_canary {\n-                    ModuleOrUniformRoot::Module(directive.parent_scope.module)\n-                } else {\n-                    ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n-                }),\n+                Some(ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())),\n                 &directive.module_path[..],\n                 None,\n                 &directive.parent_scope,\n@@ -967,11 +829,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let ImportDirective { ref module_path, span, .. } = *directive;\n \n         let module_result = self.resolve_path(\n-            Some(if directive.is_uniform_paths_canary {\n-                ModuleOrUniformRoot::Module(directive.parent_scope.module)\n-            } else {\n-                ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n-            }),\n+            Some(ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())),\n             &module_path,\n             None,\n             &directive.parent_scope,\n@@ -1038,21 +896,17 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             _ => unreachable!(),\n         };\n \n-        // Do not record uses from canaries, to avoid interfering with other\n-        // diagnostics or suggestions that rely on some items not being used.\n-        let record_used = !directive.is_uniform_paths_canary;\n-\n         let mut all_ns_err = true;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n-                if record_used && this.record_use(ident, ns, binding) {\n+                if this.record_use(ident, ns, binding) {\n                     if let ModuleOrUniformRoot::Module(module) = module {\n                         this.resolution(module, ident, ns).borrow_mut().binding =\n                             Some(this.dummy_binding);\n                     }\n                 }\n-                if record_used && ns == TypeNS {\n+                if ns == TypeNS {\n                     if let ModuleOrUniformRoot::UniformRoot(..) = module {\n                         // Make sure single-segment import is resolved non-speculatively\n                         // at least once to report the feature error.\n@@ -1065,7 +919,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                if this.resolve_ident_in_module(module, ident, ns, record_used, span).is_ok() {\n+                if this.resolve_ident_in_module(module, ident, ns, true, span).is_ok() {\n                     all_ns_failed = false;\n                 }\n             });\n@@ -1262,15 +1116,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 None => continue,\n             };\n \n-            // Don't reexport `uniform_path` canaries.\n-            let non_canary_import = match binding.kind {\n-                NameBindingKind::Import { directive, .. } => {\n-                    !directive.is_uniform_paths_canary\n-                }\n-                _ => false,\n-            };\n-\n-            if non_canary_import || binding.is_macro_def() {\n+            if binding.is_import() || binding.is_macro_def() {\n                 let def = binding.def();\n                 if def != Def::Err {\n                     if !def.def_id().is_local() {"}]}