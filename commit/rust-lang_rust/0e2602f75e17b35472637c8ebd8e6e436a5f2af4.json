{"sha": "0e2602f75e17b35472637c8ebd8e6e436a5f2af4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMjYwMmY3NWUxN2IzNTQ3MjYzN2M4ZWJkOGU2ZTQzNmE1ZjJhZjQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-15T17:16:43Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:53:16Z"}, "message": "Remove raw item query", "tree": {"sha": "959a856badde77a0f554f66320a0ec02ffa90617", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959a856badde77a0f554f66320a0ec02ffa90617"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2602f75e17b35472637c8ebd8e6e436a5f2af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2602f75e17b35472637c8ebd8e6e436a5f2af4", "html_url": "https://github.com/rust-lang/rust/commit/0e2602f75e17b35472637c8ebd8e6e436a5f2af4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7054e89d187287c0547ef43961bf4969aba57dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7054e89d187287c0547ef43961bf4969aba57dd6", "html_url": "https://github.com/rust-lang/rust/commit/7054e89d187287c0547ef43961bf4969aba57dd6"}], "stats": {"total": 494, "additions": 3, "deletions": 491}, "files": [{"sha": "309402a5aa3289e64b98bb6b20e661203bc91244", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=0e2602f75e17b35472637c8ebd8e6e436a5f2af4", "patch": "@@ -6,8 +6,8 @@ pub use hir_def::db::{\n     ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, ImportMapQuery,\n     InternConstQuery, InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery,\n     InternImplQuery, InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery,\n-    InternUnionQuery, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery,\n-    StructDataQuery, TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n+    InternUnionQuery, LangItemQuery, ModuleLangItemsQuery, StaticDataQuery, StructDataQuery,\n+    TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, InternEagerExpansionQuery, InternMacroQuery,"}, {"sha": "9c3ede2d79dd768dda61455aa83cd48849cfd668", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=0e2602f75e17b35472637c8ebd8e6e436a5f2af4", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     import_map::ImportMap,\n     item_tree::ItemTree,\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::{raw::RawItems, CrateDefMap},\n+    nameres::CrateDefMap,\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n     GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n     TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n@@ -46,9 +46,6 @@ pub trait InternDatabase: SourceDatabase {\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n-    #[salsa::invoke(RawItems::raw_items_query)]\n-    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n-\n     #[salsa::invoke(ItemTree::item_tree_query)]\n     fn item_tree(&self, file_id: HirFileId) -> Arc<ItemTree>;\n "}, {"sha": "b279bdeef6abc89a1b2494a28fedb3ed9cfaf72c", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=0e2602f75e17b35472637c8ebd8e6e436a5f2af4", "patch": "@@ -47,7 +47,6 @@\n //! path and, upon success, we run macro expansion and \"collect module\" phase on\n //! the result\n \n-pub(crate) mod raw;\n mod collector;\n mod mod_resolution;\n mod path_resolution;"}, {"sha": "d83a5b2b56f399dc03c5705bdf1aa9e2bf383e99", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "removed", "additions": 0, "deletions": 483, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/7054e89d187287c0547ef43961bf4969aba57dd6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7054e89d187287c0547ef43961bf4969aba57dd6/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=7054e89d187287c0547ef43961bf4969aba57dd6", "patch": "@@ -1,483 +0,0 @@\n-//! Lowers syntax tree of a rust file into a raw representation of containing\n-//! items, *without* attaching them to a module structure.\n-//!\n-//! That is, raw items don't have semantics, just as syntax, but, unlike syntax,\n-//! they don't change with trivial source code edits, making them a great tool\n-//! for building salsa recomputation firewalls.\n-\n-use std::{ops::Index, sync::Arc};\n-\n-use hir_expand::{\n-    ast_id_map::AstIdMap,\n-    hygiene::Hygiene,\n-    name::{AsName, Name},\n-};\n-use ra_arena::{Arena, Idx};\n-use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, AttrsOwner, NameOwner, VisibilityOwner},\n-    AstNode,\n-};\n-use test_utils::mark;\n-\n-use crate::{\n-    attr::Attrs,\n-    db::DefDatabase,\n-    path::{ImportAlias, ModPath},\n-    visibility::RawVisibility,\n-    FileAstId, HirFileId, InFile,\n-};\n-\n-/// `RawItems` is a set of top-level items in a file (except for impls).\n-///\n-/// It is the input to name resolution algorithm. `RawItems` are not invalidated\n-/// on most edits.\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct RawItems {\n-    modules: Arena<ModuleData>,\n-    imports: Arena<ImportData>,\n-    defs: Arena<DefData>,\n-    macros: Arena<MacroData>,\n-    impls: Arena<ImplData>,\n-    /// items for top-level module\n-    items: Vec<RawItem>,\n-}\n-\n-impl RawItems {\n-    pub(crate) fn raw_items_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<RawItems> {\n-        let _p = profile(\"raw_items_query\");\n-        db.item_tree(file_id);\n-        let mut collector = RawItemsCollector {\n-            raw_items: RawItems::default(),\n-            source_ast_id_map: db.ast_id_map(file_id),\n-            file_id,\n-            hygiene: Hygiene::new(db.upcast(), file_id),\n-        };\n-        if let Some(node) = db.parse_or_expand(file_id) {\n-            if let Some(source_file) = ast::SourceFile::cast(node.clone()) {\n-                collector.process_module(None, source_file);\n-            } else if let Some(item_list) = ast::MacroItems::cast(node) {\n-                collector.process_module(None, item_list);\n-            }\n-        }\n-        let raw_items = collector.raw_items;\n-        Arc::new(raw_items)\n-    }\n-\n-    pub(super) fn items(&self) -> &[RawItem] {\n-        &self.items\n-    }\n-}\n-\n-impl Index<Idx<ModuleData>> for RawItems {\n-    type Output = ModuleData;\n-    fn index(&self, idx: Idx<ModuleData>) -> &ModuleData {\n-        &self.modules[idx]\n-    }\n-}\n-\n-impl Index<Import> for RawItems {\n-    type Output = ImportData;\n-    fn index(&self, idx: Import) -> &ImportData {\n-        &self.imports[idx]\n-    }\n-}\n-\n-impl Index<Idx<DefData>> for RawItems {\n-    type Output = DefData;\n-    fn index(&self, idx: Idx<DefData>) -> &DefData {\n-        &self.defs[idx]\n-    }\n-}\n-\n-impl Index<Idx<MacroData>> for RawItems {\n-    type Output = MacroData;\n-    fn index(&self, idx: Idx<MacroData>) -> &MacroData {\n-        &self.macros[idx]\n-    }\n-}\n-\n-impl Index<Idx<ImplData>> for RawItems {\n-    type Output = ImplData;\n-    fn index(&self, idx: Idx<ImplData>) -> &ImplData {\n-        &self.impls[idx]\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone)]\n-pub(super) struct RawItem {\n-    pub(super) attrs: Attrs,\n-    pub(super) kind: RawItemKind,\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum RawItemKind {\n-    Module(Idx<ModuleData>),\n-    Import(Import),\n-    Def(Idx<DefData>),\n-    Macro(Idx<MacroData>),\n-    Impl(Idx<ImplData>),\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) enum ModuleData {\n-    Declaration {\n-        name: Name,\n-        visibility: RawVisibility,\n-        ast_id: FileAstId<ast::Module>,\n-    },\n-    Definition {\n-        name: Name,\n-        visibility: RawVisibility,\n-        ast_id: FileAstId<ast::Module>,\n-        items: Vec<RawItem>,\n-    },\n-}\n-\n-pub(crate) type Import = Idx<ImportData>;\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ImportData {\n-    pub(super) path: ModPath,\n-    pub(super) alias: Option<ImportAlias>,\n-    pub(super) is_glob: bool,\n-    pub(super) is_prelude: bool,\n-    pub(super) is_extern_crate: bool,\n-    pub(super) is_macro_use: bool,\n-    pub(super) visibility: RawVisibility,\n-}\n-\n-// type Def = Idx<DefData>;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) struct DefData {\n-    pub(super) name: Name,\n-    pub(super) kind: DefKind,\n-    pub(super) visibility: RawVisibility,\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum StructDefKind {\n-    Record,\n-    Tuple,\n-    Unit,\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum DefKind {\n-    Function(FileAstId<ast::FnDef>),\n-    Struct(FileAstId<ast::StructDef>, StructDefKind),\n-    Union(FileAstId<ast::UnionDef>),\n-    Enum(FileAstId<ast::EnumDef>),\n-    Const(FileAstId<ast::ConstDef>),\n-    Static(FileAstId<ast::StaticDef>),\n-    Trait(FileAstId<ast::TraitDef>),\n-    TypeAlias(FileAstId<ast::TypeAliasDef>),\n-}\n-\n-impl DefKind {\n-    pub fn ast_id(self) -> FileAstId<ast::ModuleItem> {\n-        match self {\n-            DefKind::Function(it) => it.upcast(),\n-            DefKind::Struct(it, _) => it.upcast(),\n-            DefKind::Union(it) => it.upcast(),\n-            DefKind::Enum(it) => it.upcast(),\n-            DefKind::Const(it) => it.upcast(),\n-            DefKind::Static(it) => it.upcast(),\n-            DefKind::Trait(it) => it.upcast(),\n-            DefKind::TypeAlias(it) => it.upcast(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) struct MacroData {\n-    pub(super) ast_id: FileAstId<ast::MacroCall>,\n-    pub(super) path: ModPath,\n-    pub(super) name: Option<Name>,\n-    pub(super) export: bool,\n-    pub(super) local_inner: bool,\n-    pub(super) builtin: bool,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) struct ImplData {\n-    pub(super) ast_id: FileAstId<ast::ImplDef>,\n-}\n-\n-struct RawItemsCollector {\n-    raw_items: RawItems,\n-    source_ast_id_map: Arc<AstIdMap>,\n-    file_id: HirFileId,\n-    hygiene: Hygiene,\n-}\n-\n-impl RawItemsCollector {\n-    fn process_module(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        body: impl ast::ModuleItemOwner,\n-    ) {\n-        for item in body.items() {\n-            self.add_item(current_module, item)\n-        }\n-    }\n-\n-    fn add_item(&mut self, current_module: Option<Idx<ModuleData>>, item: ast::ModuleItem) {\n-        let attrs = self.parse_attrs(&item);\n-        let visibility = RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene);\n-        let (kind, name) = match item {\n-            ast::ModuleItem::Module(module) => {\n-                self.add_module(current_module, module);\n-                return;\n-            }\n-            ast::ModuleItem::UseItem(use_item) => {\n-                self.add_use_item(current_module, use_item);\n-                return;\n-            }\n-            ast::ModuleItem::ExternCrateItem(extern_crate) => {\n-                self.add_extern_crate_item(current_module, extern_crate);\n-                return;\n-            }\n-            ast::ModuleItem::ImplDef(it) => {\n-                self.add_impl(current_module, it);\n-                return;\n-            }\n-            ast::ModuleItem::StructDef(it) => {\n-                let kind = match it.kind() {\n-                    ast::StructKind::Record(_) => StructDefKind::Record,\n-                    ast::StructKind::Tuple(_) => StructDefKind::Tuple,\n-                    ast::StructKind::Unit => StructDefKind::Unit,\n-                };\n-                let id = self.source_ast_id_map.ast_id(&it);\n-                let name = it.name();\n-                (DefKind::Struct(id, kind), name)\n-            }\n-            ast::ModuleItem::UnionDef(it) => {\n-                let id = self.source_ast_id_map.ast_id(&it);\n-                let name = it.name();\n-                (DefKind::Union(id), name)\n-            }\n-            ast::ModuleItem::EnumDef(it) => {\n-                (DefKind::Enum(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::FnDef(it) => {\n-                (DefKind::Function(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::TraitDef(it) => {\n-                (DefKind::Trait(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::TypeAliasDef(it) => {\n-                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::ConstDef(it) => {\n-                (DefKind::Const(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::StaticDef(it) => {\n-                (DefKind::Static(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::MacroCall(it) => {\n-                self.add_macro(current_module, it);\n-                return;\n-            }\n-            ast::ModuleItem::ExternBlock(it) => {\n-                self.add_extern_block(current_module, it);\n-                return;\n-            }\n-        };\n-        if let Some(name) = name {\n-            let name = name.as_name();\n-            let def = self.raw_items.defs.alloc(DefData { name, kind, visibility });\n-            self.push_item(current_module, attrs, RawItemKind::Def(def));\n-        }\n-    }\n-\n-    fn add_extern_block(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        block: ast::ExternBlock,\n-    ) {\n-        if let Some(items) = block.extern_item_list() {\n-            for item in items.extern_items() {\n-                let attrs = self.parse_attrs(&item);\n-                let visibility =\n-                    RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene);\n-                let (kind, name) = match item {\n-                    ast::ExternItem::FnDef(it) => {\n-                        (DefKind::Function(self.source_ast_id_map.ast_id(&it)), it.name())\n-                    }\n-                    ast::ExternItem::StaticDef(it) => {\n-                        (DefKind::Static(self.source_ast_id_map.ast_id(&it)), it.name())\n-                    }\n-                };\n-\n-                if let Some(name) = name {\n-                    let name = name.as_name();\n-                    let def = self.raw_items.defs.alloc(DefData { name, kind, visibility });\n-                    self.push_item(current_module, attrs, RawItemKind::Def(def));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn add_module(&mut self, current_module: Option<Idx<ModuleData>>, module: ast::Module) {\n-        let name = match module.name() {\n-            Some(it) => it.as_name(),\n-            None => return,\n-        };\n-        let attrs = self.parse_attrs(&module);\n-        let visibility = RawVisibility::from_ast_with_hygiene(module.visibility(), &self.hygiene);\n-\n-        let ast_id = self.source_ast_id_map.ast_id(&module);\n-        if module.semicolon_token().is_some() {\n-            let item =\n-                self.raw_items.modules.alloc(ModuleData::Declaration { name, visibility, ast_id });\n-            self.push_item(current_module, attrs, RawItemKind::Module(item));\n-            return;\n-        }\n-\n-        if let Some(item_list) = module.item_list() {\n-            let item = self.raw_items.modules.alloc(ModuleData::Definition {\n-                name,\n-                visibility,\n-                ast_id,\n-                items: Vec::new(),\n-            });\n-            self.process_module(Some(item), item_list);\n-            self.push_item(current_module, attrs, RawItemKind::Module(item));\n-            return;\n-        }\n-        mark::hit!(name_res_works_for_broken_modules);\n-    }\n-\n-    fn add_use_item(&mut self, current_module: Option<Idx<ModuleData>>, use_item: ast::UseItem) {\n-        // FIXME: cfg_attr\n-        let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n-        let attrs = self.parse_attrs(&use_item);\n-        let visibility = RawVisibility::from_ast_with_hygiene(use_item.visibility(), &self.hygiene);\n-\n-        let mut buf = Vec::new();\n-        ModPath::expand_use_item(\n-            InFile { value: use_item, file_id: self.file_id },\n-            &self.hygiene,\n-            |path, _use_tree, is_glob, alias| {\n-                let import_data = ImportData {\n-                    path,\n-                    alias,\n-                    is_glob,\n-                    is_prelude,\n-                    is_extern_crate: false,\n-                    is_macro_use: false,\n-                    visibility: visibility.clone(),\n-                };\n-                buf.push(import_data);\n-            },\n-        );\n-        for import_data in buf {\n-            self.push_import(current_module, attrs.clone(), import_data);\n-        }\n-    }\n-\n-    fn add_extern_crate_item(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        extern_crate: ast::ExternCrateItem,\n-    ) {\n-        if let Some(name_ref) = extern_crate.name_ref() {\n-            let path = ModPath::from_name_ref(&name_ref);\n-            let visibility =\n-                RawVisibility::from_ast_with_hygiene(extern_crate.visibility(), &self.hygiene);\n-            let alias = extern_crate.alias().map(|a| {\n-                a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n-            });\n-            let attrs = self.parse_attrs(&extern_crate);\n-            // FIXME: cfg_attr\n-            let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n-            let import_data = ImportData {\n-                path,\n-                alias,\n-                is_glob: false,\n-                is_prelude: false,\n-                is_extern_crate: true,\n-                is_macro_use,\n-                visibility,\n-            };\n-            self.push_import(current_module, attrs, import_data);\n-        }\n-    }\n-\n-    fn add_macro(&mut self, current_module: Option<Idx<ModuleData>>, m: ast::MacroCall) {\n-        let attrs = self.parse_attrs(&m);\n-        let path = match m.path().and_then(|path| ModPath::from_src(path, &self.hygiene)) {\n-            Some(it) => it,\n-            _ => return,\n-        };\n-\n-        let name = m.name().map(|it| it.as_name());\n-        let ast_id = self.source_ast_id_map.ast_id(&m);\n-\n-        // FIXME: cfg_attr\n-        let export_attr = attrs.by_key(\"macro_export\");\n-\n-        let export = export_attr.exists();\n-        let local_inner = if export {\n-            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    ident.text.contains(\"local_inner_macros\")\n-                }\n-                _ => false,\n-            })\n-        } else {\n-            false\n-        };\n-\n-        let builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n-\n-        let m = self.raw_items.macros.alloc(MacroData {\n-            ast_id,\n-            path,\n-            name,\n-            export,\n-            local_inner,\n-            builtin,\n-        });\n-        self.push_item(current_module, attrs, RawItemKind::Macro(m));\n-    }\n-\n-    fn add_impl(&mut self, current_module: Option<Idx<ModuleData>>, imp: ast::ImplDef) {\n-        let attrs = self.parse_attrs(&imp);\n-        let ast_id = self.source_ast_id_map.ast_id(&imp);\n-        let imp = self.raw_items.impls.alloc(ImplData { ast_id });\n-        self.push_item(current_module, attrs, RawItemKind::Impl(imp))\n-    }\n-\n-    fn push_import(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        attrs: Attrs,\n-        data: ImportData,\n-    ) {\n-        let import = self.raw_items.imports.alloc(data);\n-        self.push_item(current_module, attrs, RawItemKind::Import(import))\n-    }\n-\n-    fn push_item(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        attrs: Attrs,\n-        kind: RawItemKind,\n-    ) {\n-        match current_module {\n-            Some(module) => match &mut self.raw_items.modules[module] {\n-                ModuleData::Definition { items, .. } => items,\n-                ModuleData::Declaration { .. } => unreachable!(),\n-            },\n-            None => &mut self.raw_items.items,\n-        }\n-        .push(RawItem { attrs, kind })\n-    }\n-\n-    fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n-        Attrs::new(item, &self.hygiene)\n-    }\n-}"}, {"sha": "780c4feae6cd753a5428195b82e3997c9751d484", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2602f75e17b35472637c8ebd8e6e436a5f2af4/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=0e2602f75e17b35472637c8ebd8e6e436a5f2af4", "patch": "@@ -199,7 +199,6 @@ impl RootDatabase {\n             hir::db::InternEagerExpansionQuery\n \n             // DefDatabase\n-            hir::db::RawItemsQuery\n             hir::db::CrateDefMapQueryQuery\n             hir::db::StructDataQuery\n             hir::db::UnionDataQuery"}]}