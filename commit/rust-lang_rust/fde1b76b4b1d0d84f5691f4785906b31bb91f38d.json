{"sha": "fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZTFiNzZiNGIxZDBkODRmNTY5MWY0Nzg1OTA2YjMxYmI5MWYzOGQ=", "commit": {"author": {"name": "L\u00e9o Lanteri Thauvin", "email": "leseulartichaut@gmail.com", "date": "2021-08-16T15:29:49Z"}, "committer": {"name": "L\u00e9o Lanteri Thauvin", "email": "leseulartichaut@gmail.com", "date": "2021-08-25T18:24:35Z"}, "message": "Use if-let guards in the codebase", "tree": {"sha": "966691ff24d8ec26354d737e549bbfccaa658f3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/966691ff24d8ec26354d737e549bbfccaa658f3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "html_url": "https://github.com/rust-lang/rust/commit/fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a992a11913b39a258158646bb1e03528c5aa5060", "url": "https://api.github.com/repos/rust-lang/rust/commits/a992a11913b39a258158646bb1e03528c5aa5060", "html_url": "https://github.com/rust-lang/rust/commit/a992a11913b39a258158646bb1e03528c5aa5060"}], "stats": {"total": 494, "additions": 241, "deletions": 253}, "files": [{"sha": "81195f7fb5cb2995ee4513aeac4cf0797158bcc1", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -564,11 +564,11 @@ impl NestedMetaItem {\n         I: Iterator<Item = TokenTree>,\n     {\n         match tokens.peek() {\n-            Some(TokenTree::Token(token)) => {\n-                if let Ok(lit) = Lit::from_token(token) {\n-                    tokens.next();\n-                    return Some(NestedMetaItem::Literal(lit));\n-                }\n+            Some(TokenTree::Token(token))\n+                if let Ok(lit) = Lit::from_token(token) =>\n+            {\n+                tokens.next();\n+                return Some(NestedMetaItem::Literal(lit));\n             }\n             Some(TokenTree::Delimited(_, token::NoDelim, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();"}, {"sha": "ef3f6035085d3643e0abfb2aac36558a7c47031e", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -11,10 +11,12 @@\n #![feature(box_patterns)]\n #![cfg_attr(bootstrap, feature(const_fn_transmute))]\n #![feature(crate_visibility_modifier)]\n+#![feature(if_let_guard)]\n #![feature(iter_zip)]\n #![feature(label_break_value)]\n #![feature(nll)]\n #![feature(min_specialization)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "02b6179f89503cac7d4f92ca9bb3df2e14a68416", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -5,9 +5,11 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(backtrace)]\n+#![feature(if_let_guard)]\n #![feature(format_args_capture)]\n #![feature(iter_zip)]\n #![feature(nll)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -1027,15 +1029,15 @@ impl HandlerInner {\n             let mut error_codes = self\n                 .emitted_diagnostic_codes\n                 .iter()\n-                .filter_map(|x| match &x {\n-                    DiagnosticId::Error(s) => {\n-                        if let Ok(Some(_explanation)) = registry.try_find_description(s) {\n-                            Some(s.clone())\n-                        } else {\n-                            None\n-                        }\n+                .filter_map(|x| {\n+                    match &x {\n+                    DiagnosticId::Error(s)\n+                        if let Ok(Some(_explanation)) = registry.try_find_description(s) =>\n+                    {\n+                        Some(s.clone())\n                     }\n                     _ => None,\n+                }\n                 })\n                 .collect::<Vec<_>>();\n             if !error_codes.is_empty() {"}, {"sha": "38c099fa4f59ce8556b78a15454bff1d5e7329ae", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -305,15 +305,14 @@ impl<'a> StripUnconfigured<'a> {\n                     Some((AttrAnnotatedTokenTree::Delimited(sp, delim, inner), *spacing))\n                         .into_iter()\n                 }\n+                AttrAnnotatedTokenTree::Token(ref token) if let TokenKind::Interpolated(ref nt) = token.kind => {\n+                    panic!(\n+                        \"Nonterminal should have been flattened at {:?}: {:?}\",\n+                        token.span, nt\n+                    );\n+                }\n                 AttrAnnotatedTokenTree::Token(token) => {\n-                    if let TokenKind::Interpolated(nt) = token.kind {\n-                        panic!(\n-                            \"Nonterminal should have been flattened at {:?}: {:?}\",\n-                            token.span, nt\n-                        );\n-                    } else {\n-                        Some((AttrAnnotatedTokenTree::Token(token), *spacing)).into_iter()\n-                    }\n+                    Some((AttrAnnotatedTokenTree::Token(token), *spacing)).into_iter()\n                 }\n             })\n             .collect();"}, {"sha": "f38f85a4626883dcdf75a1267cb0f27b617b0a00", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -2,11 +2,13 @@\n #![feature(decl_macro)]\n #![feature(destructuring_assignment)]\n #![feature(format_args_capture)]\n+#![feature(if_let_guard)]\n #![feature(iter_zip)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_span)]\n #![feature(try_blocks)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "60d653ac8b6f9be426af54ac13c47fe76aaecf46", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -86,13 +86,12 @@ crate fn mod_dir_path(\n     inline: Inline,\n ) -> (PathBuf, DirOwnership) {\n     match inline {\n+        Inline::Yes if let Some(file_path) = mod_file_path_from_attr(sess, attrs, &module.dir_path) => {\n+            // For inline modules file path from `#[path]` is actually the directory path\n+            // for historical reasons, so we don't pop the last segment here.\n+            (file_path, DirOwnership::Owned { relative: None })\n+        }\n         Inline::Yes => {\n-            if let Some(file_path) = mod_file_path_from_attr(sess, attrs, &module.dir_path) {\n-                // For inline modules file path from `#[path]` is actually the directory path\n-                // for historical reasons, so we don't pop the last segment here.\n-                return (file_path, DirOwnership::Owned { relative: None });\n-            }\n-\n             // We have to push on the current module name in the case of relative\n             // paths in order to ensure that any additional module paths from inline\n             // `mod x { ... }` come after the relative extension."}, {"sha": "55700f7b0d495e119b07b2fda73c744314082cce", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -178,18 +178,19 @@ impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_>)>\n                 tt!(Punct::new('#', false))\n             }\n \n+            Interpolated(nt)\n+                if let Some((name, is_raw)) = ident_name_compatibility_hack(&nt, span, rustc) =>\n+            {\n+                TokenTree::Ident(Ident::new(rustc.sess, name.name, is_raw, name.span))\n+            }\n             Interpolated(nt) => {\n-                if let Some((name, is_raw)) = ident_name_compatibility_hack(&nt, span, rustc) {\n-                    TokenTree::Ident(Ident::new(rustc.sess, name.name, is_raw, name.span))\n-                } else {\n-                    let stream = nt_to_tokenstream(&nt, rustc.sess, CanSynthesizeMissingTokens::No);\n-                    TokenTree::Group(Group {\n-                        delimiter: Delimiter::None,\n-                        stream,\n-                        span: DelimSpan::from_single(span),\n-                        flatten: crate::base::pretty_printing_compatibility_hack(&nt, rustc.sess),\n-                    })\n-                }\n+                let stream = nt_to_tokenstream(&nt, rustc.sess, CanSynthesizeMissingTokens::No);\n+                TokenTree::Group(Group {\n+                    delimiter: Delimiter::None,\n+                    stream,\n+                    span: DelimSpan::from_single(span),\n+                    flatten: crate::base::pretty_printing_compatibility_hack(&nt, rustc.sess),\n+                })\n             }\n \n             OpenDelim(..) | CloseDelim(..) => unreachable!(),"}, {"sha": "573fa913d680a177148417bf2bfa48cab5996d30", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -31,6 +31,7 @@\n #![feature(box_patterns)]\n #![feature(core_intrinsics)]\n #![feature(discriminant_kind)]\n+#![feature(if_let_guard)]\n #![feature(never_type)]\n #![feature(extern_types)]\n #![feature(new_uninit)]\n@@ -52,6 +53,7 @@\n #![feature(try_reserve)]\n #![feature(try_reserve_kind)]\n #![feature(nonzero_ops)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "ecbe9ca417593fc0c1acdb71548532cafcad015c", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -279,13 +279,10 @@ impl<'tcx> ty::TyS<'tcx> {\n             }\n             ty::FnDef(..) => \"fn item\".into(),\n             ty::FnPtr(_) => \"fn pointer\".into(),\n-            ty::Dynamic(ref inner, ..) => {\n-                if let Some(principal) = inner.principal() {\n-                    format!(\"trait object `dyn {}`\", tcx.def_path_str(principal.def_id())).into()\n-                } else {\n-                    \"trait object\".into()\n-                }\n+            ty::Dynamic(ref inner, ..) if let Some(principal) = inner.principal() => {\n+                format!(\"trait object `dyn {}`\", tcx.def_path_str(principal.def_id())).into()\n             }\n+            ty::Dynamic(..) => \"trait object\".into(),\n             ty::Closure(..) => \"closure\".into(),\n             ty::Generator(def_id, ..) => tcx.generator_kind(def_id).unwrap().descr().into(),\n             ty::GeneratorWitness(..) => \"generator witness\".into(),\n@@ -365,20 +362,19 @@ impl<'tcx> TyCtxt<'tcx> {\n                         // Issue #63167\n                         db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n                     }\n-                    (ty::Float(_), ty::Infer(ty::IntVar(_))) => {\n+                    (ty::Float(_), ty::Infer(ty::IntVar(_)))\n                         if let Ok(\n                             // Issue #53280\n                             snippet,\n-                        ) = self.sess.source_map().span_to_snippet(sp)\n-                        {\n-                            if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                                db.span_suggestion(\n-                                    sp,\n-                                    \"use a float literal\",\n-                                    format!(\"{}.0\", snippet),\n-                                    MachineApplicable,\n-                                );\n-                            }\n+                        ) = self.sess.source_map().span_to_snippet(sp) =>\n+                    {\n+                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n+                            db.span_suggestion(\n+                                sp,\n+                                \"use a float literal\",\n+                                format!(\"{}.0\", snippet),\n+                                MachineApplicable,\n+                            );\n                         }\n                     }\n                     (ty::Param(expected), ty::Param(found)) => {"}, {"sha": "1b8e94260b9b5d73f0228dc5cf7b1aaffd5d262d", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -225,14 +225,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n \n-                ty::Tuple(tys) => {\n-                    if let Some((&last_ty, _)) = tys.split_last() {\n-                        ty = last_ty.expect_ty();\n-                    } else {\n-                        break;\n-                    }\n+                ty::Tuple(tys) if let Some((&last_ty, _)) = tys.split_last() => {\n+                    ty = last_ty.expect_ty();\n                 }\n \n+                ty::Tuple(_) => break,\n+\n                 ty::Projection(_) | ty::Opaque(..) => {\n                     let normalized = normalize(ty);\n                     if ty == normalized {"}, {"sha": "73e05a35277ec98fbc3b7be79ec84991d437d7c1", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -2,8 +2,10 @@\n \n #![feature(array_windows)]\n #![feature(crate_visibility_modifier)]\n+#![feature(if_let_guard)]\n #![cfg_attr(bootstrap, feature(bindings_after_at))]\n #![feature(box_patterns)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n #![recursion_limit = \"256\"]\n \n use rustc_ast as ast;\n@@ -262,20 +264,17 @@ pub fn nt_to_tokenstream(\n     let tokens = match *nt {\n         Nonterminal::NtItem(ref item) => prepend_attrs(&item.attrs, item.tokens.as_ref()),\n         Nonterminal::NtBlock(ref block) => convert_tokens(block.tokens.as_ref()),\n-        Nonterminal::NtStmt(ref stmt) => {\n-            if let ast::StmtKind::Empty = stmt.kind {\n-                let tokens = AttrAnnotatedTokenStream::new(vec![(\n-                    tokenstream::AttrAnnotatedTokenTree::Token(Token::new(\n-                        TokenKind::Semi,\n-                        stmt.span,\n-                    )),\n-                    Spacing::Alone,\n-                )]);\n-                prepend_attrs(&stmt.attrs(), Some(&LazyTokenStream::new(tokens)))\n-            } else {\n-                prepend_attrs(&stmt.attrs(), stmt.tokens())\n-            }\n+        Nonterminal::NtStmt(ref stmt) if let ast::StmtKind::Empty = stmt.kind => {\n+            let tokens = AttrAnnotatedTokenStream::new(vec![(\n+                tokenstream::AttrAnnotatedTokenTree::Token(Token::new(\n+                    TokenKind::Semi,\n+                    stmt.span,\n+                )),\n+                Spacing::Alone,\n+            )]);\n+            prepend_attrs(&stmt.attrs(), Some(&LazyTokenStream::new(tokens)))\n         }\n+        Nonterminal::NtStmt(ref stmt) => prepend_attrs(&stmt.attrs(), stmt.tokens()),\n         Nonterminal::NtPat(ref pat) => convert_tokens(pat.tokens.as_ref()),\n         Nonterminal::NtTy(ref ty) => convert_tokens(ty.tokens.as_ref()),\n         Nonterminal::NtIdent(ident, is_raw) => {"}, {"sha": "72e6f8a1bc8574121c0e8e9d610da8d0e78307db", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -143,15 +143,16 @@ impl<'a> Parser<'a> {\n                 token::NtTy(self.collect_tokens_no_attrs(|this| this.parse_ty())?)\n             }\n             // this could be handled like a token, since it is one\n+            NonterminalKind::Ident\n+                if let Some((ident, is_raw)) = get_macro_ident(&self.token) =>\n+            {\n+                self.bump();\n+                token::NtIdent(ident, is_raw)\n+            }\n             NonterminalKind::Ident => {\n-                if let Some((ident, is_raw)) = get_macro_ident(&self.token) {\n-                    self.bump();\n-                    token::NtIdent(ident, is_raw)\n-                } else {\n-                    let token_str = pprust::token_to_string(&self.token);\n-                    let msg = &format!(\"expected ident, found {}\", &token_str);\n-                    return Err(self.struct_span_err(self.token.span, msg));\n-                }\n+                let token_str = pprust::token_to_string(&self.token);\n+                let msg = &format!(\"expected ident, found {}\", &token_str);\n+                return Err(self.struct_span_err(self.token.span, msg));\n             }\n             NonterminalKind::Path => token::NtPath(\n                 self.collect_tokens_no_attrs(|this| this.parse_path(PathStyle::Type))?,"}, {"sha": "85515bd2a631459c6cf10ba8e60deb78f4e0d0a7", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -493,21 +493,19 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             StmtKind::Expr(_) | StmtKind::MacCall(_) => {}\n-            StmtKind::Local(ref mut local) => {\n-                if let Err(e) = self.expect_semi() {\n-                    // We might be at the `,` in `let x = foo<bar, baz>;`. Try to recover.\n-                    match &mut local.init {\n-                        Some(ref mut expr) => {\n-                            self.check_mistyped_turbofish_with_multiple_type_params(e, expr)?;\n-                            // We found `foo<bar, baz>`, have we fully recovered?\n-                            self.expect_semi()?;\n-                        }\n-                        None => return Err(e),\n+            StmtKind::Local(ref mut local) if let Err(e) = self.expect_semi() => {\n+                // We might be at the `,` in `let x = foo<bar, baz>;`. Try to recover.\n+                match &mut local.init {\n+                    Some(ref mut expr) => {\n+                        self.check_mistyped_turbofish_with_multiple_type_params(e, expr)?;\n+                        // We found `foo<bar, baz>`, have we fully recovered?\n+                        self.expect_semi()?;\n                     }\n+                    None => return Err(e),\n                 }\n                 eat_semi = false;\n             }\n-            StmtKind::Empty | StmtKind::Item(_) | StmtKind::Semi(_) => eat_semi = false,\n+            StmtKind::Empty | StmtKind::Item(_) | StmtKind::Local(_) | StmtKind::Semi(_) => eat_semi = false,\n         }\n \n         if eat_semi && self.eat(&token::Semi) {"}, {"sha": "67695dc285092a555cc391e41bbe4e9e6eaedddc", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -24,16 +24,15 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n         Some((name, _, template, _)) if name != sym::rustc_dummy => {\n             check_builtin_attribute(sess, attr, name, template)\n         }\n-        _ => {\n-            if let MacArgs::Eq(..) = attr.get_normal_item().args {\n-                // All key-value attributes are restricted to meta-item syntax.\n-                parse_meta(sess, attr)\n-                    .map_err(|mut err| {\n-                        err.emit();\n-                    })\n-                    .ok();\n-            }\n+        _ if let MacArgs::Eq(..) = attr.get_normal_item().args => {\n+            // All key-value attributes are restricted to meta-item syntax.\n+            parse_meta(sess, attr)\n+                .map_err(|mut err| {\n+                    err.emit();\n+                })\n+                .ok();\n         }\n+        _ => {}\n     }\n }\n "}, {"sha": "41d174cde0a8ca0d3999641bda02efc5fdbf3b88", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -1,5 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(if_let_guard)]\n #![feature(nll)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n #![recursion_limit = \"256\"]\n \n mod dump_visitor;\n@@ -326,54 +328,53 @@ impl<'tcx> SaveContext<'tcx> {\n                     attributes: lower_attributes(attrs.to_vec(), self),\n                 }))\n             }\n-            hir::ItemKind::Impl(hir::Impl { ref of_trait, ref self_ty, ref items, .. }) => {\n-                if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = self_ty.kind {\n-                    // Common case impl for a struct or something basic.\n-                    if generated_code(path.span) {\n-                        return None;\n-                    }\n-                    let sub_span = path.segments.last().unwrap().ident.span;\n-                    filter!(self.span_utils, sub_span);\n+            hir::ItemKind::Impl(hir::Impl { ref of_trait, ref self_ty, ref items, .. })\n+                if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = self_ty.kind =>\n+            {\n+                // Common case impl for a struct or something basic.\n+                if generated_code(path.span) {\n+                    return None;\n+                }\n+                let sub_span = path.segments.last().unwrap().ident.span;\n+                filter!(self.span_utils, sub_span);\n \n-                    let impl_id = self.next_impl_id();\n-                    let span = self.span_from_span(sub_span);\n+                let impl_id = self.next_impl_id();\n+                let span = self.span_from_span(sub_span);\n \n-                    let type_data = self.lookup_def_id(self_ty.hir_id);\n-                    type_data.map(|type_data| {\n-                        Data::RelationData(\n-                            Relation {\n-                                kind: RelationKind::Impl { id: impl_id },\n-                                span: span.clone(),\n-                                from: id_from_def_id(type_data),\n-                                to: of_trait\n-                                    .as_ref()\n-                                    .and_then(|t| self.lookup_def_id(t.hir_ref_id))\n-                                    .map(id_from_def_id)\n-                                    .unwrap_or_else(null_id),\n-                            },\n-                            Impl {\n-                                id: impl_id,\n-                                kind: match *of_trait {\n-                                    Some(_) => ImplKind::Direct,\n-                                    None => ImplKind::Inherent,\n-                                },\n-                                span,\n-                                value: String::new(),\n-                                parent: None,\n-                                children: items\n-                                    .iter()\n-                                    .map(|i| id_from_def_id(i.id.def_id.to_def_id()))\n-                                    .collect(),\n-                                docs: String::new(),\n-                                sig: None,\n-                                attributes: vec![],\n+                let type_data = self.lookup_def_id(self_ty.hir_id);\n+                type_data.map(|type_data| {\n+                    Data::RelationData(\n+                        Relation {\n+                            kind: RelationKind::Impl { id: impl_id },\n+                            span: span.clone(),\n+                            from: id_from_def_id(type_data),\n+                            to: of_trait\n+                                .as_ref()\n+                                .and_then(|t| self.lookup_def_id(t.hir_ref_id))\n+                                .map(id_from_def_id)\n+                                .unwrap_or_else(null_id),\n+                        },\n+                        Impl {\n+                            id: impl_id,\n+                            kind: match *of_trait {\n+                                Some(_) => ImplKind::Direct,\n+                                None => ImplKind::Inherent,\n                             },\n-                        )\n-                    })\n-                } else {\n-                    None\n-                }\n+                            span,\n+                            value: String::new(),\n+                            parent: None,\n+                            children: items\n+                                .iter()\n+                                .map(|i| id_from_def_id(i.id.def_id.to_def_id()))\n+                                .collect(),\n+                            docs: String::new(),\n+                            sig: None,\n+                            attributes: vec![],\n+                        },\n+                    )\n+                })\n             }\n+            hir::ItemKind::Impl(_) => None,\n             _ => {\n                 // FIXME\n                 bug!();"}, {"sha": "89e032b222fecb32971aaa9a3296d889c451a2cf", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -16,10 +16,12 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n #![feature(crate_visibility_modifier)]\n+#![feature(if_let_guard)]\n #![feature(negative_impls)]\n #![feature(nll)]\n #![feature(min_specialization)]\n #![feature(thread_local_const_init)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "2c3af802be55a92413df02cc26dec4d3936c0e8b", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -982,15 +982,13 @@ impl SourceMap {\n         None\n     }\n     pub fn ensure_source_file_source_present(&self, source_file: Lrc<SourceFile>) -> bool {\n-        source_file.add_external_src(|| match source_file.name {\n-            FileName::Real(ref name) => {\n-                if let Some(local_path) = name.local_path() {\n+        source_file.add_external_src(|| {\n+            match source_file.name {\n+                FileName::Real(ref name) if let Some(local_path) = name.local_path() => {\n                     self.file_loader.read_file(local_path).ok()\n-                } else {\n-                    None\n                 }\n+                _ => None,\n             }\n-            _ => None,\n         })\n     }\n \n@@ -1033,22 +1031,19 @@ impl FilePathMapping {\n \n     fn map_filename_prefix(&self, file: &FileName) -> (FileName, bool) {\n         match file {\n-            FileName::Real(realfile) => {\n-                if let RealFileName::LocalPath(local_path) = realfile {\n-                    let (mapped_path, mapped) = self.map_prefix(local_path.to_path_buf());\n-                    let realfile = if mapped {\n-                        RealFileName::Remapped {\n-                            local_path: Some(local_path.clone()),\n-                            virtual_name: mapped_path,\n-                        }\n-                    } else {\n-                        realfile.clone()\n-                    };\n-                    (FileName::Real(realfile), mapped)\n+            FileName::Real(realfile) if let RealFileName::LocalPath(local_path) = realfile => {\n+                let (mapped_path, mapped) = self.map_prefix(local_path.to_path_buf());\n+                let realfile = if mapped {\n+                    RealFileName::Remapped {\n+                        local_path: Some(local_path.clone()),\n+                        virtual_name: mapped_path,\n+                    }\n                 } else {\n-                    unreachable!(\"attempted to remap an already remapped filename\");\n-                }\n+                    realfile.clone()\n+                };\n+                (FileName::Real(realfile), mapped)\n             }\n+            FileName::Real(_) => unreachable!(\"attempted to remap an already remapped filename\"),\n             other => (other.clone(), false),\n         }\n     }"}, {"sha": "606fd2812ecc7ccc1ee3032fd4dcc5dedfc744c2", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -2380,12 +2380,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             if let Some(i) = (param.index as usize).checked_sub(generics.parent_count) {\n                 // Our own parameters are the resolved lifetimes.\n                 match param.kind {\n-                    GenericParamDefKind::Lifetime => {\n-                        if let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] {\n-                            self.ast_region_to_region(lifetime, None).into()\n-                        } else {\n-                            bug!()\n-                        }\n+                    GenericParamDefKind::Lifetime\n+                        if let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] =>\n+                    {\n+                        self.ast_region_to_region(lifetime, None).into()\n                     }\n                     _ => bug!(),\n                 }"}, {"sha": "dc0d8c0aeff2cf21f51ed7959085ac4a25bfff50", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -1178,12 +1178,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut user_self_ty = None;\n         let mut is_alias_variant_ctor = false;\n         match res {\n-            Res::Def(DefKind::Ctor(CtorOf::Variant, _), _) => {\n-                if let Some(self_ty) = self_ty {\n-                    let adt_def = self_ty.ty_adt_def().unwrap();\n-                    user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did, self_ty });\n-                    is_alias_variant_ctor = true;\n-                }\n+            Res::Def(DefKind::Ctor(CtorOf::Variant, _), _)\n+                if let Some(self_ty) = self_ty =>\n+            {\n+                let adt_def = self_ty.ty_adt_def().unwrap();\n+                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did, self_ty });\n+                is_alias_variant_ctor = true;\n             }\n             Res::Def(DefKind::AssocFn | DefKind::AssocConst, def_id) => {\n                 let container = tcx.associated_item(def_id).container;"}, {"sha": "1c7d68a3d57d4325120a0586c07af81d385d9a64", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -616,32 +616,30 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let lang_items = self.tcx.lang_items();\n \n         match *self_ty.value.value.kind() {\n-            ty::Dynamic(ref data, ..) => {\n-                if let Some(p) = data.principal() {\n-                    // Subtle: we can't use `instantiate_query_response` here: using it will\n-                    // commit to all of the type equalities assumed by inference going through\n-                    // autoderef (see the `method-probe-no-guessing` test).\n-                    //\n-                    // However, in this code, it is OK if we end up with an object type that is\n-                    // \"more general\" than the object type that we are evaluating. For *every*\n-                    // object type `MY_OBJECT`, a function call that goes through a trait-ref\n-                    // of the form `<MY_OBJECT as SuperTraitOf(MY_OBJECT)>::func` is a valid\n-                    // `ObjectCandidate`, and it should be discoverable \"exactly\" through one\n-                    // of the iterations in the autoderef loop, so there is no problem with it\n-                    // being discoverable in another one of these iterations.\n-                    //\n-                    // Using `instantiate_canonical_with_fresh_inference_vars` on our\n-                    // `Canonical<QueryResponse<Ty<'tcx>>>` and then *throwing away* the\n-                    // `CanonicalVarValues` will exactly give us such a generalization - it\n-                    // will still match the original object type, but it won't pollute our\n-                    // type variables in any form, so just do that!\n-                    let (QueryResponse { value: generalized_self_ty, .. }, _ignored_var_values) =\n-                        self.fcx\n-                            .instantiate_canonical_with_fresh_inference_vars(self.span, &self_ty);\n-\n-                    self.assemble_inherent_candidates_from_object(generalized_self_ty);\n-                    self.assemble_inherent_impl_candidates_for_type(p.def_id());\n-                }\n+            ty::Dynamic(ref data, ..) if let Some(p) = data.principal() => {\n+                // Subtle: we can't use `instantiate_query_response` here: using it will\n+                // commit to all of the type equalities assumed by inference going through\n+                // autoderef (see the `method-probe-no-guessing` test).\n+                //\n+                // However, in this code, it is OK if we end up with an object type that is\n+                // \"more general\" than the object type that we are evaluating. For *every*\n+                // object type `MY_OBJECT`, a function call that goes through a trait-ref\n+                // of the form `<MY_OBJECT as SuperTraitOf(MY_OBJECT)>::func` is a valid\n+                // `ObjectCandidate`, and it should be discoverable \"exactly\" through one\n+                // of the iterations in the autoderef loop, so there is no problem with it\n+                // being discoverable in another one of these iterations.\n+                //\n+                // Using `instantiate_canonical_with_fresh_inference_vars` on our\n+                // `Canonical<QueryResponse<Ty<'tcx>>>` and then *throwing away* the\n+                // `CanonicalVarValues` will exactly give us such a generalization - it\n+                // will still match the original object type, but it won't pollute our\n+                // type variables in any form, so just do that!\n+                let (QueryResponse { value: generalized_self_ty, .. }, _ignored_var_values) =\n+                    self.fcx\n+                        .instantiate_canonical_with_fresh_inference_vars(self.span, &self_ty);\n+\n+                self.assemble_inherent_candidates_from_object(generalized_self_ty);\n+                self.assemble_inherent_impl_candidates_for_type(p.def_id());\n             }\n             ty::Adt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);"}, {"sha": "392262628c0c6f27b8b4789018f2b890e387a673", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -627,15 +627,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let binding_parent = tcx.hir().get(binding_parent_id);\n             debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n             match binding_parent {\n-                hir::Node::Param(hir::Param { span, .. }) => {\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n-                        err.span_suggestion(\n-                            *span,\n-                            &format!(\"did you mean `{}`\", snippet),\n-                            format!(\" &{}\", expected),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                hir::Node::Param(hir::Param { span, .. })\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) =>\n+                {\n+                    err.span_suggestion(\n+                        *span,\n+                        &format!(\"did you mean `{}`\", snippet),\n+                        format!(\" &{}\", expected),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n                 hir::Node::Arm(_) | hir::Node::Pat(_) => {\n                     // rely on match ergonomics or it might be nested `&&pat`\n@@ -1293,13 +1293,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (Some(mut err), None) => {\n                 err.emit();\n             }\n-            (None, None) => {\n-                if let Some(mut err) =\n-                    self.error_tuple_variant_index_shorthand(variant, pat, fields)\n-                {\n-                    err.emit();\n-                }\n+            (None, None) if let Some(mut err) =\n+                    self.error_tuple_variant_index_shorthand(variant, pat, fields) =>\n+            {\n+                err.emit();\n             }\n+            (None, None) => {}\n         }\n         no_field_errors\n     }"}, {"sha": "632b9492ee43adf9b2d799dc57010691138c9869", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -1049,26 +1049,24 @@ fn check_opaque_types<'fcx, 'tcx>(\n                     let arg_is_param = match arg.unpack() {\n                         GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n \n-                        GenericArgKind::Lifetime(region) => {\n-                            if let ty::ReStatic = region {\n-                                tcx.sess\n-                                    .struct_span_err(\n-                                        span,\n-                                        \"non-defining opaque type use in defining scope\",\n-                                    )\n-                                    .span_label(\n-                                        tcx.def_span(generics.param_at(i, tcx).def_id),\n-                                        \"cannot use static lifetime; use a bound lifetime \\\n-                                                 instead or remove the lifetime parameter from the \\\n-                                                 opaque type\",\n-                                    )\n-                                    .emit();\n-                                continue;\n-                            }\n-\n-                            true\n+                        GenericArgKind::Lifetime(region) if let ty::ReStatic = region => {\n+                            tcx.sess\n+                                .struct_span_err(\n+                                    span,\n+                                    \"non-defining opaque type use in defining scope\",\n+                                )\n+                                .span_label(\n+                                    tcx.def_span(generics.param_at(i, tcx).def_id),\n+                                    \"cannot use static lifetime; use a bound lifetime \\\n+                                                instead or remove the lifetime parameter from the \\\n+                                                opaque type\",\n+                                )\n+                                .emit();\n+                            continue;\n                         }\n \n+                        GenericArgKind::Lifetime(_) => true,\n+\n                         GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n                     };\n "}, {"sha": "2e59defdb7ba04e86275b8e68ba3136dfb9a2381", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -175,10 +175,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                                 }\n                             }\n                         }\n-                        hir::ExprKind::AssignOp(..) => {\n-                            if let Some(a) = typeck_results.adjustments_mut().get_mut(lhs.hir_id) {\n-                                a.pop();\n-                            }\n+                        hir::ExprKind::AssignOp(..)\n+                            if let Some(a) = typeck_results.adjustments_mut().get_mut(lhs.hir_id) =>\n+                        {\n+                            a.pop();\n                         }\n                         _ => {}\n                     }"}, {"sha": "4048a54b58c9886ad923286f34ba1f9500e8f11d", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -446,13 +446,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         }\n \n-        Node::AnonConst(_) => {\n-            if let Some(param) = tcx.opt_const_param_of(def_id) {\n-                // We defer to `type_of` of the corresponding parameter\n-                // for generic arguments.\n-                return tcx.type_of(param);\n-            }\n+        Node::AnonConst(_) if let Some(param) = tcx.opt_const_param_of(def_id) => {\n+            // We defer to `type_of` of the corresponding parameter\n+            // for generic arguments.\n+            tcx.type_of(param)\n+        }\n \n+        Node::AnonConst(_) => {\n             let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n             match parent_node {\n                 Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })"}, {"sha": "638a46fec36f4ac4afd1b27a2d466a3fab7f6026", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -60,6 +60,7 @@ This API is completely unstable and subject to change.\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(format_args_capture)]\n+#![feature(if_let_guard)]\n #![feature(in_band_lifetimes)]\n #![feature(is_sorted)]\n #![feature(iter_zip)]\n@@ -68,6 +69,7 @@ This API is completely unstable and subject to change.\n #![feature(never_type)]\n #![feature(slice_partition_dedup)]\n #![feature(control_flow_enum)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "1a6d1aed2fd1edea75668e17f86fabb92962b917", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -69,6 +69,7 @@\n #![warn(missing_debug_implementations)]\n #![warn(missing_docs)]\n #![allow(explicit_outlives_requirements)]\n+#![cfg_attr(bootstrap, allow(incomplete_features))] // if_let_guard\n //\n // Library features for const fns:\n #![feature(const_align_of_val)]\n@@ -134,6 +135,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(extern_types)]\n #![feature(fundamental)]\n+#![feature(if_let_guard)]\n #![feature(intra_doc_pointers)]\n #![feature(intrinsics)]\n #![feature(lang_items)]"}, {"sha": "2b280773e4c50a2f64abbf7fa8a0386d067b2d7c", "filename": "library/core/src/num/dec2flt/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde1b76b4b1d0d84f5691f4785906b31bb91f38d/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs?ref=fde1b76b4b1d0d84f5691f4785906b31bb91f38d", "patch": "@@ -236,13 +236,8 @@ pub fn dec2flt<F: RawFloat>(s: &str) -> Result<F, ParseFloatError> {\n \n     let num = match parse_number(s, negative) {\n         Some(r) => r,\n-        None => {\n-            if let Some(value) = parse_inf_nan(s, negative) {\n-                return Ok(value);\n-            } else {\n-                return Err(pfe_invalid());\n-            }\n-        }\n+        None if let Some(value) = parse_inf_nan(s, negative) => return Ok(value),\n+        None => return Err(pfe_invalid()),\n     };\n     if let Some(value) = num.try_fast_path::<F>() {\n         return Ok(value);"}]}