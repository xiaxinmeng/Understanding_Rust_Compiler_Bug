{"sha": "b43e8e248bfba9e8d26821c6d98deba94d024abf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0M2U4ZTI0OGJmYmE5ZThkMjY4MjFjNmQ5OGRlYmE5NGQwMjRhYmY=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-11T05:34:28Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-04-13T16:48:58Z"}, "message": "BufWriter: avoid using expensive Vec methods\n\nWe use a Vec as our internal, constant-sized buffer, but the overhead of\nusing methods like `extend_from_slice` can be enormous, likely because\nthey don't get inlined, because `Vec` has to repeat bounds checks that\nwe've already done, and because it makes considerations for things like\nreallocating, even though they should never happen.", "tree": {"sha": "76130daddcbd70a984407876a414aa1e2bdaf502", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76130daddcbd70a984407876a414aa1e2bdaf502"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b43e8e248bfba9e8d26821c6d98deba94d024abf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b43e8e248bfba9e8d26821c6d98deba94d024abf", "html_url": "https://github.com/rust-lang/rust/commit/b43e8e248bfba9e8d26821c6d98deba94d024abf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b43e8e248bfba9e8d26821c6d98deba94d024abf/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f32d40ac3c51d6867fc6969e52e960452a40652", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f32d40ac3c51d6867fc6969e52e960452a40652", "html_url": "https://github.com/rust-lang/rust/commit/1f32d40ac3c51d6867fc6969e52e960452a40652"}], "stats": {"total": 87, "additions": 75, "deletions": 12}, "files": [{"sha": "3272826d77c25366292cc19eff933b981e98d6f4", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 75, "deletions": 12, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b43e8e248bfba9e8d26821c6d98deba94d024abf/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b43e8e248bfba9e8d26821c6d98deba94d024abf/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=b43e8e248bfba9e8d26821c6d98deba94d024abf", "patch": "@@ -4,6 +4,7 @@ use crate::io::{\n     self, Error, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n };\n use crate::mem;\n+use crate::ptr;\n \n /// Wraps a writer and buffers its output.\n ///\n@@ -68,6 +69,10 @@ use crate::mem;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W: Write> {\n     inner: Option<W>,\n+    // The buffer. Avoid using this like a normal `Vec` in common code paths.\n+    // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n+    // methods that require bounds checking or the like. This makes an enormous\n+    // difference to performance (we may want to stop using a `Vec` entirely).\n     buf: Vec<u8>,\n     // #30888: If the inner writer panics in a call to write, we don't want to\n     // write the buffered data a second time in BufWriter's destructor. This\n@@ -150,7 +155,11 @@ impl<W: Write> BufWriter<W> {\n         impl Drop for BufGuard<'_> {\n             fn drop(&mut self) {\n                 if self.written > 0 {\n-                    self.buffer.drain(..self.written);\n+                    if self.done() {\n+                        self.buffer.clear();\n+                    } else {\n+                        self.buffer.drain(..self.written);\n+                    }\n                 }\n             }\n         }\n@@ -183,7 +192,12 @@ impl<W: Write> BufWriter<W> {\n     pub(super) fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n         let available = self.buf.capacity() - self.buf.len();\n         let amt_to_buffer = available.min(buf.len());\n-        self.buf.extend_from_slice(&buf[..amt_to_buffer]);\n+\n+        // SAFETY: `amt_to_buffer` is <= buffer's spare capacity by construction.\n+        unsafe {\n+            self.write_to_buffer_unchecked(&buf[..amt_to_buffer]);\n+        }\n+\n         amt_to_buffer\n     }\n \n@@ -348,7 +362,13 @@ impl<W: Write> BufWriter<W> {\n             self.panicked = false;\n             r\n         } else {\n-            self.buf.extend_from_slice(buf);\n+            // SAFETY: We just called `self.flush_buf()`, so `self.buf.len()` is 0, and\n+            // we entered this else block because `buf.len() < self.buf.capacity()`.\n+            // Therefore, `self.buf.len() + buf.len() <= self.buf.capacity()`.\n+            unsafe {\n+                self.write_to_buffer_unchecked(buf);\n+            }\n+\n             Ok(buf.len())\n         }\n     }\n@@ -373,10 +393,29 @@ impl<W: Write> BufWriter<W> {\n             self.panicked = false;\n             r\n         } else {\n-            self.buf.extend_from_slice(buf);\n+            // SAFETY: We just called `self.flush_buf()`, so `self.buf.len()` is 0, and\n+            // we entered this else block because `buf.len() < self.buf.capacity()`.\n+            // Therefore, `self.buf.len() + buf.len() <= self.buf.capacity()`.\n+            unsafe {\n+                self.write_to_buffer_unchecked(buf);\n+            }\n+\n             Ok(())\n         }\n     }\n+\n+    // SAFETY: Requires `self.buf.len() + buf.len() <= self.buf.capacity()`,\n+    // i.e., that input buffer length is less than or equal to spare capacity.\n+    #[inline(always)]\n+    unsafe fn write_to_buffer_unchecked(&mut self, buf: &[u8]) {\n+        debug_assert!(self.buf.len() + buf.len() <= self.buf.capacity());\n+        let old_len = self.buf.len();\n+        let buf_len = buf.len();\n+        let src = buf.as_ptr();\n+        let dst = self.buf.as_mut_ptr().add(old_len);\n+        ptr::copy_nonoverlapping(src, dst, buf_len);\n+        self.buf.set_len(old_len + buf_len);\n+    }\n }\n \n #[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n@@ -456,7 +495,11 @@ impl<W: Write> Write for BufWriter<W> {\n         // prevents pathological cases for other clients which *always* make writes of this size.\n         // See #72919 and #79930 for more info and a breadcrumb trail.\n         if self.buf.len() + buf.len() <= self.buf.capacity() && buf.len() != self.buf.capacity() {\n-            self.buf.extend_from_slice(buf);\n+            // SAFETY: safe by above conditional.\n+            unsafe {\n+                self.write_to_buffer_unchecked(buf);\n+            }\n+\n             Ok(buf.len())\n         } else {\n             self.flush_and_write(buf)\n@@ -471,7 +514,11 @@ impl<W: Write> Write for BufWriter<W> {\n         // prevents pathological cases for other clients which *always* make writes of this size.\n         // See #72919 and #79930 for more info and a breadcrumb trail.\n         if self.buf.len() + buf.len() <= self.buf.capacity() && buf.len() != self.buf.capacity() {\n-            self.buf.extend_from_slice(buf);\n+            // SAFETY: safe by above conditional.\n+            unsafe {\n+                self.write_to_buffer_unchecked(buf);\n+            }\n+\n             Ok(())\n         } else {\n             self.flush_and_write_all(buf)\n@@ -492,7 +539,13 @@ impl<W: Write> Write for BufWriter<W> {\n                 self.panicked = false;\n                 r\n             } else {\n-                bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n+                // SAFETY: We checked whether or not the spare capacity was large enough above. If\n+                // it was, then we're safe already. If it wasn't, we flushed, making sufficient\n+                // room for any input <= the buffer size, which includes this input.\n+                unsafe {\n+                    bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));\n+                };\n+\n                 Ok(total_len)\n             }\n         } else {\n@@ -511,19 +564,29 @@ impl<W: Write> Write for BufWriter<W> {\n                     self.panicked = false;\n                     return r;\n                 } else {\n-                    self.buf.extend_from_slice(buf);\n+                    // SAFETY: We checked whether or not the spare capacity was large enough above.\n+                    // If it was, then we're safe already. If it wasn't, we flushed, making\n+                    // sufficient room for any input <= the buffer size, which includes this input.\n+                    unsafe {\n+                        self.write_to_buffer_unchecked(buf);\n+                    }\n+\n                     buf.len()\n                 }\n             } else {\n                 return Ok(0);\n             };\n             debug_assert!(total_written != 0);\n             for buf in iter {\n-                if self.buf.len() + buf.len() > self.buf.capacity() {\n-                    break;\n-                } else {\n-                    self.buf.extend_from_slice(buf);\n+                if self.buf.len() + buf.len() <= self.buf.capacity() {\n+                    // SAFETY: safe by above conditional.\n+                    unsafe {\n+                        self.write_to_buffer_unchecked(buf);\n+                    }\n+\n                     total_written += buf.len();\n+                } else {\n+                    break;\n                 }\n             }\n             Ok(total_written)"}]}