{"sha": "73f40197ecabf77ed59028af61739404eb60dd2e", "node_id": "C_kwDOAAsO6NoAKDczZjQwMTk3ZWNhYmY3N2VkNTkwMjhhZjYxNzM5NDA0ZWI2MGRkMmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-19T05:35:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-19T05:35:03Z"}, "message": "Auto merge of #107772 - compiler-errors:dyn-star-backend-is-ptr, r=eholk\n\nMake `dyn*`'s value backend type a pointer\n\nOne tweak on top of Ralf's commit should fix using `usize` as a `dyn*`-coercible type, and should fix when we're using various other pointer types when LLVM opaque pointers is disabled.\n\nr? `@eholk` but feel free to reassign\ncc https://github.com/rust-lang/rust/pull/107728#issuecomment-1421231823 `@RalfJung`", "tree": {"sha": "d85c5175b2c1b33af686cef847865a64be4eea77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d85c5175b2c1b33af686cef847865a64be4eea77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73f40197ecabf77ed59028af61739404eb60dd2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73f40197ecabf77ed59028af61739404eb60dd2e", "html_url": "https://github.com/rust-lang/rust/commit/73f40197ecabf77ed59028af61739404eb60dd2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73f40197ecabf77ed59028af61739404eb60dd2e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9", "html_url": "https://github.com/rust-lang/rust/commit/fcdbd1c07f0b6c8e7d8bbd727c6ca69a1af8c7e9"}, {"sha": "7f798c2b216db0bb7ebeb9dd863fbdf7668094c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f798c2b216db0bb7ebeb9dd863fbdf7668094c5", "html_url": "https://github.com/rust-lang/rust/commit/7f798c2b216db0bb7ebeb9dd863fbdf7668094c5"}], "stats": {"total": 224, "additions": 129, "deletions": 95}, "files": [{"sha": "9cda24bab87d345820ee7ec1e62227062d180a87", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=73f40197ecabf77ed59028af61739404eb60dd2e", "patch": "@@ -329,7 +329,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     ) -> &'a Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n-        match self.ty.kind() {\n+        match *self.ty.kind() {\n             ty::Ref(..) | ty::RawPtr(_) => {\n                 return self.field(cx, index).llvm_type(cx);\n             }\n@@ -339,6 +339,11 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n                 let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n                 return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index, immediate);\n             }\n+            // `dyn* Trait` has the same ABI as `*mut dyn Trait`\n+            ty::Dynamic(bounds, region, ty::DynStar) => {\n+                let ptr_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_dynamic(bounds, region, ty::Dyn));\n+                return cx.layout_of(ptr_ty).scalar_pair_element_llvm_type(cx, index, immediate);\n+            }\n             _ => {}\n         }\n "}, {"sha": "4e13d4dbcb7a4dbdbcf260218026ab762a222beb", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=73f40197ecabf77ed59028af61739404eb60dd2e", "patch": "@@ -39,7 +39,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n-use rustc_target::abi::{Align, Size, VariantIdx};\n+use rustc_target::abi::{Align, VariantIdx};\n \n use std::collections::BTreeSet;\n use std::time::{Duration, Instant};\n@@ -273,12 +273,13 @@ pub fn cast_to_dyn_star<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         matches!(dst_ty.kind(), ty::Dynamic(_, _, ty::DynStar)),\n         \"destination type must be a dyn*\"\n     );\n-    // FIXME(dyn-star): this is probably not the best way to check if this is\n-    // a pointer, and really we should ensure that the value is a suitable\n-    // pointer earlier in the compilation process.\n-    let src = match src_ty_and_layout.pointee_info_at(bx.cx(), Size::ZERO) {\n-        Some(_) => bx.ptrtoint(src, bx.cx().type_isize()),\n-        None => bx.bitcast(src, bx.type_isize()),\n+    // FIXME(dyn-star): We can remove this when all supported LLVMs use opaque ptrs only.\n+    let unit_ptr = bx.cx().type_ptr_to(bx.cx().type_struct(&[], false));\n+    let src = match bx.cx().type_kind(bx.cx().backend_type(src_ty_and_layout)) {\n+        TypeKind::Pointer => bx.pointercast(src, unit_ptr),\n+        TypeKind::Integer => bx.inttoptr(src, unit_ptr),\n+        // FIXME(dyn-star): We probably have to do a bitcast first, then inttoptr.\n+        kind => bug!(\"unexpected TypeKind for left-hand side of `dyn*` cast: {kind:?}\"),\n     };\n     (src, unsized_info(bx, src_ty_and_layout.ty, dst_ty, old_info))\n }"}, {"sha": "daaa4de1a7c8eb0e00a5d0f8248984d6bccdc31e", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 78, "deletions": 80, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=73f40197ecabf77ed59028af61739404eb60dd2e", "patch": "@@ -452,86 +452,84 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             args1 = [place.llval];\n             &args1[..]\n         };\n-        let (drop_fn, fn_abi) = match ty.kind() {\n-            // FIXME(eddyb) perhaps move some of this logic into\n-            // `Instance::resolve_drop_in_place`?\n-            ty::Dynamic(_, _, ty::Dyn) => {\n-                // IN THIS ARM, WE HAVE:\n-                // ty = *mut (dyn Trait)\n-                // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n-                //                       args[0]    args[1]\n-                //\n-                // args = ( Data, Vtable )\n-                //                  |\n-                //                  v\n-                //                /-------\\\n-                //                | ...   |\n-                //                \\-------/\n-                //\n-                let virtual_drop = Instance {\n-                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n-                    substs: drop_fn.substs,\n-                };\n-                debug!(\"ty = {:?}\", ty);\n-                debug!(\"drop_fn = {:?}\", drop_fn);\n-                debug!(\"args = {:?}\", args);\n-                let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n-                let vtable = args[1];\n-                // Truncate vtable off of args list\n-                args = &args[..1];\n-                (\n-                    meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(bx, vtable, ty, &fn_abi),\n-                    fn_abi,\n-                )\n-            }\n-            ty::Dynamic(_, _, ty::DynStar) => {\n-                // IN THIS ARM, WE HAVE:\n-                // ty = *mut (dyn* Trait)\n-                // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n-                //\n-                // args = [ * ]\n-                //          |\n-                //          v\n-                //      ( Data, Vtable )\n-                //                |\n-                //                v\n-                //              /-------\\\n-                //              | ...   |\n-                //              \\-------/\n-                //\n-                //\n-                // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n-                //\n-                // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n-                // vtable = (*args[0]).1   // loads the vtable out\n-                // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n-                //\n-                // SO THEN WE CAN USE THE ABOVE CODE.\n-                let virtual_drop = Instance {\n-                    def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n-                    substs: drop_fn.substs,\n-                };\n-                debug!(\"ty = {:?}\", ty);\n-                debug!(\"drop_fn = {:?}\", drop_fn);\n-                debug!(\"args = {:?}\", args);\n-                let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n-                let data = args[0];\n-                let data_ty = bx.cx().backend_type(place.layout);\n-                let vtable_ptr =\n-                    bx.gep(data_ty, data, &[bx.cx().const_i32(0), bx.cx().const_i32(1)]);\n-                let vtable = bx.load(bx.type_i8p(), vtable_ptr, abi::Align::ONE);\n-                // Truncate vtable off of args list\n-                args = &args[..1];\n-                debug!(\"args' = {:?}\", args);\n-                (\n-                    meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(bx, vtable, ty, &fn_abi),\n-                    fn_abi,\n-                )\n-            }\n-            _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n-        };\n+        let (drop_fn, fn_abi) =\n+            match ty.kind() {\n+                // FIXME(eddyb) perhaps move some of this logic into\n+                // `Instance::resolve_drop_in_place`?\n+                ty::Dynamic(_, _, ty::Dyn) => {\n+                    // IN THIS ARM, WE HAVE:\n+                    // ty = *mut (dyn Trait)\n+                    // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n+                    //                       args[0]    args[1]\n+                    //\n+                    // args = ( Data, Vtable )\n+                    //                  |\n+                    //                  v\n+                    //                /-------\\\n+                    //                | ...   |\n+                    //                \\-------/\n+                    //\n+                    let virtual_drop = Instance {\n+                        def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                        substs: drop_fn.substs,\n+                    };\n+                    debug!(\"ty = {:?}\", ty);\n+                    debug!(\"drop_fn = {:?}\", drop_fn);\n+                    debug!(\"args = {:?}\", args);\n+                    let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n+                    let vtable = args[1];\n+                    // Truncate vtable off of args list\n+                    args = &args[..1];\n+                    (\n+                        meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n+                            .get_fn(bx, vtable, ty, &fn_abi),\n+                        fn_abi,\n+                    )\n+                }\n+                ty::Dynamic(_, _, ty::DynStar) => {\n+                    // IN THIS ARM, WE HAVE:\n+                    // ty = *mut (dyn* Trait)\n+                    // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n+                    //\n+                    // args = [ * ]\n+                    //          |\n+                    //          v\n+                    //      ( Data, Vtable )\n+                    //                |\n+                    //                v\n+                    //              /-------\\\n+                    //              | ...   |\n+                    //              \\-------/\n+                    //\n+                    //\n+                    // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n+                    //\n+                    // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n+                    // vtable = (*args[0]).1   // loads the vtable out\n+                    // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n+                    //\n+                    // SO THEN WE CAN USE THE ABOVE CODE.\n+                    let virtual_drop = Instance {\n+                        def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n+                        substs: drop_fn.substs,\n+                    };\n+                    debug!(\"ty = {:?}\", ty);\n+                    debug!(\"drop_fn = {:?}\", drop_fn);\n+                    debug!(\"args = {:?}\", args);\n+                    let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n+                    let meta_ptr = place.project_field(bx, 1);\n+                    let meta = bx.load_operand(meta_ptr);\n+                    // Truncate vtable off of args list\n+                    args = &args[..1];\n+                    debug!(\"args' = {:?}\", args);\n+                    (\n+                        meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n+                            .get_fn(bx, meta.immediate(), ty, &fn_abi),\n+                        fn_abi,\n+                    )\n+                }\n+                _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n+            };\n         helper.do_call(\n             self,\n             bx,"}, {"sha": "993191ee96a446f8ad02652c707fa0dc84fc5414", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=73f40197ecabf77ed59028af61739404eb60dd2e", "patch": "@@ -770,7 +770,7 @@ where\n \n                 ty::Dynamic(_, _, ty::DynStar) => {\n                     if i == 0 {\n-                        TyMaybeWithLayout::Ty(tcx.types.usize)\n+                        TyMaybeWithLayout::Ty(tcx.mk_mut_ptr(tcx.types.unit))\n                     } else if i == 1 {\n                         // FIXME(dyn-star) same FIXME as above applies here too\n                         TyMaybeWithLayout::Ty("}, {"sha": "1a62794b0b441b471192f0fb6229f43c45698e25", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=73f40197ecabf77ed59028af61739404eb60dd2e", "patch": "@@ -193,7 +193,7 @@ fn layout_of_uncached<'tcx>(\n         }\n \n         ty::Dynamic(_, _, ty::DynStar) => {\n-            let mut data = scalar_unit(Int(dl.ptr_sized_integer(), false));\n+            let mut data = scalar_unit(Pointer(AddressSpace::DATA));\n             data.valid_range_mut().start = 0;\n             let mut vtable = scalar_unit(Pointer(AddressSpace::DATA));\n             vtable.valid_range_mut().start = 1;"}, {"sha": "ebe2b76aef335e5bf2c5a9948ece67e49d417ebf", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f40197ecabf77ed59028af61739404eb60dd2e/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=73f40197ecabf77ed59028af61739404eb60dd2e", "patch": "@@ -26,11 +26,9 @@ pub enum DynKind {\n     Dyn,\n     /// A sized `dyn* Trait` object\n     ///\n-    /// These objects are represented as a `(data, vtable)` pair where `data` is a ptr-sized value\n-    /// (often a pointer to the real object, but not necessarily) and `vtable` is a pointer to\n-    /// the vtable for `dyn* Trait`. The representation is essentially the same as `&dyn Trait`\n-    /// or similar, but the drop function included in the vtable is responsible for freeing the\n-    /// underlying storage if needed. This allows a `dyn*` object to be treated agnostically with\n+    /// These objects are represented as a `(data, vtable)` pair where `data` is a value of some\n+    /// ptr-sized and ptr-aligned dynamically determined type `T` and `vtable` is a pointer to the\n+    /// vtable of `impl T for Trait`. This allows a `dyn*` object to be treated agnostically with\n     /// respect to whether it points to a `Box<T>`, `Rc<T>`, etc.\n     DynStar,\n }"}, {"sha": "d6f019016a5a7a7959be2497395c47f3928aa3eb", "filename": "tests/codegen/function-arguments.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73f40197ecabf77ed59028af61739404eb60dd2e/tests%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f40197ecabf77ed59028af61739404eb60dd2e/tests%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments.rs?ref=73f40197ecabf77ed59028af61739404eb60dd2e", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: -O -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(dyn_star)]\n \n use std::mem::MaybeUninit;\n use std::num::NonZeroU64;\n@@ -279,3 +280,11 @@ pub fn enum_id_1(x: Option<Result<u16, u16>>) -> Option<Result<u16, u16>> {\n pub fn enum_id_2(x: Option<u8>) -> Option<u8> {\n   x\n }\n+\n+// CHECK: { {{\\{\\}\\*|ptr}}, {{.+}} } @dyn_star({{\\{\\}\\*|ptr}} noundef %x.0, {{.+}} noalias noundef readonly align {{.*}} dereferenceable({{.*}}) %x.1)\n+// Expect an ABI something like `{ {}*, [3 x i64]* }`, but that's hard to match on generically,\n+// so do like the `trait_box` test and just match on `{{.+}}` for the vtable.\n+#[no_mangle]\n+pub fn dyn_star(x: dyn* Drop) -> dyn* Drop {\n+  x\n+}"}, {"sha": "d35519632becf0ea033c086c2c4c9ebe754f3bcd", "filename": "tests/ui/dyn-star/llvm-old-style-ptrs.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/73f40197ecabf77ed59028af61739404eb60dd2e/tests%2Fui%2Fdyn-star%2Fllvm-old-style-ptrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f40197ecabf77ed59028af61739404eb60dd2e/tests%2Fui%2Fdyn-star%2Fllvm-old-style-ptrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fllvm-old-style-ptrs.rs?ref=73f40197ecabf77ed59028af61739404eb60dd2e", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+// compile-flags: -Copt-level=0 -Cllvm-args=-opaque-pointers=0\n+\n+// (opaque-pointers flag is called force-opaque-pointers in LLVM 13...)\n+// min-llvm-version: 14.0\n+\n+// This test can be removed once non-opaque pointers are gone from LLVM, maybe.\n+\n+#![feature(dyn_star, pointer_like_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n+use std::marker::PointerLike;\n+\n+fn make_dyn_star<'a>(t: impl PointerLike + Debug + 'a) -> dyn* Debug + 'a {\n+    t as _\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", make_dyn_star(Box::new(1i32)));\n+    println!(\"{:?}\", make_dyn_star(2usize));\n+    println!(\"{:?}\", make_dyn_star((3usize,)));\n+}"}]}