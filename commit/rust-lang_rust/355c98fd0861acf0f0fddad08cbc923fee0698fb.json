{"sha": "355c98fd0861acf0f0fddad08cbc923fee0698fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NWM5OGZkMDg2MWFjZjBmMGZkZGFkMDhjYmM5MjNmZWUwNjk4ZmI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-06T14:08:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-06T14:10:17Z"}, "message": "Docs", "tree": {"sha": "ebd5e0cf6a9fa093afb5fa2a84675e19abb1ccf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebd5e0cf6a9fa093afb5fa2a84675e19abb1ccf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/355c98fd0861acf0f0fddad08cbc923fee0698fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/355c98fd0861acf0f0fddad08cbc923fee0698fb", "html_url": "https://github.com/rust-lang/rust/commit/355c98fd0861acf0f0fddad08cbc923fee0698fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/355c98fd0861acf0f0fddad08cbc923fee0698fb/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a39519e1cef6a11a418692a8ca1dc5131a80974", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a39519e1cef6a11a418692a8ca1dc5131a80974", "html_url": "https://github.com/rust-lang/rust/commit/8a39519e1cef6a11a418692a8ca1dc5131a80974"}], "stats": {"total": 159, "additions": 84, "deletions": 75}, "files": [{"sha": "4668784d3f13e46db5a1cf7974ed106a2947b04a", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=355c98fd0861acf0f0fddad08cbc923fee0698fb", "patch": "@@ -1,4 +1,5 @@\n-//! FIXME: write short doc here\n+//! Defines a unit of change that can applied to a state of IDE to get the next\n+//! state. Changes are transactional.\n \n use std::{fmt, sync::Arc, time};\n "}, {"sha": "1b3cabf4d95f570e0b461d0575b5c98c99db3e06", "filename": "crates/ra_ide_db/src/feature_flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Ffeature_flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Ffeature_flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Ffeature_flags.rs?ref=355c98fd0861acf0f0fddad08cbc923fee0698fb", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! See docs for `FeatureFlags`.\n \n use rustc_hash::FxHashMap;\n "}, {"sha": "435b06511663ff8653ba90fdfc36f2daff80c49d", "filename": "crates/ra_ide_db/src/line_index_utils.rs", "status": "modified", "additions": 79, "deletions": 72, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs?ref=355c98fd0861acf0f0fddad08cbc923fee0698fb", "patch": "@@ -1,10 +1,87 @@\n-//! FIXME: write short doc here\n+//! Code actions can specify desirable final position of the cursor.\n+//!\n+//! The position is specified as a `TextUnit` in the final file. We need to send\n+//! it in `(Line, Column)` coordinate though. However, we only have a LineIndex\n+//! for a file pre-edit!\n+//!\n+//! Code in this module applies this \"to (Line, Column) after edit\"\n+//! transformation.\n \n use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n \n use crate::line_index::{LineCol, LineIndex, Utf16Char};\n \n+pub fn translate_offset_with_edit(\n+    line_index: &LineIndex,\n+    offset: TextUnit,\n+    text_edit: &TextEdit,\n+) -> LineCol {\n+    let mut state = Edits::from_text_edit(&text_edit);\n+\n+    let mut res = RunningLineCol::new();\n+\n+    macro_rules! test_step {\n+        ($x:ident) => {\n+            match &$x {\n+                Step::Newline(n) => {\n+                    if offset < *n {\n+                        return res.to_line_col(offset);\n+                    } else {\n+                        res.add_line(*n);\n+                    }\n+                }\n+                Step::Utf16Char(x) => {\n+                    if offset < x.end() {\n+                        // if the offset is inside a multibyte char it's invalid\n+                        // clamp it to the start of the char\n+                        let clamp = offset.min(x.start());\n+                        return res.to_line_col(clamp);\n+                    } else {\n+                        res.adjust_col(*x);\n+                    }\n+                }\n+            }\n+        };\n+    }\n+\n+    for orig_step in LineIndexStepIter::from(line_index) {\n+        loop {\n+            let translated_step = state.translate_step(&orig_step);\n+            match state.next_steps(&translated_step) {\n+                NextSteps::Use => {\n+                    test_step!(translated_step);\n+                    break;\n+                }\n+                NextSteps::ReplaceMany(ns) => {\n+                    for n in ns {\n+                        test_step!(n);\n+                    }\n+                    break;\n+                }\n+                NextSteps::AddMany(ns) => {\n+                    for n in ns {\n+                        test_step!(n);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    loop {\n+        match state.next_inserted_steps() {\n+            None => break,\n+            Some(ns) => {\n+                for n in ns {\n+                    test_step!(n);\n+                }\n+            }\n+        }\n+    }\n+\n+    res.to_line_col(offset)\n+}\n+\n #[derive(Debug, Clone)]\n enum Step {\n     Newline(TextUnit),\n@@ -55,7 +132,7 @@ struct OffsetStepIter<'a> {\n     offset: TextUnit,\n }\n \n-impl<'a> Iterator for OffsetStepIter<'a> {\n+impl Iterator for OffsetStepIter<'_> {\n     type Item = Step;\n     fn next(&mut self) -> Option<Step> {\n         let (next, next_offset) = self\n@@ -221,76 +298,6 @@ impl RunningLineCol {\n     }\n }\n \n-pub fn translate_offset_with_edit(\n-    line_index: &LineIndex,\n-    offset: TextUnit,\n-    text_edit: &TextEdit,\n-) -> LineCol {\n-    let mut state = Edits::from_text_edit(&text_edit);\n-\n-    let mut res = RunningLineCol::new();\n-\n-    macro_rules! test_step {\n-        ($x:ident) => {\n-            match &$x {\n-                Step::Newline(n) => {\n-                    if offset < *n {\n-                        return res.to_line_col(offset);\n-                    } else {\n-                        res.add_line(*n);\n-                    }\n-                }\n-                Step::Utf16Char(x) => {\n-                    if offset < x.end() {\n-                        // if the offset is inside a multibyte char it's invalid\n-                        // clamp it to the start of the char\n-                        let clamp = offset.min(x.start());\n-                        return res.to_line_col(clamp);\n-                    } else {\n-                        res.adjust_col(*x);\n-                    }\n-                }\n-            }\n-        };\n-    }\n-\n-    for orig_step in LineIndexStepIter::from(line_index) {\n-        loop {\n-            let translated_step = state.translate_step(&orig_step);\n-            match state.next_steps(&translated_step) {\n-                NextSteps::Use => {\n-                    test_step!(translated_step);\n-                    break;\n-                }\n-                NextSteps::ReplaceMany(ns) => {\n-                    for n in ns {\n-                        test_step!(n);\n-                    }\n-                    break;\n-                }\n-                NextSteps::AddMany(ns) => {\n-                    for n in ns {\n-                        test_step!(n);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    loop {\n-        match state.next_inserted_steps() {\n-            None => break,\n-            Some(ns) => {\n-                for n in ns {\n-                    test_step!(n);\n-                }\n-            }\n-        }\n-    }\n-\n-    res.to_line_col(offset)\n-}\n-\n #[cfg(test)]\n mod test {\n     use proptest::{prelude::*, proptest};"}, {"sha": "64ddf2f95e2aca72e694265efeb07a9881ee58e6", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=355c98fd0861acf0f0fddad08cbc923fee0698fb", "patch": "@@ -19,6 +19,7 @@\n //! for each library (which is assumed to never change) and an FST for each Rust\n //! file in the current workspace, and run a query against the union of all\n //! those FSTs.\n+\n use std::{\n     fmt,\n     hash::{Hash, Hasher},"}, {"sha": "7af9f9d9bb7bdafcd852e474572a1aca06dcadd0", "filename": "crates/ra_ide_db/src/wasm_shims.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Fwasm_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/355c98fd0861acf0f0fddad08cbc923fee0698fb/crates%2Fra_ide_db%2Fsrc%2Fwasm_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fwasm_shims.rs?ref=355c98fd0861acf0f0fddad08cbc923fee0698fb", "patch": "@@ -1,4 +1,4 @@\n-//! FIXME: write short doc here\n+//! A version of `std::time::Instant` that doesn't panic in WASM.\n \n #[cfg(not(feature = \"wasm\"))]\n pub use std::time::Instant;"}]}